
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:30:47.807] plan(): Setting new future strategy stack:
[10:30:47.808] List of future strategies:
[10:30:47.808] 1. sequential:
[10:30:47.808]    - args: function (..., envir = parent.frame())
[10:30:47.808]    - tweaked: FALSE
[10:30:47.808]    - call: future::plan("sequential")
[10:30:47.823] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[10:30:47.832] plan(): Setting new future strategy stack:
[10:30:47.832] List of future strategies:
[10:30:47.832] 1. sequential:
[10:30:47.832]    - args: function (..., envir = parent.frame())
[10:30:47.832]    - tweaked: FALSE
[10:30:47.832]    - call: plan(sequential)
[10:30:47.842] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[10:30:47.843] future_mapply() ...
[10:30:47.844] Generating random seeds ...
[10:30:47.844] Generating random seed streams for 4 elements ...
[10:30:47.844] Generating random seed streams for 4 elements ... DONE
[10:30:47.844] Generating random seeds ... DONE
[10:30:47.844] Will set RNG state on exit: 10407, -1093314488, -1790265292, 1494356689, -1337045025, 873218515, 1713452462
[10:30:47.845] Number of chunks: 1
[10:30:47.845] getGlobalsAndPackagesXApply() ...
[10:30:47.845]  - future.globals: TRUE
[10:30:47.846] getGlobalsAndPackages() ...
[10:30:47.846] Searching for globals...
[10:30:47.852] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:30:47.852] Searching for globals ... DONE
[10:30:47.852] Resolving globals: FALSE
[10:30:47.853] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[10:30:47.854] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[10:30:47.854] - globals: [1] ‘FUN’
[10:30:47.854] - packages: [1] ‘stats’
[10:30:47.854] getGlobalsAndPackages() ... DONE
[10:30:47.854]  - globals found/used: [n=1] ‘FUN’
[10:30:47.854]  - needed namespaces: [n=1] ‘stats’
[10:30:47.854] Finding globals ... DONE
[10:30:47.855] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:47.855] List of 2
[10:30:47.855]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:30:47.855]  $ MoreArgs     :List of 1
[10:30:47.855]   ..$ min: num 1
[10:30:47.855]  - attr(*, "where")=List of 2
[10:30:47.855]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:47.855]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:47.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:47.855]  - attr(*, "resolved")= logi FALSE
[10:30:47.855]  - attr(*, "total_size")= num NA
[10:30:47.863] Packages to be attached in all futures: [n=1] ‘stats’
[10:30:47.863] getGlobalsAndPackagesXApply() ... DONE
[10:30:47.863] Number of futures (= number of chunks): 1
[10:30:47.863] Launching 1 futures (chunks) ...
[10:30:47.863] Chunk #1 of 1 ...
[10:30:47.864]  - Finding globals in '...' for chunk #1 ...
[10:30:47.864] getGlobalsAndPackages() ...
[10:30:47.864] Searching for globals...
[10:30:47.864] 
[10:30:47.864] Searching for globals ... DONE
[10:30:47.865] - globals: [0] <none>
[10:30:47.865] getGlobalsAndPackages() ... DONE
[10:30:47.865]    + additional globals found: [n=0] 
[10:30:47.865]    + additional namespaces needed: [n=0] 
[10:30:47.865]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:47.865]  - seeds: [4] <seeds>
[10:30:47.865]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:47.865] getGlobalsAndPackages() ...
[10:30:47.866] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:47.866] Resolving globals: FALSE
[10:30:47.866] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[10:30:47.867] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[10:30:47.867] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:47.867] - packages: [1] ‘stats’
[10:30:47.867] getGlobalsAndPackages() ... DONE
[10:30:47.868] run() for ‘Future’ ...
[10:30:47.868] - state: ‘created’
[10:30:47.868] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:47.868] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:47.869] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:47.869]   - Field: ‘label’
[10:30:47.869]   - Field: ‘local’
[10:30:47.869]   - Field: ‘owner’
[10:30:47.869]   - Field: ‘envir’
[10:30:47.869]   - Field: ‘packages’
[10:30:47.869]   - Field: ‘gc’
[10:30:47.869]   - Field: ‘conditions’
[10:30:47.869]   - Field: ‘expr’
[10:30:47.869]   - Field: ‘uuid’
[10:30:47.870]   - Field: ‘seed’
[10:30:47.870]   - Field: ‘version’
[10:30:47.870]   - Field: ‘result’
[10:30:47.870]   - Field: ‘asynchronous’
[10:30:47.870]   - Field: ‘calls’
[10:30:47.870]   - Field: ‘globals’
[10:30:47.870]   - Field: ‘stdout’
[10:30:47.870]   - Field: ‘earlySignal’
[10:30:47.870]   - Field: ‘lazy’
[10:30:47.870]   - Field: ‘state’
[10:30:47.870] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:47.871] - Launch lazy future ...
[10:30:47.871] Packages needed by the future expression (n = 1): ‘stats’
[10:30:47.871] Packages needed by future strategies (n = 0): <none>
[10:30:47.872] {
[10:30:47.872]     {
[10:30:47.872]         {
[10:30:47.872]             ...future.startTime <- base::Sys.time()
[10:30:47.872]             {
[10:30:47.872]                 {
[10:30:47.872]                   {
[10:30:47.872]                     {
[10:30:47.872]                       base::local({
[10:30:47.872]                         has_future <- base::requireNamespace("future", 
[10:30:47.872]                           quietly = TRUE)
[10:30:47.872]                         if (has_future) {
[10:30:47.872]                           ns <- base::getNamespace("future")
[10:30:47.872]                           version <- ns[[".package"]][["version"]]
[10:30:47.872]                           if (is.null(version)) 
[10:30:47.872]                             version <- utils::packageVersion("future")
[10:30:47.872]                         }
[10:30:47.872]                         else {
[10:30:47.872]                           version <- NULL
[10:30:47.872]                         }
[10:30:47.872]                         if (!has_future || version < "1.8.0") {
[10:30:47.872]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:47.872]                             "", base::R.version$version.string), 
[10:30:47.872]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:47.872]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:47.872]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:47.872]                               "release", "version")], collapse = " "), 
[10:30:47.872]                             hostname = base::Sys.info()[["nodename"]])
[10:30:47.872]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:47.872]                             info)
[10:30:47.872]                           info <- base::paste(info, collapse = "; ")
[10:30:47.872]                           if (!has_future) {
[10:30:47.872]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:47.872]                               info)
[10:30:47.872]                           }
[10:30:47.872]                           else {
[10:30:47.872]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:47.872]                               info, version)
[10:30:47.872]                           }
[10:30:47.872]                           base::stop(msg)
[10:30:47.872]                         }
[10:30:47.872]                       })
[10:30:47.872]                     }
[10:30:47.872]                     base::local({
[10:30:47.872]                       for (pkg in "stats") {
[10:30:47.872]                         base::loadNamespace(pkg)
[10:30:47.872]                         base::library(pkg, character.only = TRUE)
[10:30:47.872]                       }
[10:30:47.872]                     })
[10:30:47.872]                   }
[10:30:47.872]                   ...future.strategy.old <- future::plan("list")
[10:30:47.872]                   options(future.plan = NULL)
[10:30:47.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:47.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:47.872]                 }
[10:30:47.872]                 ...future.workdir <- getwd()
[10:30:47.872]             }
[10:30:47.872]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:47.872]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:47.872]         }
[10:30:47.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:47.872]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:47.872]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:47.872]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:47.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:47.872]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:47.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:47.872]             base::names(...future.oldOptions))
[10:30:47.872]     }
[10:30:47.872]     if (FALSE) {
[10:30:47.872]     }
[10:30:47.872]     else {
[10:30:47.872]         if (TRUE) {
[10:30:47.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:47.872]                 open = "w")
[10:30:47.872]         }
[10:30:47.872]         else {
[10:30:47.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:47.872]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:47.872]         }
[10:30:47.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:47.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:47.872]             base::sink(type = "output", split = FALSE)
[10:30:47.872]             base::close(...future.stdout)
[10:30:47.872]         }, add = TRUE)
[10:30:47.872]     }
[10:30:47.872]     ...future.frame <- base::sys.nframe()
[10:30:47.872]     ...future.conditions <- base::list()
[10:30:47.872]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:47.872]     if (FALSE) {
[10:30:47.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:47.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:47.872]     }
[10:30:47.872]     ...future.result <- base::tryCatch({
[10:30:47.872]         base::withCallingHandlers({
[10:30:47.872]             ...future.value <- base::withVisible(base::local({
[10:30:47.872]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:47.872]                 if (!identical(...future.globals.maxSize.org, 
[10:30:47.872]                   ...future.globals.maxSize)) {
[10:30:47.872]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:47.872]                   on.exit(options(oopts), add = TRUE)
[10:30:47.872]                 }
[10:30:47.872]                 {
[10:30:47.872]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:47.872]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:47.872]                       envir = globalenv(), inherits = FALSE)
[10:30:47.872]                     ...future.FUN(...)
[10:30:47.872]                   }
[10:30:47.872]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:47.872]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:47.872]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:47.872]                     USE.NAMES = FALSE)
[10:30:47.872]                   do.call(mapply, args = args)
[10:30:47.872]                 }
[10:30:47.872]             }))
[10:30:47.872]             future::FutureResult(value = ...future.value$value, 
[10:30:47.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:47.872]                   ...future.rng), globalenv = if (FALSE) 
[10:30:47.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:47.872]                     ...future.globalenv.names))
[10:30:47.872]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:47.872]         }, condition = base::local({
[10:30:47.872]             c <- base::c
[10:30:47.872]             inherits <- base::inherits
[10:30:47.872]             invokeRestart <- base::invokeRestart
[10:30:47.872]             length <- base::length
[10:30:47.872]             list <- base::list
[10:30:47.872]             seq.int <- base::seq.int
[10:30:47.872]             signalCondition <- base::signalCondition
[10:30:47.872]             sys.calls <- base::sys.calls
[10:30:47.872]             `[[` <- base::`[[`
[10:30:47.872]             `+` <- base::`+`
[10:30:47.872]             `<<-` <- base::`<<-`
[10:30:47.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:47.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:47.872]                   3L)]
[10:30:47.872]             }
[10:30:47.872]             function(cond) {
[10:30:47.872]                 is_error <- inherits(cond, "error")
[10:30:47.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:47.872]                   NULL)
[10:30:47.872]                 if (is_error) {
[10:30:47.872]                   sessionInformation <- function() {
[10:30:47.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:47.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:47.872]                       search = base::search(), system = base::Sys.info())
[10:30:47.872]                   }
[10:30:47.872]                   ...future.conditions[[length(...future.conditions) + 
[10:30:47.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:47.872]                     cond$call), session = sessionInformation(), 
[10:30:47.872]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:47.872]                   signalCondition(cond)
[10:30:47.872]                 }
[10:30:47.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:47.872]                 "immediateCondition"))) {
[10:30:47.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:47.872]                   ...future.conditions[[length(...future.conditions) + 
[10:30:47.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:47.872]                   if (TRUE && !signal) {
[10:30:47.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:47.872]                     {
[10:30:47.872]                       inherits <- base::inherits
[10:30:47.872]                       invokeRestart <- base::invokeRestart
[10:30:47.872]                       is.null <- base::is.null
[10:30:47.872]                       muffled <- FALSE
[10:30:47.872]                       if (inherits(cond, "message")) {
[10:30:47.872]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:47.872]                         if (muffled) 
[10:30:47.872]                           invokeRestart("muffleMessage")
[10:30:47.872]                       }
[10:30:47.872]                       else if (inherits(cond, "warning")) {
[10:30:47.872]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:47.872]                         if (muffled) 
[10:30:47.872]                           invokeRestart("muffleWarning")
[10:30:47.872]                       }
[10:30:47.872]                       else if (inherits(cond, "condition")) {
[10:30:47.872]                         if (!is.null(pattern)) {
[10:30:47.872]                           computeRestarts <- base::computeRestarts
[10:30:47.872]                           grepl <- base::grepl
[10:30:47.872]                           restarts <- computeRestarts(cond)
[10:30:47.872]                           for (restart in restarts) {
[10:30:47.872]                             name <- restart$name
[10:30:47.872]                             if (is.null(name)) 
[10:30:47.872]                               next
[10:30:47.872]                             if (!grepl(pattern, name)) 
[10:30:47.872]                               next
[10:30:47.872]                             invokeRestart(restart)
[10:30:47.872]                             muffled <- TRUE
[10:30:47.872]                             break
[10:30:47.872]                           }
[10:30:47.872]                         }
[10:30:47.872]                       }
[10:30:47.872]                       invisible(muffled)
[10:30:47.872]                     }
[10:30:47.872]                     muffleCondition(cond, pattern = "^muffle")
[10:30:47.872]                   }
[10:30:47.872]                 }
[10:30:47.872]                 else {
[10:30:47.872]                   if (TRUE) {
[10:30:47.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:47.872]                     {
[10:30:47.872]                       inherits <- base::inherits
[10:30:47.872]                       invokeRestart <- base::invokeRestart
[10:30:47.872]                       is.null <- base::is.null
[10:30:47.872]                       muffled <- FALSE
[10:30:47.872]                       if (inherits(cond, "message")) {
[10:30:47.872]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:47.872]                         if (muffled) 
[10:30:47.872]                           invokeRestart("muffleMessage")
[10:30:47.872]                       }
[10:30:47.872]                       else if (inherits(cond, "warning")) {
[10:30:47.872]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:47.872]                         if (muffled) 
[10:30:47.872]                           invokeRestart("muffleWarning")
[10:30:47.872]                       }
[10:30:47.872]                       else if (inherits(cond, "condition")) {
[10:30:47.872]                         if (!is.null(pattern)) {
[10:30:47.872]                           computeRestarts <- base::computeRestarts
[10:30:47.872]                           grepl <- base::grepl
[10:30:47.872]                           restarts <- computeRestarts(cond)
[10:30:47.872]                           for (restart in restarts) {
[10:30:47.872]                             name <- restart$name
[10:30:47.872]                             if (is.null(name)) 
[10:30:47.872]                               next
[10:30:47.872]                             if (!grepl(pattern, name)) 
[10:30:47.872]                               next
[10:30:47.872]                             invokeRestart(restart)
[10:30:47.872]                             muffled <- TRUE
[10:30:47.872]                             break
[10:30:47.872]                           }
[10:30:47.872]                         }
[10:30:47.872]                       }
[10:30:47.872]                       invisible(muffled)
[10:30:47.872]                     }
[10:30:47.872]                     muffleCondition(cond, pattern = "^muffle")
[10:30:47.872]                   }
[10:30:47.872]                 }
[10:30:47.872]             }
[10:30:47.872]         }))
[10:30:47.872]     }, error = function(ex) {
[10:30:47.872]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:47.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:47.872]                 ...future.rng), started = ...future.startTime, 
[10:30:47.872]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:47.872]             version = "1.8"), class = "FutureResult")
[10:30:47.872]     }, finally = {
[10:30:47.872]         if (!identical(...future.workdir, getwd())) 
[10:30:47.872]             setwd(...future.workdir)
[10:30:47.872]         {
[10:30:47.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:47.872]                 ...future.oldOptions$nwarnings <- NULL
[10:30:47.872]             }
[10:30:47.872]             base::options(...future.oldOptions)
[10:30:47.872]             if (.Platform$OS.type == "windows") {
[10:30:47.872]                 old_names <- names(...future.oldEnvVars)
[10:30:47.872]                 envs <- base::Sys.getenv()
[10:30:47.872]                 names <- names(envs)
[10:30:47.872]                 common <- intersect(names, old_names)
[10:30:47.872]                 added <- setdiff(names, old_names)
[10:30:47.872]                 removed <- setdiff(old_names, names)
[10:30:47.872]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:47.872]                   envs[common]]
[10:30:47.872]                 NAMES <- toupper(changed)
[10:30:47.872]                 args <- list()
[10:30:47.872]                 for (kk in seq_along(NAMES)) {
[10:30:47.872]                   name <- changed[[kk]]
[10:30:47.872]                   NAME <- NAMES[[kk]]
[10:30:47.872]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:47.872]                     next
[10:30:47.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:47.872]                 }
[10:30:47.872]                 NAMES <- toupper(added)
[10:30:47.872]                 for (kk in seq_along(NAMES)) {
[10:30:47.872]                   name <- added[[kk]]
[10:30:47.872]                   NAME <- NAMES[[kk]]
[10:30:47.872]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:47.872]                     next
[10:30:47.872]                   args[[name]] <- ""
[10:30:47.872]                 }
[10:30:47.872]                 NAMES <- toupper(removed)
[10:30:47.872]                 for (kk in seq_along(NAMES)) {
[10:30:47.872]                   name <- removed[[kk]]
[10:30:47.872]                   NAME <- NAMES[[kk]]
[10:30:47.872]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:47.872]                     next
[10:30:47.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:47.872]                 }
[10:30:47.872]                 if (length(args) > 0) 
[10:30:47.872]                   base::do.call(base::Sys.setenv, args = args)
[10:30:47.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:47.872]             }
[10:30:47.872]             else {
[10:30:47.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:47.872]             }
[10:30:47.872]             {
[10:30:47.872]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:47.872]                   0L) {
[10:30:47.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:47.872]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:47.872]                   base::options(opts)
[10:30:47.872]                 }
[10:30:47.872]                 {
[10:30:47.872]                   {
[10:30:47.872]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:47.872]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:47.872]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:47.872]                       inherits = FALSE)
[10:30:47.872]                     NULL
[10:30:47.872]                   }
[10:30:47.872]                   options(future.plan = NULL)
[10:30:47.872]                   if (is.na(NA_character_)) 
[10:30:47.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:47.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:47.872]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:47.872]                     .init = FALSE)
[10:30:47.872]                 }
[10:30:47.872]             }
[10:30:47.872]         }
[10:30:47.872]     })
[10:30:47.872]     if (TRUE) {
[10:30:47.872]         base::sink(type = "output", split = FALSE)
[10:30:47.872]         if (TRUE) {
[10:30:47.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:47.872]         }
[10:30:47.872]         else {
[10:30:47.872]             ...future.result["stdout"] <- base::list(NULL)
[10:30:47.872]         }
[10:30:47.872]         base::close(...future.stdout)
[10:30:47.872]         ...future.stdout <- NULL
[10:30:47.872]     }
[10:30:47.872]     ...future.result$conditions <- ...future.conditions
[10:30:47.872]     ...future.result$finished <- base::Sys.time()
[10:30:47.872]     ...future.result
[10:30:47.872] }
[10:30:47.874] assign_globals() ...
[10:30:47.874] List of 5
[10:30:47.874]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:30:47.874]  $ MoreArgs                 :List of 1
[10:30:47.874]   ..$ min: num 1
[10:30:47.874]  $ ...future.elements_ii    :List of 2
[10:30:47.874]   ..$ n  :List of 4
[10:30:47.874]   .. ..$ : int 1
[10:30:47.874]   .. ..$ : int 2
[10:30:47.874]   .. ..$ : int 3
[10:30:47.874]   .. ..$ : int 4
[10:30:47.874]   ..$ max:List of 4
[10:30:47.874]   .. ..$ : int 2
[10:30:47.874]   .. ..$ : int 3
[10:30:47.874]   .. ..$ : int 4
[10:30:47.874]   .. ..$ : int 5
[10:30:47.874]  $ ...future.seeds_ii       :List of 4
[10:30:47.874]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:30:47.874]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:30:47.874]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[10:30:47.874]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[10:30:47.874]  $ ...future.globals.maxSize: NULL
[10:30:47.874]  - attr(*, "where")=List of 5
[10:30:47.874]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:47.874]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:47.874]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:47.874]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:47.874]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:47.874]  - attr(*, "resolved")= logi FALSE
[10:30:47.874]  - attr(*, "total_size")= num 2912
[10:30:47.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:47.874]  - attr(*, "already-done")= logi TRUE
[10:30:47.883] - copied ‘...future.FUN’ to environment
[10:30:47.883] - copied ‘MoreArgs’ to environment
[10:30:47.883] - copied ‘...future.elements_ii’ to environment
[10:30:47.883] - copied ‘...future.seeds_ii’ to environment
[10:30:47.883] - copied ‘...future.globals.maxSize’ to environment
[10:30:47.883] assign_globals() ... done
[10:30:47.884] plan(): Setting new future strategy stack:
[10:30:47.884] List of future strategies:
[10:30:47.884] 1. sequential:
[10:30:47.884]    - args: function (..., envir = parent.frame())
[10:30:47.884]    - tweaked: FALSE
[10:30:47.884]    - call: NULL
[10:30:47.884] plan(): nbrOfWorkers() = 1
[10:30:47.885] plan(): Setting new future strategy stack:
[10:30:47.886] List of future strategies:
[10:30:47.886] 1. sequential:
[10:30:47.886]    - args: function (..., envir = parent.frame())
[10:30:47.886]    - tweaked: FALSE
[10:30:47.886]    - call: plan(sequential)
[10:30:47.886] plan(): nbrOfWorkers() = 1
[10:30:47.886] SequentialFuture started (and completed)
[10:30:47.887] - Launch lazy future ... done
[10:30:47.887] run() for ‘SequentialFuture’ ... done
[10:30:47.887] Created future:
[10:30:47.887] SequentialFuture:
[10:30:47.887] Label: ‘future_mapply-1’
[10:30:47.887] Expression:
[10:30:47.887] {
[10:30:47.887]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:47.887]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:47.887]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:47.887]         on.exit(options(oopts), add = TRUE)
[10:30:47.887]     }
[10:30:47.887]     {
[10:30:47.887]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:47.887]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:47.887]                 inherits = FALSE)
[10:30:47.887]             ...future.FUN(...)
[10:30:47.887]         }
[10:30:47.887]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:47.887]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:47.887]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:47.887]         do.call(mapply, args = args)
[10:30:47.887]     }
[10:30:47.887] }
[10:30:47.887] Lazy evaluation: FALSE
[10:30:47.887] Asynchronous evaluation: FALSE
[10:30:47.887] Local evaluation: TRUE
[10:30:47.887] Environment: R_GlobalEnv
[10:30:47.887] Capture standard output: TRUE
[10:30:47.887] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:47.887] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:47.887] Packages: 1 packages (‘stats’)
[10:30:47.887] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:47.887] Resolved: TRUE
[10:30:47.887] Value: 280 bytes of class ‘list’
[10:30:47.887] Early signaling: FALSE
[10:30:47.887] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:47.887] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:47.888] Chunk #1 of 1 ... DONE
[10:30:47.888] Launching 1 futures (chunks) ... DONE
[10:30:47.889] Resolving 1 futures (chunks) ...
[10:30:47.889] resolve() on list ...
[10:30:47.889]  recursive: 0
[10:30:47.889]  length: 1
[10:30:47.889] 
[10:30:47.890] resolved() for ‘SequentialFuture’ ...
[10:30:47.890] - state: ‘finished’
[10:30:47.890] - run: TRUE
[10:30:47.890] - result: ‘FutureResult’
[10:30:47.890] resolved() for ‘SequentialFuture’ ... done
[10:30:47.890] Future #1
[10:30:47.893] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:47.893] - nx: 1
[10:30:47.893] - relay: TRUE
[10:30:47.893] - stdout: TRUE
[10:30:47.893] - signal: TRUE
[10:30:47.893] - resignal: FALSE
[10:30:47.893] - force: TRUE
[10:30:47.893] - relayed: [n=1] FALSE
[10:30:47.894] - queued futures: [n=1] FALSE
[10:30:47.894]  - until=1
[10:30:47.894]  - relaying element #1
[10:30:47.894] - relayed: [n=1] TRUE
[10:30:47.894] - queued futures: [n=1] TRUE
[10:30:47.894] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:47.894]  length: 0 (resolved future 1)
[10:30:47.894] Relaying remaining futures
[10:30:47.895] signalConditionsASAP(NULL, pos=0) ...
[10:30:47.895] - nx: 1
[10:30:47.895] - relay: TRUE
[10:30:47.895] - stdout: TRUE
[10:30:47.895] - signal: TRUE
[10:30:47.895] - resignal: FALSE
[10:30:47.895] - force: TRUE
[10:30:47.895] - relayed: [n=1] TRUE
[10:30:47.895] - queued futures: [n=1] TRUE
 - flush all
[10:30:47.895] - relayed: [n=1] TRUE
[10:30:47.895] - queued futures: [n=1] TRUE
[10:30:47.896] signalConditionsASAP(NULL, pos=0) ... done
[10:30:47.896] resolve() on list ... DONE
[10:30:47.896]  - Number of value chunks collected: 1
[10:30:47.896] Resolving 1 futures (chunks) ... DONE
[10:30:47.896] Reducing values from 1 chunks ...
[10:30:47.896]  - Number of values collected after concatenation: 4
[10:30:47.896]  - Number of values expected: 4
[10:30:47.896] Reducing values from 1 chunks ... DONE
[10:30:47.896] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:30:48.054] plan(): Setting new future strategy stack:
[10:30:48.054] List of future strategies:
[10:30:48.054] 1. sequential:
[10:30:48.054]    - args: function (..., envir = parent.frame())
[10:30:48.054]    - tweaked: FALSE
[10:30:48.054]    - call: plan(strategy)
[10:30:48.054] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[10:30:48.055] future_mapply() ...
[10:30:48.055] Number of chunks: 1
[10:30:48.055] getGlobalsAndPackagesXApply() ...
[10:30:48.055]  - future.globals: TRUE
[10:30:48.055] getGlobalsAndPackages() ...
[10:30:48.055] Searching for globals...
[10:30:48.056] - globals found: [1] ‘FUN’
[10:30:48.056] Searching for globals ... DONE
[10:30:48.056] Resolving globals: FALSE
[10:30:48.056] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:48.057] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:48.057] - globals: [1] ‘FUN’
[10:30:48.057] 
[10:30:48.057] getGlobalsAndPackages() ... DONE
[10:30:48.057]  - globals found/used: [n=1] ‘FUN’
[10:30:48.057]  - needed namespaces: [n=0] 
[10:30:48.057] Finding globals ... DONE
[10:30:48.057] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.058] List of 2
[10:30:48.058]  $ ...future.FUN:function (x, ...)  
[10:30:48.058]  $ MoreArgs     : NULL
[10:30:48.058]  - attr(*, "where")=List of 2
[10:30:48.058]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.058]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.058]  - attr(*, "resolved")= logi FALSE
[10:30:48.058]  - attr(*, "total_size")= num NA
[10:30:48.060] Packages to be attached in all futures: [n=0] 
[10:30:48.060] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.060] Number of futures (= number of chunks): 1
[10:30:48.060] Launching 1 futures (chunks) ...
[10:30:48.061] Chunk #1 of 1 ...
[10:30:48.061]  - Finding globals in '...' for chunk #1 ...
[10:30:48.061] getGlobalsAndPackages() ...
[10:30:48.061] Searching for globals...
[10:30:48.061] 
[10:30:48.061] Searching for globals ... DONE
[10:30:48.061] - globals: [0] <none>
[10:30:48.061] getGlobalsAndPackages() ... DONE
[10:30:48.062]    + additional globals found: [n=0] 
[10:30:48.062]    + additional namespaces needed: [n=0] 
[10:30:48.062]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.062]  - seeds: <none>
[10:30:48.062]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.062] getGlobalsAndPackages() ...
[10:30:48.062] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.062] Resolving globals: FALSE
[10:30:48.063] The total size of the 5 globals is 504 bytes (504 bytes)
[10:30:48.063] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.063] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.063] 
[10:30:48.063] getGlobalsAndPackages() ... DONE
[10:30:48.064] run() for ‘Future’ ...
[10:30:48.064] - state: ‘created’
[10:30:48.064] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.064] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.064] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.064]   - Field: ‘label’
[10:30:48.065]   - Field: ‘local’
[10:30:48.065]   - Field: ‘owner’
[10:30:48.065]   - Field: ‘envir’
[10:30:48.065]   - Field: ‘packages’
[10:30:48.065]   - Field: ‘gc’
[10:30:48.065]   - Field: ‘conditions’
[10:30:48.065]   - Field: ‘expr’
[10:30:48.065]   - Field: ‘uuid’
[10:30:48.065]   - Field: ‘seed’
[10:30:48.065]   - Field: ‘version’
[10:30:48.065]   - Field: ‘result’
[10:30:48.066]   - Field: ‘asynchronous’
[10:30:48.066]   - Field: ‘calls’
[10:30:48.066]   - Field: ‘globals’
[10:30:48.066]   - Field: ‘stdout’
[10:30:48.066]   - Field: ‘earlySignal’
[10:30:48.066]   - Field: ‘lazy’
[10:30:48.066]   - Field: ‘state’
[10:30:48.066] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.066] - Launch lazy future ...
[10:30:48.066] Packages needed by the future expression (n = 0): <none>
[10:30:48.067] Packages needed by future strategies (n = 0): <none>
[10:30:48.067] {
[10:30:48.067]     {
[10:30:48.067]         {
[10:30:48.067]             ...future.startTime <- base::Sys.time()
[10:30:48.067]             {
[10:30:48.067]                 {
[10:30:48.067]                   {
[10:30:48.067]                     base::local({
[10:30:48.067]                       has_future <- base::requireNamespace("future", 
[10:30:48.067]                         quietly = TRUE)
[10:30:48.067]                       if (has_future) {
[10:30:48.067]                         ns <- base::getNamespace("future")
[10:30:48.067]                         version <- ns[[".package"]][["version"]]
[10:30:48.067]                         if (is.null(version)) 
[10:30:48.067]                           version <- utils::packageVersion("future")
[10:30:48.067]                       }
[10:30:48.067]                       else {
[10:30:48.067]                         version <- NULL
[10:30:48.067]                       }
[10:30:48.067]                       if (!has_future || version < "1.8.0") {
[10:30:48.067]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.067]                           "", base::R.version$version.string), 
[10:30:48.067]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.067]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.067]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.067]                             "release", "version")], collapse = " "), 
[10:30:48.067]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.067]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.067]                           info)
[10:30:48.067]                         info <- base::paste(info, collapse = "; ")
[10:30:48.067]                         if (!has_future) {
[10:30:48.067]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.067]                             info)
[10:30:48.067]                         }
[10:30:48.067]                         else {
[10:30:48.067]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.067]                             info, version)
[10:30:48.067]                         }
[10:30:48.067]                         base::stop(msg)
[10:30:48.067]                       }
[10:30:48.067]                     })
[10:30:48.067]                   }
[10:30:48.067]                   ...future.strategy.old <- future::plan("list")
[10:30:48.067]                   options(future.plan = NULL)
[10:30:48.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.067]                 }
[10:30:48.067]                 ...future.workdir <- getwd()
[10:30:48.067]             }
[10:30:48.067]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.067]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.067]         }
[10:30:48.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.067]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.067]             base::names(...future.oldOptions))
[10:30:48.067]     }
[10:30:48.067]     if (FALSE) {
[10:30:48.067]     }
[10:30:48.067]     else {
[10:30:48.067]         if (TRUE) {
[10:30:48.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.067]                 open = "w")
[10:30:48.067]         }
[10:30:48.067]         else {
[10:30:48.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.067]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.067]         }
[10:30:48.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.067]             base::sink(type = "output", split = FALSE)
[10:30:48.067]             base::close(...future.stdout)
[10:30:48.067]         }, add = TRUE)
[10:30:48.067]     }
[10:30:48.067]     ...future.frame <- base::sys.nframe()
[10:30:48.067]     ...future.conditions <- base::list()
[10:30:48.067]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.067]     if (FALSE) {
[10:30:48.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.067]     }
[10:30:48.067]     ...future.result <- base::tryCatch({
[10:30:48.067]         base::withCallingHandlers({
[10:30:48.067]             ...future.value <- base::withVisible(base::local({
[10:30:48.067]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.067]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.067]                   ...future.globals.maxSize)) {
[10:30:48.067]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.067]                   on.exit(options(oopts), add = TRUE)
[10:30:48.067]                 }
[10:30:48.067]                 {
[10:30:48.067]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.067]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.067]                     USE.NAMES = FALSE)
[10:30:48.067]                   do.call(mapply, args = args)
[10:30:48.067]                 }
[10:30:48.067]             }))
[10:30:48.067]             future::FutureResult(value = ...future.value$value, 
[10:30:48.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.067]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.067]                     ...future.globalenv.names))
[10:30:48.067]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.067]         }, condition = base::local({
[10:30:48.067]             c <- base::c
[10:30:48.067]             inherits <- base::inherits
[10:30:48.067]             invokeRestart <- base::invokeRestart
[10:30:48.067]             length <- base::length
[10:30:48.067]             list <- base::list
[10:30:48.067]             seq.int <- base::seq.int
[10:30:48.067]             signalCondition <- base::signalCondition
[10:30:48.067]             sys.calls <- base::sys.calls
[10:30:48.067]             `[[` <- base::`[[`
[10:30:48.067]             `+` <- base::`+`
[10:30:48.067]             `<<-` <- base::`<<-`
[10:30:48.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.067]                   3L)]
[10:30:48.067]             }
[10:30:48.067]             function(cond) {
[10:30:48.067]                 is_error <- inherits(cond, "error")
[10:30:48.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.067]                   NULL)
[10:30:48.067]                 if (is_error) {
[10:30:48.067]                   sessionInformation <- function() {
[10:30:48.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.067]                       search = base::search(), system = base::Sys.info())
[10:30:48.067]                   }
[10:30:48.067]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.067]                     cond$call), session = sessionInformation(), 
[10:30:48.067]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.067]                   signalCondition(cond)
[10:30:48.067]                 }
[10:30:48.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.067]                 "immediateCondition"))) {
[10:30:48.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.067]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.067]                   if (TRUE && !signal) {
[10:30:48.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.067]                     {
[10:30:48.067]                       inherits <- base::inherits
[10:30:48.067]                       invokeRestart <- base::invokeRestart
[10:30:48.067]                       is.null <- base::is.null
[10:30:48.067]                       muffled <- FALSE
[10:30:48.067]                       if (inherits(cond, "message")) {
[10:30:48.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.067]                         if (muffled) 
[10:30:48.067]                           invokeRestart("muffleMessage")
[10:30:48.067]                       }
[10:30:48.067]                       else if (inherits(cond, "warning")) {
[10:30:48.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.067]                         if (muffled) 
[10:30:48.067]                           invokeRestart("muffleWarning")
[10:30:48.067]                       }
[10:30:48.067]                       else if (inherits(cond, "condition")) {
[10:30:48.067]                         if (!is.null(pattern)) {
[10:30:48.067]                           computeRestarts <- base::computeRestarts
[10:30:48.067]                           grepl <- base::grepl
[10:30:48.067]                           restarts <- computeRestarts(cond)
[10:30:48.067]                           for (restart in restarts) {
[10:30:48.067]                             name <- restart$name
[10:30:48.067]                             if (is.null(name)) 
[10:30:48.067]                               next
[10:30:48.067]                             if (!grepl(pattern, name)) 
[10:30:48.067]                               next
[10:30:48.067]                             invokeRestart(restart)
[10:30:48.067]                             muffled <- TRUE
[10:30:48.067]                             break
[10:30:48.067]                           }
[10:30:48.067]                         }
[10:30:48.067]                       }
[10:30:48.067]                       invisible(muffled)
[10:30:48.067]                     }
[10:30:48.067]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.067]                   }
[10:30:48.067]                 }
[10:30:48.067]                 else {
[10:30:48.067]                   if (TRUE) {
[10:30:48.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.067]                     {
[10:30:48.067]                       inherits <- base::inherits
[10:30:48.067]                       invokeRestart <- base::invokeRestart
[10:30:48.067]                       is.null <- base::is.null
[10:30:48.067]                       muffled <- FALSE
[10:30:48.067]                       if (inherits(cond, "message")) {
[10:30:48.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.067]                         if (muffled) 
[10:30:48.067]                           invokeRestart("muffleMessage")
[10:30:48.067]                       }
[10:30:48.067]                       else if (inherits(cond, "warning")) {
[10:30:48.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.067]                         if (muffled) 
[10:30:48.067]                           invokeRestart("muffleWarning")
[10:30:48.067]                       }
[10:30:48.067]                       else if (inherits(cond, "condition")) {
[10:30:48.067]                         if (!is.null(pattern)) {
[10:30:48.067]                           computeRestarts <- base::computeRestarts
[10:30:48.067]                           grepl <- base::grepl
[10:30:48.067]                           restarts <- computeRestarts(cond)
[10:30:48.067]                           for (restart in restarts) {
[10:30:48.067]                             name <- restart$name
[10:30:48.067]                             if (is.null(name)) 
[10:30:48.067]                               next
[10:30:48.067]                             if (!grepl(pattern, name)) 
[10:30:48.067]                               next
[10:30:48.067]                             invokeRestart(restart)
[10:30:48.067]                             muffled <- TRUE
[10:30:48.067]                             break
[10:30:48.067]                           }
[10:30:48.067]                         }
[10:30:48.067]                       }
[10:30:48.067]                       invisible(muffled)
[10:30:48.067]                     }
[10:30:48.067]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.067]                   }
[10:30:48.067]                 }
[10:30:48.067]             }
[10:30:48.067]         }))
[10:30:48.067]     }, error = function(ex) {
[10:30:48.067]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.067]                 ...future.rng), started = ...future.startTime, 
[10:30:48.067]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.067]             version = "1.8"), class = "FutureResult")
[10:30:48.067]     }, finally = {
[10:30:48.067]         if (!identical(...future.workdir, getwd())) 
[10:30:48.067]             setwd(...future.workdir)
[10:30:48.067]         {
[10:30:48.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.067]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.067]             }
[10:30:48.067]             base::options(...future.oldOptions)
[10:30:48.067]             if (.Platform$OS.type == "windows") {
[10:30:48.067]                 old_names <- names(...future.oldEnvVars)
[10:30:48.067]                 envs <- base::Sys.getenv()
[10:30:48.067]                 names <- names(envs)
[10:30:48.067]                 common <- intersect(names, old_names)
[10:30:48.067]                 added <- setdiff(names, old_names)
[10:30:48.067]                 removed <- setdiff(old_names, names)
[10:30:48.067]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.067]                   envs[common]]
[10:30:48.067]                 NAMES <- toupper(changed)
[10:30:48.067]                 args <- list()
[10:30:48.067]                 for (kk in seq_along(NAMES)) {
[10:30:48.067]                   name <- changed[[kk]]
[10:30:48.067]                   NAME <- NAMES[[kk]]
[10:30:48.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.067]                     next
[10:30:48.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.067]                 }
[10:30:48.067]                 NAMES <- toupper(added)
[10:30:48.067]                 for (kk in seq_along(NAMES)) {
[10:30:48.067]                   name <- added[[kk]]
[10:30:48.067]                   NAME <- NAMES[[kk]]
[10:30:48.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.067]                     next
[10:30:48.067]                   args[[name]] <- ""
[10:30:48.067]                 }
[10:30:48.067]                 NAMES <- toupper(removed)
[10:30:48.067]                 for (kk in seq_along(NAMES)) {
[10:30:48.067]                   name <- removed[[kk]]
[10:30:48.067]                   NAME <- NAMES[[kk]]
[10:30:48.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.067]                     next
[10:30:48.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.067]                 }
[10:30:48.067]                 if (length(args) > 0) 
[10:30:48.067]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.067]             }
[10:30:48.067]             else {
[10:30:48.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.067]             }
[10:30:48.067]             {
[10:30:48.067]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.067]                   0L) {
[10:30:48.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.067]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.067]                   base::options(opts)
[10:30:48.067]                 }
[10:30:48.067]                 {
[10:30:48.067]                   {
[10:30:48.067]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.067]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.067]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.067]                       inherits = FALSE)
[10:30:48.067]                     NULL
[10:30:48.067]                   }
[10:30:48.067]                   options(future.plan = NULL)
[10:30:48.067]                   if (is.na(NA_character_)) 
[10:30:48.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.067]                     .init = FALSE)
[10:30:48.067]                 }
[10:30:48.067]             }
[10:30:48.067]         }
[10:30:48.067]     })
[10:30:48.067]     if (TRUE) {
[10:30:48.067]         base::sink(type = "output", split = FALSE)
[10:30:48.067]         if (TRUE) {
[10:30:48.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.067]         }
[10:30:48.067]         else {
[10:30:48.067]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.067]         }
[10:30:48.067]         base::close(...future.stdout)
[10:30:48.067]         ...future.stdout <- NULL
[10:30:48.067]     }
[10:30:48.067]     ...future.result$conditions <- ...future.conditions
[10:30:48.067]     ...future.result$finished <- base::Sys.time()
[10:30:48.067]     ...future.result
[10:30:48.067] }
[10:30:48.069] assign_globals() ...
[10:30:48.069] List of 5
[10:30:48.069]  $ ...future.FUN            :function (x, ...)  
[10:30:48.069]  $ MoreArgs                 : NULL
[10:30:48.069]  $ ...future.elements_ii    :List of 2
[10:30:48.069]   ..$ :List of 4
[10:30:48.069]   .. ..$ : int 1
[10:30:48.069]   .. ..$ : int 2
[10:30:48.069]   .. ..$ : int 3
[10:30:48.069]   .. ..$ : int 4
[10:30:48.069]   ..$ :List of 4
[10:30:48.069]   .. ..$ : int 4
[10:30:48.069]   .. ..$ : int 3
[10:30:48.069]   .. ..$ : int 2
[10:30:48.069]   .. ..$ : int 1
[10:30:48.069]  $ ...future.seeds_ii       : NULL
[10:30:48.069]  $ ...future.globals.maxSize: NULL
[10:30:48.069]  - attr(*, "where")=List of 5
[10:30:48.069]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.069]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.069]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.069]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.069]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.069]  - attr(*, "resolved")= logi FALSE
[10:30:48.069]  - attr(*, "total_size")= num 504
[10:30:48.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.069]  - attr(*, "already-done")= logi TRUE
[10:30:48.077] - copied ‘...future.FUN’ to environment
[10:30:48.077] - copied ‘MoreArgs’ to environment
[10:30:48.077] - copied ‘...future.elements_ii’ to environment
[10:30:48.077] - copied ‘...future.seeds_ii’ to environment
[10:30:48.078] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.078] assign_globals() ... done
[10:30:48.078] plan(): Setting new future strategy stack:
[10:30:48.078] List of future strategies:
[10:30:48.078] 1. sequential:
[10:30:48.078]    - args: function (..., envir = parent.frame())
[10:30:48.078]    - tweaked: FALSE
[10:30:48.078]    - call: NULL
[10:30:48.078] plan(): nbrOfWorkers() = 1
[10:30:48.079] plan(): Setting new future strategy stack:
[10:30:48.079] List of future strategies:
[10:30:48.079] 1. sequential:
[10:30:48.079]    - args: function (..., envir = parent.frame())
[10:30:48.079]    - tweaked: FALSE
[10:30:48.079]    - call: plan(strategy)
[10:30:48.080] plan(): nbrOfWorkers() = 1
[10:30:48.080] SequentialFuture started (and completed)
[10:30:48.080] - Launch lazy future ... done
[10:30:48.080] run() for ‘SequentialFuture’ ... done
[10:30:48.080] Created future:
[10:30:48.080] SequentialFuture:
[10:30:48.080] Label: ‘future_mapply-1’
[10:30:48.080] Expression:
[10:30:48.080] {
[10:30:48.080]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.080]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.080]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.080]         on.exit(options(oopts), add = TRUE)
[10:30:48.080]     }
[10:30:48.080]     {
[10:30:48.080]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.080]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.080]         do.call(mapply, args = args)
[10:30:48.080]     }
[10:30:48.080] }
[10:30:48.080] Lazy evaluation: FALSE
[10:30:48.080] Asynchronous evaluation: FALSE
[10:30:48.080] Local evaluation: TRUE
[10:30:48.080] Environment: R_GlobalEnv
[10:30:48.080] Capture standard output: TRUE
[10:30:48.080] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.080] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.080] Packages: <none>
[10:30:48.080] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.080] Resolved: TRUE
[10:30:48.080] Value: 240 bytes of class ‘list’
[10:30:48.080] Early signaling: FALSE
[10:30:48.080] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.080] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.081] Chunk #1 of 1 ... DONE
[10:30:48.081] Launching 1 futures (chunks) ... DONE
[10:30:48.081] Resolving 1 futures (chunks) ...
[10:30:48.081] resolve() on list ...
[10:30:48.081]  recursive: 0
[10:30:48.082]  length: 1
[10:30:48.082] 
[10:30:48.082] resolved() for ‘SequentialFuture’ ...
[10:30:48.082] - state: ‘finished’
[10:30:48.082] - run: TRUE
[10:30:48.082] - result: ‘FutureResult’
[10:30:48.082] resolved() for ‘SequentialFuture’ ... done
[10:30:48.082] Future #1
[10:30:48.082] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.082] - nx: 1
[10:30:48.083] - relay: TRUE
[10:30:48.083] - stdout: TRUE
[10:30:48.083] - signal: TRUE
[10:30:48.083] - resignal: FALSE
[10:30:48.083] - force: TRUE
[10:30:48.083] - relayed: [n=1] FALSE
[10:30:48.083] - queued futures: [n=1] FALSE
[10:30:48.083]  - until=1
[10:30:48.083]  - relaying element #1
[10:30:48.083] - relayed: [n=1] TRUE
[10:30:48.083] - queued futures: [n=1] TRUE
[10:30:48.084] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.084]  length: 0 (resolved future 1)
[10:30:48.084] Relaying remaining futures
[10:30:48.084] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.084] - nx: 1
[10:30:48.084] - relay: TRUE
[10:30:48.084] - stdout: TRUE
[10:30:48.084] - signal: TRUE
[10:30:48.084] - resignal: FALSE
[10:30:48.084] - force: TRUE
[10:30:48.084] - relayed: [n=1] TRUE
[10:30:48.084] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.085] - relayed: [n=1] TRUE
[10:30:48.085] - queued futures: [n=1] TRUE
[10:30:48.085] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.085] resolve() on list ... DONE
[10:30:48.085]  - Number of value chunks collected: 1
[10:30:48.085] Resolving 1 futures (chunks) ... DONE
[10:30:48.085] Reducing values from 1 chunks ...
[10:30:48.085]  - Number of values collected after concatenation: 4
[10:30:48.085]  - Number of values expected: 4
[10:30:48.085] Reducing values from 1 chunks ... DONE
[10:30:48.086] future_mapply() ... DONE
[10:30:48.086] future_mapply() ...
[10:30:48.086] Number of chunks: 1
[10:30:48.086] getGlobalsAndPackagesXApply() ...
[10:30:48.086]  - future.globals: TRUE
[10:30:48.086] getGlobalsAndPackages() ...
[10:30:48.086] Searching for globals...
[10:30:48.087] - globals found: [1] ‘FUN’
[10:30:48.087] Searching for globals ... DONE
[10:30:48.087] Resolving globals: FALSE
[10:30:48.087] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:48.088] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:48.088] - globals: [1] ‘FUN’
[10:30:48.088] 
[10:30:48.088] getGlobalsAndPackages() ... DONE
[10:30:48.088]  - globals found/used: [n=1] ‘FUN’
[10:30:48.088]  - needed namespaces: [n=0] 
[10:30:48.088] Finding globals ... DONE
[10:30:48.088] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.089] List of 2
[10:30:48.089]  $ ...future.FUN:function (x, ...)  
[10:30:48.089]  $ MoreArgs     : NULL
[10:30:48.089]  - attr(*, "where")=List of 2
[10:30:48.089]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.089]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.089]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.089]  - attr(*, "resolved")= logi FALSE
[10:30:48.089]  - attr(*, "total_size")= num NA
[10:30:48.091] Packages to be attached in all futures: [n=0] 
[10:30:48.091] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.091] Number of futures (= number of chunks): 1
[10:30:48.091] Launching 1 futures (chunks) ...
[10:30:48.091] Chunk #1 of 1 ...
[10:30:48.092]  - Finding globals in '...' for chunk #1 ...
[10:30:48.092] getGlobalsAndPackages() ...
[10:30:48.092] Searching for globals...
[10:30:48.092] 
[10:30:48.092] Searching for globals ... DONE
[10:30:48.092] - globals: [0] <none>
[10:30:48.092] getGlobalsAndPackages() ... DONE
[10:30:48.092]    + additional globals found: [n=0] 
[10:30:48.092]    + additional namespaces needed: [n=0] 
[10:30:48.093]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.093]  - seeds: <none>
[10:30:48.093]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.093] getGlobalsAndPackages() ...
[10:30:48.093] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.093] Resolving globals: FALSE
[10:30:48.094] The total size of the 5 globals is 504 bytes (504 bytes)
[10:30:48.094] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.094] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.094] 
[10:30:48.094] getGlobalsAndPackages() ... DONE
[10:30:48.095] run() for ‘Future’ ...
[10:30:48.095] - state: ‘created’
[10:30:48.095] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.095] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.095]   - Field: ‘label’
[10:30:48.095]   - Field: ‘local’
[10:30:48.095]   - Field: ‘owner’
[10:30:48.096]   - Field: ‘envir’
[10:30:48.096]   - Field: ‘packages’
[10:30:48.096]   - Field: ‘gc’
[10:30:48.096]   - Field: ‘conditions’
[10:30:48.096]   - Field: ‘expr’
[10:30:48.096]   - Field: ‘uuid’
[10:30:48.096]   - Field: ‘seed’
[10:30:48.096]   - Field: ‘version’
[10:30:48.096]   - Field: ‘result’
[10:30:48.096]   - Field: ‘asynchronous’
[10:30:48.096]   - Field: ‘calls’
[10:30:48.097]   - Field: ‘globals’
[10:30:48.097]   - Field: ‘stdout’
[10:30:48.097]   - Field: ‘earlySignal’
[10:30:48.097]   - Field: ‘lazy’
[10:30:48.097]   - Field: ‘state’
[10:30:48.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.099] - Launch lazy future ...
[10:30:48.099] Packages needed by the future expression (n = 0): <none>
[10:30:48.099] Packages needed by future strategies (n = 0): <none>
[10:30:48.099] {
[10:30:48.099]     {
[10:30:48.099]         {
[10:30:48.099]             ...future.startTime <- base::Sys.time()
[10:30:48.099]             {
[10:30:48.099]                 {
[10:30:48.099]                   {
[10:30:48.099]                     base::local({
[10:30:48.099]                       has_future <- base::requireNamespace("future", 
[10:30:48.099]                         quietly = TRUE)
[10:30:48.099]                       if (has_future) {
[10:30:48.099]                         ns <- base::getNamespace("future")
[10:30:48.099]                         version <- ns[[".package"]][["version"]]
[10:30:48.099]                         if (is.null(version)) 
[10:30:48.099]                           version <- utils::packageVersion("future")
[10:30:48.099]                       }
[10:30:48.099]                       else {
[10:30:48.099]                         version <- NULL
[10:30:48.099]                       }
[10:30:48.099]                       if (!has_future || version < "1.8.0") {
[10:30:48.099]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.099]                           "", base::R.version$version.string), 
[10:30:48.099]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.099]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.099]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.099]                             "release", "version")], collapse = " "), 
[10:30:48.099]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.099]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.099]                           info)
[10:30:48.099]                         info <- base::paste(info, collapse = "; ")
[10:30:48.099]                         if (!has_future) {
[10:30:48.099]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.099]                             info)
[10:30:48.099]                         }
[10:30:48.099]                         else {
[10:30:48.099]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.099]                             info, version)
[10:30:48.099]                         }
[10:30:48.099]                         base::stop(msg)
[10:30:48.099]                       }
[10:30:48.099]                     })
[10:30:48.099]                   }
[10:30:48.099]                   ...future.strategy.old <- future::plan("list")
[10:30:48.099]                   options(future.plan = NULL)
[10:30:48.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.099]                 }
[10:30:48.099]                 ...future.workdir <- getwd()
[10:30:48.099]             }
[10:30:48.099]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.099]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.099]         }
[10:30:48.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.099]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.099]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.099]             base::names(...future.oldOptions))
[10:30:48.099]     }
[10:30:48.099]     if (FALSE) {
[10:30:48.099]     }
[10:30:48.099]     else {
[10:30:48.099]         if (TRUE) {
[10:30:48.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.099]                 open = "w")
[10:30:48.099]         }
[10:30:48.099]         else {
[10:30:48.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.099]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.099]         }
[10:30:48.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.099]             base::sink(type = "output", split = FALSE)
[10:30:48.099]             base::close(...future.stdout)
[10:30:48.099]         }, add = TRUE)
[10:30:48.099]     }
[10:30:48.099]     ...future.frame <- base::sys.nframe()
[10:30:48.099]     ...future.conditions <- base::list()
[10:30:48.099]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.099]     if (FALSE) {
[10:30:48.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.099]     }
[10:30:48.099]     ...future.result <- base::tryCatch({
[10:30:48.099]         base::withCallingHandlers({
[10:30:48.099]             ...future.value <- base::withVisible(base::local({
[10:30:48.099]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.099]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.099]                   ...future.globals.maxSize)) {
[10:30:48.099]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.099]                   on.exit(options(oopts), add = TRUE)
[10:30:48.099]                 }
[10:30:48.099]                 {
[10:30:48.099]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.099]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.099]                     USE.NAMES = FALSE)
[10:30:48.099]                   do.call(mapply, args = args)
[10:30:48.099]                 }
[10:30:48.099]             }))
[10:30:48.099]             future::FutureResult(value = ...future.value$value, 
[10:30:48.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.099]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.099]                     ...future.globalenv.names))
[10:30:48.099]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.099]         }, condition = base::local({
[10:30:48.099]             c <- base::c
[10:30:48.099]             inherits <- base::inherits
[10:30:48.099]             invokeRestart <- base::invokeRestart
[10:30:48.099]             length <- base::length
[10:30:48.099]             list <- base::list
[10:30:48.099]             seq.int <- base::seq.int
[10:30:48.099]             signalCondition <- base::signalCondition
[10:30:48.099]             sys.calls <- base::sys.calls
[10:30:48.099]             `[[` <- base::`[[`
[10:30:48.099]             `+` <- base::`+`
[10:30:48.099]             `<<-` <- base::`<<-`
[10:30:48.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.099]                   3L)]
[10:30:48.099]             }
[10:30:48.099]             function(cond) {
[10:30:48.099]                 is_error <- inherits(cond, "error")
[10:30:48.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.099]                   NULL)
[10:30:48.099]                 if (is_error) {
[10:30:48.099]                   sessionInformation <- function() {
[10:30:48.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.099]                       search = base::search(), system = base::Sys.info())
[10:30:48.099]                   }
[10:30:48.099]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.099]                     cond$call), session = sessionInformation(), 
[10:30:48.099]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.099]                   signalCondition(cond)
[10:30:48.099]                 }
[10:30:48.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.099]                 "immediateCondition"))) {
[10:30:48.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.099]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.099]                   if (TRUE && !signal) {
[10:30:48.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.099]                     {
[10:30:48.099]                       inherits <- base::inherits
[10:30:48.099]                       invokeRestart <- base::invokeRestart
[10:30:48.099]                       is.null <- base::is.null
[10:30:48.099]                       muffled <- FALSE
[10:30:48.099]                       if (inherits(cond, "message")) {
[10:30:48.099]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.099]                         if (muffled) 
[10:30:48.099]                           invokeRestart("muffleMessage")
[10:30:48.099]                       }
[10:30:48.099]                       else if (inherits(cond, "warning")) {
[10:30:48.099]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.099]                         if (muffled) 
[10:30:48.099]                           invokeRestart("muffleWarning")
[10:30:48.099]                       }
[10:30:48.099]                       else if (inherits(cond, "condition")) {
[10:30:48.099]                         if (!is.null(pattern)) {
[10:30:48.099]                           computeRestarts <- base::computeRestarts
[10:30:48.099]                           grepl <- base::grepl
[10:30:48.099]                           restarts <- computeRestarts(cond)
[10:30:48.099]                           for (restart in restarts) {
[10:30:48.099]                             name <- restart$name
[10:30:48.099]                             if (is.null(name)) 
[10:30:48.099]                               next
[10:30:48.099]                             if (!grepl(pattern, name)) 
[10:30:48.099]                               next
[10:30:48.099]                             invokeRestart(restart)
[10:30:48.099]                             muffled <- TRUE
[10:30:48.099]                             break
[10:30:48.099]                           }
[10:30:48.099]                         }
[10:30:48.099]                       }
[10:30:48.099]                       invisible(muffled)
[10:30:48.099]                     }
[10:30:48.099]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.099]                   }
[10:30:48.099]                 }
[10:30:48.099]                 else {
[10:30:48.099]                   if (TRUE) {
[10:30:48.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.099]                     {
[10:30:48.099]                       inherits <- base::inherits
[10:30:48.099]                       invokeRestart <- base::invokeRestart
[10:30:48.099]                       is.null <- base::is.null
[10:30:48.099]                       muffled <- FALSE
[10:30:48.099]                       if (inherits(cond, "message")) {
[10:30:48.099]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.099]                         if (muffled) 
[10:30:48.099]                           invokeRestart("muffleMessage")
[10:30:48.099]                       }
[10:30:48.099]                       else if (inherits(cond, "warning")) {
[10:30:48.099]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.099]                         if (muffled) 
[10:30:48.099]                           invokeRestart("muffleWarning")
[10:30:48.099]                       }
[10:30:48.099]                       else if (inherits(cond, "condition")) {
[10:30:48.099]                         if (!is.null(pattern)) {
[10:30:48.099]                           computeRestarts <- base::computeRestarts
[10:30:48.099]                           grepl <- base::grepl
[10:30:48.099]                           restarts <- computeRestarts(cond)
[10:30:48.099]                           for (restart in restarts) {
[10:30:48.099]                             name <- restart$name
[10:30:48.099]                             if (is.null(name)) 
[10:30:48.099]                               next
[10:30:48.099]                             if (!grepl(pattern, name)) 
[10:30:48.099]                               next
[10:30:48.099]                             invokeRestart(restart)
[10:30:48.099]                             muffled <- TRUE
[10:30:48.099]                             break
[10:30:48.099]                           }
[10:30:48.099]                         }
[10:30:48.099]                       }
[10:30:48.099]                       invisible(muffled)
[10:30:48.099]                     }
[10:30:48.099]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.099]                   }
[10:30:48.099]                 }
[10:30:48.099]             }
[10:30:48.099]         }))
[10:30:48.099]     }, error = function(ex) {
[10:30:48.099]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.099]                 ...future.rng), started = ...future.startTime, 
[10:30:48.099]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.099]             version = "1.8"), class = "FutureResult")
[10:30:48.099]     }, finally = {
[10:30:48.099]         if (!identical(...future.workdir, getwd())) 
[10:30:48.099]             setwd(...future.workdir)
[10:30:48.099]         {
[10:30:48.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.099]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.099]             }
[10:30:48.099]             base::options(...future.oldOptions)
[10:30:48.099]             if (.Platform$OS.type == "windows") {
[10:30:48.099]                 old_names <- names(...future.oldEnvVars)
[10:30:48.099]                 envs <- base::Sys.getenv()
[10:30:48.099]                 names <- names(envs)
[10:30:48.099]                 common <- intersect(names, old_names)
[10:30:48.099]                 added <- setdiff(names, old_names)
[10:30:48.099]                 removed <- setdiff(old_names, names)
[10:30:48.099]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.099]                   envs[common]]
[10:30:48.099]                 NAMES <- toupper(changed)
[10:30:48.099]                 args <- list()
[10:30:48.099]                 for (kk in seq_along(NAMES)) {
[10:30:48.099]                   name <- changed[[kk]]
[10:30:48.099]                   NAME <- NAMES[[kk]]
[10:30:48.099]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.099]                     next
[10:30:48.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.099]                 }
[10:30:48.099]                 NAMES <- toupper(added)
[10:30:48.099]                 for (kk in seq_along(NAMES)) {
[10:30:48.099]                   name <- added[[kk]]
[10:30:48.099]                   NAME <- NAMES[[kk]]
[10:30:48.099]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.099]                     next
[10:30:48.099]                   args[[name]] <- ""
[10:30:48.099]                 }
[10:30:48.099]                 NAMES <- toupper(removed)
[10:30:48.099]                 for (kk in seq_along(NAMES)) {
[10:30:48.099]                   name <- removed[[kk]]
[10:30:48.099]                   NAME <- NAMES[[kk]]
[10:30:48.099]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.099]                     next
[10:30:48.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.099]                 }
[10:30:48.099]                 if (length(args) > 0) 
[10:30:48.099]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.099]             }
[10:30:48.099]             else {
[10:30:48.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.099]             }
[10:30:48.099]             {
[10:30:48.099]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.099]                   0L) {
[10:30:48.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.099]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.099]                   base::options(opts)
[10:30:48.099]                 }
[10:30:48.099]                 {
[10:30:48.099]                   {
[10:30:48.099]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.099]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.099]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.099]                       inherits = FALSE)
[10:30:48.099]                     NULL
[10:30:48.099]                   }
[10:30:48.099]                   options(future.plan = NULL)
[10:30:48.099]                   if (is.na(NA_character_)) 
[10:30:48.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.099]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.099]                     .init = FALSE)
[10:30:48.099]                 }
[10:30:48.099]             }
[10:30:48.099]         }
[10:30:48.099]     })
[10:30:48.099]     if (TRUE) {
[10:30:48.099]         base::sink(type = "output", split = FALSE)
[10:30:48.099]         if (TRUE) {
[10:30:48.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.099]         }
[10:30:48.099]         else {
[10:30:48.099]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.099]         }
[10:30:48.099]         base::close(...future.stdout)
[10:30:48.099]         ...future.stdout <- NULL
[10:30:48.099]     }
[10:30:48.099]     ...future.result$conditions <- ...future.conditions
[10:30:48.099]     ...future.result$finished <- base::Sys.time()
[10:30:48.099]     ...future.result
[10:30:48.099] }
[10:30:48.101] assign_globals() ...
[10:30:48.101] List of 5
[10:30:48.101]  $ ...future.FUN            :function (x, ...)  
[10:30:48.101]  $ MoreArgs                 : NULL
[10:30:48.101]  $ ...future.elements_ii    :List of 2
[10:30:48.101]   ..$ :List of 4
[10:30:48.101]   .. ..$ : int 1
[10:30:48.101]   .. ..$ : int 2
[10:30:48.101]   .. ..$ : int 3
[10:30:48.101]   .. ..$ : int 4
[10:30:48.101]   ..$ :List of 4
[10:30:48.101]   .. ..$ : int 4
[10:30:48.101]   .. ..$ : int 3
[10:30:48.101]   .. ..$ : int 2
[10:30:48.101]   .. ..$ : int 1
[10:30:48.101]  $ ...future.seeds_ii       : NULL
[10:30:48.101]  $ ...future.globals.maxSize: NULL
[10:30:48.101]  - attr(*, "where")=List of 5
[10:30:48.101]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.101]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.101]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.101]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.101]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.101]  - attr(*, "resolved")= logi FALSE
[10:30:48.101]  - attr(*, "total_size")= num 504
[10:30:48.101]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.101]  - attr(*, "already-done")= logi TRUE
[10:30:48.108] - copied ‘...future.FUN’ to environment
[10:30:48.108] - copied ‘MoreArgs’ to environment
[10:30:48.108] - copied ‘...future.elements_ii’ to environment
[10:30:48.108] - copied ‘...future.seeds_ii’ to environment
[10:30:48.108] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.108] assign_globals() ... done
[10:30:48.109] plan(): Setting new future strategy stack:
[10:30:48.109] List of future strategies:
[10:30:48.109] 1. sequential:
[10:30:48.109]    - args: function (..., envir = parent.frame())
[10:30:48.109]    - tweaked: FALSE
[10:30:48.109]    - call: NULL
[10:30:48.109] plan(): nbrOfWorkers() = 1
[10:30:48.110] plan(): Setting new future strategy stack:
[10:30:48.110] List of future strategies:
[10:30:48.110] 1. sequential:
[10:30:48.110]    - args: function (..., envir = parent.frame())
[10:30:48.110]    - tweaked: FALSE
[10:30:48.110]    - call: plan(strategy)
[10:30:48.110] plan(): nbrOfWorkers() = 1
[10:30:48.110] SequentialFuture started (and completed)
[10:30:48.110] - Launch lazy future ... done
[10:30:48.111] run() for ‘SequentialFuture’ ... done
[10:30:48.111] Created future:
[10:30:48.111] SequentialFuture:
[10:30:48.111] Label: ‘future_mapply-1’
[10:30:48.111] Expression:
[10:30:48.111] {
[10:30:48.111]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.111]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.111]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.111]         on.exit(options(oopts), add = TRUE)
[10:30:48.111]     }
[10:30:48.111]     {
[10:30:48.111]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.111]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.111]         do.call(mapply, args = args)
[10:30:48.111]     }
[10:30:48.111] }
[10:30:48.111] Lazy evaluation: FALSE
[10:30:48.111] Asynchronous evaluation: FALSE
[10:30:48.111] Local evaluation: TRUE
[10:30:48.111] Environment: R_GlobalEnv
[10:30:48.111] Capture standard output: TRUE
[10:30:48.111] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.111] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.111] Packages: <none>
[10:30:48.111] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.111] Resolved: TRUE
[10:30:48.111] Value: 240 bytes of class ‘list’
[10:30:48.111] Early signaling: FALSE
[10:30:48.111] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.111] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.112] Chunk #1 of 1 ... DONE
[10:30:48.112] Launching 1 futures (chunks) ... DONE
[10:30:48.112] Resolving 1 futures (chunks) ...
[10:30:48.112] resolve() on list ...
[10:30:48.112]  recursive: 0
[10:30:48.112]  length: 1
[10:30:48.112] 
[10:30:48.112] resolved() for ‘SequentialFuture’ ...
[10:30:48.112] - state: ‘finished’
[10:30:48.112] - run: TRUE
[10:30:48.113] - result: ‘FutureResult’
[10:30:48.113] resolved() for ‘SequentialFuture’ ... done
[10:30:48.113] Future #1
[10:30:48.113] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.113] - nx: 1
[10:30:48.113] - relay: TRUE
[10:30:48.113] - stdout: TRUE
[10:30:48.113] - signal: TRUE
[10:30:48.113] - resignal: FALSE
[10:30:48.113] - force: TRUE
[10:30:48.113] - relayed: [n=1] FALSE
[10:30:48.114] - queued futures: [n=1] FALSE
[10:30:48.114]  - until=1
[10:30:48.114]  - relaying element #1
[10:30:48.114] - relayed: [n=1] TRUE
[10:30:48.114] - queued futures: [n=1] TRUE
[10:30:48.114] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.114]  length: 0 (resolved future 1)
[10:30:48.114] Relaying remaining futures
[10:30:48.114] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.114] - nx: 1
[10:30:48.114] - relay: TRUE
[10:30:48.115] - stdout: TRUE
[10:30:48.115] - signal: TRUE
[10:30:48.115] - resignal: FALSE
[10:30:48.115] - force: TRUE
[10:30:48.115] - relayed: [n=1] TRUE
[10:30:48.115] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.115] - relayed: [n=1] TRUE
[10:30:48.115] - queued futures: [n=1] TRUE
[10:30:48.115] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.115] resolve() on list ... DONE
[10:30:48.115]  - Number of value chunks collected: 1
[10:30:48.116] Resolving 1 futures (chunks) ... DONE
[10:30:48.116] Reducing values from 1 chunks ...
[10:30:48.116]  - Number of values collected after concatenation: 4
[10:30:48.116]  - Number of values expected: 4
[10:30:48.116] Reducing values from 1 chunks ... DONE
[10:30:48.116] future_mapply() ... DONE
[10:30:48.116] future_mapply() ...
[10:30:48.116] Number of chunks: 1
[10:30:48.116] getGlobalsAndPackagesXApply() ...
[10:30:48.116]  - future.globals: TRUE
[10:30:48.117] getGlobalsAndPackages() ...
[10:30:48.117] Searching for globals...
[10:30:48.117] - globals found: [1] ‘FUN’
[10:30:48.117] Searching for globals ... DONE
[10:30:48.117] Resolving globals: FALSE
[10:30:48.118] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:48.118] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:48.118] - globals: [1] ‘FUN’
[10:30:48.118] 
[10:30:48.118] getGlobalsAndPackages() ... DONE
[10:30:48.118]  - globals found/used: [n=1] ‘FUN’
[10:30:48.119]  - needed namespaces: [n=0] 
[10:30:48.119] Finding globals ... DONE
[10:30:48.119] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.119] List of 2
[10:30:48.119]  $ ...future.FUN:function (x, ...)  
[10:30:48.119]  $ MoreArgs     : NULL
[10:30:48.119]  - attr(*, "where")=List of 2
[10:30:48.119]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.119]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.119]  - attr(*, "resolved")= logi FALSE
[10:30:48.119]  - attr(*, "total_size")= num NA
[10:30:48.121] Packages to be attached in all futures: [n=0] 
[10:30:48.121] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.123] Number of futures (= number of chunks): 1
[10:30:48.123] Launching 1 futures (chunks) ...
[10:30:48.123] Chunk #1 of 1 ...
[10:30:48.123]  - Finding globals in '...' for chunk #1 ...
[10:30:48.123] getGlobalsAndPackages() ...
[10:30:48.124] Searching for globals...
[10:30:48.124] 
[10:30:48.124] Searching for globals ... DONE
[10:30:48.124] - globals: [0] <none>
[10:30:48.124] getGlobalsAndPackages() ... DONE
[10:30:48.124]    + additional globals found: [n=0] 
[10:30:48.124]    + additional namespaces needed: [n=0] 
[10:30:48.124]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.125]  - seeds: <none>
[10:30:48.125]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.125] getGlobalsAndPackages() ...
[10:30:48.125] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.125] Resolving globals: FALSE
[10:30:48.125] The total size of the 5 globals is 504 bytes (504 bytes)
[10:30:48.126] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.126] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.126] 
[10:30:48.126] getGlobalsAndPackages() ... DONE
[10:30:48.126] run() for ‘Future’ ...
[10:30:48.127] - state: ‘created’
[10:30:48.127] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.127] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.127] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.127]   - Field: ‘label’
[10:30:48.127]   - Field: ‘local’
[10:30:48.127]   - Field: ‘owner’
[10:30:48.128]   - Field: ‘envir’
[10:30:48.128]   - Field: ‘packages’
[10:30:48.128]   - Field: ‘gc’
[10:30:48.128]   - Field: ‘conditions’
[10:30:48.128]   - Field: ‘expr’
[10:30:48.128]   - Field: ‘uuid’
[10:30:48.128]   - Field: ‘seed’
[10:30:48.128]   - Field: ‘version’
[10:30:48.128]   - Field: ‘result’
[10:30:48.128]   - Field: ‘asynchronous’
[10:30:48.128]   - Field: ‘calls’
[10:30:48.128]   - Field: ‘globals’
[10:30:48.129]   - Field: ‘stdout’
[10:30:48.129]   - Field: ‘earlySignal’
[10:30:48.129]   - Field: ‘lazy’
[10:30:48.129]   - Field: ‘state’
[10:30:48.129] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.129] - Launch lazy future ...
[10:30:48.129] Packages needed by the future expression (n = 0): <none>
[10:30:48.129] Packages needed by future strategies (n = 0): <none>
[10:30:48.130] {
[10:30:48.130]     {
[10:30:48.130]         {
[10:30:48.130]             ...future.startTime <- base::Sys.time()
[10:30:48.130]             {
[10:30:48.130]                 {
[10:30:48.130]                   {
[10:30:48.130]                     base::local({
[10:30:48.130]                       has_future <- base::requireNamespace("future", 
[10:30:48.130]                         quietly = TRUE)
[10:30:48.130]                       if (has_future) {
[10:30:48.130]                         ns <- base::getNamespace("future")
[10:30:48.130]                         version <- ns[[".package"]][["version"]]
[10:30:48.130]                         if (is.null(version)) 
[10:30:48.130]                           version <- utils::packageVersion("future")
[10:30:48.130]                       }
[10:30:48.130]                       else {
[10:30:48.130]                         version <- NULL
[10:30:48.130]                       }
[10:30:48.130]                       if (!has_future || version < "1.8.0") {
[10:30:48.130]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.130]                           "", base::R.version$version.string), 
[10:30:48.130]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.130]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.130]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.130]                             "release", "version")], collapse = " "), 
[10:30:48.130]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.130]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.130]                           info)
[10:30:48.130]                         info <- base::paste(info, collapse = "; ")
[10:30:48.130]                         if (!has_future) {
[10:30:48.130]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.130]                             info)
[10:30:48.130]                         }
[10:30:48.130]                         else {
[10:30:48.130]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.130]                             info, version)
[10:30:48.130]                         }
[10:30:48.130]                         base::stop(msg)
[10:30:48.130]                       }
[10:30:48.130]                     })
[10:30:48.130]                   }
[10:30:48.130]                   ...future.strategy.old <- future::plan("list")
[10:30:48.130]                   options(future.plan = NULL)
[10:30:48.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.130]                 }
[10:30:48.130]                 ...future.workdir <- getwd()
[10:30:48.130]             }
[10:30:48.130]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.130]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.130]         }
[10:30:48.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.130]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.130]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.130]             base::names(...future.oldOptions))
[10:30:48.130]     }
[10:30:48.130]     if (FALSE) {
[10:30:48.130]     }
[10:30:48.130]     else {
[10:30:48.130]         if (TRUE) {
[10:30:48.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.130]                 open = "w")
[10:30:48.130]         }
[10:30:48.130]         else {
[10:30:48.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.130]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.130]         }
[10:30:48.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.130]             base::sink(type = "output", split = FALSE)
[10:30:48.130]             base::close(...future.stdout)
[10:30:48.130]         }, add = TRUE)
[10:30:48.130]     }
[10:30:48.130]     ...future.frame <- base::sys.nframe()
[10:30:48.130]     ...future.conditions <- base::list()
[10:30:48.130]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.130]     if (FALSE) {
[10:30:48.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.130]     }
[10:30:48.130]     ...future.result <- base::tryCatch({
[10:30:48.130]         base::withCallingHandlers({
[10:30:48.130]             ...future.value <- base::withVisible(base::local({
[10:30:48.130]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.130]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.130]                   ...future.globals.maxSize)) {
[10:30:48.130]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.130]                   on.exit(options(oopts), add = TRUE)
[10:30:48.130]                 }
[10:30:48.130]                 {
[10:30:48.130]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.130]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.130]                     USE.NAMES = FALSE)
[10:30:48.130]                   do.call(mapply, args = args)
[10:30:48.130]                 }
[10:30:48.130]             }))
[10:30:48.130]             future::FutureResult(value = ...future.value$value, 
[10:30:48.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.130]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.130]                     ...future.globalenv.names))
[10:30:48.130]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.130]         }, condition = base::local({
[10:30:48.130]             c <- base::c
[10:30:48.130]             inherits <- base::inherits
[10:30:48.130]             invokeRestart <- base::invokeRestart
[10:30:48.130]             length <- base::length
[10:30:48.130]             list <- base::list
[10:30:48.130]             seq.int <- base::seq.int
[10:30:48.130]             signalCondition <- base::signalCondition
[10:30:48.130]             sys.calls <- base::sys.calls
[10:30:48.130]             `[[` <- base::`[[`
[10:30:48.130]             `+` <- base::`+`
[10:30:48.130]             `<<-` <- base::`<<-`
[10:30:48.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.130]                   3L)]
[10:30:48.130]             }
[10:30:48.130]             function(cond) {
[10:30:48.130]                 is_error <- inherits(cond, "error")
[10:30:48.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.130]                   NULL)
[10:30:48.130]                 if (is_error) {
[10:30:48.130]                   sessionInformation <- function() {
[10:30:48.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.130]                       search = base::search(), system = base::Sys.info())
[10:30:48.130]                   }
[10:30:48.130]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.130]                     cond$call), session = sessionInformation(), 
[10:30:48.130]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.130]                   signalCondition(cond)
[10:30:48.130]                 }
[10:30:48.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.130]                 "immediateCondition"))) {
[10:30:48.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.130]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.130]                   if (TRUE && !signal) {
[10:30:48.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.130]                     {
[10:30:48.130]                       inherits <- base::inherits
[10:30:48.130]                       invokeRestart <- base::invokeRestart
[10:30:48.130]                       is.null <- base::is.null
[10:30:48.130]                       muffled <- FALSE
[10:30:48.130]                       if (inherits(cond, "message")) {
[10:30:48.130]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.130]                         if (muffled) 
[10:30:48.130]                           invokeRestart("muffleMessage")
[10:30:48.130]                       }
[10:30:48.130]                       else if (inherits(cond, "warning")) {
[10:30:48.130]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.130]                         if (muffled) 
[10:30:48.130]                           invokeRestart("muffleWarning")
[10:30:48.130]                       }
[10:30:48.130]                       else if (inherits(cond, "condition")) {
[10:30:48.130]                         if (!is.null(pattern)) {
[10:30:48.130]                           computeRestarts <- base::computeRestarts
[10:30:48.130]                           grepl <- base::grepl
[10:30:48.130]                           restarts <- computeRestarts(cond)
[10:30:48.130]                           for (restart in restarts) {
[10:30:48.130]                             name <- restart$name
[10:30:48.130]                             if (is.null(name)) 
[10:30:48.130]                               next
[10:30:48.130]                             if (!grepl(pattern, name)) 
[10:30:48.130]                               next
[10:30:48.130]                             invokeRestart(restart)
[10:30:48.130]                             muffled <- TRUE
[10:30:48.130]                             break
[10:30:48.130]                           }
[10:30:48.130]                         }
[10:30:48.130]                       }
[10:30:48.130]                       invisible(muffled)
[10:30:48.130]                     }
[10:30:48.130]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.130]                   }
[10:30:48.130]                 }
[10:30:48.130]                 else {
[10:30:48.130]                   if (TRUE) {
[10:30:48.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.130]                     {
[10:30:48.130]                       inherits <- base::inherits
[10:30:48.130]                       invokeRestart <- base::invokeRestart
[10:30:48.130]                       is.null <- base::is.null
[10:30:48.130]                       muffled <- FALSE
[10:30:48.130]                       if (inherits(cond, "message")) {
[10:30:48.130]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.130]                         if (muffled) 
[10:30:48.130]                           invokeRestart("muffleMessage")
[10:30:48.130]                       }
[10:30:48.130]                       else if (inherits(cond, "warning")) {
[10:30:48.130]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.130]                         if (muffled) 
[10:30:48.130]                           invokeRestart("muffleWarning")
[10:30:48.130]                       }
[10:30:48.130]                       else if (inherits(cond, "condition")) {
[10:30:48.130]                         if (!is.null(pattern)) {
[10:30:48.130]                           computeRestarts <- base::computeRestarts
[10:30:48.130]                           grepl <- base::grepl
[10:30:48.130]                           restarts <- computeRestarts(cond)
[10:30:48.130]                           for (restart in restarts) {
[10:30:48.130]                             name <- restart$name
[10:30:48.130]                             if (is.null(name)) 
[10:30:48.130]                               next
[10:30:48.130]                             if (!grepl(pattern, name)) 
[10:30:48.130]                               next
[10:30:48.130]                             invokeRestart(restart)
[10:30:48.130]                             muffled <- TRUE
[10:30:48.130]                             break
[10:30:48.130]                           }
[10:30:48.130]                         }
[10:30:48.130]                       }
[10:30:48.130]                       invisible(muffled)
[10:30:48.130]                     }
[10:30:48.130]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.130]                   }
[10:30:48.130]                 }
[10:30:48.130]             }
[10:30:48.130]         }))
[10:30:48.130]     }, error = function(ex) {
[10:30:48.130]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.130]                 ...future.rng), started = ...future.startTime, 
[10:30:48.130]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.130]             version = "1.8"), class = "FutureResult")
[10:30:48.130]     }, finally = {
[10:30:48.130]         if (!identical(...future.workdir, getwd())) 
[10:30:48.130]             setwd(...future.workdir)
[10:30:48.130]         {
[10:30:48.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.130]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.130]             }
[10:30:48.130]             base::options(...future.oldOptions)
[10:30:48.130]             if (.Platform$OS.type == "windows") {
[10:30:48.130]                 old_names <- names(...future.oldEnvVars)
[10:30:48.130]                 envs <- base::Sys.getenv()
[10:30:48.130]                 names <- names(envs)
[10:30:48.130]                 common <- intersect(names, old_names)
[10:30:48.130]                 added <- setdiff(names, old_names)
[10:30:48.130]                 removed <- setdiff(old_names, names)
[10:30:48.130]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.130]                   envs[common]]
[10:30:48.130]                 NAMES <- toupper(changed)
[10:30:48.130]                 args <- list()
[10:30:48.130]                 for (kk in seq_along(NAMES)) {
[10:30:48.130]                   name <- changed[[kk]]
[10:30:48.130]                   NAME <- NAMES[[kk]]
[10:30:48.130]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.130]                     next
[10:30:48.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.130]                 }
[10:30:48.130]                 NAMES <- toupper(added)
[10:30:48.130]                 for (kk in seq_along(NAMES)) {
[10:30:48.130]                   name <- added[[kk]]
[10:30:48.130]                   NAME <- NAMES[[kk]]
[10:30:48.130]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.130]                     next
[10:30:48.130]                   args[[name]] <- ""
[10:30:48.130]                 }
[10:30:48.130]                 NAMES <- toupper(removed)
[10:30:48.130]                 for (kk in seq_along(NAMES)) {
[10:30:48.130]                   name <- removed[[kk]]
[10:30:48.130]                   NAME <- NAMES[[kk]]
[10:30:48.130]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.130]                     next
[10:30:48.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.130]                 }
[10:30:48.130]                 if (length(args) > 0) 
[10:30:48.130]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.130]             }
[10:30:48.130]             else {
[10:30:48.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.130]             }
[10:30:48.130]             {
[10:30:48.130]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.130]                   0L) {
[10:30:48.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.130]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.130]                   base::options(opts)
[10:30:48.130]                 }
[10:30:48.130]                 {
[10:30:48.130]                   {
[10:30:48.130]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.130]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.130]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.130]                       inherits = FALSE)
[10:30:48.130]                     NULL
[10:30:48.130]                   }
[10:30:48.130]                   options(future.plan = NULL)
[10:30:48.130]                   if (is.na(NA_character_)) 
[10:30:48.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.130]                     .init = FALSE)
[10:30:48.130]                 }
[10:30:48.130]             }
[10:30:48.130]         }
[10:30:48.130]     })
[10:30:48.130]     if (TRUE) {
[10:30:48.130]         base::sink(type = "output", split = FALSE)
[10:30:48.130]         if (TRUE) {
[10:30:48.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.130]         }
[10:30:48.130]         else {
[10:30:48.130]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.130]         }
[10:30:48.130]         base::close(...future.stdout)
[10:30:48.130]         ...future.stdout <- NULL
[10:30:48.130]     }
[10:30:48.130]     ...future.result$conditions <- ...future.conditions
[10:30:48.130]     ...future.result$finished <- base::Sys.time()
[10:30:48.130]     ...future.result
[10:30:48.130] }
[10:30:48.131] assign_globals() ...
[10:30:48.131] List of 5
[10:30:48.131]  $ ...future.FUN            :function (x, ...)  
[10:30:48.131]  $ MoreArgs                 : NULL
[10:30:48.131]  $ ...future.elements_ii    :List of 2
[10:30:48.131]   ..$ times:List of 4
[10:30:48.131]   .. ..$ : int 1
[10:30:48.131]   .. ..$ : int 2
[10:30:48.131]   .. ..$ : int 3
[10:30:48.131]   .. ..$ : int 4
[10:30:48.131]   ..$ x    :List of 4
[10:30:48.131]   .. ..$ : int 4
[10:30:48.131]   .. ..$ : int 3
[10:30:48.131]   .. ..$ : int 2
[10:30:48.131]   .. ..$ : int 1
[10:30:48.131]  $ ...future.seeds_ii       : NULL
[10:30:48.131]  $ ...future.globals.maxSize: NULL
[10:30:48.131]  - attr(*, "where")=List of 5
[10:30:48.131]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.131]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.131]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.131]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.131]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.131]  - attr(*, "resolved")= logi FALSE
[10:30:48.131]  - attr(*, "total_size")= num 504
[10:30:48.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.131]  - attr(*, "already-done")= logi TRUE
[10:30:48.138] - copied ‘...future.FUN’ to environment
[10:30:48.138] - copied ‘MoreArgs’ to environment
[10:30:48.138] - copied ‘...future.elements_ii’ to environment
[10:30:48.138] - copied ‘...future.seeds_ii’ to environment
[10:30:48.138] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.139] assign_globals() ... done
[10:30:48.139] plan(): Setting new future strategy stack:
[10:30:48.139] List of future strategies:
[10:30:48.139] 1. sequential:
[10:30:48.139]    - args: function (..., envir = parent.frame())
[10:30:48.139]    - tweaked: FALSE
[10:30:48.139]    - call: NULL
[10:30:48.139] plan(): nbrOfWorkers() = 1
[10:30:48.140] plan(): Setting new future strategy stack:
[10:30:48.140] List of future strategies:
[10:30:48.140] 1. sequential:
[10:30:48.140]    - args: function (..., envir = parent.frame())
[10:30:48.140]    - tweaked: FALSE
[10:30:48.140]    - call: plan(strategy)
[10:30:48.140] plan(): nbrOfWorkers() = 1
[10:30:48.140] SequentialFuture started (and completed)
[10:30:48.141] - Launch lazy future ... done
[10:30:48.141] run() for ‘SequentialFuture’ ... done
[10:30:48.141] Created future:
[10:30:48.141] SequentialFuture:
[10:30:48.141] Label: ‘future_mapply-1’
[10:30:48.141] Expression:
[10:30:48.141] {
[10:30:48.141]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.141]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.141]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.141]         on.exit(options(oopts), add = TRUE)
[10:30:48.141]     }
[10:30:48.141]     {
[10:30:48.141]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.141]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.141]         do.call(mapply, args = args)
[10:30:48.141]     }
[10:30:48.141] }
[10:30:48.141] Lazy evaluation: FALSE
[10:30:48.141] Asynchronous evaluation: FALSE
[10:30:48.141] Local evaluation: TRUE
[10:30:48.141] Environment: R_GlobalEnv
[10:30:48.141] Capture standard output: TRUE
[10:30:48.141] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.141] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.141] Packages: <none>
[10:30:48.141] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.141] Resolved: TRUE
[10:30:48.141] Value: 240 bytes of class ‘list’
[10:30:48.141] Early signaling: FALSE
[10:30:48.141] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.141] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.142] Chunk #1 of 1 ... DONE
[10:30:48.142] Launching 1 futures (chunks) ... DONE
[10:30:48.142] Resolving 1 futures (chunks) ...
[10:30:48.142] resolve() on list ...
[10:30:48.142]  recursive: 0
[10:30:48.142]  length: 1
[10:30:48.142] 
[10:30:48.142] resolved() for ‘SequentialFuture’ ...
[10:30:48.143] - state: ‘finished’
[10:30:48.143] - run: TRUE
[10:30:48.143] - result: ‘FutureResult’
[10:30:48.143] resolved() for ‘SequentialFuture’ ... done
[10:30:48.143] Future #1
[10:30:48.143] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.143] - nx: 1
[10:30:48.143] - relay: TRUE
[10:30:48.143] - stdout: TRUE
[10:30:48.143] - signal: TRUE
[10:30:48.143] - resignal: FALSE
[10:30:48.144] - force: TRUE
[10:30:48.144] - relayed: [n=1] FALSE
[10:30:48.144] - queued futures: [n=1] FALSE
[10:30:48.144]  - until=1
[10:30:48.144]  - relaying element #1
[10:30:48.144] - relayed: [n=1] TRUE
[10:30:48.144] - queued futures: [n=1] TRUE
[10:30:48.144] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.144]  length: 0 (resolved future 1)
[10:30:48.144] Relaying remaining futures
[10:30:48.145] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.145] - nx: 1
[10:30:48.145] - relay: TRUE
[10:30:48.145] - stdout: TRUE
[10:30:48.145] - signal: TRUE
[10:30:48.145] - resignal: FALSE
[10:30:48.145] - force: TRUE
[10:30:48.145] - relayed: [n=1] TRUE
[10:30:48.145] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.145] - relayed: [n=1] TRUE
[10:30:48.145] - queued futures: [n=1] TRUE
[10:30:48.146] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.146] resolve() on list ... DONE
[10:30:48.146]  - Number of value chunks collected: 1
[10:30:48.147] Resolving 1 futures (chunks) ... DONE
[10:30:48.148] Reducing values from 1 chunks ...
[10:30:48.148]  - Number of values collected after concatenation: 4
[10:30:48.148]  - Number of values expected: 4
[10:30:48.148] Reducing values from 1 chunks ... DONE
[10:30:48.148] future_mapply() ... DONE
[10:30:48.148] future_mapply() ...
[10:30:48.148] Number of chunks: 1
[10:30:48.148] getGlobalsAndPackagesXApply() ...
[10:30:48.148]  - future.globals: TRUE
[10:30:48.149] getGlobalsAndPackages() ...
[10:30:48.149] Searching for globals...
[10:30:48.149] - globals found: [1] ‘FUN’
[10:30:48.149] Searching for globals ... DONE
[10:30:48.149] Resolving globals: FALSE
[10:30:48.150] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:48.150] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:48.150] - globals: [1] ‘FUN’
[10:30:48.150] 
[10:30:48.150] getGlobalsAndPackages() ... DONE
[10:30:48.150]  - globals found/used: [n=1] ‘FUN’
[10:30:48.151]  - needed namespaces: [n=0] 
[10:30:48.151] Finding globals ... DONE
[10:30:48.151] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.151] List of 2
[10:30:48.151]  $ ...future.FUN:function (x, ...)  
[10:30:48.151]  $ MoreArgs     :List of 1
[10:30:48.151]   ..$ x: num 42
[10:30:48.151]  - attr(*, "where")=List of 2
[10:30:48.151]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.151]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.151]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.151]  - attr(*, "resolved")= logi FALSE
[10:30:48.151]  - attr(*, "total_size")= num NA
[10:30:48.154] Packages to be attached in all futures: [n=0] 
[10:30:48.154] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.154] Number of futures (= number of chunks): 1
[10:30:48.154] Launching 1 futures (chunks) ...
[10:30:48.154] Chunk #1 of 1 ...
[10:30:48.154]  - Finding globals in '...' for chunk #1 ...
[10:30:48.154] getGlobalsAndPackages() ...
[10:30:48.154] Searching for globals...
[10:30:48.155] 
[10:30:48.155] Searching for globals ... DONE
[10:30:48.155] - globals: [0] <none>
[10:30:48.155] getGlobalsAndPackages() ... DONE
[10:30:48.155]    + additional globals found: [n=0] 
[10:30:48.155]    + additional namespaces needed: [n=0] 
[10:30:48.155]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.155]  - seeds: <none>
[10:30:48.155]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.156] getGlobalsAndPackages() ...
[10:30:48.156] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.156] Resolving globals: FALSE
[10:30:48.156] The total size of the 5 globals is 336 bytes (336 bytes)
[10:30:48.157] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 336 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:48.157] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.157] 
[10:30:48.157] getGlobalsAndPackages() ... DONE
[10:30:48.157] run() for ‘Future’ ...
[10:30:48.157] - state: ‘created’
[10:30:48.157] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.158] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.158]   - Field: ‘label’
[10:30:48.158]   - Field: ‘local’
[10:30:48.158]   - Field: ‘owner’
[10:30:48.158]   - Field: ‘envir’
[10:30:48.158]   - Field: ‘packages’
[10:30:48.158]   - Field: ‘gc’
[10:30:48.158]   - Field: ‘conditions’
[10:30:48.158]   - Field: ‘expr’
[10:30:48.159]   - Field: ‘uuid’
[10:30:48.159]   - Field: ‘seed’
[10:30:48.159]   - Field: ‘version’
[10:30:48.159]   - Field: ‘result’
[10:30:48.159]   - Field: ‘asynchronous’
[10:30:48.159]   - Field: ‘calls’
[10:30:48.159]   - Field: ‘globals’
[10:30:48.159]   - Field: ‘stdout’
[10:30:48.159]   - Field: ‘earlySignal’
[10:30:48.159]   - Field: ‘lazy’
[10:30:48.159]   - Field: ‘state’
[10:30:48.160] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.160] - Launch lazy future ...
[10:30:48.160] Packages needed by the future expression (n = 0): <none>
[10:30:48.160] Packages needed by future strategies (n = 0): <none>
[10:30:48.160] {
[10:30:48.160]     {
[10:30:48.160]         {
[10:30:48.160]             ...future.startTime <- base::Sys.time()
[10:30:48.160]             {
[10:30:48.160]                 {
[10:30:48.160]                   {
[10:30:48.160]                     base::local({
[10:30:48.160]                       has_future <- base::requireNamespace("future", 
[10:30:48.160]                         quietly = TRUE)
[10:30:48.160]                       if (has_future) {
[10:30:48.160]                         ns <- base::getNamespace("future")
[10:30:48.160]                         version <- ns[[".package"]][["version"]]
[10:30:48.160]                         if (is.null(version)) 
[10:30:48.160]                           version <- utils::packageVersion("future")
[10:30:48.160]                       }
[10:30:48.160]                       else {
[10:30:48.160]                         version <- NULL
[10:30:48.160]                       }
[10:30:48.160]                       if (!has_future || version < "1.8.0") {
[10:30:48.160]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.160]                           "", base::R.version$version.string), 
[10:30:48.160]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.160]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.160]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.160]                             "release", "version")], collapse = " "), 
[10:30:48.160]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.160]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.160]                           info)
[10:30:48.160]                         info <- base::paste(info, collapse = "; ")
[10:30:48.160]                         if (!has_future) {
[10:30:48.160]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.160]                             info)
[10:30:48.160]                         }
[10:30:48.160]                         else {
[10:30:48.160]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.160]                             info, version)
[10:30:48.160]                         }
[10:30:48.160]                         base::stop(msg)
[10:30:48.160]                       }
[10:30:48.160]                     })
[10:30:48.160]                   }
[10:30:48.160]                   ...future.strategy.old <- future::plan("list")
[10:30:48.160]                   options(future.plan = NULL)
[10:30:48.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.160]                 }
[10:30:48.160]                 ...future.workdir <- getwd()
[10:30:48.160]             }
[10:30:48.160]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.160]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.160]         }
[10:30:48.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.160]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.160]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.160]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.160]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.160]             base::names(...future.oldOptions))
[10:30:48.160]     }
[10:30:48.160]     if (FALSE) {
[10:30:48.160]     }
[10:30:48.160]     else {
[10:30:48.160]         if (TRUE) {
[10:30:48.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.160]                 open = "w")
[10:30:48.160]         }
[10:30:48.160]         else {
[10:30:48.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.160]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.160]         }
[10:30:48.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.160]             base::sink(type = "output", split = FALSE)
[10:30:48.160]             base::close(...future.stdout)
[10:30:48.160]         }, add = TRUE)
[10:30:48.160]     }
[10:30:48.160]     ...future.frame <- base::sys.nframe()
[10:30:48.160]     ...future.conditions <- base::list()
[10:30:48.160]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.160]     if (FALSE) {
[10:30:48.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.160]     }
[10:30:48.160]     ...future.result <- base::tryCatch({
[10:30:48.160]         base::withCallingHandlers({
[10:30:48.160]             ...future.value <- base::withVisible(base::local({
[10:30:48.160]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.160]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.160]                   ...future.globals.maxSize)) {
[10:30:48.160]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.160]                   on.exit(options(oopts), add = TRUE)
[10:30:48.160]                 }
[10:30:48.160]                 {
[10:30:48.160]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.160]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.160]                     USE.NAMES = FALSE)
[10:30:48.160]                   do.call(mapply, args = args)
[10:30:48.160]                 }
[10:30:48.160]             }))
[10:30:48.160]             future::FutureResult(value = ...future.value$value, 
[10:30:48.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.160]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.160]                     ...future.globalenv.names))
[10:30:48.160]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.160]         }, condition = base::local({
[10:30:48.160]             c <- base::c
[10:30:48.160]             inherits <- base::inherits
[10:30:48.160]             invokeRestart <- base::invokeRestart
[10:30:48.160]             length <- base::length
[10:30:48.160]             list <- base::list
[10:30:48.160]             seq.int <- base::seq.int
[10:30:48.160]             signalCondition <- base::signalCondition
[10:30:48.160]             sys.calls <- base::sys.calls
[10:30:48.160]             `[[` <- base::`[[`
[10:30:48.160]             `+` <- base::`+`
[10:30:48.160]             `<<-` <- base::`<<-`
[10:30:48.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.160]                   3L)]
[10:30:48.160]             }
[10:30:48.160]             function(cond) {
[10:30:48.160]                 is_error <- inherits(cond, "error")
[10:30:48.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.160]                   NULL)
[10:30:48.160]                 if (is_error) {
[10:30:48.160]                   sessionInformation <- function() {
[10:30:48.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.160]                       search = base::search(), system = base::Sys.info())
[10:30:48.160]                   }
[10:30:48.160]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.160]                     cond$call), session = sessionInformation(), 
[10:30:48.160]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.160]                   signalCondition(cond)
[10:30:48.160]                 }
[10:30:48.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.160]                 "immediateCondition"))) {
[10:30:48.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.160]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.160]                   if (TRUE && !signal) {
[10:30:48.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.160]                     {
[10:30:48.160]                       inherits <- base::inherits
[10:30:48.160]                       invokeRestart <- base::invokeRestart
[10:30:48.160]                       is.null <- base::is.null
[10:30:48.160]                       muffled <- FALSE
[10:30:48.160]                       if (inherits(cond, "message")) {
[10:30:48.160]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.160]                         if (muffled) 
[10:30:48.160]                           invokeRestart("muffleMessage")
[10:30:48.160]                       }
[10:30:48.160]                       else if (inherits(cond, "warning")) {
[10:30:48.160]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.160]                         if (muffled) 
[10:30:48.160]                           invokeRestart("muffleWarning")
[10:30:48.160]                       }
[10:30:48.160]                       else if (inherits(cond, "condition")) {
[10:30:48.160]                         if (!is.null(pattern)) {
[10:30:48.160]                           computeRestarts <- base::computeRestarts
[10:30:48.160]                           grepl <- base::grepl
[10:30:48.160]                           restarts <- computeRestarts(cond)
[10:30:48.160]                           for (restart in restarts) {
[10:30:48.160]                             name <- restart$name
[10:30:48.160]                             if (is.null(name)) 
[10:30:48.160]                               next
[10:30:48.160]                             if (!grepl(pattern, name)) 
[10:30:48.160]                               next
[10:30:48.160]                             invokeRestart(restart)
[10:30:48.160]                             muffled <- TRUE
[10:30:48.160]                             break
[10:30:48.160]                           }
[10:30:48.160]                         }
[10:30:48.160]                       }
[10:30:48.160]                       invisible(muffled)
[10:30:48.160]                     }
[10:30:48.160]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.160]                   }
[10:30:48.160]                 }
[10:30:48.160]                 else {
[10:30:48.160]                   if (TRUE) {
[10:30:48.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.160]                     {
[10:30:48.160]                       inherits <- base::inherits
[10:30:48.160]                       invokeRestart <- base::invokeRestart
[10:30:48.160]                       is.null <- base::is.null
[10:30:48.160]                       muffled <- FALSE
[10:30:48.160]                       if (inherits(cond, "message")) {
[10:30:48.160]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.160]                         if (muffled) 
[10:30:48.160]                           invokeRestart("muffleMessage")
[10:30:48.160]                       }
[10:30:48.160]                       else if (inherits(cond, "warning")) {
[10:30:48.160]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.160]                         if (muffled) 
[10:30:48.160]                           invokeRestart("muffleWarning")
[10:30:48.160]                       }
[10:30:48.160]                       else if (inherits(cond, "condition")) {
[10:30:48.160]                         if (!is.null(pattern)) {
[10:30:48.160]                           computeRestarts <- base::computeRestarts
[10:30:48.160]                           grepl <- base::grepl
[10:30:48.160]                           restarts <- computeRestarts(cond)
[10:30:48.160]                           for (restart in restarts) {
[10:30:48.160]                             name <- restart$name
[10:30:48.160]                             if (is.null(name)) 
[10:30:48.160]                               next
[10:30:48.160]                             if (!grepl(pattern, name)) 
[10:30:48.160]                               next
[10:30:48.160]                             invokeRestart(restart)
[10:30:48.160]                             muffled <- TRUE
[10:30:48.160]                             break
[10:30:48.160]                           }
[10:30:48.160]                         }
[10:30:48.160]                       }
[10:30:48.160]                       invisible(muffled)
[10:30:48.160]                     }
[10:30:48.160]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.160]                   }
[10:30:48.160]                 }
[10:30:48.160]             }
[10:30:48.160]         }))
[10:30:48.160]     }, error = function(ex) {
[10:30:48.160]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.160]                 ...future.rng), started = ...future.startTime, 
[10:30:48.160]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.160]             version = "1.8"), class = "FutureResult")
[10:30:48.160]     }, finally = {
[10:30:48.160]         if (!identical(...future.workdir, getwd())) 
[10:30:48.160]             setwd(...future.workdir)
[10:30:48.160]         {
[10:30:48.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.160]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.160]             }
[10:30:48.160]             base::options(...future.oldOptions)
[10:30:48.160]             if (.Platform$OS.type == "windows") {
[10:30:48.160]                 old_names <- names(...future.oldEnvVars)
[10:30:48.160]                 envs <- base::Sys.getenv()
[10:30:48.160]                 names <- names(envs)
[10:30:48.160]                 common <- intersect(names, old_names)
[10:30:48.160]                 added <- setdiff(names, old_names)
[10:30:48.160]                 removed <- setdiff(old_names, names)
[10:30:48.160]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.160]                   envs[common]]
[10:30:48.160]                 NAMES <- toupper(changed)
[10:30:48.160]                 args <- list()
[10:30:48.160]                 for (kk in seq_along(NAMES)) {
[10:30:48.160]                   name <- changed[[kk]]
[10:30:48.160]                   NAME <- NAMES[[kk]]
[10:30:48.160]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.160]                     next
[10:30:48.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.160]                 }
[10:30:48.160]                 NAMES <- toupper(added)
[10:30:48.160]                 for (kk in seq_along(NAMES)) {
[10:30:48.160]                   name <- added[[kk]]
[10:30:48.160]                   NAME <- NAMES[[kk]]
[10:30:48.160]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.160]                     next
[10:30:48.160]                   args[[name]] <- ""
[10:30:48.160]                 }
[10:30:48.160]                 NAMES <- toupper(removed)
[10:30:48.160]                 for (kk in seq_along(NAMES)) {
[10:30:48.160]                   name <- removed[[kk]]
[10:30:48.160]                   NAME <- NAMES[[kk]]
[10:30:48.160]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.160]                     next
[10:30:48.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.160]                 }
[10:30:48.160]                 if (length(args) > 0) 
[10:30:48.160]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.160]             }
[10:30:48.160]             else {
[10:30:48.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.160]             }
[10:30:48.160]             {
[10:30:48.160]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.160]                   0L) {
[10:30:48.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.160]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.160]                   base::options(opts)
[10:30:48.160]                 }
[10:30:48.160]                 {
[10:30:48.160]                   {
[10:30:48.160]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.160]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.160]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.160]                       inherits = FALSE)
[10:30:48.160]                     NULL
[10:30:48.160]                   }
[10:30:48.160]                   options(future.plan = NULL)
[10:30:48.160]                   if (is.na(NA_character_)) 
[10:30:48.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.160]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.160]                     .init = FALSE)
[10:30:48.160]                 }
[10:30:48.160]             }
[10:30:48.160]         }
[10:30:48.160]     })
[10:30:48.160]     if (TRUE) {
[10:30:48.160]         base::sink(type = "output", split = FALSE)
[10:30:48.160]         if (TRUE) {
[10:30:48.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.160]         }
[10:30:48.160]         else {
[10:30:48.160]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.160]         }
[10:30:48.160]         base::close(...future.stdout)
[10:30:48.160]         ...future.stdout <- NULL
[10:30:48.160]     }
[10:30:48.160]     ...future.result$conditions <- ...future.conditions
[10:30:48.160]     ...future.result$finished <- base::Sys.time()
[10:30:48.160]     ...future.result
[10:30:48.160] }
[10:30:48.162] assign_globals() ...
[10:30:48.162] List of 5
[10:30:48.162]  $ ...future.FUN            :function (x, ...)  
[10:30:48.162]  $ MoreArgs                 :List of 1
[10:30:48.162]   ..$ x: num 42
[10:30:48.162]  $ ...future.elements_ii    :List of 1
[10:30:48.162]   ..$ times:List of 4
[10:30:48.162]   .. ..$ : int 1
[10:30:48.162]   .. ..$ : int 2
[10:30:48.162]   .. ..$ : int 3
[10:30:48.162]   .. ..$ : int 4
[10:30:48.162]  $ ...future.seeds_ii       : NULL
[10:30:48.162]  $ ...future.globals.maxSize: NULL
[10:30:48.162]  - attr(*, "where")=List of 5
[10:30:48.162]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.162]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.162]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.162]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.162]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.162]  - attr(*, "resolved")= logi FALSE
[10:30:48.162]  - attr(*, "total_size")= num 336
[10:30:48.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.162]  - attr(*, "already-done")= logi TRUE
[10:30:48.168] - copied ‘...future.FUN’ to environment
[10:30:48.168] - copied ‘MoreArgs’ to environment
[10:30:48.168] - copied ‘...future.elements_ii’ to environment
[10:30:48.168] - copied ‘...future.seeds_ii’ to environment
[10:30:48.168] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.168] assign_globals() ... done
[10:30:48.168] plan(): Setting new future strategy stack:
[10:30:48.168] List of future strategies:
[10:30:48.168] 1. sequential:
[10:30:48.168]    - args: function (..., envir = parent.frame())
[10:30:48.168]    - tweaked: FALSE
[10:30:48.168]    - call: NULL
[10:30:48.169] plan(): nbrOfWorkers() = 1
[10:30:48.170] plan(): Setting new future strategy stack:
[10:30:48.170] List of future strategies:
[10:30:48.170] 1. sequential:
[10:30:48.170]    - args: function (..., envir = parent.frame())
[10:30:48.170]    - tweaked: FALSE
[10:30:48.170]    - call: plan(strategy)
[10:30:48.170] plan(): nbrOfWorkers() = 1
[10:30:48.170] SequentialFuture started (and completed)
[10:30:48.172] - Launch lazy future ... done
[10:30:48.172] run() for ‘SequentialFuture’ ... done
[10:30:48.172] Created future:
[10:30:48.172] SequentialFuture:
[10:30:48.172] Label: ‘future_mapply-1’
[10:30:48.172] Expression:
[10:30:48.172] {
[10:30:48.172]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.172]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.172]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.172]         on.exit(options(oopts), add = TRUE)
[10:30:48.172]     }
[10:30:48.172]     {
[10:30:48.172]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.172]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.172]         do.call(mapply, args = args)
[10:30:48.172]     }
[10:30:48.172] }
[10:30:48.172] Lazy evaluation: FALSE
[10:30:48.172] Asynchronous evaluation: FALSE
[10:30:48.172] Local evaluation: TRUE
[10:30:48.172] Environment: R_GlobalEnv
[10:30:48.172] Capture standard output: TRUE
[10:30:48.172] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.172] Globals: 5 objects totaling 336 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.172] Packages: <none>
[10:30:48.172] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.172] Resolved: TRUE
[10:30:48.172] Value: 280 bytes of class ‘list’
[10:30:48.172] Early signaling: FALSE
[10:30:48.172] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.172] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.173] Chunk #1 of 1 ... DONE
[10:30:48.174] Launching 1 futures (chunks) ... DONE
[10:30:48.174] Resolving 1 futures (chunks) ...
[10:30:48.174] resolve() on list ...
[10:30:48.174]  recursive: 0
[10:30:48.174]  length: 1
[10:30:48.174] 
[10:30:48.174] resolved() for ‘SequentialFuture’ ...
[10:30:48.174] - state: ‘finished’
[10:30:48.174] - run: TRUE
[10:30:48.174] - result: ‘FutureResult’
[10:30:48.174] resolved() for ‘SequentialFuture’ ... done
[10:30:48.175] Future #1
[10:30:48.175] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.175] - nx: 1
[10:30:48.175] - relay: TRUE
[10:30:48.175] - stdout: TRUE
[10:30:48.175] - signal: TRUE
[10:30:48.175] - resignal: FALSE
[10:30:48.175] - force: TRUE
[10:30:48.175] - relayed: [n=1] FALSE
[10:30:48.175] - queued futures: [n=1] FALSE
[10:30:48.175]  - until=1
[10:30:48.176]  - relaying element #1
[10:30:48.176] - relayed: [n=1] TRUE
[10:30:48.176] - queued futures: [n=1] TRUE
[10:30:48.176] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.176]  length: 0 (resolved future 1)
[10:30:48.176] Relaying remaining futures
[10:30:48.176] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.176] - nx: 1
[10:30:48.176] - relay: TRUE
[10:30:48.176] - stdout: TRUE
[10:30:48.177] - signal: TRUE
[10:30:48.177] - resignal: FALSE
[10:30:48.177] - force: TRUE
[10:30:48.177] - relayed: [n=1] TRUE
[10:30:48.177] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.177] - relayed: [n=1] TRUE
[10:30:48.177] - queued futures: [n=1] TRUE
[10:30:48.177] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.177] resolve() on list ... DONE
[10:30:48.177]  - Number of value chunks collected: 1
[10:30:48.178] Resolving 1 futures (chunks) ... DONE
[10:30:48.178] Reducing values from 1 chunks ...
[10:30:48.178]  - Number of values collected after concatenation: 4
[10:30:48.178]  - Number of values expected: 4
[10:30:48.178] Reducing values from 1 chunks ... DONE
[10:30:48.178] future_mapply() ... DONE
[10:30:48.178] future_mapply() ...
[10:30:48.178] Number of chunks: 1
[10:30:48.178] getGlobalsAndPackagesXApply() ...
[10:30:48.178]  - future.globals: TRUE
[10:30:48.179] getGlobalsAndPackages() ...
[10:30:48.179] Searching for globals...
[10:30:48.180] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:30:48.180] Searching for globals ... DONE
[10:30:48.180] Resolving globals: FALSE
[10:30:48.180] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[10:30:48.181] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[10:30:48.181] - globals: [1] ‘FUN’
[10:30:48.181] 
[10:30:48.181] getGlobalsAndPackages() ... DONE
[10:30:48.181]  - globals found/used: [n=1] ‘FUN’
[10:30:48.181]  - needed namespaces: [n=0] 
[10:30:48.181] Finding globals ... DONE
[10:30:48.181] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.182] List of 2
[10:30:48.182]  $ ...future.FUN:function (x, y)  
[10:30:48.182]  $ MoreArgs     : NULL
[10:30:48.182]  - attr(*, "where")=List of 2
[10:30:48.182]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.182]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.182]  - attr(*, "resolved")= logi FALSE
[10:30:48.182]  - attr(*, "total_size")= num NA
[10:30:48.184] Packages to be attached in all futures: [n=0] 
[10:30:48.184] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.184] Number of futures (= number of chunks): 1
[10:30:48.184] Launching 1 futures (chunks) ...
[10:30:48.184] Chunk #1 of 1 ...
[10:30:48.185]  - Finding globals in '...' for chunk #1 ...
[10:30:48.185] getGlobalsAndPackages() ...
[10:30:48.185] Searching for globals...
[10:30:48.185] 
[10:30:48.185] Searching for globals ... DONE
[10:30:48.185] - globals: [0] <none>
[10:30:48.185] getGlobalsAndPackages() ... DONE
[10:30:48.185]    + additional globals found: [n=0] 
[10:30:48.186]    + additional namespaces needed: [n=0] 
[10:30:48.186]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.186]  - seeds: <none>
[10:30:48.186]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.186] getGlobalsAndPackages() ...
[10:30:48.186] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.186] Resolving globals: FALSE
[10:30:48.187] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[10:30:48.187] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.187] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.187] 
[10:30:48.187] getGlobalsAndPackages() ... DONE
[10:30:48.188] run() for ‘Future’ ...
[10:30:48.188] - state: ‘created’
[10:30:48.188] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.188] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.188] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.188]   - Field: ‘label’
[10:30:48.189]   - Field: ‘local’
[10:30:48.189]   - Field: ‘owner’
[10:30:48.189]   - Field: ‘envir’
[10:30:48.189]   - Field: ‘packages’
[10:30:48.189]   - Field: ‘gc’
[10:30:48.189]   - Field: ‘conditions’
[10:30:48.189]   - Field: ‘expr’
[10:30:48.189]   - Field: ‘uuid’
[10:30:48.189]   - Field: ‘seed’
[10:30:48.189]   - Field: ‘version’
[10:30:48.189]   - Field: ‘result’
[10:30:48.190]   - Field: ‘asynchronous’
[10:30:48.190]   - Field: ‘calls’
[10:30:48.190]   - Field: ‘globals’
[10:30:48.190]   - Field: ‘stdout’
[10:30:48.190]   - Field: ‘earlySignal’
[10:30:48.190]   - Field: ‘lazy’
[10:30:48.190]   - Field: ‘state’
[10:30:48.190] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.190] - Launch lazy future ...
[10:30:48.190] Packages needed by the future expression (n = 0): <none>
[10:30:48.191] Packages needed by future strategies (n = 0): <none>
[10:30:48.191] {
[10:30:48.191]     {
[10:30:48.191]         {
[10:30:48.191]             ...future.startTime <- base::Sys.time()
[10:30:48.191]             {
[10:30:48.191]                 {
[10:30:48.191]                   {
[10:30:48.191]                     base::local({
[10:30:48.191]                       has_future <- base::requireNamespace("future", 
[10:30:48.191]                         quietly = TRUE)
[10:30:48.191]                       if (has_future) {
[10:30:48.191]                         ns <- base::getNamespace("future")
[10:30:48.191]                         version <- ns[[".package"]][["version"]]
[10:30:48.191]                         if (is.null(version)) 
[10:30:48.191]                           version <- utils::packageVersion("future")
[10:30:48.191]                       }
[10:30:48.191]                       else {
[10:30:48.191]                         version <- NULL
[10:30:48.191]                       }
[10:30:48.191]                       if (!has_future || version < "1.8.0") {
[10:30:48.191]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.191]                           "", base::R.version$version.string), 
[10:30:48.191]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.191]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.191]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.191]                             "release", "version")], collapse = " "), 
[10:30:48.191]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.191]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.191]                           info)
[10:30:48.191]                         info <- base::paste(info, collapse = "; ")
[10:30:48.191]                         if (!has_future) {
[10:30:48.191]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.191]                             info)
[10:30:48.191]                         }
[10:30:48.191]                         else {
[10:30:48.191]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.191]                             info, version)
[10:30:48.191]                         }
[10:30:48.191]                         base::stop(msg)
[10:30:48.191]                       }
[10:30:48.191]                     })
[10:30:48.191]                   }
[10:30:48.191]                   ...future.strategy.old <- future::plan("list")
[10:30:48.191]                   options(future.plan = NULL)
[10:30:48.191]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.191]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.191]                 }
[10:30:48.191]                 ...future.workdir <- getwd()
[10:30:48.191]             }
[10:30:48.191]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.191]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.191]         }
[10:30:48.191]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.191]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.191]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.191]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.191]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.191]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.191]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.191]             base::names(...future.oldOptions))
[10:30:48.191]     }
[10:30:48.191]     if (FALSE) {
[10:30:48.191]     }
[10:30:48.191]     else {
[10:30:48.191]         if (TRUE) {
[10:30:48.191]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.191]                 open = "w")
[10:30:48.191]         }
[10:30:48.191]         else {
[10:30:48.191]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.191]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.191]         }
[10:30:48.191]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.191]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.191]             base::sink(type = "output", split = FALSE)
[10:30:48.191]             base::close(...future.stdout)
[10:30:48.191]         }, add = TRUE)
[10:30:48.191]     }
[10:30:48.191]     ...future.frame <- base::sys.nframe()
[10:30:48.191]     ...future.conditions <- base::list()
[10:30:48.191]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.191]     if (FALSE) {
[10:30:48.191]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.191]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.191]     }
[10:30:48.191]     ...future.result <- base::tryCatch({
[10:30:48.191]         base::withCallingHandlers({
[10:30:48.191]             ...future.value <- base::withVisible(base::local({
[10:30:48.191]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.191]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.191]                   ...future.globals.maxSize)) {
[10:30:48.191]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.191]                   on.exit(options(oopts), add = TRUE)
[10:30:48.191]                 }
[10:30:48.191]                 {
[10:30:48.191]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.191]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.191]                     USE.NAMES = FALSE)
[10:30:48.191]                   do.call(mapply, args = args)
[10:30:48.191]                 }
[10:30:48.191]             }))
[10:30:48.191]             future::FutureResult(value = ...future.value$value, 
[10:30:48.191]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.191]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.191]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.191]                     ...future.globalenv.names))
[10:30:48.191]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.191]         }, condition = base::local({
[10:30:48.191]             c <- base::c
[10:30:48.191]             inherits <- base::inherits
[10:30:48.191]             invokeRestart <- base::invokeRestart
[10:30:48.191]             length <- base::length
[10:30:48.191]             list <- base::list
[10:30:48.191]             seq.int <- base::seq.int
[10:30:48.191]             signalCondition <- base::signalCondition
[10:30:48.191]             sys.calls <- base::sys.calls
[10:30:48.191]             `[[` <- base::`[[`
[10:30:48.191]             `+` <- base::`+`
[10:30:48.191]             `<<-` <- base::`<<-`
[10:30:48.191]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.191]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.191]                   3L)]
[10:30:48.191]             }
[10:30:48.191]             function(cond) {
[10:30:48.191]                 is_error <- inherits(cond, "error")
[10:30:48.191]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.191]                   NULL)
[10:30:48.191]                 if (is_error) {
[10:30:48.191]                   sessionInformation <- function() {
[10:30:48.191]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.191]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.191]                       search = base::search(), system = base::Sys.info())
[10:30:48.191]                   }
[10:30:48.191]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.191]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.191]                     cond$call), session = sessionInformation(), 
[10:30:48.191]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.191]                   signalCondition(cond)
[10:30:48.191]                 }
[10:30:48.191]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.191]                 "immediateCondition"))) {
[10:30:48.191]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.191]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.191]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.191]                   if (TRUE && !signal) {
[10:30:48.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.191]                     {
[10:30:48.191]                       inherits <- base::inherits
[10:30:48.191]                       invokeRestart <- base::invokeRestart
[10:30:48.191]                       is.null <- base::is.null
[10:30:48.191]                       muffled <- FALSE
[10:30:48.191]                       if (inherits(cond, "message")) {
[10:30:48.191]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.191]                         if (muffled) 
[10:30:48.191]                           invokeRestart("muffleMessage")
[10:30:48.191]                       }
[10:30:48.191]                       else if (inherits(cond, "warning")) {
[10:30:48.191]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.191]                         if (muffled) 
[10:30:48.191]                           invokeRestart("muffleWarning")
[10:30:48.191]                       }
[10:30:48.191]                       else if (inherits(cond, "condition")) {
[10:30:48.191]                         if (!is.null(pattern)) {
[10:30:48.191]                           computeRestarts <- base::computeRestarts
[10:30:48.191]                           grepl <- base::grepl
[10:30:48.191]                           restarts <- computeRestarts(cond)
[10:30:48.191]                           for (restart in restarts) {
[10:30:48.191]                             name <- restart$name
[10:30:48.191]                             if (is.null(name)) 
[10:30:48.191]                               next
[10:30:48.191]                             if (!grepl(pattern, name)) 
[10:30:48.191]                               next
[10:30:48.191]                             invokeRestart(restart)
[10:30:48.191]                             muffled <- TRUE
[10:30:48.191]                             break
[10:30:48.191]                           }
[10:30:48.191]                         }
[10:30:48.191]                       }
[10:30:48.191]                       invisible(muffled)
[10:30:48.191]                     }
[10:30:48.191]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.191]                   }
[10:30:48.191]                 }
[10:30:48.191]                 else {
[10:30:48.191]                   if (TRUE) {
[10:30:48.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.191]                     {
[10:30:48.191]                       inherits <- base::inherits
[10:30:48.191]                       invokeRestart <- base::invokeRestart
[10:30:48.191]                       is.null <- base::is.null
[10:30:48.191]                       muffled <- FALSE
[10:30:48.191]                       if (inherits(cond, "message")) {
[10:30:48.191]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.191]                         if (muffled) 
[10:30:48.191]                           invokeRestart("muffleMessage")
[10:30:48.191]                       }
[10:30:48.191]                       else if (inherits(cond, "warning")) {
[10:30:48.191]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.191]                         if (muffled) 
[10:30:48.191]                           invokeRestart("muffleWarning")
[10:30:48.191]                       }
[10:30:48.191]                       else if (inherits(cond, "condition")) {
[10:30:48.191]                         if (!is.null(pattern)) {
[10:30:48.191]                           computeRestarts <- base::computeRestarts
[10:30:48.191]                           grepl <- base::grepl
[10:30:48.191]                           restarts <- computeRestarts(cond)
[10:30:48.191]                           for (restart in restarts) {
[10:30:48.191]                             name <- restart$name
[10:30:48.191]                             if (is.null(name)) 
[10:30:48.191]                               next
[10:30:48.191]                             if (!grepl(pattern, name)) 
[10:30:48.191]                               next
[10:30:48.191]                             invokeRestart(restart)
[10:30:48.191]                             muffled <- TRUE
[10:30:48.191]                             break
[10:30:48.191]                           }
[10:30:48.191]                         }
[10:30:48.191]                       }
[10:30:48.191]                       invisible(muffled)
[10:30:48.191]                     }
[10:30:48.191]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.191]                   }
[10:30:48.191]                 }
[10:30:48.191]             }
[10:30:48.191]         }))
[10:30:48.191]     }, error = function(ex) {
[10:30:48.191]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.191]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.191]                 ...future.rng), started = ...future.startTime, 
[10:30:48.191]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.191]             version = "1.8"), class = "FutureResult")
[10:30:48.191]     }, finally = {
[10:30:48.191]         if (!identical(...future.workdir, getwd())) 
[10:30:48.191]             setwd(...future.workdir)
[10:30:48.191]         {
[10:30:48.191]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.191]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.191]             }
[10:30:48.191]             base::options(...future.oldOptions)
[10:30:48.191]             if (.Platform$OS.type == "windows") {
[10:30:48.191]                 old_names <- names(...future.oldEnvVars)
[10:30:48.191]                 envs <- base::Sys.getenv()
[10:30:48.191]                 names <- names(envs)
[10:30:48.191]                 common <- intersect(names, old_names)
[10:30:48.191]                 added <- setdiff(names, old_names)
[10:30:48.191]                 removed <- setdiff(old_names, names)
[10:30:48.191]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.191]                   envs[common]]
[10:30:48.191]                 NAMES <- toupper(changed)
[10:30:48.191]                 args <- list()
[10:30:48.191]                 for (kk in seq_along(NAMES)) {
[10:30:48.191]                   name <- changed[[kk]]
[10:30:48.191]                   NAME <- NAMES[[kk]]
[10:30:48.191]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.191]                     next
[10:30:48.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.191]                 }
[10:30:48.191]                 NAMES <- toupper(added)
[10:30:48.191]                 for (kk in seq_along(NAMES)) {
[10:30:48.191]                   name <- added[[kk]]
[10:30:48.191]                   NAME <- NAMES[[kk]]
[10:30:48.191]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.191]                     next
[10:30:48.191]                   args[[name]] <- ""
[10:30:48.191]                 }
[10:30:48.191]                 NAMES <- toupper(removed)
[10:30:48.191]                 for (kk in seq_along(NAMES)) {
[10:30:48.191]                   name <- removed[[kk]]
[10:30:48.191]                   NAME <- NAMES[[kk]]
[10:30:48.191]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.191]                     next
[10:30:48.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.191]                 }
[10:30:48.191]                 if (length(args) > 0) 
[10:30:48.191]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.191]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.191]             }
[10:30:48.191]             else {
[10:30:48.191]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.191]             }
[10:30:48.191]             {
[10:30:48.191]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.191]                   0L) {
[10:30:48.191]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.191]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.191]                   base::options(opts)
[10:30:48.191]                 }
[10:30:48.191]                 {
[10:30:48.191]                   {
[10:30:48.191]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.191]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.191]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.191]                       inherits = FALSE)
[10:30:48.191]                     NULL
[10:30:48.191]                   }
[10:30:48.191]                   options(future.plan = NULL)
[10:30:48.191]                   if (is.na(NA_character_)) 
[10:30:48.191]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.191]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.191]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.191]                     .init = FALSE)
[10:30:48.191]                 }
[10:30:48.191]             }
[10:30:48.191]         }
[10:30:48.191]     })
[10:30:48.191]     if (TRUE) {
[10:30:48.191]         base::sink(type = "output", split = FALSE)
[10:30:48.191]         if (TRUE) {
[10:30:48.191]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.191]         }
[10:30:48.191]         else {
[10:30:48.191]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.191]         }
[10:30:48.191]         base::close(...future.stdout)
[10:30:48.191]         ...future.stdout <- NULL
[10:30:48.191]     }
[10:30:48.191]     ...future.result$conditions <- ...future.conditions
[10:30:48.191]     ...future.result$finished <- base::Sys.time()
[10:30:48.191]     ...future.result
[10:30:48.191] }
[10:30:48.193] assign_globals() ...
[10:30:48.193] List of 5
[10:30:48.193]  $ ...future.FUN            :function (x, y)  
[10:30:48.193]  $ MoreArgs                 : NULL
[10:30:48.193]  $ ...future.elements_ii    :List of 2
[10:30:48.193]   ..$ :List of 3
[10:30:48.193]   .. ..$ a: num 1
[10:30:48.193]   .. ..$ b: num 2
[10:30:48.193]   .. ..$ c: num 3
[10:30:48.193]   ..$ :List of 3
[10:30:48.193]   .. ..$ A: num 10
[10:30:48.193]   .. ..$ B: num 0
[10:30:48.193]   .. ..$ C: num -10
[10:30:48.193]  $ ...future.seeds_ii       : NULL
[10:30:48.193]  $ ...future.globals.maxSize: NULL
[10:30:48.193]  - attr(*, "where")=List of 5
[10:30:48.193]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.193]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.193]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.193]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.193]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.193]  - attr(*, "resolved")= logi FALSE
[10:30:48.193]  - attr(*, "total_size")= num 2312
[10:30:48.193]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.193]  - attr(*, "already-done")= logi TRUE
[10:30:48.201] - reassign environment for ‘...future.FUN’
[10:30:48.201] - copied ‘...future.FUN’ to environment
[10:30:48.201] - copied ‘MoreArgs’ to environment
[10:30:48.201] - copied ‘...future.elements_ii’ to environment
[10:30:48.201] - copied ‘...future.seeds_ii’ to environment
[10:30:48.201] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.202] assign_globals() ... done
[10:30:48.202] plan(): Setting new future strategy stack:
[10:30:48.202] List of future strategies:
[10:30:48.202] 1. sequential:
[10:30:48.202]    - args: function (..., envir = parent.frame())
[10:30:48.202]    - tweaked: FALSE
[10:30:48.202]    - call: NULL
[10:30:48.202] plan(): nbrOfWorkers() = 1
[10:30:48.203] plan(): Setting new future strategy stack:
[10:30:48.203] List of future strategies:
[10:30:48.203] 1. sequential:
[10:30:48.203]    - args: function (..., envir = parent.frame())
[10:30:48.203]    - tweaked: FALSE
[10:30:48.203]    - call: plan(strategy)
[10:30:48.203] plan(): nbrOfWorkers() = 1
[10:30:48.204] SequentialFuture started (and completed)
[10:30:48.204] - Launch lazy future ... done
[10:30:48.204] run() for ‘SequentialFuture’ ... done
[10:30:48.204] Created future:
[10:30:48.204] SequentialFuture:
[10:30:48.204] Label: ‘future_mapply-1’
[10:30:48.204] Expression:
[10:30:48.204] {
[10:30:48.204]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.204]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.204]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.204]         on.exit(options(oopts), add = TRUE)
[10:30:48.204]     }
[10:30:48.204]     {
[10:30:48.204]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.204]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.204]         do.call(mapply, args = args)
[10:30:48.204]     }
[10:30:48.204] }
[10:30:48.204] Lazy evaluation: FALSE
[10:30:48.204] Asynchronous evaluation: FALSE
[10:30:48.204] Local evaluation: TRUE
[10:30:48.204] Environment: R_GlobalEnv
[10:30:48.204] Capture standard output: TRUE
[10:30:48.204] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.204] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.204] Packages: <none>
[10:30:48.204] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.204] Resolved: TRUE
[10:30:48.204] Value: 200 bytes of class ‘list’
[10:30:48.204] Early signaling: FALSE
[10:30:48.204] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.204] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.205] Chunk #1 of 1 ... DONE
[10:30:48.205] Launching 1 futures (chunks) ... DONE
[10:30:48.205] Resolving 1 futures (chunks) ...
[10:30:48.205] resolve() on list ...
[10:30:48.205]  recursive: 0
[10:30:48.205]  length: 1
[10:30:48.205] 
[10:30:48.206] resolved() for ‘SequentialFuture’ ...
[10:30:48.206] - state: ‘finished’
[10:30:48.206] - run: TRUE
[10:30:48.206] - result: ‘FutureResult’
[10:30:48.206] resolved() for ‘SequentialFuture’ ... done
[10:30:48.206] Future #1
[10:30:48.206] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.206] - nx: 1
[10:30:48.206] - relay: TRUE
[10:30:48.206] - stdout: TRUE
[10:30:48.207] - signal: TRUE
[10:30:48.207] - resignal: FALSE
[10:30:48.207] - force: TRUE
[10:30:48.207] - relayed: [n=1] FALSE
[10:30:48.207] - queued futures: [n=1] FALSE
[10:30:48.207]  - until=1
[10:30:48.207]  - relaying element #1
[10:30:48.207] - relayed: [n=1] TRUE
[10:30:48.207] - queued futures: [n=1] TRUE
[10:30:48.207] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.208]  length: 0 (resolved future 1)
[10:30:48.208] Relaying remaining futures
[10:30:48.208] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.208] - nx: 1
[10:30:48.208] - relay: TRUE
[10:30:48.208] - stdout: TRUE
[10:30:48.208] - signal: TRUE
[10:30:48.208] - resignal: FALSE
[10:30:48.208] - force: TRUE
[10:30:48.208] - relayed: [n=1] TRUE
[10:30:48.208] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.209] - relayed: [n=1] TRUE
[10:30:48.209] - queued futures: [n=1] TRUE
[10:30:48.209] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.209] resolve() on list ... DONE
[10:30:48.209]  - Number of value chunks collected: 1
[10:30:48.209] Resolving 1 futures (chunks) ... DONE
[10:30:48.209] Reducing values from 1 chunks ...
[10:30:48.209]  - Number of values collected after concatenation: 3
[10:30:48.209]  - Number of values expected: 3
[10:30:48.209] Reducing values from 1 chunks ... DONE
[10:30:48.209] future_mapply() ... DONE
- future_.mapply()
[10:30:48.210] future_mapply() ...
[10:30:48.210] Number of chunks: 1
[10:30:48.211] getGlobalsAndPackagesXApply() ...
[10:30:48.211]  - future.globals: TRUE
[10:30:48.211] getGlobalsAndPackages() ...
[10:30:48.211] Searching for globals...
[10:30:48.212] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:30:48.212] Searching for globals ... DONE
[10:30:48.212] Resolving globals: FALSE
[10:30:48.213] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[10:30:48.213] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[10:30:48.213] - globals: [1] ‘FUN’
[10:30:48.213] 
[10:30:48.213] getGlobalsAndPackages() ... DONE
[10:30:48.213]  - globals found/used: [n=1] ‘FUN’
[10:30:48.213]  - needed namespaces: [n=0] 
[10:30:48.213] Finding globals ... DONE
[10:30:48.214] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.214] List of 2
[10:30:48.214]  $ ...future.FUN:function (x, y)  
[10:30:48.214]  $ MoreArgs     : list()
[10:30:48.214]  - attr(*, "where")=List of 2
[10:30:48.214]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.214]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.214]  - attr(*, "resolved")= logi FALSE
[10:30:48.214]  - attr(*, "total_size")= num NA
[10:30:48.216] Packages to be attached in all futures: [n=0] 
[10:30:48.216] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.216] Number of futures (= number of chunks): 1
[10:30:48.217] Launching 1 futures (chunks) ...
[10:30:48.217] Chunk #1 of 1 ...
[10:30:48.217]  - Finding globals in '...' for chunk #1 ...
[10:30:48.217] getGlobalsAndPackages() ...
[10:30:48.217] Searching for globals...
[10:30:48.217] 
[10:30:48.217] Searching for globals ... DONE
[10:30:48.218] - globals: [0] <none>
[10:30:48.218] getGlobalsAndPackages() ... DONE
[10:30:48.218]    + additional globals found: [n=0] 
[10:30:48.218]    + additional namespaces needed: [n=0] 
[10:30:48.218]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.218]  - seeds: <none>
[10:30:48.218]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.218] getGlobalsAndPackages() ...
[10:30:48.218] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.218] Resolving globals: FALSE
[10:30:48.221] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[10:30:48.221] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:48.221] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.221] 
[10:30:48.221] getGlobalsAndPackages() ... DONE
[10:30:48.222] run() for ‘Future’ ...
[10:30:48.222] - state: ‘created’
[10:30:48.222] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.222] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.222] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.222]   - Field: ‘label’
[10:30:48.223]   - Field: ‘local’
[10:30:48.223]   - Field: ‘owner’
[10:30:48.223]   - Field: ‘envir’
[10:30:48.223]   - Field: ‘packages’
[10:30:48.223]   - Field: ‘gc’
[10:30:48.223]   - Field: ‘conditions’
[10:30:48.223]   - Field: ‘expr’
[10:30:48.223]   - Field: ‘uuid’
[10:30:48.223]   - Field: ‘seed’
[10:30:48.223]   - Field: ‘version’
[10:30:48.223]   - Field: ‘result’
[10:30:48.224]   - Field: ‘asynchronous’
[10:30:48.224]   - Field: ‘calls’
[10:30:48.224]   - Field: ‘globals’
[10:30:48.224]   - Field: ‘stdout’
[10:30:48.224]   - Field: ‘earlySignal’
[10:30:48.224]   - Field: ‘lazy’
[10:30:48.224]   - Field: ‘state’
[10:30:48.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.224] - Launch lazy future ...
[10:30:48.224] Packages needed by the future expression (n = 0): <none>
[10:30:48.225] Packages needed by future strategies (n = 0): <none>
[10:30:48.225] {
[10:30:48.225]     {
[10:30:48.225]         {
[10:30:48.225]             ...future.startTime <- base::Sys.time()
[10:30:48.225]             {
[10:30:48.225]                 {
[10:30:48.225]                   {
[10:30:48.225]                     base::local({
[10:30:48.225]                       has_future <- base::requireNamespace("future", 
[10:30:48.225]                         quietly = TRUE)
[10:30:48.225]                       if (has_future) {
[10:30:48.225]                         ns <- base::getNamespace("future")
[10:30:48.225]                         version <- ns[[".package"]][["version"]]
[10:30:48.225]                         if (is.null(version)) 
[10:30:48.225]                           version <- utils::packageVersion("future")
[10:30:48.225]                       }
[10:30:48.225]                       else {
[10:30:48.225]                         version <- NULL
[10:30:48.225]                       }
[10:30:48.225]                       if (!has_future || version < "1.8.0") {
[10:30:48.225]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.225]                           "", base::R.version$version.string), 
[10:30:48.225]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.225]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.225]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.225]                             "release", "version")], collapse = " "), 
[10:30:48.225]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.225]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.225]                           info)
[10:30:48.225]                         info <- base::paste(info, collapse = "; ")
[10:30:48.225]                         if (!has_future) {
[10:30:48.225]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.225]                             info)
[10:30:48.225]                         }
[10:30:48.225]                         else {
[10:30:48.225]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.225]                             info, version)
[10:30:48.225]                         }
[10:30:48.225]                         base::stop(msg)
[10:30:48.225]                       }
[10:30:48.225]                     })
[10:30:48.225]                   }
[10:30:48.225]                   ...future.strategy.old <- future::plan("list")
[10:30:48.225]                   options(future.plan = NULL)
[10:30:48.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.225]                 }
[10:30:48.225]                 ...future.workdir <- getwd()
[10:30:48.225]             }
[10:30:48.225]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.225]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.225]         }
[10:30:48.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.225]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.225]             base::names(...future.oldOptions))
[10:30:48.225]     }
[10:30:48.225]     if (FALSE) {
[10:30:48.225]     }
[10:30:48.225]     else {
[10:30:48.225]         if (TRUE) {
[10:30:48.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.225]                 open = "w")
[10:30:48.225]         }
[10:30:48.225]         else {
[10:30:48.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.225]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.225]         }
[10:30:48.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.225]             base::sink(type = "output", split = FALSE)
[10:30:48.225]             base::close(...future.stdout)
[10:30:48.225]         }, add = TRUE)
[10:30:48.225]     }
[10:30:48.225]     ...future.frame <- base::sys.nframe()
[10:30:48.225]     ...future.conditions <- base::list()
[10:30:48.225]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.225]     if (FALSE) {
[10:30:48.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.225]     }
[10:30:48.225]     ...future.result <- base::tryCatch({
[10:30:48.225]         base::withCallingHandlers({
[10:30:48.225]             ...future.value <- base::withVisible(base::local({
[10:30:48.225]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.225]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.225]                   ...future.globals.maxSize)) {
[10:30:48.225]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.225]                   on.exit(options(oopts), add = TRUE)
[10:30:48.225]                 }
[10:30:48.225]                 {
[10:30:48.225]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.225]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.225]                     USE.NAMES = FALSE)
[10:30:48.225]                   do.call(mapply, args = args)
[10:30:48.225]                 }
[10:30:48.225]             }))
[10:30:48.225]             future::FutureResult(value = ...future.value$value, 
[10:30:48.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.225]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.225]                     ...future.globalenv.names))
[10:30:48.225]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.225]         }, condition = base::local({
[10:30:48.225]             c <- base::c
[10:30:48.225]             inherits <- base::inherits
[10:30:48.225]             invokeRestart <- base::invokeRestart
[10:30:48.225]             length <- base::length
[10:30:48.225]             list <- base::list
[10:30:48.225]             seq.int <- base::seq.int
[10:30:48.225]             signalCondition <- base::signalCondition
[10:30:48.225]             sys.calls <- base::sys.calls
[10:30:48.225]             `[[` <- base::`[[`
[10:30:48.225]             `+` <- base::`+`
[10:30:48.225]             `<<-` <- base::`<<-`
[10:30:48.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.225]                   3L)]
[10:30:48.225]             }
[10:30:48.225]             function(cond) {
[10:30:48.225]                 is_error <- inherits(cond, "error")
[10:30:48.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.225]                   NULL)
[10:30:48.225]                 if (is_error) {
[10:30:48.225]                   sessionInformation <- function() {
[10:30:48.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.225]                       search = base::search(), system = base::Sys.info())
[10:30:48.225]                   }
[10:30:48.225]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.225]                     cond$call), session = sessionInformation(), 
[10:30:48.225]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.225]                   signalCondition(cond)
[10:30:48.225]                 }
[10:30:48.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.225]                 "immediateCondition"))) {
[10:30:48.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.225]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.225]                   if (TRUE && !signal) {
[10:30:48.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.225]                     {
[10:30:48.225]                       inherits <- base::inherits
[10:30:48.225]                       invokeRestart <- base::invokeRestart
[10:30:48.225]                       is.null <- base::is.null
[10:30:48.225]                       muffled <- FALSE
[10:30:48.225]                       if (inherits(cond, "message")) {
[10:30:48.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.225]                         if (muffled) 
[10:30:48.225]                           invokeRestart("muffleMessage")
[10:30:48.225]                       }
[10:30:48.225]                       else if (inherits(cond, "warning")) {
[10:30:48.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.225]                         if (muffled) 
[10:30:48.225]                           invokeRestart("muffleWarning")
[10:30:48.225]                       }
[10:30:48.225]                       else if (inherits(cond, "condition")) {
[10:30:48.225]                         if (!is.null(pattern)) {
[10:30:48.225]                           computeRestarts <- base::computeRestarts
[10:30:48.225]                           grepl <- base::grepl
[10:30:48.225]                           restarts <- computeRestarts(cond)
[10:30:48.225]                           for (restart in restarts) {
[10:30:48.225]                             name <- restart$name
[10:30:48.225]                             if (is.null(name)) 
[10:30:48.225]                               next
[10:30:48.225]                             if (!grepl(pattern, name)) 
[10:30:48.225]                               next
[10:30:48.225]                             invokeRestart(restart)
[10:30:48.225]                             muffled <- TRUE
[10:30:48.225]                             break
[10:30:48.225]                           }
[10:30:48.225]                         }
[10:30:48.225]                       }
[10:30:48.225]                       invisible(muffled)
[10:30:48.225]                     }
[10:30:48.225]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.225]                   }
[10:30:48.225]                 }
[10:30:48.225]                 else {
[10:30:48.225]                   if (TRUE) {
[10:30:48.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.225]                     {
[10:30:48.225]                       inherits <- base::inherits
[10:30:48.225]                       invokeRestart <- base::invokeRestart
[10:30:48.225]                       is.null <- base::is.null
[10:30:48.225]                       muffled <- FALSE
[10:30:48.225]                       if (inherits(cond, "message")) {
[10:30:48.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.225]                         if (muffled) 
[10:30:48.225]                           invokeRestart("muffleMessage")
[10:30:48.225]                       }
[10:30:48.225]                       else if (inherits(cond, "warning")) {
[10:30:48.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.225]                         if (muffled) 
[10:30:48.225]                           invokeRestart("muffleWarning")
[10:30:48.225]                       }
[10:30:48.225]                       else if (inherits(cond, "condition")) {
[10:30:48.225]                         if (!is.null(pattern)) {
[10:30:48.225]                           computeRestarts <- base::computeRestarts
[10:30:48.225]                           grepl <- base::grepl
[10:30:48.225]                           restarts <- computeRestarts(cond)
[10:30:48.225]                           for (restart in restarts) {
[10:30:48.225]                             name <- restart$name
[10:30:48.225]                             if (is.null(name)) 
[10:30:48.225]                               next
[10:30:48.225]                             if (!grepl(pattern, name)) 
[10:30:48.225]                               next
[10:30:48.225]                             invokeRestart(restart)
[10:30:48.225]                             muffled <- TRUE
[10:30:48.225]                             break
[10:30:48.225]                           }
[10:30:48.225]                         }
[10:30:48.225]                       }
[10:30:48.225]                       invisible(muffled)
[10:30:48.225]                     }
[10:30:48.225]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.225]                   }
[10:30:48.225]                 }
[10:30:48.225]             }
[10:30:48.225]         }))
[10:30:48.225]     }, error = function(ex) {
[10:30:48.225]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.225]                 ...future.rng), started = ...future.startTime, 
[10:30:48.225]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.225]             version = "1.8"), class = "FutureResult")
[10:30:48.225]     }, finally = {
[10:30:48.225]         if (!identical(...future.workdir, getwd())) 
[10:30:48.225]             setwd(...future.workdir)
[10:30:48.225]         {
[10:30:48.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.225]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.225]             }
[10:30:48.225]             base::options(...future.oldOptions)
[10:30:48.225]             if (.Platform$OS.type == "windows") {
[10:30:48.225]                 old_names <- names(...future.oldEnvVars)
[10:30:48.225]                 envs <- base::Sys.getenv()
[10:30:48.225]                 names <- names(envs)
[10:30:48.225]                 common <- intersect(names, old_names)
[10:30:48.225]                 added <- setdiff(names, old_names)
[10:30:48.225]                 removed <- setdiff(old_names, names)
[10:30:48.225]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.225]                   envs[common]]
[10:30:48.225]                 NAMES <- toupper(changed)
[10:30:48.225]                 args <- list()
[10:30:48.225]                 for (kk in seq_along(NAMES)) {
[10:30:48.225]                   name <- changed[[kk]]
[10:30:48.225]                   NAME <- NAMES[[kk]]
[10:30:48.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.225]                     next
[10:30:48.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.225]                 }
[10:30:48.225]                 NAMES <- toupper(added)
[10:30:48.225]                 for (kk in seq_along(NAMES)) {
[10:30:48.225]                   name <- added[[kk]]
[10:30:48.225]                   NAME <- NAMES[[kk]]
[10:30:48.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.225]                     next
[10:30:48.225]                   args[[name]] <- ""
[10:30:48.225]                 }
[10:30:48.225]                 NAMES <- toupper(removed)
[10:30:48.225]                 for (kk in seq_along(NAMES)) {
[10:30:48.225]                   name <- removed[[kk]]
[10:30:48.225]                   NAME <- NAMES[[kk]]
[10:30:48.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.225]                     next
[10:30:48.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.225]                 }
[10:30:48.225]                 if (length(args) > 0) 
[10:30:48.225]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.225]             }
[10:30:48.225]             else {
[10:30:48.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.225]             }
[10:30:48.225]             {
[10:30:48.225]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.225]                   0L) {
[10:30:48.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.225]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.225]                   base::options(opts)
[10:30:48.225]                 }
[10:30:48.225]                 {
[10:30:48.225]                   {
[10:30:48.225]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.225]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.225]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.225]                       inherits = FALSE)
[10:30:48.225]                     NULL
[10:30:48.225]                   }
[10:30:48.225]                   options(future.plan = NULL)
[10:30:48.225]                   if (is.na(NA_character_)) 
[10:30:48.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.225]                     .init = FALSE)
[10:30:48.225]                 }
[10:30:48.225]             }
[10:30:48.225]         }
[10:30:48.225]     })
[10:30:48.225]     if (TRUE) {
[10:30:48.225]         base::sink(type = "output", split = FALSE)
[10:30:48.225]         if (TRUE) {
[10:30:48.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.225]         }
[10:30:48.225]         else {
[10:30:48.225]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.225]         }
[10:30:48.225]         base::close(...future.stdout)
[10:30:48.225]         ...future.stdout <- NULL
[10:30:48.225]     }
[10:30:48.225]     ...future.result$conditions <- ...future.conditions
[10:30:48.225]     ...future.result$finished <- base::Sys.time()
[10:30:48.225]     ...future.result
[10:30:48.225] }
[10:30:48.227] assign_globals() ...
[10:30:48.227] List of 5
[10:30:48.227]  $ ...future.FUN            :function (x, y)  
[10:30:48.227]  $ MoreArgs                 : list()
[10:30:48.227]  $ ...future.elements_ii    :List of 2
[10:30:48.227]   ..$ :List of 3
[10:30:48.227]   .. ..$ a: num 1
[10:30:48.227]   .. ..$ b: num 2
[10:30:48.227]   .. ..$ c: num 3
[10:30:48.227]   ..$ :List of 3
[10:30:48.227]   .. ..$ A: num 10
[10:30:48.227]   .. ..$ B: num 0
[10:30:48.227]   .. ..$ C: num -10
[10:30:48.227]  $ ...future.seeds_ii       : NULL
[10:30:48.227]  $ ...future.globals.maxSize: NULL
[10:30:48.227]  - attr(*, "where")=List of 5
[10:30:48.227]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.227]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.227]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.227]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.227]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.227]  - attr(*, "resolved")= logi FALSE
[10:30:48.227]  - attr(*, "total_size")= num 2312
[10:30:48.227]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.227]  - attr(*, "already-done")= logi TRUE
[10:30:48.233] - reassign environment for ‘...future.FUN’
[10:30:48.233] - copied ‘...future.FUN’ to environment
[10:30:48.233] - copied ‘MoreArgs’ to environment
[10:30:48.233] - copied ‘...future.elements_ii’ to environment
[10:30:48.233] - copied ‘...future.seeds_ii’ to environment
[10:30:48.234] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.234] assign_globals() ... done
[10:30:48.234] plan(): Setting new future strategy stack:
[10:30:48.234] List of future strategies:
[10:30:48.234] 1. sequential:
[10:30:48.234]    - args: function (..., envir = parent.frame())
[10:30:48.234]    - tweaked: FALSE
[10:30:48.234]    - call: NULL
[10:30:48.234] plan(): nbrOfWorkers() = 1
[10:30:48.235] plan(): Setting new future strategy stack:
[10:30:48.235] List of future strategies:
[10:30:48.235] 1. sequential:
[10:30:48.235]    - args: function (..., envir = parent.frame())
[10:30:48.235]    - tweaked: FALSE
[10:30:48.235]    - call: plan(strategy)
[10:30:48.235] plan(): nbrOfWorkers() = 1
[10:30:48.236] SequentialFuture started (and completed)
[10:30:48.236] - Launch lazy future ... done
[10:30:48.236] run() for ‘SequentialFuture’ ... done
[10:30:48.236] Created future:
[10:30:48.236] SequentialFuture:
[10:30:48.236] Label: ‘future_.mapply-1’
[10:30:48.236] Expression:
[10:30:48.236] {
[10:30:48.236]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.236]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.236]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.236]         on.exit(options(oopts), add = TRUE)
[10:30:48.236]     }
[10:30:48.236]     {
[10:30:48.236]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.236]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.236]         do.call(mapply, args = args)
[10:30:48.236]     }
[10:30:48.236] }
[10:30:48.236] Lazy evaluation: FALSE
[10:30:48.236] Asynchronous evaluation: FALSE
[10:30:48.236] Local evaluation: TRUE
[10:30:48.236] Environment: R_GlobalEnv
[10:30:48.236] Capture standard output: TRUE
[10:30:48.236] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.236] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.236] Packages: <none>
[10:30:48.236] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.236] Resolved: TRUE
[10:30:48.236] Value: 200 bytes of class ‘list’
[10:30:48.236] Early signaling: FALSE
[10:30:48.236] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.236] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.237] Chunk #1 of 1 ... DONE
[10:30:48.237] Launching 1 futures (chunks) ... DONE
[10:30:48.237] Resolving 1 futures (chunks) ...
[10:30:48.237] resolve() on list ...
[10:30:48.237]  recursive: 0
[10:30:48.237]  length: 1
[10:30:48.237] 
[10:30:48.238] resolved() for ‘SequentialFuture’ ...
[10:30:48.238] - state: ‘finished’
[10:30:48.238] - run: TRUE
[10:30:48.238] - result: ‘FutureResult’
[10:30:48.238] resolved() for ‘SequentialFuture’ ... done
[10:30:48.238] Future #1
[10:30:48.238] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.238] - nx: 1
[10:30:48.238] - relay: TRUE
[10:30:48.238] - stdout: TRUE
[10:30:48.239] - signal: TRUE
[10:30:48.239] - resignal: FALSE
[10:30:48.239] - force: TRUE
[10:30:48.239] - relayed: [n=1] FALSE
[10:30:48.239] - queued futures: [n=1] FALSE
[10:30:48.239]  - until=1
[10:30:48.239]  - relaying element #1
[10:30:48.239] - relayed: [n=1] TRUE
[10:30:48.239] - queued futures: [n=1] TRUE
[10:30:48.239] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.240]  length: 0 (resolved future 1)
[10:30:48.240] Relaying remaining futures
[10:30:48.240] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.240] - nx: 1
[10:30:48.240] - relay: TRUE
[10:30:48.240] - stdout: TRUE
[10:30:48.240] - signal: TRUE
[10:30:48.240] - resignal: FALSE
[10:30:48.240] - force: TRUE
[10:30:48.240] - relayed: [n=1] TRUE
[10:30:48.240] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.240] - relayed: [n=1] TRUE
[10:30:48.241] - queued futures: [n=1] TRUE
[10:30:48.241] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.241] resolve() on list ... DONE
[10:30:48.241]  - Number of value chunks collected: 1
[10:30:48.241] Resolving 1 futures (chunks) ... DONE
[10:30:48.241] Reducing values from 1 chunks ...
[10:30:48.241]  - Number of values collected after concatenation: 3
[10:30:48.241]  - Number of values expected: 3
[10:30:48.241] Reducing values from 1 chunks ... DONE
[10:30:48.241] future_mapply() ... DONE
[10:30:48.242] future_mapply() ...
[10:30:48.244] Number of chunks: 5
[10:30:48.246] getGlobalsAndPackagesXApply() ...
[10:30:48.246]  - future.globals: TRUE
[10:30:48.246] getGlobalsAndPackages() ...
[10:30:48.246] Searching for globals...
[10:30:48.247] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:48.247] Searching for globals ... DONE
[10:30:48.247] Resolving globals: FALSE
[10:30:48.248] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:48.248] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:48.248] - globals: [1] ‘FUN’
[10:30:48.248] 
[10:30:48.248] getGlobalsAndPackages() ... DONE
[10:30:48.249]  - globals found/used: [n=1] ‘FUN’
[10:30:48.249]  - needed namespaces: [n=0] 
[10:30:48.249] Finding globals ... DONE
[10:30:48.249] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.249] List of 2
[10:30:48.249]  $ ...future.FUN:function (C, k)  
[10:30:48.249]  $ MoreArgs     : NULL
[10:30:48.249]  - attr(*, "where")=List of 2
[10:30:48.249]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.249]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.249]  - attr(*, "resolved")= logi FALSE
[10:30:48.249]  - attr(*, "total_size")= num NA
[10:30:48.251] Packages to be attached in all futures: [n=0] 
[10:30:48.252] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.252] Number of futures (= number of chunks): 5
[10:30:48.252] Launching 5 futures (chunks) ...
[10:30:48.252] Chunk #1 of 5 ...
[10:30:48.252]  - Finding globals in '...' for chunk #1 ...
[10:30:48.252] getGlobalsAndPackages() ...
[10:30:48.252] Searching for globals...
[10:30:48.253] 
[10:30:48.253] Searching for globals ... DONE
[10:30:48.253] - globals: [0] <none>
[10:30:48.253] getGlobalsAndPackages() ... DONE
[10:30:48.253]    + additional globals found: [n=0] 
[10:30:48.253]    + additional namespaces needed: [n=0] 
[10:30:48.253]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.253]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:48.253]  - seeds: <none>
[10:30:48.253]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.253] getGlobalsAndPackages() ...
[10:30:48.254] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.254] Resolving globals: FALSE
[10:30:48.254] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:48.255] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.255] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.255] 
[10:30:48.255] getGlobalsAndPackages() ... DONE
[10:30:48.255] run() for ‘Future’ ...
[10:30:48.255] - state: ‘created’
[10:30:48.255] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.256] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.256] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.256]   - Field: ‘label’
[10:30:48.256]   - Field: ‘local’
[10:30:48.256]   - Field: ‘owner’
[10:30:48.256]   - Field: ‘envir’
[10:30:48.256]   - Field: ‘packages’
[10:30:48.256]   - Field: ‘gc’
[10:30:48.256]   - Field: ‘conditions’
[10:30:48.256]   - Field: ‘expr’
[10:30:48.257]   - Field: ‘uuid’
[10:30:48.257]   - Field: ‘seed’
[10:30:48.257]   - Field: ‘version’
[10:30:48.257]   - Field: ‘result’
[10:30:48.257]   - Field: ‘asynchronous’
[10:30:48.257]   - Field: ‘calls’
[10:30:48.257]   - Field: ‘globals’
[10:30:48.257]   - Field: ‘stdout’
[10:30:48.257]   - Field: ‘earlySignal’
[10:30:48.257]   - Field: ‘lazy’
[10:30:48.257]   - Field: ‘state’
[10:30:48.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.258] - Launch lazy future ...
[10:30:48.258] Packages needed by the future expression (n = 0): <none>
[10:30:48.258] Packages needed by future strategies (n = 0): <none>
[10:30:48.258] {
[10:30:48.258]     {
[10:30:48.258]         {
[10:30:48.258]             ...future.startTime <- base::Sys.time()
[10:30:48.258]             {
[10:30:48.258]                 {
[10:30:48.258]                   {
[10:30:48.258]                     base::local({
[10:30:48.258]                       has_future <- base::requireNamespace("future", 
[10:30:48.258]                         quietly = TRUE)
[10:30:48.258]                       if (has_future) {
[10:30:48.258]                         ns <- base::getNamespace("future")
[10:30:48.258]                         version <- ns[[".package"]][["version"]]
[10:30:48.258]                         if (is.null(version)) 
[10:30:48.258]                           version <- utils::packageVersion("future")
[10:30:48.258]                       }
[10:30:48.258]                       else {
[10:30:48.258]                         version <- NULL
[10:30:48.258]                       }
[10:30:48.258]                       if (!has_future || version < "1.8.0") {
[10:30:48.258]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.258]                           "", base::R.version$version.string), 
[10:30:48.258]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.258]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.258]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.258]                             "release", "version")], collapse = " "), 
[10:30:48.258]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.258]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.258]                           info)
[10:30:48.258]                         info <- base::paste(info, collapse = "; ")
[10:30:48.258]                         if (!has_future) {
[10:30:48.258]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.258]                             info)
[10:30:48.258]                         }
[10:30:48.258]                         else {
[10:30:48.258]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.258]                             info, version)
[10:30:48.258]                         }
[10:30:48.258]                         base::stop(msg)
[10:30:48.258]                       }
[10:30:48.258]                     })
[10:30:48.258]                   }
[10:30:48.258]                   ...future.strategy.old <- future::plan("list")
[10:30:48.258]                   options(future.plan = NULL)
[10:30:48.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.258]                 }
[10:30:48.258]                 ...future.workdir <- getwd()
[10:30:48.258]             }
[10:30:48.258]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.258]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.258]         }
[10:30:48.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.258]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:48.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.258]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.258]             base::names(...future.oldOptions))
[10:30:48.258]     }
[10:30:48.258]     if (FALSE) {
[10:30:48.258]     }
[10:30:48.258]     else {
[10:30:48.258]         if (TRUE) {
[10:30:48.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.258]                 open = "w")
[10:30:48.258]         }
[10:30:48.258]         else {
[10:30:48.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.258]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.258]         }
[10:30:48.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.258]             base::sink(type = "output", split = FALSE)
[10:30:48.258]             base::close(...future.stdout)
[10:30:48.258]         }, add = TRUE)
[10:30:48.258]     }
[10:30:48.258]     ...future.frame <- base::sys.nframe()
[10:30:48.258]     ...future.conditions <- base::list()
[10:30:48.258]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.258]     if (FALSE) {
[10:30:48.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.258]     }
[10:30:48.258]     ...future.result <- base::tryCatch({
[10:30:48.258]         base::withCallingHandlers({
[10:30:48.258]             ...future.value <- base::withVisible(base::local({
[10:30:48.258]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.258]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.258]                   ...future.globals.maxSize)) {
[10:30:48.258]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.258]                   on.exit(options(oopts), add = TRUE)
[10:30:48.258]                 }
[10:30:48.258]                 {
[10:30:48.258]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.258]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.258]                     USE.NAMES = FALSE)
[10:30:48.258]                   do.call(mapply, args = args)
[10:30:48.258]                 }
[10:30:48.258]             }))
[10:30:48.258]             future::FutureResult(value = ...future.value$value, 
[10:30:48.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.258]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.258]                     ...future.globalenv.names))
[10:30:48.258]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.258]         }, condition = base::local({
[10:30:48.258]             c <- base::c
[10:30:48.258]             inherits <- base::inherits
[10:30:48.258]             invokeRestart <- base::invokeRestart
[10:30:48.258]             length <- base::length
[10:30:48.258]             list <- base::list
[10:30:48.258]             seq.int <- base::seq.int
[10:30:48.258]             signalCondition <- base::signalCondition
[10:30:48.258]             sys.calls <- base::sys.calls
[10:30:48.258]             `[[` <- base::`[[`
[10:30:48.258]             `+` <- base::`+`
[10:30:48.258]             `<<-` <- base::`<<-`
[10:30:48.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.258]                   3L)]
[10:30:48.258]             }
[10:30:48.258]             function(cond) {
[10:30:48.258]                 is_error <- inherits(cond, "error")
[10:30:48.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.258]                   NULL)
[10:30:48.258]                 if (is_error) {
[10:30:48.258]                   sessionInformation <- function() {
[10:30:48.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.258]                       search = base::search(), system = base::Sys.info())
[10:30:48.258]                   }
[10:30:48.258]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.258]                     cond$call), session = sessionInformation(), 
[10:30:48.258]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.258]                   signalCondition(cond)
[10:30:48.258]                 }
[10:30:48.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.258]                 "immediateCondition"))) {
[10:30:48.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.258]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.258]                   if (TRUE && !signal) {
[10:30:48.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.258]                     {
[10:30:48.258]                       inherits <- base::inherits
[10:30:48.258]                       invokeRestart <- base::invokeRestart
[10:30:48.258]                       is.null <- base::is.null
[10:30:48.258]                       muffled <- FALSE
[10:30:48.258]                       if (inherits(cond, "message")) {
[10:30:48.258]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.258]                         if (muffled) 
[10:30:48.258]                           invokeRestart("muffleMessage")
[10:30:48.258]                       }
[10:30:48.258]                       else if (inherits(cond, "warning")) {
[10:30:48.258]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.258]                         if (muffled) 
[10:30:48.258]                           invokeRestart("muffleWarning")
[10:30:48.258]                       }
[10:30:48.258]                       else if (inherits(cond, "condition")) {
[10:30:48.258]                         if (!is.null(pattern)) {
[10:30:48.258]                           computeRestarts <- base::computeRestarts
[10:30:48.258]                           grepl <- base::grepl
[10:30:48.258]                           restarts <- computeRestarts(cond)
[10:30:48.258]                           for (restart in restarts) {
[10:30:48.258]                             name <- restart$name
[10:30:48.258]                             if (is.null(name)) 
[10:30:48.258]                               next
[10:30:48.258]                             if (!grepl(pattern, name)) 
[10:30:48.258]                               next
[10:30:48.258]                             invokeRestart(restart)
[10:30:48.258]                             muffled <- TRUE
[10:30:48.258]                             break
[10:30:48.258]                           }
[10:30:48.258]                         }
[10:30:48.258]                       }
[10:30:48.258]                       invisible(muffled)
[10:30:48.258]                     }
[10:30:48.258]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.258]                   }
[10:30:48.258]                 }
[10:30:48.258]                 else {
[10:30:48.258]                   if (TRUE) {
[10:30:48.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.258]                     {
[10:30:48.258]                       inherits <- base::inherits
[10:30:48.258]                       invokeRestart <- base::invokeRestart
[10:30:48.258]                       is.null <- base::is.null
[10:30:48.258]                       muffled <- FALSE
[10:30:48.258]                       if (inherits(cond, "message")) {
[10:30:48.258]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.258]                         if (muffled) 
[10:30:48.258]                           invokeRestart("muffleMessage")
[10:30:48.258]                       }
[10:30:48.258]                       else if (inherits(cond, "warning")) {
[10:30:48.258]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.258]                         if (muffled) 
[10:30:48.258]                           invokeRestart("muffleWarning")
[10:30:48.258]                       }
[10:30:48.258]                       else if (inherits(cond, "condition")) {
[10:30:48.258]                         if (!is.null(pattern)) {
[10:30:48.258]                           computeRestarts <- base::computeRestarts
[10:30:48.258]                           grepl <- base::grepl
[10:30:48.258]                           restarts <- computeRestarts(cond)
[10:30:48.258]                           for (restart in restarts) {
[10:30:48.258]                             name <- restart$name
[10:30:48.258]                             if (is.null(name)) 
[10:30:48.258]                               next
[10:30:48.258]                             if (!grepl(pattern, name)) 
[10:30:48.258]                               next
[10:30:48.258]                             invokeRestart(restart)
[10:30:48.258]                             muffled <- TRUE
[10:30:48.258]                             break
[10:30:48.258]                           }
[10:30:48.258]                         }
[10:30:48.258]                       }
[10:30:48.258]                       invisible(muffled)
[10:30:48.258]                     }
[10:30:48.258]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.258]                   }
[10:30:48.258]                 }
[10:30:48.258]             }
[10:30:48.258]         }))
[10:30:48.258]     }, error = function(ex) {
[10:30:48.258]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.258]                 ...future.rng), started = ...future.startTime, 
[10:30:48.258]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.258]             version = "1.8"), class = "FutureResult")
[10:30:48.258]     }, finally = {
[10:30:48.258]         if (!identical(...future.workdir, getwd())) 
[10:30:48.258]             setwd(...future.workdir)
[10:30:48.258]         {
[10:30:48.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.258]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.258]             }
[10:30:48.258]             base::options(...future.oldOptions)
[10:30:48.258]             if (.Platform$OS.type == "windows") {
[10:30:48.258]                 old_names <- names(...future.oldEnvVars)
[10:30:48.258]                 envs <- base::Sys.getenv()
[10:30:48.258]                 names <- names(envs)
[10:30:48.258]                 common <- intersect(names, old_names)
[10:30:48.258]                 added <- setdiff(names, old_names)
[10:30:48.258]                 removed <- setdiff(old_names, names)
[10:30:48.258]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.258]                   envs[common]]
[10:30:48.258]                 NAMES <- toupper(changed)
[10:30:48.258]                 args <- list()
[10:30:48.258]                 for (kk in seq_along(NAMES)) {
[10:30:48.258]                   name <- changed[[kk]]
[10:30:48.258]                   NAME <- NAMES[[kk]]
[10:30:48.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.258]                     next
[10:30:48.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.258]                 }
[10:30:48.258]                 NAMES <- toupper(added)
[10:30:48.258]                 for (kk in seq_along(NAMES)) {
[10:30:48.258]                   name <- added[[kk]]
[10:30:48.258]                   NAME <- NAMES[[kk]]
[10:30:48.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.258]                     next
[10:30:48.258]                   args[[name]] <- ""
[10:30:48.258]                 }
[10:30:48.258]                 NAMES <- toupper(removed)
[10:30:48.258]                 for (kk in seq_along(NAMES)) {
[10:30:48.258]                   name <- removed[[kk]]
[10:30:48.258]                   NAME <- NAMES[[kk]]
[10:30:48.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.258]                     next
[10:30:48.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.258]                 }
[10:30:48.258]                 if (length(args) > 0) 
[10:30:48.258]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.258]             }
[10:30:48.258]             else {
[10:30:48.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.258]             }
[10:30:48.258]             {
[10:30:48.258]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.258]                   0L) {
[10:30:48.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.258]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.258]                   base::options(opts)
[10:30:48.258]                 }
[10:30:48.258]                 {
[10:30:48.258]                   {
[10:30:48.258]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.258]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.258]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.258]                       inherits = FALSE)
[10:30:48.258]                     NULL
[10:30:48.258]                   }
[10:30:48.258]                   options(future.plan = NULL)
[10:30:48.258]                   if (is.na(NA_character_)) 
[10:30:48.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.258]                     .init = FALSE)
[10:30:48.258]                 }
[10:30:48.258]             }
[10:30:48.258]         }
[10:30:48.258]     })
[10:30:48.258]     if (TRUE) {
[10:30:48.258]         base::sink(type = "output", split = FALSE)
[10:30:48.258]         if (TRUE) {
[10:30:48.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.258]         }
[10:30:48.258]         else {
[10:30:48.258]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.258]         }
[10:30:48.258]         base::close(...future.stdout)
[10:30:48.258]         ...future.stdout <- NULL
[10:30:48.258]     }
[10:30:48.258]     ...future.result$conditions <- ...future.conditions
[10:30:48.258]     ...future.result$finished <- base::Sys.time()
[10:30:48.258]     ...future.result
[10:30:48.258] }
[10:30:48.260] assign_globals() ...
[10:30:48.260] List of 5
[10:30:48.260]  $ ...future.FUN            :function (C, k)  
[10:30:48.260]  $ MoreArgs                 : NULL
[10:30:48.260]  $ ...future.elements_ii    :List of 2
[10:30:48.260]   ..$ :List of 1
[10:30:48.260]   .. ..$ : chr "A"
[10:30:48.260]   ..$ :List of 1
[10:30:48.260]   .. ..$ : int 5
[10:30:48.260]  $ ...future.seeds_ii       : NULL
[10:30:48.260]  $ ...future.globals.maxSize: NULL
[10:30:48.260]  - attr(*, "where")=List of 5
[10:30:48.260]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.260]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.260]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.260]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.260]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.260]  - attr(*, "resolved")= logi FALSE
[10:30:48.260]  - attr(*, "total_size")= num 3488
[10:30:48.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.260]  - attr(*, "already-done")= logi TRUE
[10:30:48.265] - reassign environment for ‘...future.FUN’
[10:30:48.265] - copied ‘...future.FUN’ to environment
[10:30:48.265] - copied ‘MoreArgs’ to environment
[10:30:48.265] - copied ‘...future.elements_ii’ to environment
[10:30:48.265] - copied ‘...future.seeds_ii’ to environment
[10:30:48.266] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.266] assign_globals() ... done
[10:30:48.266] plan(): Setting new future strategy stack:
[10:30:48.266] List of future strategies:
[10:30:48.266] 1. sequential:
[10:30:48.266]    - args: function (..., envir = parent.frame())
[10:30:48.266]    - tweaked: FALSE
[10:30:48.266]    - call: NULL
[10:30:48.266] plan(): nbrOfWorkers() = 1
[10:30:48.267] plan(): Setting new future strategy stack:
[10:30:48.269] List of future strategies:
[10:30:48.269] 1. sequential:
[10:30:48.269]    - args: function (..., envir = parent.frame())
[10:30:48.269]    - tweaked: FALSE
[10:30:48.269]    - call: plan(strategy)
[10:30:48.269] plan(): nbrOfWorkers() = 1
[10:30:48.270] SequentialFuture started (and completed)
[10:30:48.270] - Launch lazy future ... done
[10:30:48.270] run() for ‘SequentialFuture’ ... done
[10:30:48.270] Created future:
[10:30:48.270] SequentialFuture:
[10:30:48.270] Label: ‘future_mapply-1’
[10:30:48.270] Expression:
[10:30:48.270] {
[10:30:48.270]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.270]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.270]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.270]         on.exit(options(oopts), add = TRUE)
[10:30:48.270]     }
[10:30:48.270]     {
[10:30:48.270]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.270]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.270]         do.call(mapply, args = args)
[10:30:48.270]     }
[10:30:48.270] }
[10:30:48.270] Lazy evaluation: FALSE
[10:30:48.270] Asynchronous evaluation: FALSE
[10:30:48.270] Local evaluation: TRUE
[10:30:48.270] Environment: R_GlobalEnv
[10:30:48.270] Capture standard output: TRUE
[10:30:48.270] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.270] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.270] Packages: <none>
[10:30:48.270] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.270] Resolved: TRUE
[10:30:48.270] Value: 112 bytes of class ‘list’
[10:30:48.270] Early signaling: FALSE
[10:30:48.270] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.270] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.271] Chunk #1 of 5 ... DONE
[10:30:48.271] Chunk #2 of 5 ...
[10:30:48.271]  - Finding globals in '...' for chunk #2 ...
[10:30:48.271] getGlobalsAndPackages() ...
[10:30:48.271] Searching for globals...
[10:30:48.272] 
[10:30:48.272] Searching for globals ... DONE
[10:30:48.272] - globals: [0] <none>
[10:30:48.272] getGlobalsAndPackages() ... DONE
[10:30:48.272]    + additional globals found: [n=0] 
[10:30:48.272]    + additional namespaces needed: [n=0] 
[10:30:48.272]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:48.272]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:48.272]  - seeds: <none>
[10:30:48.272]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.273] getGlobalsAndPackages() ...
[10:30:48.273] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.273] Resolving globals: FALSE
[10:30:48.273] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:48.274] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.274] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.274] 
[10:30:48.274] getGlobalsAndPackages() ... DONE
[10:30:48.274] run() for ‘Future’ ...
[10:30:48.274] - state: ‘created’
[10:30:48.275] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.275] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.275] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.275]   - Field: ‘label’
[10:30:48.275]   - Field: ‘local’
[10:30:48.275]   - Field: ‘owner’
[10:30:48.275]   - Field: ‘envir’
[10:30:48.275]   - Field: ‘packages’
[10:30:48.275]   - Field: ‘gc’
[10:30:48.276]   - Field: ‘conditions’
[10:30:48.276]   - Field: ‘expr’
[10:30:48.276]   - Field: ‘uuid’
[10:30:48.276]   - Field: ‘seed’
[10:30:48.276]   - Field: ‘version’
[10:30:48.276]   - Field: ‘result’
[10:30:48.276]   - Field: ‘asynchronous’
[10:30:48.276]   - Field: ‘calls’
[10:30:48.276]   - Field: ‘globals’
[10:30:48.276]   - Field: ‘stdout’
[10:30:48.276]   - Field: ‘earlySignal’
[10:30:48.277]   - Field: ‘lazy’
[10:30:48.277]   - Field: ‘state’
[10:30:48.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.277] - Launch lazy future ...
[10:30:48.277] Packages needed by the future expression (n = 0): <none>
[10:30:48.277] Packages needed by future strategies (n = 0): <none>
[10:30:48.278] {
[10:30:48.278]     {
[10:30:48.278]         {
[10:30:48.278]             ...future.startTime <- base::Sys.time()
[10:30:48.278]             {
[10:30:48.278]                 {
[10:30:48.278]                   {
[10:30:48.278]                     base::local({
[10:30:48.278]                       has_future <- base::requireNamespace("future", 
[10:30:48.278]                         quietly = TRUE)
[10:30:48.278]                       if (has_future) {
[10:30:48.278]                         ns <- base::getNamespace("future")
[10:30:48.278]                         version <- ns[[".package"]][["version"]]
[10:30:48.278]                         if (is.null(version)) 
[10:30:48.278]                           version <- utils::packageVersion("future")
[10:30:48.278]                       }
[10:30:48.278]                       else {
[10:30:48.278]                         version <- NULL
[10:30:48.278]                       }
[10:30:48.278]                       if (!has_future || version < "1.8.0") {
[10:30:48.278]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.278]                           "", base::R.version$version.string), 
[10:30:48.278]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.278]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.278]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.278]                             "release", "version")], collapse = " "), 
[10:30:48.278]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.278]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.278]                           info)
[10:30:48.278]                         info <- base::paste(info, collapse = "; ")
[10:30:48.278]                         if (!has_future) {
[10:30:48.278]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.278]                             info)
[10:30:48.278]                         }
[10:30:48.278]                         else {
[10:30:48.278]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.278]                             info, version)
[10:30:48.278]                         }
[10:30:48.278]                         base::stop(msg)
[10:30:48.278]                       }
[10:30:48.278]                     })
[10:30:48.278]                   }
[10:30:48.278]                   ...future.strategy.old <- future::plan("list")
[10:30:48.278]                   options(future.plan = NULL)
[10:30:48.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.278]                 }
[10:30:48.278]                 ...future.workdir <- getwd()
[10:30:48.278]             }
[10:30:48.278]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.278]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.278]         }
[10:30:48.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.278]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:48.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.278]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.278]             base::names(...future.oldOptions))
[10:30:48.278]     }
[10:30:48.278]     if (FALSE) {
[10:30:48.278]     }
[10:30:48.278]     else {
[10:30:48.278]         if (TRUE) {
[10:30:48.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.278]                 open = "w")
[10:30:48.278]         }
[10:30:48.278]         else {
[10:30:48.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.278]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.278]         }
[10:30:48.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.278]             base::sink(type = "output", split = FALSE)
[10:30:48.278]             base::close(...future.stdout)
[10:30:48.278]         }, add = TRUE)
[10:30:48.278]     }
[10:30:48.278]     ...future.frame <- base::sys.nframe()
[10:30:48.278]     ...future.conditions <- base::list()
[10:30:48.278]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.278]     if (FALSE) {
[10:30:48.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.278]     }
[10:30:48.278]     ...future.result <- base::tryCatch({
[10:30:48.278]         base::withCallingHandlers({
[10:30:48.278]             ...future.value <- base::withVisible(base::local({
[10:30:48.278]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.278]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.278]                   ...future.globals.maxSize)) {
[10:30:48.278]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.278]                   on.exit(options(oopts), add = TRUE)
[10:30:48.278]                 }
[10:30:48.278]                 {
[10:30:48.278]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.278]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.278]                     USE.NAMES = FALSE)
[10:30:48.278]                   do.call(mapply, args = args)
[10:30:48.278]                 }
[10:30:48.278]             }))
[10:30:48.278]             future::FutureResult(value = ...future.value$value, 
[10:30:48.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.278]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.278]                     ...future.globalenv.names))
[10:30:48.278]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.278]         }, condition = base::local({
[10:30:48.278]             c <- base::c
[10:30:48.278]             inherits <- base::inherits
[10:30:48.278]             invokeRestart <- base::invokeRestart
[10:30:48.278]             length <- base::length
[10:30:48.278]             list <- base::list
[10:30:48.278]             seq.int <- base::seq.int
[10:30:48.278]             signalCondition <- base::signalCondition
[10:30:48.278]             sys.calls <- base::sys.calls
[10:30:48.278]             `[[` <- base::`[[`
[10:30:48.278]             `+` <- base::`+`
[10:30:48.278]             `<<-` <- base::`<<-`
[10:30:48.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.278]                   3L)]
[10:30:48.278]             }
[10:30:48.278]             function(cond) {
[10:30:48.278]                 is_error <- inherits(cond, "error")
[10:30:48.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.278]                   NULL)
[10:30:48.278]                 if (is_error) {
[10:30:48.278]                   sessionInformation <- function() {
[10:30:48.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.278]                       search = base::search(), system = base::Sys.info())
[10:30:48.278]                   }
[10:30:48.278]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.278]                     cond$call), session = sessionInformation(), 
[10:30:48.278]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.278]                   signalCondition(cond)
[10:30:48.278]                 }
[10:30:48.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.278]                 "immediateCondition"))) {
[10:30:48.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.278]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.278]                   if (TRUE && !signal) {
[10:30:48.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.278]                     {
[10:30:48.278]                       inherits <- base::inherits
[10:30:48.278]                       invokeRestart <- base::invokeRestart
[10:30:48.278]                       is.null <- base::is.null
[10:30:48.278]                       muffled <- FALSE
[10:30:48.278]                       if (inherits(cond, "message")) {
[10:30:48.278]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.278]                         if (muffled) 
[10:30:48.278]                           invokeRestart("muffleMessage")
[10:30:48.278]                       }
[10:30:48.278]                       else if (inherits(cond, "warning")) {
[10:30:48.278]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.278]                         if (muffled) 
[10:30:48.278]                           invokeRestart("muffleWarning")
[10:30:48.278]                       }
[10:30:48.278]                       else if (inherits(cond, "condition")) {
[10:30:48.278]                         if (!is.null(pattern)) {
[10:30:48.278]                           computeRestarts <- base::computeRestarts
[10:30:48.278]                           grepl <- base::grepl
[10:30:48.278]                           restarts <- computeRestarts(cond)
[10:30:48.278]                           for (restart in restarts) {
[10:30:48.278]                             name <- restart$name
[10:30:48.278]                             if (is.null(name)) 
[10:30:48.278]                               next
[10:30:48.278]                             if (!grepl(pattern, name)) 
[10:30:48.278]                               next
[10:30:48.278]                             invokeRestart(restart)
[10:30:48.278]                             muffled <- TRUE
[10:30:48.278]                             break
[10:30:48.278]                           }
[10:30:48.278]                         }
[10:30:48.278]                       }
[10:30:48.278]                       invisible(muffled)
[10:30:48.278]                     }
[10:30:48.278]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.278]                   }
[10:30:48.278]                 }
[10:30:48.278]                 else {
[10:30:48.278]                   if (TRUE) {
[10:30:48.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.278]                     {
[10:30:48.278]                       inherits <- base::inherits
[10:30:48.278]                       invokeRestart <- base::invokeRestart
[10:30:48.278]                       is.null <- base::is.null
[10:30:48.278]                       muffled <- FALSE
[10:30:48.278]                       if (inherits(cond, "message")) {
[10:30:48.278]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.278]                         if (muffled) 
[10:30:48.278]                           invokeRestart("muffleMessage")
[10:30:48.278]                       }
[10:30:48.278]                       else if (inherits(cond, "warning")) {
[10:30:48.278]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.278]                         if (muffled) 
[10:30:48.278]                           invokeRestart("muffleWarning")
[10:30:48.278]                       }
[10:30:48.278]                       else if (inherits(cond, "condition")) {
[10:30:48.278]                         if (!is.null(pattern)) {
[10:30:48.278]                           computeRestarts <- base::computeRestarts
[10:30:48.278]                           grepl <- base::grepl
[10:30:48.278]                           restarts <- computeRestarts(cond)
[10:30:48.278]                           for (restart in restarts) {
[10:30:48.278]                             name <- restart$name
[10:30:48.278]                             if (is.null(name)) 
[10:30:48.278]                               next
[10:30:48.278]                             if (!grepl(pattern, name)) 
[10:30:48.278]                               next
[10:30:48.278]                             invokeRestart(restart)
[10:30:48.278]                             muffled <- TRUE
[10:30:48.278]                             break
[10:30:48.278]                           }
[10:30:48.278]                         }
[10:30:48.278]                       }
[10:30:48.278]                       invisible(muffled)
[10:30:48.278]                     }
[10:30:48.278]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.278]                   }
[10:30:48.278]                 }
[10:30:48.278]             }
[10:30:48.278]         }))
[10:30:48.278]     }, error = function(ex) {
[10:30:48.278]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.278]                 ...future.rng), started = ...future.startTime, 
[10:30:48.278]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.278]             version = "1.8"), class = "FutureResult")
[10:30:48.278]     }, finally = {
[10:30:48.278]         if (!identical(...future.workdir, getwd())) 
[10:30:48.278]             setwd(...future.workdir)
[10:30:48.278]         {
[10:30:48.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.278]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.278]             }
[10:30:48.278]             base::options(...future.oldOptions)
[10:30:48.278]             if (.Platform$OS.type == "windows") {
[10:30:48.278]                 old_names <- names(...future.oldEnvVars)
[10:30:48.278]                 envs <- base::Sys.getenv()
[10:30:48.278]                 names <- names(envs)
[10:30:48.278]                 common <- intersect(names, old_names)
[10:30:48.278]                 added <- setdiff(names, old_names)
[10:30:48.278]                 removed <- setdiff(old_names, names)
[10:30:48.278]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.278]                   envs[common]]
[10:30:48.278]                 NAMES <- toupper(changed)
[10:30:48.278]                 args <- list()
[10:30:48.278]                 for (kk in seq_along(NAMES)) {
[10:30:48.278]                   name <- changed[[kk]]
[10:30:48.278]                   NAME <- NAMES[[kk]]
[10:30:48.278]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.278]                     next
[10:30:48.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.278]                 }
[10:30:48.278]                 NAMES <- toupper(added)
[10:30:48.278]                 for (kk in seq_along(NAMES)) {
[10:30:48.278]                   name <- added[[kk]]
[10:30:48.278]                   NAME <- NAMES[[kk]]
[10:30:48.278]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.278]                     next
[10:30:48.278]                   args[[name]] <- ""
[10:30:48.278]                 }
[10:30:48.278]                 NAMES <- toupper(removed)
[10:30:48.278]                 for (kk in seq_along(NAMES)) {
[10:30:48.278]                   name <- removed[[kk]]
[10:30:48.278]                   NAME <- NAMES[[kk]]
[10:30:48.278]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.278]                     next
[10:30:48.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.278]                 }
[10:30:48.278]                 if (length(args) > 0) 
[10:30:48.278]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.278]             }
[10:30:48.278]             else {
[10:30:48.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.278]             }
[10:30:48.278]             {
[10:30:48.278]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.278]                   0L) {
[10:30:48.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.278]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.278]                   base::options(opts)
[10:30:48.278]                 }
[10:30:48.278]                 {
[10:30:48.278]                   {
[10:30:48.278]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.278]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.278]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.278]                       inherits = FALSE)
[10:30:48.278]                     NULL
[10:30:48.278]                   }
[10:30:48.278]                   options(future.plan = NULL)
[10:30:48.278]                   if (is.na(NA_character_)) 
[10:30:48.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.278]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.278]                     .init = FALSE)
[10:30:48.278]                 }
[10:30:48.278]             }
[10:30:48.278]         }
[10:30:48.278]     })
[10:30:48.278]     if (TRUE) {
[10:30:48.278]         base::sink(type = "output", split = FALSE)
[10:30:48.278]         if (TRUE) {
[10:30:48.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.278]         }
[10:30:48.278]         else {
[10:30:48.278]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.278]         }
[10:30:48.278]         base::close(...future.stdout)
[10:30:48.278]         ...future.stdout <- NULL
[10:30:48.278]     }
[10:30:48.278]     ...future.result$conditions <- ...future.conditions
[10:30:48.278]     ...future.result$finished <- base::Sys.time()
[10:30:48.278]     ...future.result
[10:30:48.278] }
[10:30:48.279] assign_globals() ...
[10:30:48.279] List of 5
[10:30:48.279]  $ ...future.FUN            :function (C, k)  
[10:30:48.279]  $ MoreArgs                 : NULL
[10:30:48.279]  $ ...future.elements_ii    :List of 2
[10:30:48.279]   ..$ :List of 1
[10:30:48.279]   .. ..$ : chr "B"
[10:30:48.279]   ..$ :List of 1
[10:30:48.279]   .. ..$ : int 4
[10:30:48.279]  $ ...future.seeds_ii       : NULL
[10:30:48.279]  $ ...future.globals.maxSize: NULL
[10:30:48.279]  - attr(*, "where")=List of 5
[10:30:48.279]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.279]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.279]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.279]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.279]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.279]  - attr(*, "resolved")= logi FALSE
[10:30:48.279]  - attr(*, "total_size")= num 3488
[10:30:48.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.279]  - attr(*, "already-done")= logi TRUE
[10:30:48.284] - reassign environment for ‘...future.FUN’
[10:30:48.284] - copied ‘...future.FUN’ to environment
[10:30:48.284] - copied ‘MoreArgs’ to environment
[10:30:48.284] - copied ‘...future.elements_ii’ to environment
[10:30:48.284] - copied ‘...future.seeds_ii’ to environment
[10:30:48.285] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.285] assign_globals() ... done
[10:30:48.285] plan(): Setting new future strategy stack:
[10:30:48.285] List of future strategies:
[10:30:48.285] 1. sequential:
[10:30:48.285]    - args: function (..., envir = parent.frame())
[10:30:48.285]    - tweaked: FALSE
[10:30:48.285]    - call: NULL
[10:30:48.285] plan(): nbrOfWorkers() = 1
[10:30:48.286] plan(): Setting new future strategy stack:
[10:30:48.286] List of future strategies:
[10:30:48.286] 1. sequential:
[10:30:48.286]    - args: function (..., envir = parent.frame())
[10:30:48.286]    - tweaked: FALSE
[10:30:48.286]    - call: plan(strategy)
[10:30:48.286] plan(): nbrOfWorkers() = 1
[10:30:48.287] SequentialFuture started (and completed)
[10:30:48.287] - Launch lazy future ... done
[10:30:48.287] run() for ‘SequentialFuture’ ... done
[10:30:48.287] Created future:
[10:30:48.287] SequentialFuture:
[10:30:48.287] Label: ‘future_mapply-2’
[10:30:48.287] Expression:
[10:30:48.287] {
[10:30:48.287]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.287]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.287]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.287]         on.exit(options(oopts), add = TRUE)
[10:30:48.287]     }
[10:30:48.287]     {
[10:30:48.287]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.287]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.287]         do.call(mapply, args = args)
[10:30:48.287]     }
[10:30:48.287] }
[10:30:48.287] Lazy evaluation: FALSE
[10:30:48.287] Asynchronous evaluation: FALSE
[10:30:48.287] Local evaluation: TRUE
[10:30:48.287] Environment: R_GlobalEnv
[10:30:48.287] Capture standard output: TRUE
[10:30:48.287] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.287] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.287] Packages: <none>
[10:30:48.287] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.287] Resolved: TRUE
[10:30:48.287] Value: 112 bytes of class ‘list’
[10:30:48.287] Early signaling: FALSE
[10:30:48.287] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.287] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.288] Chunk #2 of 5 ... DONE
[10:30:48.288] Chunk #3 of 5 ...
[10:30:48.288]  - Finding globals in '...' for chunk #3 ...
[10:30:48.288] getGlobalsAndPackages() ...
[10:30:48.288] Searching for globals...
[10:30:48.289] 
[10:30:48.289] Searching for globals ... DONE
[10:30:48.289] - globals: [0] <none>
[10:30:48.289] getGlobalsAndPackages() ... DONE
[10:30:48.289]    + additional globals found: [n=0] 
[10:30:48.289]    + additional namespaces needed: [n=0] 
[10:30:48.289]  - Finding globals in '...' for chunk #3 ... DONE
[10:30:48.289]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:48.289]  - seeds: <none>
[10:30:48.289]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.289] getGlobalsAndPackages() ...
[10:30:48.290] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.290] Resolving globals: FALSE
[10:30:48.290] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:48.291] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.291] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.317] 
[10:30:48.317] getGlobalsAndPackages() ... DONE
[10:30:48.318] run() for ‘Future’ ...
[10:30:48.318] - state: ‘created’
[10:30:48.318] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.318] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.318] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.319]   - Field: ‘label’
[10:30:48.319]   - Field: ‘local’
[10:30:48.319]   - Field: ‘owner’
[10:30:48.319]   - Field: ‘envir’
[10:30:48.319]   - Field: ‘packages’
[10:30:48.319]   - Field: ‘gc’
[10:30:48.319]   - Field: ‘conditions’
[10:30:48.319]   - Field: ‘expr’
[10:30:48.319]   - Field: ‘uuid’
[10:30:48.320]   - Field: ‘seed’
[10:30:48.320]   - Field: ‘version’
[10:30:48.320]   - Field: ‘result’
[10:30:48.320]   - Field: ‘asynchronous’
[10:30:48.320]   - Field: ‘calls’
[10:30:48.320]   - Field: ‘globals’
[10:30:48.320]   - Field: ‘stdout’
[10:30:48.320]   - Field: ‘earlySignal’
[10:30:48.320]   - Field: ‘lazy’
[10:30:48.320]   - Field: ‘state’
[10:30:48.320] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.321] - Launch lazy future ...
[10:30:48.321] Packages needed by the future expression (n = 0): <none>
[10:30:48.321] Packages needed by future strategies (n = 0): <none>
[10:30:48.321] {
[10:30:48.321]     {
[10:30:48.321]         {
[10:30:48.321]             ...future.startTime <- base::Sys.time()
[10:30:48.321]             {
[10:30:48.321]                 {
[10:30:48.321]                   {
[10:30:48.321]                     base::local({
[10:30:48.321]                       has_future <- base::requireNamespace("future", 
[10:30:48.321]                         quietly = TRUE)
[10:30:48.321]                       if (has_future) {
[10:30:48.321]                         ns <- base::getNamespace("future")
[10:30:48.321]                         version <- ns[[".package"]][["version"]]
[10:30:48.321]                         if (is.null(version)) 
[10:30:48.321]                           version <- utils::packageVersion("future")
[10:30:48.321]                       }
[10:30:48.321]                       else {
[10:30:48.321]                         version <- NULL
[10:30:48.321]                       }
[10:30:48.321]                       if (!has_future || version < "1.8.0") {
[10:30:48.321]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.321]                           "", base::R.version$version.string), 
[10:30:48.321]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.321]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.321]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.321]                             "release", "version")], collapse = " "), 
[10:30:48.321]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.321]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.321]                           info)
[10:30:48.321]                         info <- base::paste(info, collapse = "; ")
[10:30:48.321]                         if (!has_future) {
[10:30:48.321]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.321]                             info)
[10:30:48.321]                         }
[10:30:48.321]                         else {
[10:30:48.321]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.321]                             info, version)
[10:30:48.321]                         }
[10:30:48.321]                         base::stop(msg)
[10:30:48.321]                       }
[10:30:48.321]                     })
[10:30:48.321]                   }
[10:30:48.321]                   ...future.strategy.old <- future::plan("list")
[10:30:48.321]                   options(future.plan = NULL)
[10:30:48.321]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.321]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.321]                 }
[10:30:48.321]                 ...future.workdir <- getwd()
[10:30:48.321]             }
[10:30:48.321]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.321]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.321]         }
[10:30:48.321]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.321]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:48.321]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.321]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.321]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.321]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.321]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.321]             base::names(...future.oldOptions))
[10:30:48.321]     }
[10:30:48.321]     if (FALSE) {
[10:30:48.321]     }
[10:30:48.321]     else {
[10:30:48.321]         if (TRUE) {
[10:30:48.321]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.321]                 open = "w")
[10:30:48.321]         }
[10:30:48.321]         else {
[10:30:48.321]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.321]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.321]         }
[10:30:48.321]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.321]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.321]             base::sink(type = "output", split = FALSE)
[10:30:48.321]             base::close(...future.stdout)
[10:30:48.321]         }, add = TRUE)
[10:30:48.321]     }
[10:30:48.321]     ...future.frame <- base::sys.nframe()
[10:30:48.321]     ...future.conditions <- base::list()
[10:30:48.321]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.321]     if (FALSE) {
[10:30:48.321]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.321]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.321]     }
[10:30:48.321]     ...future.result <- base::tryCatch({
[10:30:48.321]         base::withCallingHandlers({
[10:30:48.321]             ...future.value <- base::withVisible(base::local({
[10:30:48.321]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.321]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.321]                   ...future.globals.maxSize)) {
[10:30:48.321]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.321]                   on.exit(options(oopts), add = TRUE)
[10:30:48.321]                 }
[10:30:48.321]                 {
[10:30:48.321]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.321]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.321]                     USE.NAMES = FALSE)
[10:30:48.321]                   do.call(mapply, args = args)
[10:30:48.321]                 }
[10:30:48.321]             }))
[10:30:48.321]             future::FutureResult(value = ...future.value$value, 
[10:30:48.321]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.321]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.321]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.321]                     ...future.globalenv.names))
[10:30:48.321]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.321]         }, condition = base::local({
[10:30:48.321]             c <- base::c
[10:30:48.321]             inherits <- base::inherits
[10:30:48.321]             invokeRestart <- base::invokeRestart
[10:30:48.321]             length <- base::length
[10:30:48.321]             list <- base::list
[10:30:48.321]             seq.int <- base::seq.int
[10:30:48.321]             signalCondition <- base::signalCondition
[10:30:48.321]             sys.calls <- base::sys.calls
[10:30:48.321]             `[[` <- base::`[[`
[10:30:48.321]             `+` <- base::`+`
[10:30:48.321]             `<<-` <- base::`<<-`
[10:30:48.321]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.321]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.321]                   3L)]
[10:30:48.321]             }
[10:30:48.321]             function(cond) {
[10:30:48.321]                 is_error <- inherits(cond, "error")
[10:30:48.321]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.321]                   NULL)
[10:30:48.321]                 if (is_error) {
[10:30:48.321]                   sessionInformation <- function() {
[10:30:48.321]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.321]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.321]                       search = base::search(), system = base::Sys.info())
[10:30:48.321]                   }
[10:30:48.321]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.321]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.321]                     cond$call), session = sessionInformation(), 
[10:30:48.321]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.321]                   signalCondition(cond)
[10:30:48.321]                 }
[10:30:48.321]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.321]                 "immediateCondition"))) {
[10:30:48.321]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.321]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.321]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.321]                   if (TRUE && !signal) {
[10:30:48.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.321]                     {
[10:30:48.321]                       inherits <- base::inherits
[10:30:48.321]                       invokeRestart <- base::invokeRestart
[10:30:48.321]                       is.null <- base::is.null
[10:30:48.321]                       muffled <- FALSE
[10:30:48.321]                       if (inherits(cond, "message")) {
[10:30:48.321]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.321]                         if (muffled) 
[10:30:48.321]                           invokeRestart("muffleMessage")
[10:30:48.321]                       }
[10:30:48.321]                       else if (inherits(cond, "warning")) {
[10:30:48.321]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.321]                         if (muffled) 
[10:30:48.321]                           invokeRestart("muffleWarning")
[10:30:48.321]                       }
[10:30:48.321]                       else if (inherits(cond, "condition")) {
[10:30:48.321]                         if (!is.null(pattern)) {
[10:30:48.321]                           computeRestarts <- base::computeRestarts
[10:30:48.321]                           grepl <- base::grepl
[10:30:48.321]                           restarts <- computeRestarts(cond)
[10:30:48.321]                           for (restart in restarts) {
[10:30:48.321]                             name <- restart$name
[10:30:48.321]                             if (is.null(name)) 
[10:30:48.321]                               next
[10:30:48.321]                             if (!grepl(pattern, name)) 
[10:30:48.321]                               next
[10:30:48.321]                             invokeRestart(restart)
[10:30:48.321]                             muffled <- TRUE
[10:30:48.321]                             break
[10:30:48.321]                           }
[10:30:48.321]                         }
[10:30:48.321]                       }
[10:30:48.321]                       invisible(muffled)
[10:30:48.321]                     }
[10:30:48.321]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.321]                   }
[10:30:48.321]                 }
[10:30:48.321]                 else {
[10:30:48.321]                   if (TRUE) {
[10:30:48.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.321]                     {
[10:30:48.321]                       inherits <- base::inherits
[10:30:48.321]                       invokeRestart <- base::invokeRestart
[10:30:48.321]                       is.null <- base::is.null
[10:30:48.321]                       muffled <- FALSE
[10:30:48.321]                       if (inherits(cond, "message")) {
[10:30:48.321]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.321]                         if (muffled) 
[10:30:48.321]                           invokeRestart("muffleMessage")
[10:30:48.321]                       }
[10:30:48.321]                       else if (inherits(cond, "warning")) {
[10:30:48.321]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.321]                         if (muffled) 
[10:30:48.321]                           invokeRestart("muffleWarning")
[10:30:48.321]                       }
[10:30:48.321]                       else if (inherits(cond, "condition")) {
[10:30:48.321]                         if (!is.null(pattern)) {
[10:30:48.321]                           computeRestarts <- base::computeRestarts
[10:30:48.321]                           grepl <- base::grepl
[10:30:48.321]                           restarts <- computeRestarts(cond)
[10:30:48.321]                           for (restart in restarts) {
[10:30:48.321]                             name <- restart$name
[10:30:48.321]                             if (is.null(name)) 
[10:30:48.321]                               next
[10:30:48.321]                             if (!grepl(pattern, name)) 
[10:30:48.321]                               next
[10:30:48.321]                             invokeRestart(restart)
[10:30:48.321]                             muffled <- TRUE
[10:30:48.321]                             break
[10:30:48.321]                           }
[10:30:48.321]                         }
[10:30:48.321]                       }
[10:30:48.321]                       invisible(muffled)
[10:30:48.321]                     }
[10:30:48.321]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.321]                   }
[10:30:48.321]                 }
[10:30:48.321]             }
[10:30:48.321]         }))
[10:30:48.321]     }, error = function(ex) {
[10:30:48.321]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.321]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.321]                 ...future.rng), started = ...future.startTime, 
[10:30:48.321]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.321]             version = "1.8"), class = "FutureResult")
[10:30:48.321]     }, finally = {
[10:30:48.321]         if (!identical(...future.workdir, getwd())) 
[10:30:48.321]             setwd(...future.workdir)
[10:30:48.321]         {
[10:30:48.321]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.321]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.321]             }
[10:30:48.321]             base::options(...future.oldOptions)
[10:30:48.321]             if (.Platform$OS.type == "windows") {
[10:30:48.321]                 old_names <- names(...future.oldEnvVars)
[10:30:48.321]                 envs <- base::Sys.getenv()
[10:30:48.321]                 names <- names(envs)
[10:30:48.321]                 common <- intersect(names, old_names)
[10:30:48.321]                 added <- setdiff(names, old_names)
[10:30:48.321]                 removed <- setdiff(old_names, names)
[10:30:48.321]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.321]                   envs[common]]
[10:30:48.321]                 NAMES <- toupper(changed)
[10:30:48.321]                 args <- list()
[10:30:48.321]                 for (kk in seq_along(NAMES)) {
[10:30:48.321]                   name <- changed[[kk]]
[10:30:48.321]                   NAME <- NAMES[[kk]]
[10:30:48.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.321]                     next
[10:30:48.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.321]                 }
[10:30:48.321]                 NAMES <- toupper(added)
[10:30:48.321]                 for (kk in seq_along(NAMES)) {
[10:30:48.321]                   name <- added[[kk]]
[10:30:48.321]                   NAME <- NAMES[[kk]]
[10:30:48.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.321]                     next
[10:30:48.321]                   args[[name]] <- ""
[10:30:48.321]                 }
[10:30:48.321]                 NAMES <- toupper(removed)
[10:30:48.321]                 for (kk in seq_along(NAMES)) {
[10:30:48.321]                   name <- removed[[kk]]
[10:30:48.321]                   NAME <- NAMES[[kk]]
[10:30:48.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.321]                     next
[10:30:48.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.321]                 }
[10:30:48.321]                 if (length(args) > 0) 
[10:30:48.321]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.321]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.321]             }
[10:30:48.321]             else {
[10:30:48.321]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.321]             }
[10:30:48.321]             {
[10:30:48.321]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.321]                   0L) {
[10:30:48.321]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.321]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.321]                   base::options(opts)
[10:30:48.321]                 }
[10:30:48.321]                 {
[10:30:48.321]                   {
[10:30:48.321]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.321]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.321]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.321]                       inherits = FALSE)
[10:30:48.321]                     NULL
[10:30:48.321]                   }
[10:30:48.321]                   options(future.plan = NULL)
[10:30:48.321]                   if (is.na(NA_character_)) 
[10:30:48.321]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.321]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.321]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.321]                     .init = FALSE)
[10:30:48.321]                 }
[10:30:48.321]             }
[10:30:48.321]         }
[10:30:48.321]     })
[10:30:48.321]     if (TRUE) {
[10:30:48.321]         base::sink(type = "output", split = FALSE)
[10:30:48.321]         if (TRUE) {
[10:30:48.321]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.321]         }
[10:30:48.321]         else {
[10:30:48.321]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.321]         }
[10:30:48.321]         base::close(...future.stdout)
[10:30:48.321]         ...future.stdout <- NULL
[10:30:48.321]     }
[10:30:48.321]     ...future.result$conditions <- ...future.conditions
[10:30:48.321]     ...future.result$finished <- base::Sys.time()
[10:30:48.321]     ...future.result
[10:30:48.321] }
[10:30:48.323] assign_globals() ...
[10:30:48.323] List of 5
[10:30:48.323]  $ ...future.FUN            :function (C, k)  
[10:30:48.323]  $ MoreArgs                 : NULL
[10:30:48.323]  $ ...future.elements_ii    :List of 2
[10:30:48.323]   ..$ :List of 1
[10:30:48.323]   .. ..$ : chr "C"
[10:30:48.323]   ..$ :List of 1
[10:30:48.323]   .. ..$ : int 3
[10:30:48.323]  $ ...future.seeds_ii       : NULL
[10:30:48.323]  $ ...future.globals.maxSize: NULL
[10:30:48.323]  - attr(*, "where")=List of 5
[10:30:48.323]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.323]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.323]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.323]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.323]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.323]  - attr(*, "resolved")= logi FALSE
[10:30:48.323]  - attr(*, "total_size")= num 3488
[10:30:48.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.323]  - attr(*, "already-done")= logi TRUE
[10:30:48.328] - reassign environment for ‘...future.FUN’
[10:30:48.328] - copied ‘...future.FUN’ to environment
[10:30:48.328] - copied ‘MoreArgs’ to environment
[10:30:48.328] - copied ‘...future.elements_ii’ to environment
[10:30:48.328] - copied ‘...future.seeds_ii’ to environment
[10:30:48.329] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.329] assign_globals() ... done
[10:30:48.329] plan(): Setting new future strategy stack:
[10:30:48.329] List of future strategies:
[10:30:48.329] 1. sequential:
[10:30:48.329]    - args: function (..., envir = parent.frame())
[10:30:48.329]    - tweaked: FALSE
[10:30:48.329]    - call: NULL
[10:30:48.329] plan(): nbrOfWorkers() = 1
[10:30:48.330] plan(): Setting new future strategy stack:
[10:30:48.330] List of future strategies:
[10:30:48.330] 1. sequential:
[10:30:48.330]    - args: function (..., envir = parent.frame())
[10:30:48.330]    - tweaked: FALSE
[10:30:48.330]    - call: plan(strategy)
[10:30:48.331] plan(): nbrOfWorkers() = 1
[10:30:48.331] SequentialFuture started (and completed)
[10:30:48.331] - Launch lazy future ... done
[10:30:48.331] run() for ‘SequentialFuture’ ... done
[10:30:48.331] Created future:
[10:30:48.331] SequentialFuture:
[10:30:48.331] Label: ‘future_mapply-3’
[10:30:48.331] Expression:
[10:30:48.331] {
[10:30:48.331]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.331]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.331]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.331]         on.exit(options(oopts), add = TRUE)
[10:30:48.331]     }
[10:30:48.331]     {
[10:30:48.331]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.331]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.331]         do.call(mapply, args = args)
[10:30:48.331]     }
[10:30:48.331] }
[10:30:48.331] Lazy evaluation: FALSE
[10:30:48.331] Asynchronous evaluation: FALSE
[10:30:48.331] Local evaluation: TRUE
[10:30:48.331] Environment: R_GlobalEnv
[10:30:48.331] Capture standard output: TRUE
[10:30:48.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.331] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.331] Packages: <none>
[10:30:48.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.331] Resolved: TRUE
[10:30:48.331] Value: 112 bytes of class ‘list’
[10:30:48.331] Early signaling: FALSE
[10:30:48.331] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.331] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.332] Chunk #3 of 5 ... DONE
[10:30:48.332] Chunk #4 of 5 ...
[10:30:48.332]  - Finding globals in '...' for chunk #4 ...
[10:30:48.332] getGlobalsAndPackages() ...
[10:30:48.332] Searching for globals...
[10:30:48.333] 
[10:30:48.333] Searching for globals ... DONE
[10:30:48.333] - globals: [0] <none>
[10:30:48.333] getGlobalsAndPackages() ... DONE
[10:30:48.333]    + additional globals found: [n=0] 
[10:30:48.333]    + additional namespaces needed: [n=0] 
[10:30:48.333]  - Finding globals in '...' for chunk #4 ... DONE
[10:30:48.333]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:48.333]  - seeds: <none>
[10:30:48.334]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.334] getGlobalsAndPackages() ...
[10:30:48.334] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.334] Resolving globals: FALSE
[10:30:48.334] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:48.335] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.335] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.335] 
[10:30:48.335] getGlobalsAndPackages() ... DONE
[10:30:48.335] run() for ‘Future’ ...
[10:30:48.335] - state: ‘created’
[10:30:48.336] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.336] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.336]   - Field: ‘label’
[10:30:48.336]   - Field: ‘local’
[10:30:48.336]   - Field: ‘owner’
[10:30:48.336]   - Field: ‘envir’
[10:30:48.336]   - Field: ‘packages’
[10:30:48.336]   - Field: ‘gc’
[10:30:48.337]   - Field: ‘conditions’
[10:30:48.337]   - Field: ‘expr’
[10:30:48.337]   - Field: ‘uuid’
[10:30:48.337]   - Field: ‘seed’
[10:30:48.337]   - Field: ‘version’
[10:30:48.337]   - Field: ‘result’
[10:30:48.337]   - Field: ‘asynchronous’
[10:30:48.337]   - Field: ‘calls’
[10:30:48.337]   - Field: ‘globals’
[10:30:48.337]   - Field: ‘stdout’
[10:30:48.338]   - Field: ‘earlySignal’
[10:30:48.338]   - Field: ‘lazy’
[10:30:48.338]   - Field: ‘state’
[10:30:48.338] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.338] - Launch lazy future ...
[10:30:48.338] Packages needed by the future expression (n = 0): <none>
[10:30:48.338] Packages needed by future strategies (n = 0): <none>
[10:30:48.339] {
[10:30:48.339]     {
[10:30:48.339]         {
[10:30:48.339]             ...future.startTime <- base::Sys.time()
[10:30:48.339]             {
[10:30:48.339]                 {
[10:30:48.339]                   {
[10:30:48.339]                     base::local({
[10:30:48.339]                       has_future <- base::requireNamespace("future", 
[10:30:48.339]                         quietly = TRUE)
[10:30:48.339]                       if (has_future) {
[10:30:48.339]                         ns <- base::getNamespace("future")
[10:30:48.339]                         version <- ns[[".package"]][["version"]]
[10:30:48.339]                         if (is.null(version)) 
[10:30:48.339]                           version <- utils::packageVersion("future")
[10:30:48.339]                       }
[10:30:48.339]                       else {
[10:30:48.339]                         version <- NULL
[10:30:48.339]                       }
[10:30:48.339]                       if (!has_future || version < "1.8.0") {
[10:30:48.339]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.339]                           "", base::R.version$version.string), 
[10:30:48.339]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.339]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.339]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.339]                             "release", "version")], collapse = " "), 
[10:30:48.339]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.339]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.339]                           info)
[10:30:48.339]                         info <- base::paste(info, collapse = "; ")
[10:30:48.339]                         if (!has_future) {
[10:30:48.339]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.339]                             info)
[10:30:48.339]                         }
[10:30:48.339]                         else {
[10:30:48.339]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.339]                             info, version)
[10:30:48.339]                         }
[10:30:48.339]                         base::stop(msg)
[10:30:48.339]                       }
[10:30:48.339]                     })
[10:30:48.339]                   }
[10:30:48.339]                   ...future.strategy.old <- future::plan("list")
[10:30:48.339]                   options(future.plan = NULL)
[10:30:48.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.339]                 }
[10:30:48.339]                 ...future.workdir <- getwd()
[10:30:48.339]             }
[10:30:48.339]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.339]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.339]         }
[10:30:48.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.339]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:48.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.339]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.339]             base::names(...future.oldOptions))
[10:30:48.339]     }
[10:30:48.339]     if (FALSE) {
[10:30:48.339]     }
[10:30:48.339]     else {
[10:30:48.339]         if (TRUE) {
[10:30:48.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.339]                 open = "w")
[10:30:48.339]         }
[10:30:48.339]         else {
[10:30:48.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.339]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.339]         }
[10:30:48.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.339]             base::sink(type = "output", split = FALSE)
[10:30:48.339]             base::close(...future.stdout)
[10:30:48.339]         }, add = TRUE)
[10:30:48.339]     }
[10:30:48.339]     ...future.frame <- base::sys.nframe()
[10:30:48.339]     ...future.conditions <- base::list()
[10:30:48.339]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.339]     if (FALSE) {
[10:30:48.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.339]     }
[10:30:48.339]     ...future.result <- base::tryCatch({
[10:30:48.339]         base::withCallingHandlers({
[10:30:48.339]             ...future.value <- base::withVisible(base::local({
[10:30:48.339]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.339]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.339]                   ...future.globals.maxSize)) {
[10:30:48.339]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.339]                   on.exit(options(oopts), add = TRUE)
[10:30:48.339]                 }
[10:30:48.339]                 {
[10:30:48.339]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.339]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.339]                     USE.NAMES = FALSE)
[10:30:48.339]                   do.call(mapply, args = args)
[10:30:48.339]                 }
[10:30:48.339]             }))
[10:30:48.339]             future::FutureResult(value = ...future.value$value, 
[10:30:48.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.339]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.339]                     ...future.globalenv.names))
[10:30:48.339]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.339]         }, condition = base::local({
[10:30:48.339]             c <- base::c
[10:30:48.339]             inherits <- base::inherits
[10:30:48.339]             invokeRestart <- base::invokeRestart
[10:30:48.339]             length <- base::length
[10:30:48.339]             list <- base::list
[10:30:48.339]             seq.int <- base::seq.int
[10:30:48.339]             signalCondition <- base::signalCondition
[10:30:48.339]             sys.calls <- base::sys.calls
[10:30:48.339]             `[[` <- base::`[[`
[10:30:48.339]             `+` <- base::`+`
[10:30:48.339]             `<<-` <- base::`<<-`
[10:30:48.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.339]                   3L)]
[10:30:48.339]             }
[10:30:48.339]             function(cond) {
[10:30:48.339]                 is_error <- inherits(cond, "error")
[10:30:48.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.339]                   NULL)
[10:30:48.339]                 if (is_error) {
[10:30:48.339]                   sessionInformation <- function() {
[10:30:48.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.339]                       search = base::search(), system = base::Sys.info())
[10:30:48.339]                   }
[10:30:48.339]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.339]                     cond$call), session = sessionInformation(), 
[10:30:48.339]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.339]                   signalCondition(cond)
[10:30:48.339]                 }
[10:30:48.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.339]                 "immediateCondition"))) {
[10:30:48.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.339]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.339]                   if (TRUE && !signal) {
[10:30:48.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.339]                     {
[10:30:48.339]                       inherits <- base::inherits
[10:30:48.339]                       invokeRestart <- base::invokeRestart
[10:30:48.339]                       is.null <- base::is.null
[10:30:48.339]                       muffled <- FALSE
[10:30:48.339]                       if (inherits(cond, "message")) {
[10:30:48.339]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.339]                         if (muffled) 
[10:30:48.339]                           invokeRestart("muffleMessage")
[10:30:48.339]                       }
[10:30:48.339]                       else if (inherits(cond, "warning")) {
[10:30:48.339]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.339]                         if (muffled) 
[10:30:48.339]                           invokeRestart("muffleWarning")
[10:30:48.339]                       }
[10:30:48.339]                       else if (inherits(cond, "condition")) {
[10:30:48.339]                         if (!is.null(pattern)) {
[10:30:48.339]                           computeRestarts <- base::computeRestarts
[10:30:48.339]                           grepl <- base::grepl
[10:30:48.339]                           restarts <- computeRestarts(cond)
[10:30:48.339]                           for (restart in restarts) {
[10:30:48.339]                             name <- restart$name
[10:30:48.339]                             if (is.null(name)) 
[10:30:48.339]                               next
[10:30:48.339]                             if (!grepl(pattern, name)) 
[10:30:48.339]                               next
[10:30:48.339]                             invokeRestart(restart)
[10:30:48.339]                             muffled <- TRUE
[10:30:48.339]                             break
[10:30:48.339]                           }
[10:30:48.339]                         }
[10:30:48.339]                       }
[10:30:48.339]                       invisible(muffled)
[10:30:48.339]                     }
[10:30:48.339]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.339]                   }
[10:30:48.339]                 }
[10:30:48.339]                 else {
[10:30:48.339]                   if (TRUE) {
[10:30:48.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.339]                     {
[10:30:48.339]                       inherits <- base::inherits
[10:30:48.339]                       invokeRestart <- base::invokeRestart
[10:30:48.339]                       is.null <- base::is.null
[10:30:48.339]                       muffled <- FALSE
[10:30:48.339]                       if (inherits(cond, "message")) {
[10:30:48.339]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.339]                         if (muffled) 
[10:30:48.339]                           invokeRestart("muffleMessage")
[10:30:48.339]                       }
[10:30:48.339]                       else if (inherits(cond, "warning")) {
[10:30:48.339]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.339]                         if (muffled) 
[10:30:48.339]                           invokeRestart("muffleWarning")
[10:30:48.339]                       }
[10:30:48.339]                       else if (inherits(cond, "condition")) {
[10:30:48.339]                         if (!is.null(pattern)) {
[10:30:48.339]                           computeRestarts <- base::computeRestarts
[10:30:48.339]                           grepl <- base::grepl
[10:30:48.339]                           restarts <- computeRestarts(cond)
[10:30:48.339]                           for (restart in restarts) {
[10:30:48.339]                             name <- restart$name
[10:30:48.339]                             if (is.null(name)) 
[10:30:48.339]                               next
[10:30:48.339]                             if (!grepl(pattern, name)) 
[10:30:48.339]                               next
[10:30:48.339]                             invokeRestart(restart)
[10:30:48.339]                             muffled <- TRUE
[10:30:48.339]                             break
[10:30:48.339]                           }
[10:30:48.339]                         }
[10:30:48.339]                       }
[10:30:48.339]                       invisible(muffled)
[10:30:48.339]                     }
[10:30:48.339]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.339]                   }
[10:30:48.339]                 }
[10:30:48.339]             }
[10:30:48.339]         }))
[10:30:48.339]     }, error = function(ex) {
[10:30:48.339]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.339]                 ...future.rng), started = ...future.startTime, 
[10:30:48.339]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.339]             version = "1.8"), class = "FutureResult")
[10:30:48.339]     }, finally = {
[10:30:48.339]         if (!identical(...future.workdir, getwd())) 
[10:30:48.339]             setwd(...future.workdir)
[10:30:48.339]         {
[10:30:48.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.339]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.339]             }
[10:30:48.339]             base::options(...future.oldOptions)
[10:30:48.339]             if (.Platform$OS.type == "windows") {
[10:30:48.339]                 old_names <- names(...future.oldEnvVars)
[10:30:48.339]                 envs <- base::Sys.getenv()
[10:30:48.339]                 names <- names(envs)
[10:30:48.339]                 common <- intersect(names, old_names)
[10:30:48.339]                 added <- setdiff(names, old_names)
[10:30:48.339]                 removed <- setdiff(old_names, names)
[10:30:48.339]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.339]                   envs[common]]
[10:30:48.339]                 NAMES <- toupper(changed)
[10:30:48.339]                 args <- list()
[10:30:48.339]                 for (kk in seq_along(NAMES)) {
[10:30:48.339]                   name <- changed[[kk]]
[10:30:48.339]                   NAME <- NAMES[[kk]]
[10:30:48.339]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.339]                     next
[10:30:48.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.339]                 }
[10:30:48.339]                 NAMES <- toupper(added)
[10:30:48.339]                 for (kk in seq_along(NAMES)) {
[10:30:48.339]                   name <- added[[kk]]
[10:30:48.339]                   NAME <- NAMES[[kk]]
[10:30:48.339]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.339]                     next
[10:30:48.339]                   args[[name]] <- ""
[10:30:48.339]                 }
[10:30:48.339]                 NAMES <- toupper(removed)
[10:30:48.339]                 for (kk in seq_along(NAMES)) {
[10:30:48.339]                   name <- removed[[kk]]
[10:30:48.339]                   NAME <- NAMES[[kk]]
[10:30:48.339]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.339]                     next
[10:30:48.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.339]                 }
[10:30:48.339]                 if (length(args) > 0) 
[10:30:48.339]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.339]             }
[10:30:48.339]             else {
[10:30:48.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.339]             }
[10:30:48.339]             {
[10:30:48.339]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.339]                   0L) {
[10:30:48.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.339]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.339]                   base::options(opts)
[10:30:48.339]                 }
[10:30:48.339]                 {
[10:30:48.339]                   {
[10:30:48.339]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.339]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.339]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.339]                       inherits = FALSE)
[10:30:48.339]                     NULL
[10:30:48.339]                   }
[10:30:48.339]                   options(future.plan = NULL)
[10:30:48.339]                   if (is.na(NA_character_)) 
[10:30:48.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.339]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.339]                     .init = FALSE)
[10:30:48.339]                 }
[10:30:48.339]             }
[10:30:48.339]         }
[10:30:48.339]     })
[10:30:48.339]     if (TRUE) {
[10:30:48.339]         base::sink(type = "output", split = FALSE)
[10:30:48.339]         if (TRUE) {
[10:30:48.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.339]         }
[10:30:48.339]         else {
[10:30:48.339]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.339]         }
[10:30:48.339]         base::close(...future.stdout)
[10:30:48.339]         ...future.stdout <- NULL
[10:30:48.339]     }
[10:30:48.339]     ...future.result$conditions <- ...future.conditions
[10:30:48.339]     ...future.result$finished <- base::Sys.time()
[10:30:48.339]     ...future.result
[10:30:48.339] }
[10:30:48.340] assign_globals() ...
[10:30:48.340] List of 5
[10:30:48.340]  $ ...future.FUN            :function (C, k)  
[10:30:48.340]  $ MoreArgs                 : NULL
[10:30:48.340]  $ ...future.elements_ii    :List of 2
[10:30:48.340]   ..$ :List of 1
[10:30:48.340]   .. ..$ : chr "D"
[10:30:48.340]   ..$ :List of 1
[10:30:48.340]   .. ..$ : int 2
[10:30:48.340]  $ ...future.seeds_ii       : NULL
[10:30:48.340]  $ ...future.globals.maxSize: NULL
[10:30:48.340]  - attr(*, "where")=List of 5
[10:30:48.340]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.340]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.340]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.340]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.340]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.340]  - attr(*, "resolved")= logi FALSE
[10:30:48.340]  - attr(*, "total_size")= num 3488
[10:30:48.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.340]  - attr(*, "already-done")= logi TRUE
[10:30:48.347] - reassign environment for ‘...future.FUN’
[10:30:48.347] - copied ‘...future.FUN’ to environment
[10:30:48.347] - copied ‘MoreArgs’ to environment
[10:30:48.347] - copied ‘...future.elements_ii’ to environment
[10:30:48.347] - copied ‘...future.seeds_ii’ to environment
[10:30:48.347] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.348] assign_globals() ... done
[10:30:48.348] plan(): Setting new future strategy stack:
[10:30:48.348] List of future strategies:
[10:30:48.348] 1. sequential:
[10:30:48.348]    - args: function (..., envir = parent.frame())
[10:30:48.348]    - tweaked: FALSE
[10:30:48.348]    - call: NULL
[10:30:48.348] plan(): nbrOfWorkers() = 1
[10:30:48.349] plan(): Setting new future strategy stack:
[10:30:48.349] List of future strategies:
[10:30:48.349] 1. sequential:
[10:30:48.349]    - args: function (..., envir = parent.frame())
[10:30:48.349]    - tweaked: FALSE
[10:30:48.349]    - call: plan(strategy)
[10:30:48.349] plan(): nbrOfWorkers() = 1
[10:30:48.350] SequentialFuture started (and completed)
[10:30:48.350] - Launch lazy future ... done
[10:30:48.350] run() for ‘SequentialFuture’ ... done
[10:30:48.350] Created future:
[10:30:48.350] SequentialFuture:
[10:30:48.350] Label: ‘future_mapply-4’
[10:30:48.350] Expression:
[10:30:48.350] {
[10:30:48.350]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.350]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.350]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.350]         on.exit(options(oopts), add = TRUE)
[10:30:48.350]     }
[10:30:48.350]     {
[10:30:48.350]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.350]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.350]         do.call(mapply, args = args)
[10:30:48.350]     }
[10:30:48.350] }
[10:30:48.350] Lazy evaluation: FALSE
[10:30:48.350] Asynchronous evaluation: FALSE
[10:30:48.350] Local evaluation: TRUE
[10:30:48.350] Environment: R_GlobalEnv
[10:30:48.350] Capture standard output: TRUE
[10:30:48.350] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.350] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.350] Packages: <none>
[10:30:48.350] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.350] Resolved: TRUE
[10:30:48.350] Value: 112 bytes of class ‘list’
[10:30:48.350] Early signaling: FALSE
[10:30:48.350] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.350] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.351] Chunk #4 of 5 ... DONE
[10:30:48.351] Chunk #5 of 5 ...
[10:30:48.351]  - Finding globals in '...' for chunk #5 ...
[10:30:48.351] getGlobalsAndPackages() ...
[10:30:48.351] Searching for globals...
[10:30:48.352] 
[10:30:48.352] Searching for globals ... DONE
[10:30:48.352] - globals: [0] <none>
[10:30:48.352] getGlobalsAndPackages() ... DONE
[10:30:48.352]    + additional globals found: [n=0] 
[10:30:48.352]    + additional namespaces needed: [n=0] 
[10:30:48.352]  - Finding globals in '...' for chunk #5 ... DONE
[10:30:48.352]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:48.352]  - seeds: <none>
[10:30:48.352]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.353] getGlobalsAndPackages() ...
[10:30:48.353] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.353] Resolving globals: FALSE
[10:30:48.353] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:48.354] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.354] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.354] 
[10:30:48.354] getGlobalsAndPackages() ... DONE
[10:30:48.354] run() for ‘Future’ ...
[10:30:48.354] - state: ‘created’
[10:30:48.355] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.355] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.355]   - Field: ‘label’
[10:30:48.355]   - Field: ‘local’
[10:30:48.355]   - Field: ‘owner’
[10:30:48.355]   - Field: ‘envir’
[10:30:48.355]   - Field: ‘packages’
[10:30:48.356]   - Field: ‘gc’
[10:30:48.356]   - Field: ‘conditions’
[10:30:48.356]   - Field: ‘expr’
[10:30:48.356]   - Field: ‘uuid’
[10:30:48.356]   - Field: ‘seed’
[10:30:48.356]   - Field: ‘version’
[10:30:48.356]   - Field: ‘result’
[10:30:48.356]   - Field: ‘asynchronous’
[10:30:48.356]   - Field: ‘calls’
[10:30:48.356]   - Field: ‘globals’
[10:30:48.356]   - Field: ‘stdout’
[10:30:48.356]   - Field: ‘earlySignal’
[10:30:48.357]   - Field: ‘lazy’
[10:30:48.357]   - Field: ‘state’
[10:30:48.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.357] - Launch lazy future ...
[10:30:48.357] Packages needed by the future expression (n = 0): <none>
[10:30:48.357] Packages needed by future strategies (n = 0): <none>
[10:30:48.358] {
[10:30:48.358]     {
[10:30:48.358]         {
[10:30:48.358]             ...future.startTime <- base::Sys.time()
[10:30:48.358]             {
[10:30:48.358]                 {
[10:30:48.358]                   {
[10:30:48.358]                     base::local({
[10:30:48.358]                       has_future <- base::requireNamespace("future", 
[10:30:48.358]                         quietly = TRUE)
[10:30:48.358]                       if (has_future) {
[10:30:48.358]                         ns <- base::getNamespace("future")
[10:30:48.358]                         version <- ns[[".package"]][["version"]]
[10:30:48.358]                         if (is.null(version)) 
[10:30:48.358]                           version <- utils::packageVersion("future")
[10:30:48.358]                       }
[10:30:48.358]                       else {
[10:30:48.358]                         version <- NULL
[10:30:48.358]                       }
[10:30:48.358]                       if (!has_future || version < "1.8.0") {
[10:30:48.358]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.358]                           "", base::R.version$version.string), 
[10:30:48.358]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.358]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.358]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.358]                             "release", "version")], collapse = " "), 
[10:30:48.358]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.358]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.358]                           info)
[10:30:48.358]                         info <- base::paste(info, collapse = "; ")
[10:30:48.358]                         if (!has_future) {
[10:30:48.358]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.358]                             info)
[10:30:48.358]                         }
[10:30:48.358]                         else {
[10:30:48.358]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.358]                             info, version)
[10:30:48.358]                         }
[10:30:48.358]                         base::stop(msg)
[10:30:48.358]                       }
[10:30:48.358]                     })
[10:30:48.358]                   }
[10:30:48.358]                   ...future.strategy.old <- future::plan("list")
[10:30:48.358]                   options(future.plan = NULL)
[10:30:48.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.358]                 }
[10:30:48.358]                 ...future.workdir <- getwd()
[10:30:48.358]             }
[10:30:48.358]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.358]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.358]         }
[10:30:48.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.358]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:48.358]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.358]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.358]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.358]             base::names(...future.oldOptions))
[10:30:48.358]     }
[10:30:48.358]     if (FALSE) {
[10:30:48.358]     }
[10:30:48.358]     else {
[10:30:48.358]         if (TRUE) {
[10:30:48.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.358]                 open = "w")
[10:30:48.358]         }
[10:30:48.358]         else {
[10:30:48.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.358]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.358]         }
[10:30:48.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.358]             base::sink(type = "output", split = FALSE)
[10:30:48.358]             base::close(...future.stdout)
[10:30:48.358]         }, add = TRUE)
[10:30:48.358]     }
[10:30:48.358]     ...future.frame <- base::sys.nframe()
[10:30:48.358]     ...future.conditions <- base::list()
[10:30:48.358]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.358]     if (FALSE) {
[10:30:48.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.358]     }
[10:30:48.358]     ...future.result <- base::tryCatch({
[10:30:48.358]         base::withCallingHandlers({
[10:30:48.358]             ...future.value <- base::withVisible(base::local({
[10:30:48.358]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.358]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.358]                   ...future.globals.maxSize)) {
[10:30:48.358]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.358]                   on.exit(options(oopts), add = TRUE)
[10:30:48.358]                 }
[10:30:48.358]                 {
[10:30:48.358]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.358]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.358]                     USE.NAMES = FALSE)
[10:30:48.358]                   do.call(mapply, args = args)
[10:30:48.358]                 }
[10:30:48.358]             }))
[10:30:48.358]             future::FutureResult(value = ...future.value$value, 
[10:30:48.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.358]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.358]                     ...future.globalenv.names))
[10:30:48.358]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.358]         }, condition = base::local({
[10:30:48.358]             c <- base::c
[10:30:48.358]             inherits <- base::inherits
[10:30:48.358]             invokeRestart <- base::invokeRestart
[10:30:48.358]             length <- base::length
[10:30:48.358]             list <- base::list
[10:30:48.358]             seq.int <- base::seq.int
[10:30:48.358]             signalCondition <- base::signalCondition
[10:30:48.358]             sys.calls <- base::sys.calls
[10:30:48.358]             `[[` <- base::`[[`
[10:30:48.358]             `+` <- base::`+`
[10:30:48.358]             `<<-` <- base::`<<-`
[10:30:48.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.358]                   3L)]
[10:30:48.358]             }
[10:30:48.358]             function(cond) {
[10:30:48.358]                 is_error <- inherits(cond, "error")
[10:30:48.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.358]                   NULL)
[10:30:48.358]                 if (is_error) {
[10:30:48.358]                   sessionInformation <- function() {
[10:30:48.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.358]                       search = base::search(), system = base::Sys.info())
[10:30:48.358]                   }
[10:30:48.358]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.358]                     cond$call), session = sessionInformation(), 
[10:30:48.358]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.358]                   signalCondition(cond)
[10:30:48.358]                 }
[10:30:48.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.358]                 "immediateCondition"))) {
[10:30:48.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.358]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.358]                   if (TRUE && !signal) {
[10:30:48.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.358]                     {
[10:30:48.358]                       inherits <- base::inherits
[10:30:48.358]                       invokeRestart <- base::invokeRestart
[10:30:48.358]                       is.null <- base::is.null
[10:30:48.358]                       muffled <- FALSE
[10:30:48.358]                       if (inherits(cond, "message")) {
[10:30:48.358]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.358]                         if (muffled) 
[10:30:48.358]                           invokeRestart("muffleMessage")
[10:30:48.358]                       }
[10:30:48.358]                       else if (inherits(cond, "warning")) {
[10:30:48.358]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.358]                         if (muffled) 
[10:30:48.358]                           invokeRestart("muffleWarning")
[10:30:48.358]                       }
[10:30:48.358]                       else if (inherits(cond, "condition")) {
[10:30:48.358]                         if (!is.null(pattern)) {
[10:30:48.358]                           computeRestarts <- base::computeRestarts
[10:30:48.358]                           grepl <- base::grepl
[10:30:48.358]                           restarts <- computeRestarts(cond)
[10:30:48.358]                           for (restart in restarts) {
[10:30:48.358]                             name <- restart$name
[10:30:48.358]                             if (is.null(name)) 
[10:30:48.358]                               next
[10:30:48.358]                             if (!grepl(pattern, name)) 
[10:30:48.358]                               next
[10:30:48.358]                             invokeRestart(restart)
[10:30:48.358]                             muffled <- TRUE
[10:30:48.358]                             break
[10:30:48.358]                           }
[10:30:48.358]                         }
[10:30:48.358]                       }
[10:30:48.358]                       invisible(muffled)
[10:30:48.358]                     }
[10:30:48.358]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.358]                   }
[10:30:48.358]                 }
[10:30:48.358]                 else {
[10:30:48.358]                   if (TRUE) {
[10:30:48.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.358]                     {
[10:30:48.358]                       inherits <- base::inherits
[10:30:48.358]                       invokeRestart <- base::invokeRestart
[10:30:48.358]                       is.null <- base::is.null
[10:30:48.358]                       muffled <- FALSE
[10:30:48.358]                       if (inherits(cond, "message")) {
[10:30:48.358]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.358]                         if (muffled) 
[10:30:48.358]                           invokeRestart("muffleMessage")
[10:30:48.358]                       }
[10:30:48.358]                       else if (inherits(cond, "warning")) {
[10:30:48.358]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.358]                         if (muffled) 
[10:30:48.358]                           invokeRestart("muffleWarning")
[10:30:48.358]                       }
[10:30:48.358]                       else if (inherits(cond, "condition")) {
[10:30:48.358]                         if (!is.null(pattern)) {
[10:30:48.358]                           computeRestarts <- base::computeRestarts
[10:30:48.358]                           grepl <- base::grepl
[10:30:48.358]                           restarts <- computeRestarts(cond)
[10:30:48.358]                           for (restart in restarts) {
[10:30:48.358]                             name <- restart$name
[10:30:48.358]                             if (is.null(name)) 
[10:30:48.358]                               next
[10:30:48.358]                             if (!grepl(pattern, name)) 
[10:30:48.358]                               next
[10:30:48.358]                             invokeRestart(restart)
[10:30:48.358]                             muffled <- TRUE
[10:30:48.358]                             break
[10:30:48.358]                           }
[10:30:48.358]                         }
[10:30:48.358]                       }
[10:30:48.358]                       invisible(muffled)
[10:30:48.358]                     }
[10:30:48.358]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.358]                   }
[10:30:48.358]                 }
[10:30:48.358]             }
[10:30:48.358]         }))
[10:30:48.358]     }, error = function(ex) {
[10:30:48.358]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.358]                 ...future.rng), started = ...future.startTime, 
[10:30:48.358]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.358]             version = "1.8"), class = "FutureResult")
[10:30:48.358]     }, finally = {
[10:30:48.358]         if (!identical(...future.workdir, getwd())) 
[10:30:48.358]             setwd(...future.workdir)
[10:30:48.358]         {
[10:30:48.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.358]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.358]             }
[10:30:48.358]             base::options(...future.oldOptions)
[10:30:48.358]             if (.Platform$OS.type == "windows") {
[10:30:48.358]                 old_names <- names(...future.oldEnvVars)
[10:30:48.358]                 envs <- base::Sys.getenv()
[10:30:48.358]                 names <- names(envs)
[10:30:48.358]                 common <- intersect(names, old_names)
[10:30:48.358]                 added <- setdiff(names, old_names)
[10:30:48.358]                 removed <- setdiff(old_names, names)
[10:30:48.358]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.358]                   envs[common]]
[10:30:48.358]                 NAMES <- toupper(changed)
[10:30:48.358]                 args <- list()
[10:30:48.358]                 for (kk in seq_along(NAMES)) {
[10:30:48.358]                   name <- changed[[kk]]
[10:30:48.358]                   NAME <- NAMES[[kk]]
[10:30:48.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.358]                     next
[10:30:48.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.358]                 }
[10:30:48.358]                 NAMES <- toupper(added)
[10:30:48.358]                 for (kk in seq_along(NAMES)) {
[10:30:48.358]                   name <- added[[kk]]
[10:30:48.358]                   NAME <- NAMES[[kk]]
[10:30:48.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.358]                     next
[10:30:48.358]                   args[[name]] <- ""
[10:30:48.358]                 }
[10:30:48.358]                 NAMES <- toupper(removed)
[10:30:48.358]                 for (kk in seq_along(NAMES)) {
[10:30:48.358]                   name <- removed[[kk]]
[10:30:48.358]                   NAME <- NAMES[[kk]]
[10:30:48.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.358]                     next
[10:30:48.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.358]                 }
[10:30:48.358]                 if (length(args) > 0) 
[10:30:48.358]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.358]             }
[10:30:48.358]             else {
[10:30:48.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.358]             }
[10:30:48.358]             {
[10:30:48.358]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.358]                   0L) {
[10:30:48.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.358]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.358]                   base::options(opts)
[10:30:48.358]                 }
[10:30:48.358]                 {
[10:30:48.358]                   {
[10:30:48.358]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.358]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.358]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.358]                       inherits = FALSE)
[10:30:48.358]                     NULL
[10:30:48.358]                   }
[10:30:48.358]                   options(future.plan = NULL)
[10:30:48.358]                   if (is.na(NA_character_)) 
[10:30:48.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.358]                     .init = FALSE)
[10:30:48.358]                 }
[10:30:48.358]             }
[10:30:48.358]         }
[10:30:48.358]     })
[10:30:48.358]     if (TRUE) {
[10:30:48.358]         base::sink(type = "output", split = FALSE)
[10:30:48.358]         if (TRUE) {
[10:30:48.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.358]         }
[10:30:48.358]         else {
[10:30:48.358]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.358]         }
[10:30:48.358]         base::close(...future.stdout)
[10:30:48.358]         ...future.stdout <- NULL
[10:30:48.358]     }
[10:30:48.358]     ...future.result$conditions <- ...future.conditions
[10:30:48.358]     ...future.result$finished <- base::Sys.time()
[10:30:48.358]     ...future.result
[10:30:48.358] }
[10:30:48.359] assign_globals() ...
[10:30:48.359] List of 5
[10:30:48.359]  $ ...future.FUN            :function (C, k)  
[10:30:48.359]  $ MoreArgs                 : NULL
[10:30:48.359]  $ ...future.elements_ii    :List of 2
[10:30:48.359]   ..$ :List of 1
[10:30:48.359]   .. ..$ : chr "E"
[10:30:48.359]   ..$ :List of 1
[10:30:48.359]   .. ..$ : int 1
[10:30:48.359]  $ ...future.seeds_ii       : NULL
[10:30:48.359]  $ ...future.globals.maxSize: NULL
[10:30:48.359]  - attr(*, "where")=List of 5
[10:30:48.359]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.359]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.359]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.359]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.359]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.359]  - attr(*, "resolved")= logi FALSE
[10:30:48.359]  - attr(*, "total_size")= num 3488
[10:30:48.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.359]  - attr(*, "already-done")= logi TRUE
[10:30:48.364] - reassign environment for ‘...future.FUN’
[10:30:48.364] - copied ‘...future.FUN’ to environment
[10:30:48.364] - copied ‘MoreArgs’ to environment
[10:30:48.364] - copied ‘...future.elements_ii’ to environment
[10:30:48.365] - copied ‘...future.seeds_ii’ to environment
[10:30:48.365] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.365] assign_globals() ... done
[10:30:48.365] plan(): Setting new future strategy stack:
[10:30:48.365] List of future strategies:
[10:30:48.365] 1. sequential:
[10:30:48.365]    - args: function (..., envir = parent.frame())
[10:30:48.365]    - tweaked: FALSE
[10:30:48.365]    - call: NULL
[10:30:48.365] plan(): nbrOfWorkers() = 1
[10:30:48.366] plan(): Setting new future strategy stack:
[10:30:48.366] List of future strategies:
[10:30:48.366] 1. sequential:
[10:30:48.366]    - args: function (..., envir = parent.frame())
[10:30:48.366]    - tweaked: FALSE
[10:30:48.366]    - call: plan(strategy)
[10:30:48.367] plan(): nbrOfWorkers() = 1
[10:30:48.367] SequentialFuture started (and completed)
[10:30:48.367] - Launch lazy future ... done
[10:30:48.367] run() for ‘SequentialFuture’ ... done
[10:30:48.367] Created future:
[10:30:48.367] SequentialFuture:
[10:30:48.367] Label: ‘future_mapply-5’
[10:30:48.367] Expression:
[10:30:48.367] {
[10:30:48.367]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.367]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.367]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.367]         on.exit(options(oopts), add = TRUE)
[10:30:48.367]     }
[10:30:48.367]     {
[10:30:48.367]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.367]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.367]         do.call(mapply, args = args)
[10:30:48.367]     }
[10:30:48.367] }
[10:30:48.367] Lazy evaluation: FALSE
[10:30:48.367] Asynchronous evaluation: FALSE
[10:30:48.367] Local evaluation: TRUE
[10:30:48.367] Environment: R_GlobalEnv
[10:30:48.367] Capture standard output: TRUE
[10:30:48.367] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.367] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.367] Packages: <none>
[10:30:48.367] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.367] Resolved: TRUE
[10:30:48.367] Value: 112 bytes of class ‘list’
[10:30:48.367] Early signaling: FALSE
[10:30:48.367] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.367] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.368] Chunk #5 of 5 ... DONE
[10:30:48.368] Launching 5 futures (chunks) ... DONE
[10:30:48.368] Resolving 5 futures (chunks) ...
[10:30:48.368] resolve() on list ...
[10:30:48.368]  recursive: 0
[10:30:48.369]  length: 5
[10:30:48.369] 
[10:30:48.369] resolved() for ‘SequentialFuture’ ...
[10:30:48.370] - state: ‘finished’
[10:30:48.370] - run: TRUE
[10:30:48.371] - result: ‘FutureResult’
[10:30:48.371] resolved() for ‘SequentialFuture’ ... done
[10:30:48.371] Future #1
[10:30:48.371] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.371] - nx: 5
[10:30:48.371] - relay: TRUE
[10:30:48.371] - stdout: TRUE
[10:30:48.371] - signal: TRUE
[10:30:48.371] - resignal: FALSE
[10:30:48.371] - force: TRUE
[10:30:48.372] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:30:48.372] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:30:48.372]  - until=1
[10:30:48.372]  - relaying element #1
[10:30:48.372] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:48.372] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:48.372] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.372]  length: 4 (resolved future 1)
[10:30:48.373] resolved() for ‘SequentialFuture’ ...
[10:30:48.373] - state: ‘finished’
[10:30:48.373] - run: TRUE
[10:30:48.373] - result: ‘FutureResult’
[10:30:48.373] resolved() for ‘SequentialFuture’ ... done
[10:30:48.373] Future #2
[10:30:48.373] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:30:48.373] - nx: 5
[10:30:48.373] - relay: TRUE
[10:30:48.373] - stdout: TRUE
[10:30:48.374] - signal: TRUE
[10:30:48.374] - resignal: FALSE
[10:30:48.374] - force: TRUE
[10:30:48.374] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:48.374] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:48.374]  - until=2
[10:30:48.374]  - relaying element #2
[10:30:48.374] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:48.374] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:48.374] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:30:48.375]  length: 3 (resolved future 2)
[10:30:48.375] resolved() for ‘SequentialFuture’ ...
[10:30:48.375] - state: ‘finished’
[10:30:48.375] - run: TRUE
[10:30:48.375] - result: ‘FutureResult’
[10:30:48.375] resolved() for ‘SequentialFuture’ ... done
[10:30:48.375] Future #3
[10:30:48.375] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:30:48.375] - nx: 5
[10:30:48.375] - relay: TRUE
[10:30:48.375] - stdout: TRUE
[10:30:48.376] - signal: TRUE
[10:30:48.376] - resignal: FALSE
[10:30:48.376] - force: TRUE
[10:30:48.376] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:48.376] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:48.376]  - until=3
[10:30:48.376]  - relaying element #3
[10:30:48.376] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:48.376] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:48.376] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:30:48.377]  length: 2 (resolved future 3)
[10:30:48.377] resolved() for ‘SequentialFuture’ ...
[10:30:48.377] - state: ‘finished’
[10:30:48.377] - run: TRUE
[10:30:48.377] - result: ‘FutureResult’
[10:30:48.377] resolved() for ‘SequentialFuture’ ... done
[10:30:48.377] Future #4
[10:30:48.377] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:30:48.377] - nx: 5
[10:30:48.377] - relay: TRUE
[10:30:48.378] - stdout: TRUE
[10:30:48.378] - signal: TRUE
[10:30:48.378] - resignal: FALSE
[10:30:48.378] - force: TRUE
[10:30:48.378] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:48.378] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:48.378]  - until=4
[10:30:48.378]  - relaying element #4
[10:30:48.378] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:48.378] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:48.378] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:30:48.379]  length: 1 (resolved future 4)
[10:30:48.379] resolved() for ‘SequentialFuture’ ...
[10:30:48.379] - state: ‘finished’
[10:30:48.379] - run: TRUE
[10:30:48.379] - result: ‘FutureResult’
[10:30:48.379] resolved() for ‘SequentialFuture’ ... done
[10:30:48.379] Future #5
[10:30:48.379] signalConditionsASAP(SequentialFuture, pos=5) ...
[10:30:48.379] - nx: 5
[10:30:48.379] - relay: TRUE
[10:30:48.379] - stdout: TRUE
[10:30:48.380] - signal: TRUE
[10:30:48.380] - resignal: FALSE
[10:30:48.380] - force: TRUE
[10:30:48.380] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:48.380] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:48.380]  - until=5
[10:30:48.380]  - relaying element #5
[10:30:48.380] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:48.380] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:48.380] signalConditionsASAP(SequentialFuture, pos=5) ... done
[10:30:48.380]  length: 0 (resolved future 5)
[10:30:48.381] Relaying remaining futures
[10:30:48.381] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.381] - nx: 5
[10:30:48.381] - relay: TRUE
[10:30:48.381] - stdout: TRUE
[10:30:48.381] - signal: TRUE
[10:30:48.381] - resignal: FALSE
[10:30:48.381] - force: TRUE
[10:30:48.381] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:48.381] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[10:30:48.381] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:48.382] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:48.382] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.382] resolve() on list ... DONE
[10:30:48.382]  - Number of value chunks collected: 5
[10:30:48.382] Resolving 5 futures (chunks) ... DONE
[10:30:48.382] Reducing values from 5 chunks ...
[10:30:48.382]  - Number of values collected after concatenation: 5
[10:30:48.382]  - Number of values expected: 5
[10:30:48.382] Reducing values from 5 chunks ... DONE
[10:30:48.383] future_mapply() ... DONE
[10:30:48.383] future_mapply() ...
[10:30:48.383] Number of chunks: 1
[10:30:48.383] getGlobalsAndPackagesXApply() ...
[10:30:48.383]  - future.globals: TRUE
[10:30:48.383] getGlobalsAndPackages() ...
[10:30:48.383] Searching for globals...
[10:30:48.385] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:48.385] Searching for globals ... DONE
[10:30:48.385] Resolving globals: FALSE
[10:30:48.385] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:48.386] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:48.386] - globals: [1] ‘FUN’
[10:30:48.386] 
[10:30:48.386] getGlobalsAndPackages() ... DONE
[10:30:48.386]  - globals found/used: [n=1] ‘FUN’
[10:30:48.386]  - needed namespaces: [n=0] 
[10:30:48.386] Finding globals ... DONE
[10:30:48.386] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.386] List of 2
[10:30:48.386]  $ ...future.FUN:function (C, k)  
[10:30:48.386]  $ MoreArgs     : list()
[10:30:48.386]  - attr(*, "where")=List of 2
[10:30:48.386]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.386]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.386]  - attr(*, "resolved")= logi FALSE
[10:30:48.386]  - attr(*, "total_size")= num NA
[10:30:48.389] Packages to be attached in all futures: [n=0] 
[10:30:48.389] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.389] Number of futures (= number of chunks): 1
[10:30:48.389] Launching 1 futures (chunks) ...
[10:30:48.389] Chunk #1 of 1 ...
[10:30:48.390]  - Finding globals in '...' for chunk #1 ...
[10:30:48.390] getGlobalsAndPackages() ...
[10:30:48.390] Searching for globals...
[10:30:48.390] 
[10:30:48.390] Searching for globals ... DONE
[10:30:48.390] - globals: [0] <none>
[10:30:48.390] getGlobalsAndPackages() ... DONE
[10:30:48.390]    + additional globals found: [n=0] 
[10:30:48.390]    + additional namespaces needed: [n=0] 
[10:30:48.391]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.391]  - seeds: <none>
[10:30:48.391]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.391] getGlobalsAndPackages() ...
[10:30:48.391] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.391] Resolving globals: FALSE
[10:30:48.392] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[10:30:48.392] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:48.392] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.394] 
[10:30:48.394] getGlobalsAndPackages() ... DONE
[10:30:48.394] run() for ‘Future’ ...
[10:30:48.394] - state: ‘created’
[10:30:48.394] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.395] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.395] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.395]   - Field: ‘label’
[10:30:48.395]   - Field: ‘local’
[10:30:48.395]   - Field: ‘owner’
[10:30:48.395]   - Field: ‘envir’
[10:30:48.395]   - Field: ‘packages’
[10:30:48.395]   - Field: ‘gc’
[10:30:48.395]   - Field: ‘conditions’
[10:30:48.396]   - Field: ‘expr’
[10:30:48.396]   - Field: ‘uuid’
[10:30:48.396]   - Field: ‘seed’
[10:30:48.396]   - Field: ‘version’
[10:30:48.396]   - Field: ‘result’
[10:30:48.396]   - Field: ‘asynchronous’
[10:30:48.396]   - Field: ‘calls’
[10:30:48.396]   - Field: ‘globals’
[10:30:48.396]   - Field: ‘stdout’
[10:30:48.396]   - Field: ‘earlySignal’
[10:30:48.396]   - Field: ‘lazy’
[10:30:48.397]   - Field: ‘state’
[10:30:48.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.397] - Launch lazy future ...
[10:30:48.397] Packages needed by the future expression (n = 0): <none>
[10:30:48.397] Packages needed by future strategies (n = 0): <none>
[10:30:48.397] {
[10:30:48.397]     {
[10:30:48.397]         {
[10:30:48.397]             ...future.startTime <- base::Sys.time()
[10:30:48.397]             {
[10:30:48.397]                 {
[10:30:48.397]                   {
[10:30:48.397]                     base::local({
[10:30:48.397]                       has_future <- base::requireNamespace("future", 
[10:30:48.397]                         quietly = TRUE)
[10:30:48.397]                       if (has_future) {
[10:30:48.397]                         ns <- base::getNamespace("future")
[10:30:48.397]                         version <- ns[[".package"]][["version"]]
[10:30:48.397]                         if (is.null(version)) 
[10:30:48.397]                           version <- utils::packageVersion("future")
[10:30:48.397]                       }
[10:30:48.397]                       else {
[10:30:48.397]                         version <- NULL
[10:30:48.397]                       }
[10:30:48.397]                       if (!has_future || version < "1.8.0") {
[10:30:48.397]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.397]                           "", base::R.version$version.string), 
[10:30:48.397]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.397]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.397]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.397]                             "release", "version")], collapse = " "), 
[10:30:48.397]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.397]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.397]                           info)
[10:30:48.397]                         info <- base::paste(info, collapse = "; ")
[10:30:48.397]                         if (!has_future) {
[10:30:48.397]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.397]                             info)
[10:30:48.397]                         }
[10:30:48.397]                         else {
[10:30:48.397]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.397]                             info, version)
[10:30:48.397]                         }
[10:30:48.397]                         base::stop(msg)
[10:30:48.397]                       }
[10:30:48.397]                     })
[10:30:48.397]                   }
[10:30:48.397]                   ...future.strategy.old <- future::plan("list")
[10:30:48.397]                   options(future.plan = NULL)
[10:30:48.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.397]                 }
[10:30:48.397]                 ...future.workdir <- getwd()
[10:30:48.397]             }
[10:30:48.397]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.397]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.397]         }
[10:30:48.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.397]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.397]             base::names(...future.oldOptions))
[10:30:48.397]     }
[10:30:48.397]     if (FALSE) {
[10:30:48.397]     }
[10:30:48.397]     else {
[10:30:48.397]         if (TRUE) {
[10:30:48.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.397]                 open = "w")
[10:30:48.397]         }
[10:30:48.397]         else {
[10:30:48.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.397]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.397]         }
[10:30:48.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.397]             base::sink(type = "output", split = FALSE)
[10:30:48.397]             base::close(...future.stdout)
[10:30:48.397]         }, add = TRUE)
[10:30:48.397]     }
[10:30:48.397]     ...future.frame <- base::sys.nframe()
[10:30:48.397]     ...future.conditions <- base::list()
[10:30:48.397]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.397]     if (FALSE) {
[10:30:48.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.397]     }
[10:30:48.397]     ...future.result <- base::tryCatch({
[10:30:48.397]         base::withCallingHandlers({
[10:30:48.397]             ...future.value <- base::withVisible(base::local({
[10:30:48.397]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.397]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.397]                   ...future.globals.maxSize)) {
[10:30:48.397]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.397]                   on.exit(options(oopts), add = TRUE)
[10:30:48.397]                 }
[10:30:48.397]                 {
[10:30:48.397]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.397]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.397]                     USE.NAMES = FALSE)
[10:30:48.397]                   do.call(mapply, args = args)
[10:30:48.397]                 }
[10:30:48.397]             }))
[10:30:48.397]             future::FutureResult(value = ...future.value$value, 
[10:30:48.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.397]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.397]                     ...future.globalenv.names))
[10:30:48.397]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.397]         }, condition = base::local({
[10:30:48.397]             c <- base::c
[10:30:48.397]             inherits <- base::inherits
[10:30:48.397]             invokeRestart <- base::invokeRestart
[10:30:48.397]             length <- base::length
[10:30:48.397]             list <- base::list
[10:30:48.397]             seq.int <- base::seq.int
[10:30:48.397]             signalCondition <- base::signalCondition
[10:30:48.397]             sys.calls <- base::sys.calls
[10:30:48.397]             `[[` <- base::`[[`
[10:30:48.397]             `+` <- base::`+`
[10:30:48.397]             `<<-` <- base::`<<-`
[10:30:48.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.397]                   3L)]
[10:30:48.397]             }
[10:30:48.397]             function(cond) {
[10:30:48.397]                 is_error <- inherits(cond, "error")
[10:30:48.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.397]                   NULL)
[10:30:48.397]                 if (is_error) {
[10:30:48.397]                   sessionInformation <- function() {
[10:30:48.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.397]                       search = base::search(), system = base::Sys.info())
[10:30:48.397]                   }
[10:30:48.397]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.397]                     cond$call), session = sessionInformation(), 
[10:30:48.397]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.397]                   signalCondition(cond)
[10:30:48.397]                 }
[10:30:48.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.397]                 "immediateCondition"))) {
[10:30:48.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.397]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.397]                   if (TRUE && !signal) {
[10:30:48.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.397]                     {
[10:30:48.397]                       inherits <- base::inherits
[10:30:48.397]                       invokeRestart <- base::invokeRestart
[10:30:48.397]                       is.null <- base::is.null
[10:30:48.397]                       muffled <- FALSE
[10:30:48.397]                       if (inherits(cond, "message")) {
[10:30:48.397]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.397]                         if (muffled) 
[10:30:48.397]                           invokeRestart("muffleMessage")
[10:30:48.397]                       }
[10:30:48.397]                       else if (inherits(cond, "warning")) {
[10:30:48.397]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.397]                         if (muffled) 
[10:30:48.397]                           invokeRestart("muffleWarning")
[10:30:48.397]                       }
[10:30:48.397]                       else if (inherits(cond, "condition")) {
[10:30:48.397]                         if (!is.null(pattern)) {
[10:30:48.397]                           computeRestarts <- base::computeRestarts
[10:30:48.397]                           grepl <- base::grepl
[10:30:48.397]                           restarts <- computeRestarts(cond)
[10:30:48.397]                           for (restart in restarts) {
[10:30:48.397]                             name <- restart$name
[10:30:48.397]                             if (is.null(name)) 
[10:30:48.397]                               next
[10:30:48.397]                             if (!grepl(pattern, name)) 
[10:30:48.397]                               next
[10:30:48.397]                             invokeRestart(restart)
[10:30:48.397]                             muffled <- TRUE
[10:30:48.397]                             break
[10:30:48.397]                           }
[10:30:48.397]                         }
[10:30:48.397]                       }
[10:30:48.397]                       invisible(muffled)
[10:30:48.397]                     }
[10:30:48.397]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.397]                   }
[10:30:48.397]                 }
[10:30:48.397]                 else {
[10:30:48.397]                   if (TRUE) {
[10:30:48.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.397]                     {
[10:30:48.397]                       inherits <- base::inherits
[10:30:48.397]                       invokeRestart <- base::invokeRestart
[10:30:48.397]                       is.null <- base::is.null
[10:30:48.397]                       muffled <- FALSE
[10:30:48.397]                       if (inherits(cond, "message")) {
[10:30:48.397]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.397]                         if (muffled) 
[10:30:48.397]                           invokeRestart("muffleMessage")
[10:30:48.397]                       }
[10:30:48.397]                       else if (inherits(cond, "warning")) {
[10:30:48.397]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.397]                         if (muffled) 
[10:30:48.397]                           invokeRestart("muffleWarning")
[10:30:48.397]                       }
[10:30:48.397]                       else if (inherits(cond, "condition")) {
[10:30:48.397]                         if (!is.null(pattern)) {
[10:30:48.397]                           computeRestarts <- base::computeRestarts
[10:30:48.397]                           grepl <- base::grepl
[10:30:48.397]                           restarts <- computeRestarts(cond)
[10:30:48.397]                           for (restart in restarts) {
[10:30:48.397]                             name <- restart$name
[10:30:48.397]                             if (is.null(name)) 
[10:30:48.397]                               next
[10:30:48.397]                             if (!grepl(pattern, name)) 
[10:30:48.397]                               next
[10:30:48.397]                             invokeRestart(restart)
[10:30:48.397]                             muffled <- TRUE
[10:30:48.397]                             break
[10:30:48.397]                           }
[10:30:48.397]                         }
[10:30:48.397]                       }
[10:30:48.397]                       invisible(muffled)
[10:30:48.397]                     }
[10:30:48.397]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.397]                   }
[10:30:48.397]                 }
[10:30:48.397]             }
[10:30:48.397]         }))
[10:30:48.397]     }, error = function(ex) {
[10:30:48.397]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.397]                 ...future.rng), started = ...future.startTime, 
[10:30:48.397]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.397]             version = "1.8"), class = "FutureResult")
[10:30:48.397]     }, finally = {
[10:30:48.397]         if (!identical(...future.workdir, getwd())) 
[10:30:48.397]             setwd(...future.workdir)
[10:30:48.397]         {
[10:30:48.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.397]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.397]             }
[10:30:48.397]             base::options(...future.oldOptions)
[10:30:48.397]             if (.Platform$OS.type == "windows") {
[10:30:48.397]                 old_names <- names(...future.oldEnvVars)
[10:30:48.397]                 envs <- base::Sys.getenv()
[10:30:48.397]                 names <- names(envs)
[10:30:48.397]                 common <- intersect(names, old_names)
[10:30:48.397]                 added <- setdiff(names, old_names)
[10:30:48.397]                 removed <- setdiff(old_names, names)
[10:30:48.397]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.397]                   envs[common]]
[10:30:48.397]                 NAMES <- toupper(changed)
[10:30:48.397]                 args <- list()
[10:30:48.397]                 for (kk in seq_along(NAMES)) {
[10:30:48.397]                   name <- changed[[kk]]
[10:30:48.397]                   NAME <- NAMES[[kk]]
[10:30:48.397]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.397]                     next
[10:30:48.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.397]                 }
[10:30:48.397]                 NAMES <- toupper(added)
[10:30:48.397]                 for (kk in seq_along(NAMES)) {
[10:30:48.397]                   name <- added[[kk]]
[10:30:48.397]                   NAME <- NAMES[[kk]]
[10:30:48.397]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.397]                     next
[10:30:48.397]                   args[[name]] <- ""
[10:30:48.397]                 }
[10:30:48.397]                 NAMES <- toupper(removed)
[10:30:48.397]                 for (kk in seq_along(NAMES)) {
[10:30:48.397]                   name <- removed[[kk]]
[10:30:48.397]                   NAME <- NAMES[[kk]]
[10:30:48.397]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.397]                     next
[10:30:48.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.397]                 }
[10:30:48.397]                 if (length(args) > 0) 
[10:30:48.397]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.397]             }
[10:30:48.397]             else {
[10:30:48.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.397]             }
[10:30:48.397]             {
[10:30:48.397]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.397]                   0L) {
[10:30:48.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.397]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.397]                   base::options(opts)
[10:30:48.397]                 }
[10:30:48.397]                 {
[10:30:48.397]                   {
[10:30:48.397]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.397]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.397]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.397]                       inherits = FALSE)
[10:30:48.397]                     NULL
[10:30:48.397]                   }
[10:30:48.397]                   options(future.plan = NULL)
[10:30:48.397]                   if (is.na(NA_character_)) 
[10:30:48.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.397]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.397]                     .init = FALSE)
[10:30:48.397]                 }
[10:30:48.397]             }
[10:30:48.397]         }
[10:30:48.397]     })
[10:30:48.397]     if (TRUE) {
[10:30:48.397]         base::sink(type = "output", split = FALSE)
[10:30:48.397]         if (TRUE) {
[10:30:48.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.397]         }
[10:30:48.397]         else {
[10:30:48.397]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.397]         }
[10:30:48.397]         base::close(...future.stdout)
[10:30:48.397]         ...future.stdout <- NULL
[10:30:48.397]     }
[10:30:48.397]     ...future.result$conditions <- ...future.conditions
[10:30:48.397]     ...future.result$finished <- base::Sys.time()
[10:30:48.397]     ...future.result
[10:30:48.397] }
[10:30:48.399] assign_globals() ...
[10:30:48.399] List of 5
[10:30:48.399]  $ ...future.FUN            :function (C, k)  
[10:30:48.399]  $ MoreArgs                 : list()
[10:30:48.399]  $ ...future.elements_ii    :List of 2
[10:30:48.399]   ..$ :List of 5
[10:30:48.399]   .. ..$ : chr "A"
[10:30:48.399]   .. ..$ : chr "B"
[10:30:48.399]   .. ..$ : chr "C"
[10:30:48.399]   .. ..$ : chr "D"
[10:30:48.399]   .. ..$ : chr "E"
[10:30:48.399]   ..$ :List of 5
[10:30:48.399]   .. ..$ : int 5
[10:30:48.399]   .. ..$ : int 4
[10:30:48.399]   .. ..$ : int 3
[10:30:48.399]   .. ..$ : int 2
[10:30:48.399]   .. ..$ : int 1
[10:30:48.399]  $ ...future.seeds_ii       : NULL
[10:30:48.399]  $ ...future.globals.maxSize: NULL
[10:30:48.399]  - attr(*, "where")=List of 5
[10:30:48.399]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.399]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.399]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.399]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.399]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.399]  - attr(*, "resolved")= logi FALSE
[10:30:48.399]  - attr(*, "total_size")= num 4160
[10:30:48.399]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.399]  - attr(*, "already-done")= logi TRUE
[10:30:48.406] - reassign environment for ‘...future.FUN’
[10:30:48.406] - copied ‘...future.FUN’ to environment
[10:30:48.407] - copied ‘MoreArgs’ to environment
[10:30:48.407] - copied ‘...future.elements_ii’ to environment
[10:30:48.407] - copied ‘...future.seeds_ii’ to environment
[10:30:48.407] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.407] assign_globals() ... done
[10:30:48.407] plan(): Setting new future strategy stack:
[10:30:48.407] List of future strategies:
[10:30:48.407] 1. sequential:
[10:30:48.407]    - args: function (..., envir = parent.frame())
[10:30:48.407]    - tweaked: FALSE
[10:30:48.407]    - call: NULL
[10:30:48.408] plan(): nbrOfWorkers() = 1
[10:30:48.408] plan(): Setting new future strategy stack:
[10:30:48.409] List of future strategies:
[10:30:48.409] 1. sequential:
[10:30:48.409]    - args: function (..., envir = parent.frame())
[10:30:48.409]    - tweaked: FALSE
[10:30:48.409]    - call: plan(strategy)
[10:30:48.409] plan(): nbrOfWorkers() = 1
[10:30:48.409] SequentialFuture started (and completed)
[10:30:48.409] - Launch lazy future ... done
[10:30:48.409] run() for ‘SequentialFuture’ ... done
[10:30:48.410] Created future:
[10:30:48.410] SequentialFuture:
[10:30:48.410] Label: ‘future_.mapply-1’
[10:30:48.410] Expression:
[10:30:48.410] {
[10:30:48.410]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.410]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.410]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.410]         on.exit(options(oopts), add = TRUE)
[10:30:48.410]     }
[10:30:48.410]     {
[10:30:48.410]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.410]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.410]         do.call(mapply, args = args)
[10:30:48.410]     }
[10:30:48.410] }
[10:30:48.410] Lazy evaluation: FALSE
[10:30:48.410] Asynchronous evaluation: FALSE
[10:30:48.410] Local evaluation: TRUE
[10:30:48.410] Environment: R_GlobalEnv
[10:30:48.410] Capture standard output: TRUE
[10:30:48.410] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.410] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.410] Packages: <none>
[10:30:48.410] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.410] Resolved: TRUE
[10:30:48.410] Value: 560 bytes of class ‘list’
[10:30:48.410] Early signaling: FALSE
[10:30:48.410] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.410] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.411] Chunk #1 of 1 ... DONE
[10:30:48.411] Launching 1 futures (chunks) ... DONE
[10:30:48.411] Resolving 1 futures (chunks) ...
[10:30:48.411] resolve() on list ...
[10:30:48.411]  recursive: 0
[10:30:48.411]  length: 1
[10:30:48.411] 
[10:30:48.411] resolved() for ‘SequentialFuture’ ...
[10:30:48.411] - state: ‘finished’
[10:30:48.411] - run: TRUE
[10:30:48.412] - result: ‘FutureResult’
[10:30:48.412] resolved() for ‘SequentialFuture’ ... done
[10:30:48.412] Future #1
[10:30:48.412] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.412] - nx: 1
[10:30:48.412] - relay: TRUE
[10:30:48.412] - stdout: TRUE
[10:30:48.412] - signal: TRUE
[10:30:48.412] - resignal: FALSE
[10:30:48.412] - force: TRUE
[10:30:48.412] - relayed: [n=1] FALSE
[10:30:48.413] - queued futures: [n=1] FALSE
[10:30:48.413]  - until=1
[10:30:48.413]  - relaying element #1
[10:30:48.413] - relayed: [n=1] TRUE
[10:30:48.413] - queued futures: [n=1] TRUE
[10:30:48.413] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.413]  length: 0 (resolved future 1)
[10:30:48.413] Relaying remaining futures
[10:30:48.413] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.414] - nx: 1
[10:30:48.414] - relay: TRUE
[10:30:48.414] - stdout: TRUE
[10:30:48.414] - signal: TRUE
[10:30:48.414] - resignal: FALSE
[10:30:48.414] - force: TRUE
[10:30:48.414] - relayed: [n=1] TRUE
[10:30:48.414] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.414] - relayed: [n=1] TRUE
[10:30:48.414] - queued futures: [n=1] TRUE
[10:30:48.414] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.415] resolve() on list ... DONE
[10:30:48.415]  - Number of value chunks collected: 1
[10:30:48.415] Resolving 1 futures (chunks) ... DONE
[10:30:48.415] Reducing values from 1 chunks ...
[10:30:48.415]  - Number of values collected after concatenation: 5
[10:30:48.415]  - Number of values expected: 5
[10:30:48.415] Reducing values from 1 chunks ... DONE
[10:30:48.415] future_mapply() ... DONE
[10:30:48.415] future_mapply() ...
[10:30:48.416] Number of chunks: 3
[10:30:48.416] Index remapping (attribute 'ordering'): [n = 5] 1, 3, 5, 2, 4
[10:30:48.416] getGlobalsAndPackagesXApply() ...
[10:30:48.416]  - future.globals: TRUE
[10:30:48.416] getGlobalsAndPackages() ...
[10:30:48.416] Searching for globals...
[10:30:48.420] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:48.420] Searching for globals ... DONE
[10:30:48.420] Resolving globals: FALSE
[10:30:48.420] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:48.421] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:48.421] - globals: [1] ‘FUN’
[10:30:48.421] 
[10:30:48.421] getGlobalsAndPackages() ... DONE
[10:30:48.421]  - globals found/used: [n=1] ‘FUN’
[10:30:48.421]  - needed namespaces: [n=0] 
[10:30:48.421] Finding globals ... DONE
[10:30:48.422] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.422] List of 2
[10:30:48.422]  $ ...future.FUN:function (C, k)  
[10:30:48.422]  $ MoreArgs     : NULL
[10:30:48.422]  - attr(*, "where")=List of 2
[10:30:48.422]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.422]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.422]  - attr(*, "resolved")= logi FALSE
[10:30:48.422]  - attr(*, "total_size")= num NA
[10:30:48.424] Packages to be attached in all futures: [n=0] 
[10:30:48.424] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.424] Number of futures (= number of chunks): 3
[10:30:48.425] Launching 3 futures (chunks) ...
[10:30:48.425] Chunk #1 of 3 ...
[10:30:48.425]  - Finding globals in '...' for chunk #1 ...
[10:30:48.425] getGlobalsAndPackages() ...
[10:30:48.425] Searching for globals...
[10:30:48.425] 
[10:30:48.425] Searching for globals ... DONE
[10:30:48.426] - globals: [0] <none>
[10:30:48.426] getGlobalsAndPackages() ... DONE
[10:30:48.426]    + additional globals found: [n=0] 
[10:30:48.426]    + additional namespaces needed: [n=0] 
[10:30:48.426]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.426]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:30:48.426]  - seeds: <none>
[10:30:48.426]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.426] getGlobalsAndPackages() ...
[10:30:48.426] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.426] Resolving globals: FALSE
[10:30:48.427] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:48.427] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.427] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.428] 
[10:30:48.428] getGlobalsAndPackages() ... DONE
[10:30:48.428] run() for ‘Future’ ...
[10:30:48.428] - state: ‘created’
[10:30:48.428] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.428] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.429]   - Field: ‘label’
[10:30:48.429]   - Field: ‘local’
[10:30:48.429]   - Field: ‘owner’
[10:30:48.429]   - Field: ‘envir’
[10:30:48.429]   - Field: ‘packages’
[10:30:48.429]   - Field: ‘gc’
[10:30:48.429]   - Field: ‘conditions’
[10:30:48.429]   - Field: ‘expr’
[10:30:48.429]   - Field: ‘uuid’
[10:30:48.430]   - Field: ‘seed’
[10:30:48.430]   - Field: ‘version’
[10:30:48.430]   - Field: ‘result’
[10:30:48.430]   - Field: ‘asynchronous’
[10:30:48.430]   - Field: ‘calls’
[10:30:48.430]   - Field: ‘globals’
[10:30:48.430]   - Field: ‘stdout’
[10:30:48.430]   - Field: ‘earlySignal’
[10:30:48.430]   - Field: ‘lazy’
[10:30:48.430]   - Field: ‘state’
[10:30:48.430] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.431] - Launch lazy future ...
[10:30:48.431] Packages needed by the future expression (n = 0): <none>
[10:30:48.431] Packages needed by future strategies (n = 0): <none>
[10:30:48.431] {
[10:30:48.431]     {
[10:30:48.431]         {
[10:30:48.431]             ...future.startTime <- base::Sys.time()
[10:30:48.431]             {
[10:30:48.431]                 {
[10:30:48.431]                   {
[10:30:48.431]                     base::local({
[10:30:48.431]                       has_future <- base::requireNamespace("future", 
[10:30:48.431]                         quietly = TRUE)
[10:30:48.431]                       if (has_future) {
[10:30:48.431]                         ns <- base::getNamespace("future")
[10:30:48.431]                         version <- ns[[".package"]][["version"]]
[10:30:48.431]                         if (is.null(version)) 
[10:30:48.431]                           version <- utils::packageVersion("future")
[10:30:48.431]                       }
[10:30:48.431]                       else {
[10:30:48.431]                         version <- NULL
[10:30:48.431]                       }
[10:30:48.431]                       if (!has_future || version < "1.8.0") {
[10:30:48.431]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.431]                           "", base::R.version$version.string), 
[10:30:48.431]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.431]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.431]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.431]                             "release", "version")], collapse = " "), 
[10:30:48.431]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.431]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.431]                           info)
[10:30:48.431]                         info <- base::paste(info, collapse = "; ")
[10:30:48.431]                         if (!has_future) {
[10:30:48.431]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.431]                             info)
[10:30:48.431]                         }
[10:30:48.431]                         else {
[10:30:48.431]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.431]                             info, version)
[10:30:48.431]                         }
[10:30:48.431]                         base::stop(msg)
[10:30:48.431]                       }
[10:30:48.431]                     })
[10:30:48.431]                   }
[10:30:48.431]                   ...future.strategy.old <- future::plan("list")
[10:30:48.431]                   options(future.plan = NULL)
[10:30:48.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.431]                 }
[10:30:48.431]                 ...future.workdir <- getwd()
[10:30:48.431]             }
[10:30:48.431]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.431]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.431]         }
[10:30:48.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.431]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:30:48.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.431]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.431]             base::names(...future.oldOptions))
[10:30:48.431]     }
[10:30:48.431]     if (FALSE) {
[10:30:48.431]     }
[10:30:48.431]     else {
[10:30:48.431]         if (TRUE) {
[10:30:48.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.431]                 open = "w")
[10:30:48.431]         }
[10:30:48.431]         else {
[10:30:48.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.431]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.431]         }
[10:30:48.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.431]             base::sink(type = "output", split = FALSE)
[10:30:48.431]             base::close(...future.stdout)
[10:30:48.431]         }, add = TRUE)
[10:30:48.431]     }
[10:30:48.431]     ...future.frame <- base::sys.nframe()
[10:30:48.431]     ...future.conditions <- base::list()
[10:30:48.431]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.431]     if (FALSE) {
[10:30:48.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.431]     }
[10:30:48.431]     ...future.result <- base::tryCatch({
[10:30:48.431]         base::withCallingHandlers({
[10:30:48.431]             ...future.value <- base::withVisible(base::local({
[10:30:48.431]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.431]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.431]                   ...future.globals.maxSize)) {
[10:30:48.431]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.431]                   on.exit(options(oopts), add = TRUE)
[10:30:48.431]                 }
[10:30:48.431]                 {
[10:30:48.431]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.431]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.431]                     USE.NAMES = FALSE)
[10:30:48.431]                   do.call(mapply, args = args)
[10:30:48.431]                 }
[10:30:48.431]             }))
[10:30:48.431]             future::FutureResult(value = ...future.value$value, 
[10:30:48.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.431]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.431]                     ...future.globalenv.names))
[10:30:48.431]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.431]         }, condition = base::local({
[10:30:48.431]             c <- base::c
[10:30:48.431]             inherits <- base::inherits
[10:30:48.431]             invokeRestart <- base::invokeRestart
[10:30:48.431]             length <- base::length
[10:30:48.431]             list <- base::list
[10:30:48.431]             seq.int <- base::seq.int
[10:30:48.431]             signalCondition <- base::signalCondition
[10:30:48.431]             sys.calls <- base::sys.calls
[10:30:48.431]             `[[` <- base::`[[`
[10:30:48.431]             `+` <- base::`+`
[10:30:48.431]             `<<-` <- base::`<<-`
[10:30:48.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.431]                   3L)]
[10:30:48.431]             }
[10:30:48.431]             function(cond) {
[10:30:48.431]                 is_error <- inherits(cond, "error")
[10:30:48.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.431]                   NULL)
[10:30:48.431]                 if (is_error) {
[10:30:48.431]                   sessionInformation <- function() {
[10:30:48.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.431]                       search = base::search(), system = base::Sys.info())
[10:30:48.431]                   }
[10:30:48.431]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.431]                     cond$call), session = sessionInformation(), 
[10:30:48.431]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.431]                   signalCondition(cond)
[10:30:48.431]                 }
[10:30:48.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.431]                 "immediateCondition"))) {
[10:30:48.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.431]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.431]                   if (TRUE && !signal) {
[10:30:48.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.431]                     {
[10:30:48.431]                       inherits <- base::inherits
[10:30:48.431]                       invokeRestart <- base::invokeRestart
[10:30:48.431]                       is.null <- base::is.null
[10:30:48.431]                       muffled <- FALSE
[10:30:48.431]                       if (inherits(cond, "message")) {
[10:30:48.431]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.431]                         if (muffled) 
[10:30:48.431]                           invokeRestart("muffleMessage")
[10:30:48.431]                       }
[10:30:48.431]                       else if (inherits(cond, "warning")) {
[10:30:48.431]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.431]                         if (muffled) 
[10:30:48.431]                           invokeRestart("muffleWarning")
[10:30:48.431]                       }
[10:30:48.431]                       else if (inherits(cond, "condition")) {
[10:30:48.431]                         if (!is.null(pattern)) {
[10:30:48.431]                           computeRestarts <- base::computeRestarts
[10:30:48.431]                           grepl <- base::grepl
[10:30:48.431]                           restarts <- computeRestarts(cond)
[10:30:48.431]                           for (restart in restarts) {
[10:30:48.431]                             name <- restart$name
[10:30:48.431]                             if (is.null(name)) 
[10:30:48.431]                               next
[10:30:48.431]                             if (!grepl(pattern, name)) 
[10:30:48.431]                               next
[10:30:48.431]                             invokeRestart(restart)
[10:30:48.431]                             muffled <- TRUE
[10:30:48.431]                             break
[10:30:48.431]                           }
[10:30:48.431]                         }
[10:30:48.431]                       }
[10:30:48.431]                       invisible(muffled)
[10:30:48.431]                     }
[10:30:48.431]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.431]                   }
[10:30:48.431]                 }
[10:30:48.431]                 else {
[10:30:48.431]                   if (TRUE) {
[10:30:48.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.431]                     {
[10:30:48.431]                       inherits <- base::inherits
[10:30:48.431]                       invokeRestart <- base::invokeRestart
[10:30:48.431]                       is.null <- base::is.null
[10:30:48.431]                       muffled <- FALSE
[10:30:48.431]                       if (inherits(cond, "message")) {
[10:30:48.431]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.431]                         if (muffled) 
[10:30:48.431]                           invokeRestart("muffleMessage")
[10:30:48.431]                       }
[10:30:48.431]                       else if (inherits(cond, "warning")) {
[10:30:48.431]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.431]                         if (muffled) 
[10:30:48.431]                           invokeRestart("muffleWarning")
[10:30:48.431]                       }
[10:30:48.431]                       else if (inherits(cond, "condition")) {
[10:30:48.431]                         if (!is.null(pattern)) {
[10:30:48.431]                           computeRestarts <- base::computeRestarts
[10:30:48.431]                           grepl <- base::grepl
[10:30:48.431]                           restarts <- computeRestarts(cond)
[10:30:48.431]                           for (restart in restarts) {
[10:30:48.431]                             name <- restart$name
[10:30:48.431]                             if (is.null(name)) 
[10:30:48.431]                               next
[10:30:48.431]                             if (!grepl(pattern, name)) 
[10:30:48.431]                               next
[10:30:48.431]                             invokeRestart(restart)
[10:30:48.431]                             muffled <- TRUE
[10:30:48.431]                             break
[10:30:48.431]                           }
[10:30:48.431]                         }
[10:30:48.431]                       }
[10:30:48.431]                       invisible(muffled)
[10:30:48.431]                     }
[10:30:48.431]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.431]                   }
[10:30:48.431]                 }
[10:30:48.431]             }
[10:30:48.431]         }))
[10:30:48.431]     }, error = function(ex) {
[10:30:48.431]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.431]                 ...future.rng), started = ...future.startTime, 
[10:30:48.431]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.431]             version = "1.8"), class = "FutureResult")
[10:30:48.431]     }, finally = {
[10:30:48.431]         if (!identical(...future.workdir, getwd())) 
[10:30:48.431]             setwd(...future.workdir)
[10:30:48.431]         {
[10:30:48.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.431]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.431]             }
[10:30:48.431]             base::options(...future.oldOptions)
[10:30:48.431]             if (.Platform$OS.type == "windows") {
[10:30:48.431]                 old_names <- names(...future.oldEnvVars)
[10:30:48.431]                 envs <- base::Sys.getenv()
[10:30:48.431]                 names <- names(envs)
[10:30:48.431]                 common <- intersect(names, old_names)
[10:30:48.431]                 added <- setdiff(names, old_names)
[10:30:48.431]                 removed <- setdiff(old_names, names)
[10:30:48.431]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.431]                   envs[common]]
[10:30:48.431]                 NAMES <- toupper(changed)
[10:30:48.431]                 args <- list()
[10:30:48.431]                 for (kk in seq_along(NAMES)) {
[10:30:48.431]                   name <- changed[[kk]]
[10:30:48.431]                   NAME <- NAMES[[kk]]
[10:30:48.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.431]                     next
[10:30:48.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.431]                 }
[10:30:48.431]                 NAMES <- toupper(added)
[10:30:48.431]                 for (kk in seq_along(NAMES)) {
[10:30:48.431]                   name <- added[[kk]]
[10:30:48.431]                   NAME <- NAMES[[kk]]
[10:30:48.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.431]                     next
[10:30:48.431]                   args[[name]] <- ""
[10:30:48.431]                 }
[10:30:48.431]                 NAMES <- toupper(removed)
[10:30:48.431]                 for (kk in seq_along(NAMES)) {
[10:30:48.431]                   name <- removed[[kk]]
[10:30:48.431]                   NAME <- NAMES[[kk]]
[10:30:48.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.431]                     next
[10:30:48.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.431]                 }
[10:30:48.431]                 if (length(args) > 0) 
[10:30:48.431]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.431]             }
[10:30:48.431]             else {
[10:30:48.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.431]             }
[10:30:48.431]             {
[10:30:48.431]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.431]                   0L) {
[10:30:48.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.431]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.431]                   base::options(opts)
[10:30:48.431]                 }
[10:30:48.431]                 {
[10:30:48.431]                   {
[10:30:48.431]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.431]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.431]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.431]                       inherits = FALSE)
[10:30:48.431]                     NULL
[10:30:48.431]                   }
[10:30:48.431]                   options(future.plan = NULL)
[10:30:48.431]                   if (is.na(NA_character_)) 
[10:30:48.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.431]                     .init = FALSE)
[10:30:48.431]                 }
[10:30:48.431]             }
[10:30:48.431]         }
[10:30:48.431]     })
[10:30:48.431]     if (TRUE) {
[10:30:48.431]         base::sink(type = "output", split = FALSE)
[10:30:48.431]         if (TRUE) {
[10:30:48.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.431]         }
[10:30:48.431]         else {
[10:30:48.431]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.431]         }
[10:30:48.431]         base::close(...future.stdout)
[10:30:48.431]         ...future.stdout <- NULL
[10:30:48.431]     }
[10:30:48.431]     ...future.result$conditions <- ...future.conditions
[10:30:48.431]     ...future.result$finished <- base::Sys.time()
[10:30:48.431]     ...future.result
[10:30:48.431] }
[10:30:48.433] assign_globals() ...
[10:30:48.433] List of 5
[10:30:48.433]  $ ...future.FUN            :function (C, k)  
[10:30:48.433]  $ MoreArgs                 : NULL
[10:30:48.433]  $ ...future.elements_ii    :List of 2
[10:30:48.433]   ..$ :List of 2
[10:30:48.433]   .. ..$ : chr "A"
[10:30:48.433]   .. ..$ : chr "C"
[10:30:48.433]   ..$ :List of 2
[10:30:48.433]   .. ..$ : int 5
[10:30:48.433]   .. ..$ : int 3
[10:30:48.433]  $ ...future.seeds_ii       : NULL
[10:30:48.433]  $ ...future.globals.maxSize: NULL
[10:30:48.433]  - attr(*, "where")=List of 5
[10:30:48.433]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.433]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.433]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.433]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.433]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.433]  - attr(*, "resolved")= logi FALSE
[10:30:48.433]  - attr(*, "total_size")= num 3656
[10:30:48.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.433]  - attr(*, "already-done")= logi TRUE
[10:30:48.439] - reassign environment for ‘...future.FUN’
[10:30:48.439] - copied ‘...future.FUN’ to environment
[10:30:48.439] - copied ‘MoreArgs’ to environment
[10:30:48.439] - copied ‘...future.elements_ii’ to environment
[10:30:48.439] - copied ‘...future.seeds_ii’ to environment
[10:30:48.439] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.439] assign_globals() ... done
[10:30:48.439] plan(): Setting new future strategy stack:
[10:30:48.439] List of future strategies:
[10:30:48.439] 1. sequential:
[10:30:48.439]    - args: function (..., envir = parent.frame())
[10:30:48.439]    - tweaked: FALSE
[10:30:48.439]    - call: NULL
[10:30:48.440] plan(): nbrOfWorkers() = 1
[10:30:48.441] plan(): Setting new future strategy stack:
[10:30:48.441] List of future strategies:
[10:30:48.441] 1. sequential:
[10:30:48.441]    - args: function (..., envir = parent.frame())
[10:30:48.441]    - tweaked: FALSE
[10:30:48.441]    - call: plan(strategy)
[10:30:48.441] plan(): nbrOfWorkers() = 1
[10:30:48.441] SequentialFuture started (and completed)
[10:30:48.441] - Launch lazy future ... done
[10:30:48.442] run() for ‘SequentialFuture’ ... done
[10:30:48.442] Created future:
[10:30:48.442] SequentialFuture:
[10:30:48.442] Label: ‘future_mapply-1’
[10:30:48.442] Expression:
[10:30:48.442] {
[10:30:48.442]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.442]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.442]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.442]         on.exit(options(oopts), add = TRUE)
[10:30:48.442]     }
[10:30:48.442]     {
[10:30:48.442]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.442]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.442]         do.call(mapply, args = args)
[10:30:48.442]     }
[10:30:48.442] }
[10:30:48.442] Lazy evaluation: FALSE
[10:30:48.442] Asynchronous evaluation: FALSE
[10:30:48.442] Local evaluation: TRUE
[10:30:48.442] Environment: R_GlobalEnv
[10:30:48.442] Capture standard output: TRUE
[10:30:48.442] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.442] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.442] Packages: <none>
[10:30:48.442] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.442] Resolved: TRUE
[10:30:48.442] Value: 224 bytes of class ‘list’
[10:30:48.442] Early signaling: FALSE
[10:30:48.442] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.442] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.443] Chunk #1 of 3 ... DONE
[10:30:48.443] Chunk #2 of 3 ...
[10:30:48.443]  - Finding globals in '...' for chunk #2 ...
[10:30:48.443] getGlobalsAndPackages() ...
[10:30:48.443] Searching for globals...
[10:30:48.445] 
[10:30:48.445] Searching for globals ... DONE
[10:30:48.445] - globals: [0] <none>
[10:30:48.445] getGlobalsAndPackages() ... DONE
[10:30:48.445]    + additional globals found: [n=0] 
[10:30:48.446]    + additional namespaces needed: [n=0] 
[10:30:48.446]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:48.446]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:30:48.446]  - seeds: <none>
[10:30:48.446]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.446] getGlobalsAndPackages() ...
[10:30:48.446] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.446] Resolving globals: FALSE
[10:30:48.447] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:48.447] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.447] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.448] 
[10:30:48.448] getGlobalsAndPackages() ... DONE
[10:30:48.448] run() for ‘Future’ ...
[10:30:48.448] - state: ‘created’
[10:30:48.448] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.448] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.449]   - Field: ‘label’
[10:30:48.449]   - Field: ‘local’
[10:30:48.449]   - Field: ‘owner’
[10:30:48.449]   - Field: ‘envir’
[10:30:48.449]   - Field: ‘packages’
[10:30:48.449]   - Field: ‘gc’
[10:30:48.449]   - Field: ‘conditions’
[10:30:48.449]   - Field: ‘expr’
[10:30:48.450]   - Field: ‘uuid’
[10:30:48.450]   - Field: ‘seed’
[10:30:48.450]   - Field: ‘version’
[10:30:48.450]   - Field: ‘result’
[10:30:48.450]   - Field: ‘asynchronous’
[10:30:48.450]   - Field: ‘calls’
[10:30:48.450]   - Field: ‘globals’
[10:30:48.450]   - Field: ‘stdout’
[10:30:48.450]   - Field: ‘earlySignal’
[10:30:48.450]   - Field: ‘lazy’
[10:30:48.450]   - Field: ‘state’
[10:30:48.451] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.451] - Launch lazy future ...
[10:30:48.451] Packages needed by the future expression (n = 0): <none>
[10:30:48.451] Packages needed by future strategies (n = 0): <none>
[10:30:48.451] {
[10:30:48.451]     {
[10:30:48.451]         {
[10:30:48.451]             ...future.startTime <- base::Sys.time()
[10:30:48.451]             {
[10:30:48.451]                 {
[10:30:48.451]                   {
[10:30:48.451]                     base::local({
[10:30:48.451]                       has_future <- base::requireNamespace("future", 
[10:30:48.451]                         quietly = TRUE)
[10:30:48.451]                       if (has_future) {
[10:30:48.451]                         ns <- base::getNamespace("future")
[10:30:48.451]                         version <- ns[[".package"]][["version"]]
[10:30:48.451]                         if (is.null(version)) 
[10:30:48.451]                           version <- utils::packageVersion("future")
[10:30:48.451]                       }
[10:30:48.451]                       else {
[10:30:48.451]                         version <- NULL
[10:30:48.451]                       }
[10:30:48.451]                       if (!has_future || version < "1.8.0") {
[10:30:48.451]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.451]                           "", base::R.version$version.string), 
[10:30:48.451]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.451]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.451]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.451]                             "release", "version")], collapse = " "), 
[10:30:48.451]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.451]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.451]                           info)
[10:30:48.451]                         info <- base::paste(info, collapse = "; ")
[10:30:48.451]                         if (!has_future) {
[10:30:48.451]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.451]                             info)
[10:30:48.451]                         }
[10:30:48.451]                         else {
[10:30:48.451]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.451]                             info, version)
[10:30:48.451]                         }
[10:30:48.451]                         base::stop(msg)
[10:30:48.451]                       }
[10:30:48.451]                     })
[10:30:48.451]                   }
[10:30:48.451]                   ...future.strategy.old <- future::plan("list")
[10:30:48.451]                   options(future.plan = NULL)
[10:30:48.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.451]                 }
[10:30:48.451]                 ...future.workdir <- getwd()
[10:30:48.451]             }
[10:30:48.451]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.451]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.451]         }
[10:30:48.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.451]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:30:48.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.451]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.451]             base::names(...future.oldOptions))
[10:30:48.451]     }
[10:30:48.451]     if (FALSE) {
[10:30:48.451]     }
[10:30:48.451]     else {
[10:30:48.451]         if (TRUE) {
[10:30:48.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.451]                 open = "w")
[10:30:48.451]         }
[10:30:48.451]         else {
[10:30:48.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.451]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.451]         }
[10:30:48.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.451]             base::sink(type = "output", split = FALSE)
[10:30:48.451]             base::close(...future.stdout)
[10:30:48.451]         }, add = TRUE)
[10:30:48.451]     }
[10:30:48.451]     ...future.frame <- base::sys.nframe()
[10:30:48.451]     ...future.conditions <- base::list()
[10:30:48.451]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.451]     if (FALSE) {
[10:30:48.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.451]     }
[10:30:48.451]     ...future.result <- base::tryCatch({
[10:30:48.451]         base::withCallingHandlers({
[10:30:48.451]             ...future.value <- base::withVisible(base::local({
[10:30:48.451]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.451]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.451]                   ...future.globals.maxSize)) {
[10:30:48.451]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.451]                   on.exit(options(oopts), add = TRUE)
[10:30:48.451]                 }
[10:30:48.451]                 {
[10:30:48.451]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.451]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.451]                     USE.NAMES = FALSE)
[10:30:48.451]                   do.call(mapply, args = args)
[10:30:48.451]                 }
[10:30:48.451]             }))
[10:30:48.451]             future::FutureResult(value = ...future.value$value, 
[10:30:48.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.451]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.451]                     ...future.globalenv.names))
[10:30:48.451]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.451]         }, condition = base::local({
[10:30:48.451]             c <- base::c
[10:30:48.451]             inherits <- base::inherits
[10:30:48.451]             invokeRestart <- base::invokeRestart
[10:30:48.451]             length <- base::length
[10:30:48.451]             list <- base::list
[10:30:48.451]             seq.int <- base::seq.int
[10:30:48.451]             signalCondition <- base::signalCondition
[10:30:48.451]             sys.calls <- base::sys.calls
[10:30:48.451]             `[[` <- base::`[[`
[10:30:48.451]             `+` <- base::`+`
[10:30:48.451]             `<<-` <- base::`<<-`
[10:30:48.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.451]                   3L)]
[10:30:48.451]             }
[10:30:48.451]             function(cond) {
[10:30:48.451]                 is_error <- inherits(cond, "error")
[10:30:48.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.451]                   NULL)
[10:30:48.451]                 if (is_error) {
[10:30:48.451]                   sessionInformation <- function() {
[10:30:48.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.451]                       search = base::search(), system = base::Sys.info())
[10:30:48.451]                   }
[10:30:48.451]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.451]                     cond$call), session = sessionInformation(), 
[10:30:48.451]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.451]                   signalCondition(cond)
[10:30:48.451]                 }
[10:30:48.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.451]                 "immediateCondition"))) {
[10:30:48.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.451]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.451]                   if (TRUE && !signal) {
[10:30:48.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.451]                     {
[10:30:48.451]                       inherits <- base::inherits
[10:30:48.451]                       invokeRestart <- base::invokeRestart
[10:30:48.451]                       is.null <- base::is.null
[10:30:48.451]                       muffled <- FALSE
[10:30:48.451]                       if (inherits(cond, "message")) {
[10:30:48.451]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.451]                         if (muffled) 
[10:30:48.451]                           invokeRestart("muffleMessage")
[10:30:48.451]                       }
[10:30:48.451]                       else if (inherits(cond, "warning")) {
[10:30:48.451]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.451]                         if (muffled) 
[10:30:48.451]                           invokeRestart("muffleWarning")
[10:30:48.451]                       }
[10:30:48.451]                       else if (inherits(cond, "condition")) {
[10:30:48.451]                         if (!is.null(pattern)) {
[10:30:48.451]                           computeRestarts <- base::computeRestarts
[10:30:48.451]                           grepl <- base::grepl
[10:30:48.451]                           restarts <- computeRestarts(cond)
[10:30:48.451]                           for (restart in restarts) {
[10:30:48.451]                             name <- restart$name
[10:30:48.451]                             if (is.null(name)) 
[10:30:48.451]                               next
[10:30:48.451]                             if (!grepl(pattern, name)) 
[10:30:48.451]                               next
[10:30:48.451]                             invokeRestart(restart)
[10:30:48.451]                             muffled <- TRUE
[10:30:48.451]                             break
[10:30:48.451]                           }
[10:30:48.451]                         }
[10:30:48.451]                       }
[10:30:48.451]                       invisible(muffled)
[10:30:48.451]                     }
[10:30:48.451]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.451]                   }
[10:30:48.451]                 }
[10:30:48.451]                 else {
[10:30:48.451]                   if (TRUE) {
[10:30:48.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.451]                     {
[10:30:48.451]                       inherits <- base::inherits
[10:30:48.451]                       invokeRestart <- base::invokeRestart
[10:30:48.451]                       is.null <- base::is.null
[10:30:48.451]                       muffled <- FALSE
[10:30:48.451]                       if (inherits(cond, "message")) {
[10:30:48.451]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.451]                         if (muffled) 
[10:30:48.451]                           invokeRestart("muffleMessage")
[10:30:48.451]                       }
[10:30:48.451]                       else if (inherits(cond, "warning")) {
[10:30:48.451]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.451]                         if (muffled) 
[10:30:48.451]                           invokeRestart("muffleWarning")
[10:30:48.451]                       }
[10:30:48.451]                       else if (inherits(cond, "condition")) {
[10:30:48.451]                         if (!is.null(pattern)) {
[10:30:48.451]                           computeRestarts <- base::computeRestarts
[10:30:48.451]                           grepl <- base::grepl
[10:30:48.451]                           restarts <- computeRestarts(cond)
[10:30:48.451]                           for (restart in restarts) {
[10:30:48.451]                             name <- restart$name
[10:30:48.451]                             if (is.null(name)) 
[10:30:48.451]                               next
[10:30:48.451]                             if (!grepl(pattern, name)) 
[10:30:48.451]                               next
[10:30:48.451]                             invokeRestart(restart)
[10:30:48.451]                             muffled <- TRUE
[10:30:48.451]                             break
[10:30:48.451]                           }
[10:30:48.451]                         }
[10:30:48.451]                       }
[10:30:48.451]                       invisible(muffled)
[10:30:48.451]                     }
[10:30:48.451]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.451]                   }
[10:30:48.451]                 }
[10:30:48.451]             }
[10:30:48.451]         }))
[10:30:48.451]     }, error = function(ex) {
[10:30:48.451]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.451]                 ...future.rng), started = ...future.startTime, 
[10:30:48.451]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.451]             version = "1.8"), class = "FutureResult")
[10:30:48.451]     }, finally = {
[10:30:48.451]         if (!identical(...future.workdir, getwd())) 
[10:30:48.451]             setwd(...future.workdir)
[10:30:48.451]         {
[10:30:48.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.451]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.451]             }
[10:30:48.451]             base::options(...future.oldOptions)
[10:30:48.451]             if (.Platform$OS.type == "windows") {
[10:30:48.451]                 old_names <- names(...future.oldEnvVars)
[10:30:48.451]                 envs <- base::Sys.getenv()
[10:30:48.451]                 names <- names(envs)
[10:30:48.451]                 common <- intersect(names, old_names)
[10:30:48.451]                 added <- setdiff(names, old_names)
[10:30:48.451]                 removed <- setdiff(old_names, names)
[10:30:48.451]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.451]                   envs[common]]
[10:30:48.451]                 NAMES <- toupper(changed)
[10:30:48.451]                 args <- list()
[10:30:48.451]                 for (kk in seq_along(NAMES)) {
[10:30:48.451]                   name <- changed[[kk]]
[10:30:48.451]                   NAME <- NAMES[[kk]]
[10:30:48.451]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.451]                     next
[10:30:48.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.451]                 }
[10:30:48.451]                 NAMES <- toupper(added)
[10:30:48.451]                 for (kk in seq_along(NAMES)) {
[10:30:48.451]                   name <- added[[kk]]
[10:30:48.451]                   NAME <- NAMES[[kk]]
[10:30:48.451]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.451]                     next
[10:30:48.451]                   args[[name]] <- ""
[10:30:48.451]                 }
[10:30:48.451]                 NAMES <- toupper(removed)
[10:30:48.451]                 for (kk in seq_along(NAMES)) {
[10:30:48.451]                   name <- removed[[kk]]
[10:30:48.451]                   NAME <- NAMES[[kk]]
[10:30:48.451]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.451]                     next
[10:30:48.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.451]                 }
[10:30:48.451]                 if (length(args) > 0) 
[10:30:48.451]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.451]             }
[10:30:48.451]             else {
[10:30:48.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.451]             }
[10:30:48.451]             {
[10:30:48.451]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.451]                   0L) {
[10:30:48.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.451]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.451]                   base::options(opts)
[10:30:48.451]                 }
[10:30:48.451]                 {
[10:30:48.451]                   {
[10:30:48.451]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.451]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.451]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.451]                       inherits = FALSE)
[10:30:48.451]                     NULL
[10:30:48.451]                   }
[10:30:48.451]                   options(future.plan = NULL)
[10:30:48.451]                   if (is.na(NA_character_)) 
[10:30:48.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.451]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.451]                     .init = FALSE)
[10:30:48.451]                 }
[10:30:48.451]             }
[10:30:48.451]         }
[10:30:48.451]     })
[10:30:48.451]     if (TRUE) {
[10:30:48.451]         base::sink(type = "output", split = FALSE)
[10:30:48.451]         if (TRUE) {
[10:30:48.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.451]         }
[10:30:48.451]         else {
[10:30:48.451]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.451]         }
[10:30:48.451]         base::close(...future.stdout)
[10:30:48.451]         ...future.stdout <- NULL
[10:30:48.451]     }
[10:30:48.451]     ...future.result$conditions <- ...future.conditions
[10:30:48.451]     ...future.result$finished <- base::Sys.time()
[10:30:48.451]     ...future.result
[10:30:48.451] }
[10:30:48.453] assign_globals() ...
[10:30:48.453] List of 5
[10:30:48.453]  $ ...future.FUN            :function (C, k)  
[10:30:48.453]  $ MoreArgs                 : NULL
[10:30:48.453]  $ ...future.elements_ii    :List of 2
[10:30:48.453]   ..$ :List of 1
[10:30:48.453]   .. ..$ : chr "E"
[10:30:48.453]   ..$ :List of 1
[10:30:48.453]   .. ..$ : int 1
[10:30:48.453]  $ ...future.seeds_ii       : NULL
[10:30:48.453]  $ ...future.globals.maxSize: NULL
[10:30:48.453]  - attr(*, "where")=List of 5
[10:30:48.453]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.453]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.453]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.453]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.453]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.453]  - attr(*, "resolved")= logi FALSE
[10:30:48.453]  - attr(*, "total_size")= num 3488
[10:30:48.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.453]  - attr(*, "already-done")= logi TRUE
[10:30:48.458] - reassign environment for ‘...future.FUN’
[10:30:48.458] - copied ‘...future.FUN’ to environment
[10:30:48.459] - copied ‘MoreArgs’ to environment
[10:30:48.459] - copied ‘...future.elements_ii’ to environment
[10:30:48.459] - copied ‘...future.seeds_ii’ to environment
[10:30:48.459] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.459] assign_globals() ... done
[10:30:48.459] plan(): Setting new future strategy stack:
[10:30:48.459] List of future strategies:
[10:30:48.459] 1. sequential:
[10:30:48.459]    - args: function (..., envir = parent.frame())
[10:30:48.459]    - tweaked: FALSE
[10:30:48.459]    - call: NULL
[10:30:48.460] plan(): nbrOfWorkers() = 1
[10:30:48.460] plan(): Setting new future strategy stack:
[10:30:48.461] List of future strategies:
[10:30:48.461] 1. sequential:
[10:30:48.461]    - args: function (..., envir = parent.frame())
[10:30:48.461]    - tweaked: FALSE
[10:30:48.461]    - call: plan(strategy)
[10:30:48.461] plan(): nbrOfWorkers() = 1
[10:30:48.461] SequentialFuture started (and completed)
[10:30:48.461] - Launch lazy future ... done
[10:30:48.461] run() for ‘SequentialFuture’ ... done
[10:30:48.461] Created future:
[10:30:48.462] SequentialFuture:
[10:30:48.462] Label: ‘future_mapply-2’
[10:30:48.462] Expression:
[10:30:48.462] {
[10:30:48.462]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.462]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.462]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.462]         on.exit(options(oopts), add = TRUE)
[10:30:48.462]     }
[10:30:48.462]     {
[10:30:48.462]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.462]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.462]         do.call(mapply, args = args)
[10:30:48.462]     }
[10:30:48.462] }
[10:30:48.462] Lazy evaluation: FALSE
[10:30:48.462] Asynchronous evaluation: FALSE
[10:30:48.462] Local evaluation: TRUE
[10:30:48.462] Environment: R_GlobalEnv
[10:30:48.462] Capture standard output: TRUE
[10:30:48.462] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.462] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.462] Packages: <none>
[10:30:48.462] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.462] Resolved: TRUE
[10:30:48.462] Value: 112 bytes of class ‘list’
[10:30:48.462] Early signaling: FALSE
[10:30:48.462] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.462] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.462] Chunk #2 of 3 ... DONE
[10:30:48.462] Chunk #3 of 3 ...
[10:30:48.463]  - Finding globals in '...' for chunk #3 ...
[10:30:48.463] getGlobalsAndPackages() ...
[10:30:48.463] Searching for globals...
[10:30:48.463] 
[10:30:48.463] Searching for globals ... DONE
[10:30:48.463] - globals: [0] <none>
[10:30:48.463] getGlobalsAndPackages() ... DONE
[10:30:48.464]    + additional globals found: [n=0] 
[10:30:48.464]    + additional namespaces needed: [n=0] 
[10:30:48.464]  - Finding globals in '...' for chunk #3 ... DONE
[10:30:48.464]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:30:48.464]  - seeds: <none>
[10:30:48.464]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.464] getGlobalsAndPackages() ...
[10:30:48.464] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.464] Resolving globals: FALSE
[10:30:48.465] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:48.465] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.465] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.466] 
[10:30:48.466] getGlobalsAndPackages() ... DONE
[10:30:48.466] run() for ‘Future’ ...
[10:30:48.466] - state: ‘created’
[10:30:48.466] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.466] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.467]   - Field: ‘label’
[10:30:48.467]   - Field: ‘local’
[10:30:48.467]   - Field: ‘owner’
[10:30:48.467]   - Field: ‘envir’
[10:30:48.467]   - Field: ‘packages’
[10:30:48.467]   - Field: ‘gc’
[10:30:48.467]   - Field: ‘conditions’
[10:30:48.467]   - Field: ‘expr’
[10:30:48.467]   - Field: ‘uuid’
[10:30:48.467]   - Field: ‘seed’
[10:30:48.468]   - Field: ‘version’
[10:30:48.468]   - Field: ‘result’
[10:30:48.468]   - Field: ‘asynchronous’
[10:30:48.468]   - Field: ‘calls’
[10:30:48.468]   - Field: ‘globals’
[10:30:48.468]   - Field: ‘stdout’
[10:30:48.468]   - Field: ‘earlySignal’
[10:30:48.468]   - Field: ‘lazy’
[10:30:48.468]   - Field: ‘state’
[10:30:48.468] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.469] - Launch lazy future ...
[10:30:48.469] Packages needed by the future expression (n = 0): <none>
[10:30:48.469] Packages needed by future strategies (n = 0): <none>
[10:30:48.469] {
[10:30:48.469]     {
[10:30:48.469]         {
[10:30:48.469]             ...future.startTime <- base::Sys.time()
[10:30:48.469]             {
[10:30:48.469]                 {
[10:30:48.469]                   {
[10:30:48.469]                     base::local({
[10:30:48.469]                       has_future <- base::requireNamespace("future", 
[10:30:48.469]                         quietly = TRUE)
[10:30:48.469]                       if (has_future) {
[10:30:48.469]                         ns <- base::getNamespace("future")
[10:30:48.469]                         version <- ns[[".package"]][["version"]]
[10:30:48.469]                         if (is.null(version)) 
[10:30:48.469]                           version <- utils::packageVersion("future")
[10:30:48.469]                       }
[10:30:48.469]                       else {
[10:30:48.469]                         version <- NULL
[10:30:48.469]                       }
[10:30:48.469]                       if (!has_future || version < "1.8.0") {
[10:30:48.469]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.469]                           "", base::R.version$version.string), 
[10:30:48.469]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.469]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.469]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.469]                             "release", "version")], collapse = " "), 
[10:30:48.469]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.469]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.469]                           info)
[10:30:48.469]                         info <- base::paste(info, collapse = "; ")
[10:30:48.469]                         if (!has_future) {
[10:30:48.469]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.469]                             info)
[10:30:48.469]                         }
[10:30:48.469]                         else {
[10:30:48.469]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.469]                             info, version)
[10:30:48.469]                         }
[10:30:48.469]                         base::stop(msg)
[10:30:48.469]                       }
[10:30:48.469]                     })
[10:30:48.469]                   }
[10:30:48.469]                   ...future.strategy.old <- future::plan("list")
[10:30:48.469]                   options(future.plan = NULL)
[10:30:48.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.469]                 }
[10:30:48.469]                 ...future.workdir <- getwd()
[10:30:48.469]             }
[10:30:48.469]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.469]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.469]         }
[10:30:48.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.469]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:30:48.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.469]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.469]             base::names(...future.oldOptions))
[10:30:48.469]     }
[10:30:48.469]     if (FALSE) {
[10:30:48.469]     }
[10:30:48.469]     else {
[10:30:48.469]         if (TRUE) {
[10:30:48.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.469]                 open = "w")
[10:30:48.469]         }
[10:30:48.469]         else {
[10:30:48.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.469]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.469]         }
[10:30:48.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.469]             base::sink(type = "output", split = FALSE)
[10:30:48.469]             base::close(...future.stdout)
[10:30:48.469]         }, add = TRUE)
[10:30:48.469]     }
[10:30:48.469]     ...future.frame <- base::sys.nframe()
[10:30:48.469]     ...future.conditions <- base::list()
[10:30:48.469]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.469]     if (FALSE) {
[10:30:48.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.469]     }
[10:30:48.469]     ...future.result <- base::tryCatch({
[10:30:48.469]         base::withCallingHandlers({
[10:30:48.469]             ...future.value <- base::withVisible(base::local({
[10:30:48.469]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.469]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.469]                   ...future.globals.maxSize)) {
[10:30:48.469]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.469]                   on.exit(options(oopts), add = TRUE)
[10:30:48.469]                 }
[10:30:48.469]                 {
[10:30:48.469]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.469]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.469]                     USE.NAMES = FALSE)
[10:30:48.469]                   do.call(mapply, args = args)
[10:30:48.469]                 }
[10:30:48.469]             }))
[10:30:48.469]             future::FutureResult(value = ...future.value$value, 
[10:30:48.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.469]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.469]                     ...future.globalenv.names))
[10:30:48.469]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.469]         }, condition = base::local({
[10:30:48.469]             c <- base::c
[10:30:48.469]             inherits <- base::inherits
[10:30:48.469]             invokeRestart <- base::invokeRestart
[10:30:48.469]             length <- base::length
[10:30:48.469]             list <- base::list
[10:30:48.469]             seq.int <- base::seq.int
[10:30:48.469]             signalCondition <- base::signalCondition
[10:30:48.469]             sys.calls <- base::sys.calls
[10:30:48.469]             `[[` <- base::`[[`
[10:30:48.469]             `+` <- base::`+`
[10:30:48.469]             `<<-` <- base::`<<-`
[10:30:48.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.469]                   3L)]
[10:30:48.469]             }
[10:30:48.469]             function(cond) {
[10:30:48.469]                 is_error <- inherits(cond, "error")
[10:30:48.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.469]                   NULL)
[10:30:48.469]                 if (is_error) {
[10:30:48.469]                   sessionInformation <- function() {
[10:30:48.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.469]                       search = base::search(), system = base::Sys.info())
[10:30:48.469]                   }
[10:30:48.469]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.469]                     cond$call), session = sessionInformation(), 
[10:30:48.469]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.469]                   signalCondition(cond)
[10:30:48.469]                 }
[10:30:48.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.469]                 "immediateCondition"))) {
[10:30:48.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.469]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.469]                   if (TRUE && !signal) {
[10:30:48.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.469]                     {
[10:30:48.469]                       inherits <- base::inherits
[10:30:48.469]                       invokeRestart <- base::invokeRestart
[10:30:48.469]                       is.null <- base::is.null
[10:30:48.469]                       muffled <- FALSE
[10:30:48.469]                       if (inherits(cond, "message")) {
[10:30:48.469]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.469]                         if (muffled) 
[10:30:48.469]                           invokeRestart("muffleMessage")
[10:30:48.469]                       }
[10:30:48.469]                       else if (inherits(cond, "warning")) {
[10:30:48.469]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.469]                         if (muffled) 
[10:30:48.469]                           invokeRestart("muffleWarning")
[10:30:48.469]                       }
[10:30:48.469]                       else if (inherits(cond, "condition")) {
[10:30:48.469]                         if (!is.null(pattern)) {
[10:30:48.469]                           computeRestarts <- base::computeRestarts
[10:30:48.469]                           grepl <- base::grepl
[10:30:48.469]                           restarts <- computeRestarts(cond)
[10:30:48.469]                           for (restart in restarts) {
[10:30:48.469]                             name <- restart$name
[10:30:48.469]                             if (is.null(name)) 
[10:30:48.469]                               next
[10:30:48.469]                             if (!grepl(pattern, name)) 
[10:30:48.469]                               next
[10:30:48.469]                             invokeRestart(restart)
[10:30:48.469]                             muffled <- TRUE
[10:30:48.469]                             break
[10:30:48.469]                           }
[10:30:48.469]                         }
[10:30:48.469]                       }
[10:30:48.469]                       invisible(muffled)
[10:30:48.469]                     }
[10:30:48.469]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.469]                   }
[10:30:48.469]                 }
[10:30:48.469]                 else {
[10:30:48.469]                   if (TRUE) {
[10:30:48.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.469]                     {
[10:30:48.469]                       inherits <- base::inherits
[10:30:48.469]                       invokeRestart <- base::invokeRestart
[10:30:48.469]                       is.null <- base::is.null
[10:30:48.469]                       muffled <- FALSE
[10:30:48.469]                       if (inherits(cond, "message")) {
[10:30:48.469]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.469]                         if (muffled) 
[10:30:48.469]                           invokeRestart("muffleMessage")
[10:30:48.469]                       }
[10:30:48.469]                       else if (inherits(cond, "warning")) {
[10:30:48.469]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.469]                         if (muffled) 
[10:30:48.469]                           invokeRestart("muffleWarning")
[10:30:48.469]                       }
[10:30:48.469]                       else if (inherits(cond, "condition")) {
[10:30:48.469]                         if (!is.null(pattern)) {
[10:30:48.469]                           computeRestarts <- base::computeRestarts
[10:30:48.469]                           grepl <- base::grepl
[10:30:48.469]                           restarts <- computeRestarts(cond)
[10:30:48.469]                           for (restart in restarts) {
[10:30:48.469]                             name <- restart$name
[10:30:48.469]                             if (is.null(name)) 
[10:30:48.469]                               next
[10:30:48.469]                             if (!grepl(pattern, name)) 
[10:30:48.469]                               next
[10:30:48.469]                             invokeRestart(restart)
[10:30:48.469]                             muffled <- TRUE
[10:30:48.469]                             break
[10:30:48.469]                           }
[10:30:48.469]                         }
[10:30:48.469]                       }
[10:30:48.469]                       invisible(muffled)
[10:30:48.469]                     }
[10:30:48.469]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.469]                   }
[10:30:48.469]                 }
[10:30:48.469]             }
[10:30:48.469]         }))
[10:30:48.469]     }, error = function(ex) {
[10:30:48.469]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.469]                 ...future.rng), started = ...future.startTime, 
[10:30:48.469]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.469]             version = "1.8"), class = "FutureResult")
[10:30:48.469]     }, finally = {
[10:30:48.469]         if (!identical(...future.workdir, getwd())) 
[10:30:48.469]             setwd(...future.workdir)
[10:30:48.469]         {
[10:30:48.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.469]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.469]             }
[10:30:48.469]             base::options(...future.oldOptions)
[10:30:48.469]             if (.Platform$OS.type == "windows") {
[10:30:48.469]                 old_names <- names(...future.oldEnvVars)
[10:30:48.469]                 envs <- base::Sys.getenv()
[10:30:48.469]                 names <- names(envs)
[10:30:48.469]                 common <- intersect(names, old_names)
[10:30:48.469]                 added <- setdiff(names, old_names)
[10:30:48.469]                 removed <- setdiff(old_names, names)
[10:30:48.469]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.469]                   envs[common]]
[10:30:48.469]                 NAMES <- toupper(changed)
[10:30:48.469]                 args <- list()
[10:30:48.469]                 for (kk in seq_along(NAMES)) {
[10:30:48.469]                   name <- changed[[kk]]
[10:30:48.469]                   NAME <- NAMES[[kk]]
[10:30:48.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.469]                     next
[10:30:48.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.469]                 }
[10:30:48.469]                 NAMES <- toupper(added)
[10:30:48.469]                 for (kk in seq_along(NAMES)) {
[10:30:48.469]                   name <- added[[kk]]
[10:30:48.469]                   NAME <- NAMES[[kk]]
[10:30:48.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.469]                     next
[10:30:48.469]                   args[[name]] <- ""
[10:30:48.469]                 }
[10:30:48.469]                 NAMES <- toupper(removed)
[10:30:48.469]                 for (kk in seq_along(NAMES)) {
[10:30:48.469]                   name <- removed[[kk]]
[10:30:48.469]                   NAME <- NAMES[[kk]]
[10:30:48.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.469]                     next
[10:30:48.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.469]                 }
[10:30:48.469]                 if (length(args) > 0) 
[10:30:48.469]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.469]             }
[10:30:48.469]             else {
[10:30:48.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.469]             }
[10:30:48.469]             {
[10:30:48.469]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.469]                   0L) {
[10:30:48.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.469]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.469]                   base::options(opts)
[10:30:48.469]                 }
[10:30:48.469]                 {
[10:30:48.469]                   {
[10:30:48.469]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.469]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.469]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.469]                       inherits = FALSE)
[10:30:48.469]                     NULL
[10:30:48.469]                   }
[10:30:48.469]                   options(future.plan = NULL)
[10:30:48.469]                   if (is.na(NA_character_)) 
[10:30:48.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.469]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.469]                     .init = FALSE)
[10:30:48.469]                 }
[10:30:48.469]             }
[10:30:48.469]         }
[10:30:48.469]     })
[10:30:48.469]     if (TRUE) {
[10:30:48.469]         base::sink(type = "output", split = FALSE)
[10:30:48.469]         if (TRUE) {
[10:30:48.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.469]         }
[10:30:48.469]         else {
[10:30:48.469]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.469]         }
[10:30:48.469]         base::close(...future.stdout)
[10:30:48.469]         ...future.stdout <- NULL
[10:30:48.469]     }
[10:30:48.469]     ...future.result$conditions <- ...future.conditions
[10:30:48.469]     ...future.result$finished <- base::Sys.time()
[10:30:48.469]     ...future.result
[10:30:48.469] }
[10:30:48.473] assign_globals() ...
[10:30:48.473] List of 5
[10:30:48.473]  $ ...future.FUN            :function (C, k)  
[10:30:48.473]  $ MoreArgs                 : NULL
[10:30:48.473]  $ ...future.elements_ii    :List of 2
[10:30:48.473]   ..$ :List of 2
[10:30:48.473]   .. ..$ : chr "B"
[10:30:48.473]   .. ..$ : chr "D"
[10:30:48.473]   ..$ :List of 2
[10:30:48.473]   .. ..$ : int 4
[10:30:48.473]   .. ..$ : int 2
[10:30:48.473]  $ ...future.seeds_ii       : NULL
[10:30:48.473]  $ ...future.globals.maxSize: NULL
[10:30:48.473]  - attr(*, "where")=List of 5
[10:30:48.473]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.473]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.473]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.473]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.473]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.473]  - attr(*, "resolved")= logi FALSE
[10:30:48.473]  - attr(*, "total_size")= num 3656
[10:30:48.473]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.473]  - attr(*, "already-done")= logi TRUE
[10:30:48.479] - reassign environment for ‘...future.FUN’
[10:30:48.479] - copied ‘...future.FUN’ to environment
[10:30:48.479] - copied ‘MoreArgs’ to environment
[10:30:48.479] - copied ‘...future.elements_ii’ to environment
[10:30:48.479] - copied ‘...future.seeds_ii’ to environment
[10:30:48.479] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.479] assign_globals() ... done
[10:30:48.480] plan(): Setting new future strategy stack:
[10:30:48.480] List of future strategies:
[10:30:48.480] 1. sequential:
[10:30:48.480]    - args: function (..., envir = parent.frame())
[10:30:48.480]    - tweaked: FALSE
[10:30:48.480]    - call: NULL
[10:30:48.480] plan(): nbrOfWorkers() = 1
[10:30:48.481] plan(): Setting new future strategy stack:
[10:30:48.481] List of future strategies:
[10:30:48.481] 1. sequential:
[10:30:48.481]    - args: function (..., envir = parent.frame())
[10:30:48.481]    - tweaked: FALSE
[10:30:48.481]    - call: plan(strategy)
[10:30:48.481] plan(): nbrOfWorkers() = 1
[10:30:48.482] SequentialFuture started (and completed)
[10:30:48.482] - Launch lazy future ... done
[10:30:48.482] run() for ‘SequentialFuture’ ... done
[10:30:48.482] Created future:
[10:30:48.482] SequentialFuture:
[10:30:48.482] Label: ‘future_mapply-3’
[10:30:48.482] Expression:
[10:30:48.482] {
[10:30:48.482]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.482]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.482]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.482]         on.exit(options(oopts), add = TRUE)
[10:30:48.482]     }
[10:30:48.482]     {
[10:30:48.482]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.482]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.482]         do.call(mapply, args = args)
[10:30:48.482]     }
[10:30:48.482] }
[10:30:48.482] Lazy evaluation: FALSE
[10:30:48.482] Asynchronous evaluation: FALSE
[10:30:48.482] Local evaluation: TRUE
[10:30:48.482] Environment: R_GlobalEnv
[10:30:48.482] Capture standard output: TRUE
[10:30:48.482] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.482] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.482] Packages: <none>
[10:30:48.482] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.482] Resolved: TRUE
[10:30:48.482] Value: 224 bytes of class ‘list’
[10:30:48.482] Early signaling: FALSE
[10:30:48.482] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.482] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.483] Chunk #3 of 3 ... DONE
[10:30:48.483] Launching 3 futures (chunks) ... DONE
[10:30:48.483] Resolving 3 futures (chunks) ...
[10:30:48.483] resolve() on list ...
[10:30:48.483]  recursive: 0
[10:30:48.483]  length: 3
[10:30:48.483] 
[10:30:48.484] resolved() for ‘SequentialFuture’ ...
[10:30:48.484] - state: ‘finished’
[10:30:48.484] - run: TRUE
[10:30:48.484] - result: ‘FutureResult’
[10:30:48.484] resolved() for ‘SequentialFuture’ ... done
[10:30:48.484] Future #1
[10:30:48.484] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.484] - nx: 3
[10:30:48.484] - relay: TRUE
[10:30:48.484] - stdout: TRUE
[10:30:48.485] - signal: TRUE
[10:30:48.485] - resignal: FALSE
[10:30:48.485] - force: TRUE
[10:30:48.485] - relayed: [n=3] FALSE, FALSE, FALSE
[10:30:48.485] - queued futures: [n=3] FALSE, FALSE, FALSE
[10:30:48.485]  - until=1
[10:30:48.485]  - relaying element #1
[10:30:48.485] - relayed: [n=3] TRUE, FALSE, FALSE
[10:30:48.485] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:30:48.485] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.486]  length: 2 (resolved future 1)
[10:30:48.486] resolved() for ‘SequentialFuture’ ...
[10:30:48.486] - state: ‘finished’
[10:30:48.486] - run: TRUE
[10:30:48.486] - result: ‘FutureResult’
[10:30:48.486] resolved() for ‘SequentialFuture’ ... done
[10:30:48.486] Future #2
[10:30:48.486] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:30:48.486] - nx: 3
[10:30:48.486] - relay: TRUE
[10:30:48.487] - stdout: TRUE
[10:30:48.487] - signal: TRUE
[10:30:48.487] - resignal: FALSE
[10:30:48.487] - force: TRUE
[10:30:48.487] - relayed: [n=3] TRUE, FALSE, FALSE
[10:30:48.487] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:30:48.487]  - until=2
[10:30:48.487]  - relaying element #2
[10:30:48.487] - relayed: [n=3] TRUE, TRUE, FALSE
[10:30:48.487] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:30:48.487] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:30:48.488]  length: 1 (resolved future 2)
[10:30:48.488] resolved() for ‘SequentialFuture’ ...
[10:30:48.488] - state: ‘finished’
[10:30:48.488] - run: TRUE
[10:30:48.488] - result: ‘FutureResult’
[10:30:48.488] resolved() for ‘SequentialFuture’ ... done
[10:30:48.488] Future #3
[10:30:48.488] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:30:48.488] - nx: 3
[10:30:48.488] - relay: TRUE
[10:30:48.489] - stdout: TRUE
[10:30:48.489] - signal: TRUE
[10:30:48.489] - resignal: FALSE
[10:30:48.489] - force: TRUE
[10:30:48.489] - relayed: [n=3] TRUE, TRUE, FALSE
[10:30:48.489] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:30:48.489]  - until=3
[10:30:48.489]  - relaying element #3
[10:30:48.489] - relayed: [n=3] TRUE, TRUE, TRUE
[10:30:48.489] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:30:48.490] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:30:48.490]  length: 0 (resolved future 3)
[10:30:48.490] Relaying remaining futures
[10:30:48.490] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.490] - nx: 3
[10:30:48.490] - relay: TRUE
[10:30:48.490] - stdout: TRUE
[10:30:48.490] - signal: TRUE
[10:30:48.490] - resignal: FALSE
[10:30:48.490] - force: TRUE
[10:30:48.490] - relayed: [n=3] TRUE, TRUE, TRUE
[10:30:48.490] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[10:30:48.491] - relayed: [n=3] TRUE, TRUE, TRUE
[10:30:48.491] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:30:48.491] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.491] resolve() on list ... DONE
[10:30:48.491]  - Number of value chunks collected: 3
[10:30:48.491] Resolving 3 futures (chunks) ... DONE
[10:30:48.491] Reducing values from 3 chunks ...
[10:30:48.491]  - Number of values collected after concatenation: 5
[10:30:48.491]  - Number of values expected: 5
[10:30:48.492] Reverse index remapping (attribute 'ordering'): [n = 5] 1, 4, 2, 5, 3
[10:30:48.492] Reducing values from 3 chunks ... DONE
[10:30:48.492] future_mapply() ... DONE
[10:30:48.492] future_mapply() ...
[10:30:48.492] Number of chunks: 1
[10:30:48.492] getGlobalsAndPackagesXApply() ...
[10:30:48.492]  - future.globals: TRUE
[10:30:48.492] getGlobalsAndPackages() ...
[10:30:48.493] Searching for globals...
[10:30:48.494] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:48.494] Searching for globals ... DONE
[10:30:48.494] Resolving globals: FALSE
[10:30:48.495] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:48.495] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:48.497] - globals: [1] ‘FUN’
[10:30:48.497] 
[10:30:48.497] getGlobalsAndPackages() ... DONE
[10:30:48.497]  - globals found/used: [n=1] ‘FUN’
[10:30:48.497]  - needed namespaces: [n=0] 
[10:30:48.497] Finding globals ... DONE
[10:30:48.498] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.498] List of 2
[10:30:48.498]  $ ...future.FUN:function (C, k)  
[10:30:48.498]  $ MoreArgs     : list()
[10:30:48.498]  - attr(*, "where")=List of 2
[10:30:48.498]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.498]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.498]  - attr(*, "resolved")= logi FALSE
[10:30:48.498]  - attr(*, "total_size")= num NA
[10:30:48.500] Packages to be attached in all futures: [n=0] 
[10:30:48.501] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.501] Number of futures (= number of chunks): 1
[10:30:48.501] Launching 1 futures (chunks) ...
[10:30:48.501] Chunk #1 of 1 ...
[10:30:48.501]  - Finding globals in '...' for chunk #1 ...
[10:30:48.501] getGlobalsAndPackages() ...
[10:30:48.501] Searching for globals...
[10:30:48.502] 
[10:30:48.502] Searching for globals ... DONE
[10:30:48.502] - globals: [0] <none>
[10:30:48.502] getGlobalsAndPackages() ... DONE
[10:30:48.502]    + additional globals found: [n=0] 
[10:30:48.502]    + additional namespaces needed: [n=0] 
[10:30:48.502]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.502]  - seeds: <none>
[10:30:48.502]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.503] getGlobalsAndPackages() ...
[10:30:48.503] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.503] Resolving globals: FALSE
[10:30:48.503] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[10:30:48.504] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:48.504] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.504] 
[10:30:48.504] getGlobalsAndPackages() ... DONE
[10:30:48.504] run() for ‘Future’ ...
[10:30:48.504] - state: ‘created’
[10:30:48.505] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.505] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.505] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.505]   - Field: ‘label’
[10:30:48.505]   - Field: ‘local’
[10:30:48.505]   - Field: ‘owner’
[10:30:48.505]   - Field: ‘envir’
[10:30:48.506]   - Field: ‘packages’
[10:30:48.506]   - Field: ‘gc’
[10:30:48.506]   - Field: ‘conditions’
[10:30:48.506]   - Field: ‘expr’
[10:30:48.506]   - Field: ‘uuid’
[10:30:48.506]   - Field: ‘seed’
[10:30:48.506]   - Field: ‘version’
[10:30:48.506]   - Field: ‘result’
[10:30:48.506]   - Field: ‘asynchronous’
[10:30:48.506]   - Field: ‘calls’
[10:30:48.506]   - Field: ‘globals’
[10:30:48.507]   - Field: ‘stdout’
[10:30:48.507]   - Field: ‘earlySignal’
[10:30:48.507]   - Field: ‘lazy’
[10:30:48.507]   - Field: ‘state’
[10:30:48.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.507] - Launch lazy future ...
[10:30:48.507] Packages needed by the future expression (n = 0): <none>
[10:30:48.507] Packages needed by future strategies (n = 0): <none>
[10:30:48.508] {
[10:30:48.508]     {
[10:30:48.508]         {
[10:30:48.508]             ...future.startTime <- base::Sys.time()
[10:30:48.508]             {
[10:30:48.508]                 {
[10:30:48.508]                   {
[10:30:48.508]                     base::local({
[10:30:48.508]                       has_future <- base::requireNamespace("future", 
[10:30:48.508]                         quietly = TRUE)
[10:30:48.508]                       if (has_future) {
[10:30:48.508]                         ns <- base::getNamespace("future")
[10:30:48.508]                         version <- ns[[".package"]][["version"]]
[10:30:48.508]                         if (is.null(version)) 
[10:30:48.508]                           version <- utils::packageVersion("future")
[10:30:48.508]                       }
[10:30:48.508]                       else {
[10:30:48.508]                         version <- NULL
[10:30:48.508]                       }
[10:30:48.508]                       if (!has_future || version < "1.8.0") {
[10:30:48.508]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.508]                           "", base::R.version$version.string), 
[10:30:48.508]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.508]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.508]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.508]                             "release", "version")], collapse = " "), 
[10:30:48.508]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.508]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.508]                           info)
[10:30:48.508]                         info <- base::paste(info, collapse = "; ")
[10:30:48.508]                         if (!has_future) {
[10:30:48.508]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.508]                             info)
[10:30:48.508]                         }
[10:30:48.508]                         else {
[10:30:48.508]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.508]                             info, version)
[10:30:48.508]                         }
[10:30:48.508]                         base::stop(msg)
[10:30:48.508]                       }
[10:30:48.508]                     })
[10:30:48.508]                   }
[10:30:48.508]                   ...future.strategy.old <- future::plan("list")
[10:30:48.508]                   options(future.plan = NULL)
[10:30:48.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.508]                 }
[10:30:48.508]                 ...future.workdir <- getwd()
[10:30:48.508]             }
[10:30:48.508]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.508]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.508]         }
[10:30:48.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.508]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.508]             base::names(...future.oldOptions))
[10:30:48.508]     }
[10:30:48.508]     if (FALSE) {
[10:30:48.508]     }
[10:30:48.508]     else {
[10:30:48.508]         if (TRUE) {
[10:30:48.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.508]                 open = "w")
[10:30:48.508]         }
[10:30:48.508]         else {
[10:30:48.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.508]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.508]         }
[10:30:48.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.508]             base::sink(type = "output", split = FALSE)
[10:30:48.508]             base::close(...future.stdout)
[10:30:48.508]         }, add = TRUE)
[10:30:48.508]     }
[10:30:48.508]     ...future.frame <- base::sys.nframe()
[10:30:48.508]     ...future.conditions <- base::list()
[10:30:48.508]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.508]     if (FALSE) {
[10:30:48.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.508]     }
[10:30:48.508]     ...future.result <- base::tryCatch({
[10:30:48.508]         base::withCallingHandlers({
[10:30:48.508]             ...future.value <- base::withVisible(base::local({
[10:30:48.508]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.508]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.508]                   ...future.globals.maxSize)) {
[10:30:48.508]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.508]                   on.exit(options(oopts), add = TRUE)
[10:30:48.508]                 }
[10:30:48.508]                 {
[10:30:48.508]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.508]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.508]                     USE.NAMES = FALSE)
[10:30:48.508]                   do.call(mapply, args = args)
[10:30:48.508]                 }
[10:30:48.508]             }))
[10:30:48.508]             future::FutureResult(value = ...future.value$value, 
[10:30:48.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.508]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.508]                     ...future.globalenv.names))
[10:30:48.508]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.508]         }, condition = base::local({
[10:30:48.508]             c <- base::c
[10:30:48.508]             inherits <- base::inherits
[10:30:48.508]             invokeRestart <- base::invokeRestart
[10:30:48.508]             length <- base::length
[10:30:48.508]             list <- base::list
[10:30:48.508]             seq.int <- base::seq.int
[10:30:48.508]             signalCondition <- base::signalCondition
[10:30:48.508]             sys.calls <- base::sys.calls
[10:30:48.508]             `[[` <- base::`[[`
[10:30:48.508]             `+` <- base::`+`
[10:30:48.508]             `<<-` <- base::`<<-`
[10:30:48.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.508]                   3L)]
[10:30:48.508]             }
[10:30:48.508]             function(cond) {
[10:30:48.508]                 is_error <- inherits(cond, "error")
[10:30:48.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.508]                   NULL)
[10:30:48.508]                 if (is_error) {
[10:30:48.508]                   sessionInformation <- function() {
[10:30:48.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.508]                       search = base::search(), system = base::Sys.info())
[10:30:48.508]                   }
[10:30:48.508]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.508]                     cond$call), session = sessionInformation(), 
[10:30:48.508]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.508]                   signalCondition(cond)
[10:30:48.508]                 }
[10:30:48.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.508]                 "immediateCondition"))) {
[10:30:48.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.508]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.508]                   if (TRUE && !signal) {
[10:30:48.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.508]                     {
[10:30:48.508]                       inherits <- base::inherits
[10:30:48.508]                       invokeRestart <- base::invokeRestart
[10:30:48.508]                       is.null <- base::is.null
[10:30:48.508]                       muffled <- FALSE
[10:30:48.508]                       if (inherits(cond, "message")) {
[10:30:48.508]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.508]                         if (muffled) 
[10:30:48.508]                           invokeRestart("muffleMessage")
[10:30:48.508]                       }
[10:30:48.508]                       else if (inherits(cond, "warning")) {
[10:30:48.508]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.508]                         if (muffled) 
[10:30:48.508]                           invokeRestart("muffleWarning")
[10:30:48.508]                       }
[10:30:48.508]                       else if (inherits(cond, "condition")) {
[10:30:48.508]                         if (!is.null(pattern)) {
[10:30:48.508]                           computeRestarts <- base::computeRestarts
[10:30:48.508]                           grepl <- base::grepl
[10:30:48.508]                           restarts <- computeRestarts(cond)
[10:30:48.508]                           for (restart in restarts) {
[10:30:48.508]                             name <- restart$name
[10:30:48.508]                             if (is.null(name)) 
[10:30:48.508]                               next
[10:30:48.508]                             if (!grepl(pattern, name)) 
[10:30:48.508]                               next
[10:30:48.508]                             invokeRestart(restart)
[10:30:48.508]                             muffled <- TRUE
[10:30:48.508]                             break
[10:30:48.508]                           }
[10:30:48.508]                         }
[10:30:48.508]                       }
[10:30:48.508]                       invisible(muffled)
[10:30:48.508]                     }
[10:30:48.508]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.508]                   }
[10:30:48.508]                 }
[10:30:48.508]                 else {
[10:30:48.508]                   if (TRUE) {
[10:30:48.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.508]                     {
[10:30:48.508]                       inherits <- base::inherits
[10:30:48.508]                       invokeRestart <- base::invokeRestart
[10:30:48.508]                       is.null <- base::is.null
[10:30:48.508]                       muffled <- FALSE
[10:30:48.508]                       if (inherits(cond, "message")) {
[10:30:48.508]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.508]                         if (muffled) 
[10:30:48.508]                           invokeRestart("muffleMessage")
[10:30:48.508]                       }
[10:30:48.508]                       else if (inherits(cond, "warning")) {
[10:30:48.508]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.508]                         if (muffled) 
[10:30:48.508]                           invokeRestart("muffleWarning")
[10:30:48.508]                       }
[10:30:48.508]                       else if (inherits(cond, "condition")) {
[10:30:48.508]                         if (!is.null(pattern)) {
[10:30:48.508]                           computeRestarts <- base::computeRestarts
[10:30:48.508]                           grepl <- base::grepl
[10:30:48.508]                           restarts <- computeRestarts(cond)
[10:30:48.508]                           for (restart in restarts) {
[10:30:48.508]                             name <- restart$name
[10:30:48.508]                             if (is.null(name)) 
[10:30:48.508]                               next
[10:30:48.508]                             if (!grepl(pattern, name)) 
[10:30:48.508]                               next
[10:30:48.508]                             invokeRestart(restart)
[10:30:48.508]                             muffled <- TRUE
[10:30:48.508]                             break
[10:30:48.508]                           }
[10:30:48.508]                         }
[10:30:48.508]                       }
[10:30:48.508]                       invisible(muffled)
[10:30:48.508]                     }
[10:30:48.508]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.508]                   }
[10:30:48.508]                 }
[10:30:48.508]             }
[10:30:48.508]         }))
[10:30:48.508]     }, error = function(ex) {
[10:30:48.508]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.508]                 ...future.rng), started = ...future.startTime, 
[10:30:48.508]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.508]             version = "1.8"), class = "FutureResult")
[10:30:48.508]     }, finally = {
[10:30:48.508]         if (!identical(...future.workdir, getwd())) 
[10:30:48.508]             setwd(...future.workdir)
[10:30:48.508]         {
[10:30:48.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.508]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.508]             }
[10:30:48.508]             base::options(...future.oldOptions)
[10:30:48.508]             if (.Platform$OS.type == "windows") {
[10:30:48.508]                 old_names <- names(...future.oldEnvVars)
[10:30:48.508]                 envs <- base::Sys.getenv()
[10:30:48.508]                 names <- names(envs)
[10:30:48.508]                 common <- intersect(names, old_names)
[10:30:48.508]                 added <- setdiff(names, old_names)
[10:30:48.508]                 removed <- setdiff(old_names, names)
[10:30:48.508]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.508]                   envs[common]]
[10:30:48.508]                 NAMES <- toupper(changed)
[10:30:48.508]                 args <- list()
[10:30:48.508]                 for (kk in seq_along(NAMES)) {
[10:30:48.508]                   name <- changed[[kk]]
[10:30:48.508]                   NAME <- NAMES[[kk]]
[10:30:48.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.508]                     next
[10:30:48.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.508]                 }
[10:30:48.508]                 NAMES <- toupper(added)
[10:30:48.508]                 for (kk in seq_along(NAMES)) {
[10:30:48.508]                   name <- added[[kk]]
[10:30:48.508]                   NAME <- NAMES[[kk]]
[10:30:48.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.508]                     next
[10:30:48.508]                   args[[name]] <- ""
[10:30:48.508]                 }
[10:30:48.508]                 NAMES <- toupper(removed)
[10:30:48.508]                 for (kk in seq_along(NAMES)) {
[10:30:48.508]                   name <- removed[[kk]]
[10:30:48.508]                   NAME <- NAMES[[kk]]
[10:30:48.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.508]                     next
[10:30:48.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.508]                 }
[10:30:48.508]                 if (length(args) > 0) 
[10:30:48.508]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.508]             }
[10:30:48.508]             else {
[10:30:48.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.508]             }
[10:30:48.508]             {
[10:30:48.508]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.508]                   0L) {
[10:30:48.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.508]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.508]                   base::options(opts)
[10:30:48.508]                 }
[10:30:48.508]                 {
[10:30:48.508]                   {
[10:30:48.508]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.508]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.508]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.508]                       inherits = FALSE)
[10:30:48.508]                     NULL
[10:30:48.508]                   }
[10:30:48.508]                   options(future.plan = NULL)
[10:30:48.508]                   if (is.na(NA_character_)) 
[10:30:48.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.508]                     .init = FALSE)
[10:30:48.508]                 }
[10:30:48.508]             }
[10:30:48.508]         }
[10:30:48.508]     })
[10:30:48.508]     if (TRUE) {
[10:30:48.508]         base::sink(type = "output", split = FALSE)
[10:30:48.508]         if (TRUE) {
[10:30:48.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.508]         }
[10:30:48.508]         else {
[10:30:48.508]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.508]         }
[10:30:48.508]         base::close(...future.stdout)
[10:30:48.508]         ...future.stdout <- NULL
[10:30:48.508]     }
[10:30:48.508]     ...future.result$conditions <- ...future.conditions
[10:30:48.508]     ...future.result$finished <- base::Sys.time()
[10:30:48.508]     ...future.result
[10:30:48.508] }
[10:30:48.510] assign_globals() ...
[10:30:48.510] List of 5
[10:30:48.510]  $ ...future.FUN            :function (C, k)  
[10:30:48.510]  $ MoreArgs                 : list()
[10:30:48.510]  $ ...future.elements_ii    :List of 2
[10:30:48.510]   ..$ :List of 5
[10:30:48.510]   .. ..$ : chr "A"
[10:30:48.510]   .. ..$ : chr "B"
[10:30:48.510]   .. ..$ : chr "C"
[10:30:48.510]   .. ..$ : chr "D"
[10:30:48.510]   .. ..$ : chr "E"
[10:30:48.510]   ..$ :List of 5
[10:30:48.510]   .. ..$ : int 5
[10:30:48.510]   .. ..$ : int 4
[10:30:48.510]   .. ..$ : int 3
[10:30:48.510]   .. ..$ : int 2
[10:30:48.510]   .. ..$ : int 1
[10:30:48.510]  $ ...future.seeds_ii       : NULL
[10:30:48.510]  $ ...future.globals.maxSize: NULL
[10:30:48.510]  - attr(*, "where")=List of 5
[10:30:48.510]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.510]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.510]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.510]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.510]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.510]  - attr(*, "resolved")= logi FALSE
[10:30:48.510]  - attr(*, "total_size")= num 4160
[10:30:48.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.510]  - attr(*, "already-done")= logi TRUE
[10:30:48.517] - reassign environment for ‘...future.FUN’
[10:30:48.517] - copied ‘...future.FUN’ to environment
[10:30:48.517] - copied ‘MoreArgs’ to environment
[10:30:48.517] - copied ‘...future.elements_ii’ to environment
[10:30:48.517] - copied ‘...future.seeds_ii’ to environment
[10:30:48.517] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.517] assign_globals() ... done
[10:30:48.518] plan(): Setting new future strategy stack:
[10:30:48.518] List of future strategies:
[10:30:48.518] 1. sequential:
[10:30:48.518]    - args: function (..., envir = parent.frame())
[10:30:48.518]    - tweaked: FALSE
[10:30:48.518]    - call: NULL
[10:30:48.518] plan(): nbrOfWorkers() = 1
[10:30:48.519] plan(): Setting new future strategy stack:
[10:30:48.519] List of future strategies:
[10:30:48.519] 1. sequential:
[10:30:48.519]    - args: function (..., envir = parent.frame())
[10:30:48.519]    - tweaked: FALSE
[10:30:48.519]    - call: plan(strategy)
[10:30:48.519] plan(): nbrOfWorkers() = 1
[10:30:48.520] SequentialFuture started (and completed)
[10:30:48.520] - Launch lazy future ... done
[10:30:48.520] run() for ‘SequentialFuture’ ... done
[10:30:48.520] Created future:
[10:30:48.520] SequentialFuture:
[10:30:48.520] Label: ‘future_.mapply-1’
[10:30:48.520] Expression:
[10:30:48.520] {
[10:30:48.520]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.520]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.520]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.520]         on.exit(options(oopts), add = TRUE)
[10:30:48.520]     }
[10:30:48.520]     {
[10:30:48.520]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.520]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.520]         do.call(mapply, args = args)
[10:30:48.520]     }
[10:30:48.520] }
[10:30:48.520] Lazy evaluation: FALSE
[10:30:48.520] Asynchronous evaluation: FALSE
[10:30:48.520] Local evaluation: TRUE
[10:30:48.520] Environment: R_GlobalEnv
[10:30:48.520] Capture standard output: TRUE
[10:30:48.520] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.520] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.520] Packages: <none>
[10:30:48.520] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.520] Resolved: TRUE
[10:30:48.520] Value: 560 bytes of class ‘list’
[10:30:48.520] Early signaling: FALSE
[10:30:48.520] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.520] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.523] Chunk #1 of 1 ... DONE
[10:30:48.523] Launching 1 futures (chunks) ... DONE
[10:30:48.523] Resolving 1 futures (chunks) ...
[10:30:48.523] resolve() on list ...
[10:30:48.523]  recursive: 0
[10:30:48.524]  length: 1
[10:30:48.524] 
[10:30:48.524] resolved() for ‘SequentialFuture’ ...
[10:30:48.524] - state: ‘finished’
[10:30:48.524] - run: TRUE
[10:30:48.524] - result: ‘FutureResult’
[10:30:48.524] resolved() for ‘SequentialFuture’ ... done
[10:30:48.524] Future #1
[10:30:48.525] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.525] - nx: 1
[10:30:48.525] - relay: TRUE
[10:30:48.525] - stdout: TRUE
[10:30:48.525] - signal: TRUE
[10:30:48.525] - resignal: FALSE
[10:30:48.525] - force: TRUE
[10:30:48.525] - relayed: [n=1] FALSE
[10:30:48.525] - queued futures: [n=1] FALSE
[10:30:48.525]  - until=1
[10:30:48.525]  - relaying element #1
[10:30:48.526] - relayed: [n=1] TRUE
[10:30:48.526] - queued futures: [n=1] TRUE
[10:30:48.526] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.526]  length: 0 (resolved future 1)
[10:30:48.526] Relaying remaining futures
[10:30:48.526] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.526] - nx: 1
[10:30:48.526] - relay: TRUE
[10:30:48.526] - stdout: TRUE
[10:30:48.526] - signal: TRUE
[10:30:48.527] - resignal: FALSE
[10:30:48.527] - force: TRUE
[10:30:48.527] - relayed: [n=1] TRUE
[10:30:48.527] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.527] - relayed: [n=1] TRUE
[10:30:48.527] - queued futures: [n=1] TRUE
[10:30:48.527] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.527] resolve() on list ... DONE
[10:30:48.527]  - Number of value chunks collected: 1
[10:30:48.528] Resolving 1 futures (chunks) ... DONE
[10:30:48.528] Reducing values from 1 chunks ...
[10:30:48.528]  - Number of values collected after concatenation: 5
[10:30:48.528]  - Number of values expected: 5
[10:30:48.528] Reducing values from 1 chunks ... DONE
[10:30:48.528] future_mapply() ... DONE
[10:30:48.528] future_mapply() ...
[10:30:48.529] Number of chunks: 2
[10:30:48.529] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:30:48.529] getGlobalsAndPackagesXApply() ...
[10:30:48.529]  - future.globals: TRUE
[10:30:48.529] getGlobalsAndPackages() ...
[10:30:48.529] Searching for globals...
[10:30:48.530] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:48.531] Searching for globals ... DONE
[10:30:48.531] Resolving globals: FALSE
[10:30:48.531] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:48.531] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:48.531] - globals: [1] ‘FUN’
[10:30:48.532] 
[10:30:48.532] getGlobalsAndPackages() ... DONE
[10:30:48.532]  - globals found/used: [n=1] ‘FUN’
[10:30:48.532]  - needed namespaces: [n=0] 
[10:30:48.532] Finding globals ... DONE
[10:30:48.532] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.532] List of 2
[10:30:48.532]  $ ...future.FUN:function (C, k)  
[10:30:48.532]  $ MoreArgs     : NULL
[10:30:48.532]  - attr(*, "where")=List of 2
[10:30:48.532]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.532]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.532]  - attr(*, "resolved")= logi FALSE
[10:30:48.532]  - attr(*, "total_size")= num NA
[10:30:48.535] Packages to be attached in all futures: [n=0] 
[10:30:48.535] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.535] Number of futures (= number of chunks): 2
[10:30:48.535] Launching 2 futures (chunks) ...
[10:30:48.535] Chunk #1 of 2 ...
[10:30:48.535]  - Finding globals in '...' for chunk #1 ...
[10:30:48.535] getGlobalsAndPackages() ...
[10:30:48.535] Searching for globals...
[10:30:48.536] 
[10:30:48.536] Searching for globals ... DONE
[10:30:48.536] - globals: [0] <none>
[10:30:48.536] getGlobalsAndPackages() ... DONE
[10:30:48.536]    + additional globals found: [n=0] 
[10:30:48.536]    + additional namespaces needed: [n=0] 
[10:30:48.536]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.536]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:48.537]  - seeds: <none>
[10:30:48.537]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.537] getGlobalsAndPackages() ...
[10:30:48.537] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.537] Resolving globals: FALSE
[10:30:48.537] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:48.538] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.538] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.538] 
[10:30:48.538] getGlobalsAndPackages() ... DONE
[10:30:48.538] run() for ‘Future’ ...
[10:30:48.539] - state: ‘created’
[10:30:48.539] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.539] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.539] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.539]   - Field: ‘label’
[10:30:48.539]   - Field: ‘local’
[10:30:48.539]   - Field: ‘owner’
[10:30:48.539]   - Field: ‘envir’
[10:30:48.540]   - Field: ‘packages’
[10:30:48.540]   - Field: ‘gc’
[10:30:48.540]   - Field: ‘conditions’
[10:30:48.540]   - Field: ‘expr’
[10:30:48.540]   - Field: ‘uuid’
[10:30:48.540]   - Field: ‘seed’
[10:30:48.540]   - Field: ‘version’
[10:30:48.540]   - Field: ‘result’
[10:30:48.540]   - Field: ‘asynchronous’
[10:30:48.540]   - Field: ‘calls’
[10:30:48.540]   - Field: ‘globals’
[10:30:48.541]   - Field: ‘stdout’
[10:30:48.541]   - Field: ‘earlySignal’
[10:30:48.541]   - Field: ‘lazy’
[10:30:48.541]   - Field: ‘state’
[10:30:48.541] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.541] - Launch lazy future ...
[10:30:48.541] Packages needed by the future expression (n = 0): <none>
[10:30:48.541] Packages needed by future strategies (n = 0): <none>
[10:30:48.542] {
[10:30:48.542]     {
[10:30:48.542]         {
[10:30:48.542]             ...future.startTime <- base::Sys.time()
[10:30:48.542]             {
[10:30:48.542]                 {
[10:30:48.542]                   {
[10:30:48.542]                     base::local({
[10:30:48.542]                       has_future <- base::requireNamespace("future", 
[10:30:48.542]                         quietly = TRUE)
[10:30:48.542]                       if (has_future) {
[10:30:48.542]                         ns <- base::getNamespace("future")
[10:30:48.542]                         version <- ns[[".package"]][["version"]]
[10:30:48.542]                         if (is.null(version)) 
[10:30:48.542]                           version <- utils::packageVersion("future")
[10:30:48.542]                       }
[10:30:48.542]                       else {
[10:30:48.542]                         version <- NULL
[10:30:48.542]                       }
[10:30:48.542]                       if (!has_future || version < "1.8.0") {
[10:30:48.542]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.542]                           "", base::R.version$version.string), 
[10:30:48.542]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.542]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.542]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.542]                             "release", "version")], collapse = " "), 
[10:30:48.542]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.542]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.542]                           info)
[10:30:48.542]                         info <- base::paste(info, collapse = "; ")
[10:30:48.542]                         if (!has_future) {
[10:30:48.542]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.542]                             info)
[10:30:48.542]                         }
[10:30:48.542]                         else {
[10:30:48.542]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.542]                             info, version)
[10:30:48.542]                         }
[10:30:48.542]                         base::stop(msg)
[10:30:48.542]                       }
[10:30:48.542]                     })
[10:30:48.542]                   }
[10:30:48.542]                   ...future.strategy.old <- future::plan("list")
[10:30:48.542]                   options(future.plan = NULL)
[10:30:48.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.542]                 }
[10:30:48.542]                 ...future.workdir <- getwd()
[10:30:48.542]             }
[10:30:48.542]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.542]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.542]         }
[10:30:48.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.542]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:48.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.542]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.542]             base::names(...future.oldOptions))
[10:30:48.542]     }
[10:30:48.542]     if (FALSE) {
[10:30:48.542]     }
[10:30:48.542]     else {
[10:30:48.542]         if (TRUE) {
[10:30:48.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.542]                 open = "w")
[10:30:48.542]         }
[10:30:48.542]         else {
[10:30:48.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.542]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.542]         }
[10:30:48.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.542]             base::sink(type = "output", split = FALSE)
[10:30:48.542]             base::close(...future.stdout)
[10:30:48.542]         }, add = TRUE)
[10:30:48.542]     }
[10:30:48.542]     ...future.frame <- base::sys.nframe()
[10:30:48.542]     ...future.conditions <- base::list()
[10:30:48.542]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.542]     if (FALSE) {
[10:30:48.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.542]     }
[10:30:48.542]     ...future.result <- base::tryCatch({
[10:30:48.542]         base::withCallingHandlers({
[10:30:48.542]             ...future.value <- base::withVisible(base::local({
[10:30:48.542]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.542]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.542]                   ...future.globals.maxSize)) {
[10:30:48.542]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.542]                   on.exit(options(oopts), add = TRUE)
[10:30:48.542]                 }
[10:30:48.542]                 {
[10:30:48.542]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.542]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.542]                     USE.NAMES = FALSE)
[10:30:48.542]                   do.call(mapply, args = args)
[10:30:48.542]                 }
[10:30:48.542]             }))
[10:30:48.542]             future::FutureResult(value = ...future.value$value, 
[10:30:48.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.542]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.542]                     ...future.globalenv.names))
[10:30:48.542]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.542]         }, condition = base::local({
[10:30:48.542]             c <- base::c
[10:30:48.542]             inherits <- base::inherits
[10:30:48.542]             invokeRestart <- base::invokeRestart
[10:30:48.542]             length <- base::length
[10:30:48.542]             list <- base::list
[10:30:48.542]             seq.int <- base::seq.int
[10:30:48.542]             signalCondition <- base::signalCondition
[10:30:48.542]             sys.calls <- base::sys.calls
[10:30:48.542]             `[[` <- base::`[[`
[10:30:48.542]             `+` <- base::`+`
[10:30:48.542]             `<<-` <- base::`<<-`
[10:30:48.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.542]                   3L)]
[10:30:48.542]             }
[10:30:48.542]             function(cond) {
[10:30:48.542]                 is_error <- inherits(cond, "error")
[10:30:48.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.542]                   NULL)
[10:30:48.542]                 if (is_error) {
[10:30:48.542]                   sessionInformation <- function() {
[10:30:48.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.542]                       search = base::search(), system = base::Sys.info())
[10:30:48.542]                   }
[10:30:48.542]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.542]                     cond$call), session = sessionInformation(), 
[10:30:48.542]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.542]                   signalCondition(cond)
[10:30:48.542]                 }
[10:30:48.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.542]                 "immediateCondition"))) {
[10:30:48.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.542]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.542]                   if (TRUE && !signal) {
[10:30:48.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.542]                     {
[10:30:48.542]                       inherits <- base::inherits
[10:30:48.542]                       invokeRestart <- base::invokeRestart
[10:30:48.542]                       is.null <- base::is.null
[10:30:48.542]                       muffled <- FALSE
[10:30:48.542]                       if (inherits(cond, "message")) {
[10:30:48.542]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.542]                         if (muffled) 
[10:30:48.542]                           invokeRestart("muffleMessage")
[10:30:48.542]                       }
[10:30:48.542]                       else if (inherits(cond, "warning")) {
[10:30:48.542]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.542]                         if (muffled) 
[10:30:48.542]                           invokeRestart("muffleWarning")
[10:30:48.542]                       }
[10:30:48.542]                       else if (inherits(cond, "condition")) {
[10:30:48.542]                         if (!is.null(pattern)) {
[10:30:48.542]                           computeRestarts <- base::computeRestarts
[10:30:48.542]                           grepl <- base::grepl
[10:30:48.542]                           restarts <- computeRestarts(cond)
[10:30:48.542]                           for (restart in restarts) {
[10:30:48.542]                             name <- restart$name
[10:30:48.542]                             if (is.null(name)) 
[10:30:48.542]                               next
[10:30:48.542]                             if (!grepl(pattern, name)) 
[10:30:48.542]                               next
[10:30:48.542]                             invokeRestart(restart)
[10:30:48.542]                             muffled <- TRUE
[10:30:48.542]                             break
[10:30:48.542]                           }
[10:30:48.542]                         }
[10:30:48.542]                       }
[10:30:48.542]                       invisible(muffled)
[10:30:48.542]                     }
[10:30:48.542]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.542]                   }
[10:30:48.542]                 }
[10:30:48.542]                 else {
[10:30:48.542]                   if (TRUE) {
[10:30:48.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.542]                     {
[10:30:48.542]                       inherits <- base::inherits
[10:30:48.542]                       invokeRestart <- base::invokeRestart
[10:30:48.542]                       is.null <- base::is.null
[10:30:48.542]                       muffled <- FALSE
[10:30:48.542]                       if (inherits(cond, "message")) {
[10:30:48.542]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.542]                         if (muffled) 
[10:30:48.542]                           invokeRestart("muffleMessage")
[10:30:48.542]                       }
[10:30:48.542]                       else if (inherits(cond, "warning")) {
[10:30:48.542]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.542]                         if (muffled) 
[10:30:48.542]                           invokeRestart("muffleWarning")
[10:30:48.542]                       }
[10:30:48.542]                       else if (inherits(cond, "condition")) {
[10:30:48.542]                         if (!is.null(pattern)) {
[10:30:48.542]                           computeRestarts <- base::computeRestarts
[10:30:48.542]                           grepl <- base::grepl
[10:30:48.542]                           restarts <- computeRestarts(cond)
[10:30:48.542]                           for (restart in restarts) {
[10:30:48.542]                             name <- restart$name
[10:30:48.542]                             if (is.null(name)) 
[10:30:48.542]                               next
[10:30:48.542]                             if (!grepl(pattern, name)) 
[10:30:48.542]                               next
[10:30:48.542]                             invokeRestart(restart)
[10:30:48.542]                             muffled <- TRUE
[10:30:48.542]                             break
[10:30:48.542]                           }
[10:30:48.542]                         }
[10:30:48.542]                       }
[10:30:48.542]                       invisible(muffled)
[10:30:48.542]                     }
[10:30:48.542]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.542]                   }
[10:30:48.542]                 }
[10:30:48.542]             }
[10:30:48.542]         }))
[10:30:48.542]     }, error = function(ex) {
[10:30:48.542]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.542]                 ...future.rng), started = ...future.startTime, 
[10:30:48.542]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.542]             version = "1.8"), class = "FutureResult")
[10:30:48.542]     }, finally = {
[10:30:48.542]         if (!identical(...future.workdir, getwd())) 
[10:30:48.542]             setwd(...future.workdir)
[10:30:48.542]         {
[10:30:48.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.542]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.542]             }
[10:30:48.542]             base::options(...future.oldOptions)
[10:30:48.542]             if (.Platform$OS.type == "windows") {
[10:30:48.542]                 old_names <- names(...future.oldEnvVars)
[10:30:48.542]                 envs <- base::Sys.getenv()
[10:30:48.542]                 names <- names(envs)
[10:30:48.542]                 common <- intersect(names, old_names)
[10:30:48.542]                 added <- setdiff(names, old_names)
[10:30:48.542]                 removed <- setdiff(old_names, names)
[10:30:48.542]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.542]                   envs[common]]
[10:30:48.542]                 NAMES <- toupper(changed)
[10:30:48.542]                 args <- list()
[10:30:48.542]                 for (kk in seq_along(NAMES)) {
[10:30:48.542]                   name <- changed[[kk]]
[10:30:48.542]                   NAME <- NAMES[[kk]]
[10:30:48.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.542]                     next
[10:30:48.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.542]                 }
[10:30:48.542]                 NAMES <- toupper(added)
[10:30:48.542]                 for (kk in seq_along(NAMES)) {
[10:30:48.542]                   name <- added[[kk]]
[10:30:48.542]                   NAME <- NAMES[[kk]]
[10:30:48.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.542]                     next
[10:30:48.542]                   args[[name]] <- ""
[10:30:48.542]                 }
[10:30:48.542]                 NAMES <- toupper(removed)
[10:30:48.542]                 for (kk in seq_along(NAMES)) {
[10:30:48.542]                   name <- removed[[kk]]
[10:30:48.542]                   NAME <- NAMES[[kk]]
[10:30:48.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.542]                     next
[10:30:48.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.542]                 }
[10:30:48.542]                 if (length(args) > 0) 
[10:30:48.542]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.542]             }
[10:30:48.542]             else {
[10:30:48.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.542]             }
[10:30:48.542]             {
[10:30:48.542]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.542]                   0L) {
[10:30:48.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.542]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.542]                   base::options(opts)
[10:30:48.542]                 }
[10:30:48.542]                 {
[10:30:48.542]                   {
[10:30:48.542]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.542]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.542]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.542]                       inherits = FALSE)
[10:30:48.542]                     NULL
[10:30:48.542]                   }
[10:30:48.542]                   options(future.plan = NULL)
[10:30:48.542]                   if (is.na(NA_character_)) 
[10:30:48.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.542]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.542]                     .init = FALSE)
[10:30:48.542]                 }
[10:30:48.542]             }
[10:30:48.542]         }
[10:30:48.542]     })
[10:30:48.542]     if (TRUE) {
[10:30:48.542]         base::sink(type = "output", split = FALSE)
[10:30:48.542]         if (TRUE) {
[10:30:48.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.542]         }
[10:30:48.542]         else {
[10:30:48.542]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.542]         }
[10:30:48.542]         base::close(...future.stdout)
[10:30:48.542]         ...future.stdout <- NULL
[10:30:48.542]     }
[10:30:48.542]     ...future.result$conditions <- ...future.conditions
[10:30:48.542]     ...future.result$finished <- base::Sys.time()
[10:30:48.542]     ...future.result
[10:30:48.542] }
[10:30:48.543] assign_globals() ...
[10:30:48.544] List of 5
[10:30:48.544]  $ ...future.FUN            :function (C, k)  
[10:30:48.544]  $ MoreArgs                 : NULL
[10:30:48.544]  $ ...future.elements_ii    :List of 2
[10:30:48.544]   ..$ :List of 2
[10:30:48.544]   .. ..$ : chr "E"
[10:30:48.544]   .. ..$ : chr "D"
[10:30:48.544]   ..$ :List of 2
[10:30:48.544]   .. ..$ : int 1
[10:30:48.544]   .. ..$ : int 2
[10:30:48.544]  $ ...future.seeds_ii       : NULL
[10:30:48.544]  $ ...future.globals.maxSize: NULL
[10:30:48.544]  - attr(*, "where")=List of 5
[10:30:48.544]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.544]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.544]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.544]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.544]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.544]  - attr(*, "resolved")= logi FALSE
[10:30:48.544]  - attr(*, "total_size")= num 3656
[10:30:48.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.544]  - attr(*, "already-done")= logi TRUE
[10:30:48.551] - reassign environment for ‘...future.FUN’
[10:30:48.551] - copied ‘...future.FUN’ to environment
[10:30:48.551] - copied ‘MoreArgs’ to environment
[10:30:48.552] - copied ‘...future.elements_ii’ to environment
[10:30:48.552] - copied ‘...future.seeds_ii’ to environment
[10:30:48.552] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.552] assign_globals() ... done
[10:30:48.552] plan(): Setting new future strategy stack:
[10:30:48.552] List of future strategies:
[10:30:48.552] 1. sequential:
[10:30:48.552]    - args: function (..., envir = parent.frame())
[10:30:48.552]    - tweaked: FALSE
[10:30:48.552]    - call: NULL
[10:30:48.553] plan(): nbrOfWorkers() = 1
[10:30:48.553] plan(): Setting new future strategy stack:
[10:30:48.554] List of future strategies:
[10:30:48.554] 1. sequential:
[10:30:48.554]    - args: function (..., envir = parent.frame())
[10:30:48.554]    - tweaked: FALSE
[10:30:48.554]    - call: plan(strategy)
[10:30:48.554] plan(): nbrOfWorkers() = 1
[10:30:48.554] SequentialFuture started (and completed)
[10:30:48.554] - Launch lazy future ... done
[10:30:48.554] run() for ‘SequentialFuture’ ... done
[10:30:48.554] Created future:
[10:30:48.554] SequentialFuture:
[10:30:48.554] Label: ‘future_mapply-1’
[10:30:48.554] Expression:
[10:30:48.554] {
[10:30:48.554]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.554]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.554]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.554]         on.exit(options(oopts), add = TRUE)
[10:30:48.554]     }
[10:30:48.554]     {
[10:30:48.554]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.554]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.554]         do.call(mapply, args = args)
[10:30:48.554]     }
[10:30:48.554] }
[10:30:48.554] Lazy evaluation: FALSE
[10:30:48.554] Asynchronous evaluation: FALSE
[10:30:48.554] Local evaluation: TRUE
[10:30:48.554] Environment: R_GlobalEnv
[10:30:48.554] Capture standard output: TRUE
[10:30:48.554] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.554] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.554] Packages: <none>
[10:30:48.554] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.554] Resolved: TRUE
[10:30:48.554] Value: 224 bytes of class ‘list’
[10:30:48.554] Early signaling: FALSE
[10:30:48.554] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.554] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.555] Chunk #1 of 2 ... DONE
[10:30:48.556] Chunk #2 of 2 ...
[10:30:48.556]  - Finding globals in '...' for chunk #2 ...
[10:30:48.556] getGlobalsAndPackages() ...
[10:30:48.556] Searching for globals...
[10:30:48.556] 
[10:30:48.556] Searching for globals ... DONE
[10:30:48.556] - globals: [0] <none>
[10:30:48.556] getGlobalsAndPackages() ... DONE
[10:30:48.557]    + additional globals found: [n=0] 
[10:30:48.557]    + additional namespaces needed: [n=0] 
[10:30:48.557]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:48.557]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:48.557]  - seeds: <none>
[10:30:48.557]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.557] getGlobalsAndPackages() ...
[10:30:48.557] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.557] Resolving globals: FALSE
[10:30:48.558] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[10:30:48.558] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.559] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.559] 
[10:30:48.559] getGlobalsAndPackages() ... DONE
[10:30:48.559] run() for ‘Future’ ...
[10:30:48.559] - state: ‘created’
[10:30:48.559] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.560] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.560] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.560]   - Field: ‘label’
[10:30:48.560]   - Field: ‘local’
[10:30:48.560]   - Field: ‘owner’
[10:30:48.560]   - Field: ‘envir’
[10:30:48.560]   - Field: ‘packages’
[10:30:48.560]   - Field: ‘gc’
[10:30:48.560]   - Field: ‘conditions’
[10:30:48.560]   - Field: ‘expr’
[10:30:48.561]   - Field: ‘uuid’
[10:30:48.561]   - Field: ‘seed’
[10:30:48.561]   - Field: ‘version’
[10:30:48.561]   - Field: ‘result’
[10:30:48.561]   - Field: ‘asynchronous’
[10:30:48.561]   - Field: ‘calls’
[10:30:48.561]   - Field: ‘globals’
[10:30:48.561]   - Field: ‘stdout’
[10:30:48.561]   - Field: ‘earlySignal’
[10:30:48.561]   - Field: ‘lazy’
[10:30:48.561]   - Field: ‘state’
[10:30:48.562] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.562] - Launch lazy future ...
[10:30:48.562] Packages needed by the future expression (n = 0): <none>
[10:30:48.562] Packages needed by future strategies (n = 0): <none>
[10:30:48.562] {
[10:30:48.562]     {
[10:30:48.562]         {
[10:30:48.562]             ...future.startTime <- base::Sys.time()
[10:30:48.562]             {
[10:30:48.562]                 {
[10:30:48.562]                   {
[10:30:48.562]                     base::local({
[10:30:48.562]                       has_future <- base::requireNamespace("future", 
[10:30:48.562]                         quietly = TRUE)
[10:30:48.562]                       if (has_future) {
[10:30:48.562]                         ns <- base::getNamespace("future")
[10:30:48.562]                         version <- ns[[".package"]][["version"]]
[10:30:48.562]                         if (is.null(version)) 
[10:30:48.562]                           version <- utils::packageVersion("future")
[10:30:48.562]                       }
[10:30:48.562]                       else {
[10:30:48.562]                         version <- NULL
[10:30:48.562]                       }
[10:30:48.562]                       if (!has_future || version < "1.8.0") {
[10:30:48.562]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.562]                           "", base::R.version$version.string), 
[10:30:48.562]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.562]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.562]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.562]                             "release", "version")], collapse = " "), 
[10:30:48.562]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.562]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.562]                           info)
[10:30:48.562]                         info <- base::paste(info, collapse = "; ")
[10:30:48.562]                         if (!has_future) {
[10:30:48.562]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.562]                             info)
[10:30:48.562]                         }
[10:30:48.562]                         else {
[10:30:48.562]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.562]                             info, version)
[10:30:48.562]                         }
[10:30:48.562]                         base::stop(msg)
[10:30:48.562]                       }
[10:30:48.562]                     })
[10:30:48.562]                   }
[10:30:48.562]                   ...future.strategy.old <- future::plan("list")
[10:30:48.562]                   options(future.plan = NULL)
[10:30:48.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.562]                 }
[10:30:48.562]                 ...future.workdir <- getwd()
[10:30:48.562]             }
[10:30:48.562]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.562]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.562]         }
[10:30:48.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.562]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:48.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.562]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.562]             base::names(...future.oldOptions))
[10:30:48.562]     }
[10:30:48.562]     if (FALSE) {
[10:30:48.562]     }
[10:30:48.562]     else {
[10:30:48.562]         if (TRUE) {
[10:30:48.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.562]                 open = "w")
[10:30:48.562]         }
[10:30:48.562]         else {
[10:30:48.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.562]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.562]         }
[10:30:48.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.562]             base::sink(type = "output", split = FALSE)
[10:30:48.562]             base::close(...future.stdout)
[10:30:48.562]         }, add = TRUE)
[10:30:48.562]     }
[10:30:48.562]     ...future.frame <- base::sys.nframe()
[10:30:48.562]     ...future.conditions <- base::list()
[10:30:48.562]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.562]     if (FALSE) {
[10:30:48.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.562]     }
[10:30:48.562]     ...future.result <- base::tryCatch({
[10:30:48.562]         base::withCallingHandlers({
[10:30:48.562]             ...future.value <- base::withVisible(base::local({
[10:30:48.562]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.562]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.562]                   ...future.globals.maxSize)) {
[10:30:48.562]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.562]                   on.exit(options(oopts), add = TRUE)
[10:30:48.562]                 }
[10:30:48.562]                 {
[10:30:48.562]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.562]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.562]                     USE.NAMES = FALSE)
[10:30:48.562]                   do.call(mapply, args = args)
[10:30:48.562]                 }
[10:30:48.562]             }))
[10:30:48.562]             future::FutureResult(value = ...future.value$value, 
[10:30:48.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.562]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.562]                     ...future.globalenv.names))
[10:30:48.562]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.562]         }, condition = base::local({
[10:30:48.562]             c <- base::c
[10:30:48.562]             inherits <- base::inherits
[10:30:48.562]             invokeRestart <- base::invokeRestart
[10:30:48.562]             length <- base::length
[10:30:48.562]             list <- base::list
[10:30:48.562]             seq.int <- base::seq.int
[10:30:48.562]             signalCondition <- base::signalCondition
[10:30:48.562]             sys.calls <- base::sys.calls
[10:30:48.562]             `[[` <- base::`[[`
[10:30:48.562]             `+` <- base::`+`
[10:30:48.562]             `<<-` <- base::`<<-`
[10:30:48.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.562]                   3L)]
[10:30:48.562]             }
[10:30:48.562]             function(cond) {
[10:30:48.562]                 is_error <- inherits(cond, "error")
[10:30:48.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.562]                   NULL)
[10:30:48.562]                 if (is_error) {
[10:30:48.562]                   sessionInformation <- function() {
[10:30:48.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.562]                       search = base::search(), system = base::Sys.info())
[10:30:48.562]                   }
[10:30:48.562]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.562]                     cond$call), session = sessionInformation(), 
[10:30:48.562]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.562]                   signalCondition(cond)
[10:30:48.562]                 }
[10:30:48.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.562]                 "immediateCondition"))) {
[10:30:48.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.562]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.562]                   if (TRUE && !signal) {
[10:30:48.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.562]                     {
[10:30:48.562]                       inherits <- base::inherits
[10:30:48.562]                       invokeRestart <- base::invokeRestart
[10:30:48.562]                       is.null <- base::is.null
[10:30:48.562]                       muffled <- FALSE
[10:30:48.562]                       if (inherits(cond, "message")) {
[10:30:48.562]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.562]                         if (muffled) 
[10:30:48.562]                           invokeRestart("muffleMessage")
[10:30:48.562]                       }
[10:30:48.562]                       else if (inherits(cond, "warning")) {
[10:30:48.562]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.562]                         if (muffled) 
[10:30:48.562]                           invokeRestart("muffleWarning")
[10:30:48.562]                       }
[10:30:48.562]                       else if (inherits(cond, "condition")) {
[10:30:48.562]                         if (!is.null(pattern)) {
[10:30:48.562]                           computeRestarts <- base::computeRestarts
[10:30:48.562]                           grepl <- base::grepl
[10:30:48.562]                           restarts <- computeRestarts(cond)
[10:30:48.562]                           for (restart in restarts) {
[10:30:48.562]                             name <- restart$name
[10:30:48.562]                             if (is.null(name)) 
[10:30:48.562]                               next
[10:30:48.562]                             if (!grepl(pattern, name)) 
[10:30:48.562]                               next
[10:30:48.562]                             invokeRestart(restart)
[10:30:48.562]                             muffled <- TRUE
[10:30:48.562]                             break
[10:30:48.562]                           }
[10:30:48.562]                         }
[10:30:48.562]                       }
[10:30:48.562]                       invisible(muffled)
[10:30:48.562]                     }
[10:30:48.562]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.562]                   }
[10:30:48.562]                 }
[10:30:48.562]                 else {
[10:30:48.562]                   if (TRUE) {
[10:30:48.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.562]                     {
[10:30:48.562]                       inherits <- base::inherits
[10:30:48.562]                       invokeRestart <- base::invokeRestart
[10:30:48.562]                       is.null <- base::is.null
[10:30:48.562]                       muffled <- FALSE
[10:30:48.562]                       if (inherits(cond, "message")) {
[10:30:48.562]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.562]                         if (muffled) 
[10:30:48.562]                           invokeRestart("muffleMessage")
[10:30:48.562]                       }
[10:30:48.562]                       else if (inherits(cond, "warning")) {
[10:30:48.562]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.562]                         if (muffled) 
[10:30:48.562]                           invokeRestart("muffleWarning")
[10:30:48.562]                       }
[10:30:48.562]                       else if (inherits(cond, "condition")) {
[10:30:48.562]                         if (!is.null(pattern)) {
[10:30:48.562]                           computeRestarts <- base::computeRestarts
[10:30:48.562]                           grepl <- base::grepl
[10:30:48.562]                           restarts <- computeRestarts(cond)
[10:30:48.562]                           for (restart in restarts) {
[10:30:48.562]                             name <- restart$name
[10:30:48.562]                             if (is.null(name)) 
[10:30:48.562]                               next
[10:30:48.562]                             if (!grepl(pattern, name)) 
[10:30:48.562]                               next
[10:30:48.562]                             invokeRestart(restart)
[10:30:48.562]                             muffled <- TRUE
[10:30:48.562]                             break
[10:30:48.562]                           }
[10:30:48.562]                         }
[10:30:48.562]                       }
[10:30:48.562]                       invisible(muffled)
[10:30:48.562]                     }
[10:30:48.562]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.562]                   }
[10:30:48.562]                 }
[10:30:48.562]             }
[10:30:48.562]         }))
[10:30:48.562]     }, error = function(ex) {
[10:30:48.562]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.562]                 ...future.rng), started = ...future.startTime, 
[10:30:48.562]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.562]             version = "1.8"), class = "FutureResult")
[10:30:48.562]     }, finally = {
[10:30:48.562]         if (!identical(...future.workdir, getwd())) 
[10:30:48.562]             setwd(...future.workdir)
[10:30:48.562]         {
[10:30:48.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.562]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.562]             }
[10:30:48.562]             base::options(...future.oldOptions)
[10:30:48.562]             if (.Platform$OS.type == "windows") {
[10:30:48.562]                 old_names <- names(...future.oldEnvVars)
[10:30:48.562]                 envs <- base::Sys.getenv()
[10:30:48.562]                 names <- names(envs)
[10:30:48.562]                 common <- intersect(names, old_names)
[10:30:48.562]                 added <- setdiff(names, old_names)
[10:30:48.562]                 removed <- setdiff(old_names, names)
[10:30:48.562]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.562]                   envs[common]]
[10:30:48.562]                 NAMES <- toupper(changed)
[10:30:48.562]                 args <- list()
[10:30:48.562]                 for (kk in seq_along(NAMES)) {
[10:30:48.562]                   name <- changed[[kk]]
[10:30:48.562]                   NAME <- NAMES[[kk]]
[10:30:48.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.562]                     next
[10:30:48.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.562]                 }
[10:30:48.562]                 NAMES <- toupper(added)
[10:30:48.562]                 for (kk in seq_along(NAMES)) {
[10:30:48.562]                   name <- added[[kk]]
[10:30:48.562]                   NAME <- NAMES[[kk]]
[10:30:48.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.562]                     next
[10:30:48.562]                   args[[name]] <- ""
[10:30:48.562]                 }
[10:30:48.562]                 NAMES <- toupper(removed)
[10:30:48.562]                 for (kk in seq_along(NAMES)) {
[10:30:48.562]                   name <- removed[[kk]]
[10:30:48.562]                   NAME <- NAMES[[kk]]
[10:30:48.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.562]                     next
[10:30:48.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.562]                 }
[10:30:48.562]                 if (length(args) > 0) 
[10:30:48.562]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.562]             }
[10:30:48.562]             else {
[10:30:48.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.562]             }
[10:30:48.562]             {
[10:30:48.562]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.562]                   0L) {
[10:30:48.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.562]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.562]                   base::options(opts)
[10:30:48.562]                 }
[10:30:48.562]                 {
[10:30:48.562]                   {
[10:30:48.562]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.562]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.562]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.562]                       inherits = FALSE)
[10:30:48.562]                     NULL
[10:30:48.562]                   }
[10:30:48.562]                   options(future.plan = NULL)
[10:30:48.562]                   if (is.na(NA_character_)) 
[10:30:48.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.562]                     .init = FALSE)
[10:30:48.562]                 }
[10:30:48.562]             }
[10:30:48.562]         }
[10:30:48.562]     })
[10:30:48.562]     if (TRUE) {
[10:30:48.562]         base::sink(type = "output", split = FALSE)
[10:30:48.562]         if (TRUE) {
[10:30:48.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.562]         }
[10:30:48.562]         else {
[10:30:48.562]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.562]         }
[10:30:48.562]         base::close(...future.stdout)
[10:30:48.562]         ...future.stdout <- NULL
[10:30:48.562]     }
[10:30:48.562]     ...future.result$conditions <- ...future.conditions
[10:30:48.562]     ...future.result$finished <- base::Sys.time()
[10:30:48.562]     ...future.result
[10:30:48.562] }
[10:30:48.564] assign_globals() ...
[10:30:48.564] List of 5
[10:30:48.564]  $ ...future.FUN            :function (C, k)  
[10:30:48.564]  $ MoreArgs                 : NULL
[10:30:48.564]  $ ...future.elements_ii    :List of 2
[10:30:48.564]   ..$ :List of 3
[10:30:48.564]   .. ..$ : chr "C"
[10:30:48.564]   .. ..$ : chr "B"
[10:30:48.564]   .. ..$ : chr "A"
[10:30:48.564]   ..$ :List of 3
[10:30:48.564]   .. ..$ : int 3
[10:30:48.564]   .. ..$ : int 4
[10:30:48.564]   .. ..$ : int 5
[10:30:48.564]  $ ...future.seeds_ii       : NULL
[10:30:48.564]  $ ...future.globals.maxSize: NULL
[10:30:48.564]  - attr(*, "where")=List of 5
[10:30:48.564]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.564]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.564]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.564]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.564]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.564]  - attr(*, "resolved")= logi FALSE
[10:30:48.564]  - attr(*, "total_size")= num 3824
[10:30:48.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.564]  - attr(*, "already-done")= logi TRUE
[10:30:48.570] - reassign environment for ‘...future.FUN’
[10:30:48.571] - copied ‘...future.FUN’ to environment
[10:30:48.571] - copied ‘MoreArgs’ to environment
[10:30:48.571] - copied ‘...future.elements_ii’ to environment
[10:30:48.571] - copied ‘...future.seeds_ii’ to environment
[10:30:48.571] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.573] assign_globals() ... done
[10:30:48.574] plan(): Setting new future strategy stack:
[10:30:48.574] List of future strategies:
[10:30:48.574] 1. sequential:
[10:30:48.574]    - args: function (..., envir = parent.frame())
[10:30:48.574]    - tweaked: FALSE
[10:30:48.574]    - call: NULL
[10:30:48.574] plan(): nbrOfWorkers() = 1
[10:30:48.575] plan(): Setting new future strategy stack:
[10:30:48.575] List of future strategies:
[10:30:48.575] 1. sequential:
[10:30:48.575]    - args: function (..., envir = parent.frame())
[10:30:48.575]    - tweaked: FALSE
[10:30:48.575]    - call: plan(strategy)
[10:30:48.576] plan(): nbrOfWorkers() = 1
[10:30:48.576] SequentialFuture started (and completed)
[10:30:48.576] - Launch lazy future ... done
[10:30:48.576] run() for ‘SequentialFuture’ ... done
[10:30:48.576] Created future:
[10:30:48.576] SequentialFuture:
[10:30:48.576] Label: ‘future_mapply-2’
[10:30:48.576] Expression:
[10:30:48.576] {
[10:30:48.576]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.576]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.576]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.576]         on.exit(options(oopts), add = TRUE)
[10:30:48.576]     }
[10:30:48.576]     {
[10:30:48.576]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.576]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.576]         do.call(mapply, args = args)
[10:30:48.576]     }
[10:30:48.576] }
[10:30:48.576] Lazy evaluation: FALSE
[10:30:48.576] Asynchronous evaluation: FALSE
[10:30:48.576] Local evaluation: TRUE
[10:30:48.576] Environment: R_GlobalEnv
[10:30:48.576] Capture standard output: TRUE
[10:30:48.576] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.576] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.576] Packages: <none>
[10:30:48.576] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.576] Resolved: TRUE
[10:30:48.576] Value: 336 bytes of class ‘list’
[10:30:48.576] Early signaling: FALSE
[10:30:48.576] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.576] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.577] Chunk #2 of 2 ... DONE
[10:30:48.577] Launching 2 futures (chunks) ... DONE
[10:30:48.577] Resolving 2 futures (chunks) ...
[10:30:48.578] resolve() on list ...
[10:30:48.578]  recursive: 0
[10:30:48.578]  length: 2
[10:30:48.578] 
[10:30:48.578] resolved() for ‘SequentialFuture’ ...
[10:30:48.578] - state: ‘finished’
[10:30:48.578] - run: TRUE
[10:30:48.578] - result: ‘FutureResult’
[10:30:48.578] resolved() for ‘SequentialFuture’ ... done
[10:30:48.578] Future #1
[10:30:48.579] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.579] - nx: 2
[10:30:48.579] - relay: TRUE
[10:30:48.579] - stdout: TRUE
[10:30:48.579] - signal: TRUE
[10:30:48.579] - resignal: FALSE
[10:30:48.579] - force: TRUE
[10:30:48.579] - relayed: [n=2] FALSE, FALSE
[10:30:48.579] - queued futures: [n=2] FALSE, FALSE
[10:30:48.579]  - until=1
[10:30:48.579]  - relaying element #1
[10:30:48.580] - relayed: [n=2] TRUE, FALSE
[10:30:48.580] - queued futures: [n=2] TRUE, FALSE
[10:30:48.580] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.580]  length: 1 (resolved future 1)
[10:30:48.580] resolved() for ‘SequentialFuture’ ...
[10:30:48.580] - state: ‘finished’
[10:30:48.580] - run: TRUE
[10:30:48.580] - result: ‘FutureResult’
[10:30:48.580] resolved() for ‘SequentialFuture’ ... done
[10:30:48.581] Future #2
[10:30:48.581] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:30:48.581] - nx: 2
[10:30:48.581] - relay: TRUE
[10:30:48.581] - stdout: TRUE
[10:30:48.581] - signal: TRUE
[10:30:48.581] - resignal: FALSE
[10:30:48.581] - force: TRUE
[10:30:48.581] - relayed: [n=2] TRUE, FALSE
[10:30:48.581] - queued futures: [n=2] TRUE, FALSE
[10:30:48.581]  - until=2
[10:30:48.582]  - relaying element #2
[10:30:48.582] - relayed: [n=2] TRUE, TRUE
[10:30:48.582] - queued futures: [n=2] TRUE, TRUE
[10:30:48.582] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:30:48.582]  length: 0 (resolved future 2)
[10:30:48.582] Relaying remaining futures
[10:30:48.582] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.582] - nx: 2
[10:30:48.582] - relay: TRUE
[10:30:48.582] - stdout: TRUE
[10:30:48.582] - signal: TRUE
[10:30:48.583] - resignal: FALSE
[10:30:48.583] - force: TRUE
[10:30:48.583] - relayed: [n=2] TRUE, TRUE
[10:30:48.583] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:48.583] - relayed: [n=2] TRUE, TRUE
[10:30:48.583] - queued futures: [n=2] TRUE, TRUE
[10:30:48.583] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.583] resolve() on list ... DONE
[10:30:48.583]  - Number of value chunks collected: 2
[10:30:48.583] Resolving 2 futures (chunks) ... DONE
[10:30:48.584] Reducing values from 2 chunks ...
[10:30:48.584]  - Number of values collected after concatenation: 5
[10:30:48.584]  - Number of values expected: 5
[10:30:48.584] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:30:48.584] Reducing values from 2 chunks ... DONE
[10:30:48.584] future_mapply() ... DONE
[10:30:48.584] future_mapply() ...
[10:30:48.584] Number of chunks: 1
[10:30:48.585] getGlobalsAndPackagesXApply() ...
[10:30:48.585]  - future.globals: TRUE
[10:30:48.585] getGlobalsAndPackages() ...
[10:30:48.585] Searching for globals...
[10:30:48.586] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:48.586] Searching for globals ... DONE
[10:30:48.586] Resolving globals: FALSE
[10:30:48.587] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:48.587] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:48.587] - globals: [1] ‘FUN’
[10:30:48.587] 
[10:30:48.587] getGlobalsAndPackages() ... DONE
[10:30:48.587]  - globals found/used: [n=1] ‘FUN’
[10:30:48.588]  - needed namespaces: [n=0] 
[10:30:48.588] Finding globals ... DONE
[10:30:48.588] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.588] List of 2
[10:30:48.588]  $ ...future.FUN:function (C, k)  
[10:30:48.588]  $ MoreArgs     : list()
[10:30:48.588]  - attr(*, "where")=List of 2
[10:30:48.588]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.588]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.588]  - attr(*, "resolved")= logi FALSE
[10:30:48.588]  - attr(*, "total_size")= num NA
[10:30:48.591] Packages to be attached in all futures: [n=0] 
[10:30:48.591] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.591] Number of futures (= number of chunks): 1
[10:30:48.591] Launching 1 futures (chunks) ...
[10:30:48.591] Chunk #1 of 1 ...
[10:30:48.591]  - Finding globals in '...' for chunk #1 ...
[10:30:48.591] getGlobalsAndPackages() ...
[10:30:48.591] Searching for globals...
[10:30:48.592] 
[10:30:48.592] Searching for globals ... DONE
[10:30:48.592] - globals: [0] <none>
[10:30:48.592] getGlobalsAndPackages() ... DONE
[10:30:48.592]    + additional globals found: [n=0] 
[10:30:48.592]    + additional namespaces needed: [n=0] 
[10:30:48.592]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.592]  - seeds: <none>
[10:30:48.592]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.593] getGlobalsAndPackages() ...
[10:30:48.593] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.593] Resolving globals: FALSE
[10:30:48.593] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[10:30:48.594] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:48.594] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.594] 
[10:30:48.594] getGlobalsAndPackages() ... DONE
[10:30:48.594] run() for ‘Future’ ...
[10:30:48.595] - state: ‘created’
[10:30:48.595] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.595] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.595] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.595]   - Field: ‘label’
[10:30:48.595]   - Field: ‘local’
[10:30:48.595]   - Field: ‘owner’
[10:30:48.596]   - Field: ‘envir’
[10:30:48.596]   - Field: ‘packages’
[10:30:48.596]   - Field: ‘gc’
[10:30:48.598]   - Field: ‘conditions’
[10:30:48.598]   - Field: ‘expr’
[10:30:48.598]   - Field: ‘uuid’
[10:30:48.598]   - Field: ‘seed’
[10:30:48.598]   - Field: ‘version’
[10:30:48.598]   - Field: ‘result’
[10:30:48.598]   - Field: ‘asynchronous’
[10:30:48.599]   - Field: ‘calls’
[10:30:48.599]   - Field: ‘globals’
[10:30:48.599]   - Field: ‘stdout’
[10:30:48.599]   - Field: ‘earlySignal’
[10:30:48.599]   - Field: ‘lazy’
[10:30:48.599]   - Field: ‘state’
[10:30:48.599] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.599] - Launch lazy future ...
[10:30:48.600] Packages needed by the future expression (n = 0): <none>
[10:30:48.600] Packages needed by future strategies (n = 0): <none>
[10:30:48.600] {
[10:30:48.600]     {
[10:30:48.600]         {
[10:30:48.600]             ...future.startTime <- base::Sys.time()
[10:30:48.600]             {
[10:30:48.600]                 {
[10:30:48.600]                   {
[10:30:48.600]                     base::local({
[10:30:48.600]                       has_future <- base::requireNamespace("future", 
[10:30:48.600]                         quietly = TRUE)
[10:30:48.600]                       if (has_future) {
[10:30:48.600]                         ns <- base::getNamespace("future")
[10:30:48.600]                         version <- ns[[".package"]][["version"]]
[10:30:48.600]                         if (is.null(version)) 
[10:30:48.600]                           version <- utils::packageVersion("future")
[10:30:48.600]                       }
[10:30:48.600]                       else {
[10:30:48.600]                         version <- NULL
[10:30:48.600]                       }
[10:30:48.600]                       if (!has_future || version < "1.8.0") {
[10:30:48.600]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.600]                           "", base::R.version$version.string), 
[10:30:48.600]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.600]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.600]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.600]                             "release", "version")], collapse = " "), 
[10:30:48.600]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.600]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.600]                           info)
[10:30:48.600]                         info <- base::paste(info, collapse = "; ")
[10:30:48.600]                         if (!has_future) {
[10:30:48.600]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.600]                             info)
[10:30:48.600]                         }
[10:30:48.600]                         else {
[10:30:48.600]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.600]                             info, version)
[10:30:48.600]                         }
[10:30:48.600]                         base::stop(msg)
[10:30:48.600]                       }
[10:30:48.600]                     })
[10:30:48.600]                   }
[10:30:48.600]                   ...future.strategy.old <- future::plan("list")
[10:30:48.600]                   options(future.plan = NULL)
[10:30:48.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.600]                 }
[10:30:48.600]                 ...future.workdir <- getwd()
[10:30:48.600]             }
[10:30:48.600]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.600]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.600]         }
[10:30:48.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.600]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.600]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.600]             base::names(...future.oldOptions))
[10:30:48.600]     }
[10:30:48.600]     if (FALSE) {
[10:30:48.600]     }
[10:30:48.600]     else {
[10:30:48.600]         if (TRUE) {
[10:30:48.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.600]                 open = "w")
[10:30:48.600]         }
[10:30:48.600]         else {
[10:30:48.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.600]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.600]         }
[10:30:48.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.600]             base::sink(type = "output", split = FALSE)
[10:30:48.600]             base::close(...future.stdout)
[10:30:48.600]         }, add = TRUE)
[10:30:48.600]     }
[10:30:48.600]     ...future.frame <- base::sys.nframe()
[10:30:48.600]     ...future.conditions <- base::list()
[10:30:48.600]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.600]     if (FALSE) {
[10:30:48.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.600]     }
[10:30:48.600]     ...future.result <- base::tryCatch({
[10:30:48.600]         base::withCallingHandlers({
[10:30:48.600]             ...future.value <- base::withVisible(base::local({
[10:30:48.600]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.600]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.600]                   ...future.globals.maxSize)) {
[10:30:48.600]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.600]                   on.exit(options(oopts), add = TRUE)
[10:30:48.600]                 }
[10:30:48.600]                 {
[10:30:48.600]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.600]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.600]                     USE.NAMES = FALSE)
[10:30:48.600]                   do.call(mapply, args = args)
[10:30:48.600]                 }
[10:30:48.600]             }))
[10:30:48.600]             future::FutureResult(value = ...future.value$value, 
[10:30:48.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.600]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.600]                     ...future.globalenv.names))
[10:30:48.600]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.600]         }, condition = base::local({
[10:30:48.600]             c <- base::c
[10:30:48.600]             inherits <- base::inherits
[10:30:48.600]             invokeRestart <- base::invokeRestart
[10:30:48.600]             length <- base::length
[10:30:48.600]             list <- base::list
[10:30:48.600]             seq.int <- base::seq.int
[10:30:48.600]             signalCondition <- base::signalCondition
[10:30:48.600]             sys.calls <- base::sys.calls
[10:30:48.600]             `[[` <- base::`[[`
[10:30:48.600]             `+` <- base::`+`
[10:30:48.600]             `<<-` <- base::`<<-`
[10:30:48.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.600]                   3L)]
[10:30:48.600]             }
[10:30:48.600]             function(cond) {
[10:30:48.600]                 is_error <- inherits(cond, "error")
[10:30:48.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.600]                   NULL)
[10:30:48.600]                 if (is_error) {
[10:30:48.600]                   sessionInformation <- function() {
[10:30:48.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.600]                       search = base::search(), system = base::Sys.info())
[10:30:48.600]                   }
[10:30:48.600]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.600]                     cond$call), session = sessionInformation(), 
[10:30:48.600]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.600]                   signalCondition(cond)
[10:30:48.600]                 }
[10:30:48.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.600]                 "immediateCondition"))) {
[10:30:48.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.600]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.600]                   if (TRUE && !signal) {
[10:30:48.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.600]                     {
[10:30:48.600]                       inherits <- base::inherits
[10:30:48.600]                       invokeRestart <- base::invokeRestart
[10:30:48.600]                       is.null <- base::is.null
[10:30:48.600]                       muffled <- FALSE
[10:30:48.600]                       if (inherits(cond, "message")) {
[10:30:48.600]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.600]                         if (muffled) 
[10:30:48.600]                           invokeRestart("muffleMessage")
[10:30:48.600]                       }
[10:30:48.600]                       else if (inherits(cond, "warning")) {
[10:30:48.600]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.600]                         if (muffled) 
[10:30:48.600]                           invokeRestart("muffleWarning")
[10:30:48.600]                       }
[10:30:48.600]                       else if (inherits(cond, "condition")) {
[10:30:48.600]                         if (!is.null(pattern)) {
[10:30:48.600]                           computeRestarts <- base::computeRestarts
[10:30:48.600]                           grepl <- base::grepl
[10:30:48.600]                           restarts <- computeRestarts(cond)
[10:30:48.600]                           for (restart in restarts) {
[10:30:48.600]                             name <- restart$name
[10:30:48.600]                             if (is.null(name)) 
[10:30:48.600]                               next
[10:30:48.600]                             if (!grepl(pattern, name)) 
[10:30:48.600]                               next
[10:30:48.600]                             invokeRestart(restart)
[10:30:48.600]                             muffled <- TRUE
[10:30:48.600]                             break
[10:30:48.600]                           }
[10:30:48.600]                         }
[10:30:48.600]                       }
[10:30:48.600]                       invisible(muffled)
[10:30:48.600]                     }
[10:30:48.600]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.600]                   }
[10:30:48.600]                 }
[10:30:48.600]                 else {
[10:30:48.600]                   if (TRUE) {
[10:30:48.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.600]                     {
[10:30:48.600]                       inherits <- base::inherits
[10:30:48.600]                       invokeRestart <- base::invokeRestart
[10:30:48.600]                       is.null <- base::is.null
[10:30:48.600]                       muffled <- FALSE
[10:30:48.600]                       if (inherits(cond, "message")) {
[10:30:48.600]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.600]                         if (muffled) 
[10:30:48.600]                           invokeRestart("muffleMessage")
[10:30:48.600]                       }
[10:30:48.600]                       else if (inherits(cond, "warning")) {
[10:30:48.600]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.600]                         if (muffled) 
[10:30:48.600]                           invokeRestart("muffleWarning")
[10:30:48.600]                       }
[10:30:48.600]                       else if (inherits(cond, "condition")) {
[10:30:48.600]                         if (!is.null(pattern)) {
[10:30:48.600]                           computeRestarts <- base::computeRestarts
[10:30:48.600]                           grepl <- base::grepl
[10:30:48.600]                           restarts <- computeRestarts(cond)
[10:30:48.600]                           for (restart in restarts) {
[10:30:48.600]                             name <- restart$name
[10:30:48.600]                             if (is.null(name)) 
[10:30:48.600]                               next
[10:30:48.600]                             if (!grepl(pattern, name)) 
[10:30:48.600]                               next
[10:30:48.600]                             invokeRestart(restart)
[10:30:48.600]                             muffled <- TRUE
[10:30:48.600]                             break
[10:30:48.600]                           }
[10:30:48.600]                         }
[10:30:48.600]                       }
[10:30:48.600]                       invisible(muffled)
[10:30:48.600]                     }
[10:30:48.600]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.600]                   }
[10:30:48.600]                 }
[10:30:48.600]             }
[10:30:48.600]         }))
[10:30:48.600]     }, error = function(ex) {
[10:30:48.600]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.600]                 ...future.rng), started = ...future.startTime, 
[10:30:48.600]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.600]             version = "1.8"), class = "FutureResult")
[10:30:48.600]     }, finally = {
[10:30:48.600]         if (!identical(...future.workdir, getwd())) 
[10:30:48.600]             setwd(...future.workdir)
[10:30:48.600]         {
[10:30:48.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.600]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.600]             }
[10:30:48.600]             base::options(...future.oldOptions)
[10:30:48.600]             if (.Platform$OS.type == "windows") {
[10:30:48.600]                 old_names <- names(...future.oldEnvVars)
[10:30:48.600]                 envs <- base::Sys.getenv()
[10:30:48.600]                 names <- names(envs)
[10:30:48.600]                 common <- intersect(names, old_names)
[10:30:48.600]                 added <- setdiff(names, old_names)
[10:30:48.600]                 removed <- setdiff(old_names, names)
[10:30:48.600]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.600]                   envs[common]]
[10:30:48.600]                 NAMES <- toupper(changed)
[10:30:48.600]                 args <- list()
[10:30:48.600]                 for (kk in seq_along(NAMES)) {
[10:30:48.600]                   name <- changed[[kk]]
[10:30:48.600]                   NAME <- NAMES[[kk]]
[10:30:48.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.600]                     next
[10:30:48.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.600]                 }
[10:30:48.600]                 NAMES <- toupper(added)
[10:30:48.600]                 for (kk in seq_along(NAMES)) {
[10:30:48.600]                   name <- added[[kk]]
[10:30:48.600]                   NAME <- NAMES[[kk]]
[10:30:48.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.600]                     next
[10:30:48.600]                   args[[name]] <- ""
[10:30:48.600]                 }
[10:30:48.600]                 NAMES <- toupper(removed)
[10:30:48.600]                 for (kk in seq_along(NAMES)) {
[10:30:48.600]                   name <- removed[[kk]]
[10:30:48.600]                   NAME <- NAMES[[kk]]
[10:30:48.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.600]                     next
[10:30:48.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.600]                 }
[10:30:48.600]                 if (length(args) > 0) 
[10:30:48.600]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.600]             }
[10:30:48.600]             else {
[10:30:48.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.600]             }
[10:30:48.600]             {
[10:30:48.600]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.600]                   0L) {
[10:30:48.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.600]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.600]                   base::options(opts)
[10:30:48.600]                 }
[10:30:48.600]                 {
[10:30:48.600]                   {
[10:30:48.600]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.600]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.600]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.600]                       inherits = FALSE)
[10:30:48.600]                     NULL
[10:30:48.600]                   }
[10:30:48.600]                   options(future.plan = NULL)
[10:30:48.600]                   if (is.na(NA_character_)) 
[10:30:48.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.600]                     .init = FALSE)
[10:30:48.600]                 }
[10:30:48.600]             }
[10:30:48.600]         }
[10:30:48.600]     })
[10:30:48.600]     if (TRUE) {
[10:30:48.600]         base::sink(type = "output", split = FALSE)
[10:30:48.600]         if (TRUE) {
[10:30:48.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.600]         }
[10:30:48.600]         else {
[10:30:48.600]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.600]         }
[10:30:48.600]         base::close(...future.stdout)
[10:30:48.600]         ...future.stdout <- NULL
[10:30:48.600]     }
[10:30:48.600]     ...future.result$conditions <- ...future.conditions
[10:30:48.600]     ...future.result$finished <- base::Sys.time()
[10:30:48.600]     ...future.result
[10:30:48.600] }
[10:30:48.602] assign_globals() ...
[10:30:48.602] List of 5
[10:30:48.602]  $ ...future.FUN            :function (C, k)  
[10:30:48.602]  $ MoreArgs                 : list()
[10:30:48.602]  $ ...future.elements_ii    :List of 2
[10:30:48.602]   ..$ :List of 5
[10:30:48.602]   .. ..$ : chr "A"
[10:30:48.602]   .. ..$ : chr "B"
[10:30:48.602]   .. ..$ : chr "C"
[10:30:48.602]   .. ..$ : chr "D"
[10:30:48.602]   .. ..$ : chr "E"
[10:30:48.602]   ..$ :List of 5
[10:30:48.602]   .. ..$ : int 5
[10:30:48.602]   .. ..$ : int 4
[10:30:48.602]   .. ..$ : int 3
[10:30:48.602]   .. ..$ : int 2
[10:30:48.602]   .. ..$ : int 1
[10:30:48.602]  $ ...future.seeds_ii       : NULL
[10:30:48.602]  $ ...future.globals.maxSize: NULL
[10:30:48.602]  - attr(*, "where")=List of 5
[10:30:48.602]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.602]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.602]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.602]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.602]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.602]  - attr(*, "resolved")= logi FALSE
[10:30:48.602]  - attr(*, "total_size")= num 4160
[10:30:48.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.602]  - attr(*, "already-done")= logi TRUE
[10:30:48.609] - reassign environment for ‘...future.FUN’
[10:30:48.610] - copied ‘...future.FUN’ to environment
[10:30:48.610] - copied ‘MoreArgs’ to environment
[10:30:48.610] - copied ‘...future.elements_ii’ to environment
[10:30:48.610] - copied ‘...future.seeds_ii’ to environment
[10:30:48.610] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.610] assign_globals() ... done
[10:30:48.610] plan(): Setting new future strategy stack:
[10:30:48.610] List of future strategies:
[10:30:48.610] 1. sequential:
[10:30:48.610]    - args: function (..., envir = parent.frame())
[10:30:48.610]    - tweaked: FALSE
[10:30:48.610]    - call: NULL
[10:30:48.611] plan(): nbrOfWorkers() = 1
[10:30:48.612] plan(): Setting new future strategy stack:
[10:30:48.612] List of future strategies:
[10:30:48.612] 1. sequential:
[10:30:48.612]    - args: function (..., envir = parent.frame())
[10:30:48.612]    - tweaked: FALSE
[10:30:48.612]    - call: plan(strategy)
[10:30:48.612] plan(): nbrOfWorkers() = 1
[10:30:48.612] SequentialFuture started (and completed)
[10:30:48.612] - Launch lazy future ... done
[10:30:48.612] run() for ‘SequentialFuture’ ... done
[10:30:48.613] Created future:
[10:30:48.613] SequentialFuture:
[10:30:48.613] Label: ‘future_.mapply-1’
[10:30:48.613] Expression:
[10:30:48.613] {
[10:30:48.613]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.613]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.613]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.613]         on.exit(options(oopts), add = TRUE)
[10:30:48.613]     }
[10:30:48.613]     {
[10:30:48.613]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.613]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.613]         do.call(mapply, args = args)
[10:30:48.613]     }
[10:30:48.613] }
[10:30:48.613] Lazy evaluation: FALSE
[10:30:48.613] Asynchronous evaluation: FALSE
[10:30:48.613] Local evaluation: TRUE
[10:30:48.613] Environment: R_GlobalEnv
[10:30:48.613] Capture standard output: TRUE
[10:30:48.613] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.613] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.613] Packages: <none>
[10:30:48.613] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.613] Resolved: TRUE
[10:30:48.613] Value: 560 bytes of class ‘list’
[10:30:48.613] Early signaling: FALSE
[10:30:48.613] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.613] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.614] Chunk #1 of 1 ... DONE
[10:30:48.614] Launching 1 futures (chunks) ... DONE
[10:30:48.614] Resolving 1 futures (chunks) ...
[10:30:48.614] resolve() on list ...
[10:30:48.614]  recursive: 0
[10:30:48.614]  length: 1
[10:30:48.614] 
[10:30:48.614] resolved() for ‘SequentialFuture’ ...
[10:30:48.614] - state: ‘finished’
[10:30:48.615] - run: TRUE
[10:30:48.615] - result: ‘FutureResult’
[10:30:48.615] resolved() for ‘SequentialFuture’ ... done
[10:30:48.615] Future #1
[10:30:48.615] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.615] - nx: 1
[10:30:48.615] - relay: TRUE
[10:30:48.615] - stdout: TRUE
[10:30:48.615] - signal: TRUE
[10:30:48.615] - resignal: FALSE
[10:30:48.616] - force: TRUE
[10:30:48.616] - relayed: [n=1] FALSE
[10:30:48.616] - queued futures: [n=1] FALSE
[10:30:48.616]  - until=1
[10:30:48.616]  - relaying element #1
[10:30:48.616] - relayed: [n=1] TRUE
[10:30:48.616] - queued futures: [n=1] TRUE
[10:30:48.616] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.616]  length: 0 (resolved future 1)
[10:30:48.616] Relaying remaining futures
[10:30:48.617] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.617] - nx: 1
[10:30:48.617] - relay: TRUE
[10:30:48.617] - stdout: TRUE
[10:30:48.617] - signal: TRUE
[10:30:48.617] - resignal: FALSE
[10:30:48.617] - force: TRUE
[10:30:48.617] - relayed: [n=1] TRUE
[10:30:48.617] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.617] - relayed: [n=1] TRUE
[10:30:48.617] - queued futures: [n=1] TRUE
[10:30:48.618] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.618] resolve() on list ... DONE
[10:30:48.618]  - Number of value chunks collected: 1
[10:30:48.618] Resolving 1 futures (chunks) ... DONE
[10:30:48.618] Reducing values from 1 chunks ...
[10:30:48.618]  - Number of values collected after concatenation: 5
[10:30:48.618]  - Number of values expected: 5
[10:30:48.618] Reducing values from 1 chunks ... DONE
[10:30:48.618] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[10:30:48.619] future_mapply() ...
[10:30:48.619] Number of chunks: 1
[10:30:48.619] getGlobalsAndPackagesXApply() ...
[10:30:48.619]  - future.globals: TRUE
[10:30:48.619] getGlobalsAndPackages() ...
[10:30:48.619] Searching for globals...
[10:30:48.621] - globals found: [1] ‘FUN’
[10:30:48.621] Searching for globals ... DONE
[10:30:48.621] Resolving globals: FALSE
[10:30:48.623] The total size of the 1 globals is 848 bytes (848 bytes)
[10:30:48.624] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:30:48.624] - globals: [1] ‘FUN’
[10:30:48.624] 
[10:30:48.624] getGlobalsAndPackages() ... DONE
[10:30:48.624]  - globals found/used: [n=1] ‘FUN’
[10:30:48.624]  - needed namespaces: [n=0] 
[10:30:48.624] Finding globals ... DONE
[10:30:48.625] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.625] List of 2
[10:30:48.625]  $ ...future.FUN:function (x)  
[10:30:48.625]  $ MoreArgs     : NULL
[10:30:48.625]  - attr(*, "where")=List of 2
[10:30:48.625]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.625]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.625]  - attr(*, "resolved")= logi FALSE
[10:30:48.625]  - attr(*, "total_size")= num NA
[10:30:48.627] Packages to be attached in all futures: [n=0] 
[10:30:48.628] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.628] Number of futures (= number of chunks): 1
[10:30:48.628] Launching 1 futures (chunks) ...
[10:30:48.628] Chunk #1 of 1 ...
[10:30:48.628]  - Finding globals in '...' for chunk #1 ...
[10:30:48.628] getGlobalsAndPackages() ...
[10:30:48.628] Searching for globals...
[10:30:48.629] 
[10:30:48.629] Searching for globals ... DONE
[10:30:48.629] - globals: [0] <none>
[10:30:48.629] getGlobalsAndPackages() ... DONE
[10:30:48.629]    + additional globals found: [n=0] 
[10:30:48.629]    + additional namespaces needed: [n=0] 
[10:30:48.629]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.629]  - seeds: <none>
[10:30:48.629]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.629] getGlobalsAndPackages() ...
[10:30:48.630] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.630] Resolving globals: FALSE
[10:30:48.630] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[10:30:48.631] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.631] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.631] 
[10:30:48.631] getGlobalsAndPackages() ... DONE
[10:30:48.631] run() for ‘Future’ ...
[10:30:48.631] - state: ‘created’
[10:30:48.631] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.632] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.632]   - Field: ‘label’
[10:30:48.632]   - Field: ‘local’
[10:30:48.632]   - Field: ‘owner’
[10:30:48.632]   - Field: ‘envir’
[10:30:48.632]   - Field: ‘packages’
[10:30:48.633]   - Field: ‘gc’
[10:30:48.633]   - Field: ‘conditions’
[10:30:48.633]   - Field: ‘expr’
[10:30:48.633]   - Field: ‘uuid’
[10:30:48.633]   - Field: ‘seed’
[10:30:48.633]   - Field: ‘version’
[10:30:48.633]   - Field: ‘result’
[10:30:48.633]   - Field: ‘asynchronous’
[10:30:48.633]   - Field: ‘calls’
[10:30:48.633]   - Field: ‘globals’
[10:30:48.633]   - Field: ‘stdout’
[10:30:48.634]   - Field: ‘earlySignal’
[10:30:48.634]   - Field: ‘lazy’
[10:30:48.634]   - Field: ‘state’
[10:30:48.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.634] - Launch lazy future ...
[10:30:48.634] Packages needed by the future expression (n = 0): <none>
[10:30:48.634] Packages needed by future strategies (n = 0): <none>
[10:30:48.635] {
[10:30:48.635]     {
[10:30:48.635]         {
[10:30:48.635]             ...future.startTime <- base::Sys.time()
[10:30:48.635]             {
[10:30:48.635]                 {
[10:30:48.635]                   {
[10:30:48.635]                     base::local({
[10:30:48.635]                       has_future <- base::requireNamespace("future", 
[10:30:48.635]                         quietly = TRUE)
[10:30:48.635]                       if (has_future) {
[10:30:48.635]                         ns <- base::getNamespace("future")
[10:30:48.635]                         version <- ns[[".package"]][["version"]]
[10:30:48.635]                         if (is.null(version)) 
[10:30:48.635]                           version <- utils::packageVersion("future")
[10:30:48.635]                       }
[10:30:48.635]                       else {
[10:30:48.635]                         version <- NULL
[10:30:48.635]                       }
[10:30:48.635]                       if (!has_future || version < "1.8.0") {
[10:30:48.635]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.635]                           "", base::R.version$version.string), 
[10:30:48.635]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.635]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.635]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.635]                             "release", "version")], collapse = " "), 
[10:30:48.635]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.635]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.635]                           info)
[10:30:48.635]                         info <- base::paste(info, collapse = "; ")
[10:30:48.635]                         if (!has_future) {
[10:30:48.635]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.635]                             info)
[10:30:48.635]                         }
[10:30:48.635]                         else {
[10:30:48.635]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.635]                             info, version)
[10:30:48.635]                         }
[10:30:48.635]                         base::stop(msg)
[10:30:48.635]                       }
[10:30:48.635]                     })
[10:30:48.635]                   }
[10:30:48.635]                   ...future.strategy.old <- future::plan("list")
[10:30:48.635]                   options(future.plan = NULL)
[10:30:48.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.635]                 }
[10:30:48.635]                 ...future.workdir <- getwd()
[10:30:48.635]             }
[10:30:48.635]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.635]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.635]         }
[10:30:48.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.635]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.635]             base::names(...future.oldOptions))
[10:30:48.635]     }
[10:30:48.635]     if (FALSE) {
[10:30:48.635]     }
[10:30:48.635]     else {
[10:30:48.635]         if (TRUE) {
[10:30:48.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.635]                 open = "w")
[10:30:48.635]         }
[10:30:48.635]         else {
[10:30:48.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.635]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.635]         }
[10:30:48.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.635]             base::sink(type = "output", split = FALSE)
[10:30:48.635]             base::close(...future.stdout)
[10:30:48.635]         }, add = TRUE)
[10:30:48.635]     }
[10:30:48.635]     ...future.frame <- base::sys.nframe()
[10:30:48.635]     ...future.conditions <- base::list()
[10:30:48.635]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.635]     if (FALSE) {
[10:30:48.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.635]     }
[10:30:48.635]     ...future.result <- base::tryCatch({
[10:30:48.635]         base::withCallingHandlers({
[10:30:48.635]             ...future.value <- base::withVisible(base::local({
[10:30:48.635]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.635]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.635]                   ...future.globals.maxSize)) {
[10:30:48.635]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.635]                   on.exit(options(oopts), add = TRUE)
[10:30:48.635]                 }
[10:30:48.635]                 {
[10:30:48.635]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.635]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.635]                     USE.NAMES = FALSE)
[10:30:48.635]                   do.call(mapply, args = args)
[10:30:48.635]                 }
[10:30:48.635]             }))
[10:30:48.635]             future::FutureResult(value = ...future.value$value, 
[10:30:48.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.635]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.635]                     ...future.globalenv.names))
[10:30:48.635]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.635]         }, condition = base::local({
[10:30:48.635]             c <- base::c
[10:30:48.635]             inherits <- base::inherits
[10:30:48.635]             invokeRestart <- base::invokeRestart
[10:30:48.635]             length <- base::length
[10:30:48.635]             list <- base::list
[10:30:48.635]             seq.int <- base::seq.int
[10:30:48.635]             signalCondition <- base::signalCondition
[10:30:48.635]             sys.calls <- base::sys.calls
[10:30:48.635]             `[[` <- base::`[[`
[10:30:48.635]             `+` <- base::`+`
[10:30:48.635]             `<<-` <- base::`<<-`
[10:30:48.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.635]                   3L)]
[10:30:48.635]             }
[10:30:48.635]             function(cond) {
[10:30:48.635]                 is_error <- inherits(cond, "error")
[10:30:48.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.635]                   NULL)
[10:30:48.635]                 if (is_error) {
[10:30:48.635]                   sessionInformation <- function() {
[10:30:48.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.635]                       search = base::search(), system = base::Sys.info())
[10:30:48.635]                   }
[10:30:48.635]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.635]                     cond$call), session = sessionInformation(), 
[10:30:48.635]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.635]                   signalCondition(cond)
[10:30:48.635]                 }
[10:30:48.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.635]                 "immediateCondition"))) {
[10:30:48.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.635]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.635]                   if (TRUE && !signal) {
[10:30:48.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.635]                     {
[10:30:48.635]                       inherits <- base::inherits
[10:30:48.635]                       invokeRestart <- base::invokeRestart
[10:30:48.635]                       is.null <- base::is.null
[10:30:48.635]                       muffled <- FALSE
[10:30:48.635]                       if (inherits(cond, "message")) {
[10:30:48.635]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.635]                         if (muffled) 
[10:30:48.635]                           invokeRestart("muffleMessage")
[10:30:48.635]                       }
[10:30:48.635]                       else if (inherits(cond, "warning")) {
[10:30:48.635]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.635]                         if (muffled) 
[10:30:48.635]                           invokeRestart("muffleWarning")
[10:30:48.635]                       }
[10:30:48.635]                       else if (inherits(cond, "condition")) {
[10:30:48.635]                         if (!is.null(pattern)) {
[10:30:48.635]                           computeRestarts <- base::computeRestarts
[10:30:48.635]                           grepl <- base::grepl
[10:30:48.635]                           restarts <- computeRestarts(cond)
[10:30:48.635]                           for (restart in restarts) {
[10:30:48.635]                             name <- restart$name
[10:30:48.635]                             if (is.null(name)) 
[10:30:48.635]                               next
[10:30:48.635]                             if (!grepl(pattern, name)) 
[10:30:48.635]                               next
[10:30:48.635]                             invokeRestart(restart)
[10:30:48.635]                             muffled <- TRUE
[10:30:48.635]                             break
[10:30:48.635]                           }
[10:30:48.635]                         }
[10:30:48.635]                       }
[10:30:48.635]                       invisible(muffled)
[10:30:48.635]                     }
[10:30:48.635]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.635]                   }
[10:30:48.635]                 }
[10:30:48.635]                 else {
[10:30:48.635]                   if (TRUE) {
[10:30:48.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.635]                     {
[10:30:48.635]                       inherits <- base::inherits
[10:30:48.635]                       invokeRestart <- base::invokeRestart
[10:30:48.635]                       is.null <- base::is.null
[10:30:48.635]                       muffled <- FALSE
[10:30:48.635]                       if (inherits(cond, "message")) {
[10:30:48.635]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.635]                         if (muffled) 
[10:30:48.635]                           invokeRestart("muffleMessage")
[10:30:48.635]                       }
[10:30:48.635]                       else if (inherits(cond, "warning")) {
[10:30:48.635]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.635]                         if (muffled) 
[10:30:48.635]                           invokeRestart("muffleWarning")
[10:30:48.635]                       }
[10:30:48.635]                       else if (inherits(cond, "condition")) {
[10:30:48.635]                         if (!is.null(pattern)) {
[10:30:48.635]                           computeRestarts <- base::computeRestarts
[10:30:48.635]                           grepl <- base::grepl
[10:30:48.635]                           restarts <- computeRestarts(cond)
[10:30:48.635]                           for (restart in restarts) {
[10:30:48.635]                             name <- restart$name
[10:30:48.635]                             if (is.null(name)) 
[10:30:48.635]                               next
[10:30:48.635]                             if (!grepl(pattern, name)) 
[10:30:48.635]                               next
[10:30:48.635]                             invokeRestart(restart)
[10:30:48.635]                             muffled <- TRUE
[10:30:48.635]                             break
[10:30:48.635]                           }
[10:30:48.635]                         }
[10:30:48.635]                       }
[10:30:48.635]                       invisible(muffled)
[10:30:48.635]                     }
[10:30:48.635]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.635]                   }
[10:30:48.635]                 }
[10:30:48.635]             }
[10:30:48.635]         }))
[10:30:48.635]     }, error = function(ex) {
[10:30:48.635]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.635]                 ...future.rng), started = ...future.startTime, 
[10:30:48.635]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.635]             version = "1.8"), class = "FutureResult")
[10:30:48.635]     }, finally = {
[10:30:48.635]         if (!identical(...future.workdir, getwd())) 
[10:30:48.635]             setwd(...future.workdir)
[10:30:48.635]         {
[10:30:48.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.635]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.635]             }
[10:30:48.635]             base::options(...future.oldOptions)
[10:30:48.635]             if (.Platform$OS.type == "windows") {
[10:30:48.635]                 old_names <- names(...future.oldEnvVars)
[10:30:48.635]                 envs <- base::Sys.getenv()
[10:30:48.635]                 names <- names(envs)
[10:30:48.635]                 common <- intersect(names, old_names)
[10:30:48.635]                 added <- setdiff(names, old_names)
[10:30:48.635]                 removed <- setdiff(old_names, names)
[10:30:48.635]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.635]                   envs[common]]
[10:30:48.635]                 NAMES <- toupper(changed)
[10:30:48.635]                 args <- list()
[10:30:48.635]                 for (kk in seq_along(NAMES)) {
[10:30:48.635]                   name <- changed[[kk]]
[10:30:48.635]                   NAME <- NAMES[[kk]]
[10:30:48.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.635]                     next
[10:30:48.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.635]                 }
[10:30:48.635]                 NAMES <- toupper(added)
[10:30:48.635]                 for (kk in seq_along(NAMES)) {
[10:30:48.635]                   name <- added[[kk]]
[10:30:48.635]                   NAME <- NAMES[[kk]]
[10:30:48.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.635]                     next
[10:30:48.635]                   args[[name]] <- ""
[10:30:48.635]                 }
[10:30:48.635]                 NAMES <- toupper(removed)
[10:30:48.635]                 for (kk in seq_along(NAMES)) {
[10:30:48.635]                   name <- removed[[kk]]
[10:30:48.635]                   NAME <- NAMES[[kk]]
[10:30:48.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.635]                     next
[10:30:48.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.635]                 }
[10:30:48.635]                 if (length(args) > 0) 
[10:30:48.635]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.635]             }
[10:30:48.635]             else {
[10:30:48.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.635]             }
[10:30:48.635]             {
[10:30:48.635]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.635]                   0L) {
[10:30:48.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.635]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.635]                   base::options(opts)
[10:30:48.635]                 }
[10:30:48.635]                 {
[10:30:48.635]                   {
[10:30:48.635]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.635]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.635]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.635]                       inherits = FALSE)
[10:30:48.635]                     NULL
[10:30:48.635]                   }
[10:30:48.635]                   options(future.plan = NULL)
[10:30:48.635]                   if (is.na(NA_character_)) 
[10:30:48.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.635]                     .init = FALSE)
[10:30:48.635]                 }
[10:30:48.635]             }
[10:30:48.635]         }
[10:30:48.635]     })
[10:30:48.635]     if (TRUE) {
[10:30:48.635]         base::sink(type = "output", split = FALSE)
[10:30:48.635]         if (TRUE) {
[10:30:48.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.635]         }
[10:30:48.635]         else {
[10:30:48.635]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.635]         }
[10:30:48.635]         base::close(...future.stdout)
[10:30:48.635]         ...future.stdout <- NULL
[10:30:48.635]     }
[10:30:48.635]     ...future.result$conditions <- ...future.conditions
[10:30:48.635]     ...future.result$finished <- base::Sys.time()
[10:30:48.635]     ...future.result
[10:30:48.635] }
[10:30:48.636] assign_globals() ...
[10:30:48.636] List of 5
[10:30:48.636]  $ ...future.FUN            :function (x)  
[10:30:48.636]  $ MoreArgs                 : NULL
[10:30:48.636]  $ ...future.elements_ii    :List of 1
[10:30:48.636]   ..$ :List of 1
[10:30:48.636]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:30:48.636]  $ ...future.seeds_ii       : NULL
[10:30:48.636]  $ ...future.globals.maxSize: NULL
[10:30:48.636]  - attr(*, "where")=List of 5
[10:30:48.636]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.636]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.636]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.636]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.636]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.636]  - attr(*, "resolved")= logi FALSE
[10:30:48.636]  - attr(*, "total_size")= num 1128
[10:30:48.636]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.636]  - attr(*, "already-done")= logi TRUE
[10:30:48.641] - copied ‘...future.FUN’ to environment
[10:30:48.641] - copied ‘MoreArgs’ to environment
[10:30:48.641] - copied ‘...future.elements_ii’ to environment
[10:30:48.642] - copied ‘...future.seeds_ii’ to environment
[10:30:48.642] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.642] assign_globals() ... done
[10:30:48.642] plan(): Setting new future strategy stack:
[10:30:48.642] List of future strategies:
[10:30:48.642] 1. sequential:
[10:30:48.642]    - args: function (..., envir = parent.frame())
[10:30:48.642]    - tweaked: FALSE
[10:30:48.642]    - call: NULL
[10:30:48.642] plan(): nbrOfWorkers() = 1
[10:30:48.643] plan(): Setting new future strategy stack:
[10:30:48.643] List of future strategies:
[10:30:48.643] 1. sequential:
[10:30:48.643]    - args: function (..., envir = parent.frame())
[10:30:48.643]    - tweaked: FALSE
[10:30:48.643]    - call: plan(strategy)
[10:30:48.644] plan(): nbrOfWorkers() = 1
[10:30:48.644] SequentialFuture started (and completed)
[10:30:48.644] - Launch lazy future ... done
[10:30:48.644] run() for ‘SequentialFuture’ ... done
[10:30:48.644] Created future:
[10:30:48.644] SequentialFuture:
[10:30:48.644] Label: ‘future_mapply-1’
[10:30:48.644] Expression:
[10:30:48.644] {
[10:30:48.644]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.644]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.644]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.644]         on.exit(options(oopts), add = TRUE)
[10:30:48.644]     }
[10:30:48.644]     {
[10:30:48.644]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.644]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.644]         do.call(mapply, args = args)
[10:30:48.644]     }
[10:30:48.644] }
[10:30:48.644] Lazy evaluation: FALSE
[10:30:48.644] Asynchronous evaluation: FALSE
[10:30:48.644] Local evaluation: TRUE
[10:30:48.644] Environment: R_GlobalEnv
[10:30:48.644] Capture standard output: TRUE
[10:30:48.644] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.644] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.644] Packages: <none>
[10:30:48.644] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.644] Resolved: TRUE
[10:30:48.644] Value: 280 bytes of class ‘list’
[10:30:48.644] Early signaling: FALSE
[10:30:48.644] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.644] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.645] Chunk #1 of 1 ... DONE
[10:30:48.645] Launching 1 futures (chunks) ... DONE
[10:30:48.645] Resolving 1 futures (chunks) ...
[10:30:48.646] resolve() on list ...
[10:30:48.646]  recursive: 0
[10:30:48.646]  length: 1
[10:30:48.646] 
[10:30:48.646] resolved() for ‘SequentialFuture’ ...
[10:30:48.646] - state: ‘finished’
[10:30:48.646] - run: TRUE
[10:30:48.646] - result: ‘FutureResult’
[10:30:48.646] resolved() for ‘SequentialFuture’ ... done
[10:30:48.646] Future #1
[10:30:48.647] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.647] - nx: 1
[10:30:48.647] - relay: TRUE
[10:30:48.649] - stdout: TRUE
[10:30:48.649] - signal: TRUE
[10:30:48.649] - resignal: FALSE
[10:30:48.649] - force: TRUE
[10:30:48.649] - relayed: [n=1] FALSE
[10:30:48.649] - queued futures: [n=1] FALSE
[10:30:48.649]  - until=1
[10:30:48.649]  - relaying element #1
[10:30:48.650] - relayed: [n=1] TRUE
[10:30:48.650] - queued futures: [n=1] TRUE
[10:30:48.650] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.650]  length: 0 (resolved future 1)
[10:30:48.650] Relaying remaining futures
[10:30:48.650] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.650] - nx: 1
[10:30:48.651] - relay: TRUE
[10:30:48.651] - stdout: TRUE
[10:30:48.651] - signal: TRUE
[10:30:48.651] - resignal: FALSE
[10:30:48.651] - force: TRUE
[10:30:48.651] - relayed: [n=1] TRUE
[10:30:48.651] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.651] - relayed: [n=1] TRUE
[10:30:48.651] - queued futures: [n=1] TRUE
[10:30:48.651] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.651] resolve() on list ... DONE
[10:30:48.652]  - Number of value chunks collected: 1
[10:30:48.652] Resolving 1 futures (chunks) ... DONE
[10:30:48.652] Reducing values from 1 chunks ...
[10:30:48.652]  - Number of values collected after concatenation: 1
[10:30:48.652]  - Number of values expected: 1
[10:30:48.652] Reducing values from 1 chunks ... DONE
[10:30:48.652] future_mapply() ... DONE
[10:30:48.652] future_mapply() ...
[10:30:48.653] Number of chunks: 1
[10:30:48.653] getGlobalsAndPackagesXApply() ...
[10:30:48.653]  - future.globals: TRUE
[10:30:48.653] getGlobalsAndPackages() ...
[10:30:48.653] Searching for globals...
[10:30:48.654] - globals found: [1] ‘FUN’
[10:30:48.654] Searching for globals ... DONE
[10:30:48.654] Resolving globals: FALSE
[10:30:48.655] The total size of the 1 globals is 848 bytes (848 bytes)
[10:30:48.655] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:30:48.655] - globals: [1] ‘FUN’
[10:30:48.655] 
[10:30:48.655] getGlobalsAndPackages() ... DONE
[10:30:48.655]  - globals found/used: [n=1] ‘FUN’
[10:30:48.655]  - needed namespaces: [n=0] 
[10:30:48.656] Finding globals ... DONE
[10:30:48.656] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.656] List of 2
[10:30:48.656]  $ ...future.FUN:function (x)  
[10:30:48.656]  $ MoreArgs     : list()
[10:30:48.656]  - attr(*, "where")=List of 2
[10:30:48.656]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.656]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.656]  - attr(*, "resolved")= logi FALSE
[10:30:48.656]  - attr(*, "total_size")= num NA
[10:30:48.658] Packages to be attached in all futures: [n=0] 
[10:30:48.659] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.659] Number of futures (= number of chunks): 1
[10:30:48.659] Launching 1 futures (chunks) ...
[10:30:48.659] Chunk #1 of 1 ...
[10:30:48.659]  - Finding globals in '...' for chunk #1 ...
[10:30:48.659] getGlobalsAndPackages() ...
[10:30:48.659] Searching for globals...
[10:30:48.660] 
[10:30:48.660] Searching for globals ... DONE
[10:30:48.660] - globals: [0] <none>
[10:30:48.660] getGlobalsAndPackages() ... DONE
[10:30:48.660]    + additional globals found: [n=0] 
[10:30:48.660]    + additional namespaces needed: [n=0] 
[10:30:48.660]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.660]  - seeds: <none>
[10:30:48.660]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.660] getGlobalsAndPackages() ...
[10:30:48.660] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.661] Resolving globals: FALSE
[10:30:48.661] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[10:30:48.661] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:48.662] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.662] 
[10:30:48.662] getGlobalsAndPackages() ... DONE
[10:30:48.662] run() for ‘Future’ ...
[10:30:48.662] - state: ‘created’
[10:30:48.662] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.663] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.663] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.663]   - Field: ‘label’
[10:30:48.663]   - Field: ‘local’
[10:30:48.663]   - Field: ‘owner’
[10:30:48.663]   - Field: ‘envir’
[10:30:48.663]   - Field: ‘packages’
[10:30:48.663]   - Field: ‘gc’
[10:30:48.663]   - Field: ‘conditions’
[10:30:48.664]   - Field: ‘expr’
[10:30:48.664]   - Field: ‘uuid’
[10:30:48.664]   - Field: ‘seed’
[10:30:48.664]   - Field: ‘version’
[10:30:48.664]   - Field: ‘result’
[10:30:48.664]   - Field: ‘asynchronous’
[10:30:48.664]   - Field: ‘calls’
[10:30:48.664]   - Field: ‘globals’
[10:30:48.664]   - Field: ‘stdout’
[10:30:48.664]   - Field: ‘earlySignal’
[10:30:48.664]   - Field: ‘lazy’
[10:30:48.665]   - Field: ‘state’
[10:30:48.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.665] - Launch lazy future ...
[10:30:48.665] Packages needed by the future expression (n = 0): <none>
[10:30:48.665] Packages needed by future strategies (n = 0): <none>
[10:30:48.665] {
[10:30:48.665]     {
[10:30:48.665]         {
[10:30:48.665]             ...future.startTime <- base::Sys.time()
[10:30:48.665]             {
[10:30:48.665]                 {
[10:30:48.665]                   {
[10:30:48.665]                     base::local({
[10:30:48.665]                       has_future <- base::requireNamespace("future", 
[10:30:48.665]                         quietly = TRUE)
[10:30:48.665]                       if (has_future) {
[10:30:48.665]                         ns <- base::getNamespace("future")
[10:30:48.665]                         version <- ns[[".package"]][["version"]]
[10:30:48.665]                         if (is.null(version)) 
[10:30:48.665]                           version <- utils::packageVersion("future")
[10:30:48.665]                       }
[10:30:48.665]                       else {
[10:30:48.665]                         version <- NULL
[10:30:48.665]                       }
[10:30:48.665]                       if (!has_future || version < "1.8.0") {
[10:30:48.665]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.665]                           "", base::R.version$version.string), 
[10:30:48.665]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.665]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.665]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.665]                             "release", "version")], collapse = " "), 
[10:30:48.665]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.665]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.665]                           info)
[10:30:48.665]                         info <- base::paste(info, collapse = "; ")
[10:30:48.665]                         if (!has_future) {
[10:30:48.665]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.665]                             info)
[10:30:48.665]                         }
[10:30:48.665]                         else {
[10:30:48.665]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.665]                             info, version)
[10:30:48.665]                         }
[10:30:48.665]                         base::stop(msg)
[10:30:48.665]                       }
[10:30:48.665]                     })
[10:30:48.665]                   }
[10:30:48.665]                   ...future.strategy.old <- future::plan("list")
[10:30:48.665]                   options(future.plan = NULL)
[10:30:48.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.665]                 }
[10:30:48.665]                 ...future.workdir <- getwd()
[10:30:48.665]             }
[10:30:48.665]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.665]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.665]         }
[10:30:48.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.665]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.665]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.665]             base::names(...future.oldOptions))
[10:30:48.665]     }
[10:30:48.665]     if (FALSE) {
[10:30:48.665]     }
[10:30:48.665]     else {
[10:30:48.665]         if (TRUE) {
[10:30:48.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.665]                 open = "w")
[10:30:48.665]         }
[10:30:48.665]         else {
[10:30:48.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.665]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.665]         }
[10:30:48.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.665]             base::sink(type = "output", split = FALSE)
[10:30:48.665]             base::close(...future.stdout)
[10:30:48.665]         }, add = TRUE)
[10:30:48.665]     }
[10:30:48.665]     ...future.frame <- base::sys.nframe()
[10:30:48.665]     ...future.conditions <- base::list()
[10:30:48.665]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.665]     if (FALSE) {
[10:30:48.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.665]     }
[10:30:48.665]     ...future.result <- base::tryCatch({
[10:30:48.665]         base::withCallingHandlers({
[10:30:48.665]             ...future.value <- base::withVisible(base::local({
[10:30:48.665]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.665]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.665]                   ...future.globals.maxSize)) {
[10:30:48.665]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.665]                   on.exit(options(oopts), add = TRUE)
[10:30:48.665]                 }
[10:30:48.665]                 {
[10:30:48.665]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.665]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.665]                     USE.NAMES = FALSE)
[10:30:48.665]                   do.call(mapply, args = args)
[10:30:48.665]                 }
[10:30:48.665]             }))
[10:30:48.665]             future::FutureResult(value = ...future.value$value, 
[10:30:48.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.665]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.665]                     ...future.globalenv.names))
[10:30:48.665]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.665]         }, condition = base::local({
[10:30:48.665]             c <- base::c
[10:30:48.665]             inherits <- base::inherits
[10:30:48.665]             invokeRestart <- base::invokeRestart
[10:30:48.665]             length <- base::length
[10:30:48.665]             list <- base::list
[10:30:48.665]             seq.int <- base::seq.int
[10:30:48.665]             signalCondition <- base::signalCondition
[10:30:48.665]             sys.calls <- base::sys.calls
[10:30:48.665]             `[[` <- base::`[[`
[10:30:48.665]             `+` <- base::`+`
[10:30:48.665]             `<<-` <- base::`<<-`
[10:30:48.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.665]                   3L)]
[10:30:48.665]             }
[10:30:48.665]             function(cond) {
[10:30:48.665]                 is_error <- inherits(cond, "error")
[10:30:48.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.665]                   NULL)
[10:30:48.665]                 if (is_error) {
[10:30:48.665]                   sessionInformation <- function() {
[10:30:48.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.665]                       search = base::search(), system = base::Sys.info())
[10:30:48.665]                   }
[10:30:48.665]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.665]                     cond$call), session = sessionInformation(), 
[10:30:48.665]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.665]                   signalCondition(cond)
[10:30:48.665]                 }
[10:30:48.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.665]                 "immediateCondition"))) {
[10:30:48.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.665]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.665]                   if (TRUE && !signal) {
[10:30:48.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.665]                     {
[10:30:48.665]                       inherits <- base::inherits
[10:30:48.665]                       invokeRestart <- base::invokeRestart
[10:30:48.665]                       is.null <- base::is.null
[10:30:48.665]                       muffled <- FALSE
[10:30:48.665]                       if (inherits(cond, "message")) {
[10:30:48.665]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.665]                         if (muffled) 
[10:30:48.665]                           invokeRestart("muffleMessage")
[10:30:48.665]                       }
[10:30:48.665]                       else if (inherits(cond, "warning")) {
[10:30:48.665]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.665]                         if (muffled) 
[10:30:48.665]                           invokeRestart("muffleWarning")
[10:30:48.665]                       }
[10:30:48.665]                       else if (inherits(cond, "condition")) {
[10:30:48.665]                         if (!is.null(pattern)) {
[10:30:48.665]                           computeRestarts <- base::computeRestarts
[10:30:48.665]                           grepl <- base::grepl
[10:30:48.665]                           restarts <- computeRestarts(cond)
[10:30:48.665]                           for (restart in restarts) {
[10:30:48.665]                             name <- restart$name
[10:30:48.665]                             if (is.null(name)) 
[10:30:48.665]                               next
[10:30:48.665]                             if (!grepl(pattern, name)) 
[10:30:48.665]                               next
[10:30:48.665]                             invokeRestart(restart)
[10:30:48.665]                             muffled <- TRUE
[10:30:48.665]                             break
[10:30:48.665]                           }
[10:30:48.665]                         }
[10:30:48.665]                       }
[10:30:48.665]                       invisible(muffled)
[10:30:48.665]                     }
[10:30:48.665]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.665]                   }
[10:30:48.665]                 }
[10:30:48.665]                 else {
[10:30:48.665]                   if (TRUE) {
[10:30:48.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.665]                     {
[10:30:48.665]                       inherits <- base::inherits
[10:30:48.665]                       invokeRestart <- base::invokeRestart
[10:30:48.665]                       is.null <- base::is.null
[10:30:48.665]                       muffled <- FALSE
[10:30:48.665]                       if (inherits(cond, "message")) {
[10:30:48.665]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.665]                         if (muffled) 
[10:30:48.665]                           invokeRestart("muffleMessage")
[10:30:48.665]                       }
[10:30:48.665]                       else if (inherits(cond, "warning")) {
[10:30:48.665]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.665]                         if (muffled) 
[10:30:48.665]                           invokeRestart("muffleWarning")
[10:30:48.665]                       }
[10:30:48.665]                       else if (inherits(cond, "condition")) {
[10:30:48.665]                         if (!is.null(pattern)) {
[10:30:48.665]                           computeRestarts <- base::computeRestarts
[10:30:48.665]                           grepl <- base::grepl
[10:30:48.665]                           restarts <- computeRestarts(cond)
[10:30:48.665]                           for (restart in restarts) {
[10:30:48.665]                             name <- restart$name
[10:30:48.665]                             if (is.null(name)) 
[10:30:48.665]                               next
[10:30:48.665]                             if (!grepl(pattern, name)) 
[10:30:48.665]                               next
[10:30:48.665]                             invokeRestart(restart)
[10:30:48.665]                             muffled <- TRUE
[10:30:48.665]                             break
[10:30:48.665]                           }
[10:30:48.665]                         }
[10:30:48.665]                       }
[10:30:48.665]                       invisible(muffled)
[10:30:48.665]                     }
[10:30:48.665]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.665]                   }
[10:30:48.665]                 }
[10:30:48.665]             }
[10:30:48.665]         }))
[10:30:48.665]     }, error = function(ex) {
[10:30:48.665]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.665]                 ...future.rng), started = ...future.startTime, 
[10:30:48.665]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.665]             version = "1.8"), class = "FutureResult")
[10:30:48.665]     }, finally = {
[10:30:48.665]         if (!identical(...future.workdir, getwd())) 
[10:30:48.665]             setwd(...future.workdir)
[10:30:48.665]         {
[10:30:48.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.665]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.665]             }
[10:30:48.665]             base::options(...future.oldOptions)
[10:30:48.665]             if (.Platform$OS.type == "windows") {
[10:30:48.665]                 old_names <- names(...future.oldEnvVars)
[10:30:48.665]                 envs <- base::Sys.getenv()
[10:30:48.665]                 names <- names(envs)
[10:30:48.665]                 common <- intersect(names, old_names)
[10:30:48.665]                 added <- setdiff(names, old_names)
[10:30:48.665]                 removed <- setdiff(old_names, names)
[10:30:48.665]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.665]                   envs[common]]
[10:30:48.665]                 NAMES <- toupper(changed)
[10:30:48.665]                 args <- list()
[10:30:48.665]                 for (kk in seq_along(NAMES)) {
[10:30:48.665]                   name <- changed[[kk]]
[10:30:48.665]                   NAME <- NAMES[[kk]]
[10:30:48.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.665]                     next
[10:30:48.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.665]                 }
[10:30:48.665]                 NAMES <- toupper(added)
[10:30:48.665]                 for (kk in seq_along(NAMES)) {
[10:30:48.665]                   name <- added[[kk]]
[10:30:48.665]                   NAME <- NAMES[[kk]]
[10:30:48.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.665]                     next
[10:30:48.665]                   args[[name]] <- ""
[10:30:48.665]                 }
[10:30:48.665]                 NAMES <- toupper(removed)
[10:30:48.665]                 for (kk in seq_along(NAMES)) {
[10:30:48.665]                   name <- removed[[kk]]
[10:30:48.665]                   NAME <- NAMES[[kk]]
[10:30:48.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.665]                     next
[10:30:48.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.665]                 }
[10:30:48.665]                 if (length(args) > 0) 
[10:30:48.665]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.665]             }
[10:30:48.665]             else {
[10:30:48.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.665]             }
[10:30:48.665]             {
[10:30:48.665]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.665]                   0L) {
[10:30:48.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.665]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.665]                   base::options(opts)
[10:30:48.665]                 }
[10:30:48.665]                 {
[10:30:48.665]                   {
[10:30:48.665]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.665]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.665]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.665]                       inherits = FALSE)
[10:30:48.665]                     NULL
[10:30:48.665]                   }
[10:30:48.665]                   options(future.plan = NULL)
[10:30:48.665]                   if (is.na(NA_character_)) 
[10:30:48.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.665]                     .init = FALSE)
[10:30:48.665]                 }
[10:30:48.665]             }
[10:30:48.665]         }
[10:30:48.665]     })
[10:30:48.665]     if (TRUE) {
[10:30:48.665]         base::sink(type = "output", split = FALSE)
[10:30:48.665]         if (TRUE) {
[10:30:48.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.665]         }
[10:30:48.665]         else {
[10:30:48.665]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.665]         }
[10:30:48.665]         base::close(...future.stdout)
[10:30:48.665]         ...future.stdout <- NULL
[10:30:48.665]     }
[10:30:48.665]     ...future.result$conditions <- ...future.conditions
[10:30:48.665]     ...future.result$finished <- base::Sys.time()
[10:30:48.665]     ...future.result
[10:30:48.665] }
[10:30:48.667] assign_globals() ...
[10:30:48.667] List of 5
[10:30:48.667]  $ ...future.FUN            :function (x)  
[10:30:48.667]  $ MoreArgs                 : list()
[10:30:48.667]  $ ...future.elements_ii    :List of 1
[10:30:48.667]   ..$ :List of 1
[10:30:48.667]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:30:48.667]  $ ...future.seeds_ii       : NULL
[10:30:48.667]  $ ...future.globals.maxSize: NULL
[10:30:48.667]  - attr(*, "where")=List of 5
[10:30:48.667]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.667]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.667]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.667]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.667]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.667]  - attr(*, "resolved")= logi FALSE
[10:30:48.667]  - attr(*, "total_size")= num 1128
[10:30:48.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.667]  - attr(*, "already-done")= logi TRUE
[10:30:48.674] - copied ‘...future.FUN’ to environment
[10:30:48.674] - copied ‘MoreArgs’ to environment
[10:30:48.674] - copied ‘...future.elements_ii’ to environment
[10:30:48.675] - copied ‘...future.seeds_ii’ to environment
[10:30:48.675] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.675] assign_globals() ... done
[10:30:48.675] plan(): Setting new future strategy stack:
[10:30:48.675] List of future strategies:
[10:30:48.675] 1. sequential:
[10:30:48.675]    - args: function (..., envir = parent.frame())
[10:30:48.675]    - tweaked: FALSE
[10:30:48.675]    - call: NULL
[10:30:48.676] plan(): nbrOfWorkers() = 1
[10:30:48.676] plan(): Setting new future strategy stack:
[10:30:48.676] List of future strategies:
[10:30:48.676] 1. sequential:
[10:30:48.676]    - args: function (..., envir = parent.frame())
[10:30:48.676]    - tweaked: FALSE
[10:30:48.676]    - call: plan(strategy)
[10:30:48.677] plan(): nbrOfWorkers() = 1
[10:30:48.677] SequentialFuture started (and completed)
[10:30:48.677] - Launch lazy future ... done
[10:30:48.677] run() for ‘SequentialFuture’ ... done
[10:30:48.677] Created future:
[10:30:48.678] SequentialFuture:
[10:30:48.678] Label: ‘future_.mapply-1’
[10:30:48.678] Expression:
[10:30:48.678] {
[10:30:48.678]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.678]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.678]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.678]         on.exit(options(oopts), add = TRUE)
[10:30:48.678]     }
[10:30:48.678]     {
[10:30:48.678]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.678]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.678]         do.call(mapply, args = args)
[10:30:48.678]     }
[10:30:48.678] }
[10:30:48.678] Lazy evaluation: FALSE
[10:30:48.678] Asynchronous evaluation: FALSE
[10:30:48.678] Local evaluation: TRUE
[10:30:48.678] Environment: R_GlobalEnv
[10:30:48.678] Capture standard output: TRUE
[10:30:48.678] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.678] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.678] Packages: <none>
[10:30:48.678] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.678] Resolved: TRUE
[10:30:48.678] Value: 280 bytes of class ‘list’
[10:30:48.678] Early signaling: FALSE
[10:30:48.678] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.678] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.678] Chunk #1 of 1 ... DONE
[10:30:48.679] Launching 1 futures (chunks) ... DONE
[10:30:48.679] Resolving 1 futures (chunks) ...
[10:30:48.679] resolve() on list ...
[10:30:48.679]  recursive: 0
[10:30:48.679]  length: 1
[10:30:48.679] 
[10:30:48.679] resolved() for ‘SequentialFuture’ ...
[10:30:48.679] - state: ‘finished’
[10:30:48.679] - run: TRUE
[10:30:48.679] - result: ‘FutureResult’
[10:30:48.679] resolved() for ‘SequentialFuture’ ... done
[10:30:48.680] Future #1
[10:30:48.680] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.680] - nx: 1
[10:30:48.680] - relay: TRUE
[10:30:48.680] - stdout: TRUE
[10:30:48.680] - signal: TRUE
[10:30:48.680] - resignal: FALSE
[10:30:48.680] - force: TRUE
[10:30:48.680] - relayed: [n=1] FALSE
[10:30:48.680] - queued futures: [n=1] FALSE
[10:30:48.681]  - until=1
[10:30:48.681]  - relaying element #1
[10:30:48.681] - relayed: [n=1] TRUE
[10:30:48.681] - queued futures: [n=1] TRUE
[10:30:48.681] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.681]  length: 0 (resolved future 1)
[10:30:48.681] Relaying remaining futures
[10:30:48.681] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.681] - nx: 1
[10:30:48.681] - relay: TRUE
[10:30:48.682] - stdout: TRUE
[10:30:48.682] - signal: TRUE
[10:30:48.682] - resignal: FALSE
[10:30:48.682] - force: TRUE
[10:30:48.682] - relayed: [n=1] TRUE
[10:30:48.682] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.682] - relayed: [n=1] TRUE
[10:30:48.682] - queued futures: [n=1] TRUE
[10:30:48.682] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.682] resolve() on list ... DONE
[10:30:48.683]  - Number of value chunks collected: 1
[10:30:48.683] Resolving 1 futures (chunks) ... DONE
[10:30:48.683] Reducing values from 1 chunks ...
[10:30:48.683]  - Number of values collected after concatenation: 1
[10:30:48.683]  - Number of values expected: 1
[10:30:48.683] Reducing values from 1 chunks ... DONE
[10:30:48.683] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[10:30:48.683] future_mapply() ...
[10:30:48.684] Number of chunks: 1
[10:30:48.684] getGlobalsAndPackagesXApply() ...
[10:30:48.684]  - future.globals: TRUE
[10:30:48.684] getGlobalsAndPackages() ...
[10:30:48.684] Searching for globals...
[10:30:48.685] - globals found: [1] ‘FUN’
[10:30:48.685] Searching for globals ... DONE
[10:30:48.685] Resolving globals: FALSE
[10:30:48.685] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[10:30:48.686] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[10:30:48.686] - globals: [1] ‘FUN’
[10:30:48.686] 
[10:30:48.686] getGlobalsAndPackages() ... DONE
[10:30:48.686]  - globals found/used: [n=1] ‘FUN’
[10:30:48.686]  - needed namespaces: [n=0] 
[10:30:48.686] Finding globals ... DONE
[10:30:48.687] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.687] List of 2
[10:30:48.687]  $ ...future.FUN:function (x, y)  
[10:30:48.687]  $ MoreArgs     :List of 1
[10:30:48.687]   ..$ y: int [1:2] 3 4
[10:30:48.687]  - attr(*, "where")=List of 2
[10:30:48.687]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.687]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.687]  - attr(*, "resolved")= logi FALSE
[10:30:48.687]  - attr(*, "total_size")= num NA
[10:30:48.690] Packages to be attached in all futures: [n=0] 
[10:30:48.690] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.690] Number of futures (= number of chunks): 1
[10:30:48.690] Launching 1 futures (chunks) ...
[10:30:48.690] Chunk #1 of 1 ...
[10:30:48.690]  - Finding globals in '...' for chunk #1 ...
[10:30:48.690] getGlobalsAndPackages() ...
[10:30:48.690] Searching for globals...
[10:30:48.691] 
[10:30:48.691] Searching for globals ... DONE
[10:30:48.691] - globals: [0] <none>
[10:30:48.691] getGlobalsAndPackages() ... DONE
[10:30:48.691]    + additional globals found: [n=0] 
[10:30:48.691]    + additional namespaces needed: [n=0] 
[10:30:48.691]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.691]  - seeds: <none>
[10:30:48.692]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.692] getGlobalsAndPackages() ...
[10:30:48.692] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.692] Resolving globals: FALSE
[10:30:48.692] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[10:30:48.693] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:48.693] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.693] 
[10:30:48.693] getGlobalsAndPackages() ... DONE
[10:30:48.693] run() for ‘Future’ ...
[10:30:48.694] - state: ‘created’
[10:30:48.694] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.694] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.694] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.694]   - Field: ‘label’
[10:30:48.694]   - Field: ‘local’
[10:30:48.694]   - Field: ‘owner’
[10:30:48.694]   - Field: ‘envir’
[10:30:48.695]   - Field: ‘packages’
[10:30:48.695]   - Field: ‘gc’
[10:30:48.695]   - Field: ‘conditions’
[10:30:48.695]   - Field: ‘expr’
[10:30:48.695]   - Field: ‘uuid’
[10:30:48.695]   - Field: ‘seed’
[10:30:48.695]   - Field: ‘version’
[10:30:48.695]   - Field: ‘result’
[10:30:48.695]   - Field: ‘asynchronous’
[10:30:48.695]   - Field: ‘calls’
[10:30:48.696]   - Field: ‘globals’
[10:30:48.698]   - Field: ‘stdout’
[10:30:48.698]   - Field: ‘earlySignal’
[10:30:48.698]   - Field: ‘lazy’
[10:30:48.698]   - Field: ‘state’
[10:30:48.698] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.698] - Launch lazy future ...
[10:30:48.699] Packages needed by the future expression (n = 0): <none>
[10:30:48.699] Packages needed by future strategies (n = 0): <none>
[10:30:48.699] {
[10:30:48.699]     {
[10:30:48.699]         {
[10:30:48.699]             ...future.startTime <- base::Sys.time()
[10:30:48.699]             {
[10:30:48.699]                 {
[10:30:48.699]                   {
[10:30:48.699]                     base::local({
[10:30:48.699]                       has_future <- base::requireNamespace("future", 
[10:30:48.699]                         quietly = TRUE)
[10:30:48.699]                       if (has_future) {
[10:30:48.699]                         ns <- base::getNamespace("future")
[10:30:48.699]                         version <- ns[[".package"]][["version"]]
[10:30:48.699]                         if (is.null(version)) 
[10:30:48.699]                           version <- utils::packageVersion("future")
[10:30:48.699]                       }
[10:30:48.699]                       else {
[10:30:48.699]                         version <- NULL
[10:30:48.699]                       }
[10:30:48.699]                       if (!has_future || version < "1.8.0") {
[10:30:48.699]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.699]                           "", base::R.version$version.string), 
[10:30:48.699]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.699]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.699]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.699]                             "release", "version")], collapse = " "), 
[10:30:48.699]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.699]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.699]                           info)
[10:30:48.699]                         info <- base::paste(info, collapse = "; ")
[10:30:48.699]                         if (!has_future) {
[10:30:48.699]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.699]                             info)
[10:30:48.699]                         }
[10:30:48.699]                         else {
[10:30:48.699]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.699]                             info, version)
[10:30:48.699]                         }
[10:30:48.699]                         base::stop(msg)
[10:30:48.699]                       }
[10:30:48.699]                     })
[10:30:48.699]                   }
[10:30:48.699]                   ...future.strategy.old <- future::plan("list")
[10:30:48.699]                   options(future.plan = NULL)
[10:30:48.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.699]                 }
[10:30:48.699]                 ...future.workdir <- getwd()
[10:30:48.699]             }
[10:30:48.699]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.699]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.699]         }
[10:30:48.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.699]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.699]             base::names(...future.oldOptions))
[10:30:48.699]     }
[10:30:48.699]     if (FALSE) {
[10:30:48.699]     }
[10:30:48.699]     else {
[10:30:48.699]         if (TRUE) {
[10:30:48.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.699]                 open = "w")
[10:30:48.699]         }
[10:30:48.699]         else {
[10:30:48.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.699]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.699]         }
[10:30:48.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.699]             base::sink(type = "output", split = FALSE)
[10:30:48.699]             base::close(...future.stdout)
[10:30:48.699]         }, add = TRUE)
[10:30:48.699]     }
[10:30:48.699]     ...future.frame <- base::sys.nframe()
[10:30:48.699]     ...future.conditions <- base::list()
[10:30:48.699]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.699]     if (FALSE) {
[10:30:48.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.699]     }
[10:30:48.699]     ...future.result <- base::tryCatch({
[10:30:48.699]         base::withCallingHandlers({
[10:30:48.699]             ...future.value <- base::withVisible(base::local({
[10:30:48.699]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.699]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.699]                   ...future.globals.maxSize)) {
[10:30:48.699]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.699]                   on.exit(options(oopts), add = TRUE)
[10:30:48.699]                 }
[10:30:48.699]                 {
[10:30:48.699]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.699]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.699]                     USE.NAMES = FALSE)
[10:30:48.699]                   do.call(mapply, args = args)
[10:30:48.699]                 }
[10:30:48.699]             }))
[10:30:48.699]             future::FutureResult(value = ...future.value$value, 
[10:30:48.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.699]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.699]                     ...future.globalenv.names))
[10:30:48.699]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.699]         }, condition = base::local({
[10:30:48.699]             c <- base::c
[10:30:48.699]             inherits <- base::inherits
[10:30:48.699]             invokeRestart <- base::invokeRestart
[10:30:48.699]             length <- base::length
[10:30:48.699]             list <- base::list
[10:30:48.699]             seq.int <- base::seq.int
[10:30:48.699]             signalCondition <- base::signalCondition
[10:30:48.699]             sys.calls <- base::sys.calls
[10:30:48.699]             `[[` <- base::`[[`
[10:30:48.699]             `+` <- base::`+`
[10:30:48.699]             `<<-` <- base::`<<-`
[10:30:48.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.699]                   3L)]
[10:30:48.699]             }
[10:30:48.699]             function(cond) {
[10:30:48.699]                 is_error <- inherits(cond, "error")
[10:30:48.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.699]                   NULL)
[10:30:48.699]                 if (is_error) {
[10:30:48.699]                   sessionInformation <- function() {
[10:30:48.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.699]                       search = base::search(), system = base::Sys.info())
[10:30:48.699]                   }
[10:30:48.699]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.699]                     cond$call), session = sessionInformation(), 
[10:30:48.699]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.699]                   signalCondition(cond)
[10:30:48.699]                 }
[10:30:48.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.699]                 "immediateCondition"))) {
[10:30:48.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.699]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.699]                   if (TRUE && !signal) {
[10:30:48.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.699]                     {
[10:30:48.699]                       inherits <- base::inherits
[10:30:48.699]                       invokeRestart <- base::invokeRestart
[10:30:48.699]                       is.null <- base::is.null
[10:30:48.699]                       muffled <- FALSE
[10:30:48.699]                       if (inherits(cond, "message")) {
[10:30:48.699]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.699]                         if (muffled) 
[10:30:48.699]                           invokeRestart("muffleMessage")
[10:30:48.699]                       }
[10:30:48.699]                       else if (inherits(cond, "warning")) {
[10:30:48.699]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.699]                         if (muffled) 
[10:30:48.699]                           invokeRestart("muffleWarning")
[10:30:48.699]                       }
[10:30:48.699]                       else if (inherits(cond, "condition")) {
[10:30:48.699]                         if (!is.null(pattern)) {
[10:30:48.699]                           computeRestarts <- base::computeRestarts
[10:30:48.699]                           grepl <- base::grepl
[10:30:48.699]                           restarts <- computeRestarts(cond)
[10:30:48.699]                           for (restart in restarts) {
[10:30:48.699]                             name <- restart$name
[10:30:48.699]                             if (is.null(name)) 
[10:30:48.699]                               next
[10:30:48.699]                             if (!grepl(pattern, name)) 
[10:30:48.699]                               next
[10:30:48.699]                             invokeRestart(restart)
[10:30:48.699]                             muffled <- TRUE
[10:30:48.699]                             break
[10:30:48.699]                           }
[10:30:48.699]                         }
[10:30:48.699]                       }
[10:30:48.699]                       invisible(muffled)
[10:30:48.699]                     }
[10:30:48.699]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.699]                   }
[10:30:48.699]                 }
[10:30:48.699]                 else {
[10:30:48.699]                   if (TRUE) {
[10:30:48.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.699]                     {
[10:30:48.699]                       inherits <- base::inherits
[10:30:48.699]                       invokeRestart <- base::invokeRestart
[10:30:48.699]                       is.null <- base::is.null
[10:30:48.699]                       muffled <- FALSE
[10:30:48.699]                       if (inherits(cond, "message")) {
[10:30:48.699]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.699]                         if (muffled) 
[10:30:48.699]                           invokeRestart("muffleMessage")
[10:30:48.699]                       }
[10:30:48.699]                       else if (inherits(cond, "warning")) {
[10:30:48.699]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.699]                         if (muffled) 
[10:30:48.699]                           invokeRestart("muffleWarning")
[10:30:48.699]                       }
[10:30:48.699]                       else if (inherits(cond, "condition")) {
[10:30:48.699]                         if (!is.null(pattern)) {
[10:30:48.699]                           computeRestarts <- base::computeRestarts
[10:30:48.699]                           grepl <- base::grepl
[10:30:48.699]                           restarts <- computeRestarts(cond)
[10:30:48.699]                           for (restart in restarts) {
[10:30:48.699]                             name <- restart$name
[10:30:48.699]                             if (is.null(name)) 
[10:30:48.699]                               next
[10:30:48.699]                             if (!grepl(pattern, name)) 
[10:30:48.699]                               next
[10:30:48.699]                             invokeRestart(restart)
[10:30:48.699]                             muffled <- TRUE
[10:30:48.699]                             break
[10:30:48.699]                           }
[10:30:48.699]                         }
[10:30:48.699]                       }
[10:30:48.699]                       invisible(muffled)
[10:30:48.699]                     }
[10:30:48.699]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.699]                   }
[10:30:48.699]                 }
[10:30:48.699]             }
[10:30:48.699]         }))
[10:30:48.699]     }, error = function(ex) {
[10:30:48.699]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.699]                 ...future.rng), started = ...future.startTime, 
[10:30:48.699]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.699]             version = "1.8"), class = "FutureResult")
[10:30:48.699]     }, finally = {
[10:30:48.699]         if (!identical(...future.workdir, getwd())) 
[10:30:48.699]             setwd(...future.workdir)
[10:30:48.699]         {
[10:30:48.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.699]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.699]             }
[10:30:48.699]             base::options(...future.oldOptions)
[10:30:48.699]             if (.Platform$OS.type == "windows") {
[10:30:48.699]                 old_names <- names(...future.oldEnvVars)
[10:30:48.699]                 envs <- base::Sys.getenv()
[10:30:48.699]                 names <- names(envs)
[10:30:48.699]                 common <- intersect(names, old_names)
[10:30:48.699]                 added <- setdiff(names, old_names)
[10:30:48.699]                 removed <- setdiff(old_names, names)
[10:30:48.699]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.699]                   envs[common]]
[10:30:48.699]                 NAMES <- toupper(changed)
[10:30:48.699]                 args <- list()
[10:30:48.699]                 for (kk in seq_along(NAMES)) {
[10:30:48.699]                   name <- changed[[kk]]
[10:30:48.699]                   NAME <- NAMES[[kk]]
[10:30:48.699]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.699]                     next
[10:30:48.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.699]                 }
[10:30:48.699]                 NAMES <- toupper(added)
[10:30:48.699]                 for (kk in seq_along(NAMES)) {
[10:30:48.699]                   name <- added[[kk]]
[10:30:48.699]                   NAME <- NAMES[[kk]]
[10:30:48.699]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.699]                     next
[10:30:48.699]                   args[[name]] <- ""
[10:30:48.699]                 }
[10:30:48.699]                 NAMES <- toupper(removed)
[10:30:48.699]                 for (kk in seq_along(NAMES)) {
[10:30:48.699]                   name <- removed[[kk]]
[10:30:48.699]                   NAME <- NAMES[[kk]]
[10:30:48.699]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.699]                     next
[10:30:48.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.699]                 }
[10:30:48.699]                 if (length(args) > 0) 
[10:30:48.699]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.699]             }
[10:30:48.699]             else {
[10:30:48.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.699]             }
[10:30:48.699]             {
[10:30:48.699]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.699]                   0L) {
[10:30:48.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.699]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.699]                   base::options(opts)
[10:30:48.699]                 }
[10:30:48.699]                 {
[10:30:48.699]                   {
[10:30:48.699]                     base::assign(".Random.seed", c(10407L, -1093314488L, 
[10:30:48.699]                     -1790265292L, 1494356689L, -1337045025L, 
[10:30:48.699]                     873218515L, 1713452462L), envir = base::globalenv(), 
[10:30:48.699]                       inherits = FALSE)
[10:30:48.699]                     NULL
[10:30:48.699]                   }
[10:30:48.699]                   options(future.plan = NULL)
[10:30:48.699]                   if (is.na(NA_character_)) 
[10:30:48.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.699]                     .init = FALSE)
[10:30:48.699]                 }
[10:30:48.699]             }
[10:30:48.699]         }
[10:30:48.699]     })
[10:30:48.699]     if (TRUE) {
[10:30:48.699]         base::sink(type = "output", split = FALSE)
[10:30:48.699]         if (TRUE) {
[10:30:48.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.699]         }
[10:30:48.699]         else {
[10:30:48.699]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.699]         }
[10:30:48.699]         base::close(...future.stdout)
[10:30:48.699]         ...future.stdout <- NULL
[10:30:48.699]     }
[10:30:48.699]     ...future.result$conditions <- ...future.conditions
[10:30:48.699]     ...future.result$finished <- base::Sys.time()
[10:30:48.699]     ...future.result
[10:30:48.699] }
[10:30:48.701] assign_globals() ...
[10:30:48.701] List of 5
[10:30:48.701]  $ ...future.FUN            :function (x, y)  
[10:30:48.701]  $ MoreArgs                 :List of 1
[10:30:48.701]   ..$ y: int [1:2] 3 4
[10:30:48.701]  $ ...future.elements_ii    :List of 1
[10:30:48.701]   ..$ x:List of 2
[10:30:48.701]   .. ..$ : int 1
[10:30:48.701]   .. ..$ : int 2
[10:30:48.701]  $ ...future.seeds_ii       : NULL
[10:30:48.701]  $ ...future.globals.maxSize: NULL
[10:30:48.701]  - attr(*, "where")=List of 5
[10:30:48.701]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.701]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.701]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.701]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.701]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.701]  - attr(*, "resolved")= logi FALSE
[10:30:48.701]  - attr(*, "total_size")= num 1872
[10:30:48.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.701]  - attr(*, "already-done")= logi TRUE
[10:30:48.707] - reassign environment for ‘...future.FUN’
[10:30:48.707] - copied ‘...future.FUN’ to environment
[10:30:48.707] - copied ‘MoreArgs’ to environment
[10:30:48.707] - copied ‘...future.elements_ii’ to environment
[10:30:48.707] - copied ‘...future.seeds_ii’ to environment
[10:30:48.707] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.707] assign_globals() ... done
[10:30:48.707] plan(): Setting new future strategy stack:
[10:30:48.708] List of future strategies:
[10:30:48.708] 1. sequential:
[10:30:48.708]    - args: function (..., envir = parent.frame())
[10:30:48.708]    - tweaked: FALSE
[10:30:48.708]    - call: NULL
[10:30:48.708] plan(): nbrOfWorkers() = 1
[10:30:48.709] plan(): Setting new future strategy stack:
[10:30:48.709] List of future strategies:
[10:30:48.709] 1. sequential:
[10:30:48.709]    - args: function (..., envir = parent.frame())
[10:30:48.709]    - tweaked: FALSE
[10:30:48.709]    - call: plan(strategy)
[10:30:48.709] plan(): nbrOfWorkers() = 1
[10:30:48.709] SequentialFuture started (and completed)
[10:30:48.710] - Launch lazy future ... done
[10:30:48.710] run() for ‘SequentialFuture’ ... done
[10:30:48.710] Created future:
[10:30:48.710] SequentialFuture:
[10:30:48.710] Label: ‘future_mapply-1’
[10:30:48.710] Expression:
[10:30:48.710] {
[10:30:48.710]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.710]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.710]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.710]         on.exit(options(oopts), add = TRUE)
[10:30:48.710]     }
[10:30:48.710]     {
[10:30:48.710]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.710]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.710]         do.call(mapply, args = args)
[10:30:48.710]     }
[10:30:48.710] }
[10:30:48.710] Lazy evaluation: FALSE
[10:30:48.710] Asynchronous evaluation: FALSE
[10:30:48.710] Local evaluation: TRUE
[10:30:48.710] Environment: R_GlobalEnv
[10:30:48.710] Capture standard output: TRUE
[10:30:48.710] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.710] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.710] Packages: <none>
[10:30:48.710] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.710] Resolved: TRUE
[10:30:48.710] Value: 112 bytes of class ‘list’
[10:30:48.710] Early signaling: FALSE
[10:30:48.710] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.710] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.711] Chunk #1 of 1 ... DONE
[10:30:48.711] Launching 1 futures (chunks) ... DONE
[10:30:48.711] Resolving 1 futures (chunks) ...
[10:30:48.711] resolve() on list ...
[10:30:48.711]  recursive: 0
[10:30:48.711]  length: 1
[10:30:48.711] 
[10:30:48.712] resolved() for ‘SequentialFuture’ ...
[10:30:48.712] - state: ‘finished’
[10:30:48.712] - run: TRUE
[10:30:48.712] - result: ‘FutureResult’
[10:30:48.712] resolved() for ‘SequentialFuture’ ... done
[10:30:48.712] Future #1
[10:30:48.712] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.712] - nx: 1
[10:30:48.713] - relay: TRUE
[10:30:48.713] - stdout: TRUE
[10:30:48.713] - signal: TRUE
[10:30:48.713] - resignal: FALSE
[10:30:48.713] - force: TRUE
[10:30:48.713] - relayed: [n=1] FALSE
[10:30:48.713] - queued futures: [n=1] FALSE
[10:30:48.714]  - until=1
[10:30:48.714]  - relaying element #1
[10:30:48.714] - relayed: [n=1] TRUE
[10:30:48.714] - queued futures: [n=1] TRUE
[10:30:48.714] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.714]  length: 0 (resolved future 1)
[10:30:48.714] Relaying remaining futures
[10:30:48.715] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.715] - nx: 1
[10:30:48.715] - relay: TRUE
[10:30:48.715] - stdout: TRUE
[10:30:48.715] - signal: TRUE
[10:30:48.715] - resignal: FALSE
[10:30:48.715] - force: TRUE
[10:30:48.715] - relayed: [n=1] TRUE
[10:30:48.715] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.716] - relayed: [n=1] TRUE
[10:30:48.716] - queued futures: [n=1] TRUE
[10:30:48.716] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.716] resolve() on list ... DONE
[10:30:48.716]  - Number of value chunks collected: 1
[10:30:48.716] Resolving 1 futures (chunks) ... DONE
[10:30:48.717] Reducing values from 1 chunks ...
[10:30:48.717]  - Number of values collected after concatenation: 2
[10:30:48.717]  - Number of values expected: 2
[10:30:48.717] Reducing values from 1 chunks ... DONE
[10:30:48.717] future_mapply() ... DONE
[10:30:48.717] future_mapply() ...
[10:30:48.717] Generating random seeds ...
[10:30:48.718] Generating random seed streams for 2 elements ...
[10:30:48.718] Generating random seed streams for 2 elements ... DONE
[10:30:48.718] Generating random seeds ... DONE
[10:30:48.718] Will set RNG state on exit: 10407, 1494356689, 1190224784, 312275249, 1713452462, 635500387, 1139696322
[10:30:48.718] Number of chunks: 1
[10:30:48.718] getGlobalsAndPackagesXApply() ...
[10:30:48.719]  - future.globals: TRUE
[10:30:48.719] getGlobalsAndPackages() ...
[10:30:48.719] Searching for globals...
[10:30:48.720] - globals found: [1] ‘FUN’
[10:30:48.720] Searching for globals ... DONE
[10:30:48.721] Resolving globals: FALSE
[10:30:48.721] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[10:30:48.722] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[10:30:48.722] - globals: [1] ‘FUN’
[10:30:48.722] 
[10:30:48.722] getGlobalsAndPackages() ... DONE
[10:30:48.722]  - globals found/used: [n=1] ‘FUN’
[10:30:48.722]  - needed namespaces: [n=0] 
[10:30:48.722] Finding globals ... DONE
[10:30:48.723] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.723] List of 2
[10:30:48.723]  $ ...future.FUN:function (x, y)  
[10:30:48.723]  $ MoreArgs     :List of 1
[10:30:48.723]   ..$ y: int [1:2] 3 4
[10:30:48.723]  - attr(*, "where")=List of 2
[10:30:48.723]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.723]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.723]  - attr(*, "resolved")= logi FALSE
[10:30:48.723]  - attr(*, "total_size")= num NA
[10:30:48.729] Packages to be attached in all futures: [n=0] 
[10:30:48.729] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.729] Number of futures (= number of chunks): 1
[10:30:48.730] Launching 1 futures (chunks) ...
[10:30:48.730] Chunk #1 of 1 ...
[10:30:48.730]  - Finding globals in '...' for chunk #1 ...
[10:30:48.730] getGlobalsAndPackages() ...
[10:30:48.730] Searching for globals...
[10:30:48.730] 
[10:30:48.730] Searching for globals ... DONE
[10:30:48.730] - globals: [0] <none>
[10:30:48.731] getGlobalsAndPackages() ... DONE
[10:30:48.731]    + additional globals found: [n=0] 
[10:30:48.731]    + additional namespaces needed: [n=0] 
[10:30:48.731]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.731]  - seeds: [2] <seeds>
[10:30:48.731]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.731] getGlobalsAndPackages() ...
[10:30:48.731] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.731] Resolving globals: FALSE
[10:30:48.732] The total size of the 5 globals is 1.98 KiB (2032 bytes)
[10:30:48.732] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (160 bytes of class ‘list’) and ‘...future.elements_ii’ (112 bytes of class ‘list’)
[10:30:48.732] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.733] 
[10:30:48.733] getGlobalsAndPackages() ... DONE
[10:30:48.733] run() for ‘Future’ ...
[10:30:48.733] - state: ‘created’
[10:30:48.733] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.734] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.734]   - Field: ‘label’
[10:30:48.734]   - Field: ‘local’
[10:30:48.734]   - Field: ‘owner’
[10:30:48.734]   - Field: ‘envir’
[10:30:48.734]   - Field: ‘packages’
[10:30:48.734]   - Field: ‘gc’
[10:30:48.734]   - Field: ‘conditions’
[10:30:48.734]   - Field: ‘expr’
[10:30:48.735]   - Field: ‘uuid’
[10:30:48.735]   - Field: ‘seed’
[10:30:48.735]   - Field: ‘version’
[10:30:48.735]   - Field: ‘result’
[10:30:48.735]   - Field: ‘asynchronous’
[10:30:48.735]   - Field: ‘calls’
[10:30:48.735]   - Field: ‘globals’
[10:30:48.735]   - Field: ‘stdout’
[10:30:48.735]   - Field: ‘earlySignal’
[10:30:48.735]   - Field: ‘lazy’
[10:30:48.735]   - Field: ‘state’
[10:30:48.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.736] - Launch lazy future ...
[10:30:48.736] Packages needed by the future expression (n = 0): <none>
[10:30:48.736] Packages needed by future strategies (n = 0): <none>
[10:30:48.736] {
[10:30:48.736]     {
[10:30:48.736]         {
[10:30:48.736]             ...future.startTime <- base::Sys.time()
[10:30:48.736]             {
[10:30:48.736]                 {
[10:30:48.736]                   {
[10:30:48.736]                     base::local({
[10:30:48.736]                       has_future <- base::requireNamespace("future", 
[10:30:48.736]                         quietly = TRUE)
[10:30:48.736]                       if (has_future) {
[10:30:48.736]                         ns <- base::getNamespace("future")
[10:30:48.736]                         version <- ns[[".package"]][["version"]]
[10:30:48.736]                         if (is.null(version)) 
[10:30:48.736]                           version <- utils::packageVersion("future")
[10:30:48.736]                       }
[10:30:48.736]                       else {
[10:30:48.736]                         version <- NULL
[10:30:48.736]                       }
[10:30:48.736]                       if (!has_future || version < "1.8.0") {
[10:30:48.736]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.736]                           "", base::R.version$version.string), 
[10:30:48.736]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.736]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.736]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.736]                             "release", "version")], collapse = " "), 
[10:30:48.736]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.736]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.736]                           info)
[10:30:48.736]                         info <- base::paste(info, collapse = "; ")
[10:30:48.736]                         if (!has_future) {
[10:30:48.736]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.736]                             info)
[10:30:48.736]                         }
[10:30:48.736]                         else {
[10:30:48.736]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.736]                             info, version)
[10:30:48.736]                         }
[10:30:48.736]                         base::stop(msg)
[10:30:48.736]                       }
[10:30:48.736]                     })
[10:30:48.736]                   }
[10:30:48.736]                   ...future.strategy.old <- future::plan("list")
[10:30:48.736]                   options(future.plan = NULL)
[10:30:48.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.736]                 }
[10:30:48.736]                 ...future.workdir <- getwd()
[10:30:48.736]             }
[10:30:48.736]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.736]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.736]         }
[10:30:48.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.736]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.736]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.736]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.736]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.736]             base::names(...future.oldOptions))
[10:30:48.736]     }
[10:30:48.736]     if (FALSE) {
[10:30:48.736]     }
[10:30:48.736]     else {
[10:30:48.736]         if (TRUE) {
[10:30:48.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.736]                 open = "w")
[10:30:48.736]         }
[10:30:48.736]         else {
[10:30:48.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.736]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.736]         }
[10:30:48.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.736]             base::sink(type = "output", split = FALSE)
[10:30:48.736]             base::close(...future.stdout)
[10:30:48.736]         }, add = TRUE)
[10:30:48.736]     }
[10:30:48.736]     ...future.frame <- base::sys.nframe()
[10:30:48.736]     ...future.conditions <- base::list()
[10:30:48.736]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.736]     if (FALSE) {
[10:30:48.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.736]     }
[10:30:48.736]     ...future.result <- base::tryCatch({
[10:30:48.736]         base::withCallingHandlers({
[10:30:48.736]             ...future.value <- base::withVisible(base::local({
[10:30:48.736]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.736]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.736]                   ...future.globals.maxSize)) {
[10:30:48.736]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.736]                   on.exit(options(oopts), add = TRUE)
[10:30:48.736]                 }
[10:30:48.736]                 {
[10:30:48.736]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:48.736]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:48.736]                       envir = globalenv(), inherits = FALSE)
[10:30:48.736]                     ...future.FUN(...)
[10:30:48.736]                   }
[10:30:48.736]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:48.736]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:48.736]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.736]                     USE.NAMES = FALSE)
[10:30:48.736]                   do.call(mapply, args = args)
[10:30:48.736]                 }
[10:30:48.736]             }))
[10:30:48.736]             future::FutureResult(value = ...future.value$value, 
[10:30:48.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.736]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.736]                     ...future.globalenv.names))
[10:30:48.736]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.736]         }, condition = base::local({
[10:30:48.736]             c <- base::c
[10:30:48.736]             inherits <- base::inherits
[10:30:48.736]             invokeRestart <- base::invokeRestart
[10:30:48.736]             length <- base::length
[10:30:48.736]             list <- base::list
[10:30:48.736]             seq.int <- base::seq.int
[10:30:48.736]             signalCondition <- base::signalCondition
[10:30:48.736]             sys.calls <- base::sys.calls
[10:30:48.736]             `[[` <- base::`[[`
[10:30:48.736]             `+` <- base::`+`
[10:30:48.736]             `<<-` <- base::`<<-`
[10:30:48.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.736]                   3L)]
[10:30:48.736]             }
[10:30:48.736]             function(cond) {
[10:30:48.736]                 is_error <- inherits(cond, "error")
[10:30:48.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.736]                   NULL)
[10:30:48.736]                 if (is_error) {
[10:30:48.736]                   sessionInformation <- function() {
[10:30:48.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.736]                       search = base::search(), system = base::Sys.info())
[10:30:48.736]                   }
[10:30:48.736]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.736]                     cond$call), session = sessionInformation(), 
[10:30:48.736]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.736]                   signalCondition(cond)
[10:30:48.736]                 }
[10:30:48.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.736]                 "immediateCondition"))) {
[10:30:48.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.736]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.736]                   if (TRUE && !signal) {
[10:30:48.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.736]                     {
[10:30:48.736]                       inherits <- base::inherits
[10:30:48.736]                       invokeRestart <- base::invokeRestart
[10:30:48.736]                       is.null <- base::is.null
[10:30:48.736]                       muffled <- FALSE
[10:30:48.736]                       if (inherits(cond, "message")) {
[10:30:48.736]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.736]                         if (muffled) 
[10:30:48.736]                           invokeRestart("muffleMessage")
[10:30:48.736]                       }
[10:30:48.736]                       else if (inherits(cond, "warning")) {
[10:30:48.736]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.736]                         if (muffled) 
[10:30:48.736]                           invokeRestart("muffleWarning")
[10:30:48.736]                       }
[10:30:48.736]                       else if (inherits(cond, "condition")) {
[10:30:48.736]                         if (!is.null(pattern)) {
[10:30:48.736]                           computeRestarts <- base::computeRestarts
[10:30:48.736]                           grepl <- base::grepl
[10:30:48.736]                           restarts <- computeRestarts(cond)
[10:30:48.736]                           for (restart in restarts) {
[10:30:48.736]                             name <- restart$name
[10:30:48.736]                             if (is.null(name)) 
[10:30:48.736]                               next
[10:30:48.736]                             if (!grepl(pattern, name)) 
[10:30:48.736]                               next
[10:30:48.736]                             invokeRestart(restart)
[10:30:48.736]                             muffled <- TRUE
[10:30:48.736]                             break
[10:30:48.736]                           }
[10:30:48.736]                         }
[10:30:48.736]                       }
[10:30:48.736]                       invisible(muffled)
[10:30:48.736]                     }
[10:30:48.736]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.736]                   }
[10:30:48.736]                 }
[10:30:48.736]                 else {
[10:30:48.736]                   if (TRUE) {
[10:30:48.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.736]                     {
[10:30:48.736]                       inherits <- base::inherits
[10:30:48.736]                       invokeRestart <- base::invokeRestart
[10:30:48.736]                       is.null <- base::is.null
[10:30:48.736]                       muffled <- FALSE
[10:30:48.736]                       if (inherits(cond, "message")) {
[10:30:48.736]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.736]                         if (muffled) 
[10:30:48.736]                           invokeRestart("muffleMessage")
[10:30:48.736]                       }
[10:30:48.736]                       else if (inherits(cond, "warning")) {
[10:30:48.736]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.736]                         if (muffled) 
[10:30:48.736]                           invokeRestart("muffleWarning")
[10:30:48.736]                       }
[10:30:48.736]                       else if (inherits(cond, "condition")) {
[10:30:48.736]                         if (!is.null(pattern)) {
[10:30:48.736]                           computeRestarts <- base::computeRestarts
[10:30:48.736]                           grepl <- base::grepl
[10:30:48.736]                           restarts <- computeRestarts(cond)
[10:30:48.736]                           for (restart in restarts) {
[10:30:48.736]                             name <- restart$name
[10:30:48.736]                             if (is.null(name)) 
[10:30:48.736]                               next
[10:30:48.736]                             if (!grepl(pattern, name)) 
[10:30:48.736]                               next
[10:30:48.736]                             invokeRestart(restart)
[10:30:48.736]                             muffled <- TRUE
[10:30:48.736]                             break
[10:30:48.736]                           }
[10:30:48.736]                         }
[10:30:48.736]                       }
[10:30:48.736]                       invisible(muffled)
[10:30:48.736]                     }
[10:30:48.736]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.736]                   }
[10:30:48.736]                 }
[10:30:48.736]             }
[10:30:48.736]         }))
[10:30:48.736]     }, error = function(ex) {
[10:30:48.736]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.736]                 ...future.rng), started = ...future.startTime, 
[10:30:48.736]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.736]             version = "1.8"), class = "FutureResult")
[10:30:48.736]     }, finally = {
[10:30:48.736]         if (!identical(...future.workdir, getwd())) 
[10:30:48.736]             setwd(...future.workdir)
[10:30:48.736]         {
[10:30:48.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.736]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.736]             }
[10:30:48.736]             base::options(...future.oldOptions)
[10:30:48.736]             if (.Platform$OS.type == "windows") {
[10:30:48.736]                 old_names <- names(...future.oldEnvVars)
[10:30:48.736]                 envs <- base::Sys.getenv()
[10:30:48.736]                 names <- names(envs)
[10:30:48.736]                 common <- intersect(names, old_names)
[10:30:48.736]                 added <- setdiff(names, old_names)
[10:30:48.736]                 removed <- setdiff(old_names, names)
[10:30:48.736]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.736]                   envs[common]]
[10:30:48.736]                 NAMES <- toupper(changed)
[10:30:48.736]                 args <- list()
[10:30:48.736]                 for (kk in seq_along(NAMES)) {
[10:30:48.736]                   name <- changed[[kk]]
[10:30:48.736]                   NAME <- NAMES[[kk]]
[10:30:48.736]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.736]                     next
[10:30:48.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.736]                 }
[10:30:48.736]                 NAMES <- toupper(added)
[10:30:48.736]                 for (kk in seq_along(NAMES)) {
[10:30:48.736]                   name <- added[[kk]]
[10:30:48.736]                   NAME <- NAMES[[kk]]
[10:30:48.736]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.736]                     next
[10:30:48.736]                   args[[name]] <- ""
[10:30:48.736]                 }
[10:30:48.736]                 NAMES <- toupper(removed)
[10:30:48.736]                 for (kk in seq_along(NAMES)) {
[10:30:48.736]                   name <- removed[[kk]]
[10:30:48.736]                   NAME <- NAMES[[kk]]
[10:30:48.736]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.736]                     next
[10:30:48.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.736]                 }
[10:30:48.736]                 if (length(args) > 0) 
[10:30:48.736]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.736]             }
[10:30:48.736]             else {
[10:30:48.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.736]             }
[10:30:48.736]             {
[10:30:48.736]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.736]                   0L) {
[10:30:48.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.736]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.736]                   base::options(opts)
[10:30:48.736]                 }
[10:30:48.736]                 {
[10:30:48.736]                   {
[10:30:48.736]                     base::assign(".Random.seed", c(10407L, 1494356689L, 
[10:30:48.736]                     1190224784L, 312275249L, 1713452462L, 635500387L, 
[10:30:48.736]                     1139696322L), envir = base::globalenv(), 
[10:30:48.736]                       inherits = FALSE)
[10:30:48.736]                     NULL
[10:30:48.736]                   }
[10:30:48.736]                   options(future.plan = NULL)
[10:30:48.736]                   if (is.na(NA_character_)) 
[10:30:48.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.736]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.736]                     .init = FALSE)
[10:30:48.736]                 }
[10:30:48.736]             }
[10:30:48.736]         }
[10:30:48.736]     })
[10:30:48.736]     if (TRUE) {
[10:30:48.736]         base::sink(type = "output", split = FALSE)
[10:30:48.736]         if (TRUE) {
[10:30:48.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.736]         }
[10:30:48.736]         else {
[10:30:48.736]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.736]         }
[10:30:48.736]         base::close(...future.stdout)
[10:30:48.736]         ...future.stdout <- NULL
[10:30:48.736]     }
[10:30:48.736]     ...future.result$conditions <- ...future.conditions
[10:30:48.736]     ...future.result$finished <- base::Sys.time()
[10:30:48.736]     ...future.result
[10:30:48.736] }
[10:30:48.738] assign_globals() ...
[10:30:48.738] List of 5
[10:30:48.738]  $ ...future.FUN            :function (x, y)  
[10:30:48.738]  $ MoreArgs                 :List of 1
[10:30:48.738]   ..$ y: int [1:2] 3 4
[10:30:48.738]  $ ...future.elements_ii    :List of 1
[10:30:48.738]   ..$ x:List of 2
[10:30:48.738]   .. ..$ : int 1
[10:30:48.738]   .. ..$ : int 2
[10:30:48.738]  $ ...future.seeds_ii       :List of 2
[10:30:48.738]   ..$ : int [1:7] 10407 2146868457 1861477544 -273292896 -1749852869 2128880512 -397894512
[10:30:48.738]   ..$ : int [1:7] 10407 -2021288253 -585916047 504476604 34606726 -1433618408 567666353
[10:30:48.738]  $ ...future.globals.maxSize: NULL
[10:30:48.738]  - attr(*, "where")=List of 5
[10:30:48.738]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.738]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.738]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.738]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.738]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.738]  - attr(*, "resolved")= logi FALSE
[10:30:48.738]  - attr(*, "total_size")= num 2032
[10:30:48.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.738]  - attr(*, "already-done")= logi TRUE
[10:30:48.744] - reassign environment for ‘...future.FUN’
[10:30:48.744] - copied ‘...future.FUN’ to environment
[10:30:48.744] - copied ‘MoreArgs’ to environment
[10:30:48.744] - copied ‘...future.elements_ii’ to environment
[10:30:48.744] - copied ‘...future.seeds_ii’ to environment
[10:30:48.745] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.745] assign_globals() ... done
[10:30:48.745] plan(): Setting new future strategy stack:
[10:30:48.745] List of future strategies:
[10:30:48.745] 1. sequential:
[10:30:48.745]    - args: function (..., envir = parent.frame())
[10:30:48.745]    - tweaked: FALSE
[10:30:48.745]    - call: NULL
[10:30:48.745] plan(): nbrOfWorkers() = 1
[10:30:48.746] plan(): Setting new future strategy stack:
[10:30:48.746] List of future strategies:
[10:30:48.746] 1. sequential:
[10:30:48.746]    - args: function (..., envir = parent.frame())
[10:30:48.746]    - tweaked: FALSE
[10:30:48.746]    - call: plan(strategy)
[10:30:48.747] plan(): nbrOfWorkers() = 1
[10:30:48.747] SequentialFuture started (and completed)
[10:30:48.747] - Launch lazy future ... done
[10:30:48.747] run() for ‘SequentialFuture’ ... done
[10:30:48.747] Created future:
[10:30:48.747] SequentialFuture:
[10:30:48.747] Label: ‘future_mapply-1’
[10:30:48.747] Expression:
[10:30:48.747] {
[10:30:48.747]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.747]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.747]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.747]         on.exit(options(oopts), add = TRUE)
[10:30:48.747]     }
[10:30:48.747]     {
[10:30:48.747]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:48.747]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:48.747]                 inherits = FALSE)
[10:30:48.747]             ...future.FUN(...)
[10:30:48.747]         }
[10:30:48.747]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:48.747]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:48.747]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.747]         do.call(mapply, args = args)
[10:30:48.747]     }
[10:30:48.747] }
[10:30:48.747] Lazy evaluation: FALSE
[10:30:48.747] Asynchronous evaluation: FALSE
[10:30:48.747] Local evaluation: TRUE
[10:30:48.747] Environment: R_GlobalEnv
[10:30:48.747] Capture standard output: TRUE
[10:30:48.747] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.747] Globals: 5 objects totaling 1.98 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.747] Packages: <none>
[10:30:48.747] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:48.747] Resolved: TRUE
[10:30:48.747] Value: 112 bytes of class ‘list’
[10:30:48.747] Early signaling: FALSE
[10:30:48.747] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.747] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.748] Chunk #1 of 1 ... DONE
[10:30:48.748] Launching 1 futures (chunks) ... DONE
[10:30:48.748] Resolving 1 futures (chunks) ...
[10:30:48.748] resolve() on list ...
[10:30:48.749]  recursive: 0
[10:30:48.749]  length: 1
[10:30:48.749] 
[10:30:48.749] resolved() for ‘SequentialFuture’ ...
[10:30:48.749] - state: ‘finished’
[10:30:48.749] - run: TRUE
[10:30:48.749] - result: ‘FutureResult’
[10:30:48.751] resolved() for ‘SequentialFuture’ ... done
[10:30:48.751] Future #1
[10:30:48.752] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.752] - nx: 1
[10:30:48.752] - relay: TRUE
[10:30:48.752] - stdout: TRUE
[10:30:48.752] - signal: TRUE
[10:30:48.752] - resignal: FALSE
[10:30:48.752] - force: TRUE
[10:30:48.752] - relayed: [n=1] FALSE
[10:30:48.752] - queued futures: [n=1] FALSE
[10:30:48.753]  - until=1
[10:30:48.753]  - relaying element #1
[10:30:48.753] - relayed: [n=1] TRUE
[10:30:48.753] - queued futures: [n=1] TRUE
[10:30:48.753] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.753]  length: 0 (resolved future 1)
[10:30:48.753] Relaying remaining futures
[10:30:48.753] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.754] - nx: 1
[10:30:48.754] - relay: TRUE
[10:30:48.754] - stdout: TRUE
[10:30:48.754] - signal: TRUE
[10:30:48.754] - resignal: FALSE
[10:30:48.754] - force: TRUE
[10:30:48.754] - relayed: [n=1] TRUE
[10:30:48.754] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.754] - relayed: [n=1] TRUE
[10:30:48.754] - queued futures: [n=1] TRUE
[10:30:48.754] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.755] resolve() on list ... DONE
[10:30:48.755]  - Number of value chunks collected: 1
[10:30:48.755] Resolving 1 futures (chunks) ... DONE
[10:30:48.755] Reducing values from 1 chunks ...
[10:30:48.755]  - Number of values collected after concatenation: 2
[10:30:48.755]  - Number of values expected: 2
[10:30:48.755] Reducing values from 1 chunks ... DONE
[10:30:48.755] future_mapply() ... DONE
[10:30:48.755] future_mapply() ...
[10:30:48.756] Number of chunks: 1
[10:30:48.756] getGlobalsAndPackagesXApply() ...
[10:30:48.756]  - future.globals: TRUE
[10:30:48.756] getGlobalsAndPackages() ...
[10:30:48.756] Searching for globals...
[10:30:48.757] - globals found: [1] ‘FUN’
[10:30:48.757] Searching for globals ... DONE
[10:30:48.757] Resolving globals: FALSE
[10:30:48.758] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[10:30:48.758] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[10:30:48.758] - globals: [1] ‘FUN’
[10:30:48.758] 
[10:30:48.758] getGlobalsAndPackages() ... DONE
[10:30:48.758]  - globals found/used: [n=1] ‘FUN’
[10:30:48.758]  - needed namespaces: [n=0] 
[10:30:48.759] Finding globals ... DONE
[10:30:48.759] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.759] List of 2
[10:30:48.759]  $ ...future.FUN:function (x, y)  
[10:30:48.759]  $ MoreArgs     :List of 1
[10:30:48.759]   ..$ y: int [1:2] 3 4
[10:30:48.759]  - attr(*, "where")=List of 2
[10:30:48.759]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.759]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.759]  - attr(*, "resolved")= logi FALSE
[10:30:48.759]  - attr(*, "total_size")= num NA
[10:30:48.762] Packages to be attached in all futures: [n=0] 
[10:30:48.762] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.762] Number of futures (= number of chunks): 1
[10:30:48.762] Launching 1 futures (chunks) ...
[10:30:48.762] Chunk #1 of 1 ...
[10:30:48.762]  - Finding globals in '...' for chunk #1 ...
[10:30:48.762] getGlobalsAndPackages() ...
[10:30:48.763] Searching for globals...
[10:30:48.763] 
[10:30:48.763] Searching for globals ... DONE
[10:30:48.763] - globals: [0] <none>
[10:30:48.763] getGlobalsAndPackages() ... DONE
[10:30:48.763]    + additional globals found: [n=0] 
[10:30:48.763]    + additional namespaces needed: [n=0] 
[10:30:48.763]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.763]  - seeds: <none>
[10:30:48.764]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.764] getGlobalsAndPackages() ...
[10:30:48.764] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.764] Resolving globals: FALSE
[10:30:48.764] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[10:30:48.765] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:48.765] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.765] 
[10:30:48.765] getGlobalsAndPackages() ... DONE
[10:30:48.765] run() for ‘Future’ ...
[10:30:48.766] - state: ‘created’
[10:30:48.766] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.766] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.766] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.766]   - Field: ‘label’
[10:30:48.766]   - Field: ‘local’
[10:30:48.766]   - Field: ‘owner’
[10:30:48.766]   - Field: ‘envir’
[10:30:48.767]   - Field: ‘packages’
[10:30:48.767]   - Field: ‘gc’
[10:30:48.767]   - Field: ‘conditions’
[10:30:48.767]   - Field: ‘expr’
[10:30:48.767]   - Field: ‘uuid’
[10:30:48.767]   - Field: ‘seed’
[10:30:48.767]   - Field: ‘version’
[10:30:48.767]   - Field: ‘result’
[10:30:48.767]   - Field: ‘asynchronous’
[10:30:48.767]   - Field: ‘calls’
[10:30:48.767]   - Field: ‘globals’
[10:30:48.768]   - Field: ‘stdout’
[10:30:48.768]   - Field: ‘earlySignal’
[10:30:48.768]   - Field: ‘lazy’
[10:30:48.768]   - Field: ‘state’
[10:30:48.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.768] - Launch lazy future ...
[10:30:48.768] Packages needed by the future expression (n = 0): <none>
[10:30:48.768] Packages needed by future strategies (n = 0): <none>
[10:30:48.769] {
[10:30:48.769]     {
[10:30:48.769]         {
[10:30:48.769]             ...future.startTime <- base::Sys.time()
[10:30:48.769]             {
[10:30:48.769]                 {
[10:30:48.769]                   {
[10:30:48.769]                     base::local({
[10:30:48.769]                       has_future <- base::requireNamespace("future", 
[10:30:48.769]                         quietly = TRUE)
[10:30:48.769]                       if (has_future) {
[10:30:48.769]                         ns <- base::getNamespace("future")
[10:30:48.769]                         version <- ns[[".package"]][["version"]]
[10:30:48.769]                         if (is.null(version)) 
[10:30:48.769]                           version <- utils::packageVersion("future")
[10:30:48.769]                       }
[10:30:48.769]                       else {
[10:30:48.769]                         version <- NULL
[10:30:48.769]                       }
[10:30:48.769]                       if (!has_future || version < "1.8.0") {
[10:30:48.769]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.769]                           "", base::R.version$version.string), 
[10:30:48.769]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.769]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.769]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.769]                             "release", "version")], collapse = " "), 
[10:30:48.769]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.769]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.769]                           info)
[10:30:48.769]                         info <- base::paste(info, collapse = "; ")
[10:30:48.769]                         if (!has_future) {
[10:30:48.769]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.769]                             info)
[10:30:48.769]                         }
[10:30:48.769]                         else {
[10:30:48.769]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.769]                             info, version)
[10:30:48.769]                         }
[10:30:48.769]                         base::stop(msg)
[10:30:48.769]                       }
[10:30:48.769]                     })
[10:30:48.769]                   }
[10:30:48.769]                   ...future.strategy.old <- future::plan("list")
[10:30:48.769]                   options(future.plan = NULL)
[10:30:48.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.769]                 }
[10:30:48.769]                 ...future.workdir <- getwd()
[10:30:48.769]             }
[10:30:48.769]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.769]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.769]         }
[10:30:48.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.769]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.769]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.769]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.769]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.769]             base::names(...future.oldOptions))
[10:30:48.769]     }
[10:30:48.769]     if (FALSE) {
[10:30:48.769]     }
[10:30:48.769]     else {
[10:30:48.769]         if (TRUE) {
[10:30:48.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.769]                 open = "w")
[10:30:48.769]         }
[10:30:48.769]         else {
[10:30:48.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.769]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.769]         }
[10:30:48.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.769]             base::sink(type = "output", split = FALSE)
[10:30:48.769]             base::close(...future.stdout)
[10:30:48.769]         }, add = TRUE)
[10:30:48.769]     }
[10:30:48.769]     ...future.frame <- base::sys.nframe()
[10:30:48.769]     ...future.conditions <- base::list()
[10:30:48.769]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.769]     if (FALSE) {
[10:30:48.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.769]     }
[10:30:48.769]     ...future.result <- base::tryCatch({
[10:30:48.769]         base::withCallingHandlers({
[10:30:48.769]             ...future.value <- base::withVisible(base::local({
[10:30:48.769]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.769]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.769]                   ...future.globals.maxSize)) {
[10:30:48.769]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.769]                   on.exit(options(oopts), add = TRUE)
[10:30:48.769]                 }
[10:30:48.769]                 {
[10:30:48.769]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.769]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.769]                     USE.NAMES = FALSE)
[10:30:48.769]                   do.call(mapply, args = args)
[10:30:48.769]                 }
[10:30:48.769]             }))
[10:30:48.769]             future::FutureResult(value = ...future.value$value, 
[10:30:48.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.769]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.769]                     ...future.globalenv.names))
[10:30:48.769]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.769]         }, condition = base::local({
[10:30:48.769]             c <- base::c
[10:30:48.769]             inherits <- base::inherits
[10:30:48.769]             invokeRestart <- base::invokeRestart
[10:30:48.769]             length <- base::length
[10:30:48.769]             list <- base::list
[10:30:48.769]             seq.int <- base::seq.int
[10:30:48.769]             signalCondition <- base::signalCondition
[10:30:48.769]             sys.calls <- base::sys.calls
[10:30:48.769]             `[[` <- base::`[[`
[10:30:48.769]             `+` <- base::`+`
[10:30:48.769]             `<<-` <- base::`<<-`
[10:30:48.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.769]                   3L)]
[10:30:48.769]             }
[10:30:48.769]             function(cond) {
[10:30:48.769]                 is_error <- inherits(cond, "error")
[10:30:48.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.769]                   NULL)
[10:30:48.769]                 if (is_error) {
[10:30:48.769]                   sessionInformation <- function() {
[10:30:48.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.769]                       search = base::search(), system = base::Sys.info())
[10:30:48.769]                   }
[10:30:48.769]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.769]                     cond$call), session = sessionInformation(), 
[10:30:48.769]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.769]                   signalCondition(cond)
[10:30:48.769]                 }
[10:30:48.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.769]                 "immediateCondition"))) {
[10:30:48.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.769]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.769]                   if (TRUE && !signal) {
[10:30:48.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.769]                     {
[10:30:48.769]                       inherits <- base::inherits
[10:30:48.769]                       invokeRestart <- base::invokeRestart
[10:30:48.769]                       is.null <- base::is.null
[10:30:48.769]                       muffled <- FALSE
[10:30:48.769]                       if (inherits(cond, "message")) {
[10:30:48.769]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.769]                         if (muffled) 
[10:30:48.769]                           invokeRestart("muffleMessage")
[10:30:48.769]                       }
[10:30:48.769]                       else if (inherits(cond, "warning")) {
[10:30:48.769]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.769]                         if (muffled) 
[10:30:48.769]                           invokeRestart("muffleWarning")
[10:30:48.769]                       }
[10:30:48.769]                       else if (inherits(cond, "condition")) {
[10:30:48.769]                         if (!is.null(pattern)) {
[10:30:48.769]                           computeRestarts <- base::computeRestarts
[10:30:48.769]                           grepl <- base::grepl
[10:30:48.769]                           restarts <- computeRestarts(cond)
[10:30:48.769]                           for (restart in restarts) {
[10:30:48.769]                             name <- restart$name
[10:30:48.769]                             if (is.null(name)) 
[10:30:48.769]                               next
[10:30:48.769]                             if (!grepl(pattern, name)) 
[10:30:48.769]                               next
[10:30:48.769]                             invokeRestart(restart)
[10:30:48.769]                             muffled <- TRUE
[10:30:48.769]                             break
[10:30:48.769]                           }
[10:30:48.769]                         }
[10:30:48.769]                       }
[10:30:48.769]                       invisible(muffled)
[10:30:48.769]                     }
[10:30:48.769]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.769]                   }
[10:30:48.769]                 }
[10:30:48.769]                 else {
[10:30:48.769]                   if (TRUE) {
[10:30:48.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.769]                     {
[10:30:48.769]                       inherits <- base::inherits
[10:30:48.769]                       invokeRestart <- base::invokeRestart
[10:30:48.769]                       is.null <- base::is.null
[10:30:48.769]                       muffled <- FALSE
[10:30:48.769]                       if (inherits(cond, "message")) {
[10:30:48.769]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.769]                         if (muffled) 
[10:30:48.769]                           invokeRestart("muffleMessage")
[10:30:48.769]                       }
[10:30:48.769]                       else if (inherits(cond, "warning")) {
[10:30:48.769]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.769]                         if (muffled) 
[10:30:48.769]                           invokeRestart("muffleWarning")
[10:30:48.769]                       }
[10:30:48.769]                       else if (inherits(cond, "condition")) {
[10:30:48.769]                         if (!is.null(pattern)) {
[10:30:48.769]                           computeRestarts <- base::computeRestarts
[10:30:48.769]                           grepl <- base::grepl
[10:30:48.769]                           restarts <- computeRestarts(cond)
[10:30:48.769]                           for (restart in restarts) {
[10:30:48.769]                             name <- restart$name
[10:30:48.769]                             if (is.null(name)) 
[10:30:48.769]                               next
[10:30:48.769]                             if (!grepl(pattern, name)) 
[10:30:48.769]                               next
[10:30:48.769]                             invokeRestart(restart)
[10:30:48.769]                             muffled <- TRUE
[10:30:48.769]                             break
[10:30:48.769]                           }
[10:30:48.769]                         }
[10:30:48.769]                       }
[10:30:48.769]                       invisible(muffled)
[10:30:48.769]                     }
[10:30:48.769]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.769]                   }
[10:30:48.769]                 }
[10:30:48.769]             }
[10:30:48.769]         }))
[10:30:48.769]     }, error = function(ex) {
[10:30:48.769]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.769]                 ...future.rng), started = ...future.startTime, 
[10:30:48.769]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.769]             version = "1.8"), class = "FutureResult")
[10:30:48.769]     }, finally = {
[10:30:48.769]         if (!identical(...future.workdir, getwd())) 
[10:30:48.769]             setwd(...future.workdir)
[10:30:48.769]         {
[10:30:48.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.769]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.769]             }
[10:30:48.769]             base::options(...future.oldOptions)
[10:30:48.769]             if (.Platform$OS.type == "windows") {
[10:30:48.769]                 old_names <- names(...future.oldEnvVars)
[10:30:48.769]                 envs <- base::Sys.getenv()
[10:30:48.769]                 names <- names(envs)
[10:30:48.769]                 common <- intersect(names, old_names)
[10:30:48.769]                 added <- setdiff(names, old_names)
[10:30:48.769]                 removed <- setdiff(old_names, names)
[10:30:48.769]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.769]                   envs[common]]
[10:30:48.769]                 NAMES <- toupper(changed)
[10:30:48.769]                 args <- list()
[10:30:48.769]                 for (kk in seq_along(NAMES)) {
[10:30:48.769]                   name <- changed[[kk]]
[10:30:48.769]                   NAME <- NAMES[[kk]]
[10:30:48.769]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.769]                     next
[10:30:48.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.769]                 }
[10:30:48.769]                 NAMES <- toupper(added)
[10:30:48.769]                 for (kk in seq_along(NAMES)) {
[10:30:48.769]                   name <- added[[kk]]
[10:30:48.769]                   NAME <- NAMES[[kk]]
[10:30:48.769]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.769]                     next
[10:30:48.769]                   args[[name]] <- ""
[10:30:48.769]                 }
[10:30:48.769]                 NAMES <- toupper(removed)
[10:30:48.769]                 for (kk in seq_along(NAMES)) {
[10:30:48.769]                   name <- removed[[kk]]
[10:30:48.769]                   NAME <- NAMES[[kk]]
[10:30:48.769]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.769]                     next
[10:30:48.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.769]                 }
[10:30:48.769]                 if (length(args) > 0) 
[10:30:48.769]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.769]             }
[10:30:48.769]             else {
[10:30:48.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.769]             }
[10:30:48.769]             {
[10:30:48.769]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.769]                   0L) {
[10:30:48.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.769]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.769]                   base::options(opts)
[10:30:48.769]                 }
[10:30:48.769]                 {
[10:30:48.769]                   {
[10:30:48.769]                     base::assign(".Random.seed", c(10407L, 1494356689L, 
[10:30:48.769]                     1190224784L, 312275249L, 1713452462L, 635500387L, 
[10:30:48.769]                     1139696322L), envir = base::globalenv(), 
[10:30:48.769]                       inherits = FALSE)
[10:30:48.769]                     NULL
[10:30:48.769]                   }
[10:30:48.769]                   options(future.plan = NULL)
[10:30:48.769]                   if (is.na(NA_character_)) 
[10:30:48.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.769]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.769]                     .init = FALSE)
[10:30:48.769]                 }
[10:30:48.769]             }
[10:30:48.769]         }
[10:30:48.769]     })
[10:30:48.769]     if (TRUE) {
[10:30:48.769]         base::sink(type = "output", split = FALSE)
[10:30:48.769]         if (TRUE) {
[10:30:48.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.769]         }
[10:30:48.769]         else {
[10:30:48.769]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.769]         }
[10:30:48.769]         base::close(...future.stdout)
[10:30:48.769]         ...future.stdout <- NULL
[10:30:48.769]     }
[10:30:48.769]     ...future.result$conditions <- ...future.conditions
[10:30:48.769]     ...future.result$finished <- base::Sys.time()
[10:30:48.769]     ...future.result
[10:30:48.769] }
[10:30:48.771] assign_globals() ...
[10:30:48.771] List of 5
[10:30:48.771]  $ ...future.FUN            :function (x, y)  
[10:30:48.771]  $ MoreArgs                 :List of 1
[10:30:48.771]   ..$ y: int [1:2] 3 4
[10:30:48.771]  $ ...future.elements_ii    :List of 1
[10:30:48.771]   ..$ x:List of 2
[10:30:48.771]   .. ..$ : int 1
[10:30:48.771]   .. ..$ : int 2
[10:30:48.771]  $ ...future.seeds_ii       : NULL
[10:30:48.771]  $ ...future.globals.maxSize: NULL
[10:30:48.771]  - attr(*, "where")=List of 5
[10:30:48.771]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.771]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.771]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.771]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.771]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.771]  - attr(*, "resolved")= logi FALSE
[10:30:48.771]  - attr(*, "total_size")= num 1872
[10:30:48.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.771]  - attr(*, "already-done")= logi TRUE
[10:30:48.779] - reassign environment for ‘...future.FUN’
[10:30:48.779] - copied ‘...future.FUN’ to environment
[10:30:48.779] - copied ‘MoreArgs’ to environment
[10:30:48.779] - copied ‘...future.elements_ii’ to environment
[10:30:48.779] - copied ‘...future.seeds_ii’ to environment
[10:30:48.779] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.779] assign_globals() ... done
[10:30:48.780] plan(): Setting new future strategy stack:
[10:30:48.780] List of future strategies:
[10:30:48.780] 1. sequential:
[10:30:48.780]    - args: function (..., envir = parent.frame())
[10:30:48.780]    - tweaked: FALSE
[10:30:48.780]    - call: NULL
[10:30:48.780] plan(): nbrOfWorkers() = 1
[10:30:48.781] plan(): Setting new future strategy stack:
[10:30:48.781] List of future strategies:
[10:30:48.781] 1. sequential:
[10:30:48.781]    - args: function (..., envir = parent.frame())
[10:30:48.781]    - tweaked: FALSE
[10:30:48.781]    - call: plan(strategy)
[10:30:48.781] plan(): nbrOfWorkers() = 1
[10:30:48.782] SequentialFuture started (and completed)
[10:30:48.782] - Launch lazy future ... done
[10:30:48.782] run() for ‘SequentialFuture’ ... done
[10:30:48.782] Created future:
[10:30:48.782] SequentialFuture:
[10:30:48.782] Label: ‘future_.mapply-1’
[10:30:48.782] Expression:
[10:30:48.782] {
[10:30:48.782]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.782]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.782]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.782]         on.exit(options(oopts), add = TRUE)
[10:30:48.782]     }
[10:30:48.782]     {
[10:30:48.782]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.782]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.782]         do.call(mapply, args = args)
[10:30:48.782]     }
[10:30:48.782] }
[10:30:48.782] Lazy evaluation: FALSE
[10:30:48.782] Asynchronous evaluation: FALSE
[10:30:48.782] Local evaluation: TRUE
[10:30:48.782] Environment: R_GlobalEnv
[10:30:48.782] Capture standard output: TRUE
[10:30:48.782] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.782] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.782] Packages: <none>
[10:30:48.782] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.782] Resolved: TRUE
[10:30:48.782] Value: 112 bytes of class ‘list’
[10:30:48.782] Early signaling: FALSE
[10:30:48.782] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.782] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.783] Chunk #1 of 1 ... DONE
[10:30:48.783] Launching 1 futures (chunks) ... DONE
[10:30:48.783] Resolving 1 futures (chunks) ...
[10:30:48.783] resolve() on list ...
[10:30:48.783]  recursive: 0
[10:30:48.783]  length: 1
[10:30:48.784] 
[10:30:48.784] resolved() for ‘SequentialFuture’ ...
[10:30:48.784] - state: ‘finished’
[10:30:48.784] - run: TRUE
[10:30:48.784] - result: ‘FutureResult’
[10:30:48.784] resolved() for ‘SequentialFuture’ ... done
[10:30:48.784] Future #1
[10:30:48.784] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.784] - nx: 1
[10:30:48.784] - relay: TRUE
[10:30:48.784] - stdout: TRUE
[10:30:48.785] - signal: TRUE
[10:30:48.785] - resignal: FALSE
[10:30:48.785] - force: TRUE
[10:30:48.785] - relayed: [n=1] FALSE
[10:30:48.785] - queued futures: [n=1] FALSE
[10:30:48.785]  - until=1
[10:30:48.785]  - relaying element #1
[10:30:48.785] - relayed: [n=1] TRUE
[10:30:48.785] - queued futures: [n=1] TRUE
[10:30:48.786] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.786]  length: 0 (resolved future 1)
[10:30:48.786] Relaying remaining futures
[10:30:48.786] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.786] - nx: 1
[10:30:48.786] - relay: TRUE
[10:30:48.786] - stdout: TRUE
[10:30:48.786] - signal: TRUE
[10:30:48.786] - resignal: FALSE
[10:30:48.786] - force: TRUE
[10:30:48.786] - relayed: [n=1] TRUE
[10:30:48.786] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.787] - relayed: [n=1] TRUE
[10:30:48.787] - queued futures: [n=1] TRUE
[10:30:48.787] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.787] resolve() on list ... DONE
[10:30:48.787]  - Number of value chunks collected: 1
[10:30:48.787] Resolving 1 futures (chunks) ... DONE
[10:30:48.787] Reducing values from 1 chunks ...
[10:30:48.787]  - Number of values collected after concatenation: 2
[10:30:48.787]  - Number of values expected: 2
[10:30:48.787] Reducing values from 1 chunks ... DONE
[10:30:48.788] future_mapply() ... DONE
- Recycle arguments to same length ...
[10:30:48.788] future_mapply() ...
[10:30:48.788] Number of chunks: 1
[10:30:48.788] getGlobalsAndPackagesXApply() ...
[10:30:48.788]  - future.globals: TRUE
[10:30:48.788] getGlobalsAndPackages() ...
[10:30:48.788] Searching for globals...
[10:30:48.789] - globals found: [1] ‘FUN’
[10:30:48.789] Searching for globals ... DONE
[10:30:48.789] Resolving globals: FALSE
[10:30:48.789] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:48.790] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:48.790] - globals: [1] ‘FUN’
[10:30:48.790] 
[10:30:48.790] getGlobalsAndPackages() ... DONE
[10:30:48.790]  - globals found/used: [n=1] ‘FUN’
[10:30:48.790]  - needed namespaces: [n=0] 
[10:30:48.790] Finding globals ... DONE
[10:30:48.791] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.791] List of 2
[10:30:48.791]  $ ...future.FUN:function (x, ...)  
[10:30:48.791]  $ MoreArgs     : NULL
[10:30:48.791]  - attr(*, "where")=List of 2
[10:30:48.791]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.791]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.791]  - attr(*, "resolved")= logi FALSE
[10:30:48.791]  - attr(*, "total_size")= num NA
[10:30:48.793] Packages to be attached in all futures: [n=0] 
[10:30:48.793] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.793] Number of futures (= number of chunks): 1
[10:30:48.793] Launching 1 futures (chunks) ...
[10:30:48.794] Chunk #1 of 1 ...
[10:30:48.794]  - Finding globals in '...' for chunk #1 ...
[10:30:48.794] getGlobalsAndPackages() ...
[10:30:48.794] Searching for globals...
[10:30:48.794] 
[10:30:48.794] Searching for globals ... DONE
[10:30:48.794] - globals: [0] <none>
[10:30:48.794] getGlobalsAndPackages() ... DONE
[10:30:48.795]    + additional globals found: [n=0] 
[10:30:48.795]    + additional namespaces needed: [n=0] 
[10:30:48.795]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.795]  - seeds: <none>
[10:30:48.795]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.795] getGlobalsAndPackages() ...
[10:30:48.795] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.795] Resolving globals: FALSE
[10:30:48.796] The total size of the 5 globals is 504 bytes (504 bytes)
[10:30:48.796] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.796] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.796] 
[10:30:48.798] getGlobalsAndPackages() ... DONE
[10:30:48.799] run() for ‘Future’ ...
[10:30:48.799] - state: ‘created’
[10:30:48.799] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.799] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.800]   - Field: ‘label’
[10:30:48.800]   - Field: ‘local’
[10:30:48.800]   - Field: ‘owner’
[10:30:48.800]   - Field: ‘envir’
[10:30:48.800]   - Field: ‘packages’
[10:30:48.800]   - Field: ‘gc’
[10:30:48.800]   - Field: ‘conditions’
[10:30:48.800]   - Field: ‘expr’
[10:30:48.801]   - Field: ‘uuid’
[10:30:48.801]   - Field: ‘seed’
[10:30:48.801]   - Field: ‘version’
[10:30:48.801]   - Field: ‘result’
[10:30:48.801]   - Field: ‘asynchronous’
[10:30:48.801]   - Field: ‘calls’
[10:30:48.801]   - Field: ‘globals’
[10:30:48.801]   - Field: ‘stdout’
[10:30:48.801]   - Field: ‘earlySignal’
[10:30:48.801]   - Field: ‘lazy’
[10:30:48.802]   - Field: ‘state’
[10:30:48.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.802] - Launch lazy future ...
[10:30:48.802] Packages needed by the future expression (n = 0): <none>
[10:30:48.802] Packages needed by future strategies (n = 0): <none>
[10:30:48.802] {
[10:30:48.802]     {
[10:30:48.802]         {
[10:30:48.802]             ...future.startTime <- base::Sys.time()
[10:30:48.802]             {
[10:30:48.802]                 {
[10:30:48.802]                   {
[10:30:48.802]                     base::local({
[10:30:48.802]                       has_future <- base::requireNamespace("future", 
[10:30:48.802]                         quietly = TRUE)
[10:30:48.802]                       if (has_future) {
[10:30:48.802]                         ns <- base::getNamespace("future")
[10:30:48.802]                         version <- ns[[".package"]][["version"]]
[10:30:48.802]                         if (is.null(version)) 
[10:30:48.802]                           version <- utils::packageVersion("future")
[10:30:48.802]                       }
[10:30:48.802]                       else {
[10:30:48.802]                         version <- NULL
[10:30:48.802]                       }
[10:30:48.802]                       if (!has_future || version < "1.8.0") {
[10:30:48.802]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.802]                           "", base::R.version$version.string), 
[10:30:48.802]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.802]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.802]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.802]                             "release", "version")], collapse = " "), 
[10:30:48.802]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.802]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.802]                           info)
[10:30:48.802]                         info <- base::paste(info, collapse = "; ")
[10:30:48.802]                         if (!has_future) {
[10:30:48.802]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.802]                             info)
[10:30:48.802]                         }
[10:30:48.802]                         else {
[10:30:48.802]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.802]                             info, version)
[10:30:48.802]                         }
[10:30:48.802]                         base::stop(msg)
[10:30:48.802]                       }
[10:30:48.802]                     })
[10:30:48.802]                   }
[10:30:48.802]                   ...future.strategy.old <- future::plan("list")
[10:30:48.802]                   options(future.plan = NULL)
[10:30:48.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.802]                 }
[10:30:48.802]                 ...future.workdir <- getwd()
[10:30:48.802]             }
[10:30:48.802]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.802]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.802]         }
[10:30:48.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.802]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.802]             base::names(...future.oldOptions))
[10:30:48.802]     }
[10:30:48.802]     if (FALSE) {
[10:30:48.802]     }
[10:30:48.802]     else {
[10:30:48.802]         if (TRUE) {
[10:30:48.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.802]                 open = "w")
[10:30:48.802]         }
[10:30:48.802]         else {
[10:30:48.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.802]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.802]         }
[10:30:48.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.802]             base::sink(type = "output", split = FALSE)
[10:30:48.802]             base::close(...future.stdout)
[10:30:48.802]         }, add = TRUE)
[10:30:48.802]     }
[10:30:48.802]     ...future.frame <- base::sys.nframe()
[10:30:48.802]     ...future.conditions <- base::list()
[10:30:48.802]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.802]     if (FALSE) {
[10:30:48.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.802]     }
[10:30:48.802]     ...future.result <- base::tryCatch({
[10:30:48.802]         base::withCallingHandlers({
[10:30:48.802]             ...future.value <- base::withVisible(base::local({
[10:30:48.802]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.802]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.802]                   ...future.globals.maxSize)) {
[10:30:48.802]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.802]                   on.exit(options(oopts), add = TRUE)
[10:30:48.802]                 }
[10:30:48.802]                 {
[10:30:48.802]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.802]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.802]                     USE.NAMES = FALSE)
[10:30:48.802]                   do.call(mapply, args = args)
[10:30:48.802]                 }
[10:30:48.802]             }))
[10:30:48.802]             future::FutureResult(value = ...future.value$value, 
[10:30:48.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.802]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.802]                     ...future.globalenv.names))
[10:30:48.802]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.802]         }, condition = base::local({
[10:30:48.802]             c <- base::c
[10:30:48.802]             inherits <- base::inherits
[10:30:48.802]             invokeRestart <- base::invokeRestart
[10:30:48.802]             length <- base::length
[10:30:48.802]             list <- base::list
[10:30:48.802]             seq.int <- base::seq.int
[10:30:48.802]             signalCondition <- base::signalCondition
[10:30:48.802]             sys.calls <- base::sys.calls
[10:30:48.802]             `[[` <- base::`[[`
[10:30:48.802]             `+` <- base::`+`
[10:30:48.802]             `<<-` <- base::`<<-`
[10:30:48.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.802]                   3L)]
[10:30:48.802]             }
[10:30:48.802]             function(cond) {
[10:30:48.802]                 is_error <- inherits(cond, "error")
[10:30:48.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.802]                   NULL)
[10:30:48.802]                 if (is_error) {
[10:30:48.802]                   sessionInformation <- function() {
[10:30:48.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.802]                       search = base::search(), system = base::Sys.info())
[10:30:48.802]                   }
[10:30:48.802]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.802]                     cond$call), session = sessionInformation(), 
[10:30:48.802]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.802]                   signalCondition(cond)
[10:30:48.802]                 }
[10:30:48.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.802]                 "immediateCondition"))) {
[10:30:48.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.802]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.802]                   if (TRUE && !signal) {
[10:30:48.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.802]                     {
[10:30:48.802]                       inherits <- base::inherits
[10:30:48.802]                       invokeRestart <- base::invokeRestart
[10:30:48.802]                       is.null <- base::is.null
[10:30:48.802]                       muffled <- FALSE
[10:30:48.802]                       if (inherits(cond, "message")) {
[10:30:48.802]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.802]                         if (muffled) 
[10:30:48.802]                           invokeRestart("muffleMessage")
[10:30:48.802]                       }
[10:30:48.802]                       else if (inherits(cond, "warning")) {
[10:30:48.802]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.802]                         if (muffled) 
[10:30:48.802]                           invokeRestart("muffleWarning")
[10:30:48.802]                       }
[10:30:48.802]                       else if (inherits(cond, "condition")) {
[10:30:48.802]                         if (!is.null(pattern)) {
[10:30:48.802]                           computeRestarts <- base::computeRestarts
[10:30:48.802]                           grepl <- base::grepl
[10:30:48.802]                           restarts <- computeRestarts(cond)
[10:30:48.802]                           for (restart in restarts) {
[10:30:48.802]                             name <- restart$name
[10:30:48.802]                             if (is.null(name)) 
[10:30:48.802]                               next
[10:30:48.802]                             if (!grepl(pattern, name)) 
[10:30:48.802]                               next
[10:30:48.802]                             invokeRestart(restart)
[10:30:48.802]                             muffled <- TRUE
[10:30:48.802]                             break
[10:30:48.802]                           }
[10:30:48.802]                         }
[10:30:48.802]                       }
[10:30:48.802]                       invisible(muffled)
[10:30:48.802]                     }
[10:30:48.802]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.802]                   }
[10:30:48.802]                 }
[10:30:48.802]                 else {
[10:30:48.802]                   if (TRUE) {
[10:30:48.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.802]                     {
[10:30:48.802]                       inherits <- base::inherits
[10:30:48.802]                       invokeRestart <- base::invokeRestart
[10:30:48.802]                       is.null <- base::is.null
[10:30:48.802]                       muffled <- FALSE
[10:30:48.802]                       if (inherits(cond, "message")) {
[10:30:48.802]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.802]                         if (muffled) 
[10:30:48.802]                           invokeRestart("muffleMessage")
[10:30:48.802]                       }
[10:30:48.802]                       else if (inherits(cond, "warning")) {
[10:30:48.802]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.802]                         if (muffled) 
[10:30:48.802]                           invokeRestart("muffleWarning")
[10:30:48.802]                       }
[10:30:48.802]                       else if (inherits(cond, "condition")) {
[10:30:48.802]                         if (!is.null(pattern)) {
[10:30:48.802]                           computeRestarts <- base::computeRestarts
[10:30:48.802]                           grepl <- base::grepl
[10:30:48.802]                           restarts <- computeRestarts(cond)
[10:30:48.802]                           for (restart in restarts) {
[10:30:48.802]                             name <- restart$name
[10:30:48.802]                             if (is.null(name)) 
[10:30:48.802]                               next
[10:30:48.802]                             if (!grepl(pattern, name)) 
[10:30:48.802]                               next
[10:30:48.802]                             invokeRestart(restart)
[10:30:48.802]                             muffled <- TRUE
[10:30:48.802]                             break
[10:30:48.802]                           }
[10:30:48.802]                         }
[10:30:48.802]                       }
[10:30:48.802]                       invisible(muffled)
[10:30:48.802]                     }
[10:30:48.802]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.802]                   }
[10:30:48.802]                 }
[10:30:48.802]             }
[10:30:48.802]         }))
[10:30:48.802]     }, error = function(ex) {
[10:30:48.802]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.802]                 ...future.rng), started = ...future.startTime, 
[10:30:48.802]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.802]             version = "1.8"), class = "FutureResult")
[10:30:48.802]     }, finally = {
[10:30:48.802]         if (!identical(...future.workdir, getwd())) 
[10:30:48.802]             setwd(...future.workdir)
[10:30:48.802]         {
[10:30:48.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.802]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.802]             }
[10:30:48.802]             base::options(...future.oldOptions)
[10:30:48.802]             if (.Platform$OS.type == "windows") {
[10:30:48.802]                 old_names <- names(...future.oldEnvVars)
[10:30:48.802]                 envs <- base::Sys.getenv()
[10:30:48.802]                 names <- names(envs)
[10:30:48.802]                 common <- intersect(names, old_names)
[10:30:48.802]                 added <- setdiff(names, old_names)
[10:30:48.802]                 removed <- setdiff(old_names, names)
[10:30:48.802]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.802]                   envs[common]]
[10:30:48.802]                 NAMES <- toupper(changed)
[10:30:48.802]                 args <- list()
[10:30:48.802]                 for (kk in seq_along(NAMES)) {
[10:30:48.802]                   name <- changed[[kk]]
[10:30:48.802]                   NAME <- NAMES[[kk]]
[10:30:48.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.802]                     next
[10:30:48.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.802]                 }
[10:30:48.802]                 NAMES <- toupper(added)
[10:30:48.802]                 for (kk in seq_along(NAMES)) {
[10:30:48.802]                   name <- added[[kk]]
[10:30:48.802]                   NAME <- NAMES[[kk]]
[10:30:48.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.802]                     next
[10:30:48.802]                   args[[name]] <- ""
[10:30:48.802]                 }
[10:30:48.802]                 NAMES <- toupper(removed)
[10:30:48.802]                 for (kk in seq_along(NAMES)) {
[10:30:48.802]                   name <- removed[[kk]]
[10:30:48.802]                   NAME <- NAMES[[kk]]
[10:30:48.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.802]                     next
[10:30:48.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.802]                 }
[10:30:48.802]                 if (length(args) > 0) 
[10:30:48.802]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.802]             }
[10:30:48.802]             else {
[10:30:48.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.802]             }
[10:30:48.802]             {
[10:30:48.802]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.802]                   0L) {
[10:30:48.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.802]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.802]                   base::options(opts)
[10:30:48.802]                 }
[10:30:48.802]                 {
[10:30:48.802]                   {
[10:30:48.802]                     base::assign(".Random.seed", c(10407L, 1494356689L, 
[10:30:48.802]                     1190224784L, 312275249L, 1713452462L, 635500387L, 
[10:30:48.802]                     1139696322L), envir = base::globalenv(), 
[10:30:48.802]                       inherits = FALSE)
[10:30:48.802]                     NULL
[10:30:48.802]                   }
[10:30:48.802]                   options(future.plan = NULL)
[10:30:48.802]                   if (is.na(NA_character_)) 
[10:30:48.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.802]                     .init = FALSE)
[10:30:48.802]                 }
[10:30:48.802]             }
[10:30:48.802]         }
[10:30:48.802]     })
[10:30:48.802]     if (TRUE) {
[10:30:48.802]         base::sink(type = "output", split = FALSE)
[10:30:48.802]         if (TRUE) {
[10:30:48.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.802]         }
[10:30:48.802]         else {
[10:30:48.802]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.802]         }
[10:30:48.802]         base::close(...future.stdout)
[10:30:48.802]         ...future.stdout <- NULL
[10:30:48.802]     }
[10:30:48.802]     ...future.result$conditions <- ...future.conditions
[10:30:48.802]     ...future.result$finished <- base::Sys.time()
[10:30:48.802]     ...future.result
[10:30:48.802] }
[10:30:48.804] assign_globals() ...
[10:30:48.804] List of 5
[10:30:48.804]  $ ...future.FUN            :function (x, ...)  
[10:30:48.804]  $ MoreArgs                 : NULL
[10:30:48.804]  $ ...future.elements_ii    :List of 2
[10:30:48.804]   ..$ :List of 4
[10:30:48.804]   .. ..$ : int 1
[10:30:48.804]   .. ..$ : int 2
[10:30:48.804]   .. ..$ : int 3
[10:30:48.804]   .. ..$ : int 4
[10:30:48.804]   ..$ :List of 4
[10:30:48.804]   .. ..$ : int 2
[10:30:48.804]   .. ..$ : int 1
[10:30:48.804]   .. ..$ : int 2
[10:30:48.804]   .. ..$ : int 1
[10:30:48.804]  $ ...future.seeds_ii       : NULL
[10:30:48.804]  $ ...future.globals.maxSize: NULL
[10:30:48.804]  - attr(*, "where")=List of 5
[10:30:48.804]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.804]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.804]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.804]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.804]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.804]  - attr(*, "resolved")= logi FALSE
[10:30:48.804]  - attr(*, "total_size")= num 504
[10:30:48.804]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.804]  - attr(*, "already-done")= logi TRUE
[10:30:48.811] - copied ‘...future.FUN’ to environment
[10:30:48.811] - copied ‘MoreArgs’ to environment
[10:30:48.811] - copied ‘...future.elements_ii’ to environment
[10:30:48.812] - copied ‘...future.seeds_ii’ to environment
[10:30:48.812] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.812] assign_globals() ... done
[10:30:48.812] plan(): Setting new future strategy stack:
[10:30:48.812] List of future strategies:
[10:30:48.812] 1. sequential:
[10:30:48.812]    - args: function (..., envir = parent.frame())
[10:30:48.812]    - tweaked: FALSE
[10:30:48.812]    - call: NULL
[10:30:48.812] plan(): nbrOfWorkers() = 1
[10:30:48.813] plan(): Setting new future strategy stack:
[10:30:48.813] List of future strategies:
[10:30:48.813] 1. sequential:
[10:30:48.813]    - args: function (..., envir = parent.frame())
[10:30:48.813]    - tweaked: FALSE
[10:30:48.813]    - call: plan(strategy)
[10:30:48.814] plan(): nbrOfWorkers() = 1
[10:30:48.814] SequentialFuture started (and completed)
[10:30:48.814] - Launch lazy future ... done
[10:30:48.814] run() for ‘SequentialFuture’ ... done
[10:30:48.814] Created future:
[10:30:48.814] SequentialFuture:
[10:30:48.814] Label: ‘future_mapply-1’
[10:30:48.814] Expression:
[10:30:48.814] {
[10:30:48.814]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.814]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.814]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.814]         on.exit(options(oopts), add = TRUE)
[10:30:48.814]     }
[10:30:48.814]     {
[10:30:48.814]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.814]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.814]         do.call(mapply, args = args)
[10:30:48.814]     }
[10:30:48.814] }
[10:30:48.814] Lazy evaluation: FALSE
[10:30:48.814] Asynchronous evaluation: FALSE
[10:30:48.814] Local evaluation: TRUE
[10:30:48.814] Environment: R_GlobalEnv
[10:30:48.814] Capture standard output: TRUE
[10:30:48.814] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.814] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.814] Packages: <none>
[10:30:48.814] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.814] Resolved: TRUE
[10:30:48.814] Value: 224 bytes of class ‘list’
[10:30:48.814] Early signaling: FALSE
[10:30:48.814] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.814] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.815] Chunk #1 of 1 ... DONE
[10:30:48.815] Launching 1 futures (chunks) ... DONE
[10:30:48.816] Resolving 1 futures (chunks) ...
[10:30:48.816] resolve() on list ...
[10:30:48.816]  recursive: 0
[10:30:48.816]  length: 1
[10:30:48.816] 
[10:30:48.816] resolved() for ‘SequentialFuture’ ...
[10:30:48.816] - state: ‘finished’
[10:30:48.816] - run: TRUE
[10:30:48.816] - result: ‘FutureResult’
[10:30:48.816] resolved() for ‘SequentialFuture’ ... done
[10:30:48.817] Future #1
[10:30:48.817] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.817] - nx: 1
[10:30:48.817] - relay: TRUE
[10:30:48.817] - stdout: TRUE
[10:30:48.817] - signal: TRUE
[10:30:48.817] - resignal: FALSE
[10:30:48.817] - force: TRUE
[10:30:48.817] - relayed: [n=1] FALSE
[10:30:48.817] - queued futures: [n=1] FALSE
[10:30:48.818]  - until=1
[10:30:48.818]  - relaying element #1
[10:30:48.818] - relayed: [n=1] TRUE
[10:30:48.818] - queued futures: [n=1] TRUE
[10:30:48.818] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.818]  length: 0 (resolved future 1)
[10:30:48.818] Relaying remaining futures
[10:30:48.818] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.818] - nx: 1
[10:30:48.818] - relay: TRUE
[10:30:48.819] - stdout: TRUE
[10:30:48.819] - signal: TRUE
[10:30:48.819] - resignal: FALSE
[10:30:48.819] - force: TRUE
[10:30:48.819] - relayed: [n=1] TRUE
[10:30:48.819] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.819] - relayed: [n=1] TRUE
[10:30:48.819] - queued futures: [n=1] TRUE
[10:30:48.819] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.819] resolve() on list ... DONE
[10:30:48.820]  - Number of value chunks collected: 1
[10:30:48.820] Resolving 1 futures (chunks) ... DONE
[10:30:48.820] Reducing values from 1 chunks ...
[10:30:48.820]  - Number of values collected after concatenation: 4
[10:30:48.820]  - Number of values expected: 4
[10:30:48.820] Reducing values from 1 chunks ... DONE
[10:30:48.822] future_mapply() ... DONE
- Parallel RNG ...
[10:30:48.822] future_mapply() ...
[10:30:48.823] Generating random seeds ...
[10:30:48.823] Generating random seed streams for 4 elements ...
[10:30:48.823] Generating random seed streams for 4 elements ... DONE
[10:30:48.823] Generating random seeds ... DONE
[10:30:48.823] Will set RNG state on exit: 10407, 312275249, -74592902, -695450688, 1139696322, 1629593144, 1452859301
[10:30:48.823] Number of chunks: 1
[10:30:48.823] getGlobalsAndPackagesXApply() ...
[10:30:48.823]  - future.globals: TRUE
[10:30:48.824] getGlobalsAndPackages() ...
[10:30:48.824] Searching for globals...
[10:30:48.825] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:30:48.825] Searching for globals ... DONE
[10:30:48.825] Resolving globals: FALSE
[10:30:48.826] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[10:30:48.826] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[10:30:48.826] - globals: [1] ‘FUN’
[10:30:48.826] - packages: [1] ‘stats’
[10:30:48.827] getGlobalsAndPackages() ... DONE
[10:30:48.827]  - globals found/used: [n=1] ‘FUN’
[10:30:48.827]  - needed namespaces: [n=1] ‘stats’
[10:30:48.827] Finding globals ... DONE
[10:30:48.827] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.827] List of 2
[10:30:48.827]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:30:48.827]  $ MoreArgs     :List of 1
[10:30:48.827]   ..$ min: num 1
[10:30:48.827]  - attr(*, "where")=List of 2
[10:30:48.827]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.827]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.827]  - attr(*, "resolved")= logi FALSE
[10:30:48.827]  - attr(*, "total_size")= num NA
[10:30:48.830] Packages to be attached in all futures: [n=1] ‘stats’
[10:30:48.830] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.830] Number of futures (= number of chunks): 1
[10:30:48.830] Launching 1 futures (chunks) ...
[10:30:48.830] Chunk #1 of 1 ...
[10:30:48.831]  - Finding globals in '...' for chunk #1 ...
[10:30:48.831] getGlobalsAndPackages() ...
[10:30:48.831] Searching for globals...
[10:30:48.831] 
[10:30:48.831] Searching for globals ... DONE
[10:30:48.831] - globals: [0] <none>
[10:30:48.831] getGlobalsAndPackages() ... DONE
[10:30:48.831]    + additional globals found: [n=0] 
[10:30:48.832]    + additional namespaces needed: [n=0] 
[10:30:48.832]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.832]  - seeds: [4] <seeds>
[10:30:48.832]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.832] getGlobalsAndPackages() ...
[10:30:48.832] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.832] Resolving globals: FALSE
[10:30:48.833] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[10:30:48.833] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[10:30:48.833] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.833] - packages: [1] ‘stats’
[10:30:48.834] getGlobalsAndPackages() ... DONE
[10:30:48.834] run() for ‘Future’ ...
[10:30:48.834] - state: ‘created’
[10:30:48.834] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.834] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.834] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.835]   - Field: ‘label’
[10:30:48.835]   - Field: ‘local’
[10:30:48.835]   - Field: ‘owner’
[10:30:48.835]   - Field: ‘envir’
[10:30:48.835]   - Field: ‘packages’
[10:30:48.835]   - Field: ‘gc’
[10:30:48.835]   - Field: ‘conditions’
[10:30:48.835]   - Field: ‘expr’
[10:30:48.835]   - Field: ‘uuid’
[10:30:48.835]   - Field: ‘seed’
[10:30:48.836]   - Field: ‘version’
[10:30:48.836]   - Field: ‘result’
[10:30:48.836]   - Field: ‘asynchronous’
[10:30:48.836]   - Field: ‘calls’
[10:30:48.836]   - Field: ‘globals’
[10:30:48.836]   - Field: ‘stdout’
[10:30:48.836]   - Field: ‘earlySignal’
[10:30:48.836]   - Field: ‘lazy’
[10:30:48.836]   - Field: ‘state’
[10:30:48.836] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.836] - Launch lazy future ...
[10:30:48.837] Packages needed by the future expression (n = 1): ‘stats’
[10:30:48.837] Packages needed by future strategies (n = 0): <none>
[10:30:48.837] {
[10:30:48.837]     {
[10:30:48.837]         {
[10:30:48.837]             ...future.startTime <- base::Sys.time()
[10:30:48.837]             {
[10:30:48.837]                 {
[10:30:48.837]                   {
[10:30:48.837]                     {
[10:30:48.837]                       base::local({
[10:30:48.837]                         has_future <- base::requireNamespace("future", 
[10:30:48.837]                           quietly = TRUE)
[10:30:48.837]                         if (has_future) {
[10:30:48.837]                           ns <- base::getNamespace("future")
[10:30:48.837]                           version <- ns[[".package"]][["version"]]
[10:30:48.837]                           if (is.null(version)) 
[10:30:48.837]                             version <- utils::packageVersion("future")
[10:30:48.837]                         }
[10:30:48.837]                         else {
[10:30:48.837]                           version <- NULL
[10:30:48.837]                         }
[10:30:48.837]                         if (!has_future || version < "1.8.0") {
[10:30:48.837]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.837]                             "", base::R.version$version.string), 
[10:30:48.837]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:48.837]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.837]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.837]                               "release", "version")], collapse = " "), 
[10:30:48.837]                             hostname = base::Sys.info()[["nodename"]])
[10:30:48.837]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.837]                             info)
[10:30:48.837]                           info <- base::paste(info, collapse = "; ")
[10:30:48.837]                           if (!has_future) {
[10:30:48.837]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.837]                               info)
[10:30:48.837]                           }
[10:30:48.837]                           else {
[10:30:48.837]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.837]                               info, version)
[10:30:48.837]                           }
[10:30:48.837]                           base::stop(msg)
[10:30:48.837]                         }
[10:30:48.837]                       })
[10:30:48.837]                     }
[10:30:48.837]                     base::local({
[10:30:48.837]                       for (pkg in "stats") {
[10:30:48.837]                         base::loadNamespace(pkg)
[10:30:48.837]                         base::library(pkg, character.only = TRUE)
[10:30:48.837]                       }
[10:30:48.837]                     })
[10:30:48.837]                   }
[10:30:48.837]                   ...future.strategy.old <- future::plan("list")
[10:30:48.837]                   options(future.plan = NULL)
[10:30:48.837]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.837]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.837]                 }
[10:30:48.837]                 ...future.workdir <- getwd()
[10:30:48.837]             }
[10:30:48.837]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.837]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.837]         }
[10:30:48.837]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.837]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.837]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.837]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.837]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.837]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.837]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.837]             base::names(...future.oldOptions))
[10:30:48.837]     }
[10:30:48.837]     if (FALSE) {
[10:30:48.837]     }
[10:30:48.837]     else {
[10:30:48.837]         if (TRUE) {
[10:30:48.837]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.837]                 open = "w")
[10:30:48.837]         }
[10:30:48.837]         else {
[10:30:48.837]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.837]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.837]         }
[10:30:48.837]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.837]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.837]             base::sink(type = "output", split = FALSE)
[10:30:48.837]             base::close(...future.stdout)
[10:30:48.837]         }, add = TRUE)
[10:30:48.837]     }
[10:30:48.837]     ...future.frame <- base::sys.nframe()
[10:30:48.837]     ...future.conditions <- base::list()
[10:30:48.837]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.837]     if (FALSE) {
[10:30:48.837]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.837]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.837]     }
[10:30:48.837]     ...future.result <- base::tryCatch({
[10:30:48.837]         base::withCallingHandlers({
[10:30:48.837]             ...future.value <- base::withVisible(base::local({
[10:30:48.837]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.837]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.837]                   ...future.globals.maxSize)) {
[10:30:48.837]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.837]                   on.exit(options(oopts), add = TRUE)
[10:30:48.837]                 }
[10:30:48.837]                 {
[10:30:48.837]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:48.837]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:48.837]                       envir = globalenv(), inherits = FALSE)
[10:30:48.837]                     ...future.FUN(...)
[10:30:48.837]                   }
[10:30:48.837]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:48.837]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:48.837]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.837]                     USE.NAMES = FALSE)
[10:30:48.837]                   do.call(mapply, args = args)
[10:30:48.837]                 }
[10:30:48.837]             }))
[10:30:48.837]             future::FutureResult(value = ...future.value$value, 
[10:30:48.837]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.837]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.837]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.837]                     ...future.globalenv.names))
[10:30:48.837]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.837]         }, condition = base::local({
[10:30:48.837]             c <- base::c
[10:30:48.837]             inherits <- base::inherits
[10:30:48.837]             invokeRestart <- base::invokeRestart
[10:30:48.837]             length <- base::length
[10:30:48.837]             list <- base::list
[10:30:48.837]             seq.int <- base::seq.int
[10:30:48.837]             signalCondition <- base::signalCondition
[10:30:48.837]             sys.calls <- base::sys.calls
[10:30:48.837]             `[[` <- base::`[[`
[10:30:48.837]             `+` <- base::`+`
[10:30:48.837]             `<<-` <- base::`<<-`
[10:30:48.837]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.837]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.837]                   3L)]
[10:30:48.837]             }
[10:30:48.837]             function(cond) {
[10:30:48.837]                 is_error <- inherits(cond, "error")
[10:30:48.837]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.837]                   NULL)
[10:30:48.837]                 if (is_error) {
[10:30:48.837]                   sessionInformation <- function() {
[10:30:48.837]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.837]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.837]                       search = base::search(), system = base::Sys.info())
[10:30:48.837]                   }
[10:30:48.837]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.837]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.837]                     cond$call), session = sessionInformation(), 
[10:30:48.837]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.837]                   signalCondition(cond)
[10:30:48.837]                 }
[10:30:48.837]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.837]                 "immediateCondition"))) {
[10:30:48.837]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.837]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.837]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.837]                   if (TRUE && !signal) {
[10:30:48.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.837]                     {
[10:30:48.837]                       inherits <- base::inherits
[10:30:48.837]                       invokeRestart <- base::invokeRestart
[10:30:48.837]                       is.null <- base::is.null
[10:30:48.837]                       muffled <- FALSE
[10:30:48.837]                       if (inherits(cond, "message")) {
[10:30:48.837]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.837]                         if (muffled) 
[10:30:48.837]                           invokeRestart("muffleMessage")
[10:30:48.837]                       }
[10:30:48.837]                       else if (inherits(cond, "warning")) {
[10:30:48.837]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.837]                         if (muffled) 
[10:30:48.837]                           invokeRestart("muffleWarning")
[10:30:48.837]                       }
[10:30:48.837]                       else if (inherits(cond, "condition")) {
[10:30:48.837]                         if (!is.null(pattern)) {
[10:30:48.837]                           computeRestarts <- base::computeRestarts
[10:30:48.837]                           grepl <- base::grepl
[10:30:48.837]                           restarts <- computeRestarts(cond)
[10:30:48.837]                           for (restart in restarts) {
[10:30:48.837]                             name <- restart$name
[10:30:48.837]                             if (is.null(name)) 
[10:30:48.837]                               next
[10:30:48.837]                             if (!grepl(pattern, name)) 
[10:30:48.837]                               next
[10:30:48.837]                             invokeRestart(restart)
[10:30:48.837]                             muffled <- TRUE
[10:30:48.837]                             break
[10:30:48.837]                           }
[10:30:48.837]                         }
[10:30:48.837]                       }
[10:30:48.837]                       invisible(muffled)
[10:30:48.837]                     }
[10:30:48.837]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.837]                   }
[10:30:48.837]                 }
[10:30:48.837]                 else {
[10:30:48.837]                   if (TRUE) {
[10:30:48.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.837]                     {
[10:30:48.837]                       inherits <- base::inherits
[10:30:48.837]                       invokeRestart <- base::invokeRestart
[10:30:48.837]                       is.null <- base::is.null
[10:30:48.837]                       muffled <- FALSE
[10:30:48.837]                       if (inherits(cond, "message")) {
[10:30:48.837]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.837]                         if (muffled) 
[10:30:48.837]                           invokeRestart("muffleMessage")
[10:30:48.837]                       }
[10:30:48.837]                       else if (inherits(cond, "warning")) {
[10:30:48.837]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.837]                         if (muffled) 
[10:30:48.837]                           invokeRestart("muffleWarning")
[10:30:48.837]                       }
[10:30:48.837]                       else if (inherits(cond, "condition")) {
[10:30:48.837]                         if (!is.null(pattern)) {
[10:30:48.837]                           computeRestarts <- base::computeRestarts
[10:30:48.837]                           grepl <- base::grepl
[10:30:48.837]                           restarts <- computeRestarts(cond)
[10:30:48.837]                           for (restart in restarts) {
[10:30:48.837]                             name <- restart$name
[10:30:48.837]                             if (is.null(name)) 
[10:30:48.837]                               next
[10:30:48.837]                             if (!grepl(pattern, name)) 
[10:30:48.837]                               next
[10:30:48.837]                             invokeRestart(restart)
[10:30:48.837]                             muffled <- TRUE
[10:30:48.837]                             break
[10:30:48.837]                           }
[10:30:48.837]                         }
[10:30:48.837]                       }
[10:30:48.837]                       invisible(muffled)
[10:30:48.837]                     }
[10:30:48.837]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.837]                   }
[10:30:48.837]                 }
[10:30:48.837]             }
[10:30:48.837]         }))
[10:30:48.837]     }, error = function(ex) {
[10:30:48.837]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.837]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.837]                 ...future.rng), started = ...future.startTime, 
[10:30:48.837]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.837]             version = "1.8"), class = "FutureResult")
[10:30:48.837]     }, finally = {
[10:30:48.837]         if (!identical(...future.workdir, getwd())) 
[10:30:48.837]             setwd(...future.workdir)
[10:30:48.837]         {
[10:30:48.837]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.837]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.837]             }
[10:30:48.837]             base::options(...future.oldOptions)
[10:30:48.837]             if (.Platform$OS.type == "windows") {
[10:30:48.837]                 old_names <- names(...future.oldEnvVars)
[10:30:48.837]                 envs <- base::Sys.getenv()
[10:30:48.837]                 names <- names(envs)
[10:30:48.837]                 common <- intersect(names, old_names)
[10:30:48.837]                 added <- setdiff(names, old_names)
[10:30:48.837]                 removed <- setdiff(old_names, names)
[10:30:48.837]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.837]                   envs[common]]
[10:30:48.837]                 NAMES <- toupper(changed)
[10:30:48.837]                 args <- list()
[10:30:48.837]                 for (kk in seq_along(NAMES)) {
[10:30:48.837]                   name <- changed[[kk]]
[10:30:48.837]                   NAME <- NAMES[[kk]]
[10:30:48.837]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.837]                     next
[10:30:48.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.837]                 }
[10:30:48.837]                 NAMES <- toupper(added)
[10:30:48.837]                 for (kk in seq_along(NAMES)) {
[10:30:48.837]                   name <- added[[kk]]
[10:30:48.837]                   NAME <- NAMES[[kk]]
[10:30:48.837]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.837]                     next
[10:30:48.837]                   args[[name]] <- ""
[10:30:48.837]                 }
[10:30:48.837]                 NAMES <- toupper(removed)
[10:30:48.837]                 for (kk in seq_along(NAMES)) {
[10:30:48.837]                   name <- removed[[kk]]
[10:30:48.837]                   NAME <- NAMES[[kk]]
[10:30:48.837]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.837]                     next
[10:30:48.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.837]                 }
[10:30:48.837]                 if (length(args) > 0) 
[10:30:48.837]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.837]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.837]             }
[10:30:48.837]             else {
[10:30:48.837]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.837]             }
[10:30:48.837]             {
[10:30:48.837]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.837]                   0L) {
[10:30:48.837]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.837]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.837]                   base::options(opts)
[10:30:48.837]                 }
[10:30:48.837]                 {
[10:30:48.837]                   {
[10:30:48.837]                     base::assign(".Random.seed", c(10407L, 312275249L, 
[10:30:48.837]                     -74592902L, -695450688L, 1139696322L, 1629593144L, 
[10:30:48.837]                     1452859301L), envir = base::globalenv(), 
[10:30:48.837]                       inherits = FALSE)
[10:30:48.837]                     NULL
[10:30:48.837]                   }
[10:30:48.837]                   options(future.plan = NULL)
[10:30:48.837]                   if (is.na(NA_character_)) 
[10:30:48.837]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.837]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.837]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.837]                     .init = FALSE)
[10:30:48.837]                 }
[10:30:48.837]             }
[10:30:48.837]         }
[10:30:48.837]     })
[10:30:48.837]     if (TRUE) {
[10:30:48.837]         base::sink(type = "output", split = FALSE)
[10:30:48.837]         if (TRUE) {
[10:30:48.837]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.837]         }
[10:30:48.837]         else {
[10:30:48.837]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.837]         }
[10:30:48.837]         base::close(...future.stdout)
[10:30:48.837]         ...future.stdout <- NULL
[10:30:48.837]     }
[10:30:48.837]     ...future.result$conditions <- ...future.conditions
[10:30:48.837]     ...future.result$finished <- base::Sys.time()
[10:30:48.837]     ...future.result
[10:30:48.837] }
[10:30:48.839] assign_globals() ...
[10:30:48.839] List of 5
[10:30:48.839]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:30:48.839]  $ MoreArgs                 :List of 1
[10:30:48.839]   ..$ min: num 1
[10:30:48.839]  $ ...future.elements_ii    :List of 2
[10:30:48.839]   ..$ n  :List of 4
[10:30:48.839]   .. ..$ : int 1
[10:30:48.839]   .. ..$ : int 2
[10:30:48.839]   .. ..$ : int 3
[10:30:48.839]   .. ..$ : int 4
[10:30:48.839]   ..$ max:List of 4
[10:30:48.839]   .. ..$ : int 2
[10:30:48.839]   .. ..$ : int 3
[10:30:48.839]   .. ..$ : int 4
[10:30:48.839]   .. ..$ : int 5
[10:30:48.839]  $ ...future.seeds_ii       :List of 4
[10:30:48.839]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:30:48.839]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:30:48.839]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[10:30:48.839]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[10:30:48.839]  $ ...future.globals.maxSize: NULL
[10:30:48.839]  - attr(*, "where")=List of 5
[10:30:48.839]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.839]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.839]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.839]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.839]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.839]  - attr(*, "resolved")= logi FALSE
[10:30:48.839]  - attr(*, "total_size")= num 2912
[10:30:48.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.839]  - attr(*, "already-done")= logi TRUE
[10:30:48.853] - copied ‘...future.FUN’ to environment
[10:30:48.853] - copied ‘MoreArgs’ to environment
[10:30:48.853] - copied ‘...future.elements_ii’ to environment
[10:30:48.853] - copied ‘...future.seeds_ii’ to environment
[10:30:48.853] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.853] assign_globals() ... done
[10:30:48.854] plan(): Setting new future strategy stack:
[10:30:48.854] List of future strategies:
[10:30:48.854] 1. sequential:
[10:30:48.854]    - args: function (..., envir = parent.frame())
[10:30:48.854]    - tweaked: FALSE
[10:30:48.854]    - call: NULL
[10:30:48.854] plan(): nbrOfWorkers() = 1
[10:30:48.855] plan(): Setting new future strategy stack:
[10:30:48.855] List of future strategies:
[10:30:48.855] 1. sequential:
[10:30:48.855]    - args: function (..., envir = parent.frame())
[10:30:48.855]    - tweaked: FALSE
[10:30:48.855]    - call: plan(strategy)
[10:30:48.856] plan(): nbrOfWorkers() = 1
[10:30:48.856] SequentialFuture started (and completed)
[10:30:48.856] - Launch lazy future ... done
[10:30:48.856] run() for ‘SequentialFuture’ ... done
[10:30:48.856] Created future:
[10:30:48.856] SequentialFuture:
[10:30:48.856] Label: ‘future_mapply-1’
[10:30:48.856] Expression:
[10:30:48.856] {
[10:30:48.856]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.856]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.856]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.856]         on.exit(options(oopts), add = TRUE)
[10:30:48.856]     }
[10:30:48.856]     {
[10:30:48.856]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:48.856]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:48.856]                 inherits = FALSE)
[10:30:48.856]             ...future.FUN(...)
[10:30:48.856]         }
[10:30:48.856]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:48.856]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:48.856]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.856]         do.call(mapply, args = args)
[10:30:48.856]     }
[10:30:48.856] }
[10:30:48.856] Lazy evaluation: FALSE
[10:30:48.856] Asynchronous evaluation: FALSE
[10:30:48.856] Local evaluation: TRUE
[10:30:48.856] Environment: R_GlobalEnv
[10:30:48.856] Capture standard output: TRUE
[10:30:48.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.856] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.856] Packages: 1 packages (‘stats’)
[10:30:48.856] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:48.856] Resolved: TRUE
[10:30:48.856] Value: 280 bytes of class ‘list’
[10:30:48.856] Early signaling: FALSE
[10:30:48.856] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.856] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.857] Chunk #1 of 1 ... DONE
[10:30:48.858] Launching 1 futures (chunks) ... DONE
[10:30:48.858] Resolving 1 futures (chunks) ...
[10:30:48.858] resolve() on list ...
[10:30:48.858]  recursive: 0
[10:30:48.858]  length: 1
[10:30:48.858] 
[10:30:48.858] resolved() for ‘SequentialFuture’ ...
[10:30:48.858] - state: ‘finished’
[10:30:48.858] - run: TRUE
[10:30:48.858] - result: ‘FutureResult’
[10:30:48.858] resolved() for ‘SequentialFuture’ ... done
[10:30:48.859] Future #1
[10:30:48.859] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.859] - nx: 1
[10:30:48.859] - relay: TRUE
[10:30:48.859] - stdout: TRUE
[10:30:48.859] - signal: TRUE
[10:30:48.859] - resignal: FALSE
[10:30:48.859] - force: TRUE
[10:30:48.859] - relayed: [n=1] FALSE
[10:30:48.859] - queued futures: [n=1] FALSE
[10:30:48.859]  - until=1
[10:30:48.860]  - relaying element #1
[10:30:48.860] - relayed: [n=1] TRUE
[10:30:48.860] - queued futures: [n=1] TRUE
[10:30:48.860] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.860]  length: 0 (resolved future 1)
[10:30:48.860] Relaying remaining futures
[10:30:48.860] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.860] - nx: 1
[10:30:48.860] - relay: TRUE
[10:30:48.860] - stdout: TRUE
[10:30:48.861] - signal: TRUE
[10:30:48.861] - resignal: FALSE
[10:30:48.861] - force: TRUE
[10:30:48.861] - relayed: [n=1] TRUE
[10:30:48.861] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.861] - relayed: [n=1] TRUE
[10:30:48.861] - queued futures: [n=1] TRUE
[10:30:48.861] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.861] resolve() on list ... DONE
[10:30:48.861]  - Number of value chunks collected: 1
[10:30:48.862] Resolving 1 futures (chunks) ... DONE
[10:30:48.862] Reducing values from 1 chunks ...
[10:30:48.862]  - Number of values collected after concatenation: 4
[10:30:48.862]  - Number of values expected: 4
[10:30:48.862] Reducing values from 1 chunks ... DONE
[10:30:48.862] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[10:30:48.864] future_mapply() ...
[10:30:48.865] Number of chunks: 1
[10:30:48.865] getGlobalsAndPackagesXApply() ...
[10:30:48.865]  - future.globals: TRUE
[10:30:48.865] getGlobalsAndPackages() ...
[10:30:48.865] Searching for globals...
[10:30:48.866] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:30:48.866] Searching for globals ... DONE
[10:30:48.866] Resolving globals: FALSE
[10:30:48.867] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[10:30:48.867] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[10:30:48.867] - globals: [1] ‘FUN’
[10:30:48.867] - packages: [1] ‘stats’
[10:30:48.867] getGlobalsAndPackages() ... DONE
[10:30:48.867]  - globals found/used: [n=1] ‘FUN’
[10:30:48.868]  - needed namespaces: [n=1] ‘stats’
[10:30:48.868] Finding globals ... DONE
[10:30:48.868] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.868] List of 2
[10:30:48.868]  $ ...future.FUN:function (x, w, ...)  
[10:30:48.868]  $ MoreArgs     : NULL
[10:30:48.868]  - attr(*, "where")=List of 2
[10:30:48.868]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.868]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.868]  - attr(*, "resolved")= logi FALSE
[10:30:48.868]  - attr(*, "total_size")= num NA
[10:30:48.872] Packages to be attached in all futures: [n=1] ‘stats’
[10:30:48.872] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.873] Number of futures (= number of chunks): 1
[10:30:48.873] Launching 1 futures (chunks) ...
[10:30:48.873] Chunk #1 of 1 ...
[10:30:48.873]  - Finding globals in '...' for chunk #1 ...
[10:30:48.873] getGlobalsAndPackages() ...
[10:30:48.873] Searching for globals...
[10:30:48.874] 
[10:30:48.874] Searching for globals ... DONE
[10:30:48.874] - globals: [0] <none>
[10:30:48.874] getGlobalsAndPackages() ... DONE
[10:30:48.874]    + additional globals found: [n=0] 
[10:30:48.874]    + additional namespaces needed: [n=0] 
[10:30:48.874]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.875]  - seeds: <none>
[10:30:48.875]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.875] getGlobalsAndPackages() ...
[10:30:48.875] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.875] Resolving globals: FALSE
[10:30:48.876] The total size of the 5 globals is 3.10 KiB (3176 bytes)
[10:30:48.876] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (1.72 KiB of class ‘list’), ‘...future.FUN’ (1.38 KiB of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.876] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.876] - packages: [1] ‘stats’
[10:30:48.877] getGlobalsAndPackages() ... DONE
[10:30:48.877] run() for ‘Future’ ...
[10:30:48.877] - state: ‘created’
[10:30:48.877] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.877] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.878] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.878]   - Field: ‘label’
[10:30:48.878]   - Field: ‘local’
[10:30:48.878]   - Field: ‘owner’
[10:30:48.878]   - Field: ‘envir’
[10:30:48.878]   - Field: ‘packages’
[10:30:48.878]   - Field: ‘gc’
[10:30:48.878]   - Field: ‘conditions’
[10:30:48.878]   - Field: ‘expr’
[10:30:48.878]   - Field: ‘uuid’
[10:30:48.879]   - Field: ‘seed’
[10:30:48.879]   - Field: ‘version’
[10:30:48.879]   - Field: ‘result’
[10:30:48.879]   - Field: ‘asynchronous’
[10:30:48.879]   - Field: ‘calls’
[10:30:48.879]   - Field: ‘globals’
[10:30:48.879]   - Field: ‘stdout’
[10:30:48.879]   - Field: ‘earlySignal’
[10:30:48.879]   - Field: ‘lazy’
[10:30:48.879]   - Field: ‘state’
[10:30:48.879] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.880] - Launch lazy future ...
[10:30:48.880] Packages needed by the future expression (n = 1): ‘stats’
[10:30:48.880] Packages needed by future strategies (n = 0): <none>
[10:30:48.880] {
[10:30:48.880]     {
[10:30:48.880]         {
[10:30:48.880]             ...future.startTime <- base::Sys.time()
[10:30:48.880]             {
[10:30:48.880]                 {
[10:30:48.880]                   {
[10:30:48.880]                     {
[10:30:48.880]                       base::local({
[10:30:48.880]                         has_future <- base::requireNamespace("future", 
[10:30:48.880]                           quietly = TRUE)
[10:30:48.880]                         if (has_future) {
[10:30:48.880]                           ns <- base::getNamespace("future")
[10:30:48.880]                           version <- ns[[".package"]][["version"]]
[10:30:48.880]                           if (is.null(version)) 
[10:30:48.880]                             version <- utils::packageVersion("future")
[10:30:48.880]                         }
[10:30:48.880]                         else {
[10:30:48.880]                           version <- NULL
[10:30:48.880]                         }
[10:30:48.880]                         if (!has_future || version < "1.8.0") {
[10:30:48.880]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.880]                             "", base::R.version$version.string), 
[10:30:48.880]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:48.880]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.880]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.880]                               "release", "version")], collapse = " "), 
[10:30:48.880]                             hostname = base::Sys.info()[["nodename"]])
[10:30:48.880]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.880]                             info)
[10:30:48.880]                           info <- base::paste(info, collapse = "; ")
[10:30:48.880]                           if (!has_future) {
[10:30:48.880]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.880]                               info)
[10:30:48.880]                           }
[10:30:48.880]                           else {
[10:30:48.880]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.880]                               info, version)
[10:30:48.880]                           }
[10:30:48.880]                           base::stop(msg)
[10:30:48.880]                         }
[10:30:48.880]                       })
[10:30:48.880]                     }
[10:30:48.880]                     base::local({
[10:30:48.880]                       for (pkg in "stats") {
[10:30:48.880]                         base::loadNamespace(pkg)
[10:30:48.880]                         base::library(pkg, character.only = TRUE)
[10:30:48.880]                       }
[10:30:48.880]                     })
[10:30:48.880]                   }
[10:30:48.880]                   ...future.strategy.old <- future::plan("list")
[10:30:48.880]                   options(future.plan = NULL)
[10:30:48.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.880]                 }
[10:30:48.880]                 ...future.workdir <- getwd()
[10:30:48.880]             }
[10:30:48.880]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.880]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.880]         }
[10:30:48.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.880]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.880]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.880]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.880]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.880]             base::names(...future.oldOptions))
[10:30:48.880]     }
[10:30:48.880]     if (FALSE) {
[10:30:48.880]     }
[10:30:48.880]     else {
[10:30:48.880]         if (TRUE) {
[10:30:48.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.880]                 open = "w")
[10:30:48.880]         }
[10:30:48.880]         else {
[10:30:48.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.880]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.880]         }
[10:30:48.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.880]             base::sink(type = "output", split = FALSE)
[10:30:48.880]             base::close(...future.stdout)
[10:30:48.880]         }, add = TRUE)
[10:30:48.880]     }
[10:30:48.880]     ...future.frame <- base::sys.nframe()
[10:30:48.880]     ...future.conditions <- base::list()
[10:30:48.880]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.880]     if (FALSE) {
[10:30:48.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.880]     }
[10:30:48.880]     ...future.result <- base::tryCatch({
[10:30:48.880]         base::withCallingHandlers({
[10:30:48.880]             ...future.value <- base::withVisible(base::local({
[10:30:48.880]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.880]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.880]                   ...future.globals.maxSize)) {
[10:30:48.880]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.880]                   on.exit(options(oopts), add = TRUE)
[10:30:48.880]                 }
[10:30:48.880]                 {
[10:30:48.880]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.880]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.880]                     USE.NAMES = FALSE)
[10:30:48.880]                   do.call(mapply, args = args)
[10:30:48.880]                 }
[10:30:48.880]             }))
[10:30:48.880]             future::FutureResult(value = ...future.value$value, 
[10:30:48.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.880]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.880]                     ...future.globalenv.names))
[10:30:48.880]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.880]         }, condition = base::local({
[10:30:48.880]             c <- base::c
[10:30:48.880]             inherits <- base::inherits
[10:30:48.880]             invokeRestart <- base::invokeRestart
[10:30:48.880]             length <- base::length
[10:30:48.880]             list <- base::list
[10:30:48.880]             seq.int <- base::seq.int
[10:30:48.880]             signalCondition <- base::signalCondition
[10:30:48.880]             sys.calls <- base::sys.calls
[10:30:48.880]             `[[` <- base::`[[`
[10:30:48.880]             `+` <- base::`+`
[10:30:48.880]             `<<-` <- base::`<<-`
[10:30:48.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.880]                   3L)]
[10:30:48.880]             }
[10:30:48.880]             function(cond) {
[10:30:48.880]                 is_error <- inherits(cond, "error")
[10:30:48.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.880]                   NULL)
[10:30:48.880]                 if (is_error) {
[10:30:48.880]                   sessionInformation <- function() {
[10:30:48.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.880]                       search = base::search(), system = base::Sys.info())
[10:30:48.880]                   }
[10:30:48.880]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.880]                     cond$call), session = sessionInformation(), 
[10:30:48.880]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.880]                   signalCondition(cond)
[10:30:48.880]                 }
[10:30:48.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.880]                 "immediateCondition"))) {
[10:30:48.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.880]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.880]                   if (TRUE && !signal) {
[10:30:48.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.880]                     {
[10:30:48.880]                       inherits <- base::inherits
[10:30:48.880]                       invokeRestart <- base::invokeRestart
[10:30:48.880]                       is.null <- base::is.null
[10:30:48.880]                       muffled <- FALSE
[10:30:48.880]                       if (inherits(cond, "message")) {
[10:30:48.880]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.880]                         if (muffled) 
[10:30:48.880]                           invokeRestart("muffleMessage")
[10:30:48.880]                       }
[10:30:48.880]                       else if (inherits(cond, "warning")) {
[10:30:48.880]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.880]                         if (muffled) 
[10:30:48.880]                           invokeRestart("muffleWarning")
[10:30:48.880]                       }
[10:30:48.880]                       else if (inherits(cond, "condition")) {
[10:30:48.880]                         if (!is.null(pattern)) {
[10:30:48.880]                           computeRestarts <- base::computeRestarts
[10:30:48.880]                           grepl <- base::grepl
[10:30:48.880]                           restarts <- computeRestarts(cond)
[10:30:48.880]                           for (restart in restarts) {
[10:30:48.880]                             name <- restart$name
[10:30:48.880]                             if (is.null(name)) 
[10:30:48.880]                               next
[10:30:48.880]                             if (!grepl(pattern, name)) 
[10:30:48.880]                               next
[10:30:48.880]                             invokeRestart(restart)
[10:30:48.880]                             muffled <- TRUE
[10:30:48.880]                             break
[10:30:48.880]                           }
[10:30:48.880]                         }
[10:30:48.880]                       }
[10:30:48.880]                       invisible(muffled)
[10:30:48.880]                     }
[10:30:48.880]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.880]                   }
[10:30:48.880]                 }
[10:30:48.880]                 else {
[10:30:48.880]                   if (TRUE) {
[10:30:48.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.880]                     {
[10:30:48.880]                       inherits <- base::inherits
[10:30:48.880]                       invokeRestart <- base::invokeRestart
[10:30:48.880]                       is.null <- base::is.null
[10:30:48.880]                       muffled <- FALSE
[10:30:48.880]                       if (inherits(cond, "message")) {
[10:30:48.880]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.880]                         if (muffled) 
[10:30:48.880]                           invokeRestart("muffleMessage")
[10:30:48.880]                       }
[10:30:48.880]                       else if (inherits(cond, "warning")) {
[10:30:48.880]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.880]                         if (muffled) 
[10:30:48.880]                           invokeRestart("muffleWarning")
[10:30:48.880]                       }
[10:30:48.880]                       else if (inherits(cond, "condition")) {
[10:30:48.880]                         if (!is.null(pattern)) {
[10:30:48.880]                           computeRestarts <- base::computeRestarts
[10:30:48.880]                           grepl <- base::grepl
[10:30:48.880]                           restarts <- computeRestarts(cond)
[10:30:48.880]                           for (restart in restarts) {
[10:30:48.880]                             name <- restart$name
[10:30:48.880]                             if (is.null(name)) 
[10:30:48.880]                               next
[10:30:48.880]                             if (!grepl(pattern, name)) 
[10:30:48.880]                               next
[10:30:48.880]                             invokeRestart(restart)
[10:30:48.880]                             muffled <- TRUE
[10:30:48.880]                             break
[10:30:48.880]                           }
[10:30:48.880]                         }
[10:30:48.880]                       }
[10:30:48.880]                       invisible(muffled)
[10:30:48.880]                     }
[10:30:48.880]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.880]                   }
[10:30:48.880]                 }
[10:30:48.880]             }
[10:30:48.880]         }))
[10:30:48.880]     }, error = function(ex) {
[10:30:48.880]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.880]                 ...future.rng), started = ...future.startTime, 
[10:30:48.880]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.880]             version = "1.8"), class = "FutureResult")
[10:30:48.880]     }, finally = {
[10:30:48.880]         if (!identical(...future.workdir, getwd())) 
[10:30:48.880]             setwd(...future.workdir)
[10:30:48.880]         {
[10:30:48.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.880]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.880]             }
[10:30:48.880]             base::options(...future.oldOptions)
[10:30:48.880]             if (.Platform$OS.type == "windows") {
[10:30:48.880]                 old_names <- names(...future.oldEnvVars)
[10:30:48.880]                 envs <- base::Sys.getenv()
[10:30:48.880]                 names <- names(envs)
[10:30:48.880]                 common <- intersect(names, old_names)
[10:30:48.880]                 added <- setdiff(names, old_names)
[10:30:48.880]                 removed <- setdiff(old_names, names)
[10:30:48.880]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.880]                   envs[common]]
[10:30:48.880]                 NAMES <- toupper(changed)
[10:30:48.880]                 args <- list()
[10:30:48.880]                 for (kk in seq_along(NAMES)) {
[10:30:48.880]                   name <- changed[[kk]]
[10:30:48.880]                   NAME <- NAMES[[kk]]
[10:30:48.880]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.880]                     next
[10:30:48.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.880]                 }
[10:30:48.880]                 NAMES <- toupper(added)
[10:30:48.880]                 for (kk in seq_along(NAMES)) {
[10:30:48.880]                   name <- added[[kk]]
[10:30:48.880]                   NAME <- NAMES[[kk]]
[10:30:48.880]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.880]                     next
[10:30:48.880]                   args[[name]] <- ""
[10:30:48.880]                 }
[10:30:48.880]                 NAMES <- toupper(removed)
[10:30:48.880]                 for (kk in seq_along(NAMES)) {
[10:30:48.880]                   name <- removed[[kk]]
[10:30:48.880]                   NAME <- NAMES[[kk]]
[10:30:48.880]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.880]                     next
[10:30:48.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.880]                 }
[10:30:48.880]                 if (length(args) > 0) 
[10:30:48.880]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.880]             }
[10:30:48.880]             else {
[10:30:48.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.880]             }
[10:30:48.880]             {
[10:30:48.880]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.880]                   0L) {
[10:30:48.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.880]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.880]                   base::options(opts)
[10:30:48.880]                 }
[10:30:48.880]                 {
[10:30:48.880]                   {
[10:30:48.880]                     base::assign(".Random.seed", c(10407L, 1895445699L, 
[10:30:48.880]                     355952873L, -1742510359L, -1798658587L, 291641892L, 
[10:30:48.880]                     952779669L), envir = base::globalenv(), inherits = FALSE)
[10:30:48.880]                     NULL
[10:30:48.880]                   }
[10:30:48.880]                   options(future.plan = NULL)
[10:30:48.880]                   if (is.na(NA_character_)) 
[10:30:48.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.880]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.880]                     .init = FALSE)
[10:30:48.880]                 }
[10:30:48.880]             }
[10:30:48.880]         }
[10:30:48.880]     })
[10:30:48.880]     if (TRUE) {
[10:30:48.880]         base::sink(type = "output", split = FALSE)
[10:30:48.880]         if (TRUE) {
[10:30:48.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.880]         }
[10:30:48.880]         else {
[10:30:48.880]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.880]         }
[10:30:48.880]         base::close(...future.stdout)
[10:30:48.880]         ...future.stdout <- NULL
[10:30:48.880]     }
[10:30:48.880]     ...future.result$conditions <- ...future.conditions
[10:30:48.880]     ...future.result$finished <- base::Sys.time()
[10:30:48.880]     ...future.result
[10:30:48.880] }
[10:30:48.882] assign_globals() ...
[10:30:48.882] List of 5
[10:30:48.882]  $ ...future.FUN            :function (x, w, ...)  
[10:30:48.882]  $ MoreArgs                 : NULL
[10:30:48.882]  $ ...future.elements_ii    :List of 2
[10:30:48.882]   ..$ :List of 5
[10:30:48.882]   .. ..$ : num [1:10] 0.4828 0.0542 0.5459 0.7322 0.3768 ...
[10:30:48.882]   .. ..$ : num [1:10] 0.346 0.781 0.5 0.988 0.666 ...
[10:30:48.882]   .. ..$ : num [1:10] 0.2397 0.6634 0.0799 0.7901 0.1617 ...
[10:30:48.882]   .. ..$ : num [1:10] 0.00745 0.76047 0.86531 0.12364 0.2365 ...
[10:30:48.882]   .. ..$ : num [1:10] 0.969 0.453 0.43 0.707 0.161 ...
[10:30:48.882]   ..$ :List of 5
[10:30:48.882]   .. ..$ : num [1:10] 4 5 5 5 3 9 8 6 7 7
[10:30:48.882]   .. ..$ : num [1:10] 8 5 9 2 7 5 6 4 5 7
[10:30:48.882]   .. ..$ : num [1:10] 5 6 5 11 9 4 9 7 5 4
[10:30:48.882]   .. ..$ : num [1:10] 7 4 2 7 4 3 9 6 5 7
[10:30:48.882]   .. ..$ : num [1:10] 8 7 6 6 5 5 7 8 2 5
[10:30:48.882]  $ ...future.seeds_ii       : NULL
[10:30:48.882]  $ ...future.globals.maxSize: NULL
[10:30:48.882]  - attr(*, "where")=List of 5
[10:30:48.882]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.882]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.882]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.882]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.882]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.882]  - attr(*, "resolved")= logi FALSE
[10:30:48.882]  - attr(*, "total_size")= num 3176
[10:30:48.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.882]  - attr(*, "already-done")= logi TRUE
[10:30:48.890] - copied ‘...future.FUN’ to environment
[10:30:48.890] - copied ‘MoreArgs’ to environment
[10:30:48.890] - copied ‘...future.elements_ii’ to environment
[10:30:48.890] - copied ‘...future.seeds_ii’ to environment
[10:30:48.890] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.890] assign_globals() ... done
[10:30:48.891] plan(): Setting new future strategy stack:
[10:30:48.891] List of future strategies:
[10:30:48.891] 1. sequential:
[10:30:48.891]    - args: function (..., envir = parent.frame())
[10:30:48.891]    - tweaked: FALSE
[10:30:48.891]    - call: NULL
[10:30:48.891] plan(): nbrOfWorkers() = 1
[10:30:48.892] plan(): Setting new future strategy stack:
[10:30:48.892] List of future strategies:
[10:30:48.892] 1. sequential:
[10:30:48.892]    - args: function (..., envir = parent.frame())
[10:30:48.892]    - tweaked: FALSE
[10:30:48.892]    - call: plan(strategy)
[10:30:48.893] plan(): nbrOfWorkers() = 1
[10:30:48.893] SequentialFuture started (and completed)
[10:30:48.893] - Launch lazy future ... done
[10:30:48.893] run() for ‘SequentialFuture’ ... done
[10:30:48.893] Created future:
[10:30:48.893] SequentialFuture:
[10:30:48.893] Label: ‘future_Map-1’
[10:30:48.893] Expression:
[10:30:48.893] {
[10:30:48.893]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.893]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.893]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.893]         on.exit(options(oopts), add = TRUE)
[10:30:48.893]     }
[10:30:48.893]     {
[10:30:48.893]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.893]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.893]         do.call(mapply, args = args)
[10:30:48.893]     }
[10:30:48.893] }
[10:30:48.893] Lazy evaluation: FALSE
[10:30:48.893] Asynchronous evaluation: FALSE
[10:30:48.893] Local evaluation: TRUE
[10:30:48.893] Environment: R_GlobalEnv
[10:30:48.893] Capture standard output: TRUE
[10:30:48.893] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.893] Globals: 5 objects totaling 3.10 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.893] Packages: 1 packages (‘stats’)
[10:30:48.893] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.893] Resolved: TRUE
[10:30:48.893] Value: 280 bytes of class ‘list’
[10:30:48.893] Early signaling: FALSE
[10:30:48.893] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.893] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.894] Chunk #1 of 1 ... DONE
[10:30:48.894] Launching 1 futures (chunks) ... DONE
[10:30:48.894] Resolving 1 futures (chunks) ...
[10:30:48.895] resolve() on list ...
[10:30:48.895]  recursive: 0
[10:30:48.895]  length: 1
[10:30:48.895] 
[10:30:48.895] resolved() for ‘SequentialFuture’ ...
[10:30:48.895] - state: ‘finished’
[10:30:48.895] - run: TRUE
[10:30:48.895] - result: ‘FutureResult’
[10:30:48.895] resolved() for ‘SequentialFuture’ ... done
[10:30:48.895] Future #1
[10:30:48.896] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.896] - nx: 1
[10:30:48.896] - relay: TRUE
[10:30:48.896] - stdout: TRUE
[10:30:48.896] - signal: TRUE
[10:30:48.898] - resignal: FALSE
[10:30:48.898] - force: TRUE
[10:30:48.898] - relayed: [n=1] FALSE
[10:30:48.898] - queued futures: [n=1] FALSE
[10:30:48.899]  - until=1
[10:30:48.899]  - relaying element #1
[10:30:48.899] - relayed: [n=1] TRUE
[10:30:48.899] - queued futures: [n=1] TRUE
[10:30:48.899] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.899]  length: 0 (resolved future 1)
[10:30:48.899] Relaying remaining futures
[10:30:48.900] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.900] - nx: 1
[10:30:48.900] - relay: TRUE
[10:30:48.900] - stdout: TRUE
[10:30:48.900] - signal: TRUE
[10:30:48.900] - resignal: FALSE
[10:30:48.900] - force: TRUE
[10:30:48.900] - relayed: [n=1] TRUE
[10:30:48.900] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.901] - relayed: [n=1] TRUE
[10:30:48.901] - queued futures: [n=1] TRUE
[10:30:48.901] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.901] resolve() on list ... DONE
[10:30:48.901]  - Number of value chunks collected: 1
[10:30:48.901] Resolving 1 futures (chunks) ... DONE
[10:30:48.901] Reducing values from 1 chunks ...
[10:30:48.901]  - Number of values collected after concatenation: 5
[10:30:48.902]  - Number of values expected: 5
[10:30:48.902] Reducing values from 1 chunks ... DONE
[10:30:48.902] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[10:30:48.904] future_mapply() ...
[10:30:48.904] Number of chunks: 1
[10:30:48.904] getGlobalsAndPackagesXApply() ...
[10:30:48.904]  - future.globals: TRUE
[10:30:48.904] getGlobalsAndPackages() ...
[10:30:48.904] Searching for globals...
[10:30:48.905] - globals found: [1] ‘FUN’
[10:30:48.905] Searching for globals ... DONE
[10:30:48.905] Resolving globals: FALSE
[10:30:48.905] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:48.906] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:48.906] - globals: [1] ‘FUN’
[10:30:48.906] 
[10:30:48.906] getGlobalsAndPackages() ... DONE
[10:30:48.906]  - globals found/used: [n=1] ‘FUN’
[10:30:48.906]  - needed namespaces: [n=0] 
[10:30:48.907] Finding globals ... DONE
[10:30:48.907] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.907] List of 2
[10:30:48.907]  $ ...future.FUN:function (e1, e2)  
[10:30:48.907]  $ MoreArgs     : NULL
[10:30:48.907]  - attr(*, "where")=List of 2
[10:30:48.907]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.907]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.907]  - attr(*, "resolved")= logi FALSE
[10:30:48.907]  - attr(*, "total_size")= num NA
[10:30:48.909] Packages to be attached in all futures: [n=0] 
[10:30:48.910] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.910] Number of futures (= number of chunks): 1
[10:30:48.910] Launching 1 futures (chunks) ...
[10:30:48.910] Chunk #1 of 1 ...
[10:30:48.910]  - Finding globals in '...' for chunk #1 ...
[10:30:48.910] getGlobalsAndPackages() ...
[10:30:48.910] Searching for globals...
[10:30:48.911] 
[10:30:48.911] Searching for globals ... DONE
[10:30:48.911] - globals: [0] <none>
[10:30:48.911] getGlobalsAndPackages() ... DONE
[10:30:48.911]    + additional globals found: [n=0] 
[10:30:48.911]    + additional namespaces needed: [n=0] 
[10:30:48.911]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.911]  - seeds: <none>
[10:30:48.911]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.912] getGlobalsAndPackages() ...
[10:30:48.912] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.912] Resolving globals: FALSE
[10:30:48.912] The total size of the 5 globals is 392 bytes (392 bytes)
[10:30:48.913] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 392 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (336 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.913] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.913] 
[10:30:48.913] getGlobalsAndPackages() ... DONE
[10:30:48.913] run() for ‘Future’ ...
[10:30:48.914] - state: ‘created’
[10:30:48.914] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.914] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.914] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.914]   - Field: ‘label’
[10:30:48.914]   - Field: ‘local’
[10:30:48.914]   - Field: ‘owner’
[10:30:48.914]   - Field: ‘envir’
[10:30:48.915]   - Field: ‘packages’
[10:30:48.915]   - Field: ‘gc’
[10:30:48.915]   - Field: ‘conditions’
[10:30:48.915]   - Field: ‘expr’
[10:30:48.915]   - Field: ‘uuid’
[10:30:48.915]   - Field: ‘seed’
[10:30:48.915]   - Field: ‘version’
[10:30:48.915]   - Field: ‘result’
[10:30:48.915]   - Field: ‘asynchronous’
[10:30:48.915]   - Field: ‘calls’
[10:30:48.916]   - Field: ‘globals’
[10:30:48.916]   - Field: ‘stdout’
[10:30:48.916]   - Field: ‘earlySignal’
[10:30:48.916]   - Field: ‘lazy’
[10:30:48.916]   - Field: ‘state’
[10:30:48.916] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.916] - Launch lazy future ...
[10:30:48.916] Packages needed by the future expression (n = 0): <none>
[10:30:48.916] Packages needed by future strategies (n = 0): <none>
[10:30:48.917] {
[10:30:48.917]     {
[10:30:48.917]         {
[10:30:48.917]             ...future.startTime <- base::Sys.time()
[10:30:48.917]             {
[10:30:48.917]                 {
[10:30:48.917]                   {
[10:30:48.917]                     base::local({
[10:30:48.917]                       has_future <- base::requireNamespace("future", 
[10:30:48.917]                         quietly = TRUE)
[10:30:48.917]                       if (has_future) {
[10:30:48.917]                         ns <- base::getNamespace("future")
[10:30:48.917]                         version <- ns[[".package"]][["version"]]
[10:30:48.917]                         if (is.null(version)) 
[10:30:48.917]                           version <- utils::packageVersion("future")
[10:30:48.917]                       }
[10:30:48.917]                       else {
[10:30:48.917]                         version <- NULL
[10:30:48.917]                       }
[10:30:48.917]                       if (!has_future || version < "1.8.0") {
[10:30:48.917]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.917]                           "", base::R.version$version.string), 
[10:30:48.917]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.917]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.917]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.917]                             "release", "version")], collapse = " "), 
[10:30:48.917]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.917]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.917]                           info)
[10:30:48.917]                         info <- base::paste(info, collapse = "; ")
[10:30:48.917]                         if (!has_future) {
[10:30:48.917]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.917]                             info)
[10:30:48.917]                         }
[10:30:48.917]                         else {
[10:30:48.917]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.917]                             info, version)
[10:30:48.917]                         }
[10:30:48.917]                         base::stop(msg)
[10:30:48.917]                       }
[10:30:48.917]                     })
[10:30:48.917]                   }
[10:30:48.917]                   ...future.strategy.old <- future::plan("list")
[10:30:48.917]                   options(future.plan = NULL)
[10:30:48.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.917]                 }
[10:30:48.917]                 ...future.workdir <- getwd()
[10:30:48.917]             }
[10:30:48.917]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.917]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.917]         }
[10:30:48.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.917]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.917]             base::names(...future.oldOptions))
[10:30:48.917]     }
[10:30:48.917]     if (FALSE) {
[10:30:48.917]     }
[10:30:48.917]     else {
[10:30:48.917]         if (TRUE) {
[10:30:48.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.917]                 open = "w")
[10:30:48.917]         }
[10:30:48.917]         else {
[10:30:48.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.917]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.917]         }
[10:30:48.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.917]             base::sink(type = "output", split = FALSE)
[10:30:48.917]             base::close(...future.stdout)
[10:30:48.917]         }, add = TRUE)
[10:30:48.917]     }
[10:30:48.917]     ...future.frame <- base::sys.nframe()
[10:30:48.917]     ...future.conditions <- base::list()
[10:30:48.917]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.917]     if (FALSE) {
[10:30:48.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.917]     }
[10:30:48.917]     ...future.result <- base::tryCatch({
[10:30:48.917]         base::withCallingHandlers({
[10:30:48.917]             ...future.value <- base::withVisible(base::local({
[10:30:48.917]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.917]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.917]                   ...future.globals.maxSize)) {
[10:30:48.917]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.917]                   on.exit(options(oopts), add = TRUE)
[10:30:48.917]                 }
[10:30:48.917]                 {
[10:30:48.917]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.917]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.917]                     USE.NAMES = FALSE)
[10:30:48.917]                   do.call(mapply, args = args)
[10:30:48.917]                 }
[10:30:48.917]             }))
[10:30:48.917]             future::FutureResult(value = ...future.value$value, 
[10:30:48.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.917]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.917]                     ...future.globalenv.names))
[10:30:48.917]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.917]         }, condition = base::local({
[10:30:48.917]             c <- base::c
[10:30:48.917]             inherits <- base::inherits
[10:30:48.917]             invokeRestart <- base::invokeRestart
[10:30:48.917]             length <- base::length
[10:30:48.917]             list <- base::list
[10:30:48.917]             seq.int <- base::seq.int
[10:30:48.917]             signalCondition <- base::signalCondition
[10:30:48.917]             sys.calls <- base::sys.calls
[10:30:48.917]             `[[` <- base::`[[`
[10:30:48.917]             `+` <- base::`+`
[10:30:48.917]             `<<-` <- base::`<<-`
[10:30:48.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.917]                   3L)]
[10:30:48.917]             }
[10:30:48.917]             function(cond) {
[10:30:48.917]                 is_error <- inherits(cond, "error")
[10:30:48.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.917]                   NULL)
[10:30:48.917]                 if (is_error) {
[10:30:48.917]                   sessionInformation <- function() {
[10:30:48.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.917]                       search = base::search(), system = base::Sys.info())
[10:30:48.917]                   }
[10:30:48.917]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.917]                     cond$call), session = sessionInformation(), 
[10:30:48.917]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.917]                   signalCondition(cond)
[10:30:48.917]                 }
[10:30:48.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.917]                 "immediateCondition"))) {
[10:30:48.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.917]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.917]                   if (TRUE && !signal) {
[10:30:48.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.917]                     {
[10:30:48.917]                       inherits <- base::inherits
[10:30:48.917]                       invokeRestart <- base::invokeRestart
[10:30:48.917]                       is.null <- base::is.null
[10:30:48.917]                       muffled <- FALSE
[10:30:48.917]                       if (inherits(cond, "message")) {
[10:30:48.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.917]                         if (muffled) 
[10:30:48.917]                           invokeRestart("muffleMessage")
[10:30:48.917]                       }
[10:30:48.917]                       else if (inherits(cond, "warning")) {
[10:30:48.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.917]                         if (muffled) 
[10:30:48.917]                           invokeRestart("muffleWarning")
[10:30:48.917]                       }
[10:30:48.917]                       else if (inherits(cond, "condition")) {
[10:30:48.917]                         if (!is.null(pattern)) {
[10:30:48.917]                           computeRestarts <- base::computeRestarts
[10:30:48.917]                           grepl <- base::grepl
[10:30:48.917]                           restarts <- computeRestarts(cond)
[10:30:48.917]                           for (restart in restarts) {
[10:30:48.917]                             name <- restart$name
[10:30:48.917]                             if (is.null(name)) 
[10:30:48.917]                               next
[10:30:48.917]                             if (!grepl(pattern, name)) 
[10:30:48.917]                               next
[10:30:48.917]                             invokeRestart(restart)
[10:30:48.917]                             muffled <- TRUE
[10:30:48.917]                             break
[10:30:48.917]                           }
[10:30:48.917]                         }
[10:30:48.917]                       }
[10:30:48.917]                       invisible(muffled)
[10:30:48.917]                     }
[10:30:48.917]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.917]                   }
[10:30:48.917]                 }
[10:30:48.917]                 else {
[10:30:48.917]                   if (TRUE) {
[10:30:48.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.917]                     {
[10:30:48.917]                       inherits <- base::inherits
[10:30:48.917]                       invokeRestart <- base::invokeRestart
[10:30:48.917]                       is.null <- base::is.null
[10:30:48.917]                       muffled <- FALSE
[10:30:48.917]                       if (inherits(cond, "message")) {
[10:30:48.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.917]                         if (muffled) 
[10:30:48.917]                           invokeRestart("muffleMessage")
[10:30:48.917]                       }
[10:30:48.917]                       else if (inherits(cond, "warning")) {
[10:30:48.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.917]                         if (muffled) 
[10:30:48.917]                           invokeRestart("muffleWarning")
[10:30:48.917]                       }
[10:30:48.917]                       else if (inherits(cond, "condition")) {
[10:30:48.917]                         if (!is.null(pattern)) {
[10:30:48.917]                           computeRestarts <- base::computeRestarts
[10:30:48.917]                           grepl <- base::grepl
[10:30:48.917]                           restarts <- computeRestarts(cond)
[10:30:48.917]                           for (restart in restarts) {
[10:30:48.917]                             name <- restart$name
[10:30:48.917]                             if (is.null(name)) 
[10:30:48.917]                               next
[10:30:48.917]                             if (!grepl(pattern, name)) 
[10:30:48.917]                               next
[10:30:48.917]                             invokeRestart(restart)
[10:30:48.917]                             muffled <- TRUE
[10:30:48.917]                             break
[10:30:48.917]                           }
[10:30:48.917]                         }
[10:30:48.917]                       }
[10:30:48.917]                       invisible(muffled)
[10:30:48.917]                     }
[10:30:48.917]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.917]                   }
[10:30:48.917]                 }
[10:30:48.917]             }
[10:30:48.917]         }))
[10:30:48.917]     }, error = function(ex) {
[10:30:48.917]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.917]                 ...future.rng), started = ...future.startTime, 
[10:30:48.917]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.917]             version = "1.8"), class = "FutureResult")
[10:30:48.917]     }, finally = {
[10:30:48.917]         if (!identical(...future.workdir, getwd())) 
[10:30:48.917]             setwd(...future.workdir)
[10:30:48.917]         {
[10:30:48.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.917]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.917]             }
[10:30:48.917]             base::options(...future.oldOptions)
[10:30:48.917]             if (.Platform$OS.type == "windows") {
[10:30:48.917]                 old_names <- names(...future.oldEnvVars)
[10:30:48.917]                 envs <- base::Sys.getenv()
[10:30:48.917]                 names <- names(envs)
[10:30:48.917]                 common <- intersect(names, old_names)
[10:30:48.917]                 added <- setdiff(names, old_names)
[10:30:48.917]                 removed <- setdiff(old_names, names)
[10:30:48.917]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.917]                   envs[common]]
[10:30:48.917]                 NAMES <- toupper(changed)
[10:30:48.917]                 args <- list()
[10:30:48.917]                 for (kk in seq_along(NAMES)) {
[10:30:48.917]                   name <- changed[[kk]]
[10:30:48.917]                   NAME <- NAMES[[kk]]
[10:30:48.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.917]                     next
[10:30:48.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.917]                 }
[10:30:48.917]                 NAMES <- toupper(added)
[10:30:48.917]                 for (kk in seq_along(NAMES)) {
[10:30:48.917]                   name <- added[[kk]]
[10:30:48.917]                   NAME <- NAMES[[kk]]
[10:30:48.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.917]                     next
[10:30:48.917]                   args[[name]] <- ""
[10:30:48.917]                 }
[10:30:48.917]                 NAMES <- toupper(removed)
[10:30:48.917]                 for (kk in seq_along(NAMES)) {
[10:30:48.917]                   name <- removed[[kk]]
[10:30:48.917]                   NAME <- NAMES[[kk]]
[10:30:48.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.917]                     next
[10:30:48.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.917]                 }
[10:30:48.917]                 if (length(args) > 0) 
[10:30:48.917]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.917]             }
[10:30:48.917]             else {
[10:30:48.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.917]             }
[10:30:48.917]             {
[10:30:48.917]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.917]                   0L) {
[10:30:48.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.917]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.917]                   base::options(opts)
[10:30:48.917]                 }
[10:30:48.917]                 {
[10:30:48.917]                   {
[10:30:48.917]                     base::assign(".Random.seed", c(10407L, 1895445699L, 
[10:30:48.917]                     355952873L, -1742510359L, -1798658587L, 291641892L, 
[10:30:48.917]                     952779669L), envir = base::globalenv(), inherits = FALSE)
[10:30:48.917]                     NULL
[10:30:48.917]                   }
[10:30:48.917]                   options(future.plan = NULL)
[10:30:48.917]                   if (is.na(NA_character_)) 
[10:30:48.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.917]                     .init = FALSE)
[10:30:48.917]                 }
[10:30:48.917]             }
[10:30:48.917]         }
[10:30:48.917]     })
[10:30:48.917]     if (TRUE) {
[10:30:48.917]         base::sink(type = "output", split = FALSE)
[10:30:48.917]         if (TRUE) {
[10:30:48.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.917]         }
[10:30:48.917]         else {
[10:30:48.917]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.917]         }
[10:30:48.917]         base::close(...future.stdout)
[10:30:48.917]         ...future.stdout <- NULL
[10:30:48.917]     }
[10:30:48.917]     ...future.result$conditions <- ...future.conditions
[10:30:48.917]     ...future.result$finished <- base::Sys.time()
[10:30:48.917]     ...future.result
[10:30:48.917] }
[10:30:48.919] assign_globals() ...
[10:30:48.919] List of 5
[10:30:48.919]  $ ...future.FUN            :function (e1, e2)  
[10:30:48.919]  $ MoreArgs                 : NULL
[10:30:48.919]  $ ...future.elements_ii    :List of 2
[10:30:48.919]   ..$ :List of 3
[10:30:48.919]   .. ..$ : num 1
[10:30:48.919]   .. ..$ : num 1
[10:30:48.919]   .. ..$ : num 1
[10:30:48.919]   ..$ :List of 3
[10:30:48.919]   .. ..$ : int 1
[10:30:48.919]   .. ..$ : int 2
[10:30:48.919]   .. ..$ : int 3
[10:30:48.919]  $ ...future.seeds_ii       : NULL
[10:30:48.919]  $ ...future.globals.maxSize: NULL
[10:30:48.919]  - attr(*, "where")=List of 5
[10:30:48.919]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.919]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.919]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.919]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.919]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.919]  - attr(*, "resolved")= logi FALSE
[10:30:48.919]  - attr(*, "total_size")= num 392
[10:30:48.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.919]  - attr(*, "already-done")= logi TRUE
[10:30:48.928] - copied ‘...future.FUN’ to environment
[10:30:48.928] - copied ‘MoreArgs’ to environment
[10:30:48.928] - copied ‘...future.elements_ii’ to environment
[10:30:48.928] - copied ‘...future.seeds_ii’ to environment
[10:30:48.929] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.929] assign_globals() ... done
[10:30:48.929] plan(): Setting new future strategy stack:
[10:30:48.929] List of future strategies:
[10:30:48.929] 1. sequential:
[10:30:48.929]    - args: function (..., envir = parent.frame())
[10:30:48.929]    - tweaked: FALSE
[10:30:48.929]    - call: NULL
[10:30:48.929] plan(): nbrOfWorkers() = 1
[10:30:48.930] plan(): Setting new future strategy stack:
[10:30:48.930] List of future strategies:
[10:30:48.930] 1. sequential:
[10:30:48.930]    - args: function (..., envir = parent.frame())
[10:30:48.930]    - tweaked: FALSE
[10:30:48.930]    - call: plan(strategy)
[10:30:48.931] plan(): nbrOfWorkers() = 1
[10:30:48.931] SequentialFuture started (and completed)
[10:30:48.931] - Launch lazy future ... done
[10:30:48.931] run() for ‘SequentialFuture’ ... done
[10:30:48.931] Created future:
[10:30:48.931] SequentialFuture:
[10:30:48.931] Label: ‘future_Map-1’
[10:30:48.931] Expression:
[10:30:48.931] {
[10:30:48.931]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.931]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.931]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.931]         on.exit(options(oopts), add = TRUE)
[10:30:48.931]     }
[10:30:48.931]     {
[10:30:48.931]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.931]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.931]         do.call(mapply, args = args)
[10:30:48.931]     }
[10:30:48.931] }
[10:30:48.931] Lazy evaluation: FALSE
[10:30:48.931] Asynchronous evaluation: FALSE
[10:30:48.931] Local evaluation: TRUE
[10:30:48.931] Environment: R_GlobalEnv
[10:30:48.931] Capture standard output: TRUE
[10:30:48.931] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.931] Globals: 5 objects totaling 392 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.931] Packages: <none>
[10:30:48.931] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.931] Resolved: TRUE
[10:30:48.931] Value: 168 bytes of class ‘list’
[10:30:48.931] Early signaling: FALSE
[10:30:48.931] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.931] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.932] Chunk #1 of 1 ... DONE
[10:30:48.933] Launching 1 futures (chunks) ... DONE
[10:30:48.933] Resolving 1 futures (chunks) ...
[10:30:48.933] resolve() on list ...
[10:30:48.933]  recursive: 0
[10:30:48.933]  length: 1
[10:30:48.933] 
[10:30:48.933] resolved() for ‘SequentialFuture’ ...
[10:30:48.933] - state: ‘finished’
[10:30:48.933] - run: TRUE
[10:30:48.933] - result: ‘FutureResult’
[10:30:48.934] resolved() for ‘SequentialFuture’ ... done
[10:30:48.934] Future #1
[10:30:48.934] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.934] - nx: 1
[10:30:48.934] - relay: TRUE
[10:30:48.934] - stdout: TRUE
[10:30:48.934] - signal: TRUE
[10:30:48.934] - resignal: FALSE
[10:30:48.934] - force: TRUE
[10:30:48.934] - relayed: [n=1] FALSE
[10:30:48.934] - queued futures: [n=1] FALSE
[10:30:48.935]  - until=1
[10:30:48.935]  - relaying element #1
[10:30:48.935] - relayed: [n=1] TRUE
[10:30:48.935] - queued futures: [n=1] TRUE
[10:30:48.935] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.935]  length: 0 (resolved future 1)
[10:30:48.935] Relaying remaining futures
[10:30:48.935] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.935] - nx: 1
[10:30:48.935] - relay: TRUE
[10:30:48.936] - stdout: TRUE
[10:30:48.936] - signal: TRUE
[10:30:48.936] - resignal: FALSE
[10:30:48.936] - force: TRUE
[10:30:48.936] - relayed: [n=1] TRUE
[10:30:48.936] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.936] - relayed: [n=1] TRUE
[10:30:48.936] - queued futures: [n=1] TRUE
[10:30:48.936] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.936] resolve() on list ... DONE
[10:30:48.937]  - Number of value chunks collected: 1
[10:30:48.937] Resolving 1 futures (chunks) ... DONE
[10:30:48.937] Reducing values from 1 chunks ...
[10:30:48.937]  - Number of values collected after concatenation: 3
[10:30:48.937]  - Number of values expected: 3
[10:30:48.937] Reducing values from 1 chunks ... DONE
[10:30:48.937] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[10:30:48.938] future_mapply() ...
[10:30:48.938] Number of chunks: 1
[10:30:48.938] getGlobalsAndPackagesXApply() ...
[10:30:48.938]  - future.globals: TRUE
[10:30:48.938] getGlobalsAndPackages() ...
[10:30:48.938] Searching for globals...
[10:30:48.939] - globals found: [1] ‘FUN’
[10:30:48.939] Searching for globals ... DONE
[10:30:48.939] Resolving globals: FALSE
[10:30:48.940] The total size of the 1 globals is 848 bytes (848 bytes)
[10:30:48.940] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:30:48.940] - globals: [1] ‘FUN’
[10:30:48.940] 
[10:30:48.940] getGlobalsAndPackages() ... DONE
[10:30:48.940]  - globals found/used: [n=1] ‘FUN’
[10:30:48.940]  - needed namespaces: [n=0] 
[10:30:48.941] Finding globals ... DONE
[10:30:48.941] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.941] List of 2
[10:30:48.941]  $ ...future.FUN:function (x)  
[10:30:48.941]  $ MoreArgs     : NULL
[10:30:48.941]  - attr(*, "where")=List of 2
[10:30:48.941]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.941]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.941]  - attr(*, "resolved")= logi FALSE
[10:30:48.941]  - attr(*, "total_size")= num NA
[10:30:48.943] Packages to be attached in all futures: [n=0] 
[10:30:48.944] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.944] Number of futures (= number of chunks): 1
[10:30:48.944] Launching 1 futures (chunks) ...
[10:30:48.944] Chunk #1 of 1 ...
[10:30:48.944]  - Finding globals in '...' for chunk #1 ...
[10:30:48.944] getGlobalsAndPackages() ...
[10:30:48.944] Searching for globals...
[10:30:48.945] 
[10:30:48.945] Searching for globals ... DONE
[10:30:48.945] - globals: [0] <none>
[10:30:48.945] getGlobalsAndPackages() ... DONE
[10:30:48.945]    + additional globals found: [n=0] 
[10:30:48.945]    + additional namespaces needed: [n=0] 
[10:30:48.945]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.945]  - seeds: <none>
[10:30:48.945]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.945] getGlobalsAndPackages() ...
[10:30:48.946] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.946] Resolving globals: FALSE
[10:30:48.946] The total size of the 5 globals is 960 bytes (960 bytes)
[10:30:48.947] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 960 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.947] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.947] 
[10:30:48.947] getGlobalsAndPackages() ... DONE
[10:30:48.947] run() for ‘Future’ ...
[10:30:48.947] - state: ‘created’
[10:30:48.947] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:30:48.950] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.950] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:30:48.950]   - Field: ‘label’
[10:30:48.950]   - Field: ‘local’
[10:30:48.950]   - Field: ‘owner’
[10:30:48.951]   - Field: ‘envir’
[10:30:48.951]   - Field: ‘packages’
[10:30:48.951]   - Field: ‘gc’
[10:30:48.951]   - Field: ‘conditions’
[10:30:48.951]   - Field: ‘expr’
[10:30:48.951]   - Field: ‘uuid’
[10:30:48.951]   - Field: ‘seed’
[10:30:48.951]   - Field: ‘version’
[10:30:48.951]   - Field: ‘result’
[10:30:48.952]   - Field: ‘asynchronous’
[10:30:48.952]   - Field: ‘calls’
[10:30:48.952]   - Field: ‘globals’
[10:30:48.952]   - Field: ‘stdout’
[10:30:48.952]   - Field: ‘earlySignal’
[10:30:48.952]   - Field: ‘lazy’
[10:30:48.952]   - Field: ‘state’
[10:30:48.952] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:30:48.953] - Launch lazy future ...
[10:30:48.953] Packages needed by the future expression (n = 0): <none>
[10:30:48.953] Packages needed by future strategies (n = 0): <none>
[10:30:48.953] {
[10:30:48.953]     {
[10:30:48.953]         {
[10:30:48.953]             ...future.startTime <- base::Sys.time()
[10:30:48.953]             {
[10:30:48.953]                 {
[10:30:48.953]                   {
[10:30:48.953]                     base::local({
[10:30:48.953]                       has_future <- base::requireNamespace("future", 
[10:30:48.953]                         quietly = TRUE)
[10:30:48.953]                       if (has_future) {
[10:30:48.953]                         ns <- base::getNamespace("future")
[10:30:48.953]                         version <- ns[[".package"]][["version"]]
[10:30:48.953]                         if (is.null(version)) 
[10:30:48.953]                           version <- utils::packageVersion("future")
[10:30:48.953]                       }
[10:30:48.953]                       else {
[10:30:48.953]                         version <- NULL
[10:30:48.953]                       }
[10:30:48.953]                       if (!has_future || version < "1.8.0") {
[10:30:48.953]                         info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.953]                           "", base::R.version$version.string), 
[10:30:48.953]                           platform = base::sprintf("%s (%s-bit)", 
[10:30:48.953]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.953]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.953]                             "release", "version")], collapse = " "), 
[10:30:48.953]                           hostname = base::Sys.info()[["nodename"]])
[10:30:48.953]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.953]                           info)
[10:30:48.953]                         info <- base::paste(info, collapse = "; ")
[10:30:48.953]                         if (!has_future) {
[10:30:48.953]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.953]                             info)
[10:30:48.953]                         }
[10:30:48.953]                         else {
[10:30:48.953]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.953]                             info, version)
[10:30:48.953]                         }
[10:30:48.953]                         base::stop(msg)
[10:30:48.953]                       }
[10:30:48.953]                     })
[10:30:48.953]                   }
[10:30:48.953]                   ...future.strategy.old <- future::plan("list")
[10:30:48.953]                   options(future.plan = NULL)
[10:30:48.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.953]                 }
[10:30:48.953]                 ...future.workdir <- getwd()
[10:30:48.953]             }
[10:30:48.953]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.953]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.953]         }
[10:30:48.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.953]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:48.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.953]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.953]             base::names(...future.oldOptions))
[10:30:48.953]     }
[10:30:48.953]     if (FALSE) {
[10:30:48.953]     }
[10:30:48.953]     else {
[10:30:48.953]         if (TRUE) {
[10:30:48.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.953]                 open = "w")
[10:30:48.953]         }
[10:30:48.953]         else {
[10:30:48.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.953]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.953]         }
[10:30:48.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.953]             base::sink(type = "output", split = FALSE)
[10:30:48.953]             base::close(...future.stdout)
[10:30:48.953]         }, add = TRUE)
[10:30:48.953]     }
[10:30:48.953]     ...future.frame <- base::sys.nframe()
[10:30:48.953]     ...future.conditions <- base::list()
[10:30:48.953]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.953]     if (FALSE) {
[10:30:48.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.953]     }
[10:30:48.953]     ...future.result <- base::tryCatch({
[10:30:48.953]         base::withCallingHandlers({
[10:30:48.953]             ...future.value <- base::withVisible(base::local({
[10:30:48.953]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.953]                 if (!identical(...future.globals.maxSize.org, 
[10:30:48.953]                   ...future.globals.maxSize)) {
[10:30:48.953]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.953]                   on.exit(options(oopts), add = TRUE)
[10:30:48.953]                 }
[10:30:48.953]                 {
[10:30:48.953]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.953]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.953]                     USE.NAMES = FALSE)
[10:30:48.953]                   do.call(mapply, args = args)
[10:30:48.953]                 }
[10:30:48.953]             }))
[10:30:48.953]             future::FutureResult(value = ...future.value$value, 
[10:30:48.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.953]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.953]                     ...future.globalenv.names))
[10:30:48.953]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.953]         }, condition = base::local({
[10:30:48.953]             c <- base::c
[10:30:48.953]             inherits <- base::inherits
[10:30:48.953]             invokeRestart <- base::invokeRestart
[10:30:48.953]             length <- base::length
[10:30:48.953]             list <- base::list
[10:30:48.953]             seq.int <- base::seq.int
[10:30:48.953]             signalCondition <- base::signalCondition
[10:30:48.953]             sys.calls <- base::sys.calls
[10:30:48.953]             `[[` <- base::`[[`
[10:30:48.953]             `+` <- base::`+`
[10:30:48.953]             `<<-` <- base::`<<-`
[10:30:48.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.953]                   3L)]
[10:30:48.953]             }
[10:30:48.953]             function(cond) {
[10:30:48.953]                 is_error <- inherits(cond, "error")
[10:30:48.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.953]                   NULL)
[10:30:48.953]                 if (is_error) {
[10:30:48.953]                   sessionInformation <- function() {
[10:30:48.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.953]                       search = base::search(), system = base::Sys.info())
[10:30:48.953]                   }
[10:30:48.953]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.953]                     cond$call), session = sessionInformation(), 
[10:30:48.953]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.953]                   signalCondition(cond)
[10:30:48.953]                 }
[10:30:48.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.953]                 "immediateCondition"))) {
[10:30:48.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.953]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.953]                   if (TRUE && !signal) {
[10:30:48.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.953]                     {
[10:30:48.953]                       inherits <- base::inherits
[10:30:48.953]                       invokeRestart <- base::invokeRestart
[10:30:48.953]                       is.null <- base::is.null
[10:30:48.953]                       muffled <- FALSE
[10:30:48.953]                       if (inherits(cond, "message")) {
[10:30:48.953]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.953]                         if (muffled) 
[10:30:48.953]                           invokeRestart("muffleMessage")
[10:30:48.953]                       }
[10:30:48.953]                       else if (inherits(cond, "warning")) {
[10:30:48.953]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.953]                         if (muffled) 
[10:30:48.953]                           invokeRestart("muffleWarning")
[10:30:48.953]                       }
[10:30:48.953]                       else if (inherits(cond, "condition")) {
[10:30:48.953]                         if (!is.null(pattern)) {
[10:30:48.953]                           computeRestarts <- base::computeRestarts
[10:30:48.953]                           grepl <- base::grepl
[10:30:48.953]                           restarts <- computeRestarts(cond)
[10:30:48.953]                           for (restart in restarts) {
[10:30:48.953]                             name <- restart$name
[10:30:48.953]                             if (is.null(name)) 
[10:30:48.953]                               next
[10:30:48.953]                             if (!grepl(pattern, name)) 
[10:30:48.953]                               next
[10:30:48.953]                             invokeRestart(restart)
[10:30:48.953]                             muffled <- TRUE
[10:30:48.953]                             break
[10:30:48.953]                           }
[10:30:48.953]                         }
[10:30:48.953]                       }
[10:30:48.953]                       invisible(muffled)
[10:30:48.953]                     }
[10:30:48.953]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.953]                   }
[10:30:48.953]                 }
[10:30:48.953]                 else {
[10:30:48.953]                   if (TRUE) {
[10:30:48.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.953]                     {
[10:30:48.953]                       inherits <- base::inherits
[10:30:48.953]                       invokeRestart <- base::invokeRestart
[10:30:48.953]                       is.null <- base::is.null
[10:30:48.953]                       muffled <- FALSE
[10:30:48.953]                       if (inherits(cond, "message")) {
[10:30:48.953]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.953]                         if (muffled) 
[10:30:48.953]                           invokeRestart("muffleMessage")
[10:30:48.953]                       }
[10:30:48.953]                       else if (inherits(cond, "warning")) {
[10:30:48.953]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.953]                         if (muffled) 
[10:30:48.953]                           invokeRestart("muffleWarning")
[10:30:48.953]                       }
[10:30:48.953]                       else if (inherits(cond, "condition")) {
[10:30:48.953]                         if (!is.null(pattern)) {
[10:30:48.953]                           computeRestarts <- base::computeRestarts
[10:30:48.953]                           grepl <- base::grepl
[10:30:48.953]                           restarts <- computeRestarts(cond)
[10:30:48.953]                           for (restart in restarts) {
[10:30:48.953]                             name <- restart$name
[10:30:48.953]                             if (is.null(name)) 
[10:30:48.953]                               next
[10:30:48.953]                             if (!grepl(pattern, name)) 
[10:30:48.953]                               next
[10:30:48.953]                             invokeRestart(restart)
[10:30:48.953]                             muffled <- TRUE
[10:30:48.953]                             break
[10:30:48.953]                           }
[10:30:48.953]                         }
[10:30:48.953]                       }
[10:30:48.953]                       invisible(muffled)
[10:30:48.953]                     }
[10:30:48.953]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.953]                   }
[10:30:48.953]                 }
[10:30:48.953]             }
[10:30:48.953]         }))
[10:30:48.953]     }, error = function(ex) {
[10:30:48.953]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.953]                 ...future.rng), started = ...future.startTime, 
[10:30:48.953]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.953]             version = "1.8"), class = "FutureResult")
[10:30:48.953]     }, finally = {
[10:30:48.953]         if (!identical(...future.workdir, getwd())) 
[10:30:48.953]             setwd(...future.workdir)
[10:30:48.953]         {
[10:30:48.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.953]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.953]             }
[10:30:48.953]             base::options(...future.oldOptions)
[10:30:48.953]             if (.Platform$OS.type == "windows") {
[10:30:48.953]                 old_names <- names(...future.oldEnvVars)
[10:30:48.953]                 envs <- base::Sys.getenv()
[10:30:48.953]                 names <- names(envs)
[10:30:48.953]                 common <- intersect(names, old_names)
[10:30:48.953]                 added <- setdiff(names, old_names)
[10:30:48.953]                 removed <- setdiff(old_names, names)
[10:30:48.953]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.953]                   envs[common]]
[10:30:48.953]                 NAMES <- toupper(changed)
[10:30:48.953]                 args <- list()
[10:30:48.953]                 for (kk in seq_along(NAMES)) {
[10:30:48.953]                   name <- changed[[kk]]
[10:30:48.953]                   NAME <- NAMES[[kk]]
[10:30:48.953]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.953]                     next
[10:30:48.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.953]                 }
[10:30:48.953]                 NAMES <- toupper(added)
[10:30:48.953]                 for (kk in seq_along(NAMES)) {
[10:30:48.953]                   name <- added[[kk]]
[10:30:48.953]                   NAME <- NAMES[[kk]]
[10:30:48.953]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.953]                     next
[10:30:48.953]                   args[[name]] <- ""
[10:30:48.953]                 }
[10:30:48.953]                 NAMES <- toupper(removed)
[10:30:48.953]                 for (kk in seq_along(NAMES)) {
[10:30:48.953]                   name <- removed[[kk]]
[10:30:48.953]                   NAME <- NAMES[[kk]]
[10:30:48.953]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.953]                     next
[10:30:48.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.953]                 }
[10:30:48.953]                 if (length(args) > 0) 
[10:30:48.953]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.953]             }
[10:30:48.953]             else {
[10:30:48.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.953]             }
[10:30:48.953]             {
[10:30:48.953]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.953]                   0L) {
[10:30:48.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.953]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.953]                   base::options(opts)
[10:30:48.953]                 }
[10:30:48.953]                 {
[10:30:48.953]                   {
[10:30:48.953]                     base::assign(".Random.seed", c(10407L, 1895445699L, 
[10:30:48.953]                     355952873L, -1742510359L, -1798658587L, 291641892L, 
[10:30:48.953]                     952779669L), envir = base::globalenv(), inherits = FALSE)
[10:30:48.953]                     NULL
[10:30:48.953]                   }
[10:30:48.953]                   options(future.plan = NULL)
[10:30:48.953]                   if (is.na(NA_character_)) 
[10:30:48.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.953]                     .init = FALSE)
[10:30:48.953]                 }
[10:30:48.953]             }
[10:30:48.953]         }
[10:30:48.953]     })
[10:30:48.953]     if (TRUE) {
[10:30:48.953]         base::sink(type = "output", split = FALSE)
[10:30:48.953]         if (TRUE) {
[10:30:48.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.953]         }
[10:30:48.953]         else {
[10:30:48.953]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.953]         }
[10:30:48.953]         base::close(...future.stdout)
[10:30:48.953]         ...future.stdout <- NULL
[10:30:48.953]     }
[10:30:48.953]     ...future.result$conditions <- ...future.conditions
[10:30:48.953]     ...future.result$finished <- base::Sys.time()
[10:30:48.953]     ...future.result
[10:30:48.953] }
[10:30:48.955] assign_globals() ...
[10:30:48.955] List of 5
[10:30:48.955]  $ ...future.FUN            :function (x)  
[10:30:48.955]  $ MoreArgs                 : NULL
[10:30:48.955]  $ ...future.elements_ii    :List of 1
[10:30:48.955]   ..$ :List of 2
[10:30:48.955]   .. ..$ a: num 0
[10:30:48.955]   .. ..$ b: num 0
[10:30:48.955]  $ ...future.seeds_ii       : NULL
[10:30:48.955]  $ ...future.globals.maxSize: NULL
[10:30:48.955]  - attr(*, "where")=List of 5
[10:30:48.955]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:48.955]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:48.955]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:48.955]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:48.955]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:48.955]  - attr(*, "resolved")= logi FALSE
[10:30:48.955]  - attr(*, "total_size")= num 960
[10:30:48.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.955]  - attr(*, "already-done")= logi TRUE
[10:30:48.960] - copied ‘...future.FUN’ to environment
[10:30:48.960] - copied ‘MoreArgs’ to environment
[10:30:48.961] - copied ‘...future.elements_ii’ to environment
[10:30:48.961] - copied ‘...future.seeds_ii’ to environment
[10:30:48.961] - copied ‘...future.globals.maxSize’ to environment
[10:30:48.961] assign_globals() ... done
[10:30:48.961] plan(): Setting new future strategy stack:
[10:30:48.961] List of future strategies:
[10:30:48.961] 1. sequential:
[10:30:48.961]    - args: function (..., envir = parent.frame())
[10:30:48.961]    - tweaked: FALSE
[10:30:48.961]    - call: NULL
[10:30:48.962] plan(): nbrOfWorkers() = 1
[10:30:48.962] plan(): Setting new future strategy stack:
[10:30:48.962] List of future strategies:
[10:30:48.962] 1. sequential:
[10:30:48.962]    - args: function (..., envir = parent.frame())
[10:30:48.962]    - tweaked: FALSE
[10:30:48.962]    - call: plan(strategy)
[10:30:48.963] plan(): nbrOfWorkers() = 1
[10:30:48.963] SequentialFuture started (and completed)
[10:30:48.963] - Launch lazy future ... done
[10:30:48.963] run() for ‘SequentialFuture’ ... done
[10:30:48.963] Created future:
[10:30:48.963] SequentialFuture:
[10:30:48.963] Label: ‘future_mapply-1’
[10:30:48.963] Expression:
[10:30:48.963] {
[10:30:48.963]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.963]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:48.963]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.963]         on.exit(options(oopts), add = TRUE)
[10:30:48.963]     }
[10:30:48.963]     {
[10:30:48.963]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.963]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:48.963]         do.call(mapply, args = args)
[10:30:48.963]     }
[10:30:48.963] }
[10:30:48.963] Lazy evaluation: FALSE
[10:30:48.963] Asynchronous evaluation: FALSE
[10:30:48.963] Local evaluation: TRUE
[10:30:48.963] Environment: R_GlobalEnv
[10:30:48.963] Capture standard output: TRUE
[10:30:48.963] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:48.963] Globals: 5 objects totaling 960 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:48.963] Packages: <none>
[10:30:48.963] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:48.963] Resolved: TRUE
[10:30:48.963] Value: 112 bytes of class ‘list’
[10:30:48.963] Early signaling: FALSE
[10:30:48.963] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:48.963] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:30:48.964] Chunk #1 of 1 ... DONE
[10:30:48.964] Launching 1 futures (chunks) ... DONE
[10:30:48.964] Resolving 1 futures (chunks) ...
[10:30:48.965] resolve() on list ...
[10:30:48.965]  recursive: 0
[10:30:48.965]  length: 1
[10:30:48.965] 
[10:30:48.965] resolved() for ‘SequentialFuture’ ...
[10:30:48.965] - state: ‘finished’
[10:30:48.965] - run: TRUE
[10:30:48.965] - result: ‘FutureResult’
[10:30:48.965] resolved() for ‘SequentialFuture’ ... done
[10:30:48.965] Future #1
[10:30:48.966] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:30:48.966] - nx: 1
[10:30:48.966] - relay: TRUE
[10:30:48.966] - stdout: TRUE
[10:30:48.966] - signal: TRUE
[10:30:48.966] - resignal: FALSE
[10:30:48.966] - force: TRUE
[10:30:48.966] - relayed: [n=1] FALSE
[10:30:48.966] - queued futures: [n=1] FALSE
[10:30:48.966]  - until=1
[10:30:48.966]  - relaying element #1
[10:30:48.967] - relayed: [n=1] TRUE
[10:30:48.967] - queued futures: [n=1] TRUE
[10:30:48.967] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:30:48.967]  length: 0 (resolved future 1)
[10:30:48.967] Relaying remaining futures
[10:30:48.967] signalConditionsASAP(NULL, pos=0) ...
[10:30:48.967] - nx: 1
[10:30:48.967] - relay: TRUE
[10:30:48.967] - stdout: TRUE
[10:30:48.967] - signal: TRUE
[10:30:48.968] - resignal: FALSE
[10:30:48.968] - force: TRUE
[10:30:48.968] - relayed: [n=1] TRUE
[10:30:48.968] - queued futures: [n=1] TRUE
 - flush all
[10:30:48.968] - relayed: [n=1] TRUE
[10:30:48.968] - queued futures: [n=1] TRUE
[10:30:48.968] signalConditionsASAP(NULL, pos=0) ... done
[10:30:48.968] resolve() on list ... DONE
[10:30:48.968]  - Number of value chunks collected: 1
[10:30:48.968] Resolving 1 futures (chunks) ... DONE
[10:30:48.969] Reducing values from 1 chunks ...
[10:30:48.969]  - Number of values collected after concatenation: 2
[10:30:48.969]  - Number of values expected: 2
[10:30:48.969] Reducing values from 1 chunks ... DONE
[10:30:48.969] future_mapply() ... DONE
[10:30:48.969] plan(): Setting new future strategy stack:
[10:30:48.969] List of future strategies:
[10:30:48.969] 1. sequential:
[10:30:48.969]    - args: function (..., envir = parent.frame())
[10:30:48.969]    - tweaked: FALSE
[10:30:48.969]    - call: plan(sequential)
[10:30:48.970] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:30:48.970] plan(): Setting new future strategy stack:
[10:30:48.970] List of future strategies:
[10:30:48.970] 1. multicore:
[10:30:48.970]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:48.970]    - tweaked: FALSE
[10:30:48.970]    - call: plan(strategy)
[10:30:48.974] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[10:30:48.974] future_mapply() ...
[10:30:48.978] Number of chunks: 2
[10:30:48.980] getGlobalsAndPackagesXApply() ...
[10:30:48.980]  - future.globals: TRUE
[10:30:48.980] getGlobalsAndPackages() ...
[10:30:48.980] Searching for globals...
[10:30:48.981] - globals found: [1] ‘FUN’
[10:30:48.981] Searching for globals ... DONE
[10:30:48.981] Resolving globals: FALSE
[10:30:48.981] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:48.982] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:48.982] - globals: [1] ‘FUN’
[10:30:48.982] 
[10:30:48.982] getGlobalsAndPackages() ... DONE
[10:30:48.982]  - globals found/used: [n=1] ‘FUN’
[10:30:48.982]  - needed namespaces: [n=0] 
[10:30:48.983] Finding globals ... DONE
[10:30:48.983] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:48.983] List of 2
[10:30:48.983]  $ ...future.FUN:function (x, ...)  
[10:30:48.983]  $ MoreArgs     : NULL
[10:30:48.983]  - attr(*, "where")=List of 2
[10:30:48.983]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:48.983]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:48.983]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:48.983]  - attr(*, "resolved")= logi FALSE
[10:30:48.983]  - attr(*, "total_size")= num NA
[10:30:48.986] Packages to be attached in all futures: [n=0] 
[10:30:48.986] getGlobalsAndPackagesXApply() ... DONE
[10:30:48.986] Number of futures (= number of chunks): 2
[10:30:48.986] Launching 2 futures (chunks) ...
[10:30:48.986] Chunk #1 of 2 ...
[10:30:48.986]  - Finding globals in '...' for chunk #1 ...
[10:30:48.986] getGlobalsAndPackages() ...
[10:30:48.986] Searching for globals...
[10:30:48.987] 
[10:30:48.987] Searching for globals ... DONE
[10:30:48.987] - globals: [0] <none>
[10:30:48.987] getGlobalsAndPackages() ... DONE
[10:30:48.987]    + additional globals found: [n=0] 
[10:30:48.987]    + additional namespaces needed: [n=0] 
[10:30:48.987]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:48.987]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:48.987]  - seeds: <none>
[10:30:48.988]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.988] getGlobalsAndPackages() ...
[10:30:48.988] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.988] Resolving globals: FALSE
[10:30:48.988] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:48.989] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:48.989] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:48.989] 
[10:30:48.989] getGlobalsAndPackages() ... DONE
[10:30:48.989] run() for ‘Future’ ...
[10:30:48.990] - state: ‘created’
[10:30:48.990] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:48.993] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:48.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:48.994]   - Field: ‘label’
[10:30:48.994]   - Field: ‘local’
[10:30:48.994]   - Field: ‘owner’
[10:30:48.994]   - Field: ‘envir’
[10:30:48.994]   - Field: ‘workers’
[10:30:48.994]   - Field: ‘packages’
[10:30:48.994]   - Field: ‘gc’
[10:30:48.994]   - Field: ‘job’
[10:30:48.994]   - Field: ‘conditions’
[10:30:48.994]   - Field: ‘expr’
[10:30:48.994]   - Field: ‘uuid’
[10:30:48.995]   - Field: ‘seed’
[10:30:48.995]   - Field: ‘version’
[10:30:48.995]   - Field: ‘result’
[10:30:48.995]   - Field: ‘asynchronous’
[10:30:48.995]   - Field: ‘calls’
[10:30:48.995]   - Field: ‘globals’
[10:30:48.995]   - Field: ‘stdout’
[10:30:48.995]   - Field: ‘earlySignal’
[10:30:48.995]   - Field: ‘lazy’
[10:30:48.995]   - Field: ‘state’
[10:30:48.996] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:48.996] - Launch lazy future ...
[10:30:48.997] Packages needed by the future expression (n = 0): <none>
[10:30:48.997] Packages needed by future strategies (n = 0): <none>
[10:30:48.997] {
[10:30:48.997]     {
[10:30:48.997]         {
[10:30:48.997]             ...future.startTime <- base::Sys.time()
[10:30:48.997]             {
[10:30:48.997]                 {
[10:30:48.997]                   {
[10:30:48.997]                     {
[10:30:48.997]                       base::local({
[10:30:48.997]                         has_future <- base::requireNamespace("future", 
[10:30:48.997]                           quietly = TRUE)
[10:30:48.997]                         if (has_future) {
[10:30:48.997]                           ns <- base::getNamespace("future")
[10:30:48.997]                           version <- ns[[".package"]][["version"]]
[10:30:48.997]                           if (is.null(version)) 
[10:30:48.997]                             version <- utils::packageVersion("future")
[10:30:48.997]                         }
[10:30:48.997]                         else {
[10:30:48.997]                           version <- NULL
[10:30:48.997]                         }
[10:30:48.997]                         if (!has_future || version < "1.8.0") {
[10:30:48.997]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:48.997]                             "", base::R.version$version.string), 
[10:30:48.997]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:48.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:48.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:48.997]                               "release", "version")], collapse = " "), 
[10:30:48.997]                             hostname = base::Sys.info()[["nodename"]])
[10:30:48.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:48.997]                             info)
[10:30:48.997]                           info <- base::paste(info, collapse = "; ")
[10:30:48.997]                           if (!has_future) {
[10:30:48.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:48.997]                               info)
[10:30:48.997]                           }
[10:30:48.997]                           else {
[10:30:48.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:48.997]                               info, version)
[10:30:48.997]                           }
[10:30:48.997]                           base::stop(msg)
[10:30:48.997]                         }
[10:30:48.997]                       })
[10:30:48.997]                     }
[10:30:48.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:48.997]                     base::options(mc.cores = 1L)
[10:30:48.997]                   }
[10:30:48.997]                   ...future.strategy.old <- future::plan("list")
[10:30:48.997]                   options(future.plan = NULL)
[10:30:48.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:48.997]                 }
[10:30:48.997]                 ...future.workdir <- getwd()
[10:30:48.997]             }
[10:30:48.997]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:48.997]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:48.997]         }
[10:30:48.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:48.997]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:48.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:48.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:48.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:48.997]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:48.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:48.997]             base::names(...future.oldOptions))
[10:30:48.997]     }
[10:30:48.997]     if (FALSE) {
[10:30:48.997]     }
[10:30:48.997]     else {
[10:30:48.997]         if (TRUE) {
[10:30:48.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:48.997]                 open = "w")
[10:30:48.997]         }
[10:30:48.997]         else {
[10:30:48.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:48.997]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:48.997]         }
[10:30:48.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:48.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:48.997]             base::sink(type = "output", split = FALSE)
[10:30:48.997]             base::close(...future.stdout)
[10:30:48.997]         }, add = TRUE)
[10:30:48.997]     }
[10:30:48.997]     ...future.frame <- base::sys.nframe()
[10:30:48.997]     ...future.conditions <- base::list()
[10:30:48.997]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:48.997]     if (FALSE) {
[10:30:48.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:48.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:48.997]     }
[10:30:48.997]     ...future.result <- base::tryCatch({
[10:30:48.997]         base::withCallingHandlers({
[10:30:48.997]             ...future.value <- base::withVisible(base::local({
[10:30:48.997]                 withCallingHandlers({
[10:30:48.997]                   {
[10:30:48.997]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:48.997]                     if (!identical(...future.globals.maxSize.org, 
[10:30:48.997]                       ...future.globals.maxSize)) {
[10:30:48.997]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:48.997]                       on.exit(options(oopts), add = TRUE)
[10:30:48.997]                     }
[10:30:48.997]                     {
[10:30:48.997]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:48.997]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:48.997]                         USE.NAMES = FALSE)
[10:30:48.997]                       do.call(mapply, args = args)
[10:30:48.997]                     }
[10:30:48.997]                   }
[10:30:48.997]                 }, immediateCondition = function(cond) {
[10:30:48.997]                   save_rds <- function (object, pathname, ...) 
[10:30:48.997]                   {
[10:30:48.997]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:48.997]                     if (file_test("-f", pathname_tmp)) {
[10:30:48.997]                       fi_tmp <- file.info(pathname_tmp)
[10:30:48.997]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:48.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:48.997]                         fi_tmp[["mtime"]])
[10:30:48.997]                     }
[10:30:48.997]                     tryCatch({
[10:30:48.997]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:48.997]                     }, error = function(ex) {
[10:30:48.997]                       msg <- conditionMessage(ex)
[10:30:48.997]                       fi_tmp <- file.info(pathname_tmp)
[10:30:48.997]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:48.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:48.997]                         fi_tmp[["mtime"]], msg)
[10:30:48.997]                       ex$message <- msg
[10:30:48.997]                       stop(ex)
[10:30:48.997]                     })
[10:30:48.997]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:48.997]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:48.997]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:48.997]                       fi_tmp <- file.info(pathname_tmp)
[10:30:48.997]                       fi <- file.info(pathname)
[10:30:48.997]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:48.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:48.997]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:48.997]                         fi[["size"]], fi[["mtime"]])
[10:30:48.997]                       stop(msg)
[10:30:48.997]                     }
[10:30:48.997]                     invisible(pathname)
[10:30:48.997]                   }
[10:30:48.997]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:48.997]                     rootPath = tempdir()) 
[10:30:48.997]                   {
[10:30:48.997]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:48.997]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:48.997]                       tmpdir = path, fileext = ".rds")
[10:30:48.997]                     save_rds(obj, file)
[10:30:48.997]                   }
[10:30:48.997]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:48.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.997]                   {
[10:30:48.997]                     inherits <- base::inherits
[10:30:48.997]                     invokeRestart <- base::invokeRestart
[10:30:48.997]                     is.null <- base::is.null
[10:30:48.997]                     muffled <- FALSE
[10:30:48.997]                     if (inherits(cond, "message")) {
[10:30:48.997]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:48.997]                       if (muffled) 
[10:30:48.997]                         invokeRestart("muffleMessage")
[10:30:48.997]                     }
[10:30:48.997]                     else if (inherits(cond, "warning")) {
[10:30:48.997]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:48.997]                       if (muffled) 
[10:30:48.997]                         invokeRestart("muffleWarning")
[10:30:48.997]                     }
[10:30:48.997]                     else if (inherits(cond, "condition")) {
[10:30:48.997]                       if (!is.null(pattern)) {
[10:30:48.997]                         computeRestarts <- base::computeRestarts
[10:30:48.997]                         grepl <- base::grepl
[10:30:48.997]                         restarts <- computeRestarts(cond)
[10:30:48.997]                         for (restart in restarts) {
[10:30:48.997]                           name <- restart$name
[10:30:48.997]                           if (is.null(name)) 
[10:30:48.997]                             next
[10:30:48.997]                           if (!grepl(pattern, name)) 
[10:30:48.997]                             next
[10:30:48.997]                           invokeRestart(restart)
[10:30:48.997]                           muffled <- TRUE
[10:30:48.997]                           break
[10:30:48.997]                         }
[10:30:48.997]                       }
[10:30:48.997]                     }
[10:30:48.997]                     invisible(muffled)
[10:30:48.997]                   }
[10:30:48.997]                   muffleCondition(cond)
[10:30:48.997]                 })
[10:30:48.997]             }))
[10:30:48.997]             future::FutureResult(value = ...future.value$value, 
[10:30:48.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.997]                   ...future.rng), globalenv = if (FALSE) 
[10:30:48.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:48.997]                     ...future.globalenv.names))
[10:30:48.997]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:48.997]         }, condition = base::local({
[10:30:48.997]             c <- base::c
[10:30:48.997]             inherits <- base::inherits
[10:30:48.997]             invokeRestart <- base::invokeRestart
[10:30:48.997]             length <- base::length
[10:30:48.997]             list <- base::list
[10:30:48.997]             seq.int <- base::seq.int
[10:30:48.997]             signalCondition <- base::signalCondition
[10:30:48.997]             sys.calls <- base::sys.calls
[10:30:48.997]             `[[` <- base::`[[`
[10:30:48.997]             `+` <- base::`+`
[10:30:48.997]             `<<-` <- base::`<<-`
[10:30:48.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:48.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:48.997]                   3L)]
[10:30:48.997]             }
[10:30:48.997]             function(cond) {
[10:30:48.997]                 is_error <- inherits(cond, "error")
[10:30:48.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:48.997]                   NULL)
[10:30:48.997]                 if (is_error) {
[10:30:48.997]                   sessionInformation <- function() {
[10:30:48.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:48.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:48.997]                       search = base::search(), system = base::Sys.info())
[10:30:48.997]                   }
[10:30:48.997]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:48.997]                     cond$call), session = sessionInformation(), 
[10:30:48.997]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:48.997]                   signalCondition(cond)
[10:30:48.997]                 }
[10:30:48.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:48.997]                 "immediateCondition"))) {
[10:30:48.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:48.997]                   ...future.conditions[[length(...future.conditions) + 
[10:30:48.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:48.997]                   if (TRUE && !signal) {
[10:30:48.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.997]                     {
[10:30:48.997]                       inherits <- base::inherits
[10:30:48.997]                       invokeRestart <- base::invokeRestart
[10:30:48.997]                       is.null <- base::is.null
[10:30:48.997]                       muffled <- FALSE
[10:30:48.997]                       if (inherits(cond, "message")) {
[10:30:48.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.997]                         if (muffled) 
[10:30:48.997]                           invokeRestart("muffleMessage")
[10:30:48.997]                       }
[10:30:48.997]                       else if (inherits(cond, "warning")) {
[10:30:48.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.997]                         if (muffled) 
[10:30:48.997]                           invokeRestart("muffleWarning")
[10:30:48.997]                       }
[10:30:48.997]                       else if (inherits(cond, "condition")) {
[10:30:48.997]                         if (!is.null(pattern)) {
[10:30:48.997]                           computeRestarts <- base::computeRestarts
[10:30:48.997]                           grepl <- base::grepl
[10:30:48.997]                           restarts <- computeRestarts(cond)
[10:30:48.997]                           for (restart in restarts) {
[10:30:48.997]                             name <- restart$name
[10:30:48.997]                             if (is.null(name)) 
[10:30:48.997]                               next
[10:30:48.997]                             if (!grepl(pattern, name)) 
[10:30:48.997]                               next
[10:30:48.997]                             invokeRestart(restart)
[10:30:48.997]                             muffled <- TRUE
[10:30:48.997]                             break
[10:30:48.997]                           }
[10:30:48.997]                         }
[10:30:48.997]                       }
[10:30:48.997]                       invisible(muffled)
[10:30:48.997]                     }
[10:30:48.997]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.997]                   }
[10:30:48.997]                 }
[10:30:48.997]                 else {
[10:30:48.997]                   if (TRUE) {
[10:30:48.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:48.997]                     {
[10:30:48.997]                       inherits <- base::inherits
[10:30:48.997]                       invokeRestart <- base::invokeRestart
[10:30:48.997]                       is.null <- base::is.null
[10:30:48.997]                       muffled <- FALSE
[10:30:48.997]                       if (inherits(cond, "message")) {
[10:30:48.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:48.997]                         if (muffled) 
[10:30:48.997]                           invokeRestart("muffleMessage")
[10:30:48.997]                       }
[10:30:48.997]                       else if (inherits(cond, "warning")) {
[10:30:48.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:48.997]                         if (muffled) 
[10:30:48.997]                           invokeRestart("muffleWarning")
[10:30:48.997]                       }
[10:30:48.997]                       else if (inherits(cond, "condition")) {
[10:30:48.997]                         if (!is.null(pattern)) {
[10:30:48.997]                           computeRestarts <- base::computeRestarts
[10:30:48.997]                           grepl <- base::grepl
[10:30:48.997]                           restarts <- computeRestarts(cond)
[10:30:48.997]                           for (restart in restarts) {
[10:30:48.997]                             name <- restart$name
[10:30:48.997]                             if (is.null(name)) 
[10:30:48.997]                               next
[10:30:48.997]                             if (!grepl(pattern, name)) 
[10:30:48.997]                               next
[10:30:48.997]                             invokeRestart(restart)
[10:30:48.997]                             muffled <- TRUE
[10:30:48.997]                             break
[10:30:48.997]                           }
[10:30:48.997]                         }
[10:30:48.997]                       }
[10:30:48.997]                       invisible(muffled)
[10:30:48.997]                     }
[10:30:48.997]                     muffleCondition(cond, pattern = "^muffle")
[10:30:48.997]                   }
[10:30:48.997]                 }
[10:30:48.997]             }
[10:30:48.997]         }))
[10:30:48.997]     }, error = function(ex) {
[10:30:48.997]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:48.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:48.997]                 ...future.rng), started = ...future.startTime, 
[10:30:48.997]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:48.997]             version = "1.8"), class = "FutureResult")
[10:30:48.997]     }, finally = {
[10:30:48.997]         if (!identical(...future.workdir, getwd())) 
[10:30:48.997]             setwd(...future.workdir)
[10:30:48.997]         {
[10:30:48.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:48.997]                 ...future.oldOptions$nwarnings <- NULL
[10:30:48.997]             }
[10:30:48.997]             base::options(...future.oldOptions)
[10:30:48.997]             if (.Platform$OS.type == "windows") {
[10:30:48.997]                 old_names <- names(...future.oldEnvVars)
[10:30:48.997]                 envs <- base::Sys.getenv()
[10:30:48.997]                 names <- names(envs)
[10:30:48.997]                 common <- intersect(names, old_names)
[10:30:48.997]                 added <- setdiff(names, old_names)
[10:30:48.997]                 removed <- setdiff(old_names, names)
[10:30:48.997]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:48.997]                   envs[common]]
[10:30:48.997]                 NAMES <- toupper(changed)
[10:30:48.997]                 args <- list()
[10:30:48.997]                 for (kk in seq_along(NAMES)) {
[10:30:48.997]                   name <- changed[[kk]]
[10:30:48.997]                   NAME <- NAMES[[kk]]
[10:30:48.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.997]                     next
[10:30:48.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.997]                 }
[10:30:48.997]                 NAMES <- toupper(added)
[10:30:48.997]                 for (kk in seq_along(NAMES)) {
[10:30:48.997]                   name <- added[[kk]]
[10:30:48.997]                   NAME <- NAMES[[kk]]
[10:30:48.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.997]                     next
[10:30:48.997]                   args[[name]] <- ""
[10:30:48.997]                 }
[10:30:48.997]                 NAMES <- toupper(removed)
[10:30:48.997]                 for (kk in seq_along(NAMES)) {
[10:30:48.997]                   name <- removed[[kk]]
[10:30:48.997]                   NAME <- NAMES[[kk]]
[10:30:48.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:48.997]                     next
[10:30:48.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:48.997]                 }
[10:30:48.997]                 if (length(args) > 0) 
[10:30:48.997]                   base::do.call(base::Sys.setenv, args = args)
[10:30:48.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:48.997]             }
[10:30:48.997]             else {
[10:30:48.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:48.997]             }
[10:30:48.997]             {
[10:30:48.997]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:48.997]                   0L) {
[10:30:48.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:48.997]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:48.997]                   base::options(opts)
[10:30:48.997]                 }
[10:30:48.997]                 {
[10:30:48.997]                   {
[10:30:48.997]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:48.997]                     NULL
[10:30:48.997]                   }
[10:30:48.997]                   options(future.plan = NULL)
[10:30:48.997]                   if (is.na(NA_character_)) 
[10:30:48.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:48.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:48.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:48.997]                     .init = FALSE)
[10:30:48.997]                 }
[10:30:48.997]             }
[10:30:48.997]         }
[10:30:48.997]     })
[10:30:48.997]     if (TRUE) {
[10:30:48.997]         base::sink(type = "output", split = FALSE)
[10:30:48.997]         if (TRUE) {
[10:30:48.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:48.997]         }
[10:30:48.997]         else {
[10:30:48.997]             ...future.result["stdout"] <- base::list(NULL)
[10:30:48.997]         }
[10:30:48.997]         base::close(...future.stdout)
[10:30:48.997]         ...future.stdout <- NULL
[10:30:48.997]     }
[10:30:48.997]     ...future.result$conditions <- ...future.conditions
[10:30:48.997]     ...future.result$finished <- base::Sys.time()
[10:30:48.997]     ...future.result
[10:30:48.997] }
[10:30:49.000] assign_globals() ...
[10:30:49.000] List of 5
[10:30:49.000]  $ ...future.FUN            :function (x, ...)  
[10:30:49.000]  $ MoreArgs                 : NULL
[10:30:49.000]  $ ...future.elements_ii    :List of 2
[10:30:49.000]   ..$ :List of 2
[10:30:49.000]   .. ..$ : int 1
[10:30:49.000]   .. ..$ : int 2
[10:30:49.000]   ..$ :List of 2
[10:30:49.000]   .. ..$ : int 4
[10:30:49.000]   .. ..$ : int 3
[10:30:49.000]  $ ...future.seeds_ii       : NULL
[10:30:49.000]  $ ...future.globals.maxSize: NULL
[10:30:49.000]  - attr(*, "where")=List of 5
[10:30:49.000]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.000]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.000]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.000]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.000]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.000]  - attr(*, "resolved")= logi FALSE
[10:30:49.000]  - attr(*, "total_size")= num 280
[10:30:49.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.000]  - attr(*, "already-done")= logi TRUE
[10:30:49.006] - copied ‘...future.FUN’ to environment
[10:30:49.006] - copied ‘MoreArgs’ to environment
[10:30:49.006] - copied ‘...future.elements_ii’ to environment
[10:30:49.009] - copied ‘...future.seeds_ii’ to environment
[10:30:49.009] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.009] assign_globals() ... done
[10:30:49.009] requestCore(): workers = 2
[10:30:49.013] MulticoreFuture started
[10:30:49.014] - Launch lazy future ... done
[10:30:49.014] plan(): Setting new future strategy stack:
[10:30:49.015] run() for ‘MulticoreFuture’ ... done
[10:30:49.015] Created future:
[10:30:49.015] List of future strategies:
[10:30:49.015] 1. sequential:
[10:30:49.015]    - args: function (..., envir = parent.frame())
[10:30:49.015]    - tweaked: FALSE
[10:30:49.015]    - call: NULL
[10:30:49.017] plan(): nbrOfWorkers() = 1
[10:30:49.020] plan(): Setting new future strategy stack:
[10:30:49.020] List of future strategies:
[10:30:49.020] 1. multicore:
[10:30:49.020]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.020]    - tweaked: FALSE
[10:30:49.020]    - call: plan(strategy)
[10:30:49.027] plan(): nbrOfWorkers() = 2
[10:30:49.016] MulticoreFuture:
[10:30:49.016] Label: ‘future_mapply-1’
[10:30:49.016] Expression:
[10:30:49.016] {
[10:30:49.016]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.016]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.016]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.016]         on.exit(options(oopts), add = TRUE)
[10:30:49.016]     }
[10:30:49.016]     {
[10:30:49.016]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.016]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.016]         do.call(mapply, args = args)
[10:30:49.016]     }
[10:30:49.016] }
[10:30:49.016] Lazy evaluation: FALSE
[10:30:49.016] Asynchronous evaluation: TRUE
[10:30:49.016] Local evaluation: TRUE
[10:30:49.016] Environment: R_GlobalEnv
[10:30:49.016] Capture standard output: TRUE
[10:30:49.016] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.016] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.016] Packages: <none>
[10:30:49.016] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.016] Resolved: TRUE
[10:30:49.016] Value: <not collected>
[10:30:49.016] Conditions captured: <none>
[10:30:49.016] Early signaling: FALSE
[10:30:49.016] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.016] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.029] Chunk #1 of 2 ... DONE
[10:30:49.029] Chunk #2 of 2 ...
[10:30:49.029]  - Finding globals in '...' for chunk #2 ...
[10:30:49.029] getGlobalsAndPackages() ...
[10:30:49.030] Searching for globals...
[10:30:49.030] 
[10:30:49.031] Searching for globals ... DONE
[10:30:49.031] - globals: [0] <none>
[10:30:49.031] getGlobalsAndPackages() ... DONE
[10:30:49.031]    + additional globals found: [n=0] 
[10:30:49.031]    + additional namespaces needed: [n=0] 
[10:30:49.032]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:49.032]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.032]  - seeds: <none>
[10:30:49.032]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.032] getGlobalsAndPackages() ...
[10:30:49.032] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.033] Resolving globals: FALSE
[10:30:49.034] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:49.034] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.035] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.035] 
[10:30:49.035] getGlobalsAndPackages() ... DONE
[10:30:49.036] run() for ‘Future’ ...
[10:30:49.036] - state: ‘created’
[10:30:49.036] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.041] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.042]   - Field: ‘label’
[10:30:49.042]   - Field: ‘local’
[10:30:49.042]   - Field: ‘owner’
[10:30:49.042]   - Field: ‘envir’
[10:30:49.042]   - Field: ‘workers’
[10:30:49.042]   - Field: ‘packages’
[10:30:49.042]   - Field: ‘gc’
[10:30:49.042]   - Field: ‘job’
[10:30:49.043]   - Field: ‘conditions’
[10:30:49.043]   - Field: ‘expr’
[10:30:49.043]   - Field: ‘uuid’
[10:30:49.043]   - Field: ‘seed’
[10:30:49.043]   - Field: ‘version’
[10:30:49.043]   - Field: ‘result’
[10:30:49.043]   - Field: ‘asynchronous’
[10:30:49.043]   - Field: ‘calls’
[10:30:49.044]   - Field: ‘globals’
[10:30:49.044]   - Field: ‘stdout’
[10:30:49.044]   - Field: ‘earlySignal’
[10:30:49.044]   - Field: ‘lazy’
[10:30:49.044]   - Field: ‘state’
[10:30:49.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.044] - Launch lazy future ...
[10:30:49.045] Packages needed by the future expression (n = 0): <none>
[10:30:49.045] Packages needed by future strategies (n = 0): <none>
[10:30:49.046] {
[10:30:49.046]     {
[10:30:49.046]         {
[10:30:49.046]             ...future.startTime <- base::Sys.time()
[10:30:49.046]             {
[10:30:49.046]                 {
[10:30:49.046]                   {
[10:30:49.046]                     {
[10:30:49.046]                       base::local({
[10:30:49.046]                         has_future <- base::requireNamespace("future", 
[10:30:49.046]                           quietly = TRUE)
[10:30:49.046]                         if (has_future) {
[10:30:49.046]                           ns <- base::getNamespace("future")
[10:30:49.046]                           version <- ns[[".package"]][["version"]]
[10:30:49.046]                           if (is.null(version)) 
[10:30:49.046]                             version <- utils::packageVersion("future")
[10:30:49.046]                         }
[10:30:49.046]                         else {
[10:30:49.046]                           version <- NULL
[10:30:49.046]                         }
[10:30:49.046]                         if (!has_future || version < "1.8.0") {
[10:30:49.046]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.046]                             "", base::R.version$version.string), 
[10:30:49.046]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.046]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.046]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.046]                               "release", "version")], collapse = " "), 
[10:30:49.046]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.046]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.046]                             info)
[10:30:49.046]                           info <- base::paste(info, collapse = "; ")
[10:30:49.046]                           if (!has_future) {
[10:30:49.046]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.046]                               info)
[10:30:49.046]                           }
[10:30:49.046]                           else {
[10:30:49.046]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.046]                               info, version)
[10:30:49.046]                           }
[10:30:49.046]                           base::stop(msg)
[10:30:49.046]                         }
[10:30:49.046]                       })
[10:30:49.046]                     }
[10:30:49.046]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.046]                     base::options(mc.cores = 1L)
[10:30:49.046]                   }
[10:30:49.046]                   ...future.strategy.old <- future::plan("list")
[10:30:49.046]                   options(future.plan = NULL)
[10:30:49.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.046]                 }
[10:30:49.046]                 ...future.workdir <- getwd()
[10:30:49.046]             }
[10:30:49.046]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.046]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.046]         }
[10:30:49.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.046]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.046]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.046]             base::names(...future.oldOptions))
[10:30:49.046]     }
[10:30:49.046]     if (FALSE) {
[10:30:49.046]     }
[10:30:49.046]     else {
[10:30:49.046]         if (TRUE) {
[10:30:49.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.046]                 open = "w")
[10:30:49.046]         }
[10:30:49.046]         else {
[10:30:49.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.046]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.046]         }
[10:30:49.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.046]             base::sink(type = "output", split = FALSE)
[10:30:49.046]             base::close(...future.stdout)
[10:30:49.046]         }, add = TRUE)
[10:30:49.046]     }
[10:30:49.046]     ...future.frame <- base::sys.nframe()
[10:30:49.046]     ...future.conditions <- base::list()
[10:30:49.046]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.046]     if (FALSE) {
[10:30:49.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.046]     }
[10:30:49.046]     ...future.result <- base::tryCatch({
[10:30:49.046]         base::withCallingHandlers({
[10:30:49.046]             ...future.value <- base::withVisible(base::local({
[10:30:49.046]                 withCallingHandlers({
[10:30:49.046]                   {
[10:30:49.046]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.046]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.046]                       ...future.globals.maxSize)) {
[10:30:49.046]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.046]                       on.exit(options(oopts), add = TRUE)
[10:30:49.046]                     }
[10:30:49.046]                     {
[10:30:49.046]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.046]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.046]                         USE.NAMES = FALSE)
[10:30:49.046]                       do.call(mapply, args = args)
[10:30:49.046]                     }
[10:30:49.046]                   }
[10:30:49.046]                 }, immediateCondition = function(cond) {
[10:30:49.046]                   save_rds <- function (object, pathname, ...) 
[10:30:49.046]                   {
[10:30:49.046]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.046]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.046]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.046]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.046]                         fi_tmp[["mtime"]])
[10:30:49.046]                     }
[10:30:49.046]                     tryCatch({
[10:30:49.046]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.046]                     }, error = function(ex) {
[10:30:49.046]                       msg <- conditionMessage(ex)
[10:30:49.046]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.046]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.046]                         fi_tmp[["mtime"]], msg)
[10:30:49.046]                       ex$message <- msg
[10:30:49.046]                       stop(ex)
[10:30:49.046]                     })
[10:30:49.046]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.046]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.046]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.046]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.046]                       fi <- file.info(pathname)
[10:30:49.046]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.046]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.046]                         fi[["size"]], fi[["mtime"]])
[10:30:49.046]                       stop(msg)
[10:30:49.046]                     }
[10:30:49.046]                     invisible(pathname)
[10:30:49.046]                   }
[10:30:49.046]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.046]                     rootPath = tempdir()) 
[10:30:49.046]                   {
[10:30:49.046]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.046]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.046]                       tmpdir = path, fileext = ".rds")
[10:30:49.046]                     save_rds(obj, file)
[10:30:49.046]                   }
[10:30:49.046]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.046]                   {
[10:30:49.046]                     inherits <- base::inherits
[10:30:49.046]                     invokeRestart <- base::invokeRestart
[10:30:49.046]                     is.null <- base::is.null
[10:30:49.046]                     muffled <- FALSE
[10:30:49.046]                     if (inherits(cond, "message")) {
[10:30:49.046]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.046]                       if (muffled) 
[10:30:49.046]                         invokeRestart("muffleMessage")
[10:30:49.046]                     }
[10:30:49.046]                     else if (inherits(cond, "warning")) {
[10:30:49.046]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.046]                       if (muffled) 
[10:30:49.046]                         invokeRestart("muffleWarning")
[10:30:49.046]                     }
[10:30:49.046]                     else if (inherits(cond, "condition")) {
[10:30:49.046]                       if (!is.null(pattern)) {
[10:30:49.046]                         computeRestarts <- base::computeRestarts
[10:30:49.046]                         grepl <- base::grepl
[10:30:49.046]                         restarts <- computeRestarts(cond)
[10:30:49.046]                         for (restart in restarts) {
[10:30:49.046]                           name <- restart$name
[10:30:49.046]                           if (is.null(name)) 
[10:30:49.046]                             next
[10:30:49.046]                           if (!grepl(pattern, name)) 
[10:30:49.046]                             next
[10:30:49.046]                           invokeRestart(restart)
[10:30:49.046]                           muffled <- TRUE
[10:30:49.046]                           break
[10:30:49.046]                         }
[10:30:49.046]                       }
[10:30:49.046]                     }
[10:30:49.046]                     invisible(muffled)
[10:30:49.046]                   }
[10:30:49.046]                   muffleCondition(cond)
[10:30:49.046]                 })
[10:30:49.046]             }))
[10:30:49.046]             future::FutureResult(value = ...future.value$value, 
[10:30:49.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.046]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.046]                     ...future.globalenv.names))
[10:30:49.046]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.046]         }, condition = base::local({
[10:30:49.046]             c <- base::c
[10:30:49.046]             inherits <- base::inherits
[10:30:49.046]             invokeRestart <- base::invokeRestart
[10:30:49.046]             length <- base::length
[10:30:49.046]             list <- base::list
[10:30:49.046]             seq.int <- base::seq.int
[10:30:49.046]             signalCondition <- base::signalCondition
[10:30:49.046]             sys.calls <- base::sys.calls
[10:30:49.046]             `[[` <- base::`[[`
[10:30:49.046]             `+` <- base::`+`
[10:30:49.046]             `<<-` <- base::`<<-`
[10:30:49.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.046]                   3L)]
[10:30:49.046]             }
[10:30:49.046]             function(cond) {
[10:30:49.046]                 is_error <- inherits(cond, "error")
[10:30:49.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.046]                   NULL)
[10:30:49.046]                 if (is_error) {
[10:30:49.046]                   sessionInformation <- function() {
[10:30:49.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.046]                       search = base::search(), system = base::Sys.info())
[10:30:49.046]                   }
[10:30:49.046]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.046]                     cond$call), session = sessionInformation(), 
[10:30:49.046]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.046]                   signalCondition(cond)
[10:30:49.046]                 }
[10:30:49.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.046]                 "immediateCondition"))) {
[10:30:49.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.046]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.046]                   if (TRUE && !signal) {
[10:30:49.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.046]                     {
[10:30:49.046]                       inherits <- base::inherits
[10:30:49.046]                       invokeRestart <- base::invokeRestart
[10:30:49.046]                       is.null <- base::is.null
[10:30:49.046]                       muffled <- FALSE
[10:30:49.046]                       if (inherits(cond, "message")) {
[10:30:49.046]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.046]                         if (muffled) 
[10:30:49.046]                           invokeRestart("muffleMessage")
[10:30:49.046]                       }
[10:30:49.046]                       else if (inherits(cond, "warning")) {
[10:30:49.046]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.046]                         if (muffled) 
[10:30:49.046]                           invokeRestart("muffleWarning")
[10:30:49.046]                       }
[10:30:49.046]                       else if (inherits(cond, "condition")) {
[10:30:49.046]                         if (!is.null(pattern)) {
[10:30:49.046]                           computeRestarts <- base::computeRestarts
[10:30:49.046]                           grepl <- base::grepl
[10:30:49.046]                           restarts <- computeRestarts(cond)
[10:30:49.046]                           for (restart in restarts) {
[10:30:49.046]                             name <- restart$name
[10:30:49.046]                             if (is.null(name)) 
[10:30:49.046]                               next
[10:30:49.046]                             if (!grepl(pattern, name)) 
[10:30:49.046]                               next
[10:30:49.046]                             invokeRestart(restart)
[10:30:49.046]                             muffled <- TRUE
[10:30:49.046]                             break
[10:30:49.046]                           }
[10:30:49.046]                         }
[10:30:49.046]                       }
[10:30:49.046]                       invisible(muffled)
[10:30:49.046]                     }
[10:30:49.046]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.046]                   }
[10:30:49.046]                 }
[10:30:49.046]                 else {
[10:30:49.046]                   if (TRUE) {
[10:30:49.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.046]                     {
[10:30:49.046]                       inherits <- base::inherits
[10:30:49.046]                       invokeRestart <- base::invokeRestart
[10:30:49.046]                       is.null <- base::is.null
[10:30:49.046]                       muffled <- FALSE
[10:30:49.046]                       if (inherits(cond, "message")) {
[10:30:49.046]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.046]                         if (muffled) 
[10:30:49.046]                           invokeRestart("muffleMessage")
[10:30:49.046]                       }
[10:30:49.046]                       else if (inherits(cond, "warning")) {
[10:30:49.046]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.046]                         if (muffled) 
[10:30:49.046]                           invokeRestart("muffleWarning")
[10:30:49.046]                       }
[10:30:49.046]                       else if (inherits(cond, "condition")) {
[10:30:49.046]                         if (!is.null(pattern)) {
[10:30:49.046]                           computeRestarts <- base::computeRestarts
[10:30:49.046]                           grepl <- base::grepl
[10:30:49.046]                           restarts <- computeRestarts(cond)
[10:30:49.046]                           for (restart in restarts) {
[10:30:49.046]                             name <- restart$name
[10:30:49.046]                             if (is.null(name)) 
[10:30:49.046]                               next
[10:30:49.046]                             if (!grepl(pattern, name)) 
[10:30:49.046]                               next
[10:30:49.046]                             invokeRestart(restart)
[10:30:49.046]                             muffled <- TRUE
[10:30:49.046]                             break
[10:30:49.046]                           }
[10:30:49.046]                         }
[10:30:49.046]                       }
[10:30:49.046]                       invisible(muffled)
[10:30:49.046]                     }
[10:30:49.046]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.046]                   }
[10:30:49.046]                 }
[10:30:49.046]             }
[10:30:49.046]         }))
[10:30:49.046]     }, error = function(ex) {
[10:30:49.046]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.046]                 ...future.rng), started = ...future.startTime, 
[10:30:49.046]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.046]             version = "1.8"), class = "FutureResult")
[10:30:49.046]     }, finally = {
[10:30:49.046]         if (!identical(...future.workdir, getwd())) 
[10:30:49.046]             setwd(...future.workdir)
[10:30:49.046]         {
[10:30:49.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.046]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.046]             }
[10:30:49.046]             base::options(...future.oldOptions)
[10:30:49.046]             if (.Platform$OS.type == "windows") {
[10:30:49.046]                 old_names <- names(...future.oldEnvVars)
[10:30:49.046]                 envs <- base::Sys.getenv()
[10:30:49.046]                 names <- names(envs)
[10:30:49.046]                 common <- intersect(names, old_names)
[10:30:49.046]                 added <- setdiff(names, old_names)
[10:30:49.046]                 removed <- setdiff(old_names, names)
[10:30:49.046]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.046]                   envs[common]]
[10:30:49.046]                 NAMES <- toupper(changed)
[10:30:49.046]                 args <- list()
[10:30:49.046]                 for (kk in seq_along(NAMES)) {
[10:30:49.046]                   name <- changed[[kk]]
[10:30:49.046]                   NAME <- NAMES[[kk]]
[10:30:49.046]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.046]                     next
[10:30:49.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.046]                 }
[10:30:49.046]                 NAMES <- toupper(added)
[10:30:49.046]                 for (kk in seq_along(NAMES)) {
[10:30:49.046]                   name <- added[[kk]]
[10:30:49.046]                   NAME <- NAMES[[kk]]
[10:30:49.046]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.046]                     next
[10:30:49.046]                   args[[name]] <- ""
[10:30:49.046]                 }
[10:30:49.046]                 NAMES <- toupper(removed)
[10:30:49.046]                 for (kk in seq_along(NAMES)) {
[10:30:49.046]                   name <- removed[[kk]]
[10:30:49.046]                   NAME <- NAMES[[kk]]
[10:30:49.046]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.046]                     next
[10:30:49.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.046]                 }
[10:30:49.046]                 if (length(args) > 0) 
[10:30:49.046]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.046]             }
[10:30:49.046]             else {
[10:30:49.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.046]             }
[10:30:49.046]             {
[10:30:49.046]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.046]                   0L) {
[10:30:49.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.046]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.046]                   base::options(opts)
[10:30:49.046]                 }
[10:30:49.046]                 {
[10:30:49.046]                   {
[10:30:49.046]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.046]                     NULL
[10:30:49.046]                   }
[10:30:49.046]                   options(future.plan = NULL)
[10:30:49.046]                   if (is.na(NA_character_)) 
[10:30:49.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.046]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.046]                     .init = FALSE)
[10:30:49.046]                 }
[10:30:49.046]             }
[10:30:49.046]         }
[10:30:49.046]     })
[10:30:49.046]     if (TRUE) {
[10:30:49.046]         base::sink(type = "output", split = FALSE)
[10:30:49.046]         if (TRUE) {
[10:30:49.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.046]         }
[10:30:49.046]         else {
[10:30:49.046]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.046]         }
[10:30:49.046]         base::close(...future.stdout)
[10:30:49.046]         ...future.stdout <- NULL
[10:30:49.046]     }
[10:30:49.046]     ...future.result$conditions <- ...future.conditions
[10:30:49.046]     ...future.result$finished <- base::Sys.time()
[10:30:49.046]     ...future.result
[10:30:49.046] }
[10:30:49.049] assign_globals() ...
[10:30:49.049] List of 5
[10:30:49.049]  $ ...future.FUN            :function (x, ...)  
[10:30:49.049]  $ MoreArgs                 : NULL
[10:30:49.049]  $ ...future.elements_ii    :List of 2
[10:30:49.049]   ..$ :List of 2
[10:30:49.049]   .. ..$ : int 3
[10:30:49.049]   .. ..$ : int 4
[10:30:49.049]   ..$ :List of 2
[10:30:49.049]   .. ..$ : int 2
[10:30:49.049]   .. ..$ : int 1
[10:30:49.049]  $ ...future.seeds_ii       : NULL
[10:30:49.049]  $ ...future.globals.maxSize: NULL
[10:30:49.049]  - attr(*, "where")=List of 5
[10:30:49.049]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.049]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.049]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.049]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.049]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.049]  - attr(*, "resolved")= logi FALSE
[10:30:49.049]  - attr(*, "total_size")= num 280
[10:30:49.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.049]  - attr(*, "already-done")= logi TRUE
[10:30:49.057] - copied ‘...future.FUN’ to environment
[10:30:49.057] - copied ‘MoreArgs’ to environment
[10:30:49.057] - copied ‘...future.elements_ii’ to environment
[10:30:49.057] - copied ‘...future.seeds_ii’ to environment
[10:30:49.057] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.057] assign_globals() ... done
[10:30:49.057] requestCore(): workers = 2
[10:30:49.066] MulticoreFuture started
[10:30:49.066] - Launch lazy future ... done
[10:30:49.067] run() for ‘MulticoreFuture’ ... done
[10:30:49.068] Created future:
[10:30:49.068] plan(): Setting new future strategy stack:
[10:30:49.068] List of future strategies:
[10:30:49.068] 1. sequential:
[10:30:49.068]    - args: function (..., envir = parent.frame())
[10:30:49.068]    - tweaked: FALSE
[10:30:49.068]    - call: NULL
[10:30:49.069] plan(): nbrOfWorkers() = 1
[10:30:49.072] plan(): Setting new future strategy stack:
[10:30:49.073] List of future strategies:
[10:30:49.073] 1. multicore:
[10:30:49.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.073]    - tweaked: FALSE
[10:30:49.073]    - call: plan(strategy)
[10:30:49.080] plan(): nbrOfWorkers() = 2
[10:30:49.068] MulticoreFuture:
[10:30:49.068] Label: ‘future_mapply-2’
[10:30:49.068] Expression:
[10:30:49.068] {
[10:30:49.068]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.068]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.068]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.068]         on.exit(options(oopts), add = TRUE)
[10:30:49.068]     }
[10:30:49.068]     {
[10:30:49.068]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.068]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.068]         do.call(mapply, args = args)
[10:30:49.068]     }
[10:30:49.068] }
[10:30:49.068] Lazy evaluation: FALSE
[10:30:49.068] Asynchronous evaluation: TRUE
[10:30:49.068] Local evaluation: TRUE
[10:30:49.068] Environment: R_GlobalEnv
[10:30:49.068] Capture standard output: TRUE
[10:30:49.068] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.068] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.068] Packages: <none>
[10:30:49.068] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.068] Resolved: TRUE
[10:30:49.068] Value: <not collected>
[10:30:49.068] Conditions captured: <none>
[10:30:49.068] Early signaling: FALSE
[10:30:49.068] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.068] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.082] Chunk #2 of 2 ... DONE
[10:30:49.082] Launching 2 futures (chunks) ... DONE
[10:30:49.082] Resolving 2 futures (chunks) ...
[10:30:49.082] resolve() on list ...
[10:30:49.083]  recursive: 0
[10:30:49.083]  length: 2
[10:30:49.083] 
[10:30:49.083] Future #1
[10:30:49.084] result() for MulticoreFuture ...
[10:30:49.087] result() for MulticoreFuture ...
[10:30:49.087] result() for MulticoreFuture ... done
[10:30:49.087] result() for MulticoreFuture ... done
[10:30:49.087] result() for MulticoreFuture ...
[10:30:49.087] result() for MulticoreFuture ... done
[10:30:49.088] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:49.088] - nx: 2
[10:30:49.088] - relay: TRUE
[10:30:49.088] - stdout: TRUE
[10:30:49.088] - signal: TRUE
[10:30:49.089] - resignal: FALSE
[10:30:49.089] - force: TRUE
[10:30:49.089] - relayed: [n=2] FALSE, FALSE
[10:30:49.089] - queued futures: [n=2] FALSE, FALSE
[10:30:49.089]  - until=1
[10:30:49.089]  - relaying element #1
[10:30:49.089] result() for MulticoreFuture ...
[10:30:49.090] result() for MulticoreFuture ... done
[10:30:49.090] result() for MulticoreFuture ...
[10:30:49.090] result() for MulticoreFuture ... done
[10:30:49.090] result() for MulticoreFuture ...
[10:30:49.090] result() for MulticoreFuture ... done
[10:30:49.091] result() for MulticoreFuture ...
[10:30:49.091] result() for MulticoreFuture ... done
[10:30:49.091] - relayed: [n=2] TRUE, FALSE
[10:30:49.091] - queued futures: [n=2] TRUE, FALSE
[10:30:49.091] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:49.092]  length: 1 (resolved future 1)
[10:30:49.092] Future #2
[10:30:49.092] result() for MulticoreFuture ...
[10:30:49.093] result() for MulticoreFuture ...
[10:30:49.093] result() for MulticoreFuture ... done
[10:30:49.093] result() for MulticoreFuture ... done
[10:30:49.093] result() for MulticoreFuture ...
[10:30:49.094] result() for MulticoreFuture ... done
[10:30:49.094] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:49.094] - nx: 2
[10:30:49.094] - relay: TRUE
[10:30:49.094] - stdout: TRUE
[10:30:49.094] - signal: TRUE
[10:30:49.094] - resignal: FALSE
[10:30:49.095] - force: TRUE
[10:30:49.095] - relayed: [n=2] TRUE, FALSE
[10:30:49.095] - queued futures: [n=2] TRUE, FALSE
[10:30:49.095]  - until=2
[10:30:49.095]  - relaying element #2
[10:30:49.095] result() for MulticoreFuture ...
[10:30:49.095] result() for MulticoreFuture ... done
[10:30:49.095] result() for MulticoreFuture ...
[10:30:49.095] result() for MulticoreFuture ... done
[10:30:49.096] result() for MulticoreFuture ...
[10:30:49.096] result() for MulticoreFuture ... done
[10:30:49.096] result() for MulticoreFuture ...
[10:30:49.096] result() for MulticoreFuture ... done
[10:30:49.096] - relayed: [n=2] TRUE, TRUE
[10:30:49.096] - queued futures: [n=2] TRUE, TRUE
[10:30:49.096] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:49.096]  length: 0 (resolved future 2)
[10:30:49.096] Relaying remaining futures
[10:30:49.097] signalConditionsASAP(NULL, pos=0) ...
[10:30:49.097] - nx: 2
[10:30:49.097] - relay: TRUE
[10:30:49.097] - stdout: TRUE
[10:30:49.097] - signal: TRUE
[10:30:49.097] - resignal: FALSE
[10:30:49.097] - force: TRUE
[10:30:49.097] - relayed: [n=2] TRUE, TRUE
[10:30:49.097] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:49.098] - relayed: [n=2] TRUE, TRUE
[10:30:49.098] - queued futures: [n=2] TRUE, TRUE
[10:30:49.098] signalConditionsASAP(NULL, pos=0) ... done
[10:30:49.098] resolve() on list ... DONE
[10:30:49.098] result() for MulticoreFuture ...
[10:30:49.098] result() for MulticoreFuture ... done
[10:30:49.098] result() for MulticoreFuture ...
[10:30:49.098] result() for MulticoreFuture ... done
[10:30:49.098] result() for MulticoreFuture ...
[10:30:49.098] result() for MulticoreFuture ... done
[10:30:49.099] result() for MulticoreFuture ...
[10:30:49.099] result() for MulticoreFuture ... done
[10:30:49.099]  - Number of value chunks collected: 2
[10:30:49.099] Resolving 2 futures (chunks) ... DONE
[10:30:49.099] Reducing values from 2 chunks ...
[10:30:49.099]  - Number of values collected after concatenation: 4
[10:30:49.099]  - Number of values expected: 4
[10:30:49.099] Reducing values from 2 chunks ... DONE
[10:30:49.099] future_mapply() ... DONE
[10:30:49.100] future_mapply() ...
[10:30:49.105] Number of chunks: 2
[10:30:49.105] getGlobalsAndPackagesXApply() ...
[10:30:49.105]  - future.globals: TRUE
[10:30:49.105] getGlobalsAndPackages() ...
[10:30:49.105] Searching for globals...
[10:30:49.106] - globals found: [1] ‘FUN’
[10:30:49.106] Searching for globals ... DONE
[10:30:49.106] Resolving globals: FALSE
[10:30:49.107] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:49.107] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:49.107] - globals: [1] ‘FUN’
[10:30:49.107] 
[10:30:49.107] getGlobalsAndPackages() ... DONE
[10:30:49.108]  - globals found/used: [n=1] ‘FUN’
[10:30:49.108]  - needed namespaces: [n=0] 
[10:30:49.108] Finding globals ... DONE
[10:30:49.108] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:49.108] List of 2
[10:30:49.108]  $ ...future.FUN:function (x, ...)  
[10:30:49.108]  $ MoreArgs     : NULL
[10:30:49.108]  - attr(*, "where")=List of 2
[10:30:49.108]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:49.108]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:49.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.108]  - attr(*, "resolved")= logi FALSE
[10:30:49.108]  - attr(*, "total_size")= num NA
[10:30:49.111] Packages to be attached in all futures: [n=0] 
[10:30:49.111] getGlobalsAndPackagesXApply() ... DONE
[10:30:49.111] Number of futures (= number of chunks): 2
[10:30:49.112] Launching 2 futures (chunks) ...
[10:30:49.112] Chunk #1 of 2 ...
[10:30:49.112]  - Finding globals in '...' for chunk #1 ...
[10:30:49.112] getGlobalsAndPackages() ...
[10:30:49.112] Searching for globals...
[10:30:49.112] 
[10:30:49.113] Searching for globals ... DONE
[10:30:49.113] - globals: [0] <none>
[10:30:49.113] getGlobalsAndPackages() ... DONE
[10:30:49.115]    + additional globals found: [n=0] 
[10:30:49.115]    + additional namespaces needed: [n=0] 
[10:30:49.116]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:49.116]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.116]  - seeds: <none>
[10:30:49.116]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.116] getGlobalsAndPackages() ...
[10:30:49.116] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.116] Resolving globals: FALSE
[10:30:49.117] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:49.118] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.118] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.118] 
[10:30:49.118] getGlobalsAndPackages() ... DONE
[10:30:49.118] run() for ‘Future’ ...
[10:30:49.118] - state: ‘created’
[10:30:49.119] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.123] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.123]   - Field: ‘label’
[10:30:49.123]   - Field: ‘local’
[10:30:49.123]   - Field: ‘owner’
[10:30:49.123]   - Field: ‘envir’
[10:30:49.123]   - Field: ‘workers’
[10:30:49.124]   - Field: ‘packages’
[10:30:49.124]   - Field: ‘gc’
[10:30:49.124]   - Field: ‘job’
[10:30:49.124]   - Field: ‘conditions’
[10:30:49.124]   - Field: ‘expr’
[10:30:49.124]   - Field: ‘uuid’
[10:30:49.124]   - Field: ‘seed’
[10:30:49.124]   - Field: ‘version’
[10:30:49.124]   - Field: ‘result’
[10:30:49.124]   - Field: ‘asynchronous’
[10:30:49.125]   - Field: ‘calls’
[10:30:49.125]   - Field: ‘globals’
[10:30:49.125]   - Field: ‘stdout’
[10:30:49.125]   - Field: ‘earlySignal’
[10:30:49.125]   - Field: ‘lazy’
[10:30:49.125]   - Field: ‘state’
[10:30:49.125] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.125] - Launch lazy future ...
[10:30:49.126] Packages needed by the future expression (n = 0): <none>
[10:30:49.126] Packages needed by future strategies (n = 0): <none>
[10:30:49.126] {
[10:30:49.126]     {
[10:30:49.126]         {
[10:30:49.126]             ...future.startTime <- base::Sys.time()
[10:30:49.126]             {
[10:30:49.126]                 {
[10:30:49.126]                   {
[10:30:49.126]                     {
[10:30:49.126]                       base::local({
[10:30:49.126]                         has_future <- base::requireNamespace("future", 
[10:30:49.126]                           quietly = TRUE)
[10:30:49.126]                         if (has_future) {
[10:30:49.126]                           ns <- base::getNamespace("future")
[10:30:49.126]                           version <- ns[[".package"]][["version"]]
[10:30:49.126]                           if (is.null(version)) 
[10:30:49.126]                             version <- utils::packageVersion("future")
[10:30:49.126]                         }
[10:30:49.126]                         else {
[10:30:49.126]                           version <- NULL
[10:30:49.126]                         }
[10:30:49.126]                         if (!has_future || version < "1.8.0") {
[10:30:49.126]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.126]                             "", base::R.version$version.string), 
[10:30:49.126]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.126]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.126]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.126]                               "release", "version")], collapse = " "), 
[10:30:49.126]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.126]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.126]                             info)
[10:30:49.126]                           info <- base::paste(info, collapse = "; ")
[10:30:49.126]                           if (!has_future) {
[10:30:49.126]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.126]                               info)
[10:30:49.126]                           }
[10:30:49.126]                           else {
[10:30:49.126]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.126]                               info, version)
[10:30:49.126]                           }
[10:30:49.126]                           base::stop(msg)
[10:30:49.126]                         }
[10:30:49.126]                       })
[10:30:49.126]                     }
[10:30:49.126]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.126]                     base::options(mc.cores = 1L)
[10:30:49.126]                   }
[10:30:49.126]                   ...future.strategy.old <- future::plan("list")
[10:30:49.126]                   options(future.plan = NULL)
[10:30:49.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.126]                 }
[10:30:49.126]                 ...future.workdir <- getwd()
[10:30:49.126]             }
[10:30:49.126]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.126]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.126]         }
[10:30:49.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.126]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.126]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.126]             base::names(...future.oldOptions))
[10:30:49.126]     }
[10:30:49.126]     if (FALSE) {
[10:30:49.126]     }
[10:30:49.126]     else {
[10:30:49.126]         if (TRUE) {
[10:30:49.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.126]                 open = "w")
[10:30:49.126]         }
[10:30:49.126]         else {
[10:30:49.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.126]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.126]         }
[10:30:49.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.126]             base::sink(type = "output", split = FALSE)
[10:30:49.126]             base::close(...future.stdout)
[10:30:49.126]         }, add = TRUE)
[10:30:49.126]     }
[10:30:49.126]     ...future.frame <- base::sys.nframe()
[10:30:49.126]     ...future.conditions <- base::list()
[10:30:49.126]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.126]     if (FALSE) {
[10:30:49.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.126]     }
[10:30:49.126]     ...future.result <- base::tryCatch({
[10:30:49.126]         base::withCallingHandlers({
[10:30:49.126]             ...future.value <- base::withVisible(base::local({
[10:30:49.126]                 withCallingHandlers({
[10:30:49.126]                   {
[10:30:49.126]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.126]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.126]                       ...future.globals.maxSize)) {
[10:30:49.126]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.126]                       on.exit(options(oopts), add = TRUE)
[10:30:49.126]                     }
[10:30:49.126]                     {
[10:30:49.126]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.126]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.126]                         USE.NAMES = FALSE)
[10:30:49.126]                       do.call(mapply, args = args)
[10:30:49.126]                     }
[10:30:49.126]                   }
[10:30:49.126]                 }, immediateCondition = function(cond) {
[10:30:49.126]                   save_rds <- function (object, pathname, ...) 
[10:30:49.126]                   {
[10:30:49.126]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.126]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.126]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.126]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.126]                         fi_tmp[["mtime"]])
[10:30:49.126]                     }
[10:30:49.126]                     tryCatch({
[10:30:49.126]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.126]                     }, error = function(ex) {
[10:30:49.126]                       msg <- conditionMessage(ex)
[10:30:49.126]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.126]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.126]                         fi_tmp[["mtime"]], msg)
[10:30:49.126]                       ex$message <- msg
[10:30:49.126]                       stop(ex)
[10:30:49.126]                     })
[10:30:49.126]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.126]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.126]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.126]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.126]                       fi <- file.info(pathname)
[10:30:49.126]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.126]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.126]                         fi[["size"]], fi[["mtime"]])
[10:30:49.126]                       stop(msg)
[10:30:49.126]                     }
[10:30:49.126]                     invisible(pathname)
[10:30:49.126]                   }
[10:30:49.126]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.126]                     rootPath = tempdir()) 
[10:30:49.126]                   {
[10:30:49.126]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.126]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.126]                       tmpdir = path, fileext = ".rds")
[10:30:49.126]                     save_rds(obj, file)
[10:30:49.126]                   }
[10:30:49.126]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.126]                   {
[10:30:49.126]                     inherits <- base::inherits
[10:30:49.126]                     invokeRestart <- base::invokeRestart
[10:30:49.126]                     is.null <- base::is.null
[10:30:49.126]                     muffled <- FALSE
[10:30:49.126]                     if (inherits(cond, "message")) {
[10:30:49.126]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.126]                       if (muffled) 
[10:30:49.126]                         invokeRestart("muffleMessage")
[10:30:49.126]                     }
[10:30:49.126]                     else if (inherits(cond, "warning")) {
[10:30:49.126]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.126]                       if (muffled) 
[10:30:49.126]                         invokeRestart("muffleWarning")
[10:30:49.126]                     }
[10:30:49.126]                     else if (inherits(cond, "condition")) {
[10:30:49.126]                       if (!is.null(pattern)) {
[10:30:49.126]                         computeRestarts <- base::computeRestarts
[10:30:49.126]                         grepl <- base::grepl
[10:30:49.126]                         restarts <- computeRestarts(cond)
[10:30:49.126]                         for (restart in restarts) {
[10:30:49.126]                           name <- restart$name
[10:30:49.126]                           if (is.null(name)) 
[10:30:49.126]                             next
[10:30:49.126]                           if (!grepl(pattern, name)) 
[10:30:49.126]                             next
[10:30:49.126]                           invokeRestart(restart)
[10:30:49.126]                           muffled <- TRUE
[10:30:49.126]                           break
[10:30:49.126]                         }
[10:30:49.126]                       }
[10:30:49.126]                     }
[10:30:49.126]                     invisible(muffled)
[10:30:49.126]                   }
[10:30:49.126]                   muffleCondition(cond)
[10:30:49.126]                 })
[10:30:49.126]             }))
[10:30:49.126]             future::FutureResult(value = ...future.value$value, 
[10:30:49.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.126]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.126]                     ...future.globalenv.names))
[10:30:49.126]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.126]         }, condition = base::local({
[10:30:49.126]             c <- base::c
[10:30:49.126]             inherits <- base::inherits
[10:30:49.126]             invokeRestart <- base::invokeRestart
[10:30:49.126]             length <- base::length
[10:30:49.126]             list <- base::list
[10:30:49.126]             seq.int <- base::seq.int
[10:30:49.126]             signalCondition <- base::signalCondition
[10:30:49.126]             sys.calls <- base::sys.calls
[10:30:49.126]             `[[` <- base::`[[`
[10:30:49.126]             `+` <- base::`+`
[10:30:49.126]             `<<-` <- base::`<<-`
[10:30:49.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.126]                   3L)]
[10:30:49.126]             }
[10:30:49.126]             function(cond) {
[10:30:49.126]                 is_error <- inherits(cond, "error")
[10:30:49.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.126]                   NULL)
[10:30:49.126]                 if (is_error) {
[10:30:49.126]                   sessionInformation <- function() {
[10:30:49.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.126]                       search = base::search(), system = base::Sys.info())
[10:30:49.126]                   }
[10:30:49.126]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.126]                     cond$call), session = sessionInformation(), 
[10:30:49.126]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.126]                   signalCondition(cond)
[10:30:49.126]                 }
[10:30:49.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.126]                 "immediateCondition"))) {
[10:30:49.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.126]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.126]                   if (TRUE && !signal) {
[10:30:49.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.126]                     {
[10:30:49.126]                       inherits <- base::inherits
[10:30:49.126]                       invokeRestart <- base::invokeRestart
[10:30:49.126]                       is.null <- base::is.null
[10:30:49.126]                       muffled <- FALSE
[10:30:49.126]                       if (inherits(cond, "message")) {
[10:30:49.126]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.126]                         if (muffled) 
[10:30:49.126]                           invokeRestart("muffleMessage")
[10:30:49.126]                       }
[10:30:49.126]                       else if (inherits(cond, "warning")) {
[10:30:49.126]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.126]                         if (muffled) 
[10:30:49.126]                           invokeRestart("muffleWarning")
[10:30:49.126]                       }
[10:30:49.126]                       else if (inherits(cond, "condition")) {
[10:30:49.126]                         if (!is.null(pattern)) {
[10:30:49.126]                           computeRestarts <- base::computeRestarts
[10:30:49.126]                           grepl <- base::grepl
[10:30:49.126]                           restarts <- computeRestarts(cond)
[10:30:49.126]                           for (restart in restarts) {
[10:30:49.126]                             name <- restart$name
[10:30:49.126]                             if (is.null(name)) 
[10:30:49.126]                               next
[10:30:49.126]                             if (!grepl(pattern, name)) 
[10:30:49.126]                               next
[10:30:49.126]                             invokeRestart(restart)
[10:30:49.126]                             muffled <- TRUE
[10:30:49.126]                             break
[10:30:49.126]                           }
[10:30:49.126]                         }
[10:30:49.126]                       }
[10:30:49.126]                       invisible(muffled)
[10:30:49.126]                     }
[10:30:49.126]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.126]                   }
[10:30:49.126]                 }
[10:30:49.126]                 else {
[10:30:49.126]                   if (TRUE) {
[10:30:49.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.126]                     {
[10:30:49.126]                       inherits <- base::inherits
[10:30:49.126]                       invokeRestart <- base::invokeRestart
[10:30:49.126]                       is.null <- base::is.null
[10:30:49.126]                       muffled <- FALSE
[10:30:49.126]                       if (inherits(cond, "message")) {
[10:30:49.126]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.126]                         if (muffled) 
[10:30:49.126]                           invokeRestart("muffleMessage")
[10:30:49.126]                       }
[10:30:49.126]                       else if (inherits(cond, "warning")) {
[10:30:49.126]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.126]                         if (muffled) 
[10:30:49.126]                           invokeRestart("muffleWarning")
[10:30:49.126]                       }
[10:30:49.126]                       else if (inherits(cond, "condition")) {
[10:30:49.126]                         if (!is.null(pattern)) {
[10:30:49.126]                           computeRestarts <- base::computeRestarts
[10:30:49.126]                           grepl <- base::grepl
[10:30:49.126]                           restarts <- computeRestarts(cond)
[10:30:49.126]                           for (restart in restarts) {
[10:30:49.126]                             name <- restart$name
[10:30:49.126]                             if (is.null(name)) 
[10:30:49.126]                               next
[10:30:49.126]                             if (!grepl(pattern, name)) 
[10:30:49.126]                               next
[10:30:49.126]                             invokeRestart(restart)
[10:30:49.126]                             muffled <- TRUE
[10:30:49.126]                             break
[10:30:49.126]                           }
[10:30:49.126]                         }
[10:30:49.126]                       }
[10:30:49.126]                       invisible(muffled)
[10:30:49.126]                     }
[10:30:49.126]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.126]                   }
[10:30:49.126]                 }
[10:30:49.126]             }
[10:30:49.126]         }))
[10:30:49.126]     }, error = function(ex) {
[10:30:49.126]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.126]                 ...future.rng), started = ...future.startTime, 
[10:30:49.126]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.126]             version = "1.8"), class = "FutureResult")
[10:30:49.126]     }, finally = {
[10:30:49.126]         if (!identical(...future.workdir, getwd())) 
[10:30:49.126]             setwd(...future.workdir)
[10:30:49.126]         {
[10:30:49.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.126]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.126]             }
[10:30:49.126]             base::options(...future.oldOptions)
[10:30:49.126]             if (.Platform$OS.type == "windows") {
[10:30:49.126]                 old_names <- names(...future.oldEnvVars)
[10:30:49.126]                 envs <- base::Sys.getenv()
[10:30:49.126]                 names <- names(envs)
[10:30:49.126]                 common <- intersect(names, old_names)
[10:30:49.126]                 added <- setdiff(names, old_names)
[10:30:49.126]                 removed <- setdiff(old_names, names)
[10:30:49.126]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.126]                   envs[common]]
[10:30:49.126]                 NAMES <- toupper(changed)
[10:30:49.126]                 args <- list()
[10:30:49.126]                 for (kk in seq_along(NAMES)) {
[10:30:49.126]                   name <- changed[[kk]]
[10:30:49.126]                   NAME <- NAMES[[kk]]
[10:30:49.126]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.126]                     next
[10:30:49.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.126]                 }
[10:30:49.126]                 NAMES <- toupper(added)
[10:30:49.126]                 for (kk in seq_along(NAMES)) {
[10:30:49.126]                   name <- added[[kk]]
[10:30:49.126]                   NAME <- NAMES[[kk]]
[10:30:49.126]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.126]                     next
[10:30:49.126]                   args[[name]] <- ""
[10:30:49.126]                 }
[10:30:49.126]                 NAMES <- toupper(removed)
[10:30:49.126]                 for (kk in seq_along(NAMES)) {
[10:30:49.126]                   name <- removed[[kk]]
[10:30:49.126]                   NAME <- NAMES[[kk]]
[10:30:49.126]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.126]                     next
[10:30:49.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.126]                 }
[10:30:49.126]                 if (length(args) > 0) 
[10:30:49.126]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.126]             }
[10:30:49.126]             else {
[10:30:49.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.126]             }
[10:30:49.126]             {
[10:30:49.126]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.126]                   0L) {
[10:30:49.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.126]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.126]                   base::options(opts)
[10:30:49.126]                 }
[10:30:49.126]                 {
[10:30:49.126]                   {
[10:30:49.126]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.126]                     NULL
[10:30:49.126]                   }
[10:30:49.126]                   options(future.plan = NULL)
[10:30:49.126]                   if (is.na(NA_character_)) 
[10:30:49.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.126]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.126]                     .init = FALSE)
[10:30:49.126]                 }
[10:30:49.126]             }
[10:30:49.126]         }
[10:30:49.126]     })
[10:30:49.126]     if (TRUE) {
[10:30:49.126]         base::sink(type = "output", split = FALSE)
[10:30:49.126]         if (TRUE) {
[10:30:49.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.126]         }
[10:30:49.126]         else {
[10:30:49.126]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.126]         }
[10:30:49.126]         base::close(...future.stdout)
[10:30:49.126]         ...future.stdout <- NULL
[10:30:49.126]     }
[10:30:49.126]     ...future.result$conditions <- ...future.conditions
[10:30:49.126]     ...future.result$finished <- base::Sys.time()
[10:30:49.126]     ...future.result
[10:30:49.126] }
[10:30:49.129] assign_globals() ...
[10:30:49.129] List of 5
[10:30:49.129]  $ ...future.FUN            :function (x, ...)  
[10:30:49.129]  $ MoreArgs                 : NULL
[10:30:49.129]  $ ...future.elements_ii    :List of 2
[10:30:49.129]   ..$ :List of 2
[10:30:49.129]   .. ..$ : int 1
[10:30:49.129]   .. ..$ : int 2
[10:30:49.129]   ..$ :List of 2
[10:30:49.129]   .. ..$ : int 4
[10:30:49.129]   .. ..$ : int 3
[10:30:49.129]  $ ...future.seeds_ii       : NULL
[10:30:49.129]  $ ...future.globals.maxSize: NULL
[10:30:49.129]  - attr(*, "where")=List of 5
[10:30:49.129]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.129]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.129]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.129]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.129]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.129]  - attr(*, "resolved")= logi FALSE
[10:30:49.129]  - attr(*, "total_size")= num 280
[10:30:49.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.129]  - attr(*, "already-done")= logi TRUE
[10:30:49.135] - copied ‘...future.FUN’ to environment
[10:30:49.135] - copied ‘MoreArgs’ to environment
[10:30:49.135] - copied ‘...future.elements_ii’ to environment
[10:30:49.135] - copied ‘...future.seeds_ii’ to environment
[10:30:49.135] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.135] assign_globals() ... done
[10:30:49.135] requestCore(): workers = 2
[10:30:49.138] MulticoreFuture started
[10:30:49.138] - Launch lazy future ... done
[10:30:49.138] run() for ‘MulticoreFuture’ ... done
[10:30:49.139] Created future:
[10:30:49.139] plan(): Setting new future strategy stack:
[10:30:49.139] List of future strategies:
[10:30:49.139] 1. sequential:
[10:30:49.139]    - args: function (..., envir = parent.frame())
[10:30:49.139]    - tweaked: FALSE
[10:30:49.139]    - call: NULL
[10:30:49.140] plan(): nbrOfWorkers() = 1
[10:30:49.142] plan(): Setting new future strategy stack:
[10:30:49.143] List of future strategies:
[10:30:49.143] 1. multicore:
[10:30:49.143]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.143]    - tweaked: FALSE
[10:30:49.143]    - call: plan(strategy)
[10:30:49.148] plan(): nbrOfWorkers() = 2
[10:30:49.139] MulticoreFuture:
[10:30:49.139] Label: ‘future_mapply-1’
[10:30:49.139] Expression:
[10:30:49.139] {
[10:30:49.139]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.139]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.139]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.139]         on.exit(options(oopts), add = TRUE)
[10:30:49.139]     }
[10:30:49.139]     {
[10:30:49.139]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.139]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.139]         do.call(mapply, args = args)
[10:30:49.139]     }
[10:30:49.139] }
[10:30:49.139] Lazy evaluation: FALSE
[10:30:49.139] Asynchronous evaluation: TRUE
[10:30:49.139] Local evaluation: TRUE
[10:30:49.139] Environment: R_GlobalEnv
[10:30:49.139] Capture standard output: TRUE
[10:30:49.139] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.139] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.139] Packages: <none>
[10:30:49.139] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.139] Resolved: TRUE
[10:30:49.139] Value: <not collected>
[10:30:49.139] Conditions captured: <none>
[10:30:49.139] Early signaling: FALSE
[10:30:49.139] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.139] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.149] Chunk #1 of 2 ... DONE
[10:30:49.149] Chunk #2 of 2 ...
[10:30:49.150]  - Finding globals in '...' for chunk #2 ...
[10:30:49.150] getGlobalsAndPackages() ...
[10:30:49.150] Searching for globals...
[10:30:49.150] 
[10:30:49.151] Searching for globals ... DONE
[10:30:49.151] - globals: [0] <none>
[10:30:49.151] getGlobalsAndPackages() ... DONE
[10:30:49.151]    + additional globals found: [n=0] 
[10:30:49.151]    + additional namespaces needed: [n=0] 
[10:30:49.151]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:49.152]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.152]  - seeds: <none>
[10:30:49.152]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.152] getGlobalsAndPackages() ...
[10:30:49.152] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.152] Resolving globals: FALSE
[10:30:49.153] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:49.154] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.154] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.155] 
[10:30:49.155] getGlobalsAndPackages() ... DONE
[10:30:49.155] run() for ‘Future’ ...
[10:30:49.156] - state: ‘created’
[10:30:49.156] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.166] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.167]   - Field: ‘label’
[10:30:49.167]   - Field: ‘local’
[10:30:49.167]   - Field: ‘owner’
[10:30:49.167]   - Field: ‘envir’
[10:30:49.168]   - Field: ‘workers’
[10:30:49.168]   - Field: ‘packages’
[10:30:49.168]   - Field: ‘gc’
[10:30:49.169]   - Field: ‘job’
[10:30:49.169]   - Field: ‘conditions’
[10:30:49.169]   - Field: ‘expr’
[10:30:49.169]   - Field: ‘uuid’
[10:30:49.170]   - Field: ‘seed’
[10:30:49.170]   - Field: ‘version’
[10:30:49.170]   - Field: ‘result’
[10:30:49.170]   - Field: ‘asynchronous’
[10:30:49.171]   - Field: ‘calls’
[10:30:49.171]   - Field: ‘globals’
[10:30:49.171]   - Field: ‘stdout’
[10:30:49.171]   - Field: ‘earlySignal’
[10:30:49.171]   - Field: ‘lazy’
[10:30:49.171]   - Field: ‘state’
[10:30:49.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.172] - Launch lazy future ...
[10:30:49.172] Packages needed by the future expression (n = 0): <none>
[10:30:49.172] Packages needed by future strategies (n = 0): <none>
[10:30:49.173] {
[10:30:49.173]     {
[10:30:49.173]         {
[10:30:49.173]             ...future.startTime <- base::Sys.time()
[10:30:49.173]             {
[10:30:49.173]                 {
[10:30:49.173]                   {
[10:30:49.173]                     {
[10:30:49.173]                       base::local({
[10:30:49.173]                         has_future <- base::requireNamespace("future", 
[10:30:49.173]                           quietly = TRUE)
[10:30:49.173]                         if (has_future) {
[10:30:49.173]                           ns <- base::getNamespace("future")
[10:30:49.173]                           version <- ns[[".package"]][["version"]]
[10:30:49.173]                           if (is.null(version)) 
[10:30:49.173]                             version <- utils::packageVersion("future")
[10:30:49.173]                         }
[10:30:49.173]                         else {
[10:30:49.173]                           version <- NULL
[10:30:49.173]                         }
[10:30:49.173]                         if (!has_future || version < "1.8.0") {
[10:30:49.173]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.173]                             "", base::R.version$version.string), 
[10:30:49.173]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.173]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.173]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.173]                               "release", "version")], collapse = " "), 
[10:30:49.173]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.173]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.173]                             info)
[10:30:49.173]                           info <- base::paste(info, collapse = "; ")
[10:30:49.173]                           if (!has_future) {
[10:30:49.173]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.173]                               info)
[10:30:49.173]                           }
[10:30:49.173]                           else {
[10:30:49.173]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.173]                               info, version)
[10:30:49.173]                           }
[10:30:49.173]                           base::stop(msg)
[10:30:49.173]                         }
[10:30:49.173]                       })
[10:30:49.173]                     }
[10:30:49.173]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.173]                     base::options(mc.cores = 1L)
[10:30:49.173]                   }
[10:30:49.173]                   ...future.strategy.old <- future::plan("list")
[10:30:49.173]                   options(future.plan = NULL)
[10:30:49.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.173]                 }
[10:30:49.173]                 ...future.workdir <- getwd()
[10:30:49.173]             }
[10:30:49.173]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.173]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.173]         }
[10:30:49.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.173]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.173]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.173]             base::names(...future.oldOptions))
[10:30:49.173]     }
[10:30:49.173]     if (FALSE) {
[10:30:49.173]     }
[10:30:49.173]     else {
[10:30:49.173]         if (TRUE) {
[10:30:49.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.173]                 open = "w")
[10:30:49.173]         }
[10:30:49.173]         else {
[10:30:49.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.173]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.173]         }
[10:30:49.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.173]             base::sink(type = "output", split = FALSE)
[10:30:49.173]             base::close(...future.stdout)
[10:30:49.173]         }, add = TRUE)
[10:30:49.173]     }
[10:30:49.173]     ...future.frame <- base::sys.nframe()
[10:30:49.173]     ...future.conditions <- base::list()
[10:30:49.173]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.173]     if (FALSE) {
[10:30:49.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.173]     }
[10:30:49.173]     ...future.result <- base::tryCatch({
[10:30:49.173]         base::withCallingHandlers({
[10:30:49.173]             ...future.value <- base::withVisible(base::local({
[10:30:49.173]                 withCallingHandlers({
[10:30:49.173]                   {
[10:30:49.173]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.173]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.173]                       ...future.globals.maxSize)) {
[10:30:49.173]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.173]                       on.exit(options(oopts), add = TRUE)
[10:30:49.173]                     }
[10:30:49.173]                     {
[10:30:49.173]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.173]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.173]                         USE.NAMES = FALSE)
[10:30:49.173]                       do.call(mapply, args = args)
[10:30:49.173]                     }
[10:30:49.173]                   }
[10:30:49.173]                 }, immediateCondition = function(cond) {
[10:30:49.173]                   save_rds <- function (object, pathname, ...) 
[10:30:49.173]                   {
[10:30:49.173]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.173]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.173]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.173]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.173]                         fi_tmp[["mtime"]])
[10:30:49.173]                     }
[10:30:49.173]                     tryCatch({
[10:30:49.173]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.173]                     }, error = function(ex) {
[10:30:49.173]                       msg <- conditionMessage(ex)
[10:30:49.173]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.173]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.173]                         fi_tmp[["mtime"]], msg)
[10:30:49.173]                       ex$message <- msg
[10:30:49.173]                       stop(ex)
[10:30:49.173]                     })
[10:30:49.173]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.173]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.173]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.173]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.173]                       fi <- file.info(pathname)
[10:30:49.173]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.173]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.173]                         fi[["size"]], fi[["mtime"]])
[10:30:49.173]                       stop(msg)
[10:30:49.173]                     }
[10:30:49.173]                     invisible(pathname)
[10:30:49.173]                   }
[10:30:49.173]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.173]                     rootPath = tempdir()) 
[10:30:49.173]                   {
[10:30:49.173]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.173]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.173]                       tmpdir = path, fileext = ".rds")
[10:30:49.173]                     save_rds(obj, file)
[10:30:49.173]                   }
[10:30:49.173]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.173]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.173]                   {
[10:30:49.173]                     inherits <- base::inherits
[10:30:49.173]                     invokeRestart <- base::invokeRestart
[10:30:49.173]                     is.null <- base::is.null
[10:30:49.173]                     muffled <- FALSE
[10:30:49.173]                     if (inherits(cond, "message")) {
[10:30:49.173]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.173]                       if (muffled) 
[10:30:49.173]                         invokeRestart("muffleMessage")
[10:30:49.173]                     }
[10:30:49.173]                     else if (inherits(cond, "warning")) {
[10:30:49.173]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.173]                       if (muffled) 
[10:30:49.173]                         invokeRestart("muffleWarning")
[10:30:49.173]                     }
[10:30:49.173]                     else if (inherits(cond, "condition")) {
[10:30:49.173]                       if (!is.null(pattern)) {
[10:30:49.173]                         computeRestarts <- base::computeRestarts
[10:30:49.173]                         grepl <- base::grepl
[10:30:49.173]                         restarts <- computeRestarts(cond)
[10:30:49.173]                         for (restart in restarts) {
[10:30:49.173]                           name <- restart$name
[10:30:49.173]                           if (is.null(name)) 
[10:30:49.173]                             next
[10:30:49.173]                           if (!grepl(pattern, name)) 
[10:30:49.173]                             next
[10:30:49.173]                           invokeRestart(restart)
[10:30:49.173]                           muffled <- TRUE
[10:30:49.173]                           break
[10:30:49.173]                         }
[10:30:49.173]                       }
[10:30:49.173]                     }
[10:30:49.173]                     invisible(muffled)
[10:30:49.173]                   }
[10:30:49.173]                   muffleCondition(cond)
[10:30:49.173]                 })
[10:30:49.173]             }))
[10:30:49.173]             future::FutureResult(value = ...future.value$value, 
[10:30:49.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.173]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.173]                     ...future.globalenv.names))
[10:30:49.173]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.173]         }, condition = base::local({
[10:30:49.173]             c <- base::c
[10:30:49.173]             inherits <- base::inherits
[10:30:49.173]             invokeRestart <- base::invokeRestart
[10:30:49.173]             length <- base::length
[10:30:49.173]             list <- base::list
[10:30:49.173]             seq.int <- base::seq.int
[10:30:49.173]             signalCondition <- base::signalCondition
[10:30:49.173]             sys.calls <- base::sys.calls
[10:30:49.173]             `[[` <- base::`[[`
[10:30:49.173]             `+` <- base::`+`
[10:30:49.173]             `<<-` <- base::`<<-`
[10:30:49.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.173]                   3L)]
[10:30:49.173]             }
[10:30:49.173]             function(cond) {
[10:30:49.173]                 is_error <- inherits(cond, "error")
[10:30:49.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.173]                   NULL)
[10:30:49.173]                 if (is_error) {
[10:30:49.173]                   sessionInformation <- function() {
[10:30:49.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.173]                       search = base::search(), system = base::Sys.info())
[10:30:49.173]                   }
[10:30:49.173]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.173]                     cond$call), session = sessionInformation(), 
[10:30:49.173]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.173]                   signalCondition(cond)
[10:30:49.173]                 }
[10:30:49.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.173]                 "immediateCondition"))) {
[10:30:49.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.173]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.173]                   if (TRUE && !signal) {
[10:30:49.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.173]                     {
[10:30:49.173]                       inherits <- base::inherits
[10:30:49.173]                       invokeRestart <- base::invokeRestart
[10:30:49.173]                       is.null <- base::is.null
[10:30:49.173]                       muffled <- FALSE
[10:30:49.173]                       if (inherits(cond, "message")) {
[10:30:49.173]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.173]                         if (muffled) 
[10:30:49.173]                           invokeRestart("muffleMessage")
[10:30:49.173]                       }
[10:30:49.173]                       else if (inherits(cond, "warning")) {
[10:30:49.173]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.173]                         if (muffled) 
[10:30:49.173]                           invokeRestart("muffleWarning")
[10:30:49.173]                       }
[10:30:49.173]                       else if (inherits(cond, "condition")) {
[10:30:49.173]                         if (!is.null(pattern)) {
[10:30:49.173]                           computeRestarts <- base::computeRestarts
[10:30:49.173]                           grepl <- base::grepl
[10:30:49.173]                           restarts <- computeRestarts(cond)
[10:30:49.173]                           for (restart in restarts) {
[10:30:49.173]                             name <- restart$name
[10:30:49.173]                             if (is.null(name)) 
[10:30:49.173]                               next
[10:30:49.173]                             if (!grepl(pattern, name)) 
[10:30:49.173]                               next
[10:30:49.173]                             invokeRestart(restart)
[10:30:49.173]                             muffled <- TRUE
[10:30:49.173]                             break
[10:30:49.173]                           }
[10:30:49.173]                         }
[10:30:49.173]                       }
[10:30:49.173]                       invisible(muffled)
[10:30:49.173]                     }
[10:30:49.173]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.173]                   }
[10:30:49.173]                 }
[10:30:49.173]                 else {
[10:30:49.173]                   if (TRUE) {
[10:30:49.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.173]                     {
[10:30:49.173]                       inherits <- base::inherits
[10:30:49.173]                       invokeRestart <- base::invokeRestart
[10:30:49.173]                       is.null <- base::is.null
[10:30:49.173]                       muffled <- FALSE
[10:30:49.173]                       if (inherits(cond, "message")) {
[10:30:49.173]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.173]                         if (muffled) 
[10:30:49.173]                           invokeRestart("muffleMessage")
[10:30:49.173]                       }
[10:30:49.173]                       else if (inherits(cond, "warning")) {
[10:30:49.173]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.173]                         if (muffled) 
[10:30:49.173]                           invokeRestart("muffleWarning")
[10:30:49.173]                       }
[10:30:49.173]                       else if (inherits(cond, "condition")) {
[10:30:49.173]                         if (!is.null(pattern)) {
[10:30:49.173]                           computeRestarts <- base::computeRestarts
[10:30:49.173]                           grepl <- base::grepl
[10:30:49.173]                           restarts <- computeRestarts(cond)
[10:30:49.173]                           for (restart in restarts) {
[10:30:49.173]                             name <- restart$name
[10:30:49.173]                             if (is.null(name)) 
[10:30:49.173]                               next
[10:30:49.173]                             if (!grepl(pattern, name)) 
[10:30:49.173]                               next
[10:30:49.173]                             invokeRestart(restart)
[10:30:49.173]                             muffled <- TRUE
[10:30:49.173]                             break
[10:30:49.173]                           }
[10:30:49.173]                         }
[10:30:49.173]                       }
[10:30:49.173]                       invisible(muffled)
[10:30:49.173]                     }
[10:30:49.173]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.173]                   }
[10:30:49.173]                 }
[10:30:49.173]             }
[10:30:49.173]         }))
[10:30:49.173]     }, error = function(ex) {
[10:30:49.173]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.173]                 ...future.rng), started = ...future.startTime, 
[10:30:49.173]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.173]             version = "1.8"), class = "FutureResult")
[10:30:49.173]     }, finally = {
[10:30:49.173]         if (!identical(...future.workdir, getwd())) 
[10:30:49.173]             setwd(...future.workdir)
[10:30:49.173]         {
[10:30:49.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.173]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.173]             }
[10:30:49.173]             base::options(...future.oldOptions)
[10:30:49.173]             if (.Platform$OS.type == "windows") {
[10:30:49.173]                 old_names <- names(...future.oldEnvVars)
[10:30:49.173]                 envs <- base::Sys.getenv()
[10:30:49.173]                 names <- names(envs)
[10:30:49.173]                 common <- intersect(names, old_names)
[10:30:49.173]                 added <- setdiff(names, old_names)
[10:30:49.173]                 removed <- setdiff(old_names, names)
[10:30:49.173]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.173]                   envs[common]]
[10:30:49.173]                 NAMES <- toupper(changed)
[10:30:49.173]                 args <- list()
[10:30:49.173]                 for (kk in seq_along(NAMES)) {
[10:30:49.173]                   name <- changed[[kk]]
[10:30:49.173]                   NAME <- NAMES[[kk]]
[10:30:49.173]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.173]                     next
[10:30:49.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.173]                 }
[10:30:49.173]                 NAMES <- toupper(added)
[10:30:49.173]                 for (kk in seq_along(NAMES)) {
[10:30:49.173]                   name <- added[[kk]]
[10:30:49.173]                   NAME <- NAMES[[kk]]
[10:30:49.173]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.173]                     next
[10:30:49.173]                   args[[name]] <- ""
[10:30:49.173]                 }
[10:30:49.173]                 NAMES <- toupper(removed)
[10:30:49.173]                 for (kk in seq_along(NAMES)) {
[10:30:49.173]                   name <- removed[[kk]]
[10:30:49.173]                   NAME <- NAMES[[kk]]
[10:30:49.173]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.173]                     next
[10:30:49.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.173]                 }
[10:30:49.173]                 if (length(args) > 0) 
[10:30:49.173]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.173]             }
[10:30:49.173]             else {
[10:30:49.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.173]             }
[10:30:49.173]             {
[10:30:49.173]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.173]                   0L) {
[10:30:49.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.173]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.173]                   base::options(opts)
[10:30:49.173]                 }
[10:30:49.173]                 {
[10:30:49.173]                   {
[10:30:49.173]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.173]                     NULL
[10:30:49.173]                   }
[10:30:49.173]                   options(future.plan = NULL)
[10:30:49.173]                   if (is.na(NA_character_)) 
[10:30:49.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.173]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.173]                     .init = FALSE)
[10:30:49.173]                 }
[10:30:49.173]             }
[10:30:49.173]         }
[10:30:49.173]     })
[10:30:49.173]     if (TRUE) {
[10:30:49.173]         base::sink(type = "output", split = FALSE)
[10:30:49.173]         if (TRUE) {
[10:30:49.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.173]         }
[10:30:49.173]         else {
[10:30:49.173]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.173]         }
[10:30:49.173]         base::close(...future.stdout)
[10:30:49.173]         ...future.stdout <- NULL
[10:30:49.173]     }
[10:30:49.173]     ...future.result$conditions <- ...future.conditions
[10:30:49.173]     ...future.result$finished <- base::Sys.time()
[10:30:49.173]     ...future.result
[10:30:49.173] }
[10:30:49.176] assign_globals() ...
[10:30:49.176] List of 5
[10:30:49.176]  $ ...future.FUN            :function (x, ...)  
[10:30:49.176]  $ MoreArgs                 : NULL
[10:30:49.176]  $ ...future.elements_ii    :List of 2
[10:30:49.176]   ..$ :List of 2
[10:30:49.176]   .. ..$ : int 3
[10:30:49.176]   .. ..$ : int 4
[10:30:49.176]   ..$ :List of 2
[10:30:49.176]   .. ..$ : int 2
[10:30:49.176]   .. ..$ : int 1
[10:30:49.176]  $ ...future.seeds_ii       : NULL
[10:30:49.176]  $ ...future.globals.maxSize: NULL
[10:30:49.176]  - attr(*, "where")=List of 5
[10:30:49.176]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.176]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.176]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.176]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.176]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.176]  - attr(*, "resolved")= logi FALSE
[10:30:49.176]  - attr(*, "total_size")= num 280
[10:30:49.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.176]  - attr(*, "already-done")= logi TRUE
[10:30:49.185] - copied ‘...future.FUN’ to environment
[10:30:49.185] - copied ‘MoreArgs’ to environment
[10:30:49.185] - copied ‘...future.elements_ii’ to environment
[10:30:49.185] - copied ‘...future.seeds_ii’ to environment
[10:30:49.185] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.185] assign_globals() ... done
[10:30:49.186] requestCore(): workers = 2
[10:30:49.188] MulticoreFuture started
[10:30:49.188] - Launch lazy future ... done
[10:30:49.189] run() for ‘MulticoreFuture’ ... done
[10:30:49.189] Created future:
[10:30:49.189] plan(): Setting new future strategy stack:
[10:30:49.190] List of future strategies:
[10:30:49.190] 1. sequential:
[10:30:49.190]    - args: function (..., envir = parent.frame())
[10:30:49.190]    - tweaked: FALSE
[10:30:49.190]    - call: NULL
[10:30:49.191] plan(): nbrOfWorkers() = 1
[10:30:49.193] plan(): Setting new future strategy stack:
[10:30:49.193] List of future strategies:
[10:30:49.193] 1. multicore:
[10:30:49.193]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.193]    - tweaked: FALSE
[10:30:49.193]    - call: plan(strategy)
[10:30:49.198] plan(): nbrOfWorkers() = 2
[10:30:49.189] MulticoreFuture:
[10:30:49.189] Label: ‘future_mapply-2’
[10:30:49.189] Expression:
[10:30:49.189] {
[10:30:49.189]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.189]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.189]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.189]         on.exit(options(oopts), add = TRUE)
[10:30:49.189]     }
[10:30:49.189]     {
[10:30:49.189]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.189]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.189]         do.call(mapply, args = args)
[10:30:49.189]     }
[10:30:49.189] }
[10:30:49.189] Lazy evaluation: FALSE
[10:30:49.189] Asynchronous evaluation: TRUE
[10:30:49.189] Local evaluation: TRUE
[10:30:49.189] Environment: R_GlobalEnv
[10:30:49.189] Capture standard output: TRUE
[10:30:49.189] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.189] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.189] Packages: <none>
[10:30:49.189] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.189] Resolved: TRUE
[10:30:49.189] Value: <not collected>
[10:30:49.189] Conditions captured: <none>
[10:30:49.189] Early signaling: FALSE
[10:30:49.189] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.189] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.199] Chunk #2 of 2 ... DONE
[10:30:49.200] Launching 2 futures (chunks) ... DONE
[10:30:49.200] Resolving 2 futures (chunks) ...
[10:30:49.200] resolve() on list ...
[10:30:49.200]  recursive: 0
[10:30:49.200]  length: 2
[10:30:49.200] 
[10:30:49.201] Future #1
[10:30:49.201] result() for MulticoreFuture ...
[10:30:49.202] result() for MulticoreFuture ...
[10:30:49.202] result() for MulticoreFuture ... done
[10:30:49.202] result() for MulticoreFuture ... done
[10:30:49.202] result() for MulticoreFuture ...
[10:30:49.203] result() for MulticoreFuture ... done
[10:30:49.203] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:49.203] - nx: 2
[10:30:49.203] - relay: TRUE
[10:30:49.203] - stdout: TRUE
[10:30:49.203] - signal: TRUE
[10:30:49.204] - resignal: FALSE
[10:30:49.204] - force: TRUE
[10:30:49.204] - relayed: [n=2] FALSE, FALSE
[10:30:49.204] - queued futures: [n=2] FALSE, FALSE
[10:30:49.204]  - until=1
[10:30:49.204]  - relaying element #1
[10:30:49.204] result() for MulticoreFuture ...
[10:30:49.205] result() for MulticoreFuture ... done
[10:30:49.205] result() for MulticoreFuture ...
[10:30:49.205] result() for MulticoreFuture ... done
[10:30:49.205] result() for MulticoreFuture ...
[10:30:49.205] result() for MulticoreFuture ... done
[10:30:49.206] result() for MulticoreFuture ...
[10:30:49.206] result() for MulticoreFuture ... done
[10:30:49.206] - relayed: [n=2] TRUE, FALSE
[10:30:49.206] - queued futures: [n=2] TRUE, FALSE
[10:30:49.206] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:49.206]  length: 1 (resolved future 1)
[10:30:49.207] Future #2
[10:30:49.207] result() for MulticoreFuture ...
[10:30:49.208] result() for MulticoreFuture ...
[10:30:49.208] result() for MulticoreFuture ... done
[10:30:49.208] result() for MulticoreFuture ... done
[10:30:49.208] result() for MulticoreFuture ...
[10:30:49.208] result() for MulticoreFuture ... done
[10:30:49.208] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:49.208] - nx: 2
[10:30:49.209] - relay: TRUE
[10:30:49.209] - stdout: TRUE
[10:30:49.209] - signal: TRUE
[10:30:49.209] - resignal: FALSE
[10:30:49.209] - force: TRUE
[10:30:49.209] - relayed: [n=2] TRUE, FALSE
[10:30:49.209] - queued futures: [n=2] TRUE, FALSE
[10:30:49.209]  - until=2
[10:30:49.210]  - relaying element #2
[10:30:49.210] result() for MulticoreFuture ...
[10:30:49.210] result() for MulticoreFuture ... done
[10:30:49.210] result() for MulticoreFuture ...
[10:30:49.210] result() for MulticoreFuture ... done
[10:30:49.210] result() for MulticoreFuture ...
[10:30:49.213] result() for MulticoreFuture ... done
[10:30:49.214] result() for MulticoreFuture ...
[10:30:49.214] result() for MulticoreFuture ... done
[10:30:49.214] - relayed: [n=2] TRUE, TRUE
[10:30:49.214] - queued futures: [n=2] TRUE, TRUE
[10:30:49.214] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:49.215]  length: 0 (resolved future 2)
[10:30:49.215] Relaying remaining futures
[10:30:49.215] signalConditionsASAP(NULL, pos=0) ...
[10:30:49.215] - nx: 2
[10:30:49.215] - relay: TRUE
[10:30:49.215] - stdout: TRUE
[10:30:49.216] - signal: TRUE
[10:30:49.216] - resignal: FALSE
[10:30:49.216] - force: TRUE
[10:30:49.216] - relayed: [n=2] TRUE, TRUE
[10:30:49.216] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:49.216] - relayed: [n=2] TRUE, TRUE
[10:30:49.217] - queued futures: [n=2] TRUE, TRUE
[10:30:49.217] signalConditionsASAP(NULL, pos=0) ... done
[10:30:49.217] resolve() on list ... DONE
[10:30:49.217] result() for MulticoreFuture ...
[10:30:49.217] result() for MulticoreFuture ... done
[10:30:49.217] result() for MulticoreFuture ...
[10:30:49.218] result() for MulticoreFuture ... done
[10:30:49.218] result() for MulticoreFuture ...
[10:30:49.218] result() for MulticoreFuture ... done
[10:30:49.218] result() for MulticoreFuture ...
[10:30:49.218] result() for MulticoreFuture ... done
[10:30:49.218]  - Number of value chunks collected: 2
[10:30:49.218] Resolving 2 futures (chunks) ... DONE
[10:30:49.219] Reducing values from 2 chunks ...
[10:30:49.219]  - Number of values collected after concatenation: 4
[10:30:49.219]  - Number of values expected: 4
[10:30:49.219] Reducing values from 2 chunks ... DONE
[10:30:49.219] future_mapply() ... DONE
[10:30:49.219] future_mapply() ...
[10:30:49.224] Number of chunks: 2
[10:30:49.224] getGlobalsAndPackagesXApply() ...
[10:30:49.224]  - future.globals: TRUE
[10:30:49.225] getGlobalsAndPackages() ...
[10:30:49.225] Searching for globals...
[10:30:49.226] - globals found: [1] ‘FUN’
[10:30:49.226] Searching for globals ... DONE
[10:30:49.226] Resolving globals: FALSE
[10:30:49.226] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:49.227] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:49.227] - globals: [1] ‘FUN’
[10:30:49.227] 
[10:30:49.227] getGlobalsAndPackages() ... DONE
[10:30:49.227]  - globals found/used: [n=1] ‘FUN’
[10:30:49.227]  - needed namespaces: [n=0] 
[10:30:49.228] Finding globals ... DONE
[10:30:49.228] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:49.228] List of 2
[10:30:49.228]  $ ...future.FUN:function (x, ...)  
[10:30:49.228]  $ MoreArgs     : NULL
[10:30:49.228]  - attr(*, "where")=List of 2
[10:30:49.228]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:49.228]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:49.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.228]  - attr(*, "resolved")= logi FALSE
[10:30:49.228]  - attr(*, "total_size")= num NA
[10:30:49.231] Packages to be attached in all futures: [n=0] 
[10:30:49.231] getGlobalsAndPackagesXApply() ... DONE
[10:30:49.231] Number of futures (= number of chunks): 2
[10:30:49.231] Launching 2 futures (chunks) ...
[10:30:49.232] Chunk #1 of 2 ...
[10:30:49.232]  - Finding globals in '...' for chunk #1 ...
[10:30:49.232] getGlobalsAndPackages() ...
[10:30:49.232] Searching for globals...
[10:30:49.232] 
[10:30:49.232] Searching for globals ... DONE
[10:30:49.233] - globals: [0] <none>
[10:30:49.233] getGlobalsAndPackages() ... DONE
[10:30:49.233]    + additional globals found: [n=0] 
[10:30:49.233]    + additional namespaces needed: [n=0] 
[10:30:49.233]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:49.233]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.233]  - seeds: <none>
[10:30:49.233]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.233] getGlobalsAndPackages() ...
[10:30:49.234] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.234] Resolving globals: FALSE
[10:30:49.234] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:49.235] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.235] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.235] 
[10:30:49.235] getGlobalsAndPackages() ... DONE
[10:30:49.235] run() for ‘Future’ ...
[10:30:49.235] - state: ‘created’
[10:30:49.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.239] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.240]   - Field: ‘label’
[10:30:49.240]   - Field: ‘local’
[10:30:49.240]   - Field: ‘owner’
[10:30:49.240]   - Field: ‘envir’
[10:30:49.240]   - Field: ‘workers’
[10:30:49.240]   - Field: ‘packages’
[10:30:49.240]   - Field: ‘gc’
[10:30:49.240]   - Field: ‘job’
[10:30:49.240]   - Field: ‘conditions’
[10:30:49.240]   - Field: ‘expr’
[10:30:49.241]   - Field: ‘uuid’
[10:30:49.241]   - Field: ‘seed’
[10:30:49.241]   - Field: ‘version’
[10:30:49.241]   - Field: ‘result’
[10:30:49.241]   - Field: ‘asynchronous’
[10:30:49.241]   - Field: ‘calls’
[10:30:49.241]   - Field: ‘globals’
[10:30:49.241]   - Field: ‘stdout’
[10:30:49.241]   - Field: ‘earlySignal’
[10:30:49.241]   - Field: ‘lazy’
[10:30:49.241]   - Field: ‘state’
[10:30:49.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.242] - Launch lazy future ...
[10:30:49.242] Packages needed by the future expression (n = 0): <none>
[10:30:49.242] Packages needed by future strategies (n = 0): <none>
[10:30:49.243] {
[10:30:49.243]     {
[10:30:49.243]         {
[10:30:49.243]             ...future.startTime <- base::Sys.time()
[10:30:49.243]             {
[10:30:49.243]                 {
[10:30:49.243]                   {
[10:30:49.243]                     {
[10:30:49.243]                       base::local({
[10:30:49.243]                         has_future <- base::requireNamespace("future", 
[10:30:49.243]                           quietly = TRUE)
[10:30:49.243]                         if (has_future) {
[10:30:49.243]                           ns <- base::getNamespace("future")
[10:30:49.243]                           version <- ns[[".package"]][["version"]]
[10:30:49.243]                           if (is.null(version)) 
[10:30:49.243]                             version <- utils::packageVersion("future")
[10:30:49.243]                         }
[10:30:49.243]                         else {
[10:30:49.243]                           version <- NULL
[10:30:49.243]                         }
[10:30:49.243]                         if (!has_future || version < "1.8.0") {
[10:30:49.243]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.243]                             "", base::R.version$version.string), 
[10:30:49.243]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.243]                               "release", "version")], collapse = " "), 
[10:30:49.243]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.243]                             info)
[10:30:49.243]                           info <- base::paste(info, collapse = "; ")
[10:30:49.243]                           if (!has_future) {
[10:30:49.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.243]                               info)
[10:30:49.243]                           }
[10:30:49.243]                           else {
[10:30:49.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.243]                               info, version)
[10:30:49.243]                           }
[10:30:49.243]                           base::stop(msg)
[10:30:49.243]                         }
[10:30:49.243]                       })
[10:30:49.243]                     }
[10:30:49.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.243]                     base::options(mc.cores = 1L)
[10:30:49.243]                   }
[10:30:49.243]                   ...future.strategy.old <- future::plan("list")
[10:30:49.243]                   options(future.plan = NULL)
[10:30:49.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.243]                 }
[10:30:49.243]                 ...future.workdir <- getwd()
[10:30:49.243]             }
[10:30:49.243]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.243]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.243]         }
[10:30:49.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.243]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.243]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.243]             base::names(...future.oldOptions))
[10:30:49.243]     }
[10:30:49.243]     if (FALSE) {
[10:30:49.243]     }
[10:30:49.243]     else {
[10:30:49.243]         if (TRUE) {
[10:30:49.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.243]                 open = "w")
[10:30:49.243]         }
[10:30:49.243]         else {
[10:30:49.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.243]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.243]         }
[10:30:49.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.243]             base::sink(type = "output", split = FALSE)
[10:30:49.243]             base::close(...future.stdout)
[10:30:49.243]         }, add = TRUE)
[10:30:49.243]     }
[10:30:49.243]     ...future.frame <- base::sys.nframe()
[10:30:49.243]     ...future.conditions <- base::list()
[10:30:49.243]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.243]     if (FALSE) {
[10:30:49.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.243]     }
[10:30:49.243]     ...future.result <- base::tryCatch({
[10:30:49.243]         base::withCallingHandlers({
[10:30:49.243]             ...future.value <- base::withVisible(base::local({
[10:30:49.243]                 withCallingHandlers({
[10:30:49.243]                   {
[10:30:49.243]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.243]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.243]                       ...future.globals.maxSize)) {
[10:30:49.243]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.243]                       on.exit(options(oopts), add = TRUE)
[10:30:49.243]                     }
[10:30:49.243]                     {
[10:30:49.243]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.243]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.243]                         USE.NAMES = FALSE)
[10:30:49.243]                       do.call(mapply, args = args)
[10:30:49.243]                     }
[10:30:49.243]                   }
[10:30:49.243]                 }, immediateCondition = function(cond) {
[10:30:49.243]                   save_rds <- function (object, pathname, ...) 
[10:30:49.243]                   {
[10:30:49.243]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.243]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.243]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.243]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.243]                         fi_tmp[["mtime"]])
[10:30:49.243]                     }
[10:30:49.243]                     tryCatch({
[10:30:49.243]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.243]                     }, error = function(ex) {
[10:30:49.243]                       msg <- conditionMessage(ex)
[10:30:49.243]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.243]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.243]                         fi_tmp[["mtime"]], msg)
[10:30:49.243]                       ex$message <- msg
[10:30:49.243]                       stop(ex)
[10:30:49.243]                     })
[10:30:49.243]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.243]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.243]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.243]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.243]                       fi <- file.info(pathname)
[10:30:49.243]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.243]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.243]                         fi[["size"]], fi[["mtime"]])
[10:30:49.243]                       stop(msg)
[10:30:49.243]                     }
[10:30:49.243]                     invisible(pathname)
[10:30:49.243]                   }
[10:30:49.243]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.243]                     rootPath = tempdir()) 
[10:30:49.243]                   {
[10:30:49.243]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.243]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.243]                       tmpdir = path, fileext = ".rds")
[10:30:49.243]                     save_rds(obj, file)
[10:30:49.243]                   }
[10:30:49.243]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.243]                   {
[10:30:49.243]                     inherits <- base::inherits
[10:30:49.243]                     invokeRestart <- base::invokeRestart
[10:30:49.243]                     is.null <- base::is.null
[10:30:49.243]                     muffled <- FALSE
[10:30:49.243]                     if (inherits(cond, "message")) {
[10:30:49.243]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.243]                       if (muffled) 
[10:30:49.243]                         invokeRestart("muffleMessage")
[10:30:49.243]                     }
[10:30:49.243]                     else if (inherits(cond, "warning")) {
[10:30:49.243]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.243]                       if (muffled) 
[10:30:49.243]                         invokeRestart("muffleWarning")
[10:30:49.243]                     }
[10:30:49.243]                     else if (inherits(cond, "condition")) {
[10:30:49.243]                       if (!is.null(pattern)) {
[10:30:49.243]                         computeRestarts <- base::computeRestarts
[10:30:49.243]                         grepl <- base::grepl
[10:30:49.243]                         restarts <- computeRestarts(cond)
[10:30:49.243]                         for (restart in restarts) {
[10:30:49.243]                           name <- restart$name
[10:30:49.243]                           if (is.null(name)) 
[10:30:49.243]                             next
[10:30:49.243]                           if (!grepl(pattern, name)) 
[10:30:49.243]                             next
[10:30:49.243]                           invokeRestart(restart)
[10:30:49.243]                           muffled <- TRUE
[10:30:49.243]                           break
[10:30:49.243]                         }
[10:30:49.243]                       }
[10:30:49.243]                     }
[10:30:49.243]                     invisible(muffled)
[10:30:49.243]                   }
[10:30:49.243]                   muffleCondition(cond)
[10:30:49.243]                 })
[10:30:49.243]             }))
[10:30:49.243]             future::FutureResult(value = ...future.value$value, 
[10:30:49.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.243]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.243]                     ...future.globalenv.names))
[10:30:49.243]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.243]         }, condition = base::local({
[10:30:49.243]             c <- base::c
[10:30:49.243]             inherits <- base::inherits
[10:30:49.243]             invokeRestart <- base::invokeRestart
[10:30:49.243]             length <- base::length
[10:30:49.243]             list <- base::list
[10:30:49.243]             seq.int <- base::seq.int
[10:30:49.243]             signalCondition <- base::signalCondition
[10:30:49.243]             sys.calls <- base::sys.calls
[10:30:49.243]             `[[` <- base::`[[`
[10:30:49.243]             `+` <- base::`+`
[10:30:49.243]             `<<-` <- base::`<<-`
[10:30:49.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.243]                   3L)]
[10:30:49.243]             }
[10:30:49.243]             function(cond) {
[10:30:49.243]                 is_error <- inherits(cond, "error")
[10:30:49.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.243]                   NULL)
[10:30:49.243]                 if (is_error) {
[10:30:49.243]                   sessionInformation <- function() {
[10:30:49.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.243]                       search = base::search(), system = base::Sys.info())
[10:30:49.243]                   }
[10:30:49.243]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.243]                     cond$call), session = sessionInformation(), 
[10:30:49.243]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.243]                   signalCondition(cond)
[10:30:49.243]                 }
[10:30:49.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.243]                 "immediateCondition"))) {
[10:30:49.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.243]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.243]                   if (TRUE && !signal) {
[10:30:49.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.243]                     {
[10:30:49.243]                       inherits <- base::inherits
[10:30:49.243]                       invokeRestart <- base::invokeRestart
[10:30:49.243]                       is.null <- base::is.null
[10:30:49.243]                       muffled <- FALSE
[10:30:49.243]                       if (inherits(cond, "message")) {
[10:30:49.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.243]                         if (muffled) 
[10:30:49.243]                           invokeRestart("muffleMessage")
[10:30:49.243]                       }
[10:30:49.243]                       else if (inherits(cond, "warning")) {
[10:30:49.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.243]                         if (muffled) 
[10:30:49.243]                           invokeRestart("muffleWarning")
[10:30:49.243]                       }
[10:30:49.243]                       else if (inherits(cond, "condition")) {
[10:30:49.243]                         if (!is.null(pattern)) {
[10:30:49.243]                           computeRestarts <- base::computeRestarts
[10:30:49.243]                           grepl <- base::grepl
[10:30:49.243]                           restarts <- computeRestarts(cond)
[10:30:49.243]                           for (restart in restarts) {
[10:30:49.243]                             name <- restart$name
[10:30:49.243]                             if (is.null(name)) 
[10:30:49.243]                               next
[10:30:49.243]                             if (!grepl(pattern, name)) 
[10:30:49.243]                               next
[10:30:49.243]                             invokeRestart(restart)
[10:30:49.243]                             muffled <- TRUE
[10:30:49.243]                             break
[10:30:49.243]                           }
[10:30:49.243]                         }
[10:30:49.243]                       }
[10:30:49.243]                       invisible(muffled)
[10:30:49.243]                     }
[10:30:49.243]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.243]                   }
[10:30:49.243]                 }
[10:30:49.243]                 else {
[10:30:49.243]                   if (TRUE) {
[10:30:49.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.243]                     {
[10:30:49.243]                       inherits <- base::inherits
[10:30:49.243]                       invokeRestart <- base::invokeRestart
[10:30:49.243]                       is.null <- base::is.null
[10:30:49.243]                       muffled <- FALSE
[10:30:49.243]                       if (inherits(cond, "message")) {
[10:30:49.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.243]                         if (muffled) 
[10:30:49.243]                           invokeRestart("muffleMessage")
[10:30:49.243]                       }
[10:30:49.243]                       else if (inherits(cond, "warning")) {
[10:30:49.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.243]                         if (muffled) 
[10:30:49.243]                           invokeRestart("muffleWarning")
[10:30:49.243]                       }
[10:30:49.243]                       else if (inherits(cond, "condition")) {
[10:30:49.243]                         if (!is.null(pattern)) {
[10:30:49.243]                           computeRestarts <- base::computeRestarts
[10:30:49.243]                           grepl <- base::grepl
[10:30:49.243]                           restarts <- computeRestarts(cond)
[10:30:49.243]                           for (restart in restarts) {
[10:30:49.243]                             name <- restart$name
[10:30:49.243]                             if (is.null(name)) 
[10:30:49.243]                               next
[10:30:49.243]                             if (!grepl(pattern, name)) 
[10:30:49.243]                               next
[10:30:49.243]                             invokeRestart(restart)
[10:30:49.243]                             muffled <- TRUE
[10:30:49.243]                             break
[10:30:49.243]                           }
[10:30:49.243]                         }
[10:30:49.243]                       }
[10:30:49.243]                       invisible(muffled)
[10:30:49.243]                     }
[10:30:49.243]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.243]                   }
[10:30:49.243]                 }
[10:30:49.243]             }
[10:30:49.243]         }))
[10:30:49.243]     }, error = function(ex) {
[10:30:49.243]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.243]                 ...future.rng), started = ...future.startTime, 
[10:30:49.243]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.243]             version = "1.8"), class = "FutureResult")
[10:30:49.243]     }, finally = {
[10:30:49.243]         if (!identical(...future.workdir, getwd())) 
[10:30:49.243]             setwd(...future.workdir)
[10:30:49.243]         {
[10:30:49.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.243]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.243]             }
[10:30:49.243]             base::options(...future.oldOptions)
[10:30:49.243]             if (.Platform$OS.type == "windows") {
[10:30:49.243]                 old_names <- names(...future.oldEnvVars)
[10:30:49.243]                 envs <- base::Sys.getenv()
[10:30:49.243]                 names <- names(envs)
[10:30:49.243]                 common <- intersect(names, old_names)
[10:30:49.243]                 added <- setdiff(names, old_names)
[10:30:49.243]                 removed <- setdiff(old_names, names)
[10:30:49.243]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.243]                   envs[common]]
[10:30:49.243]                 NAMES <- toupper(changed)
[10:30:49.243]                 args <- list()
[10:30:49.243]                 for (kk in seq_along(NAMES)) {
[10:30:49.243]                   name <- changed[[kk]]
[10:30:49.243]                   NAME <- NAMES[[kk]]
[10:30:49.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.243]                     next
[10:30:49.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.243]                 }
[10:30:49.243]                 NAMES <- toupper(added)
[10:30:49.243]                 for (kk in seq_along(NAMES)) {
[10:30:49.243]                   name <- added[[kk]]
[10:30:49.243]                   NAME <- NAMES[[kk]]
[10:30:49.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.243]                     next
[10:30:49.243]                   args[[name]] <- ""
[10:30:49.243]                 }
[10:30:49.243]                 NAMES <- toupper(removed)
[10:30:49.243]                 for (kk in seq_along(NAMES)) {
[10:30:49.243]                   name <- removed[[kk]]
[10:30:49.243]                   NAME <- NAMES[[kk]]
[10:30:49.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.243]                     next
[10:30:49.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.243]                 }
[10:30:49.243]                 if (length(args) > 0) 
[10:30:49.243]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.243]             }
[10:30:49.243]             else {
[10:30:49.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.243]             }
[10:30:49.243]             {
[10:30:49.243]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.243]                   0L) {
[10:30:49.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.243]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.243]                   base::options(opts)
[10:30:49.243]                 }
[10:30:49.243]                 {
[10:30:49.243]                   {
[10:30:49.243]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.243]                     NULL
[10:30:49.243]                   }
[10:30:49.243]                   options(future.plan = NULL)
[10:30:49.243]                   if (is.na(NA_character_)) 
[10:30:49.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.243]                     .init = FALSE)
[10:30:49.243]                 }
[10:30:49.243]             }
[10:30:49.243]         }
[10:30:49.243]     })
[10:30:49.243]     if (TRUE) {
[10:30:49.243]         base::sink(type = "output", split = FALSE)
[10:30:49.243]         if (TRUE) {
[10:30:49.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.243]         }
[10:30:49.243]         else {
[10:30:49.243]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.243]         }
[10:30:49.243]         base::close(...future.stdout)
[10:30:49.243]         ...future.stdout <- NULL
[10:30:49.243]     }
[10:30:49.243]     ...future.result$conditions <- ...future.conditions
[10:30:49.243]     ...future.result$finished <- base::Sys.time()
[10:30:49.243]     ...future.result
[10:30:49.243] }
[10:30:49.245] assign_globals() ...
[10:30:49.245] List of 5
[10:30:49.245]  $ ...future.FUN            :function (x, ...)  
[10:30:49.245]  $ MoreArgs                 : NULL
[10:30:49.245]  $ ...future.elements_ii    :List of 2
[10:30:49.245]   ..$ times:List of 2
[10:30:49.245]   .. ..$ : int 1
[10:30:49.245]   .. ..$ : int 2
[10:30:49.245]   ..$ x    :List of 2
[10:30:49.245]   .. ..$ : int 4
[10:30:49.245]   .. ..$ : int 3
[10:30:49.245]  $ ...future.seeds_ii       : NULL
[10:30:49.245]  $ ...future.globals.maxSize: NULL
[10:30:49.245]  - attr(*, "where")=List of 5
[10:30:49.245]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.245]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.245]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.245]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.245]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.245]  - attr(*, "resolved")= logi FALSE
[10:30:49.245]  - attr(*, "total_size")= num 280
[10:30:49.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.245]  - attr(*, "already-done")= logi TRUE
[10:30:49.254] - copied ‘...future.FUN’ to environment
[10:30:49.254] - copied ‘MoreArgs’ to environment
[10:30:49.254] - copied ‘...future.elements_ii’ to environment
[10:30:49.254] - copied ‘...future.seeds_ii’ to environment
[10:30:49.254] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.254] assign_globals() ... done
[10:30:49.255] requestCore(): workers = 2
[10:30:49.257] MulticoreFuture started
[10:30:49.257] - Launch lazy future ... done
[10:30:49.258] run() for ‘MulticoreFuture’ ... done
[10:30:49.258] Created future:
[10:30:49.258] plan(): Setting new future strategy stack:
[10:30:49.258] List of future strategies:
[10:30:49.258] 1. sequential:
[10:30:49.258]    - args: function (..., envir = parent.frame())
[10:30:49.258]    - tweaked: FALSE
[10:30:49.258]    - call: NULL
[10:30:49.259] plan(): nbrOfWorkers() = 1
[10:30:49.262] plan(): Setting new future strategy stack:
[10:30:49.262] List of future strategies:
[10:30:49.262] 1. multicore:
[10:30:49.262]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.262]    - tweaked: FALSE
[10:30:49.262]    - call: plan(strategy)
[10:30:49.267] plan(): nbrOfWorkers() = 2
[10:30:49.258] MulticoreFuture:
[10:30:49.258] Label: ‘future_mapply-1’
[10:30:49.258] Expression:
[10:30:49.258] {
[10:30:49.258]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.258]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.258]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.258]         on.exit(options(oopts), add = TRUE)
[10:30:49.258]     }
[10:30:49.258]     {
[10:30:49.258]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.258]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.258]         do.call(mapply, args = args)
[10:30:49.258]     }
[10:30:49.258] }
[10:30:49.258] Lazy evaluation: FALSE
[10:30:49.258] Asynchronous evaluation: TRUE
[10:30:49.258] Local evaluation: TRUE
[10:30:49.258] Environment: R_GlobalEnv
[10:30:49.258] Capture standard output: TRUE
[10:30:49.258] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.258] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.258] Packages: <none>
[10:30:49.258] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.258] Resolved: TRUE
[10:30:49.258] Value: <not collected>
[10:30:49.258] Conditions captured: <none>
[10:30:49.258] Early signaling: FALSE
[10:30:49.258] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.258] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.268] Chunk #1 of 2 ... DONE
[10:30:49.269] Chunk #2 of 2 ...
[10:30:49.269]  - Finding globals in '...' for chunk #2 ...
[10:30:49.269] getGlobalsAndPackages() ...
[10:30:49.269] Searching for globals...
[10:30:49.270] 
[10:30:49.270] Searching for globals ... DONE
[10:30:49.270] - globals: [0] <none>
[10:30:49.270] getGlobalsAndPackages() ... DONE
[10:30:49.270]    + additional globals found: [n=0] 
[10:30:49.271]    + additional namespaces needed: [n=0] 
[10:30:49.271]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:49.271]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.271]  - seeds: <none>
[10:30:49.271]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.271] getGlobalsAndPackages() ...
[10:30:49.271] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.272] Resolving globals: FALSE
[10:30:49.272] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:49.273] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.273] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.274] 
[10:30:49.274] getGlobalsAndPackages() ... DONE
[10:30:49.274] run() for ‘Future’ ...
[10:30:49.274] - state: ‘created’
[10:30:49.275] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.279] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.280]   - Field: ‘label’
[10:30:49.280]   - Field: ‘local’
[10:30:49.280]   - Field: ‘owner’
[10:30:49.280]   - Field: ‘envir’
[10:30:49.280]   - Field: ‘workers’
[10:30:49.281]   - Field: ‘packages’
[10:30:49.281]   - Field: ‘gc’
[10:30:49.281]   - Field: ‘job’
[10:30:49.281]   - Field: ‘conditions’
[10:30:49.281]   - Field: ‘expr’
[10:30:49.281]   - Field: ‘uuid’
[10:30:49.282]   - Field: ‘seed’
[10:30:49.282]   - Field: ‘version’
[10:30:49.282]   - Field: ‘result’
[10:30:49.282]   - Field: ‘asynchronous’
[10:30:49.282]   - Field: ‘calls’
[10:30:49.282]   - Field: ‘globals’
[10:30:49.282]   - Field: ‘stdout’
[10:30:49.283]   - Field: ‘earlySignal’
[10:30:49.283]   - Field: ‘lazy’
[10:30:49.283]   - Field: ‘state’
[10:30:49.283] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.283] - Launch lazy future ...
[10:30:49.284] Packages needed by the future expression (n = 0): <none>
[10:30:49.284] Packages needed by future strategies (n = 0): <none>
[10:30:49.285] {
[10:30:49.285]     {
[10:30:49.285]         {
[10:30:49.285]             ...future.startTime <- base::Sys.time()
[10:30:49.285]             {
[10:30:49.285]                 {
[10:30:49.285]                   {
[10:30:49.285]                     {
[10:30:49.285]                       base::local({
[10:30:49.285]                         has_future <- base::requireNamespace("future", 
[10:30:49.285]                           quietly = TRUE)
[10:30:49.285]                         if (has_future) {
[10:30:49.285]                           ns <- base::getNamespace("future")
[10:30:49.285]                           version <- ns[[".package"]][["version"]]
[10:30:49.285]                           if (is.null(version)) 
[10:30:49.285]                             version <- utils::packageVersion("future")
[10:30:49.285]                         }
[10:30:49.285]                         else {
[10:30:49.285]                           version <- NULL
[10:30:49.285]                         }
[10:30:49.285]                         if (!has_future || version < "1.8.0") {
[10:30:49.285]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.285]                             "", base::R.version$version.string), 
[10:30:49.285]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.285]                               "release", "version")], collapse = " "), 
[10:30:49.285]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.285]                             info)
[10:30:49.285]                           info <- base::paste(info, collapse = "; ")
[10:30:49.285]                           if (!has_future) {
[10:30:49.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.285]                               info)
[10:30:49.285]                           }
[10:30:49.285]                           else {
[10:30:49.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.285]                               info, version)
[10:30:49.285]                           }
[10:30:49.285]                           base::stop(msg)
[10:30:49.285]                         }
[10:30:49.285]                       })
[10:30:49.285]                     }
[10:30:49.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.285]                     base::options(mc.cores = 1L)
[10:30:49.285]                   }
[10:30:49.285]                   ...future.strategy.old <- future::plan("list")
[10:30:49.285]                   options(future.plan = NULL)
[10:30:49.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.285]                 }
[10:30:49.285]                 ...future.workdir <- getwd()
[10:30:49.285]             }
[10:30:49.285]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.285]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.285]         }
[10:30:49.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.285]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.285]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.285]             base::names(...future.oldOptions))
[10:30:49.285]     }
[10:30:49.285]     if (FALSE) {
[10:30:49.285]     }
[10:30:49.285]     else {
[10:30:49.285]         if (TRUE) {
[10:30:49.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.285]                 open = "w")
[10:30:49.285]         }
[10:30:49.285]         else {
[10:30:49.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.285]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.285]         }
[10:30:49.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.285]             base::sink(type = "output", split = FALSE)
[10:30:49.285]             base::close(...future.stdout)
[10:30:49.285]         }, add = TRUE)
[10:30:49.285]     }
[10:30:49.285]     ...future.frame <- base::sys.nframe()
[10:30:49.285]     ...future.conditions <- base::list()
[10:30:49.285]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.285]     if (FALSE) {
[10:30:49.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.285]     }
[10:30:49.285]     ...future.result <- base::tryCatch({
[10:30:49.285]         base::withCallingHandlers({
[10:30:49.285]             ...future.value <- base::withVisible(base::local({
[10:30:49.285]                 withCallingHandlers({
[10:30:49.285]                   {
[10:30:49.285]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.285]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.285]                       ...future.globals.maxSize)) {
[10:30:49.285]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.285]                       on.exit(options(oopts), add = TRUE)
[10:30:49.285]                     }
[10:30:49.285]                     {
[10:30:49.285]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.285]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.285]                         USE.NAMES = FALSE)
[10:30:49.285]                       do.call(mapply, args = args)
[10:30:49.285]                     }
[10:30:49.285]                   }
[10:30:49.285]                 }, immediateCondition = function(cond) {
[10:30:49.285]                   save_rds <- function (object, pathname, ...) 
[10:30:49.285]                   {
[10:30:49.285]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.285]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.285]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.285]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.285]                         fi_tmp[["mtime"]])
[10:30:49.285]                     }
[10:30:49.285]                     tryCatch({
[10:30:49.285]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.285]                     }, error = function(ex) {
[10:30:49.285]                       msg <- conditionMessage(ex)
[10:30:49.285]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.285]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.285]                         fi_tmp[["mtime"]], msg)
[10:30:49.285]                       ex$message <- msg
[10:30:49.285]                       stop(ex)
[10:30:49.285]                     })
[10:30:49.285]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.285]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.285]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.285]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.285]                       fi <- file.info(pathname)
[10:30:49.285]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.285]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.285]                         fi[["size"]], fi[["mtime"]])
[10:30:49.285]                       stop(msg)
[10:30:49.285]                     }
[10:30:49.285]                     invisible(pathname)
[10:30:49.285]                   }
[10:30:49.285]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.285]                     rootPath = tempdir()) 
[10:30:49.285]                   {
[10:30:49.285]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.285]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.285]                       tmpdir = path, fileext = ".rds")
[10:30:49.285]                     save_rds(obj, file)
[10:30:49.285]                   }
[10:30:49.285]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.285]                   {
[10:30:49.285]                     inherits <- base::inherits
[10:30:49.285]                     invokeRestart <- base::invokeRestart
[10:30:49.285]                     is.null <- base::is.null
[10:30:49.285]                     muffled <- FALSE
[10:30:49.285]                     if (inherits(cond, "message")) {
[10:30:49.285]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.285]                       if (muffled) 
[10:30:49.285]                         invokeRestart("muffleMessage")
[10:30:49.285]                     }
[10:30:49.285]                     else if (inherits(cond, "warning")) {
[10:30:49.285]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.285]                       if (muffled) 
[10:30:49.285]                         invokeRestart("muffleWarning")
[10:30:49.285]                     }
[10:30:49.285]                     else if (inherits(cond, "condition")) {
[10:30:49.285]                       if (!is.null(pattern)) {
[10:30:49.285]                         computeRestarts <- base::computeRestarts
[10:30:49.285]                         grepl <- base::grepl
[10:30:49.285]                         restarts <- computeRestarts(cond)
[10:30:49.285]                         for (restart in restarts) {
[10:30:49.285]                           name <- restart$name
[10:30:49.285]                           if (is.null(name)) 
[10:30:49.285]                             next
[10:30:49.285]                           if (!grepl(pattern, name)) 
[10:30:49.285]                             next
[10:30:49.285]                           invokeRestart(restart)
[10:30:49.285]                           muffled <- TRUE
[10:30:49.285]                           break
[10:30:49.285]                         }
[10:30:49.285]                       }
[10:30:49.285]                     }
[10:30:49.285]                     invisible(muffled)
[10:30:49.285]                   }
[10:30:49.285]                   muffleCondition(cond)
[10:30:49.285]                 })
[10:30:49.285]             }))
[10:30:49.285]             future::FutureResult(value = ...future.value$value, 
[10:30:49.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.285]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.285]                     ...future.globalenv.names))
[10:30:49.285]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.285]         }, condition = base::local({
[10:30:49.285]             c <- base::c
[10:30:49.285]             inherits <- base::inherits
[10:30:49.285]             invokeRestart <- base::invokeRestart
[10:30:49.285]             length <- base::length
[10:30:49.285]             list <- base::list
[10:30:49.285]             seq.int <- base::seq.int
[10:30:49.285]             signalCondition <- base::signalCondition
[10:30:49.285]             sys.calls <- base::sys.calls
[10:30:49.285]             `[[` <- base::`[[`
[10:30:49.285]             `+` <- base::`+`
[10:30:49.285]             `<<-` <- base::`<<-`
[10:30:49.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.285]                   3L)]
[10:30:49.285]             }
[10:30:49.285]             function(cond) {
[10:30:49.285]                 is_error <- inherits(cond, "error")
[10:30:49.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.285]                   NULL)
[10:30:49.285]                 if (is_error) {
[10:30:49.285]                   sessionInformation <- function() {
[10:30:49.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.285]                       search = base::search(), system = base::Sys.info())
[10:30:49.285]                   }
[10:30:49.285]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.285]                     cond$call), session = sessionInformation(), 
[10:30:49.285]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.285]                   signalCondition(cond)
[10:30:49.285]                 }
[10:30:49.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.285]                 "immediateCondition"))) {
[10:30:49.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.285]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.285]                   if (TRUE && !signal) {
[10:30:49.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.285]                     {
[10:30:49.285]                       inherits <- base::inherits
[10:30:49.285]                       invokeRestart <- base::invokeRestart
[10:30:49.285]                       is.null <- base::is.null
[10:30:49.285]                       muffled <- FALSE
[10:30:49.285]                       if (inherits(cond, "message")) {
[10:30:49.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.285]                         if (muffled) 
[10:30:49.285]                           invokeRestart("muffleMessage")
[10:30:49.285]                       }
[10:30:49.285]                       else if (inherits(cond, "warning")) {
[10:30:49.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.285]                         if (muffled) 
[10:30:49.285]                           invokeRestart("muffleWarning")
[10:30:49.285]                       }
[10:30:49.285]                       else if (inherits(cond, "condition")) {
[10:30:49.285]                         if (!is.null(pattern)) {
[10:30:49.285]                           computeRestarts <- base::computeRestarts
[10:30:49.285]                           grepl <- base::grepl
[10:30:49.285]                           restarts <- computeRestarts(cond)
[10:30:49.285]                           for (restart in restarts) {
[10:30:49.285]                             name <- restart$name
[10:30:49.285]                             if (is.null(name)) 
[10:30:49.285]                               next
[10:30:49.285]                             if (!grepl(pattern, name)) 
[10:30:49.285]                               next
[10:30:49.285]                             invokeRestart(restart)
[10:30:49.285]                             muffled <- TRUE
[10:30:49.285]                             break
[10:30:49.285]                           }
[10:30:49.285]                         }
[10:30:49.285]                       }
[10:30:49.285]                       invisible(muffled)
[10:30:49.285]                     }
[10:30:49.285]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.285]                   }
[10:30:49.285]                 }
[10:30:49.285]                 else {
[10:30:49.285]                   if (TRUE) {
[10:30:49.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.285]                     {
[10:30:49.285]                       inherits <- base::inherits
[10:30:49.285]                       invokeRestart <- base::invokeRestart
[10:30:49.285]                       is.null <- base::is.null
[10:30:49.285]                       muffled <- FALSE
[10:30:49.285]                       if (inherits(cond, "message")) {
[10:30:49.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.285]                         if (muffled) 
[10:30:49.285]                           invokeRestart("muffleMessage")
[10:30:49.285]                       }
[10:30:49.285]                       else if (inherits(cond, "warning")) {
[10:30:49.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.285]                         if (muffled) 
[10:30:49.285]                           invokeRestart("muffleWarning")
[10:30:49.285]                       }
[10:30:49.285]                       else if (inherits(cond, "condition")) {
[10:30:49.285]                         if (!is.null(pattern)) {
[10:30:49.285]                           computeRestarts <- base::computeRestarts
[10:30:49.285]                           grepl <- base::grepl
[10:30:49.285]                           restarts <- computeRestarts(cond)
[10:30:49.285]                           for (restart in restarts) {
[10:30:49.285]                             name <- restart$name
[10:30:49.285]                             if (is.null(name)) 
[10:30:49.285]                               next
[10:30:49.285]                             if (!grepl(pattern, name)) 
[10:30:49.285]                               next
[10:30:49.285]                             invokeRestart(restart)
[10:30:49.285]                             muffled <- TRUE
[10:30:49.285]                             break
[10:30:49.285]                           }
[10:30:49.285]                         }
[10:30:49.285]                       }
[10:30:49.285]                       invisible(muffled)
[10:30:49.285]                     }
[10:30:49.285]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.285]                   }
[10:30:49.285]                 }
[10:30:49.285]             }
[10:30:49.285]         }))
[10:30:49.285]     }, error = function(ex) {
[10:30:49.285]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.285]                 ...future.rng), started = ...future.startTime, 
[10:30:49.285]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.285]             version = "1.8"), class = "FutureResult")
[10:30:49.285]     }, finally = {
[10:30:49.285]         if (!identical(...future.workdir, getwd())) 
[10:30:49.285]             setwd(...future.workdir)
[10:30:49.285]         {
[10:30:49.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.285]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.285]             }
[10:30:49.285]             base::options(...future.oldOptions)
[10:30:49.285]             if (.Platform$OS.type == "windows") {
[10:30:49.285]                 old_names <- names(...future.oldEnvVars)
[10:30:49.285]                 envs <- base::Sys.getenv()
[10:30:49.285]                 names <- names(envs)
[10:30:49.285]                 common <- intersect(names, old_names)
[10:30:49.285]                 added <- setdiff(names, old_names)
[10:30:49.285]                 removed <- setdiff(old_names, names)
[10:30:49.285]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.285]                   envs[common]]
[10:30:49.285]                 NAMES <- toupper(changed)
[10:30:49.285]                 args <- list()
[10:30:49.285]                 for (kk in seq_along(NAMES)) {
[10:30:49.285]                   name <- changed[[kk]]
[10:30:49.285]                   NAME <- NAMES[[kk]]
[10:30:49.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.285]                     next
[10:30:49.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.285]                 }
[10:30:49.285]                 NAMES <- toupper(added)
[10:30:49.285]                 for (kk in seq_along(NAMES)) {
[10:30:49.285]                   name <- added[[kk]]
[10:30:49.285]                   NAME <- NAMES[[kk]]
[10:30:49.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.285]                     next
[10:30:49.285]                   args[[name]] <- ""
[10:30:49.285]                 }
[10:30:49.285]                 NAMES <- toupper(removed)
[10:30:49.285]                 for (kk in seq_along(NAMES)) {
[10:30:49.285]                   name <- removed[[kk]]
[10:30:49.285]                   NAME <- NAMES[[kk]]
[10:30:49.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.285]                     next
[10:30:49.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.285]                 }
[10:30:49.285]                 if (length(args) > 0) 
[10:30:49.285]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.285]             }
[10:30:49.285]             else {
[10:30:49.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.285]             }
[10:30:49.285]             {
[10:30:49.285]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.285]                   0L) {
[10:30:49.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.285]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.285]                   base::options(opts)
[10:30:49.285]                 }
[10:30:49.285]                 {
[10:30:49.285]                   {
[10:30:49.285]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.285]                     NULL
[10:30:49.285]                   }
[10:30:49.285]                   options(future.plan = NULL)
[10:30:49.285]                   if (is.na(NA_character_)) 
[10:30:49.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.285]                     .init = FALSE)
[10:30:49.285]                 }
[10:30:49.285]             }
[10:30:49.285]         }
[10:30:49.285]     })
[10:30:49.285]     if (TRUE) {
[10:30:49.285]         base::sink(type = "output", split = FALSE)
[10:30:49.285]         if (TRUE) {
[10:30:49.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.285]         }
[10:30:49.285]         else {
[10:30:49.285]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.285]         }
[10:30:49.285]         base::close(...future.stdout)
[10:30:49.285]         ...future.stdout <- NULL
[10:30:49.285]     }
[10:30:49.285]     ...future.result$conditions <- ...future.conditions
[10:30:49.285]     ...future.result$finished <- base::Sys.time()
[10:30:49.285]     ...future.result
[10:30:49.285] }
[10:30:49.288] assign_globals() ...
[10:30:49.288] List of 5
[10:30:49.288]  $ ...future.FUN            :function (x, ...)  
[10:30:49.288]  $ MoreArgs                 : NULL
[10:30:49.288]  $ ...future.elements_ii    :List of 2
[10:30:49.288]   ..$ times:List of 2
[10:30:49.288]   .. ..$ : int 3
[10:30:49.288]   .. ..$ : int 4
[10:30:49.288]   ..$ x    :List of 2
[10:30:49.288]   .. ..$ : int 2
[10:30:49.288]   .. ..$ : int 1
[10:30:49.288]  $ ...future.seeds_ii       : NULL
[10:30:49.288]  $ ...future.globals.maxSize: NULL
[10:30:49.288]  - attr(*, "where")=List of 5
[10:30:49.288]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.288]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.288]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.288]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.288]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.288]  - attr(*, "resolved")= logi FALSE
[10:30:49.288]  - attr(*, "total_size")= num 280
[10:30:49.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.288]  - attr(*, "already-done")= logi TRUE
[10:30:49.302] - copied ‘...future.FUN’ to environment
[10:30:49.303] - copied ‘MoreArgs’ to environment
[10:30:49.303] - copied ‘...future.elements_ii’ to environment
[10:30:49.303] - copied ‘...future.seeds_ii’ to environment
[10:30:49.303] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.303] assign_globals() ... done
[10:30:49.303] requestCore(): workers = 2
[10:30:49.306] MulticoreFuture started
[10:30:49.306] - Launch lazy future ... done
[10:30:49.307] run() for ‘MulticoreFuture’ ... done
[10:30:49.307] Created future:
[10:30:49.307] plan(): Setting new future strategy stack:
[10:30:49.308] List of future strategies:
[10:30:49.308] 1. sequential:
[10:30:49.308]    - args: function (..., envir = parent.frame())
[10:30:49.308]    - tweaked: FALSE
[10:30:49.308]    - call: NULL
[10:30:49.309] plan(): nbrOfWorkers() = 1
[10:30:49.311] plan(): Setting new future strategy stack:
[10:30:49.311] List of future strategies:
[10:30:49.311] 1. multicore:
[10:30:49.311]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.311]    - tweaked: FALSE
[10:30:49.311]    - call: plan(strategy)
[10:30:49.318] plan(): nbrOfWorkers() = 2
[10:30:49.307] MulticoreFuture:
[10:30:49.307] Label: ‘future_mapply-2’
[10:30:49.307] Expression:
[10:30:49.307] {
[10:30:49.307]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.307]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.307]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.307]         on.exit(options(oopts), add = TRUE)
[10:30:49.307]     }
[10:30:49.307]     {
[10:30:49.307]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.307]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.307]         do.call(mapply, args = args)
[10:30:49.307]     }
[10:30:49.307] }
[10:30:49.307] Lazy evaluation: FALSE
[10:30:49.307] Asynchronous evaluation: TRUE
[10:30:49.307] Local evaluation: TRUE
[10:30:49.307] Environment: R_GlobalEnv
[10:30:49.307] Capture standard output: TRUE
[10:30:49.307] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.307] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.307] Packages: <none>
[10:30:49.307] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.307] Resolved: TRUE
[10:30:49.307] Value: <not collected>
[10:30:49.307] Conditions captured: <none>
[10:30:49.307] Early signaling: FALSE
[10:30:49.307] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.307] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.319] Chunk #2 of 2 ... DONE
[10:30:49.319] Launching 2 futures (chunks) ... DONE
[10:30:49.320] Resolving 2 futures (chunks) ...
[10:30:49.320] resolve() on list ...
[10:30:49.320]  recursive: 0
[10:30:49.320]  length: 2
[10:30:49.320] 
[10:30:49.321] Future #1
[10:30:49.321] result() for MulticoreFuture ...
[10:30:49.322] result() for MulticoreFuture ...
[10:30:49.322] result() for MulticoreFuture ... done
[10:30:49.323] result() for MulticoreFuture ... done
[10:30:49.323] result() for MulticoreFuture ...
[10:30:49.323] result() for MulticoreFuture ... done
[10:30:49.323] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:49.324] - nx: 2
[10:30:49.324] - relay: TRUE
[10:30:49.324] - stdout: TRUE
[10:30:49.324] - signal: TRUE
[10:30:49.324] - resignal: FALSE
[10:30:49.324] - force: TRUE
[10:30:49.325] - relayed: [n=2] FALSE, FALSE
[10:30:49.325] - queued futures: [n=2] FALSE, FALSE
[10:30:49.325]  - until=1
[10:30:49.325]  - relaying element #1
[10:30:49.326] result() for MulticoreFuture ...
[10:30:49.326] result() for MulticoreFuture ... done
[10:30:49.326] result() for MulticoreFuture ...
[10:30:49.326] result() for MulticoreFuture ... done
[10:30:49.326] result() for MulticoreFuture ...
[10:30:49.327] result() for MulticoreFuture ... done
[10:30:49.327] result() for MulticoreFuture ...
[10:30:49.327] result() for MulticoreFuture ... done
[10:30:49.327] - relayed: [n=2] TRUE, FALSE
[10:30:49.327] - queued futures: [n=2] TRUE, FALSE
[10:30:49.327] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:49.328]  length: 1 (resolved future 1)
[10:30:49.328] Future #2
[10:30:49.328] result() for MulticoreFuture ...
[10:30:49.329] result() for MulticoreFuture ...
[10:30:49.329] result() for MulticoreFuture ... done
[10:30:49.329] result() for MulticoreFuture ... done
[10:30:49.329] result() for MulticoreFuture ...
[10:30:49.329] result() for MulticoreFuture ... done
[10:30:49.330] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:49.330] - nx: 2
[10:30:49.330] - relay: TRUE
[10:30:49.330] - stdout: TRUE
[10:30:49.330] - signal: TRUE
[10:30:49.330] - resignal: FALSE
[10:30:49.330] - force: TRUE
[10:30:49.330] - relayed: [n=2] TRUE, FALSE
[10:30:49.331] - queued futures: [n=2] TRUE, FALSE
[10:30:49.331]  - until=2
[10:30:49.331]  - relaying element #2
[10:30:49.331] result() for MulticoreFuture ...
[10:30:49.331] result() for MulticoreFuture ... done
[10:30:49.331] result() for MulticoreFuture ...
[10:30:49.331] result() for MulticoreFuture ... done
[10:30:49.332] result() for MulticoreFuture ...
[10:30:49.332] result() for MulticoreFuture ... done
[10:30:49.332] result() for MulticoreFuture ...
[10:30:49.332] result() for MulticoreFuture ... done
[10:30:49.332] - relayed: [n=2] TRUE, TRUE
[10:30:49.332] - queued futures: [n=2] TRUE, TRUE
[10:30:49.332] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:49.332]  length: 0 (resolved future 2)
[10:30:49.332] Relaying remaining futures
[10:30:49.333] signalConditionsASAP(NULL, pos=0) ...
[10:30:49.333] - nx: 2
[10:30:49.333] - relay: TRUE
[10:30:49.333] - stdout: TRUE
[10:30:49.333] - signal: TRUE
[10:30:49.333] - resignal: FALSE
[10:30:49.333] - force: TRUE
[10:30:49.333] - relayed: [n=2] TRUE, TRUE
[10:30:49.333] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:49.334] - relayed: [n=2] TRUE, TRUE
[10:30:49.334] - queued futures: [n=2] TRUE, TRUE
[10:30:49.334] signalConditionsASAP(NULL, pos=0) ... done
[10:30:49.334] resolve() on list ... DONE
[10:30:49.334] result() for MulticoreFuture ...
[10:30:49.334] result() for MulticoreFuture ... done
[10:30:49.334] result() for MulticoreFuture ...
[10:30:49.334] result() for MulticoreFuture ... done
[10:30:49.335] result() for MulticoreFuture ...
[10:30:49.335] result() for MulticoreFuture ... done
[10:30:49.335] result() for MulticoreFuture ...
[10:30:49.335] result() for MulticoreFuture ... done
[10:30:49.335]  - Number of value chunks collected: 2
[10:30:49.335] Resolving 2 futures (chunks) ... DONE
[10:30:49.335] Reducing values from 2 chunks ...
[10:30:49.335]  - Number of values collected after concatenation: 4
[10:30:49.336]  - Number of values expected: 4
[10:30:49.336] Reducing values from 2 chunks ... DONE
[10:30:49.336] future_mapply() ... DONE
[10:30:49.336] future_mapply() ...
[10:30:49.341] Number of chunks: 2
[10:30:49.341] getGlobalsAndPackagesXApply() ...
[10:30:49.341]  - future.globals: TRUE
[10:30:49.341] getGlobalsAndPackages() ...
[10:30:49.341] Searching for globals...
[10:30:49.342] - globals found: [1] ‘FUN’
[10:30:49.342] Searching for globals ... DONE
[10:30:49.342] Resolving globals: FALSE
[10:30:49.343] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:49.346] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:49.346] - globals: [1] ‘FUN’
[10:30:49.346] 
[10:30:49.346] getGlobalsAndPackages() ... DONE
[10:30:49.346]  - globals found/used: [n=1] ‘FUN’
[10:30:49.346]  - needed namespaces: [n=0] 
[10:30:49.347] Finding globals ... DONE
[10:30:49.347] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:49.347] List of 2
[10:30:49.347]  $ ...future.FUN:function (x, ...)  
[10:30:49.347]  $ MoreArgs     :List of 1
[10:30:49.347]   ..$ x: num 42
[10:30:49.347]  - attr(*, "where")=List of 2
[10:30:49.347]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:49.347]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:49.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.347]  - attr(*, "resolved")= logi FALSE
[10:30:49.347]  - attr(*, "total_size")= num NA
[10:30:49.352] Packages to be attached in all futures: [n=0] 
[10:30:49.352] getGlobalsAndPackagesXApply() ... DONE
[10:30:49.352] Number of futures (= number of chunks): 2
[10:30:49.352] Launching 2 futures (chunks) ...
[10:30:49.352] Chunk #1 of 2 ...
[10:30:49.352]  - Finding globals in '...' for chunk #1 ...
[10:30:49.353] getGlobalsAndPackages() ...
[10:30:49.353] Searching for globals...
[10:30:49.353] 
[10:30:49.353] Searching for globals ... DONE
[10:30:49.353] - globals: [0] <none>
[10:30:49.353] getGlobalsAndPackages() ... DONE
[10:30:49.353]    + additional globals found: [n=0] 
[10:30:49.354]    + additional namespaces needed: [n=0] 
[10:30:49.354]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:49.354]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.354]  - seeds: <none>
[10:30:49.354]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.354] getGlobalsAndPackages() ...
[10:30:49.354] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.354] Resolving globals: FALSE
[10:30:49.355] The total size of the 5 globals is 224 bytes (224 bytes)
[10:30:49.355] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:49.355] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.356] 
[10:30:49.356] getGlobalsAndPackages() ... DONE
[10:30:49.356] run() for ‘Future’ ...
[10:30:49.356] - state: ‘created’
[10:30:49.356] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.360] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.361] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.361]   - Field: ‘label’
[10:30:49.361]   - Field: ‘local’
[10:30:49.361]   - Field: ‘owner’
[10:30:49.361]   - Field: ‘envir’
[10:30:49.361]   - Field: ‘workers’
[10:30:49.361]   - Field: ‘packages’
[10:30:49.362]   - Field: ‘gc’
[10:30:49.362]   - Field: ‘job’
[10:30:49.362]   - Field: ‘conditions’
[10:30:49.362]   - Field: ‘expr’
[10:30:49.362]   - Field: ‘uuid’
[10:30:49.362]   - Field: ‘seed’
[10:30:49.362]   - Field: ‘version’
[10:30:49.362]   - Field: ‘result’
[10:30:49.362]   - Field: ‘asynchronous’
[10:30:49.362]   - Field: ‘calls’
[10:30:49.363]   - Field: ‘globals’
[10:30:49.363]   - Field: ‘stdout’
[10:30:49.363]   - Field: ‘earlySignal’
[10:30:49.363]   - Field: ‘lazy’
[10:30:49.363]   - Field: ‘state’
[10:30:49.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.363] - Launch lazy future ...
[10:30:49.363] Packages needed by the future expression (n = 0): <none>
[10:30:49.364] Packages needed by future strategies (n = 0): <none>
[10:30:49.364] {
[10:30:49.364]     {
[10:30:49.364]         {
[10:30:49.364]             ...future.startTime <- base::Sys.time()
[10:30:49.364]             {
[10:30:49.364]                 {
[10:30:49.364]                   {
[10:30:49.364]                     {
[10:30:49.364]                       base::local({
[10:30:49.364]                         has_future <- base::requireNamespace("future", 
[10:30:49.364]                           quietly = TRUE)
[10:30:49.364]                         if (has_future) {
[10:30:49.364]                           ns <- base::getNamespace("future")
[10:30:49.364]                           version <- ns[[".package"]][["version"]]
[10:30:49.364]                           if (is.null(version)) 
[10:30:49.364]                             version <- utils::packageVersion("future")
[10:30:49.364]                         }
[10:30:49.364]                         else {
[10:30:49.364]                           version <- NULL
[10:30:49.364]                         }
[10:30:49.364]                         if (!has_future || version < "1.8.0") {
[10:30:49.364]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.364]                             "", base::R.version$version.string), 
[10:30:49.364]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.364]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.364]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.364]                               "release", "version")], collapse = " "), 
[10:30:49.364]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.364]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.364]                             info)
[10:30:49.364]                           info <- base::paste(info, collapse = "; ")
[10:30:49.364]                           if (!has_future) {
[10:30:49.364]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.364]                               info)
[10:30:49.364]                           }
[10:30:49.364]                           else {
[10:30:49.364]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.364]                               info, version)
[10:30:49.364]                           }
[10:30:49.364]                           base::stop(msg)
[10:30:49.364]                         }
[10:30:49.364]                       })
[10:30:49.364]                     }
[10:30:49.364]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.364]                     base::options(mc.cores = 1L)
[10:30:49.364]                   }
[10:30:49.364]                   ...future.strategy.old <- future::plan("list")
[10:30:49.364]                   options(future.plan = NULL)
[10:30:49.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.364]                 }
[10:30:49.364]                 ...future.workdir <- getwd()
[10:30:49.364]             }
[10:30:49.364]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.364]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.364]         }
[10:30:49.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.364]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.364]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.364]             base::names(...future.oldOptions))
[10:30:49.364]     }
[10:30:49.364]     if (FALSE) {
[10:30:49.364]     }
[10:30:49.364]     else {
[10:30:49.364]         if (TRUE) {
[10:30:49.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.364]                 open = "w")
[10:30:49.364]         }
[10:30:49.364]         else {
[10:30:49.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.364]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.364]         }
[10:30:49.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.364]             base::sink(type = "output", split = FALSE)
[10:30:49.364]             base::close(...future.stdout)
[10:30:49.364]         }, add = TRUE)
[10:30:49.364]     }
[10:30:49.364]     ...future.frame <- base::sys.nframe()
[10:30:49.364]     ...future.conditions <- base::list()
[10:30:49.364]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.364]     if (FALSE) {
[10:30:49.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.364]     }
[10:30:49.364]     ...future.result <- base::tryCatch({
[10:30:49.364]         base::withCallingHandlers({
[10:30:49.364]             ...future.value <- base::withVisible(base::local({
[10:30:49.364]                 withCallingHandlers({
[10:30:49.364]                   {
[10:30:49.364]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.364]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.364]                       ...future.globals.maxSize)) {
[10:30:49.364]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.364]                       on.exit(options(oopts), add = TRUE)
[10:30:49.364]                     }
[10:30:49.364]                     {
[10:30:49.364]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.364]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.364]                         USE.NAMES = FALSE)
[10:30:49.364]                       do.call(mapply, args = args)
[10:30:49.364]                     }
[10:30:49.364]                   }
[10:30:49.364]                 }, immediateCondition = function(cond) {
[10:30:49.364]                   save_rds <- function (object, pathname, ...) 
[10:30:49.364]                   {
[10:30:49.364]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.364]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.364]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.364]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.364]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.364]                         fi_tmp[["mtime"]])
[10:30:49.364]                     }
[10:30:49.364]                     tryCatch({
[10:30:49.364]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.364]                     }, error = function(ex) {
[10:30:49.364]                       msg <- conditionMessage(ex)
[10:30:49.364]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.364]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.364]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.364]                         fi_tmp[["mtime"]], msg)
[10:30:49.364]                       ex$message <- msg
[10:30:49.364]                       stop(ex)
[10:30:49.364]                     })
[10:30:49.364]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.364]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.364]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.364]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.364]                       fi <- file.info(pathname)
[10:30:49.364]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.364]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.364]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.364]                         fi[["size"]], fi[["mtime"]])
[10:30:49.364]                       stop(msg)
[10:30:49.364]                     }
[10:30:49.364]                     invisible(pathname)
[10:30:49.364]                   }
[10:30:49.364]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.364]                     rootPath = tempdir()) 
[10:30:49.364]                   {
[10:30:49.364]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.364]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.364]                       tmpdir = path, fileext = ".rds")
[10:30:49.364]                     save_rds(obj, file)
[10:30:49.364]                   }
[10:30:49.364]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.364]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.364]                   {
[10:30:49.364]                     inherits <- base::inherits
[10:30:49.364]                     invokeRestart <- base::invokeRestart
[10:30:49.364]                     is.null <- base::is.null
[10:30:49.364]                     muffled <- FALSE
[10:30:49.364]                     if (inherits(cond, "message")) {
[10:30:49.364]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.364]                       if (muffled) 
[10:30:49.364]                         invokeRestart("muffleMessage")
[10:30:49.364]                     }
[10:30:49.364]                     else if (inherits(cond, "warning")) {
[10:30:49.364]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.364]                       if (muffled) 
[10:30:49.364]                         invokeRestart("muffleWarning")
[10:30:49.364]                     }
[10:30:49.364]                     else if (inherits(cond, "condition")) {
[10:30:49.364]                       if (!is.null(pattern)) {
[10:30:49.364]                         computeRestarts <- base::computeRestarts
[10:30:49.364]                         grepl <- base::grepl
[10:30:49.364]                         restarts <- computeRestarts(cond)
[10:30:49.364]                         for (restart in restarts) {
[10:30:49.364]                           name <- restart$name
[10:30:49.364]                           if (is.null(name)) 
[10:30:49.364]                             next
[10:30:49.364]                           if (!grepl(pattern, name)) 
[10:30:49.364]                             next
[10:30:49.364]                           invokeRestart(restart)
[10:30:49.364]                           muffled <- TRUE
[10:30:49.364]                           break
[10:30:49.364]                         }
[10:30:49.364]                       }
[10:30:49.364]                     }
[10:30:49.364]                     invisible(muffled)
[10:30:49.364]                   }
[10:30:49.364]                   muffleCondition(cond)
[10:30:49.364]                 })
[10:30:49.364]             }))
[10:30:49.364]             future::FutureResult(value = ...future.value$value, 
[10:30:49.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.364]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.364]                     ...future.globalenv.names))
[10:30:49.364]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.364]         }, condition = base::local({
[10:30:49.364]             c <- base::c
[10:30:49.364]             inherits <- base::inherits
[10:30:49.364]             invokeRestart <- base::invokeRestart
[10:30:49.364]             length <- base::length
[10:30:49.364]             list <- base::list
[10:30:49.364]             seq.int <- base::seq.int
[10:30:49.364]             signalCondition <- base::signalCondition
[10:30:49.364]             sys.calls <- base::sys.calls
[10:30:49.364]             `[[` <- base::`[[`
[10:30:49.364]             `+` <- base::`+`
[10:30:49.364]             `<<-` <- base::`<<-`
[10:30:49.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.364]                   3L)]
[10:30:49.364]             }
[10:30:49.364]             function(cond) {
[10:30:49.364]                 is_error <- inherits(cond, "error")
[10:30:49.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.364]                   NULL)
[10:30:49.364]                 if (is_error) {
[10:30:49.364]                   sessionInformation <- function() {
[10:30:49.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.364]                       search = base::search(), system = base::Sys.info())
[10:30:49.364]                   }
[10:30:49.364]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.364]                     cond$call), session = sessionInformation(), 
[10:30:49.364]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.364]                   signalCondition(cond)
[10:30:49.364]                 }
[10:30:49.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.364]                 "immediateCondition"))) {
[10:30:49.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.364]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.364]                   if (TRUE && !signal) {
[10:30:49.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.364]                     {
[10:30:49.364]                       inherits <- base::inherits
[10:30:49.364]                       invokeRestart <- base::invokeRestart
[10:30:49.364]                       is.null <- base::is.null
[10:30:49.364]                       muffled <- FALSE
[10:30:49.364]                       if (inherits(cond, "message")) {
[10:30:49.364]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.364]                         if (muffled) 
[10:30:49.364]                           invokeRestart("muffleMessage")
[10:30:49.364]                       }
[10:30:49.364]                       else if (inherits(cond, "warning")) {
[10:30:49.364]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.364]                         if (muffled) 
[10:30:49.364]                           invokeRestart("muffleWarning")
[10:30:49.364]                       }
[10:30:49.364]                       else if (inherits(cond, "condition")) {
[10:30:49.364]                         if (!is.null(pattern)) {
[10:30:49.364]                           computeRestarts <- base::computeRestarts
[10:30:49.364]                           grepl <- base::grepl
[10:30:49.364]                           restarts <- computeRestarts(cond)
[10:30:49.364]                           for (restart in restarts) {
[10:30:49.364]                             name <- restart$name
[10:30:49.364]                             if (is.null(name)) 
[10:30:49.364]                               next
[10:30:49.364]                             if (!grepl(pattern, name)) 
[10:30:49.364]                               next
[10:30:49.364]                             invokeRestart(restart)
[10:30:49.364]                             muffled <- TRUE
[10:30:49.364]                             break
[10:30:49.364]                           }
[10:30:49.364]                         }
[10:30:49.364]                       }
[10:30:49.364]                       invisible(muffled)
[10:30:49.364]                     }
[10:30:49.364]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.364]                   }
[10:30:49.364]                 }
[10:30:49.364]                 else {
[10:30:49.364]                   if (TRUE) {
[10:30:49.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.364]                     {
[10:30:49.364]                       inherits <- base::inherits
[10:30:49.364]                       invokeRestart <- base::invokeRestart
[10:30:49.364]                       is.null <- base::is.null
[10:30:49.364]                       muffled <- FALSE
[10:30:49.364]                       if (inherits(cond, "message")) {
[10:30:49.364]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.364]                         if (muffled) 
[10:30:49.364]                           invokeRestart("muffleMessage")
[10:30:49.364]                       }
[10:30:49.364]                       else if (inherits(cond, "warning")) {
[10:30:49.364]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.364]                         if (muffled) 
[10:30:49.364]                           invokeRestart("muffleWarning")
[10:30:49.364]                       }
[10:30:49.364]                       else if (inherits(cond, "condition")) {
[10:30:49.364]                         if (!is.null(pattern)) {
[10:30:49.364]                           computeRestarts <- base::computeRestarts
[10:30:49.364]                           grepl <- base::grepl
[10:30:49.364]                           restarts <- computeRestarts(cond)
[10:30:49.364]                           for (restart in restarts) {
[10:30:49.364]                             name <- restart$name
[10:30:49.364]                             if (is.null(name)) 
[10:30:49.364]                               next
[10:30:49.364]                             if (!grepl(pattern, name)) 
[10:30:49.364]                               next
[10:30:49.364]                             invokeRestart(restart)
[10:30:49.364]                             muffled <- TRUE
[10:30:49.364]                             break
[10:30:49.364]                           }
[10:30:49.364]                         }
[10:30:49.364]                       }
[10:30:49.364]                       invisible(muffled)
[10:30:49.364]                     }
[10:30:49.364]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.364]                   }
[10:30:49.364]                 }
[10:30:49.364]             }
[10:30:49.364]         }))
[10:30:49.364]     }, error = function(ex) {
[10:30:49.364]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.364]                 ...future.rng), started = ...future.startTime, 
[10:30:49.364]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.364]             version = "1.8"), class = "FutureResult")
[10:30:49.364]     }, finally = {
[10:30:49.364]         if (!identical(...future.workdir, getwd())) 
[10:30:49.364]             setwd(...future.workdir)
[10:30:49.364]         {
[10:30:49.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.364]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.364]             }
[10:30:49.364]             base::options(...future.oldOptions)
[10:30:49.364]             if (.Platform$OS.type == "windows") {
[10:30:49.364]                 old_names <- names(...future.oldEnvVars)
[10:30:49.364]                 envs <- base::Sys.getenv()
[10:30:49.364]                 names <- names(envs)
[10:30:49.364]                 common <- intersect(names, old_names)
[10:30:49.364]                 added <- setdiff(names, old_names)
[10:30:49.364]                 removed <- setdiff(old_names, names)
[10:30:49.364]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.364]                   envs[common]]
[10:30:49.364]                 NAMES <- toupper(changed)
[10:30:49.364]                 args <- list()
[10:30:49.364]                 for (kk in seq_along(NAMES)) {
[10:30:49.364]                   name <- changed[[kk]]
[10:30:49.364]                   NAME <- NAMES[[kk]]
[10:30:49.364]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.364]                     next
[10:30:49.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.364]                 }
[10:30:49.364]                 NAMES <- toupper(added)
[10:30:49.364]                 for (kk in seq_along(NAMES)) {
[10:30:49.364]                   name <- added[[kk]]
[10:30:49.364]                   NAME <- NAMES[[kk]]
[10:30:49.364]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.364]                     next
[10:30:49.364]                   args[[name]] <- ""
[10:30:49.364]                 }
[10:30:49.364]                 NAMES <- toupper(removed)
[10:30:49.364]                 for (kk in seq_along(NAMES)) {
[10:30:49.364]                   name <- removed[[kk]]
[10:30:49.364]                   NAME <- NAMES[[kk]]
[10:30:49.364]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.364]                     next
[10:30:49.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.364]                 }
[10:30:49.364]                 if (length(args) > 0) 
[10:30:49.364]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.364]             }
[10:30:49.364]             else {
[10:30:49.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.364]             }
[10:30:49.364]             {
[10:30:49.364]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.364]                   0L) {
[10:30:49.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.364]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.364]                   base::options(opts)
[10:30:49.364]                 }
[10:30:49.364]                 {
[10:30:49.364]                   {
[10:30:49.364]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.364]                     NULL
[10:30:49.364]                   }
[10:30:49.364]                   options(future.plan = NULL)
[10:30:49.364]                   if (is.na(NA_character_)) 
[10:30:49.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.364]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.364]                     .init = FALSE)
[10:30:49.364]                 }
[10:30:49.364]             }
[10:30:49.364]         }
[10:30:49.364]     })
[10:30:49.364]     if (TRUE) {
[10:30:49.364]         base::sink(type = "output", split = FALSE)
[10:30:49.364]         if (TRUE) {
[10:30:49.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.364]         }
[10:30:49.364]         else {
[10:30:49.364]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.364]         }
[10:30:49.364]         base::close(...future.stdout)
[10:30:49.364]         ...future.stdout <- NULL
[10:30:49.364]     }
[10:30:49.364]     ...future.result$conditions <- ...future.conditions
[10:30:49.364]     ...future.result$finished <- base::Sys.time()
[10:30:49.364]     ...future.result
[10:30:49.364] }
[10:30:49.367] assign_globals() ...
[10:30:49.367] List of 5
[10:30:49.367]  $ ...future.FUN            :function (x, ...)  
[10:30:49.367]  $ MoreArgs                 :List of 1
[10:30:49.367]   ..$ x: num 42
[10:30:49.367]  $ ...future.elements_ii    :List of 1
[10:30:49.367]   ..$ times:List of 2
[10:30:49.367]   .. ..$ : int 1
[10:30:49.367]   .. ..$ : int 2
[10:30:49.367]  $ ...future.seeds_ii       : NULL
[10:30:49.367]  $ ...future.globals.maxSize: NULL
[10:30:49.367]  - attr(*, "where")=List of 5
[10:30:49.367]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.367]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.367]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.367]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.367]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.367]  - attr(*, "resolved")= logi FALSE
[10:30:49.367]  - attr(*, "total_size")= num 224
[10:30:49.367]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.367]  - attr(*, "already-done")= logi TRUE
[10:30:49.372] - copied ‘...future.FUN’ to environment
[10:30:49.373] - copied ‘MoreArgs’ to environment
[10:30:49.375] - copied ‘...future.elements_ii’ to environment
[10:30:49.375] - copied ‘...future.seeds_ii’ to environment
[10:30:49.375] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.375] assign_globals() ... done
[10:30:49.375] requestCore(): workers = 2
[10:30:49.378] MulticoreFuture started
[10:30:49.379] - Launch lazy future ... done
[10:30:49.379] plan(): Setting new future strategy stack:
[10:30:49.379] run() for ‘MulticoreFuture’ ... done
[10:30:49.380] Created future:
[10:30:49.380] List of future strategies:
[10:30:49.380] 1. sequential:
[10:30:49.380]    - args: function (..., envir = parent.frame())
[10:30:49.380]    - tweaked: FALSE
[10:30:49.380]    - call: NULL
[10:30:49.381] plan(): nbrOfWorkers() = 1
[10:30:49.384] plan(): Setting new future strategy stack:
[10:30:49.385] List of future strategies:
[10:30:49.385] 1. multicore:
[10:30:49.385]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.385]    - tweaked: FALSE
[10:30:49.385]    - call: plan(strategy)
[10:30:49.392] plan(): nbrOfWorkers() = 2
[10:30:49.380] MulticoreFuture:
[10:30:49.380] Label: ‘future_mapply-1’
[10:30:49.380] Expression:
[10:30:49.380] {
[10:30:49.380]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.380]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.380]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.380]         on.exit(options(oopts), add = TRUE)
[10:30:49.380]     }
[10:30:49.380]     {
[10:30:49.380]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.380]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.380]         do.call(mapply, args = args)
[10:30:49.380]     }
[10:30:49.380] }
[10:30:49.380] Lazy evaluation: FALSE
[10:30:49.380] Asynchronous evaluation: TRUE
[10:30:49.380] Local evaluation: TRUE
[10:30:49.380] Environment: R_GlobalEnv
[10:30:49.380] Capture standard output: TRUE
[10:30:49.380] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.380] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.380] Packages: <none>
[10:30:49.380] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.380] Resolved: TRUE
[10:30:49.380] Value: <not collected>
[10:30:49.380] Conditions captured: <none>
[10:30:49.380] Early signaling: FALSE
[10:30:49.380] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.380] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.393] Chunk #1 of 2 ... DONE
[10:30:49.393] Chunk #2 of 2 ...
[10:30:49.394]  - Finding globals in '...' for chunk #2 ...
[10:30:49.394] getGlobalsAndPackages() ...
[10:30:49.394] Searching for globals...
[10:30:49.395] 
[10:30:49.395] Searching for globals ... DONE
[10:30:49.395] - globals: [0] <none>
[10:30:49.396] getGlobalsAndPackages() ... DONE
[10:30:49.396]    + additional globals found: [n=0] 
[10:30:49.396]    + additional namespaces needed: [n=0] 
[10:30:49.396]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:49.396]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.396]  - seeds: <none>
[10:30:49.396]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.397] getGlobalsAndPackages() ...
[10:30:49.397] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.397] Resolving globals: FALSE
[10:30:49.398] The total size of the 5 globals is 224 bytes (224 bytes)
[10:30:49.399] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:49.399] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.399] 
[10:30:49.400] getGlobalsAndPackages() ... DONE
[10:30:49.400] run() for ‘Future’ ...
[10:30:49.400] - state: ‘created’
[10:30:49.401] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.406] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.406]   - Field: ‘label’
[10:30:49.407]   - Field: ‘local’
[10:30:49.407]   - Field: ‘owner’
[10:30:49.407]   - Field: ‘envir’
[10:30:49.407]   - Field: ‘workers’
[10:30:49.407]   - Field: ‘packages’
[10:30:49.407]   - Field: ‘gc’
[10:30:49.407]   - Field: ‘job’
[10:30:49.407]   - Field: ‘conditions’
[10:30:49.408]   - Field: ‘expr’
[10:30:49.408]   - Field: ‘uuid’
[10:30:49.408]   - Field: ‘seed’
[10:30:49.408]   - Field: ‘version’
[10:30:49.408]   - Field: ‘result’
[10:30:49.408]   - Field: ‘asynchronous’
[10:30:49.408]   - Field: ‘calls’
[10:30:49.408]   - Field: ‘globals’
[10:30:49.409]   - Field: ‘stdout’
[10:30:49.409]   - Field: ‘earlySignal’
[10:30:49.409]   - Field: ‘lazy’
[10:30:49.409]   - Field: ‘state’
[10:30:49.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.409] - Launch lazy future ...
[10:30:49.410] Packages needed by the future expression (n = 0): <none>
[10:30:49.410] Packages needed by future strategies (n = 0): <none>
[10:30:49.411] {
[10:30:49.411]     {
[10:30:49.411]         {
[10:30:49.411]             ...future.startTime <- base::Sys.time()
[10:30:49.411]             {
[10:30:49.411]                 {
[10:30:49.411]                   {
[10:30:49.411]                     {
[10:30:49.411]                       base::local({
[10:30:49.411]                         has_future <- base::requireNamespace("future", 
[10:30:49.411]                           quietly = TRUE)
[10:30:49.411]                         if (has_future) {
[10:30:49.411]                           ns <- base::getNamespace("future")
[10:30:49.411]                           version <- ns[[".package"]][["version"]]
[10:30:49.411]                           if (is.null(version)) 
[10:30:49.411]                             version <- utils::packageVersion("future")
[10:30:49.411]                         }
[10:30:49.411]                         else {
[10:30:49.411]                           version <- NULL
[10:30:49.411]                         }
[10:30:49.411]                         if (!has_future || version < "1.8.0") {
[10:30:49.411]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.411]                             "", base::R.version$version.string), 
[10:30:49.411]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.411]                               "release", "version")], collapse = " "), 
[10:30:49.411]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.411]                             info)
[10:30:49.411]                           info <- base::paste(info, collapse = "; ")
[10:30:49.411]                           if (!has_future) {
[10:30:49.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.411]                               info)
[10:30:49.411]                           }
[10:30:49.411]                           else {
[10:30:49.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.411]                               info, version)
[10:30:49.411]                           }
[10:30:49.411]                           base::stop(msg)
[10:30:49.411]                         }
[10:30:49.411]                       })
[10:30:49.411]                     }
[10:30:49.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.411]                     base::options(mc.cores = 1L)
[10:30:49.411]                   }
[10:30:49.411]                   ...future.strategy.old <- future::plan("list")
[10:30:49.411]                   options(future.plan = NULL)
[10:30:49.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.411]                 }
[10:30:49.411]                 ...future.workdir <- getwd()
[10:30:49.411]             }
[10:30:49.411]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.411]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.411]         }
[10:30:49.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.411]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.411]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.411]             base::names(...future.oldOptions))
[10:30:49.411]     }
[10:30:49.411]     if (FALSE) {
[10:30:49.411]     }
[10:30:49.411]     else {
[10:30:49.411]         if (TRUE) {
[10:30:49.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.411]                 open = "w")
[10:30:49.411]         }
[10:30:49.411]         else {
[10:30:49.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.411]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.411]         }
[10:30:49.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.411]             base::sink(type = "output", split = FALSE)
[10:30:49.411]             base::close(...future.stdout)
[10:30:49.411]         }, add = TRUE)
[10:30:49.411]     }
[10:30:49.411]     ...future.frame <- base::sys.nframe()
[10:30:49.411]     ...future.conditions <- base::list()
[10:30:49.411]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.411]     if (FALSE) {
[10:30:49.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.411]     }
[10:30:49.411]     ...future.result <- base::tryCatch({
[10:30:49.411]         base::withCallingHandlers({
[10:30:49.411]             ...future.value <- base::withVisible(base::local({
[10:30:49.411]                 withCallingHandlers({
[10:30:49.411]                   {
[10:30:49.411]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.411]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.411]                       ...future.globals.maxSize)) {
[10:30:49.411]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.411]                       on.exit(options(oopts), add = TRUE)
[10:30:49.411]                     }
[10:30:49.411]                     {
[10:30:49.411]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.411]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.411]                         USE.NAMES = FALSE)
[10:30:49.411]                       do.call(mapply, args = args)
[10:30:49.411]                     }
[10:30:49.411]                   }
[10:30:49.411]                 }, immediateCondition = function(cond) {
[10:30:49.411]                   save_rds <- function (object, pathname, ...) 
[10:30:49.411]                   {
[10:30:49.411]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.411]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.411]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.411]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.411]                         fi_tmp[["mtime"]])
[10:30:49.411]                     }
[10:30:49.411]                     tryCatch({
[10:30:49.411]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.411]                     }, error = function(ex) {
[10:30:49.411]                       msg <- conditionMessage(ex)
[10:30:49.411]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.411]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.411]                         fi_tmp[["mtime"]], msg)
[10:30:49.411]                       ex$message <- msg
[10:30:49.411]                       stop(ex)
[10:30:49.411]                     })
[10:30:49.411]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.411]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.411]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.411]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.411]                       fi <- file.info(pathname)
[10:30:49.411]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.411]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.411]                         fi[["size"]], fi[["mtime"]])
[10:30:49.411]                       stop(msg)
[10:30:49.411]                     }
[10:30:49.411]                     invisible(pathname)
[10:30:49.411]                   }
[10:30:49.411]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.411]                     rootPath = tempdir()) 
[10:30:49.411]                   {
[10:30:49.411]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.411]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.411]                       tmpdir = path, fileext = ".rds")
[10:30:49.411]                     save_rds(obj, file)
[10:30:49.411]                   }
[10:30:49.411]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.411]                   {
[10:30:49.411]                     inherits <- base::inherits
[10:30:49.411]                     invokeRestart <- base::invokeRestart
[10:30:49.411]                     is.null <- base::is.null
[10:30:49.411]                     muffled <- FALSE
[10:30:49.411]                     if (inherits(cond, "message")) {
[10:30:49.411]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.411]                       if (muffled) 
[10:30:49.411]                         invokeRestart("muffleMessage")
[10:30:49.411]                     }
[10:30:49.411]                     else if (inherits(cond, "warning")) {
[10:30:49.411]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.411]                       if (muffled) 
[10:30:49.411]                         invokeRestart("muffleWarning")
[10:30:49.411]                     }
[10:30:49.411]                     else if (inherits(cond, "condition")) {
[10:30:49.411]                       if (!is.null(pattern)) {
[10:30:49.411]                         computeRestarts <- base::computeRestarts
[10:30:49.411]                         grepl <- base::grepl
[10:30:49.411]                         restarts <- computeRestarts(cond)
[10:30:49.411]                         for (restart in restarts) {
[10:30:49.411]                           name <- restart$name
[10:30:49.411]                           if (is.null(name)) 
[10:30:49.411]                             next
[10:30:49.411]                           if (!grepl(pattern, name)) 
[10:30:49.411]                             next
[10:30:49.411]                           invokeRestart(restart)
[10:30:49.411]                           muffled <- TRUE
[10:30:49.411]                           break
[10:30:49.411]                         }
[10:30:49.411]                       }
[10:30:49.411]                     }
[10:30:49.411]                     invisible(muffled)
[10:30:49.411]                   }
[10:30:49.411]                   muffleCondition(cond)
[10:30:49.411]                 })
[10:30:49.411]             }))
[10:30:49.411]             future::FutureResult(value = ...future.value$value, 
[10:30:49.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.411]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.411]                     ...future.globalenv.names))
[10:30:49.411]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.411]         }, condition = base::local({
[10:30:49.411]             c <- base::c
[10:30:49.411]             inherits <- base::inherits
[10:30:49.411]             invokeRestart <- base::invokeRestart
[10:30:49.411]             length <- base::length
[10:30:49.411]             list <- base::list
[10:30:49.411]             seq.int <- base::seq.int
[10:30:49.411]             signalCondition <- base::signalCondition
[10:30:49.411]             sys.calls <- base::sys.calls
[10:30:49.411]             `[[` <- base::`[[`
[10:30:49.411]             `+` <- base::`+`
[10:30:49.411]             `<<-` <- base::`<<-`
[10:30:49.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.411]                   3L)]
[10:30:49.411]             }
[10:30:49.411]             function(cond) {
[10:30:49.411]                 is_error <- inherits(cond, "error")
[10:30:49.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.411]                   NULL)
[10:30:49.411]                 if (is_error) {
[10:30:49.411]                   sessionInformation <- function() {
[10:30:49.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.411]                       search = base::search(), system = base::Sys.info())
[10:30:49.411]                   }
[10:30:49.411]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.411]                     cond$call), session = sessionInformation(), 
[10:30:49.411]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.411]                   signalCondition(cond)
[10:30:49.411]                 }
[10:30:49.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.411]                 "immediateCondition"))) {
[10:30:49.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.411]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.411]                   if (TRUE && !signal) {
[10:30:49.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.411]                     {
[10:30:49.411]                       inherits <- base::inherits
[10:30:49.411]                       invokeRestart <- base::invokeRestart
[10:30:49.411]                       is.null <- base::is.null
[10:30:49.411]                       muffled <- FALSE
[10:30:49.411]                       if (inherits(cond, "message")) {
[10:30:49.411]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.411]                         if (muffled) 
[10:30:49.411]                           invokeRestart("muffleMessage")
[10:30:49.411]                       }
[10:30:49.411]                       else if (inherits(cond, "warning")) {
[10:30:49.411]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.411]                         if (muffled) 
[10:30:49.411]                           invokeRestart("muffleWarning")
[10:30:49.411]                       }
[10:30:49.411]                       else if (inherits(cond, "condition")) {
[10:30:49.411]                         if (!is.null(pattern)) {
[10:30:49.411]                           computeRestarts <- base::computeRestarts
[10:30:49.411]                           grepl <- base::grepl
[10:30:49.411]                           restarts <- computeRestarts(cond)
[10:30:49.411]                           for (restart in restarts) {
[10:30:49.411]                             name <- restart$name
[10:30:49.411]                             if (is.null(name)) 
[10:30:49.411]                               next
[10:30:49.411]                             if (!grepl(pattern, name)) 
[10:30:49.411]                               next
[10:30:49.411]                             invokeRestart(restart)
[10:30:49.411]                             muffled <- TRUE
[10:30:49.411]                             break
[10:30:49.411]                           }
[10:30:49.411]                         }
[10:30:49.411]                       }
[10:30:49.411]                       invisible(muffled)
[10:30:49.411]                     }
[10:30:49.411]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.411]                   }
[10:30:49.411]                 }
[10:30:49.411]                 else {
[10:30:49.411]                   if (TRUE) {
[10:30:49.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.411]                     {
[10:30:49.411]                       inherits <- base::inherits
[10:30:49.411]                       invokeRestart <- base::invokeRestart
[10:30:49.411]                       is.null <- base::is.null
[10:30:49.411]                       muffled <- FALSE
[10:30:49.411]                       if (inherits(cond, "message")) {
[10:30:49.411]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.411]                         if (muffled) 
[10:30:49.411]                           invokeRestart("muffleMessage")
[10:30:49.411]                       }
[10:30:49.411]                       else if (inherits(cond, "warning")) {
[10:30:49.411]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.411]                         if (muffled) 
[10:30:49.411]                           invokeRestart("muffleWarning")
[10:30:49.411]                       }
[10:30:49.411]                       else if (inherits(cond, "condition")) {
[10:30:49.411]                         if (!is.null(pattern)) {
[10:30:49.411]                           computeRestarts <- base::computeRestarts
[10:30:49.411]                           grepl <- base::grepl
[10:30:49.411]                           restarts <- computeRestarts(cond)
[10:30:49.411]                           for (restart in restarts) {
[10:30:49.411]                             name <- restart$name
[10:30:49.411]                             if (is.null(name)) 
[10:30:49.411]                               next
[10:30:49.411]                             if (!grepl(pattern, name)) 
[10:30:49.411]                               next
[10:30:49.411]                             invokeRestart(restart)
[10:30:49.411]                             muffled <- TRUE
[10:30:49.411]                             break
[10:30:49.411]                           }
[10:30:49.411]                         }
[10:30:49.411]                       }
[10:30:49.411]                       invisible(muffled)
[10:30:49.411]                     }
[10:30:49.411]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.411]                   }
[10:30:49.411]                 }
[10:30:49.411]             }
[10:30:49.411]         }))
[10:30:49.411]     }, error = function(ex) {
[10:30:49.411]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.411]                 ...future.rng), started = ...future.startTime, 
[10:30:49.411]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.411]             version = "1.8"), class = "FutureResult")
[10:30:49.411]     }, finally = {
[10:30:49.411]         if (!identical(...future.workdir, getwd())) 
[10:30:49.411]             setwd(...future.workdir)
[10:30:49.411]         {
[10:30:49.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.411]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.411]             }
[10:30:49.411]             base::options(...future.oldOptions)
[10:30:49.411]             if (.Platform$OS.type == "windows") {
[10:30:49.411]                 old_names <- names(...future.oldEnvVars)
[10:30:49.411]                 envs <- base::Sys.getenv()
[10:30:49.411]                 names <- names(envs)
[10:30:49.411]                 common <- intersect(names, old_names)
[10:30:49.411]                 added <- setdiff(names, old_names)
[10:30:49.411]                 removed <- setdiff(old_names, names)
[10:30:49.411]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.411]                   envs[common]]
[10:30:49.411]                 NAMES <- toupper(changed)
[10:30:49.411]                 args <- list()
[10:30:49.411]                 for (kk in seq_along(NAMES)) {
[10:30:49.411]                   name <- changed[[kk]]
[10:30:49.411]                   NAME <- NAMES[[kk]]
[10:30:49.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.411]                     next
[10:30:49.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.411]                 }
[10:30:49.411]                 NAMES <- toupper(added)
[10:30:49.411]                 for (kk in seq_along(NAMES)) {
[10:30:49.411]                   name <- added[[kk]]
[10:30:49.411]                   NAME <- NAMES[[kk]]
[10:30:49.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.411]                     next
[10:30:49.411]                   args[[name]] <- ""
[10:30:49.411]                 }
[10:30:49.411]                 NAMES <- toupper(removed)
[10:30:49.411]                 for (kk in seq_along(NAMES)) {
[10:30:49.411]                   name <- removed[[kk]]
[10:30:49.411]                   NAME <- NAMES[[kk]]
[10:30:49.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.411]                     next
[10:30:49.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.411]                 }
[10:30:49.411]                 if (length(args) > 0) 
[10:30:49.411]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.411]             }
[10:30:49.411]             else {
[10:30:49.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.411]             }
[10:30:49.411]             {
[10:30:49.411]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.411]                   0L) {
[10:30:49.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.411]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.411]                   base::options(opts)
[10:30:49.411]                 }
[10:30:49.411]                 {
[10:30:49.411]                   {
[10:30:49.411]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.411]                     NULL
[10:30:49.411]                   }
[10:30:49.411]                   options(future.plan = NULL)
[10:30:49.411]                   if (is.na(NA_character_)) 
[10:30:49.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.411]                     .init = FALSE)
[10:30:49.411]                 }
[10:30:49.411]             }
[10:30:49.411]         }
[10:30:49.411]     })
[10:30:49.411]     if (TRUE) {
[10:30:49.411]         base::sink(type = "output", split = FALSE)
[10:30:49.411]         if (TRUE) {
[10:30:49.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.411]         }
[10:30:49.411]         else {
[10:30:49.411]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.411]         }
[10:30:49.411]         base::close(...future.stdout)
[10:30:49.411]         ...future.stdout <- NULL
[10:30:49.411]     }
[10:30:49.411]     ...future.result$conditions <- ...future.conditions
[10:30:49.411]     ...future.result$finished <- base::Sys.time()
[10:30:49.411]     ...future.result
[10:30:49.411] }
[10:30:49.414] assign_globals() ...
[10:30:49.414] List of 5
[10:30:49.414]  $ ...future.FUN            :function (x, ...)  
[10:30:49.414]  $ MoreArgs                 :List of 1
[10:30:49.414]   ..$ x: num 42
[10:30:49.414]  $ ...future.elements_ii    :List of 1
[10:30:49.414]   ..$ times:List of 2
[10:30:49.414]   .. ..$ : int 3
[10:30:49.414]   .. ..$ : int 4
[10:30:49.414]  $ ...future.seeds_ii       : NULL
[10:30:49.414]  $ ...future.globals.maxSize: NULL
[10:30:49.414]  - attr(*, "where")=List of 5
[10:30:49.414]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.414]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.414]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.414]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.414]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.414]  - attr(*, "resolved")= logi FALSE
[10:30:49.414]  - attr(*, "total_size")= num 224
[10:30:49.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.414]  - attr(*, "already-done")= logi TRUE
[10:30:49.422] - copied ‘...future.FUN’ to environment
[10:30:49.422] - copied ‘MoreArgs’ to environment
[10:30:49.422] - copied ‘...future.elements_ii’ to environment
[10:30:49.422] - copied ‘...future.seeds_ii’ to environment
[10:30:49.422] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.422] assign_globals() ... done
[10:30:49.422] requestCore(): workers = 2
[10:30:49.425] MulticoreFuture started
[10:30:49.425] - Launch lazy future ... done
[10:30:49.426] run() for ‘MulticoreFuture’ ... done
[10:30:49.426] Created future:
[10:30:49.426] plan(): Setting new future strategy stack:
[10:30:49.427] List of future strategies:
[10:30:49.427] 1. sequential:
[10:30:49.427]    - args: function (..., envir = parent.frame())
[10:30:49.427]    - tweaked: FALSE
[10:30:49.427]    - call: NULL
[10:30:49.427] plan(): nbrOfWorkers() = 1
[10:30:49.430] plan(): Setting new future strategy stack:
[10:30:49.430] List of future strategies:
[10:30:49.430] 1. multicore:
[10:30:49.430]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.430]    - tweaked: FALSE
[10:30:49.430]    - call: plan(strategy)
[10:30:49.426] MulticoreFuture:
[10:30:49.426] Label: ‘future_mapply-2’
[10:30:49.426] Expression:
[10:30:49.426] {
[10:30:49.426]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.426]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.426]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.426]         on.exit(options(oopts), add = TRUE)
[10:30:49.426]     }
[10:30:49.426]     {
[10:30:49.426]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.426]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.426]         do.call(mapply, args = args)
[10:30:49.426]     }
[10:30:49.426] }
[10:30:49.426] Lazy evaluation: FALSE
[10:30:49.426] Asynchronous evaluation: TRUE
[10:30:49.426] Local evaluation: TRUE
[10:30:49.426] Environment: R_GlobalEnv
[10:30:49.426] Capture standard output: TRUE
[10:30:49.426] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.426] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.426] Packages: <none>
[10:30:49.426] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.426] Resolved: FALSE
[10:30:49.426] Value: <not collected>
[10:30:49.426] Conditions captured: <none>
[10:30:49.426] Early signaling: FALSE
[10:30:49.426] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.426] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.439] Chunk #2 of 2 ... DONE
[10:30:49.439] Launching 2 futures (chunks) ... DONE
[10:30:49.439] Resolving 2 futures (chunks) ...
[10:30:49.440] resolve() on list ...
[10:30:49.443] plan(): nbrOfWorkers() = 2
[10:30:49.440]  recursive: 0
[10:30:49.444]  length: 2
[10:30:49.444] 
[10:30:49.445] Future #1
[10:30:49.445] result() for MulticoreFuture ...
[10:30:49.447] result() for MulticoreFuture ...
[10:30:49.447] result() for MulticoreFuture ... done
[10:30:49.447] result() for MulticoreFuture ... done
[10:30:49.447] result() for MulticoreFuture ...
[10:30:49.448] result() for MulticoreFuture ... done
[10:30:49.448] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:49.448] - nx: 2
[10:30:49.449] - relay: TRUE
[10:30:49.449] - stdout: TRUE
[10:30:49.449] - signal: TRUE
[10:30:49.450] - resignal: FALSE
[10:30:49.450] - force: TRUE
[10:30:49.450] - relayed: [n=2] FALSE, FALSE
[10:30:49.450] - queued futures: [n=2] FALSE, FALSE
[10:30:49.451]  - until=1
[10:30:49.451]  - relaying element #1
[10:30:49.451] result() for MulticoreFuture ...
[10:30:49.451] result() for MulticoreFuture ... done
[10:30:49.452] result() for MulticoreFuture ...
[10:30:49.452] result() for MulticoreFuture ... done
[10:30:49.452] result() for MulticoreFuture ...
[10:30:49.452] result() for MulticoreFuture ... done
[10:30:49.453] result() for MulticoreFuture ...
[10:30:49.453] result() for MulticoreFuture ... done
[10:30:49.453] - relayed: [n=2] TRUE, FALSE
[10:30:49.453] - queued futures: [n=2] TRUE, FALSE
[10:30:49.453] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:49.453]  length: 1 (resolved future 1)
[10:30:49.454] Future #2
[10:30:49.454] result() for MulticoreFuture ...
[10:30:49.455] result() for MulticoreFuture ...
[10:30:49.455] result() for MulticoreFuture ... done
[10:30:49.455] result() for MulticoreFuture ... done
[10:30:49.455] result() for MulticoreFuture ...
[10:30:49.456] result() for MulticoreFuture ... done
[10:30:49.456] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:49.456] - nx: 2
[10:30:49.456] - relay: TRUE
[10:30:49.457] - stdout: TRUE
[10:30:49.457] - signal: TRUE
[10:30:49.457] - resignal: FALSE
[10:30:49.457] - force: TRUE
[10:30:49.457] - relayed: [n=2] TRUE, FALSE
[10:30:49.457] - queued futures: [n=2] TRUE, FALSE
[10:30:49.458]  - until=2
[10:30:49.458]  - relaying element #2
[10:30:49.458] result() for MulticoreFuture ...
[10:30:49.458] result() for MulticoreFuture ... done
[10:30:49.458] result() for MulticoreFuture ...
[10:30:49.458] result() for MulticoreFuture ... done
[10:30:49.459] result() for MulticoreFuture ...
[10:30:49.459] result() for MulticoreFuture ... done
[10:30:49.459] result() for MulticoreFuture ...
[10:30:49.459] result() for MulticoreFuture ... done
[10:30:49.459] - relayed: [n=2] TRUE, TRUE
[10:30:49.459] - queued futures: [n=2] TRUE, TRUE
[10:30:49.459] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:49.460]  length: 0 (resolved future 2)
[10:30:49.460] Relaying remaining futures
[10:30:49.460] signalConditionsASAP(NULL, pos=0) ...
[10:30:49.460] - nx: 2
[10:30:49.460] - relay: TRUE
[10:30:49.460] - stdout: TRUE
[10:30:49.460] - signal: TRUE
[10:30:49.460] - resignal: FALSE
[10:30:49.460] - force: TRUE
[10:30:49.460] - relayed: [n=2] TRUE, TRUE
[10:30:49.461] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:49.461] - relayed: [n=2] TRUE, TRUE
[10:30:49.461] - queued futures: [n=2] TRUE, TRUE
[10:30:49.461] signalConditionsASAP(NULL, pos=0) ... done
[10:30:49.461] resolve() on list ... DONE
[10:30:49.461] result() for MulticoreFuture ...
[10:30:49.461] result() for MulticoreFuture ... done
[10:30:49.462] result() for MulticoreFuture ...
[10:30:49.462] result() for MulticoreFuture ... done
[10:30:49.462] result() for MulticoreFuture ...
[10:30:49.462] result() for MulticoreFuture ... done
[10:30:49.462] result() for MulticoreFuture ...
[10:30:49.462] result() for MulticoreFuture ... done
[10:30:49.462]  - Number of value chunks collected: 2
[10:30:49.462] Resolving 2 futures (chunks) ... DONE
[10:30:49.462] Reducing values from 2 chunks ...
[10:30:49.463]  - Number of values collected after concatenation: 4
[10:30:49.463]  - Number of values expected: 4
[10:30:49.463] Reducing values from 2 chunks ... DONE
[10:30:49.463] future_mapply() ... DONE
[10:30:49.463] future_mapply() ...
[10:30:49.468] Number of chunks: 2
[10:30:49.468] getGlobalsAndPackagesXApply() ...
[10:30:49.468]  - future.globals: TRUE
[10:30:49.468] getGlobalsAndPackages() ...
[10:30:49.468] Searching for globals...
[10:30:49.470] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:30:49.470] Searching for globals ... DONE
[10:30:49.470] Resolving globals: FALSE
[10:30:49.471] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[10:30:49.471] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[10:30:49.471] - globals: [1] ‘FUN’
[10:30:49.472] 
[10:30:49.472] getGlobalsAndPackages() ... DONE
[10:30:49.472]  - globals found/used: [n=1] ‘FUN’
[10:30:49.472]  - needed namespaces: [n=0] 
[10:30:49.472] Finding globals ... DONE
[10:30:49.472] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:49.472] List of 2
[10:30:49.472]  $ ...future.FUN:function (x, y)  
[10:30:49.472]  $ MoreArgs     : NULL
[10:30:49.472]  - attr(*, "where")=List of 2
[10:30:49.472]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:49.472]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:49.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.472]  - attr(*, "resolved")= logi FALSE
[10:30:49.472]  - attr(*, "total_size")= num NA
[10:30:49.475] Packages to be attached in all futures: [n=0] 
[10:30:49.475] getGlobalsAndPackagesXApply() ... DONE
[10:30:49.476] Number of futures (= number of chunks): 2
[10:30:49.476] Launching 2 futures (chunks) ...
[10:30:49.476] Chunk #1 of 2 ...
[10:30:49.476]  - Finding globals in '...' for chunk #1 ...
[10:30:49.476] getGlobalsAndPackages() ...
[10:30:49.476] Searching for globals...
[10:30:49.477] 
[10:30:49.477] Searching for globals ... DONE
[10:30:49.477] - globals: [0] <none>
[10:30:49.479] getGlobalsAndPackages() ... DONE
[10:30:49.479]    + additional globals found: [n=0] 
[10:30:49.479]    + additional namespaces needed: [n=0] 
[10:30:49.480]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:49.480]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.480]  - seeds: <none>
[10:30:49.480]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.480] getGlobalsAndPackages() ...
[10:30:49.480] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.480] Resolving globals: FALSE
[10:30:49.481] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[10:30:49.482] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.482] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.482] 
[10:30:49.482] getGlobalsAndPackages() ... DONE
[10:30:49.482] run() for ‘Future’ ...
[10:30:49.482] - state: ‘created’
[10:30:49.483] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.487] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.487]   - Field: ‘label’
[10:30:49.487]   - Field: ‘local’
[10:30:49.487]   - Field: ‘owner’
[10:30:49.487]   - Field: ‘envir’
[10:30:49.488]   - Field: ‘workers’
[10:30:49.488]   - Field: ‘packages’
[10:30:49.488]   - Field: ‘gc’
[10:30:49.488]   - Field: ‘job’
[10:30:49.488]   - Field: ‘conditions’
[10:30:49.488]   - Field: ‘expr’
[10:30:49.488]   - Field: ‘uuid’
[10:30:49.488]   - Field: ‘seed’
[10:30:49.488]   - Field: ‘version’
[10:30:49.488]   - Field: ‘result’
[10:30:49.489]   - Field: ‘asynchronous’
[10:30:49.489]   - Field: ‘calls’
[10:30:49.489]   - Field: ‘globals’
[10:30:49.489]   - Field: ‘stdout’
[10:30:49.489]   - Field: ‘earlySignal’
[10:30:49.489]   - Field: ‘lazy’
[10:30:49.489]   - Field: ‘state’
[10:30:49.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.489] - Launch lazy future ...
[10:30:49.490] Packages needed by the future expression (n = 0): <none>
[10:30:49.490] Packages needed by future strategies (n = 0): <none>
[10:30:49.490] {
[10:30:49.490]     {
[10:30:49.490]         {
[10:30:49.490]             ...future.startTime <- base::Sys.time()
[10:30:49.490]             {
[10:30:49.490]                 {
[10:30:49.490]                   {
[10:30:49.490]                     {
[10:30:49.490]                       base::local({
[10:30:49.490]                         has_future <- base::requireNamespace("future", 
[10:30:49.490]                           quietly = TRUE)
[10:30:49.490]                         if (has_future) {
[10:30:49.490]                           ns <- base::getNamespace("future")
[10:30:49.490]                           version <- ns[[".package"]][["version"]]
[10:30:49.490]                           if (is.null(version)) 
[10:30:49.490]                             version <- utils::packageVersion("future")
[10:30:49.490]                         }
[10:30:49.490]                         else {
[10:30:49.490]                           version <- NULL
[10:30:49.490]                         }
[10:30:49.490]                         if (!has_future || version < "1.8.0") {
[10:30:49.490]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.490]                             "", base::R.version$version.string), 
[10:30:49.490]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.490]                               "release", "version")], collapse = " "), 
[10:30:49.490]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.490]                             info)
[10:30:49.490]                           info <- base::paste(info, collapse = "; ")
[10:30:49.490]                           if (!has_future) {
[10:30:49.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.490]                               info)
[10:30:49.490]                           }
[10:30:49.490]                           else {
[10:30:49.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.490]                               info, version)
[10:30:49.490]                           }
[10:30:49.490]                           base::stop(msg)
[10:30:49.490]                         }
[10:30:49.490]                       })
[10:30:49.490]                     }
[10:30:49.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.490]                     base::options(mc.cores = 1L)
[10:30:49.490]                   }
[10:30:49.490]                   ...future.strategy.old <- future::plan("list")
[10:30:49.490]                   options(future.plan = NULL)
[10:30:49.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.490]                 }
[10:30:49.490]                 ...future.workdir <- getwd()
[10:30:49.490]             }
[10:30:49.490]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.490]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.490]         }
[10:30:49.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.490]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.490]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.490]             base::names(...future.oldOptions))
[10:30:49.490]     }
[10:30:49.490]     if (FALSE) {
[10:30:49.490]     }
[10:30:49.490]     else {
[10:30:49.490]         if (TRUE) {
[10:30:49.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.490]                 open = "w")
[10:30:49.490]         }
[10:30:49.490]         else {
[10:30:49.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.490]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.490]         }
[10:30:49.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.490]             base::sink(type = "output", split = FALSE)
[10:30:49.490]             base::close(...future.stdout)
[10:30:49.490]         }, add = TRUE)
[10:30:49.490]     }
[10:30:49.490]     ...future.frame <- base::sys.nframe()
[10:30:49.490]     ...future.conditions <- base::list()
[10:30:49.490]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.490]     if (FALSE) {
[10:30:49.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.490]     }
[10:30:49.490]     ...future.result <- base::tryCatch({
[10:30:49.490]         base::withCallingHandlers({
[10:30:49.490]             ...future.value <- base::withVisible(base::local({
[10:30:49.490]                 withCallingHandlers({
[10:30:49.490]                   {
[10:30:49.490]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.490]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.490]                       ...future.globals.maxSize)) {
[10:30:49.490]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.490]                       on.exit(options(oopts), add = TRUE)
[10:30:49.490]                     }
[10:30:49.490]                     {
[10:30:49.490]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.490]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.490]                         USE.NAMES = FALSE)
[10:30:49.490]                       do.call(mapply, args = args)
[10:30:49.490]                     }
[10:30:49.490]                   }
[10:30:49.490]                 }, immediateCondition = function(cond) {
[10:30:49.490]                   save_rds <- function (object, pathname, ...) 
[10:30:49.490]                   {
[10:30:49.490]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.490]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.490]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.490]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.490]                         fi_tmp[["mtime"]])
[10:30:49.490]                     }
[10:30:49.490]                     tryCatch({
[10:30:49.490]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.490]                     }, error = function(ex) {
[10:30:49.490]                       msg <- conditionMessage(ex)
[10:30:49.490]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.490]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.490]                         fi_tmp[["mtime"]], msg)
[10:30:49.490]                       ex$message <- msg
[10:30:49.490]                       stop(ex)
[10:30:49.490]                     })
[10:30:49.490]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.490]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.490]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.490]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.490]                       fi <- file.info(pathname)
[10:30:49.490]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.490]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.490]                         fi[["size"]], fi[["mtime"]])
[10:30:49.490]                       stop(msg)
[10:30:49.490]                     }
[10:30:49.490]                     invisible(pathname)
[10:30:49.490]                   }
[10:30:49.490]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.490]                     rootPath = tempdir()) 
[10:30:49.490]                   {
[10:30:49.490]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.490]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.490]                       tmpdir = path, fileext = ".rds")
[10:30:49.490]                     save_rds(obj, file)
[10:30:49.490]                   }
[10:30:49.490]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.490]                   {
[10:30:49.490]                     inherits <- base::inherits
[10:30:49.490]                     invokeRestart <- base::invokeRestart
[10:30:49.490]                     is.null <- base::is.null
[10:30:49.490]                     muffled <- FALSE
[10:30:49.490]                     if (inherits(cond, "message")) {
[10:30:49.490]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.490]                       if (muffled) 
[10:30:49.490]                         invokeRestart("muffleMessage")
[10:30:49.490]                     }
[10:30:49.490]                     else if (inherits(cond, "warning")) {
[10:30:49.490]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.490]                       if (muffled) 
[10:30:49.490]                         invokeRestart("muffleWarning")
[10:30:49.490]                     }
[10:30:49.490]                     else if (inherits(cond, "condition")) {
[10:30:49.490]                       if (!is.null(pattern)) {
[10:30:49.490]                         computeRestarts <- base::computeRestarts
[10:30:49.490]                         grepl <- base::grepl
[10:30:49.490]                         restarts <- computeRestarts(cond)
[10:30:49.490]                         for (restart in restarts) {
[10:30:49.490]                           name <- restart$name
[10:30:49.490]                           if (is.null(name)) 
[10:30:49.490]                             next
[10:30:49.490]                           if (!grepl(pattern, name)) 
[10:30:49.490]                             next
[10:30:49.490]                           invokeRestart(restart)
[10:30:49.490]                           muffled <- TRUE
[10:30:49.490]                           break
[10:30:49.490]                         }
[10:30:49.490]                       }
[10:30:49.490]                     }
[10:30:49.490]                     invisible(muffled)
[10:30:49.490]                   }
[10:30:49.490]                   muffleCondition(cond)
[10:30:49.490]                 })
[10:30:49.490]             }))
[10:30:49.490]             future::FutureResult(value = ...future.value$value, 
[10:30:49.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.490]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.490]                     ...future.globalenv.names))
[10:30:49.490]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.490]         }, condition = base::local({
[10:30:49.490]             c <- base::c
[10:30:49.490]             inherits <- base::inherits
[10:30:49.490]             invokeRestart <- base::invokeRestart
[10:30:49.490]             length <- base::length
[10:30:49.490]             list <- base::list
[10:30:49.490]             seq.int <- base::seq.int
[10:30:49.490]             signalCondition <- base::signalCondition
[10:30:49.490]             sys.calls <- base::sys.calls
[10:30:49.490]             `[[` <- base::`[[`
[10:30:49.490]             `+` <- base::`+`
[10:30:49.490]             `<<-` <- base::`<<-`
[10:30:49.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.490]                   3L)]
[10:30:49.490]             }
[10:30:49.490]             function(cond) {
[10:30:49.490]                 is_error <- inherits(cond, "error")
[10:30:49.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.490]                   NULL)
[10:30:49.490]                 if (is_error) {
[10:30:49.490]                   sessionInformation <- function() {
[10:30:49.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.490]                       search = base::search(), system = base::Sys.info())
[10:30:49.490]                   }
[10:30:49.490]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.490]                     cond$call), session = sessionInformation(), 
[10:30:49.490]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.490]                   signalCondition(cond)
[10:30:49.490]                 }
[10:30:49.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.490]                 "immediateCondition"))) {
[10:30:49.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.490]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.490]                   if (TRUE && !signal) {
[10:30:49.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.490]                     {
[10:30:49.490]                       inherits <- base::inherits
[10:30:49.490]                       invokeRestart <- base::invokeRestart
[10:30:49.490]                       is.null <- base::is.null
[10:30:49.490]                       muffled <- FALSE
[10:30:49.490]                       if (inherits(cond, "message")) {
[10:30:49.490]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.490]                         if (muffled) 
[10:30:49.490]                           invokeRestart("muffleMessage")
[10:30:49.490]                       }
[10:30:49.490]                       else if (inherits(cond, "warning")) {
[10:30:49.490]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.490]                         if (muffled) 
[10:30:49.490]                           invokeRestart("muffleWarning")
[10:30:49.490]                       }
[10:30:49.490]                       else if (inherits(cond, "condition")) {
[10:30:49.490]                         if (!is.null(pattern)) {
[10:30:49.490]                           computeRestarts <- base::computeRestarts
[10:30:49.490]                           grepl <- base::grepl
[10:30:49.490]                           restarts <- computeRestarts(cond)
[10:30:49.490]                           for (restart in restarts) {
[10:30:49.490]                             name <- restart$name
[10:30:49.490]                             if (is.null(name)) 
[10:30:49.490]                               next
[10:30:49.490]                             if (!grepl(pattern, name)) 
[10:30:49.490]                               next
[10:30:49.490]                             invokeRestart(restart)
[10:30:49.490]                             muffled <- TRUE
[10:30:49.490]                             break
[10:30:49.490]                           }
[10:30:49.490]                         }
[10:30:49.490]                       }
[10:30:49.490]                       invisible(muffled)
[10:30:49.490]                     }
[10:30:49.490]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.490]                   }
[10:30:49.490]                 }
[10:30:49.490]                 else {
[10:30:49.490]                   if (TRUE) {
[10:30:49.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.490]                     {
[10:30:49.490]                       inherits <- base::inherits
[10:30:49.490]                       invokeRestart <- base::invokeRestart
[10:30:49.490]                       is.null <- base::is.null
[10:30:49.490]                       muffled <- FALSE
[10:30:49.490]                       if (inherits(cond, "message")) {
[10:30:49.490]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.490]                         if (muffled) 
[10:30:49.490]                           invokeRestart("muffleMessage")
[10:30:49.490]                       }
[10:30:49.490]                       else if (inherits(cond, "warning")) {
[10:30:49.490]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.490]                         if (muffled) 
[10:30:49.490]                           invokeRestart("muffleWarning")
[10:30:49.490]                       }
[10:30:49.490]                       else if (inherits(cond, "condition")) {
[10:30:49.490]                         if (!is.null(pattern)) {
[10:30:49.490]                           computeRestarts <- base::computeRestarts
[10:30:49.490]                           grepl <- base::grepl
[10:30:49.490]                           restarts <- computeRestarts(cond)
[10:30:49.490]                           for (restart in restarts) {
[10:30:49.490]                             name <- restart$name
[10:30:49.490]                             if (is.null(name)) 
[10:30:49.490]                               next
[10:30:49.490]                             if (!grepl(pattern, name)) 
[10:30:49.490]                               next
[10:30:49.490]                             invokeRestart(restart)
[10:30:49.490]                             muffled <- TRUE
[10:30:49.490]                             break
[10:30:49.490]                           }
[10:30:49.490]                         }
[10:30:49.490]                       }
[10:30:49.490]                       invisible(muffled)
[10:30:49.490]                     }
[10:30:49.490]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.490]                   }
[10:30:49.490]                 }
[10:30:49.490]             }
[10:30:49.490]         }))
[10:30:49.490]     }, error = function(ex) {
[10:30:49.490]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.490]                 ...future.rng), started = ...future.startTime, 
[10:30:49.490]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.490]             version = "1.8"), class = "FutureResult")
[10:30:49.490]     }, finally = {
[10:30:49.490]         if (!identical(...future.workdir, getwd())) 
[10:30:49.490]             setwd(...future.workdir)
[10:30:49.490]         {
[10:30:49.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.490]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.490]             }
[10:30:49.490]             base::options(...future.oldOptions)
[10:30:49.490]             if (.Platform$OS.type == "windows") {
[10:30:49.490]                 old_names <- names(...future.oldEnvVars)
[10:30:49.490]                 envs <- base::Sys.getenv()
[10:30:49.490]                 names <- names(envs)
[10:30:49.490]                 common <- intersect(names, old_names)
[10:30:49.490]                 added <- setdiff(names, old_names)
[10:30:49.490]                 removed <- setdiff(old_names, names)
[10:30:49.490]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.490]                   envs[common]]
[10:30:49.490]                 NAMES <- toupper(changed)
[10:30:49.490]                 args <- list()
[10:30:49.490]                 for (kk in seq_along(NAMES)) {
[10:30:49.490]                   name <- changed[[kk]]
[10:30:49.490]                   NAME <- NAMES[[kk]]
[10:30:49.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.490]                     next
[10:30:49.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.490]                 }
[10:30:49.490]                 NAMES <- toupper(added)
[10:30:49.490]                 for (kk in seq_along(NAMES)) {
[10:30:49.490]                   name <- added[[kk]]
[10:30:49.490]                   NAME <- NAMES[[kk]]
[10:30:49.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.490]                     next
[10:30:49.490]                   args[[name]] <- ""
[10:30:49.490]                 }
[10:30:49.490]                 NAMES <- toupper(removed)
[10:30:49.490]                 for (kk in seq_along(NAMES)) {
[10:30:49.490]                   name <- removed[[kk]]
[10:30:49.490]                   NAME <- NAMES[[kk]]
[10:30:49.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.490]                     next
[10:30:49.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.490]                 }
[10:30:49.490]                 if (length(args) > 0) 
[10:30:49.490]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.490]             }
[10:30:49.490]             else {
[10:30:49.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.490]             }
[10:30:49.490]             {
[10:30:49.490]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.490]                   0L) {
[10:30:49.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.490]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.490]                   base::options(opts)
[10:30:49.490]                 }
[10:30:49.490]                 {
[10:30:49.490]                   {
[10:30:49.490]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.490]                     NULL
[10:30:49.490]                   }
[10:30:49.490]                   options(future.plan = NULL)
[10:30:49.490]                   if (is.na(NA_character_)) 
[10:30:49.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.490]                     .init = FALSE)
[10:30:49.490]                 }
[10:30:49.490]             }
[10:30:49.490]         }
[10:30:49.490]     })
[10:30:49.490]     if (TRUE) {
[10:30:49.490]         base::sink(type = "output", split = FALSE)
[10:30:49.490]         if (TRUE) {
[10:30:49.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.490]         }
[10:30:49.490]         else {
[10:30:49.490]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.490]         }
[10:30:49.490]         base::close(...future.stdout)
[10:30:49.490]         ...future.stdout <- NULL
[10:30:49.490]     }
[10:30:49.490]     ...future.result$conditions <- ...future.conditions
[10:30:49.490]     ...future.result$finished <- base::Sys.time()
[10:30:49.490]     ...future.result
[10:30:49.490] }
[10:30:49.493] assign_globals() ...
[10:30:49.493] List of 5
[10:30:49.493]  $ ...future.FUN            :function (x, y)  
[10:30:49.493]  $ MoreArgs                 : NULL
[10:30:49.493]  $ ...future.elements_ii    :List of 2
[10:30:49.493]   ..$ :List of 1
[10:30:49.493]   .. ..$ a: num 1
[10:30:49.493]   ..$ :List of 1
[10:30:49.493]   .. ..$ A: num 10
[10:30:49.493]  $ ...future.seeds_ii       : NULL
[10:30:49.493]  $ ...future.globals.maxSize: NULL
[10:30:49.493]  - attr(*, "where")=List of 5
[10:30:49.493]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.493]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.493]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.493]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.493]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.493]  - attr(*, "resolved")= logi FALSE
[10:30:49.493]  - attr(*, "total_size")= num 2088
[10:30:49.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.493]  - attr(*, "already-done")= logi TRUE
[10:30:49.498] - reassign environment for ‘...future.FUN’
[10:30:49.499] - copied ‘...future.FUN’ to environment
[10:30:49.499] - copied ‘MoreArgs’ to environment
[10:30:49.499] - copied ‘...future.elements_ii’ to environment
[10:30:49.499] - copied ‘...future.seeds_ii’ to environment
[10:30:49.499] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.499] assign_globals() ... done
[10:30:49.499] requestCore(): workers = 2
[10:30:49.502] MulticoreFuture started
[10:30:49.502] - Launch lazy future ... done
[10:30:49.502] run() for ‘MulticoreFuture’ ... done
[10:30:49.503] Created future:
[10:30:49.503] plan(): Setting new future strategy stack:
[10:30:49.503] List of future strategies:
[10:30:49.503] 1. sequential:
[10:30:49.503]    - args: function (..., envir = parent.frame())
[10:30:49.503]    - tweaked: FALSE
[10:30:49.503]    - call: NULL
[10:30:49.504] plan(): nbrOfWorkers() = 1
[10:30:49.506] plan(): Setting new future strategy stack:
[10:30:49.506] List of future strategies:
[10:30:49.506] 1. multicore:
[10:30:49.506]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.506]    - tweaked: FALSE
[10:30:49.506]    - call: plan(strategy)
[10:30:49.512] plan(): nbrOfWorkers() = 2
[10:30:49.503] MulticoreFuture:
[10:30:49.503] Label: ‘future_mapply-1’
[10:30:49.503] Expression:
[10:30:49.503] {
[10:30:49.503]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.503]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.503]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.503]         on.exit(options(oopts), add = TRUE)
[10:30:49.503]     }
[10:30:49.503]     {
[10:30:49.503]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.503]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.503]         do.call(mapply, args = args)
[10:30:49.503]     }
[10:30:49.503] }
[10:30:49.503] Lazy evaluation: FALSE
[10:30:49.503] Asynchronous evaluation: TRUE
[10:30:49.503] Local evaluation: TRUE
[10:30:49.503] Environment: R_GlobalEnv
[10:30:49.503] Capture standard output: TRUE
[10:30:49.503] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.503] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.503] Packages: <none>
[10:30:49.503] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.503] Resolved: TRUE
[10:30:49.503] Value: <not collected>
[10:30:49.503] Conditions captured: <none>
[10:30:49.503] Early signaling: FALSE
[10:30:49.503] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.503] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.513] Chunk #1 of 2 ... DONE
[10:30:49.513] Chunk #2 of 2 ...
[10:30:49.513]  - Finding globals in '...' for chunk #2 ...
[10:30:49.514] getGlobalsAndPackages() ...
[10:30:49.514] Searching for globals...
[10:30:49.514] 
[10:30:49.515] Searching for globals ... DONE
[10:30:49.515] - globals: [0] <none>
[10:30:49.515] getGlobalsAndPackages() ... DONE
[10:30:49.515]    + additional globals found: [n=0] 
[10:30:49.515]    + additional namespaces needed: [n=0] 
[10:30:49.515]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:49.515]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.516]  - seeds: <none>
[10:30:49.516]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.516] getGlobalsAndPackages() ...
[10:30:49.516] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.516] Resolving globals: FALSE
[10:30:49.517] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[10:30:49.518] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.518] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.518] 
[10:30:49.519] getGlobalsAndPackages() ... DONE
[10:30:49.524] run() for ‘Future’ ...
[10:30:49.524] - state: ‘created’
[10:30:49.524] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.531] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.532]   - Field: ‘label’
[10:30:49.532]   - Field: ‘local’
[10:30:49.533]   - Field: ‘owner’
[10:30:49.533]   - Field: ‘envir’
[10:30:49.533]   - Field: ‘workers’
[10:30:49.533]   - Field: ‘packages’
[10:30:49.533]   - Field: ‘gc’
[10:30:49.534]   - Field: ‘job’
[10:30:49.534]   - Field: ‘conditions’
[10:30:49.534]   - Field: ‘expr’
[10:30:49.534]   - Field: ‘uuid’
[10:30:49.534]   - Field: ‘seed’
[10:30:49.535]   - Field: ‘version’
[10:30:49.535]   - Field: ‘result’
[10:30:49.535]   - Field: ‘asynchronous’
[10:30:49.535]   - Field: ‘calls’
[10:30:49.535]   - Field: ‘globals’
[10:30:49.535]   - Field: ‘stdout’
[10:30:49.536]   - Field: ‘earlySignal’
[10:30:49.536]   - Field: ‘lazy’
[10:30:49.536]   - Field: ‘state’
[10:30:49.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.536] - Launch lazy future ...
[10:30:49.537] Packages needed by the future expression (n = 0): <none>
[10:30:49.537] Packages needed by future strategies (n = 0): <none>
[10:30:49.538] {
[10:30:49.538]     {
[10:30:49.538]         {
[10:30:49.538]             ...future.startTime <- base::Sys.time()
[10:30:49.538]             {
[10:30:49.538]                 {
[10:30:49.538]                   {
[10:30:49.538]                     {
[10:30:49.538]                       base::local({
[10:30:49.538]                         has_future <- base::requireNamespace("future", 
[10:30:49.538]                           quietly = TRUE)
[10:30:49.538]                         if (has_future) {
[10:30:49.538]                           ns <- base::getNamespace("future")
[10:30:49.538]                           version <- ns[[".package"]][["version"]]
[10:30:49.538]                           if (is.null(version)) 
[10:30:49.538]                             version <- utils::packageVersion("future")
[10:30:49.538]                         }
[10:30:49.538]                         else {
[10:30:49.538]                           version <- NULL
[10:30:49.538]                         }
[10:30:49.538]                         if (!has_future || version < "1.8.0") {
[10:30:49.538]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.538]                             "", base::R.version$version.string), 
[10:30:49.538]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.538]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.538]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.538]                               "release", "version")], collapse = " "), 
[10:30:49.538]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.538]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.538]                             info)
[10:30:49.538]                           info <- base::paste(info, collapse = "; ")
[10:30:49.538]                           if (!has_future) {
[10:30:49.538]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.538]                               info)
[10:30:49.538]                           }
[10:30:49.538]                           else {
[10:30:49.538]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.538]                               info, version)
[10:30:49.538]                           }
[10:30:49.538]                           base::stop(msg)
[10:30:49.538]                         }
[10:30:49.538]                       })
[10:30:49.538]                     }
[10:30:49.538]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.538]                     base::options(mc.cores = 1L)
[10:30:49.538]                   }
[10:30:49.538]                   ...future.strategy.old <- future::plan("list")
[10:30:49.538]                   options(future.plan = NULL)
[10:30:49.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.538]                 }
[10:30:49.538]                 ...future.workdir <- getwd()
[10:30:49.538]             }
[10:30:49.538]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.538]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.538]         }
[10:30:49.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.538]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.538]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.538]             base::names(...future.oldOptions))
[10:30:49.538]     }
[10:30:49.538]     if (FALSE) {
[10:30:49.538]     }
[10:30:49.538]     else {
[10:30:49.538]         if (TRUE) {
[10:30:49.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.538]                 open = "w")
[10:30:49.538]         }
[10:30:49.538]         else {
[10:30:49.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.538]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.538]         }
[10:30:49.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.538]             base::sink(type = "output", split = FALSE)
[10:30:49.538]             base::close(...future.stdout)
[10:30:49.538]         }, add = TRUE)
[10:30:49.538]     }
[10:30:49.538]     ...future.frame <- base::sys.nframe()
[10:30:49.538]     ...future.conditions <- base::list()
[10:30:49.538]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.538]     if (FALSE) {
[10:30:49.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.538]     }
[10:30:49.538]     ...future.result <- base::tryCatch({
[10:30:49.538]         base::withCallingHandlers({
[10:30:49.538]             ...future.value <- base::withVisible(base::local({
[10:30:49.538]                 withCallingHandlers({
[10:30:49.538]                   {
[10:30:49.538]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.538]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.538]                       ...future.globals.maxSize)) {
[10:30:49.538]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.538]                       on.exit(options(oopts), add = TRUE)
[10:30:49.538]                     }
[10:30:49.538]                     {
[10:30:49.538]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.538]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.538]                         USE.NAMES = FALSE)
[10:30:49.538]                       do.call(mapply, args = args)
[10:30:49.538]                     }
[10:30:49.538]                   }
[10:30:49.538]                 }, immediateCondition = function(cond) {
[10:30:49.538]                   save_rds <- function (object, pathname, ...) 
[10:30:49.538]                   {
[10:30:49.538]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.538]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.538]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.538]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.538]                         fi_tmp[["mtime"]])
[10:30:49.538]                     }
[10:30:49.538]                     tryCatch({
[10:30:49.538]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.538]                     }, error = function(ex) {
[10:30:49.538]                       msg <- conditionMessage(ex)
[10:30:49.538]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.538]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.538]                         fi_tmp[["mtime"]], msg)
[10:30:49.538]                       ex$message <- msg
[10:30:49.538]                       stop(ex)
[10:30:49.538]                     })
[10:30:49.538]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.538]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.538]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.538]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.538]                       fi <- file.info(pathname)
[10:30:49.538]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.538]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.538]                         fi[["size"]], fi[["mtime"]])
[10:30:49.538]                       stop(msg)
[10:30:49.538]                     }
[10:30:49.538]                     invisible(pathname)
[10:30:49.538]                   }
[10:30:49.538]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.538]                     rootPath = tempdir()) 
[10:30:49.538]                   {
[10:30:49.538]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.538]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.538]                       tmpdir = path, fileext = ".rds")
[10:30:49.538]                     save_rds(obj, file)
[10:30:49.538]                   }
[10:30:49.538]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.538]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.538]                   {
[10:30:49.538]                     inherits <- base::inherits
[10:30:49.538]                     invokeRestart <- base::invokeRestart
[10:30:49.538]                     is.null <- base::is.null
[10:30:49.538]                     muffled <- FALSE
[10:30:49.538]                     if (inherits(cond, "message")) {
[10:30:49.538]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.538]                       if (muffled) 
[10:30:49.538]                         invokeRestart("muffleMessage")
[10:30:49.538]                     }
[10:30:49.538]                     else if (inherits(cond, "warning")) {
[10:30:49.538]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.538]                       if (muffled) 
[10:30:49.538]                         invokeRestart("muffleWarning")
[10:30:49.538]                     }
[10:30:49.538]                     else if (inherits(cond, "condition")) {
[10:30:49.538]                       if (!is.null(pattern)) {
[10:30:49.538]                         computeRestarts <- base::computeRestarts
[10:30:49.538]                         grepl <- base::grepl
[10:30:49.538]                         restarts <- computeRestarts(cond)
[10:30:49.538]                         for (restart in restarts) {
[10:30:49.538]                           name <- restart$name
[10:30:49.538]                           if (is.null(name)) 
[10:30:49.538]                             next
[10:30:49.538]                           if (!grepl(pattern, name)) 
[10:30:49.538]                             next
[10:30:49.538]                           invokeRestart(restart)
[10:30:49.538]                           muffled <- TRUE
[10:30:49.538]                           break
[10:30:49.538]                         }
[10:30:49.538]                       }
[10:30:49.538]                     }
[10:30:49.538]                     invisible(muffled)
[10:30:49.538]                   }
[10:30:49.538]                   muffleCondition(cond)
[10:30:49.538]                 })
[10:30:49.538]             }))
[10:30:49.538]             future::FutureResult(value = ...future.value$value, 
[10:30:49.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.538]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.538]                     ...future.globalenv.names))
[10:30:49.538]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.538]         }, condition = base::local({
[10:30:49.538]             c <- base::c
[10:30:49.538]             inherits <- base::inherits
[10:30:49.538]             invokeRestart <- base::invokeRestart
[10:30:49.538]             length <- base::length
[10:30:49.538]             list <- base::list
[10:30:49.538]             seq.int <- base::seq.int
[10:30:49.538]             signalCondition <- base::signalCondition
[10:30:49.538]             sys.calls <- base::sys.calls
[10:30:49.538]             `[[` <- base::`[[`
[10:30:49.538]             `+` <- base::`+`
[10:30:49.538]             `<<-` <- base::`<<-`
[10:30:49.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.538]                   3L)]
[10:30:49.538]             }
[10:30:49.538]             function(cond) {
[10:30:49.538]                 is_error <- inherits(cond, "error")
[10:30:49.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.538]                   NULL)
[10:30:49.538]                 if (is_error) {
[10:30:49.538]                   sessionInformation <- function() {
[10:30:49.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.538]                       search = base::search(), system = base::Sys.info())
[10:30:49.538]                   }
[10:30:49.538]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.538]                     cond$call), session = sessionInformation(), 
[10:30:49.538]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.538]                   signalCondition(cond)
[10:30:49.538]                 }
[10:30:49.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.538]                 "immediateCondition"))) {
[10:30:49.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.538]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.538]                   if (TRUE && !signal) {
[10:30:49.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.538]                     {
[10:30:49.538]                       inherits <- base::inherits
[10:30:49.538]                       invokeRestart <- base::invokeRestart
[10:30:49.538]                       is.null <- base::is.null
[10:30:49.538]                       muffled <- FALSE
[10:30:49.538]                       if (inherits(cond, "message")) {
[10:30:49.538]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.538]                         if (muffled) 
[10:30:49.538]                           invokeRestart("muffleMessage")
[10:30:49.538]                       }
[10:30:49.538]                       else if (inherits(cond, "warning")) {
[10:30:49.538]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.538]                         if (muffled) 
[10:30:49.538]                           invokeRestart("muffleWarning")
[10:30:49.538]                       }
[10:30:49.538]                       else if (inherits(cond, "condition")) {
[10:30:49.538]                         if (!is.null(pattern)) {
[10:30:49.538]                           computeRestarts <- base::computeRestarts
[10:30:49.538]                           grepl <- base::grepl
[10:30:49.538]                           restarts <- computeRestarts(cond)
[10:30:49.538]                           for (restart in restarts) {
[10:30:49.538]                             name <- restart$name
[10:30:49.538]                             if (is.null(name)) 
[10:30:49.538]                               next
[10:30:49.538]                             if (!grepl(pattern, name)) 
[10:30:49.538]                               next
[10:30:49.538]                             invokeRestart(restart)
[10:30:49.538]                             muffled <- TRUE
[10:30:49.538]                             break
[10:30:49.538]                           }
[10:30:49.538]                         }
[10:30:49.538]                       }
[10:30:49.538]                       invisible(muffled)
[10:30:49.538]                     }
[10:30:49.538]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.538]                   }
[10:30:49.538]                 }
[10:30:49.538]                 else {
[10:30:49.538]                   if (TRUE) {
[10:30:49.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.538]                     {
[10:30:49.538]                       inherits <- base::inherits
[10:30:49.538]                       invokeRestart <- base::invokeRestart
[10:30:49.538]                       is.null <- base::is.null
[10:30:49.538]                       muffled <- FALSE
[10:30:49.538]                       if (inherits(cond, "message")) {
[10:30:49.538]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.538]                         if (muffled) 
[10:30:49.538]                           invokeRestart("muffleMessage")
[10:30:49.538]                       }
[10:30:49.538]                       else if (inherits(cond, "warning")) {
[10:30:49.538]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.538]                         if (muffled) 
[10:30:49.538]                           invokeRestart("muffleWarning")
[10:30:49.538]                       }
[10:30:49.538]                       else if (inherits(cond, "condition")) {
[10:30:49.538]                         if (!is.null(pattern)) {
[10:30:49.538]                           computeRestarts <- base::computeRestarts
[10:30:49.538]                           grepl <- base::grepl
[10:30:49.538]                           restarts <- computeRestarts(cond)
[10:30:49.538]                           for (restart in restarts) {
[10:30:49.538]                             name <- restart$name
[10:30:49.538]                             if (is.null(name)) 
[10:30:49.538]                               next
[10:30:49.538]                             if (!grepl(pattern, name)) 
[10:30:49.538]                               next
[10:30:49.538]                             invokeRestart(restart)
[10:30:49.538]                             muffled <- TRUE
[10:30:49.538]                             break
[10:30:49.538]                           }
[10:30:49.538]                         }
[10:30:49.538]                       }
[10:30:49.538]                       invisible(muffled)
[10:30:49.538]                     }
[10:30:49.538]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.538]                   }
[10:30:49.538]                 }
[10:30:49.538]             }
[10:30:49.538]         }))
[10:30:49.538]     }, error = function(ex) {
[10:30:49.538]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.538]                 ...future.rng), started = ...future.startTime, 
[10:30:49.538]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.538]             version = "1.8"), class = "FutureResult")
[10:30:49.538]     }, finally = {
[10:30:49.538]         if (!identical(...future.workdir, getwd())) 
[10:30:49.538]             setwd(...future.workdir)
[10:30:49.538]         {
[10:30:49.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.538]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.538]             }
[10:30:49.538]             base::options(...future.oldOptions)
[10:30:49.538]             if (.Platform$OS.type == "windows") {
[10:30:49.538]                 old_names <- names(...future.oldEnvVars)
[10:30:49.538]                 envs <- base::Sys.getenv()
[10:30:49.538]                 names <- names(envs)
[10:30:49.538]                 common <- intersect(names, old_names)
[10:30:49.538]                 added <- setdiff(names, old_names)
[10:30:49.538]                 removed <- setdiff(old_names, names)
[10:30:49.538]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.538]                   envs[common]]
[10:30:49.538]                 NAMES <- toupper(changed)
[10:30:49.538]                 args <- list()
[10:30:49.538]                 for (kk in seq_along(NAMES)) {
[10:30:49.538]                   name <- changed[[kk]]
[10:30:49.538]                   NAME <- NAMES[[kk]]
[10:30:49.538]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.538]                     next
[10:30:49.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.538]                 }
[10:30:49.538]                 NAMES <- toupper(added)
[10:30:49.538]                 for (kk in seq_along(NAMES)) {
[10:30:49.538]                   name <- added[[kk]]
[10:30:49.538]                   NAME <- NAMES[[kk]]
[10:30:49.538]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.538]                     next
[10:30:49.538]                   args[[name]] <- ""
[10:30:49.538]                 }
[10:30:49.538]                 NAMES <- toupper(removed)
[10:30:49.538]                 for (kk in seq_along(NAMES)) {
[10:30:49.538]                   name <- removed[[kk]]
[10:30:49.538]                   NAME <- NAMES[[kk]]
[10:30:49.538]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.538]                     next
[10:30:49.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.538]                 }
[10:30:49.538]                 if (length(args) > 0) 
[10:30:49.538]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.538]             }
[10:30:49.538]             else {
[10:30:49.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.538]             }
[10:30:49.538]             {
[10:30:49.538]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.538]                   0L) {
[10:30:49.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.538]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.538]                   base::options(opts)
[10:30:49.538]                 }
[10:30:49.538]                 {
[10:30:49.538]                   {
[10:30:49.538]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.538]                     NULL
[10:30:49.538]                   }
[10:30:49.538]                   options(future.plan = NULL)
[10:30:49.538]                   if (is.na(NA_character_)) 
[10:30:49.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.538]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.538]                     .init = FALSE)
[10:30:49.538]                 }
[10:30:49.538]             }
[10:30:49.538]         }
[10:30:49.538]     })
[10:30:49.538]     if (TRUE) {
[10:30:49.538]         base::sink(type = "output", split = FALSE)
[10:30:49.538]         if (TRUE) {
[10:30:49.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.538]         }
[10:30:49.538]         else {
[10:30:49.538]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.538]         }
[10:30:49.538]         base::close(...future.stdout)
[10:30:49.538]         ...future.stdout <- NULL
[10:30:49.538]     }
[10:30:49.538]     ...future.result$conditions <- ...future.conditions
[10:30:49.538]     ...future.result$finished <- base::Sys.time()
[10:30:49.538]     ...future.result
[10:30:49.538] }
[10:30:49.541] assign_globals() ...
[10:30:49.541] List of 5
[10:30:49.541]  $ ...future.FUN            :function (x, y)  
[10:30:49.541]  $ MoreArgs                 : NULL
[10:30:49.541]  $ ...future.elements_ii    :List of 2
[10:30:49.541]   ..$ :List of 2
[10:30:49.541]   .. ..$ b: num 2
[10:30:49.541]   .. ..$ c: num 3
[10:30:49.541]   ..$ :List of 2
[10:30:49.541]   .. ..$ B: num 0
[10:30:49.541]   .. ..$ C: num -10
[10:30:49.541]  $ ...future.seeds_ii       : NULL
[10:30:49.541]  $ ...future.globals.maxSize: NULL
[10:30:49.541]  - attr(*, "where")=List of 5
[10:30:49.541]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.541]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.541]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.541]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.541]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.541]  - attr(*, "resolved")= logi FALSE
[10:30:49.541]  - attr(*, "total_size")= num 2200
[10:30:49.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.541]  - attr(*, "already-done")= logi TRUE
[10:30:49.549] - reassign environment for ‘...future.FUN’
[10:30:49.549] - copied ‘...future.FUN’ to environment
[10:30:49.549] - copied ‘MoreArgs’ to environment
[10:30:49.549] - copied ‘...future.elements_ii’ to environment
[10:30:49.549] - copied ‘...future.seeds_ii’ to environment
[10:30:49.550] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.550] assign_globals() ... done
[10:30:49.550] requestCore(): workers = 2
[10:30:49.552] MulticoreFuture started
[10:30:49.553] - Launch lazy future ... done
[10:30:49.553] run() for ‘MulticoreFuture’ ... done
[10:30:49.553] Created future:
[10:30:49.554] plan(): Setting new future strategy stack:
[10:30:49.554] List of future strategies:
[10:30:49.554] 1. sequential:
[10:30:49.554]    - args: function (..., envir = parent.frame())
[10:30:49.554]    - tweaked: FALSE
[10:30:49.554]    - call: NULL
[10:30:49.555] plan(): nbrOfWorkers() = 1
[10:30:49.557] plan(): Setting new future strategy stack:
[10:30:49.557] List of future strategies:
[10:30:49.557] 1. multicore:
[10:30:49.557]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.557]    - tweaked: FALSE
[10:30:49.557]    - call: plan(strategy)
[10:30:49.563] plan(): nbrOfWorkers() = 2
[10:30:49.553] MulticoreFuture:
[10:30:49.553] Label: ‘future_mapply-2’
[10:30:49.553] Expression:
[10:30:49.553] {
[10:30:49.553]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.553]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.553]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.553]         on.exit(options(oopts), add = TRUE)
[10:30:49.553]     }
[10:30:49.553]     {
[10:30:49.553]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.553]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.553]         do.call(mapply, args = args)
[10:30:49.553]     }
[10:30:49.553] }
[10:30:49.553] Lazy evaluation: FALSE
[10:30:49.553] Asynchronous evaluation: TRUE
[10:30:49.553] Local evaluation: TRUE
[10:30:49.553] Environment: R_GlobalEnv
[10:30:49.553] Capture standard output: TRUE
[10:30:49.553] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.553] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.553] Packages: <none>
[10:30:49.553] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.553] Resolved: TRUE
[10:30:49.553] Value: <not collected>
[10:30:49.553] Conditions captured: <none>
[10:30:49.553] Early signaling: FALSE
[10:30:49.553] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.553] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.564] Chunk #2 of 2 ... DONE
[10:30:49.564] Launching 2 futures (chunks) ... DONE
[10:30:49.564] Resolving 2 futures (chunks) ...
[10:30:49.564] resolve() on list ...
[10:30:49.564]  recursive: 0
[10:30:49.565]  length: 2
[10:30:49.565] 
[10:30:49.565] Future #1
[10:30:49.565] result() for MulticoreFuture ...
[10:30:49.566] result() for MulticoreFuture ...
[10:30:49.567] result() for MulticoreFuture ... done
[10:30:49.567] result() for MulticoreFuture ... done
[10:30:49.567] result() for MulticoreFuture ...
[10:30:49.567] result() for MulticoreFuture ... done
[10:30:49.567] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:49.568] - nx: 2
[10:30:49.568] - relay: TRUE
[10:30:49.568] - stdout: TRUE
[10:30:49.568] - signal: TRUE
[10:30:49.568] - resignal: FALSE
[10:30:49.569] - force: TRUE
[10:30:49.569] - relayed: [n=2] FALSE, FALSE
[10:30:49.569] - queued futures: [n=2] FALSE, FALSE
[10:30:49.569]  - until=1
[10:30:49.569]  - relaying element #1
[10:30:49.569] result() for MulticoreFuture ...
[10:30:49.570] result() for MulticoreFuture ... done
[10:30:49.570] result() for MulticoreFuture ...
[10:30:49.570] result() for MulticoreFuture ... done
[10:30:49.570] result() for MulticoreFuture ...
[10:30:49.571] result() for MulticoreFuture ... done
[10:30:49.571] result() for MulticoreFuture ...
[10:30:49.571] result() for MulticoreFuture ... done
[10:30:49.571] - relayed: [n=2] TRUE, FALSE
[10:30:49.571] - queued futures: [n=2] TRUE, FALSE
[10:30:49.571] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:49.572]  length: 1 (resolved future 1)
[10:30:49.572] Future #2
[10:30:49.572] result() for MulticoreFuture ...
[10:30:49.577] result() for MulticoreFuture ...
[10:30:49.577] result() for MulticoreFuture ... done
[10:30:49.578] result() for MulticoreFuture ... done
[10:30:49.578] result() for MulticoreFuture ...
[10:30:49.578] result() for MulticoreFuture ... done
[10:30:49.579] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:49.579] - nx: 2
[10:30:49.579] - relay: TRUE
[10:30:49.579] - stdout: TRUE
[10:30:49.579] - signal: TRUE
[10:30:49.580] - resignal: FALSE
[10:30:49.580] - force: TRUE
[10:30:49.580] - relayed: [n=2] TRUE, FALSE
[10:30:49.580] - queued futures: [n=2] TRUE, FALSE
[10:30:49.580]  - until=2
[10:30:49.580]  - relaying element #2
[10:30:49.581] result() for MulticoreFuture ...
[10:30:49.581] result() for MulticoreFuture ... done
[10:30:49.581] result() for MulticoreFuture ...
[10:30:49.581] result() for MulticoreFuture ... done
[10:30:49.581] result() for MulticoreFuture ...
[10:30:49.582] result() for MulticoreFuture ... done
[10:30:49.582] result() for MulticoreFuture ...
[10:30:49.582] result() for MulticoreFuture ... done
[10:30:49.582] - relayed: [n=2] TRUE, TRUE
[10:30:49.582] - queued futures: [n=2] TRUE, TRUE
[10:30:49.582] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:49.582]  length: 0 (resolved future 2)
[10:30:49.583] Relaying remaining futures
[10:30:49.583] signalConditionsASAP(NULL, pos=0) ...
[10:30:49.583] - nx: 2
[10:30:49.583] - relay: TRUE
[10:30:49.583] - stdout: TRUE
[10:30:49.583] - signal: TRUE
[10:30:49.583] - resignal: FALSE
[10:30:49.583] - force: TRUE
[10:30:49.583] - relayed: [n=2] TRUE, TRUE
[10:30:49.584] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:49.584] - relayed: [n=2] TRUE, TRUE
[10:30:49.584] - queued futures: [n=2] TRUE, TRUE
[10:30:49.584] signalConditionsASAP(NULL, pos=0) ... done
[10:30:49.584] resolve() on list ... DONE
[10:30:49.584] result() for MulticoreFuture ...
[10:30:49.584] result() for MulticoreFuture ... done
[10:30:49.584] result() for MulticoreFuture ...
[10:30:49.584] result() for MulticoreFuture ... done
[10:30:49.585] result() for MulticoreFuture ...
[10:30:49.585] result() for MulticoreFuture ... done
[10:30:49.585] result() for MulticoreFuture ...
[10:30:49.585] result() for MulticoreFuture ... done
[10:30:49.585]  - Number of value chunks collected: 2
[10:30:49.585] Resolving 2 futures (chunks) ... DONE
[10:30:49.586] Reducing values from 2 chunks ...
[10:30:49.586]  - Number of values collected after concatenation: 3
[10:30:49.586]  - Number of values expected: 3
[10:30:49.586] Reducing values from 2 chunks ... DONE
[10:30:49.586] future_mapply() ... DONE
- future_.mapply()
[10:30:49.586] future_mapply() ...
[10:30:49.591] Number of chunks: 2
[10:30:49.591] getGlobalsAndPackagesXApply() ...
[10:30:49.591]  - future.globals: TRUE
[10:30:49.591] getGlobalsAndPackages() ...
[10:30:49.591] Searching for globals...
[10:30:49.593] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:30:49.593] Searching for globals ... DONE
[10:30:49.593] Resolving globals: FALSE
[10:30:49.594] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[10:30:49.594] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[10:30:49.594] - globals: [1] ‘FUN’
[10:30:49.594] 
[10:30:49.595] getGlobalsAndPackages() ... DONE
[10:30:49.595]  - globals found/used: [n=1] ‘FUN’
[10:30:49.595]  - needed namespaces: [n=0] 
[10:30:49.595] Finding globals ... DONE
[10:30:49.595] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:49.595] List of 2
[10:30:49.595]  $ ...future.FUN:function (x, y)  
[10:30:49.595]  $ MoreArgs     : list()
[10:30:49.595]  - attr(*, "where")=List of 2
[10:30:49.595]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:49.595]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:49.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.595]  - attr(*, "resolved")= logi FALSE
[10:30:49.595]  - attr(*, "total_size")= num NA
[10:30:49.598] Packages to be attached in all futures: [n=0] 
[10:30:49.598] getGlobalsAndPackagesXApply() ... DONE
[10:30:49.599] Number of futures (= number of chunks): 2
[10:30:49.599] Launching 2 futures (chunks) ...
[10:30:49.599] Chunk #1 of 2 ...
[10:30:49.599]  - Finding globals in '...' for chunk #1 ...
[10:30:49.599] getGlobalsAndPackages() ...
[10:30:49.599] Searching for globals...
[10:30:49.599] 
[10:30:49.600] Searching for globals ... DONE
[10:30:49.600] - globals: [0] <none>
[10:30:49.600] getGlobalsAndPackages() ... DONE
[10:30:49.600]    + additional globals found: [n=0] 
[10:30:49.600]    + additional namespaces needed: [n=0] 
[10:30:49.600]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:49.600]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.600]  - seeds: <none>
[10:30:49.600]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.600] getGlobalsAndPackages() ...
[10:30:49.601] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.601] Resolving globals: FALSE
[10:30:49.601] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[10:30:49.602] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:49.602] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.602] 
[10:30:49.602] getGlobalsAndPackages() ... DONE
[10:30:49.602] run() for ‘Future’ ...
[10:30:49.602] - state: ‘created’
[10:30:49.603] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.609] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.609]   - Field: ‘label’
[10:30:49.609]   - Field: ‘local’
[10:30:49.609]   - Field: ‘owner’
[10:30:49.609]   - Field: ‘envir’
[10:30:49.610]   - Field: ‘workers’
[10:30:49.610]   - Field: ‘packages’
[10:30:49.610]   - Field: ‘gc’
[10:30:49.610]   - Field: ‘job’
[10:30:49.610]   - Field: ‘conditions’
[10:30:49.610]   - Field: ‘expr’
[10:30:49.610]   - Field: ‘uuid’
[10:30:49.610]   - Field: ‘seed’
[10:30:49.611]   - Field: ‘version’
[10:30:49.611]   - Field: ‘result’
[10:30:49.611]   - Field: ‘asynchronous’
[10:30:49.611]   - Field: ‘calls’
[10:30:49.611]   - Field: ‘globals’
[10:30:49.611]   - Field: ‘stdout’
[10:30:49.611]   - Field: ‘earlySignal’
[10:30:49.611]   - Field: ‘lazy’
[10:30:49.611]   - Field: ‘state’
[10:30:49.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.612] - Launch lazy future ...
[10:30:49.612] Packages needed by the future expression (n = 0): <none>
[10:30:49.612] Packages needed by future strategies (n = 0): <none>
[10:30:49.613] {
[10:30:49.613]     {
[10:30:49.613]         {
[10:30:49.613]             ...future.startTime <- base::Sys.time()
[10:30:49.613]             {
[10:30:49.613]                 {
[10:30:49.613]                   {
[10:30:49.613]                     {
[10:30:49.613]                       base::local({
[10:30:49.613]                         has_future <- base::requireNamespace("future", 
[10:30:49.613]                           quietly = TRUE)
[10:30:49.613]                         if (has_future) {
[10:30:49.613]                           ns <- base::getNamespace("future")
[10:30:49.613]                           version <- ns[[".package"]][["version"]]
[10:30:49.613]                           if (is.null(version)) 
[10:30:49.613]                             version <- utils::packageVersion("future")
[10:30:49.613]                         }
[10:30:49.613]                         else {
[10:30:49.613]                           version <- NULL
[10:30:49.613]                         }
[10:30:49.613]                         if (!has_future || version < "1.8.0") {
[10:30:49.613]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.613]                             "", base::R.version$version.string), 
[10:30:49.613]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.613]                               "release", "version")], collapse = " "), 
[10:30:49.613]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.613]                             info)
[10:30:49.613]                           info <- base::paste(info, collapse = "; ")
[10:30:49.613]                           if (!has_future) {
[10:30:49.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.613]                               info)
[10:30:49.613]                           }
[10:30:49.613]                           else {
[10:30:49.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.613]                               info, version)
[10:30:49.613]                           }
[10:30:49.613]                           base::stop(msg)
[10:30:49.613]                         }
[10:30:49.613]                       })
[10:30:49.613]                     }
[10:30:49.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.613]                     base::options(mc.cores = 1L)
[10:30:49.613]                   }
[10:30:49.613]                   ...future.strategy.old <- future::plan("list")
[10:30:49.613]                   options(future.plan = NULL)
[10:30:49.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.613]                 }
[10:30:49.613]                 ...future.workdir <- getwd()
[10:30:49.613]             }
[10:30:49.613]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.613]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.613]         }
[10:30:49.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.613]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.613]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.613]             base::names(...future.oldOptions))
[10:30:49.613]     }
[10:30:49.613]     if (FALSE) {
[10:30:49.613]     }
[10:30:49.613]     else {
[10:30:49.613]         if (TRUE) {
[10:30:49.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.613]                 open = "w")
[10:30:49.613]         }
[10:30:49.613]         else {
[10:30:49.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.613]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.613]         }
[10:30:49.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.613]             base::sink(type = "output", split = FALSE)
[10:30:49.613]             base::close(...future.stdout)
[10:30:49.613]         }, add = TRUE)
[10:30:49.613]     }
[10:30:49.613]     ...future.frame <- base::sys.nframe()
[10:30:49.613]     ...future.conditions <- base::list()
[10:30:49.613]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.613]     if (FALSE) {
[10:30:49.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.613]     }
[10:30:49.613]     ...future.result <- base::tryCatch({
[10:30:49.613]         base::withCallingHandlers({
[10:30:49.613]             ...future.value <- base::withVisible(base::local({
[10:30:49.613]                 withCallingHandlers({
[10:30:49.613]                   {
[10:30:49.613]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.613]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.613]                       ...future.globals.maxSize)) {
[10:30:49.613]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.613]                       on.exit(options(oopts), add = TRUE)
[10:30:49.613]                     }
[10:30:49.613]                     {
[10:30:49.613]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.613]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.613]                         USE.NAMES = FALSE)
[10:30:49.613]                       do.call(mapply, args = args)
[10:30:49.613]                     }
[10:30:49.613]                   }
[10:30:49.613]                 }, immediateCondition = function(cond) {
[10:30:49.613]                   save_rds <- function (object, pathname, ...) 
[10:30:49.613]                   {
[10:30:49.613]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.613]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.613]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.613]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.613]                         fi_tmp[["mtime"]])
[10:30:49.613]                     }
[10:30:49.613]                     tryCatch({
[10:30:49.613]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.613]                     }, error = function(ex) {
[10:30:49.613]                       msg <- conditionMessage(ex)
[10:30:49.613]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.613]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.613]                         fi_tmp[["mtime"]], msg)
[10:30:49.613]                       ex$message <- msg
[10:30:49.613]                       stop(ex)
[10:30:49.613]                     })
[10:30:49.613]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.613]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.613]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.613]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.613]                       fi <- file.info(pathname)
[10:30:49.613]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.613]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.613]                         fi[["size"]], fi[["mtime"]])
[10:30:49.613]                       stop(msg)
[10:30:49.613]                     }
[10:30:49.613]                     invisible(pathname)
[10:30:49.613]                   }
[10:30:49.613]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.613]                     rootPath = tempdir()) 
[10:30:49.613]                   {
[10:30:49.613]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.613]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.613]                       tmpdir = path, fileext = ".rds")
[10:30:49.613]                     save_rds(obj, file)
[10:30:49.613]                   }
[10:30:49.613]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.613]                   {
[10:30:49.613]                     inherits <- base::inherits
[10:30:49.613]                     invokeRestart <- base::invokeRestart
[10:30:49.613]                     is.null <- base::is.null
[10:30:49.613]                     muffled <- FALSE
[10:30:49.613]                     if (inherits(cond, "message")) {
[10:30:49.613]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.613]                       if (muffled) 
[10:30:49.613]                         invokeRestart("muffleMessage")
[10:30:49.613]                     }
[10:30:49.613]                     else if (inherits(cond, "warning")) {
[10:30:49.613]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.613]                       if (muffled) 
[10:30:49.613]                         invokeRestart("muffleWarning")
[10:30:49.613]                     }
[10:30:49.613]                     else if (inherits(cond, "condition")) {
[10:30:49.613]                       if (!is.null(pattern)) {
[10:30:49.613]                         computeRestarts <- base::computeRestarts
[10:30:49.613]                         grepl <- base::grepl
[10:30:49.613]                         restarts <- computeRestarts(cond)
[10:30:49.613]                         for (restart in restarts) {
[10:30:49.613]                           name <- restart$name
[10:30:49.613]                           if (is.null(name)) 
[10:30:49.613]                             next
[10:30:49.613]                           if (!grepl(pattern, name)) 
[10:30:49.613]                             next
[10:30:49.613]                           invokeRestart(restart)
[10:30:49.613]                           muffled <- TRUE
[10:30:49.613]                           break
[10:30:49.613]                         }
[10:30:49.613]                       }
[10:30:49.613]                     }
[10:30:49.613]                     invisible(muffled)
[10:30:49.613]                   }
[10:30:49.613]                   muffleCondition(cond)
[10:30:49.613]                 })
[10:30:49.613]             }))
[10:30:49.613]             future::FutureResult(value = ...future.value$value, 
[10:30:49.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.613]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.613]                     ...future.globalenv.names))
[10:30:49.613]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.613]         }, condition = base::local({
[10:30:49.613]             c <- base::c
[10:30:49.613]             inherits <- base::inherits
[10:30:49.613]             invokeRestart <- base::invokeRestart
[10:30:49.613]             length <- base::length
[10:30:49.613]             list <- base::list
[10:30:49.613]             seq.int <- base::seq.int
[10:30:49.613]             signalCondition <- base::signalCondition
[10:30:49.613]             sys.calls <- base::sys.calls
[10:30:49.613]             `[[` <- base::`[[`
[10:30:49.613]             `+` <- base::`+`
[10:30:49.613]             `<<-` <- base::`<<-`
[10:30:49.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.613]                   3L)]
[10:30:49.613]             }
[10:30:49.613]             function(cond) {
[10:30:49.613]                 is_error <- inherits(cond, "error")
[10:30:49.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.613]                   NULL)
[10:30:49.613]                 if (is_error) {
[10:30:49.613]                   sessionInformation <- function() {
[10:30:49.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.613]                       search = base::search(), system = base::Sys.info())
[10:30:49.613]                   }
[10:30:49.613]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.613]                     cond$call), session = sessionInformation(), 
[10:30:49.613]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.613]                   signalCondition(cond)
[10:30:49.613]                 }
[10:30:49.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.613]                 "immediateCondition"))) {
[10:30:49.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.613]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.613]                   if (TRUE && !signal) {
[10:30:49.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.613]                     {
[10:30:49.613]                       inherits <- base::inherits
[10:30:49.613]                       invokeRestart <- base::invokeRestart
[10:30:49.613]                       is.null <- base::is.null
[10:30:49.613]                       muffled <- FALSE
[10:30:49.613]                       if (inherits(cond, "message")) {
[10:30:49.613]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.613]                         if (muffled) 
[10:30:49.613]                           invokeRestart("muffleMessage")
[10:30:49.613]                       }
[10:30:49.613]                       else if (inherits(cond, "warning")) {
[10:30:49.613]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.613]                         if (muffled) 
[10:30:49.613]                           invokeRestart("muffleWarning")
[10:30:49.613]                       }
[10:30:49.613]                       else if (inherits(cond, "condition")) {
[10:30:49.613]                         if (!is.null(pattern)) {
[10:30:49.613]                           computeRestarts <- base::computeRestarts
[10:30:49.613]                           grepl <- base::grepl
[10:30:49.613]                           restarts <- computeRestarts(cond)
[10:30:49.613]                           for (restart in restarts) {
[10:30:49.613]                             name <- restart$name
[10:30:49.613]                             if (is.null(name)) 
[10:30:49.613]                               next
[10:30:49.613]                             if (!grepl(pattern, name)) 
[10:30:49.613]                               next
[10:30:49.613]                             invokeRestart(restart)
[10:30:49.613]                             muffled <- TRUE
[10:30:49.613]                             break
[10:30:49.613]                           }
[10:30:49.613]                         }
[10:30:49.613]                       }
[10:30:49.613]                       invisible(muffled)
[10:30:49.613]                     }
[10:30:49.613]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.613]                   }
[10:30:49.613]                 }
[10:30:49.613]                 else {
[10:30:49.613]                   if (TRUE) {
[10:30:49.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.613]                     {
[10:30:49.613]                       inherits <- base::inherits
[10:30:49.613]                       invokeRestart <- base::invokeRestart
[10:30:49.613]                       is.null <- base::is.null
[10:30:49.613]                       muffled <- FALSE
[10:30:49.613]                       if (inherits(cond, "message")) {
[10:30:49.613]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.613]                         if (muffled) 
[10:30:49.613]                           invokeRestart("muffleMessage")
[10:30:49.613]                       }
[10:30:49.613]                       else if (inherits(cond, "warning")) {
[10:30:49.613]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.613]                         if (muffled) 
[10:30:49.613]                           invokeRestart("muffleWarning")
[10:30:49.613]                       }
[10:30:49.613]                       else if (inherits(cond, "condition")) {
[10:30:49.613]                         if (!is.null(pattern)) {
[10:30:49.613]                           computeRestarts <- base::computeRestarts
[10:30:49.613]                           grepl <- base::grepl
[10:30:49.613]                           restarts <- computeRestarts(cond)
[10:30:49.613]                           for (restart in restarts) {
[10:30:49.613]                             name <- restart$name
[10:30:49.613]                             if (is.null(name)) 
[10:30:49.613]                               next
[10:30:49.613]                             if (!grepl(pattern, name)) 
[10:30:49.613]                               next
[10:30:49.613]                             invokeRestart(restart)
[10:30:49.613]                             muffled <- TRUE
[10:30:49.613]                             break
[10:30:49.613]                           }
[10:30:49.613]                         }
[10:30:49.613]                       }
[10:30:49.613]                       invisible(muffled)
[10:30:49.613]                     }
[10:30:49.613]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.613]                   }
[10:30:49.613]                 }
[10:30:49.613]             }
[10:30:49.613]         }))
[10:30:49.613]     }, error = function(ex) {
[10:30:49.613]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.613]                 ...future.rng), started = ...future.startTime, 
[10:30:49.613]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.613]             version = "1.8"), class = "FutureResult")
[10:30:49.613]     }, finally = {
[10:30:49.613]         if (!identical(...future.workdir, getwd())) 
[10:30:49.613]             setwd(...future.workdir)
[10:30:49.613]         {
[10:30:49.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.613]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.613]             }
[10:30:49.613]             base::options(...future.oldOptions)
[10:30:49.613]             if (.Platform$OS.type == "windows") {
[10:30:49.613]                 old_names <- names(...future.oldEnvVars)
[10:30:49.613]                 envs <- base::Sys.getenv()
[10:30:49.613]                 names <- names(envs)
[10:30:49.613]                 common <- intersect(names, old_names)
[10:30:49.613]                 added <- setdiff(names, old_names)
[10:30:49.613]                 removed <- setdiff(old_names, names)
[10:30:49.613]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.613]                   envs[common]]
[10:30:49.613]                 NAMES <- toupper(changed)
[10:30:49.613]                 args <- list()
[10:30:49.613]                 for (kk in seq_along(NAMES)) {
[10:30:49.613]                   name <- changed[[kk]]
[10:30:49.613]                   NAME <- NAMES[[kk]]
[10:30:49.613]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.613]                     next
[10:30:49.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.613]                 }
[10:30:49.613]                 NAMES <- toupper(added)
[10:30:49.613]                 for (kk in seq_along(NAMES)) {
[10:30:49.613]                   name <- added[[kk]]
[10:30:49.613]                   NAME <- NAMES[[kk]]
[10:30:49.613]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.613]                     next
[10:30:49.613]                   args[[name]] <- ""
[10:30:49.613]                 }
[10:30:49.613]                 NAMES <- toupper(removed)
[10:30:49.613]                 for (kk in seq_along(NAMES)) {
[10:30:49.613]                   name <- removed[[kk]]
[10:30:49.613]                   NAME <- NAMES[[kk]]
[10:30:49.613]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.613]                     next
[10:30:49.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.613]                 }
[10:30:49.613]                 if (length(args) > 0) 
[10:30:49.613]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.613]             }
[10:30:49.613]             else {
[10:30:49.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.613]             }
[10:30:49.613]             {
[10:30:49.613]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.613]                   0L) {
[10:30:49.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.613]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.613]                   base::options(opts)
[10:30:49.613]                 }
[10:30:49.613]                 {
[10:30:49.613]                   {
[10:30:49.613]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.613]                     NULL
[10:30:49.613]                   }
[10:30:49.613]                   options(future.plan = NULL)
[10:30:49.613]                   if (is.na(NA_character_)) 
[10:30:49.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.613]                     .init = FALSE)
[10:30:49.613]                 }
[10:30:49.613]             }
[10:30:49.613]         }
[10:30:49.613]     })
[10:30:49.613]     if (TRUE) {
[10:30:49.613]         base::sink(type = "output", split = FALSE)
[10:30:49.613]         if (TRUE) {
[10:30:49.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.613]         }
[10:30:49.613]         else {
[10:30:49.613]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.613]         }
[10:30:49.613]         base::close(...future.stdout)
[10:30:49.613]         ...future.stdout <- NULL
[10:30:49.613]     }
[10:30:49.613]     ...future.result$conditions <- ...future.conditions
[10:30:49.613]     ...future.result$finished <- base::Sys.time()
[10:30:49.613]     ...future.result
[10:30:49.613] }
[10:30:49.615] assign_globals() ...
[10:30:49.615] List of 5
[10:30:49.615]  $ ...future.FUN            :function (x, y)  
[10:30:49.615]  $ MoreArgs                 : list()
[10:30:49.615]  $ ...future.elements_ii    :List of 2
[10:30:49.615]   ..$ :List of 1
[10:30:49.615]   .. ..$ a: num 1
[10:30:49.615]   ..$ :List of 1
[10:30:49.615]   .. ..$ A: num 10
[10:30:49.615]  $ ...future.seeds_ii       : NULL
[10:30:49.615]  $ ...future.globals.maxSize: NULL
[10:30:49.615]  - attr(*, "where")=List of 5
[10:30:49.615]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.615]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.615]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.615]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.615]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.615]  - attr(*, "resolved")= logi FALSE
[10:30:49.615]  - attr(*, "total_size")= num 2088
[10:30:49.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.615]  - attr(*, "already-done")= logi TRUE
[10:30:49.620] - reassign environment for ‘...future.FUN’
[10:30:49.620] - copied ‘...future.FUN’ to environment
[10:30:49.620] - copied ‘MoreArgs’ to environment
[10:30:49.621] - copied ‘...future.elements_ii’ to environment
[10:30:49.621] - copied ‘...future.seeds_ii’ to environment
[10:30:49.621] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.621] assign_globals() ... done
[10:30:49.621] requestCore(): workers = 2
[10:30:49.623] MulticoreFuture started
[10:30:49.624] - Launch lazy future ... done
[10:30:49.624] run() for ‘MulticoreFuture’ ... done
[10:30:49.624] Created future:
[10:30:49.624] plan(): Setting new future strategy stack:
[10:30:49.625] List of future strategies:
[10:30:49.625] 1. sequential:
[10:30:49.625]    - args: function (..., envir = parent.frame())
[10:30:49.625]    - tweaked: FALSE
[10:30:49.625]    - call: NULL
[10:30:49.626] plan(): nbrOfWorkers() = 1
[10:30:49.628] plan(): Setting new future strategy stack:
[10:30:49.628] List of future strategies:
[10:30:49.628] 1. multicore:
[10:30:49.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.628]    - tweaked: FALSE
[10:30:49.628]    - call: plan(strategy)
[10:30:49.633] plan(): nbrOfWorkers() = 2
[10:30:49.624] MulticoreFuture:
[10:30:49.624] Label: ‘future_.mapply-1’
[10:30:49.624] Expression:
[10:30:49.624] {
[10:30:49.624]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.624]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.624]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.624]         on.exit(options(oopts), add = TRUE)
[10:30:49.624]     }
[10:30:49.624]     {
[10:30:49.624]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.624]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.624]         do.call(mapply, args = args)
[10:30:49.624]     }
[10:30:49.624] }
[10:30:49.624] Lazy evaluation: FALSE
[10:30:49.624] Asynchronous evaluation: TRUE
[10:30:49.624] Local evaluation: TRUE
[10:30:49.624] Environment: R_GlobalEnv
[10:30:49.624] Capture standard output: TRUE
[10:30:49.624] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.624] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.624] Packages: <none>
[10:30:49.624] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.624] Resolved: TRUE
[10:30:49.624] Value: <not collected>
[10:30:49.624] Conditions captured: <none>
[10:30:49.624] Early signaling: FALSE
[10:30:49.624] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.624] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.634] Chunk #1 of 2 ... DONE
[10:30:49.634] Chunk #2 of 2 ...
[10:30:49.634]  - Finding globals in '...' for chunk #2 ...
[10:30:49.635] getGlobalsAndPackages() ...
[10:30:49.635] Searching for globals...
[10:30:49.635] 
[10:30:49.635] Searching for globals ... DONE
[10:30:49.636] - globals: [0] <none>
[10:30:49.636] getGlobalsAndPackages() ... DONE
[10:30:49.636]    + additional globals found: [n=0] 
[10:30:49.636]    + additional namespaces needed: [n=0] 
[10:30:49.636]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:49.636]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:49.636]  - seeds: <none>
[10:30:49.637]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.637] getGlobalsAndPackages() ...
[10:30:49.637] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.637] Resolving globals: FALSE
[10:30:49.638] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[10:30:49.639] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:49.639] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.639] 
[10:30:49.639] getGlobalsAndPackages() ... DONE
[10:30:49.640] run() for ‘Future’ ...
[10:30:49.640] - state: ‘created’
[10:30:49.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.645] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.645] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.646]   - Field: ‘label’
[10:30:49.646]   - Field: ‘local’
[10:30:49.646]   - Field: ‘owner’
[10:30:49.646]   - Field: ‘envir’
[10:30:49.646]   - Field: ‘workers’
[10:30:49.646]   - Field: ‘packages’
[10:30:49.647]   - Field: ‘gc’
[10:30:49.647]   - Field: ‘job’
[10:30:49.647]   - Field: ‘conditions’
[10:30:49.647]   - Field: ‘expr’
[10:30:49.647]   - Field: ‘uuid’
[10:30:49.651]   - Field: ‘seed’
[10:30:49.651]   - Field: ‘version’
[10:30:49.651]   - Field: ‘result’
[10:30:49.652]   - Field: ‘asynchronous’
[10:30:49.652]   - Field: ‘calls’
[10:30:49.652]   - Field: ‘globals’
[10:30:49.653]   - Field: ‘stdout’
[10:30:49.653]   - Field: ‘earlySignal’
[10:30:49.653]   - Field: ‘lazy’
[10:30:49.654]   - Field: ‘state’
[10:30:49.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.654] - Launch lazy future ...
[10:30:49.655] Packages needed by the future expression (n = 0): <none>
[10:30:49.655] Packages needed by future strategies (n = 0): <none>
[10:30:49.656] {
[10:30:49.656]     {
[10:30:49.656]         {
[10:30:49.656]             ...future.startTime <- base::Sys.time()
[10:30:49.656]             {
[10:30:49.656]                 {
[10:30:49.656]                   {
[10:30:49.656]                     {
[10:30:49.656]                       base::local({
[10:30:49.656]                         has_future <- base::requireNamespace("future", 
[10:30:49.656]                           quietly = TRUE)
[10:30:49.656]                         if (has_future) {
[10:30:49.656]                           ns <- base::getNamespace("future")
[10:30:49.656]                           version <- ns[[".package"]][["version"]]
[10:30:49.656]                           if (is.null(version)) 
[10:30:49.656]                             version <- utils::packageVersion("future")
[10:30:49.656]                         }
[10:30:49.656]                         else {
[10:30:49.656]                           version <- NULL
[10:30:49.656]                         }
[10:30:49.656]                         if (!has_future || version < "1.8.0") {
[10:30:49.656]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.656]                             "", base::R.version$version.string), 
[10:30:49.656]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.656]                               "release", "version")], collapse = " "), 
[10:30:49.656]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.656]                             info)
[10:30:49.656]                           info <- base::paste(info, collapse = "; ")
[10:30:49.656]                           if (!has_future) {
[10:30:49.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.656]                               info)
[10:30:49.656]                           }
[10:30:49.656]                           else {
[10:30:49.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.656]                               info, version)
[10:30:49.656]                           }
[10:30:49.656]                           base::stop(msg)
[10:30:49.656]                         }
[10:30:49.656]                       })
[10:30:49.656]                     }
[10:30:49.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.656]                     base::options(mc.cores = 1L)
[10:30:49.656]                   }
[10:30:49.656]                   ...future.strategy.old <- future::plan("list")
[10:30:49.656]                   options(future.plan = NULL)
[10:30:49.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.656]                 }
[10:30:49.656]                 ...future.workdir <- getwd()
[10:30:49.656]             }
[10:30:49.656]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.656]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.656]         }
[10:30:49.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.656]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:49.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.656]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.656]             base::names(...future.oldOptions))
[10:30:49.656]     }
[10:30:49.656]     if (FALSE) {
[10:30:49.656]     }
[10:30:49.656]     else {
[10:30:49.656]         if (TRUE) {
[10:30:49.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.656]                 open = "w")
[10:30:49.656]         }
[10:30:49.656]         else {
[10:30:49.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.656]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.656]         }
[10:30:49.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.656]             base::sink(type = "output", split = FALSE)
[10:30:49.656]             base::close(...future.stdout)
[10:30:49.656]         }, add = TRUE)
[10:30:49.656]     }
[10:30:49.656]     ...future.frame <- base::sys.nframe()
[10:30:49.656]     ...future.conditions <- base::list()
[10:30:49.656]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.656]     if (FALSE) {
[10:30:49.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.656]     }
[10:30:49.656]     ...future.result <- base::tryCatch({
[10:30:49.656]         base::withCallingHandlers({
[10:30:49.656]             ...future.value <- base::withVisible(base::local({
[10:30:49.656]                 withCallingHandlers({
[10:30:49.656]                   {
[10:30:49.656]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.656]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.656]                       ...future.globals.maxSize)) {
[10:30:49.656]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.656]                       on.exit(options(oopts), add = TRUE)
[10:30:49.656]                     }
[10:30:49.656]                     {
[10:30:49.656]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.656]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.656]                         USE.NAMES = FALSE)
[10:30:49.656]                       do.call(mapply, args = args)
[10:30:49.656]                     }
[10:30:49.656]                   }
[10:30:49.656]                 }, immediateCondition = function(cond) {
[10:30:49.656]                   save_rds <- function (object, pathname, ...) 
[10:30:49.656]                   {
[10:30:49.656]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.656]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.656]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.656]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.656]                         fi_tmp[["mtime"]])
[10:30:49.656]                     }
[10:30:49.656]                     tryCatch({
[10:30:49.656]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.656]                     }, error = function(ex) {
[10:30:49.656]                       msg <- conditionMessage(ex)
[10:30:49.656]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.656]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.656]                         fi_tmp[["mtime"]], msg)
[10:30:49.656]                       ex$message <- msg
[10:30:49.656]                       stop(ex)
[10:30:49.656]                     })
[10:30:49.656]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.656]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.656]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.656]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.656]                       fi <- file.info(pathname)
[10:30:49.656]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.656]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.656]                         fi[["size"]], fi[["mtime"]])
[10:30:49.656]                       stop(msg)
[10:30:49.656]                     }
[10:30:49.656]                     invisible(pathname)
[10:30:49.656]                   }
[10:30:49.656]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.656]                     rootPath = tempdir()) 
[10:30:49.656]                   {
[10:30:49.656]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.656]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.656]                       tmpdir = path, fileext = ".rds")
[10:30:49.656]                     save_rds(obj, file)
[10:30:49.656]                   }
[10:30:49.656]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.656]                   {
[10:30:49.656]                     inherits <- base::inherits
[10:30:49.656]                     invokeRestart <- base::invokeRestart
[10:30:49.656]                     is.null <- base::is.null
[10:30:49.656]                     muffled <- FALSE
[10:30:49.656]                     if (inherits(cond, "message")) {
[10:30:49.656]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.656]                       if (muffled) 
[10:30:49.656]                         invokeRestart("muffleMessage")
[10:30:49.656]                     }
[10:30:49.656]                     else if (inherits(cond, "warning")) {
[10:30:49.656]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.656]                       if (muffled) 
[10:30:49.656]                         invokeRestart("muffleWarning")
[10:30:49.656]                     }
[10:30:49.656]                     else if (inherits(cond, "condition")) {
[10:30:49.656]                       if (!is.null(pattern)) {
[10:30:49.656]                         computeRestarts <- base::computeRestarts
[10:30:49.656]                         grepl <- base::grepl
[10:30:49.656]                         restarts <- computeRestarts(cond)
[10:30:49.656]                         for (restart in restarts) {
[10:30:49.656]                           name <- restart$name
[10:30:49.656]                           if (is.null(name)) 
[10:30:49.656]                             next
[10:30:49.656]                           if (!grepl(pattern, name)) 
[10:30:49.656]                             next
[10:30:49.656]                           invokeRestart(restart)
[10:30:49.656]                           muffled <- TRUE
[10:30:49.656]                           break
[10:30:49.656]                         }
[10:30:49.656]                       }
[10:30:49.656]                     }
[10:30:49.656]                     invisible(muffled)
[10:30:49.656]                   }
[10:30:49.656]                   muffleCondition(cond)
[10:30:49.656]                 })
[10:30:49.656]             }))
[10:30:49.656]             future::FutureResult(value = ...future.value$value, 
[10:30:49.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.656]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.656]                     ...future.globalenv.names))
[10:30:49.656]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.656]         }, condition = base::local({
[10:30:49.656]             c <- base::c
[10:30:49.656]             inherits <- base::inherits
[10:30:49.656]             invokeRestart <- base::invokeRestart
[10:30:49.656]             length <- base::length
[10:30:49.656]             list <- base::list
[10:30:49.656]             seq.int <- base::seq.int
[10:30:49.656]             signalCondition <- base::signalCondition
[10:30:49.656]             sys.calls <- base::sys.calls
[10:30:49.656]             `[[` <- base::`[[`
[10:30:49.656]             `+` <- base::`+`
[10:30:49.656]             `<<-` <- base::`<<-`
[10:30:49.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.656]                   3L)]
[10:30:49.656]             }
[10:30:49.656]             function(cond) {
[10:30:49.656]                 is_error <- inherits(cond, "error")
[10:30:49.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.656]                   NULL)
[10:30:49.656]                 if (is_error) {
[10:30:49.656]                   sessionInformation <- function() {
[10:30:49.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.656]                       search = base::search(), system = base::Sys.info())
[10:30:49.656]                   }
[10:30:49.656]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.656]                     cond$call), session = sessionInformation(), 
[10:30:49.656]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.656]                   signalCondition(cond)
[10:30:49.656]                 }
[10:30:49.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.656]                 "immediateCondition"))) {
[10:30:49.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.656]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.656]                   if (TRUE && !signal) {
[10:30:49.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.656]                     {
[10:30:49.656]                       inherits <- base::inherits
[10:30:49.656]                       invokeRestart <- base::invokeRestart
[10:30:49.656]                       is.null <- base::is.null
[10:30:49.656]                       muffled <- FALSE
[10:30:49.656]                       if (inherits(cond, "message")) {
[10:30:49.656]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.656]                         if (muffled) 
[10:30:49.656]                           invokeRestart("muffleMessage")
[10:30:49.656]                       }
[10:30:49.656]                       else if (inherits(cond, "warning")) {
[10:30:49.656]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.656]                         if (muffled) 
[10:30:49.656]                           invokeRestart("muffleWarning")
[10:30:49.656]                       }
[10:30:49.656]                       else if (inherits(cond, "condition")) {
[10:30:49.656]                         if (!is.null(pattern)) {
[10:30:49.656]                           computeRestarts <- base::computeRestarts
[10:30:49.656]                           grepl <- base::grepl
[10:30:49.656]                           restarts <- computeRestarts(cond)
[10:30:49.656]                           for (restart in restarts) {
[10:30:49.656]                             name <- restart$name
[10:30:49.656]                             if (is.null(name)) 
[10:30:49.656]                               next
[10:30:49.656]                             if (!grepl(pattern, name)) 
[10:30:49.656]                               next
[10:30:49.656]                             invokeRestart(restart)
[10:30:49.656]                             muffled <- TRUE
[10:30:49.656]                             break
[10:30:49.656]                           }
[10:30:49.656]                         }
[10:30:49.656]                       }
[10:30:49.656]                       invisible(muffled)
[10:30:49.656]                     }
[10:30:49.656]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.656]                   }
[10:30:49.656]                 }
[10:30:49.656]                 else {
[10:30:49.656]                   if (TRUE) {
[10:30:49.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.656]                     {
[10:30:49.656]                       inherits <- base::inherits
[10:30:49.656]                       invokeRestart <- base::invokeRestart
[10:30:49.656]                       is.null <- base::is.null
[10:30:49.656]                       muffled <- FALSE
[10:30:49.656]                       if (inherits(cond, "message")) {
[10:30:49.656]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.656]                         if (muffled) 
[10:30:49.656]                           invokeRestart("muffleMessage")
[10:30:49.656]                       }
[10:30:49.656]                       else if (inherits(cond, "warning")) {
[10:30:49.656]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.656]                         if (muffled) 
[10:30:49.656]                           invokeRestart("muffleWarning")
[10:30:49.656]                       }
[10:30:49.656]                       else if (inherits(cond, "condition")) {
[10:30:49.656]                         if (!is.null(pattern)) {
[10:30:49.656]                           computeRestarts <- base::computeRestarts
[10:30:49.656]                           grepl <- base::grepl
[10:30:49.656]                           restarts <- computeRestarts(cond)
[10:30:49.656]                           for (restart in restarts) {
[10:30:49.656]                             name <- restart$name
[10:30:49.656]                             if (is.null(name)) 
[10:30:49.656]                               next
[10:30:49.656]                             if (!grepl(pattern, name)) 
[10:30:49.656]                               next
[10:30:49.656]                             invokeRestart(restart)
[10:30:49.656]                             muffled <- TRUE
[10:30:49.656]                             break
[10:30:49.656]                           }
[10:30:49.656]                         }
[10:30:49.656]                       }
[10:30:49.656]                       invisible(muffled)
[10:30:49.656]                     }
[10:30:49.656]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.656]                   }
[10:30:49.656]                 }
[10:30:49.656]             }
[10:30:49.656]         }))
[10:30:49.656]     }, error = function(ex) {
[10:30:49.656]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.656]                 ...future.rng), started = ...future.startTime, 
[10:30:49.656]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.656]             version = "1.8"), class = "FutureResult")
[10:30:49.656]     }, finally = {
[10:30:49.656]         if (!identical(...future.workdir, getwd())) 
[10:30:49.656]             setwd(...future.workdir)
[10:30:49.656]         {
[10:30:49.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.656]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.656]             }
[10:30:49.656]             base::options(...future.oldOptions)
[10:30:49.656]             if (.Platform$OS.type == "windows") {
[10:30:49.656]                 old_names <- names(...future.oldEnvVars)
[10:30:49.656]                 envs <- base::Sys.getenv()
[10:30:49.656]                 names <- names(envs)
[10:30:49.656]                 common <- intersect(names, old_names)
[10:30:49.656]                 added <- setdiff(names, old_names)
[10:30:49.656]                 removed <- setdiff(old_names, names)
[10:30:49.656]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.656]                   envs[common]]
[10:30:49.656]                 NAMES <- toupper(changed)
[10:30:49.656]                 args <- list()
[10:30:49.656]                 for (kk in seq_along(NAMES)) {
[10:30:49.656]                   name <- changed[[kk]]
[10:30:49.656]                   NAME <- NAMES[[kk]]
[10:30:49.656]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.656]                     next
[10:30:49.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.656]                 }
[10:30:49.656]                 NAMES <- toupper(added)
[10:30:49.656]                 for (kk in seq_along(NAMES)) {
[10:30:49.656]                   name <- added[[kk]]
[10:30:49.656]                   NAME <- NAMES[[kk]]
[10:30:49.656]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.656]                     next
[10:30:49.656]                   args[[name]] <- ""
[10:30:49.656]                 }
[10:30:49.656]                 NAMES <- toupper(removed)
[10:30:49.656]                 for (kk in seq_along(NAMES)) {
[10:30:49.656]                   name <- removed[[kk]]
[10:30:49.656]                   NAME <- NAMES[[kk]]
[10:30:49.656]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.656]                     next
[10:30:49.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.656]                 }
[10:30:49.656]                 if (length(args) > 0) 
[10:30:49.656]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.656]             }
[10:30:49.656]             else {
[10:30:49.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.656]             }
[10:30:49.656]             {
[10:30:49.656]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.656]                   0L) {
[10:30:49.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.656]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.656]                   base::options(opts)
[10:30:49.656]                 }
[10:30:49.656]                 {
[10:30:49.656]                   {
[10:30:49.656]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.656]                     NULL
[10:30:49.656]                   }
[10:30:49.656]                   options(future.plan = NULL)
[10:30:49.656]                   if (is.na(NA_character_)) 
[10:30:49.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.656]                     .init = FALSE)
[10:30:49.656]                 }
[10:30:49.656]             }
[10:30:49.656]         }
[10:30:49.656]     })
[10:30:49.656]     if (TRUE) {
[10:30:49.656]         base::sink(type = "output", split = FALSE)
[10:30:49.656]         if (TRUE) {
[10:30:49.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.656]         }
[10:30:49.656]         else {
[10:30:49.656]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.656]         }
[10:30:49.656]         base::close(...future.stdout)
[10:30:49.656]         ...future.stdout <- NULL
[10:30:49.656]     }
[10:30:49.656]     ...future.result$conditions <- ...future.conditions
[10:30:49.656]     ...future.result$finished <- base::Sys.time()
[10:30:49.656]     ...future.result
[10:30:49.656] }
[10:30:49.659] assign_globals() ...
[10:30:49.659] List of 5
[10:30:49.659]  $ ...future.FUN            :function (x, y)  
[10:30:49.659]  $ MoreArgs                 : list()
[10:30:49.659]  $ ...future.elements_ii    :List of 2
[10:30:49.659]   ..$ :List of 2
[10:30:49.659]   .. ..$ b: num 2
[10:30:49.659]   .. ..$ c: num 3
[10:30:49.659]   ..$ :List of 2
[10:30:49.659]   .. ..$ B: num 0
[10:30:49.659]   .. ..$ C: num -10
[10:30:49.659]  $ ...future.seeds_ii       : NULL
[10:30:49.659]  $ ...future.globals.maxSize: NULL
[10:30:49.659]  - attr(*, "where")=List of 5
[10:30:49.659]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.659]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.659]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.659]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.659]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.659]  - attr(*, "resolved")= logi FALSE
[10:30:49.659]  - attr(*, "total_size")= num 2200
[10:30:49.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.659]  - attr(*, "already-done")= logi TRUE
[10:30:49.669] - reassign environment for ‘...future.FUN’
[10:30:49.669] - copied ‘...future.FUN’ to environment
[10:30:49.669] - copied ‘MoreArgs’ to environment
[10:30:49.669] - copied ‘...future.elements_ii’ to environment
[10:30:49.669] - copied ‘...future.seeds_ii’ to environment
[10:30:49.670] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.670] assign_globals() ... done
[10:30:49.670] requestCore(): workers = 2
[10:30:49.672] MulticoreFuture started
[10:30:49.673] - Launch lazy future ... done
[10:30:49.673] run() for ‘MulticoreFuture’ ... done
[10:30:49.673] Created future:
[10:30:49.674] plan(): Setting new future strategy stack:
[10:30:49.674] List of future strategies:
[10:30:49.674] 1. sequential:
[10:30:49.674]    - args: function (..., envir = parent.frame())
[10:30:49.674]    - tweaked: FALSE
[10:30:49.674]    - call: NULL
[10:30:49.675] plan(): nbrOfWorkers() = 1
[10:30:49.677] plan(): Setting new future strategy stack:
[10:30:49.677] List of future strategies:
[10:30:49.677] 1. multicore:
[10:30:49.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.677]    - tweaked: FALSE
[10:30:49.677]    - call: plan(strategy)
[10:30:49.683] plan(): nbrOfWorkers() = 2
[10:30:49.674] MulticoreFuture:
[10:30:49.674] Label: ‘future_.mapply-2’
[10:30:49.674] Expression:
[10:30:49.674] {
[10:30:49.674]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.674]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.674]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.674]         on.exit(options(oopts), add = TRUE)
[10:30:49.674]     }
[10:30:49.674]     {
[10:30:49.674]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.674]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.674]         do.call(mapply, args = args)
[10:30:49.674]     }
[10:30:49.674] }
[10:30:49.674] Lazy evaluation: FALSE
[10:30:49.674] Asynchronous evaluation: TRUE
[10:30:49.674] Local evaluation: TRUE
[10:30:49.674] Environment: R_GlobalEnv
[10:30:49.674] Capture standard output: TRUE
[10:30:49.674] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.674] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.674] Packages: <none>
[10:30:49.674] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.674] Resolved: TRUE
[10:30:49.674] Value: <not collected>
[10:30:49.674] Conditions captured: <none>
[10:30:49.674] Early signaling: FALSE
[10:30:49.674] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.674] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.684] Chunk #2 of 2 ... DONE
[10:30:49.684] Launching 2 futures (chunks) ... DONE
[10:30:49.684] Resolving 2 futures (chunks) ...
[10:30:49.684] resolve() on list ...
[10:30:49.684]  recursive: 0
[10:30:49.685]  length: 2
[10:30:49.685] 
[10:30:49.685] Future #1
[10:30:49.685] result() for MulticoreFuture ...
[10:30:49.686] result() for MulticoreFuture ...
[10:30:49.686] result() for MulticoreFuture ... done
[10:30:49.687] result() for MulticoreFuture ... done
[10:30:49.687] result() for MulticoreFuture ...
[10:30:49.687] result() for MulticoreFuture ... done
[10:30:49.687] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:49.687] - nx: 2
[10:30:49.687] - relay: TRUE
[10:30:49.687] - stdout: TRUE
[10:30:49.688] - signal: TRUE
[10:30:49.688] - resignal: FALSE
[10:30:49.688] - force: TRUE
[10:30:49.688] - relayed: [n=2] FALSE, FALSE
[10:30:49.688] - queued futures: [n=2] FALSE, FALSE
[10:30:49.688]  - until=1
[10:30:49.689]  - relaying element #1
[10:30:49.689] result() for MulticoreFuture ...
[10:30:49.689] result() for MulticoreFuture ... done
[10:30:49.689] result() for MulticoreFuture ...
[10:30:49.689] result() for MulticoreFuture ... done
[10:30:49.689] result() for MulticoreFuture ...
[10:30:49.690] result() for MulticoreFuture ... done
[10:30:49.690] result() for MulticoreFuture ...
[10:30:49.690] result() for MulticoreFuture ... done
[10:30:49.690] - relayed: [n=2] TRUE, FALSE
[10:30:49.690] - queued futures: [n=2] TRUE, FALSE
[10:30:49.690] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:49.691]  length: 1 (resolved future 1)
[10:30:49.691] Future #2
[10:30:49.691] result() for MulticoreFuture ...
[10:30:49.692] result() for MulticoreFuture ...
[10:30:49.692] result() for MulticoreFuture ... done
[10:30:49.692] result() for MulticoreFuture ... done
[10:30:49.692] result() for MulticoreFuture ...
[10:30:49.692] result() for MulticoreFuture ... done
[10:30:49.693] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:49.693] - nx: 2
[10:30:49.693] - relay: TRUE
[10:30:49.693] - stdout: TRUE
[10:30:49.693] - signal: TRUE
[10:30:49.693] - resignal: FALSE
[10:30:49.693] - force: TRUE
[10:30:49.693] - relayed: [n=2] TRUE, FALSE
[10:30:49.694] - queued futures: [n=2] TRUE, FALSE
[10:30:49.694]  - until=2
[10:30:49.694]  - relaying element #2
[10:30:49.694] result() for MulticoreFuture ...
[10:30:49.694] result() for MulticoreFuture ... done
[10:30:49.694] result() for MulticoreFuture ...
[10:30:49.694] result() for MulticoreFuture ... done
[10:30:49.694] result() for MulticoreFuture ...
[10:30:49.695] result() for MulticoreFuture ... done
[10:30:49.695] result() for MulticoreFuture ...
[10:30:49.695] result() for MulticoreFuture ... done
[10:30:49.695] - relayed: [n=2] TRUE, TRUE
[10:30:49.695] - queued futures: [n=2] TRUE, TRUE
[10:30:49.702] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:49.702]  length: 0 (resolved future 2)
[10:30:49.702] Relaying remaining futures
[10:30:49.702] signalConditionsASAP(NULL, pos=0) ...
[10:30:49.702] - nx: 2
[10:30:49.702] - relay: TRUE
[10:30:49.702] - stdout: TRUE
[10:30:49.702] - signal: TRUE
[10:30:49.702] - resignal: FALSE
[10:30:49.702] - force: TRUE
[10:30:49.703] - relayed: [n=2] TRUE, TRUE
[10:30:49.703] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:49.703] - relayed: [n=2] TRUE, TRUE
[10:30:49.703] - queued futures: [n=2] TRUE, TRUE
[10:30:49.703] signalConditionsASAP(NULL, pos=0) ... done
[10:30:49.703] resolve() on list ... DONE
[10:30:49.703] result() for MulticoreFuture ...
[10:30:49.703] result() for MulticoreFuture ... done
[10:30:49.704] result() for MulticoreFuture ...
[10:30:49.704] result() for MulticoreFuture ... done
[10:30:49.704] result() for MulticoreFuture ...
[10:30:49.704] result() for MulticoreFuture ... done
[10:30:49.704] result() for MulticoreFuture ...
[10:30:49.704] result() for MulticoreFuture ... done
[10:30:49.705]  - Number of value chunks collected: 2
[10:30:49.705] Resolving 2 futures (chunks) ... DONE
[10:30:49.705] Reducing values from 2 chunks ...
[10:30:49.705]  - Number of values collected after concatenation: 3
[10:30:49.705]  - Number of values expected: 3
[10:30:49.705] Reducing values from 2 chunks ... DONE
[10:30:49.705] future_mapply() ... DONE
[10:30:49.706] future_mapply() ...
[10:30:49.711] Number of chunks: 5
[10:30:49.711] getGlobalsAndPackagesXApply() ...
[10:30:49.711]  - future.globals: TRUE
[10:30:49.711] getGlobalsAndPackages() ...
[10:30:49.711] Searching for globals...
[10:30:49.713] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:49.713] Searching for globals ... DONE
[10:30:49.713] Resolving globals: FALSE
[10:30:49.714] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:49.714] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:49.714] - globals: [1] ‘FUN’
[10:30:49.714] 
[10:30:49.714] getGlobalsAndPackages() ... DONE
[10:30:49.714]  - globals found/used: [n=1] ‘FUN’
[10:30:49.715]  - needed namespaces: [n=0] 
[10:30:49.715] Finding globals ... DONE
[10:30:49.715] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:49.715] List of 2
[10:30:49.715]  $ ...future.FUN:function (C, k)  
[10:30:49.715]  $ MoreArgs     : NULL
[10:30:49.715]  - attr(*, "where")=List of 2
[10:30:49.715]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:49.715]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:49.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.715]  - attr(*, "resolved")= logi FALSE
[10:30:49.715]  - attr(*, "total_size")= num NA
[10:30:49.718] Packages to be attached in all futures: [n=0] 
[10:30:49.718] getGlobalsAndPackagesXApply() ... DONE
[10:30:49.718] Number of futures (= number of chunks): 5
[10:30:49.718] Launching 5 futures (chunks) ...
[10:30:49.719] Chunk #1 of 5 ...
[10:30:49.719]  - Finding globals in '...' for chunk #1 ...
[10:30:49.719] getGlobalsAndPackages() ...
[10:30:49.719] Searching for globals...
[10:30:49.719] 
[10:30:49.719] Searching for globals ... DONE
[10:30:49.719] - globals: [0] <none>
[10:30:49.720] getGlobalsAndPackages() ... DONE
[10:30:49.720]    + additional globals found: [n=0] 
[10:30:49.720]    + additional namespaces needed: [n=0] 
[10:30:49.720]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:49.720]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:49.720]  - seeds: <none>
[10:30:49.720]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.720] getGlobalsAndPackages() ...
[10:30:49.720] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.720] Resolving globals: FALSE
[10:30:49.721] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:49.722] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.722] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.722] 
[10:30:49.722] getGlobalsAndPackages() ... DONE
[10:30:49.722] run() for ‘Future’ ...
[10:30:49.722] - state: ‘created’
[10:30:49.722] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.727] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.727] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.727]   - Field: ‘label’
[10:30:49.727]   - Field: ‘local’
[10:30:49.727]   - Field: ‘owner’
[10:30:49.727]   - Field: ‘envir’
[10:30:49.728]   - Field: ‘workers’
[10:30:49.728]   - Field: ‘packages’
[10:30:49.728]   - Field: ‘gc’
[10:30:49.728]   - Field: ‘job’
[10:30:49.728]   - Field: ‘conditions’
[10:30:49.728]   - Field: ‘expr’
[10:30:49.728]   - Field: ‘uuid’
[10:30:49.729]   - Field: ‘seed’
[10:30:49.729]   - Field: ‘version’
[10:30:49.729]   - Field: ‘result’
[10:30:49.729]   - Field: ‘asynchronous’
[10:30:49.729]   - Field: ‘calls’
[10:30:49.729]   - Field: ‘globals’
[10:30:49.729]   - Field: ‘stdout’
[10:30:49.730]   - Field: ‘earlySignal’
[10:30:49.730]   - Field: ‘lazy’
[10:30:49.730]   - Field: ‘state’
[10:30:49.730] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.730] - Launch lazy future ...
[10:30:49.730] Packages needed by the future expression (n = 0): <none>
[10:30:49.731] Packages needed by future strategies (n = 0): <none>
[10:30:49.731] {
[10:30:49.731]     {
[10:30:49.731]         {
[10:30:49.731]             ...future.startTime <- base::Sys.time()
[10:30:49.731]             {
[10:30:49.731]                 {
[10:30:49.731]                   {
[10:30:49.731]                     {
[10:30:49.731]                       base::local({
[10:30:49.731]                         has_future <- base::requireNamespace("future", 
[10:30:49.731]                           quietly = TRUE)
[10:30:49.731]                         if (has_future) {
[10:30:49.731]                           ns <- base::getNamespace("future")
[10:30:49.731]                           version <- ns[[".package"]][["version"]]
[10:30:49.731]                           if (is.null(version)) 
[10:30:49.731]                             version <- utils::packageVersion("future")
[10:30:49.731]                         }
[10:30:49.731]                         else {
[10:30:49.731]                           version <- NULL
[10:30:49.731]                         }
[10:30:49.731]                         if (!has_future || version < "1.8.0") {
[10:30:49.731]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.731]                             "", base::R.version$version.string), 
[10:30:49.731]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.731]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.731]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.731]                               "release", "version")], collapse = " "), 
[10:30:49.731]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.731]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.731]                             info)
[10:30:49.731]                           info <- base::paste(info, collapse = "; ")
[10:30:49.731]                           if (!has_future) {
[10:30:49.731]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.731]                               info)
[10:30:49.731]                           }
[10:30:49.731]                           else {
[10:30:49.731]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.731]                               info, version)
[10:30:49.731]                           }
[10:30:49.731]                           base::stop(msg)
[10:30:49.731]                         }
[10:30:49.731]                       })
[10:30:49.731]                     }
[10:30:49.731]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.731]                     base::options(mc.cores = 1L)
[10:30:49.731]                   }
[10:30:49.731]                   ...future.strategy.old <- future::plan("list")
[10:30:49.731]                   options(future.plan = NULL)
[10:30:49.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.731]                 }
[10:30:49.731]                 ...future.workdir <- getwd()
[10:30:49.731]             }
[10:30:49.731]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.731]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.731]         }
[10:30:49.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.731]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:49.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.731]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.731]             base::names(...future.oldOptions))
[10:30:49.731]     }
[10:30:49.731]     if (FALSE) {
[10:30:49.731]     }
[10:30:49.731]     else {
[10:30:49.731]         if (TRUE) {
[10:30:49.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.731]                 open = "w")
[10:30:49.731]         }
[10:30:49.731]         else {
[10:30:49.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.731]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.731]         }
[10:30:49.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.731]             base::sink(type = "output", split = FALSE)
[10:30:49.731]             base::close(...future.stdout)
[10:30:49.731]         }, add = TRUE)
[10:30:49.731]     }
[10:30:49.731]     ...future.frame <- base::sys.nframe()
[10:30:49.731]     ...future.conditions <- base::list()
[10:30:49.731]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.731]     if (FALSE) {
[10:30:49.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.731]     }
[10:30:49.731]     ...future.result <- base::tryCatch({
[10:30:49.731]         base::withCallingHandlers({
[10:30:49.731]             ...future.value <- base::withVisible(base::local({
[10:30:49.731]                 withCallingHandlers({
[10:30:49.731]                   {
[10:30:49.731]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.731]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.731]                       ...future.globals.maxSize)) {
[10:30:49.731]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.731]                       on.exit(options(oopts), add = TRUE)
[10:30:49.731]                     }
[10:30:49.731]                     {
[10:30:49.731]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.731]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.731]                         USE.NAMES = FALSE)
[10:30:49.731]                       do.call(mapply, args = args)
[10:30:49.731]                     }
[10:30:49.731]                   }
[10:30:49.731]                 }, immediateCondition = function(cond) {
[10:30:49.731]                   save_rds <- function (object, pathname, ...) 
[10:30:49.731]                   {
[10:30:49.731]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.731]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.731]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.731]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.731]                         fi_tmp[["mtime"]])
[10:30:49.731]                     }
[10:30:49.731]                     tryCatch({
[10:30:49.731]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.731]                     }, error = function(ex) {
[10:30:49.731]                       msg <- conditionMessage(ex)
[10:30:49.731]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.731]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.731]                         fi_tmp[["mtime"]], msg)
[10:30:49.731]                       ex$message <- msg
[10:30:49.731]                       stop(ex)
[10:30:49.731]                     })
[10:30:49.731]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.731]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.731]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.731]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.731]                       fi <- file.info(pathname)
[10:30:49.731]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.731]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.731]                         fi[["size"]], fi[["mtime"]])
[10:30:49.731]                       stop(msg)
[10:30:49.731]                     }
[10:30:49.731]                     invisible(pathname)
[10:30:49.731]                   }
[10:30:49.731]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.731]                     rootPath = tempdir()) 
[10:30:49.731]                   {
[10:30:49.731]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.731]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.731]                       tmpdir = path, fileext = ".rds")
[10:30:49.731]                     save_rds(obj, file)
[10:30:49.731]                   }
[10:30:49.731]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.731]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.731]                   {
[10:30:49.731]                     inherits <- base::inherits
[10:30:49.731]                     invokeRestart <- base::invokeRestart
[10:30:49.731]                     is.null <- base::is.null
[10:30:49.731]                     muffled <- FALSE
[10:30:49.731]                     if (inherits(cond, "message")) {
[10:30:49.731]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.731]                       if (muffled) 
[10:30:49.731]                         invokeRestart("muffleMessage")
[10:30:49.731]                     }
[10:30:49.731]                     else if (inherits(cond, "warning")) {
[10:30:49.731]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.731]                       if (muffled) 
[10:30:49.731]                         invokeRestart("muffleWarning")
[10:30:49.731]                     }
[10:30:49.731]                     else if (inherits(cond, "condition")) {
[10:30:49.731]                       if (!is.null(pattern)) {
[10:30:49.731]                         computeRestarts <- base::computeRestarts
[10:30:49.731]                         grepl <- base::grepl
[10:30:49.731]                         restarts <- computeRestarts(cond)
[10:30:49.731]                         for (restart in restarts) {
[10:30:49.731]                           name <- restart$name
[10:30:49.731]                           if (is.null(name)) 
[10:30:49.731]                             next
[10:30:49.731]                           if (!grepl(pattern, name)) 
[10:30:49.731]                             next
[10:30:49.731]                           invokeRestart(restart)
[10:30:49.731]                           muffled <- TRUE
[10:30:49.731]                           break
[10:30:49.731]                         }
[10:30:49.731]                       }
[10:30:49.731]                     }
[10:30:49.731]                     invisible(muffled)
[10:30:49.731]                   }
[10:30:49.731]                   muffleCondition(cond)
[10:30:49.731]                 })
[10:30:49.731]             }))
[10:30:49.731]             future::FutureResult(value = ...future.value$value, 
[10:30:49.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.731]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.731]                     ...future.globalenv.names))
[10:30:49.731]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.731]         }, condition = base::local({
[10:30:49.731]             c <- base::c
[10:30:49.731]             inherits <- base::inherits
[10:30:49.731]             invokeRestart <- base::invokeRestart
[10:30:49.731]             length <- base::length
[10:30:49.731]             list <- base::list
[10:30:49.731]             seq.int <- base::seq.int
[10:30:49.731]             signalCondition <- base::signalCondition
[10:30:49.731]             sys.calls <- base::sys.calls
[10:30:49.731]             `[[` <- base::`[[`
[10:30:49.731]             `+` <- base::`+`
[10:30:49.731]             `<<-` <- base::`<<-`
[10:30:49.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.731]                   3L)]
[10:30:49.731]             }
[10:30:49.731]             function(cond) {
[10:30:49.731]                 is_error <- inherits(cond, "error")
[10:30:49.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.731]                   NULL)
[10:30:49.731]                 if (is_error) {
[10:30:49.731]                   sessionInformation <- function() {
[10:30:49.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.731]                       search = base::search(), system = base::Sys.info())
[10:30:49.731]                   }
[10:30:49.731]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.731]                     cond$call), session = sessionInformation(), 
[10:30:49.731]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.731]                   signalCondition(cond)
[10:30:49.731]                 }
[10:30:49.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.731]                 "immediateCondition"))) {
[10:30:49.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.731]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.731]                   if (TRUE && !signal) {
[10:30:49.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.731]                     {
[10:30:49.731]                       inherits <- base::inherits
[10:30:49.731]                       invokeRestart <- base::invokeRestart
[10:30:49.731]                       is.null <- base::is.null
[10:30:49.731]                       muffled <- FALSE
[10:30:49.731]                       if (inherits(cond, "message")) {
[10:30:49.731]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.731]                         if (muffled) 
[10:30:49.731]                           invokeRestart("muffleMessage")
[10:30:49.731]                       }
[10:30:49.731]                       else if (inherits(cond, "warning")) {
[10:30:49.731]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.731]                         if (muffled) 
[10:30:49.731]                           invokeRestart("muffleWarning")
[10:30:49.731]                       }
[10:30:49.731]                       else if (inherits(cond, "condition")) {
[10:30:49.731]                         if (!is.null(pattern)) {
[10:30:49.731]                           computeRestarts <- base::computeRestarts
[10:30:49.731]                           grepl <- base::grepl
[10:30:49.731]                           restarts <- computeRestarts(cond)
[10:30:49.731]                           for (restart in restarts) {
[10:30:49.731]                             name <- restart$name
[10:30:49.731]                             if (is.null(name)) 
[10:30:49.731]                               next
[10:30:49.731]                             if (!grepl(pattern, name)) 
[10:30:49.731]                               next
[10:30:49.731]                             invokeRestart(restart)
[10:30:49.731]                             muffled <- TRUE
[10:30:49.731]                             break
[10:30:49.731]                           }
[10:30:49.731]                         }
[10:30:49.731]                       }
[10:30:49.731]                       invisible(muffled)
[10:30:49.731]                     }
[10:30:49.731]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.731]                   }
[10:30:49.731]                 }
[10:30:49.731]                 else {
[10:30:49.731]                   if (TRUE) {
[10:30:49.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.731]                     {
[10:30:49.731]                       inherits <- base::inherits
[10:30:49.731]                       invokeRestart <- base::invokeRestart
[10:30:49.731]                       is.null <- base::is.null
[10:30:49.731]                       muffled <- FALSE
[10:30:49.731]                       if (inherits(cond, "message")) {
[10:30:49.731]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.731]                         if (muffled) 
[10:30:49.731]                           invokeRestart("muffleMessage")
[10:30:49.731]                       }
[10:30:49.731]                       else if (inherits(cond, "warning")) {
[10:30:49.731]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.731]                         if (muffled) 
[10:30:49.731]                           invokeRestart("muffleWarning")
[10:30:49.731]                       }
[10:30:49.731]                       else if (inherits(cond, "condition")) {
[10:30:49.731]                         if (!is.null(pattern)) {
[10:30:49.731]                           computeRestarts <- base::computeRestarts
[10:30:49.731]                           grepl <- base::grepl
[10:30:49.731]                           restarts <- computeRestarts(cond)
[10:30:49.731]                           for (restart in restarts) {
[10:30:49.731]                             name <- restart$name
[10:30:49.731]                             if (is.null(name)) 
[10:30:49.731]                               next
[10:30:49.731]                             if (!grepl(pattern, name)) 
[10:30:49.731]                               next
[10:30:49.731]                             invokeRestart(restart)
[10:30:49.731]                             muffled <- TRUE
[10:30:49.731]                             break
[10:30:49.731]                           }
[10:30:49.731]                         }
[10:30:49.731]                       }
[10:30:49.731]                       invisible(muffled)
[10:30:49.731]                     }
[10:30:49.731]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.731]                   }
[10:30:49.731]                 }
[10:30:49.731]             }
[10:30:49.731]         }))
[10:30:49.731]     }, error = function(ex) {
[10:30:49.731]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.731]                 ...future.rng), started = ...future.startTime, 
[10:30:49.731]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.731]             version = "1.8"), class = "FutureResult")
[10:30:49.731]     }, finally = {
[10:30:49.731]         if (!identical(...future.workdir, getwd())) 
[10:30:49.731]             setwd(...future.workdir)
[10:30:49.731]         {
[10:30:49.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.731]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.731]             }
[10:30:49.731]             base::options(...future.oldOptions)
[10:30:49.731]             if (.Platform$OS.type == "windows") {
[10:30:49.731]                 old_names <- names(...future.oldEnvVars)
[10:30:49.731]                 envs <- base::Sys.getenv()
[10:30:49.731]                 names <- names(envs)
[10:30:49.731]                 common <- intersect(names, old_names)
[10:30:49.731]                 added <- setdiff(names, old_names)
[10:30:49.731]                 removed <- setdiff(old_names, names)
[10:30:49.731]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.731]                   envs[common]]
[10:30:49.731]                 NAMES <- toupper(changed)
[10:30:49.731]                 args <- list()
[10:30:49.731]                 for (kk in seq_along(NAMES)) {
[10:30:49.731]                   name <- changed[[kk]]
[10:30:49.731]                   NAME <- NAMES[[kk]]
[10:30:49.731]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.731]                     next
[10:30:49.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.731]                 }
[10:30:49.731]                 NAMES <- toupper(added)
[10:30:49.731]                 for (kk in seq_along(NAMES)) {
[10:30:49.731]                   name <- added[[kk]]
[10:30:49.731]                   NAME <- NAMES[[kk]]
[10:30:49.731]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.731]                     next
[10:30:49.731]                   args[[name]] <- ""
[10:30:49.731]                 }
[10:30:49.731]                 NAMES <- toupper(removed)
[10:30:49.731]                 for (kk in seq_along(NAMES)) {
[10:30:49.731]                   name <- removed[[kk]]
[10:30:49.731]                   NAME <- NAMES[[kk]]
[10:30:49.731]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.731]                     next
[10:30:49.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.731]                 }
[10:30:49.731]                 if (length(args) > 0) 
[10:30:49.731]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.731]             }
[10:30:49.731]             else {
[10:30:49.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.731]             }
[10:30:49.731]             {
[10:30:49.731]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.731]                   0L) {
[10:30:49.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.731]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.731]                   base::options(opts)
[10:30:49.731]                 }
[10:30:49.731]                 {
[10:30:49.731]                   {
[10:30:49.731]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.731]                     NULL
[10:30:49.731]                   }
[10:30:49.731]                   options(future.plan = NULL)
[10:30:49.731]                   if (is.na(NA_character_)) 
[10:30:49.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.731]                     .init = FALSE)
[10:30:49.731]                 }
[10:30:49.731]             }
[10:30:49.731]         }
[10:30:49.731]     })
[10:30:49.731]     if (TRUE) {
[10:30:49.731]         base::sink(type = "output", split = FALSE)
[10:30:49.731]         if (TRUE) {
[10:30:49.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.731]         }
[10:30:49.731]         else {
[10:30:49.731]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.731]         }
[10:30:49.731]         base::close(...future.stdout)
[10:30:49.731]         ...future.stdout <- NULL
[10:30:49.731]     }
[10:30:49.731]     ...future.result$conditions <- ...future.conditions
[10:30:49.731]     ...future.result$finished <- base::Sys.time()
[10:30:49.731]     ...future.result
[10:30:49.731] }
[10:30:49.735] assign_globals() ...
[10:30:49.735] List of 5
[10:30:49.735]  $ ...future.FUN            :function (C, k)  
[10:30:49.735]  $ MoreArgs                 : NULL
[10:30:49.735]  $ ...future.elements_ii    :List of 2
[10:30:49.735]   ..$ :List of 1
[10:30:49.735]   .. ..$ : chr "A"
[10:30:49.735]   ..$ :List of 1
[10:30:49.735]   .. ..$ : int 5
[10:30:49.735]  $ ...future.seeds_ii       : NULL
[10:30:49.735]  $ ...future.globals.maxSize: NULL
[10:30:49.735]  - attr(*, "where")=List of 5
[10:30:49.735]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.735]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.735]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.735]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.735]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.735]  - attr(*, "resolved")= logi FALSE
[10:30:49.735]  - attr(*, "total_size")= num 3488
[10:30:49.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.735]  - attr(*, "already-done")= logi TRUE
[10:30:49.744] - reassign environment for ‘...future.FUN’
[10:30:49.744] - copied ‘...future.FUN’ to environment
[10:30:49.745] - copied ‘MoreArgs’ to environment
[10:30:49.745] - copied ‘...future.elements_ii’ to environment
[10:30:49.745] - copied ‘...future.seeds_ii’ to environment
[10:30:49.745] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.745] assign_globals() ... done
[10:30:49.745] requestCore(): workers = 2
[10:30:49.748] MulticoreFuture started
[10:30:49.748] - Launch lazy future ... done
[10:30:49.749] run() for ‘MulticoreFuture’ ... done
[10:30:49.749] Created future:
[10:30:49.749] plan(): Setting new future strategy stack:
[10:30:49.749] List of future strategies:
[10:30:49.749] 1. sequential:
[10:30:49.749]    - args: function (..., envir = parent.frame())
[10:30:49.749]    - tweaked: FALSE
[10:30:49.749]    - call: NULL
[10:30:49.750] plan(): nbrOfWorkers() = 1
[10:30:49.753] plan(): Setting new future strategy stack:
[10:30:49.753] List of future strategies:
[10:30:49.753] 1. multicore:
[10:30:49.753]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.753]    - tweaked: FALSE
[10:30:49.753]    - call: plan(strategy)
[10:30:49.759] plan(): nbrOfWorkers() = 2
[10:30:49.749] MulticoreFuture:
[10:30:49.749] Label: ‘future_mapply-1’
[10:30:49.749] Expression:
[10:30:49.749] {
[10:30:49.749]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.749]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.749]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.749]         on.exit(options(oopts), add = TRUE)
[10:30:49.749]     }
[10:30:49.749]     {
[10:30:49.749]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.749]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.749]         do.call(mapply, args = args)
[10:30:49.749]     }
[10:30:49.749] }
[10:30:49.749] Lazy evaluation: FALSE
[10:30:49.749] Asynchronous evaluation: TRUE
[10:30:49.749] Local evaluation: TRUE
[10:30:49.749] Environment: R_GlobalEnv
[10:30:49.749] Capture standard output: TRUE
[10:30:49.749] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.749] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.749] Packages: <none>
[10:30:49.749] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.749] Resolved: TRUE
[10:30:49.749] Value: <not collected>
[10:30:49.749] Conditions captured: <none>
[10:30:49.749] Early signaling: FALSE
[10:30:49.749] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.749] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.761] Chunk #1 of 5 ... DONE
[10:30:49.761] Chunk #2 of 5 ...
[10:30:49.761]  - Finding globals in '...' for chunk #2 ...
[10:30:49.762] getGlobalsAndPackages() ...
[10:30:49.762] Searching for globals...
[10:30:49.763] 
[10:30:49.763] Searching for globals ... DONE
[10:30:49.763] - globals: [0] <none>
[10:30:49.763] getGlobalsAndPackages() ... DONE
[10:30:49.763]    + additional globals found: [n=0] 
[10:30:49.763]    + additional namespaces needed: [n=0] 
[10:30:49.764]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:49.764]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:49.764]  - seeds: <none>
[10:30:49.764]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.764] getGlobalsAndPackages() ...
[10:30:49.764] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.765] Resolving globals: FALSE
[10:30:49.766] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:49.766] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.767] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.767] 
[10:30:49.767] getGlobalsAndPackages() ... DONE
[10:30:49.767] run() for ‘Future’ ...
[10:30:49.768] - state: ‘created’
[10:30:49.768] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.773] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.773] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.773]   - Field: ‘label’
[10:30:49.773]   - Field: ‘local’
[10:30:49.773]   - Field: ‘owner’
[10:30:49.773]   - Field: ‘envir’
[10:30:49.774]   - Field: ‘workers’
[10:30:49.774]   - Field: ‘packages’
[10:30:49.774]   - Field: ‘gc’
[10:30:49.774]   - Field: ‘job’
[10:30:49.774]   - Field: ‘conditions’
[10:30:49.774]   - Field: ‘expr’
[10:30:49.774]   - Field: ‘uuid’
[10:30:49.775]   - Field: ‘seed’
[10:30:49.775]   - Field: ‘version’
[10:30:49.775]   - Field: ‘result’
[10:30:49.775]   - Field: ‘asynchronous’
[10:30:49.775]   - Field: ‘calls’
[10:30:49.775]   - Field: ‘globals’
[10:30:49.775]   - Field: ‘stdout’
[10:30:49.776]   - Field: ‘earlySignal’
[10:30:49.776]   - Field: ‘lazy’
[10:30:49.776]   - Field: ‘state’
[10:30:49.776] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.776] - Launch lazy future ...
[10:30:49.777] Packages needed by the future expression (n = 0): <none>
[10:30:49.777] Packages needed by future strategies (n = 0): <none>
[10:30:49.778] {
[10:30:49.778]     {
[10:30:49.778]         {
[10:30:49.778]             ...future.startTime <- base::Sys.time()
[10:30:49.778]             {
[10:30:49.778]                 {
[10:30:49.778]                   {
[10:30:49.778]                     {
[10:30:49.778]                       base::local({
[10:30:49.778]                         has_future <- base::requireNamespace("future", 
[10:30:49.778]                           quietly = TRUE)
[10:30:49.778]                         if (has_future) {
[10:30:49.778]                           ns <- base::getNamespace("future")
[10:30:49.778]                           version <- ns[[".package"]][["version"]]
[10:30:49.778]                           if (is.null(version)) 
[10:30:49.778]                             version <- utils::packageVersion("future")
[10:30:49.778]                         }
[10:30:49.778]                         else {
[10:30:49.778]                           version <- NULL
[10:30:49.778]                         }
[10:30:49.778]                         if (!has_future || version < "1.8.0") {
[10:30:49.778]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.778]                             "", base::R.version$version.string), 
[10:30:49.778]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.778]                               "release", "version")], collapse = " "), 
[10:30:49.778]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.778]                             info)
[10:30:49.778]                           info <- base::paste(info, collapse = "; ")
[10:30:49.778]                           if (!has_future) {
[10:30:49.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.778]                               info)
[10:30:49.778]                           }
[10:30:49.778]                           else {
[10:30:49.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.778]                               info, version)
[10:30:49.778]                           }
[10:30:49.778]                           base::stop(msg)
[10:30:49.778]                         }
[10:30:49.778]                       })
[10:30:49.778]                     }
[10:30:49.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.778]                     base::options(mc.cores = 1L)
[10:30:49.778]                   }
[10:30:49.778]                   ...future.strategy.old <- future::plan("list")
[10:30:49.778]                   options(future.plan = NULL)
[10:30:49.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.778]                 }
[10:30:49.778]                 ...future.workdir <- getwd()
[10:30:49.778]             }
[10:30:49.778]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.778]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.778]         }
[10:30:49.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.778]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:49.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.778]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.778]             base::names(...future.oldOptions))
[10:30:49.778]     }
[10:30:49.778]     if (FALSE) {
[10:30:49.778]     }
[10:30:49.778]     else {
[10:30:49.778]         if (TRUE) {
[10:30:49.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.778]                 open = "w")
[10:30:49.778]         }
[10:30:49.778]         else {
[10:30:49.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.778]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.778]         }
[10:30:49.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.778]             base::sink(type = "output", split = FALSE)
[10:30:49.778]             base::close(...future.stdout)
[10:30:49.778]         }, add = TRUE)
[10:30:49.778]     }
[10:30:49.778]     ...future.frame <- base::sys.nframe()
[10:30:49.778]     ...future.conditions <- base::list()
[10:30:49.778]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.778]     if (FALSE) {
[10:30:49.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.778]     }
[10:30:49.778]     ...future.result <- base::tryCatch({
[10:30:49.778]         base::withCallingHandlers({
[10:30:49.778]             ...future.value <- base::withVisible(base::local({
[10:30:49.778]                 withCallingHandlers({
[10:30:49.778]                   {
[10:30:49.778]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.778]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.778]                       ...future.globals.maxSize)) {
[10:30:49.778]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.778]                       on.exit(options(oopts), add = TRUE)
[10:30:49.778]                     }
[10:30:49.778]                     {
[10:30:49.778]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.778]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.778]                         USE.NAMES = FALSE)
[10:30:49.778]                       do.call(mapply, args = args)
[10:30:49.778]                     }
[10:30:49.778]                   }
[10:30:49.778]                 }, immediateCondition = function(cond) {
[10:30:49.778]                   save_rds <- function (object, pathname, ...) 
[10:30:49.778]                   {
[10:30:49.778]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.778]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.778]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.778]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.778]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.778]                         fi_tmp[["mtime"]])
[10:30:49.778]                     }
[10:30:49.778]                     tryCatch({
[10:30:49.778]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.778]                     }, error = function(ex) {
[10:30:49.778]                       msg <- conditionMessage(ex)
[10:30:49.778]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.778]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.778]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.778]                         fi_tmp[["mtime"]], msg)
[10:30:49.778]                       ex$message <- msg
[10:30:49.778]                       stop(ex)
[10:30:49.778]                     })
[10:30:49.778]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.778]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.778]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.778]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.778]                       fi <- file.info(pathname)
[10:30:49.778]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.778]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.778]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.778]                         fi[["size"]], fi[["mtime"]])
[10:30:49.778]                       stop(msg)
[10:30:49.778]                     }
[10:30:49.778]                     invisible(pathname)
[10:30:49.778]                   }
[10:30:49.778]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.778]                     rootPath = tempdir()) 
[10:30:49.778]                   {
[10:30:49.778]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.778]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.778]                       tmpdir = path, fileext = ".rds")
[10:30:49.778]                     save_rds(obj, file)
[10:30:49.778]                   }
[10:30:49.778]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.778]                   {
[10:30:49.778]                     inherits <- base::inherits
[10:30:49.778]                     invokeRestart <- base::invokeRestart
[10:30:49.778]                     is.null <- base::is.null
[10:30:49.778]                     muffled <- FALSE
[10:30:49.778]                     if (inherits(cond, "message")) {
[10:30:49.778]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.778]                       if (muffled) 
[10:30:49.778]                         invokeRestart("muffleMessage")
[10:30:49.778]                     }
[10:30:49.778]                     else if (inherits(cond, "warning")) {
[10:30:49.778]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.778]                       if (muffled) 
[10:30:49.778]                         invokeRestart("muffleWarning")
[10:30:49.778]                     }
[10:30:49.778]                     else if (inherits(cond, "condition")) {
[10:30:49.778]                       if (!is.null(pattern)) {
[10:30:49.778]                         computeRestarts <- base::computeRestarts
[10:30:49.778]                         grepl <- base::grepl
[10:30:49.778]                         restarts <- computeRestarts(cond)
[10:30:49.778]                         for (restart in restarts) {
[10:30:49.778]                           name <- restart$name
[10:30:49.778]                           if (is.null(name)) 
[10:30:49.778]                             next
[10:30:49.778]                           if (!grepl(pattern, name)) 
[10:30:49.778]                             next
[10:30:49.778]                           invokeRestart(restart)
[10:30:49.778]                           muffled <- TRUE
[10:30:49.778]                           break
[10:30:49.778]                         }
[10:30:49.778]                       }
[10:30:49.778]                     }
[10:30:49.778]                     invisible(muffled)
[10:30:49.778]                   }
[10:30:49.778]                   muffleCondition(cond)
[10:30:49.778]                 })
[10:30:49.778]             }))
[10:30:49.778]             future::FutureResult(value = ...future.value$value, 
[10:30:49.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.778]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.778]                     ...future.globalenv.names))
[10:30:49.778]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.778]         }, condition = base::local({
[10:30:49.778]             c <- base::c
[10:30:49.778]             inherits <- base::inherits
[10:30:49.778]             invokeRestart <- base::invokeRestart
[10:30:49.778]             length <- base::length
[10:30:49.778]             list <- base::list
[10:30:49.778]             seq.int <- base::seq.int
[10:30:49.778]             signalCondition <- base::signalCondition
[10:30:49.778]             sys.calls <- base::sys.calls
[10:30:49.778]             `[[` <- base::`[[`
[10:30:49.778]             `+` <- base::`+`
[10:30:49.778]             `<<-` <- base::`<<-`
[10:30:49.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.778]                   3L)]
[10:30:49.778]             }
[10:30:49.778]             function(cond) {
[10:30:49.778]                 is_error <- inherits(cond, "error")
[10:30:49.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.778]                   NULL)
[10:30:49.778]                 if (is_error) {
[10:30:49.778]                   sessionInformation <- function() {
[10:30:49.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.778]                       search = base::search(), system = base::Sys.info())
[10:30:49.778]                   }
[10:30:49.778]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.778]                     cond$call), session = sessionInformation(), 
[10:30:49.778]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.778]                   signalCondition(cond)
[10:30:49.778]                 }
[10:30:49.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.778]                 "immediateCondition"))) {
[10:30:49.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.778]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.778]                   if (TRUE && !signal) {
[10:30:49.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.778]                     {
[10:30:49.778]                       inherits <- base::inherits
[10:30:49.778]                       invokeRestart <- base::invokeRestart
[10:30:49.778]                       is.null <- base::is.null
[10:30:49.778]                       muffled <- FALSE
[10:30:49.778]                       if (inherits(cond, "message")) {
[10:30:49.778]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.778]                         if (muffled) 
[10:30:49.778]                           invokeRestart("muffleMessage")
[10:30:49.778]                       }
[10:30:49.778]                       else if (inherits(cond, "warning")) {
[10:30:49.778]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.778]                         if (muffled) 
[10:30:49.778]                           invokeRestart("muffleWarning")
[10:30:49.778]                       }
[10:30:49.778]                       else if (inherits(cond, "condition")) {
[10:30:49.778]                         if (!is.null(pattern)) {
[10:30:49.778]                           computeRestarts <- base::computeRestarts
[10:30:49.778]                           grepl <- base::grepl
[10:30:49.778]                           restarts <- computeRestarts(cond)
[10:30:49.778]                           for (restart in restarts) {
[10:30:49.778]                             name <- restart$name
[10:30:49.778]                             if (is.null(name)) 
[10:30:49.778]                               next
[10:30:49.778]                             if (!grepl(pattern, name)) 
[10:30:49.778]                               next
[10:30:49.778]                             invokeRestart(restart)
[10:30:49.778]                             muffled <- TRUE
[10:30:49.778]                             break
[10:30:49.778]                           }
[10:30:49.778]                         }
[10:30:49.778]                       }
[10:30:49.778]                       invisible(muffled)
[10:30:49.778]                     }
[10:30:49.778]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.778]                   }
[10:30:49.778]                 }
[10:30:49.778]                 else {
[10:30:49.778]                   if (TRUE) {
[10:30:49.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.778]                     {
[10:30:49.778]                       inherits <- base::inherits
[10:30:49.778]                       invokeRestart <- base::invokeRestart
[10:30:49.778]                       is.null <- base::is.null
[10:30:49.778]                       muffled <- FALSE
[10:30:49.778]                       if (inherits(cond, "message")) {
[10:30:49.778]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.778]                         if (muffled) 
[10:30:49.778]                           invokeRestart("muffleMessage")
[10:30:49.778]                       }
[10:30:49.778]                       else if (inherits(cond, "warning")) {
[10:30:49.778]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.778]                         if (muffled) 
[10:30:49.778]                           invokeRestart("muffleWarning")
[10:30:49.778]                       }
[10:30:49.778]                       else if (inherits(cond, "condition")) {
[10:30:49.778]                         if (!is.null(pattern)) {
[10:30:49.778]                           computeRestarts <- base::computeRestarts
[10:30:49.778]                           grepl <- base::grepl
[10:30:49.778]                           restarts <- computeRestarts(cond)
[10:30:49.778]                           for (restart in restarts) {
[10:30:49.778]                             name <- restart$name
[10:30:49.778]                             if (is.null(name)) 
[10:30:49.778]                               next
[10:30:49.778]                             if (!grepl(pattern, name)) 
[10:30:49.778]                               next
[10:30:49.778]                             invokeRestart(restart)
[10:30:49.778]                             muffled <- TRUE
[10:30:49.778]                             break
[10:30:49.778]                           }
[10:30:49.778]                         }
[10:30:49.778]                       }
[10:30:49.778]                       invisible(muffled)
[10:30:49.778]                     }
[10:30:49.778]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.778]                   }
[10:30:49.778]                 }
[10:30:49.778]             }
[10:30:49.778]         }))
[10:30:49.778]     }, error = function(ex) {
[10:30:49.778]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.778]                 ...future.rng), started = ...future.startTime, 
[10:30:49.778]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.778]             version = "1.8"), class = "FutureResult")
[10:30:49.778]     }, finally = {
[10:30:49.778]         if (!identical(...future.workdir, getwd())) 
[10:30:49.778]             setwd(...future.workdir)
[10:30:49.778]         {
[10:30:49.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.778]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.778]             }
[10:30:49.778]             base::options(...future.oldOptions)
[10:30:49.778]             if (.Platform$OS.type == "windows") {
[10:30:49.778]                 old_names <- names(...future.oldEnvVars)
[10:30:49.778]                 envs <- base::Sys.getenv()
[10:30:49.778]                 names <- names(envs)
[10:30:49.778]                 common <- intersect(names, old_names)
[10:30:49.778]                 added <- setdiff(names, old_names)
[10:30:49.778]                 removed <- setdiff(old_names, names)
[10:30:49.778]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.778]                   envs[common]]
[10:30:49.778]                 NAMES <- toupper(changed)
[10:30:49.778]                 args <- list()
[10:30:49.778]                 for (kk in seq_along(NAMES)) {
[10:30:49.778]                   name <- changed[[kk]]
[10:30:49.778]                   NAME <- NAMES[[kk]]
[10:30:49.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.778]                     next
[10:30:49.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.778]                 }
[10:30:49.778]                 NAMES <- toupper(added)
[10:30:49.778]                 for (kk in seq_along(NAMES)) {
[10:30:49.778]                   name <- added[[kk]]
[10:30:49.778]                   NAME <- NAMES[[kk]]
[10:30:49.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.778]                     next
[10:30:49.778]                   args[[name]] <- ""
[10:30:49.778]                 }
[10:30:49.778]                 NAMES <- toupper(removed)
[10:30:49.778]                 for (kk in seq_along(NAMES)) {
[10:30:49.778]                   name <- removed[[kk]]
[10:30:49.778]                   NAME <- NAMES[[kk]]
[10:30:49.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.778]                     next
[10:30:49.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.778]                 }
[10:30:49.778]                 if (length(args) > 0) 
[10:30:49.778]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.778]             }
[10:30:49.778]             else {
[10:30:49.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.778]             }
[10:30:49.778]             {
[10:30:49.778]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.778]                   0L) {
[10:30:49.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.778]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.778]                   base::options(opts)
[10:30:49.778]                 }
[10:30:49.778]                 {
[10:30:49.778]                   {
[10:30:49.778]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.778]                     NULL
[10:30:49.778]                   }
[10:30:49.778]                   options(future.plan = NULL)
[10:30:49.778]                   if (is.na(NA_character_)) 
[10:30:49.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.778]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.778]                     .init = FALSE)
[10:30:49.778]                 }
[10:30:49.778]             }
[10:30:49.778]         }
[10:30:49.778]     })
[10:30:49.778]     if (TRUE) {
[10:30:49.778]         base::sink(type = "output", split = FALSE)
[10:30:49.778]         if (TRUE) {
[10:30:49.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.778]         }
[10:30:49.778]         else {
[10:30:49.778]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.778]         }
[10:30:49.778]         base::close(...future.stdout)
[10:30:49.778]         ...future.stdout <- NULL
[10:30:49.778]     }
[10:30:49.778]     ...future.result$conditions <- ...future.conditions
[10:30:49.778]     ...future.result$finished <- base::Sys.time()
[10:30:49.778]     ...future.result
[10:30:49.778] }
[10:30:49.781] assign_globals() ...
[10:30:49.781] List of 5
[10:30:49.781]  $ ...future.FUN            :function (C, k)  
[10:30:49.781]  $ MoreArgs                 : NULL
[10:30:49.781]  $ ...future.elements_ii    :List of 2
[10:30:49.781]   ..$ :List of 1
[10:30:49.781]   .. ..$ : chr "B"
[10:30:49.781]   ..$ :List of 1
[10:30:49.781]   .. ..$ : int 4
[10:30:49.781]  $ ...future.seeds_ii       : NULL
[10:30:49.781]  $ ...future.globals.maxSize: NULL
[10:30:49.781]  - attr(*, "where")=List of 5
[10:30:49.781]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.781]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.781]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.781]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.781]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.781]  - attr(*, "resolved")= logi FALSE
[10:30:49.781]  - attr(*, "total_size")= num 3488
[10:30:49.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.781]  - attr(*, "already-done")= logi TRUE
[10:30:49.793] - reassign environment for ‘...future.FUN’
[10:30:49.794] - copied ‘...future.FUN’ to environment
[10:30:49.794] - copied ‘MoreArgs’ to environment
[10:30:49.794] - copied ‘...future.elements_ii’ to environment
[10:30:49.794] - copied ‘...future.seeds_ii’ to environment
[10:30:49.794] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.794] assign_globals() ... done
[10:30:49.795] requestCore(): workers = 2
[10:30:49.798] MulticoreFuture started
[10:30:49.799] - Launch lazy future ... done
[10:30:49.799] plan(): Setting new future strategy stack:
[10:30:49.799] run() for ‘MulticoreFuture’ ... done
[10:30:49.800] Created future:
[10:30:49.799] List of future strategies:
[10:30:49.799] 1. sequential:
[10:30:49.799]    - args: function (..., envir = parent.frame())
[10:30:49.799]    - tweaked: FALSE
[10:30:49.799]    - call: NULL
[10:30:49.801] plan(): nbrOfWorkers() = 1
[10:30:49.804] plan(): Setting new future strategy stack:
[10:30:49.804] List of future strategies:
[10:30:49.804] 1. multicore:
[10:30:49.804]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.804]    - tweaked: FALSE
[10:30:49.804]    - call: plan(strategy)
[10:30:49.811] plan(): nbrOfWorkers() = 2
[10:30:49.800] MulticoreFuture:
[10:30:49.800] Label: ‘future_mapply-2’
[10:30:49.800] Expression:
[10:30:49.800] {
[10:30:49.800]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.800]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.800]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.800]         on.exit(options(oopts), add = TRUE)
[10:30:49.800]     }
[10:30:49.800]     {
[10:30:49.800]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.800]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.800]         do.call(mapply, args = args)
[10:30:49.800]     }
[10:30:49.800] }
[10:30:49.800] Lazy evaluation: FALSE
[10:30:49.800] Asynchronous evaluation: TRUE
[10:30:49.800] Local evaluation: TRUE
[10:30:49.800] Environment: R_GlobalEnv
[10:30:49.800] Capture standard output: TRUE
[10:30:49.800] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.800] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.800] Packages: <none>
[10:30:49.800] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.800] Resolved: TRUE
[10:30:49.800] Value: <not collected>
[10:30:49.800] Conditions captured: <none>
[10:30:49.800] Early signaling: FALSE
[10:30:49.800] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.800] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.812] Chunk #2 of 5 ... DONE
[10:30:49.813] Chunk #3 of 5 ...
[10:30:49.813]  - Finding globals in '...' for chunk #3 ...
[10:30:49.813] getGlobalsAndPackages() ...
[10:30:49.813] Searching for globals...
[10:30:49.814] 
[10:30:49.814] Searching for globals ... DONE
[10:30:49.814] - globals: [0] <none>
[10:30:49.815] getGlobalsAndPackages() ... DONE
[10:30:49.815]    + additional globals found: [n=0] 
[10:30:49.815]    + additional namespaces needed: [n=0] 
[10:30:49.815]  - Finding globals in '...' for chunk #3 ... DONE
[10:30:49.815]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:49.816]  - seeds: <none>
[10:30:49.816]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.816] getGlobalsAndPackages() ...
[10:30:49.816] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.816] Resolving globals: FALSE
[10:30:49.817] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:49.818] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.819] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.819] 
[10:30:49.819] getGlobalsAndPackages() ... DONE
[10:30:49.820] run() for ‘Future’ ...
[10:30:49.820] - state: ‘created’
[10:30:49.820] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.825] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.825] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.825]   - Field: ‘label’
[10:30:49.825]   - Field: ‘local’
[10:30:49.826]   - Field: ‘owner’
[10:30:49.826]   - Field: ‘envir’
[10:30:49.826]   - Field: ‘workers’
[10:30:49.826]   - Field: ‘packages’
[10:30:49.826]   - Field: ‘gc’
[10:30:49.826]   - Field: ‘job’
[10:30:49.827]   - Field: ‘conditions’
[10:30:49.827]   - Field: ‘expr’
[10:30:49.827]   - Field: ‘uuid’
[10:30:49.827]   - Field: ‘seed’
[10:30:49.827]   - Field: ‘version’
[10:30:49.827]   - Field: ‘result’
[10:30:49.827]   - Field: ‘asynchronous’
[10:30:49.827]   - Field: ‘calls’
[10:30:49.828]   - Field: ‘globals’
[10:30:49.828]   - Field: ‘stdout’
[10:30:49.828]   - Field: ‘earlySignal’
[10:30:49.828]   - Field: ‘lazy’
[10:30:49.828]   - Field: ‘state’
[10:30:49.828] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.828] - Launch lazy future ...
[10:30:49.829] Packages needed by the future expression (n = 0): <none>
[10:30:49.829] Packages needed by future strategies (n = 0): <none>
[10:30:49.830] {
[10:30:49.830]     {
[10:30:49.830]         {
[10:30:49.830]             ...future.startTime <- base::Sys.time()
[10:30:49.830]             {
[10:30:49.830]                 {
[10:30:49.830]                   {
[10:30:49.830]                     {
[10:30:49.830]                       base::local({
[10:30:49.830]                         has_future <- base::requireNamespace("future", 
[10:30:49.830]                           quietly = TRUE)
[10:30:49.830]                         if (has_future) {
[10:30:49.830]                           ns <- base::getNamespace("future")
[10:30:49.830]                           version <- ns[[".package"]][["version"]]
[10:30:49.830]                           if (is.null(version)) 
[10:30:49.830]                             version <- utils::packageVersion("future")
[10:30:49.830]                         }
[10:30:49.830]                         else {
[10:30:49.830]                           version <- NULL
[10:30:49.830]                         }
[10:30:49.830]                         if (!has_future || version < "1.8.0") {
[10:30:49.830]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.830]                             "", base::R.version$version.string), 
[10:30:49.830]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.830]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.830]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.830]                               "release", "version")], collapse = " "), 
[10:30:49.830]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.830]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.830]                             info)
[10:30:49.830]                           info <- base::paste(info, collapse = "; ")
[10:30:49.830]                           if (!has_future) {
[10:30:49.830]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.830]                               info)
[10:30:49.830]                           }
[10:30:49.830]                           else {
[10:30:49.830]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.830]                               info, version)
[10:30:49.830]                           }
[10:30:49.830]                           base::stop(msg)
[10:30:49.830]                         }
[10:30:49.830]                       })
[10:30:49.830]                     }
[10:30:49.830]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.830]                     base::options(mc.cores = 1L)
[10:30:49.830]                   }
[10:30:49.830]                   ...future.strategy.old <- future::plan("list")
[10:30:49.830]                   options(future.plan = NULL)
[10:30:49.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.830]                 }
[10:30:49.830]                 ...future.workdir <- getwd()
[10:30:49.830]             }
[10:30:49.830]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.830]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.830]         }
[10:30:49.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.830]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:49.830]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.830]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.830]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.830]             base::names(...future.oldOptions))
[10:30:49.830]     }
[10:30:49.830]     if (FALSE) {
[10:30:49.830]     }
[10:30:49.830]     else {
[10:30:49.830]         if (TRUE) {
[10:30:49.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.830]                 open = "w")
[10:30:49.830]         }
[10:30:49.830]         else {
[10:30:49.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.830]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.830]         }
[10:30:49.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.830]             base::sink(type = "output", split = FALSE)
[10:30:49.830]             base::close(...future.stdout)
[10:30:49.830]         }, add = TRUE)
[10:30:49.830]     }
[10:30:49.830]     ...future.frame <- base::sys.nframe()
[10:30:49.830]     ...future.conditions <- base::list()
[10:30:49.830]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.830]     if (FALSE) {
[10:30:49.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.830]     }
[10:30:49.830]     ...future.result <- base::tryCatch({
[10:30:49.830]         base::withCallingHandlers({
[10:30:49.830]             ...future.value <- base::withVisible(base::local({
[10:30:49.830]                 withCallingHandlers({
[10:30:49.830]                   {
[10:30:49.830]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.830]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.830]                       ...future.globals.maxSize)) {
[10:30:49.830]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.830]                       on.exit(options(oopts), add = TRUE)
[10:30:49.830]                     }
[10:30:49.830]                     {
[10:30:49.830]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.830]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.830]                         USE.NAMES = FALSE)
[10:30:49.830]                       do.call(mapply, args = args)
[10:30:49.830]                     }
[10:30:49.830]                   }
[10:30:49.830]                 }, immediateCondition = function(cond) {
[10:30:49.830]                   save_rds <- function (object, pathname, ...) 
[10:30:49.830]                   {
[10:30:49.830]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.830]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.830]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.830]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.830]                         fi_tmp[["mtime"]])
[10:30:49.830]                     }
[10:30:49.830]                     tryCatch({
[10:30:49.830]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.830]                     }, error = function(ex) {
[10:30:49.830]                       msg <- conditionMessage(ex)
[10:30:49.830]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.830]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.830]                         fi_tmp[["mtime"]], msg)
[10:30:49.830]                       ex$message <- msg
[10:30:49.830]                       stop(ex)
[10:30:49.830]                     })
[10:30:49.830]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.830]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.830]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.830]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.830]                       fi <- file.info(pathname)
[10:30:49.830]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.830]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.830]                         fi[["size"]], fi[["mtime"]])
[10:30:49.830]                       stop(msg)
[10:30:49.830]                     }
[10:30:49.830]                     invisible(pathname)
[10:30:49.830]                   }
[10:30:49.830]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.830]                     rootPath = tempdir()) 
[10:30:49.830]                   {
[10:30:49.830]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.830]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.830]                       tmpdir = path, fileext = ".rds")
[10:30:49.830]                     save_rds(obj, file)
[10:30:49.830]                   }
[10:30:49.830]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.830]                   {
[10:30:49.830]                     inherits <- base::inherits
[10:30:49.830]                     invokeRestart <- base::invokeRestart
[10:30:49.830]                     is.null <- base::is.null
[10:30:49.830]                     muffled <- FALSE
[10:30:49.830]                     if (inherits(cond, "message")) {
[10:30:49.830]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.830]                       if (muffled) 
[10:30:49.830]                         invokeRestart("muffleMessage")
[10:30:49.830]                     }
[10:30:49.830]                     else if (inherits(cond, "warning")) {
[10:30:49.830]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.830]                       if (muffled) 
[10:30:49.830]                         invokeRestart("muffleWarning")
[10:30:49.830]                     }
[10:30:49.830]                     else if (inherits(cond, "condition")) {
[10:30:49.830]                       if (!is.null(pattern)) {
[10:30:49.830]                         computeRestarts <- base::computeRestarts
[10:30:49.830]                         grepl <- base::grepl
[10:30:49.830]                         restarts <- computeRestarts(cond)
[10:30:49.830]                         for (restart in restarts) {
[10:30:49.830]                           name <- restart$name
[10:30:49.830]                           if (is.null(name)) 
[10:30:49.830]                             next
[10:30:49.830]                           if (!grepl(pattern, name)) 
[10:30:49.830]                             next
[10:30:49.830]                           invokeRestart(restart)
[10:30:49.830]                           muffled <- TRUE
[10:30:49.830]                           break
[10:30:49.830]                         }
[10:30:49.830]                       }
[10:30:49.830]                     }
[10:30:49.830]                     invisible(muffled)
[10:30:49.830]                   }
[10:30:49.830]                   muffleCondition(cond)
[10:30:49.830]                 })
[10:30:49.830]             }))
[10:30:49.830]             future::FutureResult(value = ...future.value$value, 
[10:30:49.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.830]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.830]                     ...future.globalenv.names))
[10:30:49.830]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.830]         }, condition = base::local({
[10:30:49.830]             c <- base::c
[10:30:49.830]             inherits <- base::inherits
[10:30:49.830]             invokeRestart <- base::invokeRestart
[10:30:49.830]             length <- base::length
[10:30:49.830]             list <- base::list
[10:30:49.830]             seq.int <- base::seq.int
[10:30:49.830]             signalCondition <- base::signalCondition
[10:30:49.830]             sys.calls <- base::sys.calls
[10:30:49.830]             `[[` <- base::`[[`
[10:30:49.830]             `+` <- base::`+`
[10:30:49.830]             `<<-` <- base::`<<-`
[10:30:49.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.830]                   3L)]
[10:30:49.830]             }
[10:30:49.830]             function(cond) {
[10:30:49.830]                 is_error <- inherits(cond, "error")
[10:30:49.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.830]                   NULL)
[10:30:49.830]                 if (is_error) {
[10:30:49.830]                   sessionInformation <- function() {
[10:30:49.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.830]                       search = base::search(), system = base::Sys.info())
[10:30:49.830]                   }
[10:30:49.830]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.830]                     cond$call), session = sessionInformation(), 
[10:30:49.830]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.830]                   signalCondition(cond)
[10:30:49.830]                 }
[10:30:49.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.830]                 "immediateCondition"))) {
[10:30:49.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.830]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.830]                   if (TRUE && !signal) {
[10:30:49.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.830]                     {
[10:30:49.830]                       inherits <- base::inherits
[10:30:49.830]                       invokeRestart <- base::invokeRestart
[10:30:49.830]                       is.null <- base::is.null
[10:30:49.830]                       muffled <- FALSE
[10:30:49.830]                       if (inherits(cond, "message")) {
[10:30:49.830]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.830]                         if (muffled) 
[10:30:49.830]                           invokeRestart("muffleMessage")
[10:30:49.830]                       }
[10:30:49.830]                       else if (inherits(cond, "warning")) {
[10:30:49.830]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.830]                         if (muffled) 
[10:30:49.830]                           invokeRestart("muffleWarning")
[10:30:49.830]                       }
[10:30:49.830]                       else if (inherits(cond, "condition")) {
[10:30:49.830]                         if (!is.null(pattern)) {
[10:30:49.830]                           computeRestarts <- base::computeRestarts
[10:30:49.830]                           grepl <- base::grepl
[10:30:49.830]                           restarts <- computeRestarts(cond)
[10:30:49.830]                           for (restart in restarts) {
[10:30:49.830]                             name <- restart$name
[10:30:49.830]                             if (is.null(name)) 
[10:30:49.830]                               next
[10:30:49.830]                             if (!grepl(pattern, name)) 
[10:30:49.830]                               next
[10:30:49.830]                             invokeRestart(restart)
[10:30:49.830]                             muffled <- TRUE
[10:30:49.830]                             break
[10:30:49.830]                           }
[10:30:49.830]                         }
[10:30:49.830]                       }
[10:30:49.830]                       invisible(muffled)
[10:30:49.830]                     }
[10:30:49.830]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.830]                   }
[10:30:49.830]                 }
[10:30:49.830]                 else {
[10:30:49.830]                   if (TRUE) {
[10:30:49.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.830]                     {
[10:30:49.830]                       inherits <- base::inherits
[10:30:49.830]                       invokeRestart <- base::invokeRestart
[10:30:49.830]                       is.null <- base::is.null
[10:30:49.830]                       muffled <- FALSE
[10:30:49.830]                       if (inherits(cond, "message")) {
[10:30:49.830]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.830]                         if (muffled) 
[10:30:49.830]                           invokeRestart("muffleMessage")
[10:30:49.830]                       }
[10:30:49.830]                       else if (inherits(cond, "warning")) {
[10:30:49.830]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.830]                         if (muffled) 
[10:30:49.830]                           invokeRestart("muffleWarning")
[10:30:49.830]                       }
[10:30:49.830]                       else if (inherits(cond, "condition")) {
[10:30:49.830]                         if (!is.null(pattern)) {
[10:30:49.830]                           computeRestarts <- base::computeRestarts
[10:30:49.830]                           grepl <- base::grepl
[10:30:49.830]                           restarts <- computeRestarts(cond)
[10:30:49.830]                           for (restart in restarts) {
[10:30:49.830]                             name <- restart$name
[10:30:49.830]                             if (is.null(name)) 
[10:30:49.830]                               next
[10:30:49.830]                             if (!grepl(pattern, name)) 
[10:30:49.830]                               next
[10:30:49.830]                             invokeRestart(restart)
[10:30:49.830]                             muffled <- TRUE
[10:30:49.830]                             break
[10:30:49.830]                           }
[10:30:49.830]                         }
[10:30:49.830]                       }
[10:30:49.830]                       invisible(muffled)
[10:30:49.830]                     }
[10:30:49.830]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.830]                   }
[10:30:49.830]                 }
[10:30:49.830]             }
[10:30:49.830]         }))
[10:30:49.830]     }, error = function(ex) {
[10:30:49.830]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.830]                 ...future.rng), started = ...future.startTime, 
[10:30:49.830]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.830]             version = "1.8"), class = "FutureResult")
[10:30:49.830]     }, finally = {
[10:30:49.830]         if (!identical(...future.workdir, getwd())) 
[10:30:49.830]             setwd(...future.workdir)
[10:30:49.830]         {
[10:30:49.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.830]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.830]             }
[10:30:49.830]             base::options(...future.oldOptions)
[10:30:49.830]             if (.Platform$OS.type == "windows") {
[10:30:49.830]                 old_names <- names(...future.oldEnvVars)
[10:30:49.830]                 envs <- base::Sys.getenv()
[10:30:49.830]                 names <- names(envs)
[10:30:49.830]                 common <- intersect(names, old_names)
[10:30:49.830]                 added <- setdiff(names, old_names)
[10:30:49.830]                 removed <- setdiff(old_names, names)
[10:30:49.830]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.830]                   envs[common]]
[10:30:49.830]                 NAMES <- toupper(changed)
[10:30:49.830]                 args <- list()
[10:30:49.830]                 for (kk in seq_along(NAMES)) {
[10:30:49.830]                   name <- changed[[kk]]
[10:30:49.830]                   NAME <- NAMES[[kk]]
[10:30:49.830]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.830]                     next
[10:30:49.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.830]                 }
[10:30:49.830]                 NAMES <- toupper(added)
[10:30:49.830]                 for (kk in seq_along(NAMES)) {
[10:30:49.830]                   name <- added[[kk]]
[10:30:49.830]                   NAME <- NAMES[[kk]]
[10:30:49.830]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.830]                     next
[10:30:49.830]                   args[[name]] <- ""
[10:30:49.830]                 }
[10:30:49.830]                 NAMES <- toupper(removed)
[10:30:49.830]                 for (kk in seq_along(NAMES)) {
[10:30:49.830]                   name <- removed[[kk]]
[10:30:49.830]                   NAME <- NAMES[[kk]]
[10:30:49.830]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.830]                     next
[10:30:49.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.830]                 }
[10:30:49.830]                 if (length(args) > 0) 
[10:30:49.830]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.830]             }
[10:30:49.830]             else {
[10:30:49.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.830]             }
[10:30:49.830]             {
[10:30:49.830]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.830]                   0L) {
[10:30:49.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.830]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.830]                   base::options(opts)
[10:30:49.830]                 }
[10:30:49.830]                 {
[10:30:49.830]                   {
[10:30:49.830]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.830]                     NULL
[10:30:49.830]                   }
[10:30:49.830]                   options(future.plan = NULL)
[10:30:49.830]                   if (is.na(NA_character_)) 
[10:30:49.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.830]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.830]                     .init = FALSE)
[10:30:49.830]                 }
[10:30:49.830]             }
[10:30:49.830]         }
[10:30:49.830]     })
[10:30:49.830]     if (TRUE) {
[10:30:49.830]         base::sink(type = "output", split = FALSE)
[10:30:49.830]         if (TRUE) {
[10:30:49.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.830]         }
[10:30:49.830]         else {
[10:30:49.830]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.830]         }
[10:30:49.830]         base::close(...future.stdout)
[10:30:49.830]         ...future.stdout <- NULL
[10:30:49.830]     }
[10:30:49.830]     ...future.result$conditions <- ...future.conditions
[10:30:49.830]     ...future.result$finished <- base::Sys.time()
[10:30:49.830]     ...future.result
[10:30:49.830] }
[10:30:49.833] assign_globals() ...
[10:30:49.833] List of 5
[10:30:49.833]  $ ...future.FUN            :function (C, k)  
[10:30:49.833]  $ MoreArgs                 : NULL
[10:30:49.833]  $ ...future.elements_ii    :List of 2
[10:30:49.833]   ..$ :List of 1
[10:30:49.833]   .. ..$ : chr "C"
[10:30:49.833]   ..$ :List of 1
[10:30:49.833]   .. ..$ : int 3
[10:30:49.833]  $ ...future.seeds_ii       : NULL
[10:30:49.833]  $ ...future.globals.maxSize: NULL
[10:30:49.833]  - attr(*, "where")=List of 5
[10:30:49.833]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.833]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.833]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.833]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.833]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.833]  - attr(*, "resolved")= logi FALSE
[10:30:49.833]  - attr(*, "total_size")= num 3488
[10:30:49.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.833]  - attr(*, "already-done")= logi TRUE
[10:30:49.841] - reassign environment for ‘...future.FUN’
[10:30:49.841] - copied ‘...future.FUN’ to environment
[10:30:49.841] - copied ‘MoreArgs’ to environment
[10:30:49.841] - copied ‘...future.elements_ii’ to environment
[10:30:49.841] - copied ‘...future.seeds_ii’ to environment
[10:30:49.842] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.842] assign_globals() ... done
[10:30:49.842] requestCore(): workers = 2
[10:30:49.842] Poll #1 (0): usedCores() = 2, workers = 2
[10:30:49.856] result() for MulticoreFuture ...
[10:30:49.857] result() for MulticoreFuture ...
[10:30:49.857] result() for MulticoreFuture ... done
[10:30:49.857] result() for MulticoreFuture ... done
[10:30:49.857] result() for MulticoreFuture ...
[10:30:49.858] result() for MulticoreFuture ... done
[10:30:49.861] MulticoreFuture started
[10:30:49.862] - Launch lazy future ... done
[10:30:49.863] plan(): Setting new future strategy stack:
[10:30:49.863] run() for ‘MulticoreFuture’ ... done
[10:30:49.864] Created future:
[10:30:49.863] List of future strategies:
[10:30:49.863] 1. sequential:
[10:30:49.863]    - args: function (..., envir = parent.frame())
[10:30:49.863]    - tweaked: FALSE
[10:30:49.863]    - call: NULL
[10:30:49.865] plan(): nbrOfWorkers() = 1
[10:30:49.869] plan(): Setting new future strategy stack:
[10:30:49.870] List of future strategies:
[10:30:49.870] 1. multicore:
[10:30:49.870]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.870]    - tweaked: FALSE
[10:30:49.870]    - call: plan(strategy)
[10:30:49.877] plan(): nbrOfWorkers() = 2
[10:30:49.864] MulticoreFuture:
[10:30:49.864] Label: ‘future_mapply-3’
[10:30:49.864] Expression:
[10:30:49.864] {
[10:30:49.864]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.864]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.864]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.864]         on.exit(options(oopts), add = TRUE)
[10:30:49.864]     }
[10:30:49.864]     {
[10:30:49.864]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.864]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.864]         do.call(mapply, args = args)
[10:30:49.864]     }
[10:30:49.864] }
[10:30:49.864] Lazy evaluation: FALSE
[10:30:49.864] Asynchronous evaluation: TRUE
[10:30:49.864] Local evaluation: TRUE
[10:30:49.864] Environment: R_GlobalEnv
[10:30:49.864] Capture standard output: TRUE
[10:30:49.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.864] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.864] Packages: <none>
[10:30:49.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.864] Resolved: TRUE
[10:30:49.864] Value: <not collected>
[10:30:49.864] Conditions captured: <none>
[10:30:49.864] Early signaling: FALSE
[10:30:49.864] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.864] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.878] Chunk #3 of 5 ... DONE
[10:30:49.879] Chunk #4 of 5 ...
[10:30:49.879]  - Finding globals in '...' for chunk #4 ...
[10:30:49.879] getGlobalsAndPackages() ...
[10:30:49.879] Searching for globals...
[10:30:49.880] 
[10:30:49.881] Searching for globals ... DONE
[10:30:49.881] - globals: [0] <none>
[10:30:49.881] getGlobalsAndPackages() ... DONE
[10:30:49.881]    + additional globals found: [n=0] 
[10:30:49.881]    + additional namespaces needed: [n=0] 
[10:30:49.882]  - Finding globals in '...' for chunk #4 ... DONE
[10:30:49.882]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:49.882]  - seeds: <none>
[10:30:49.882]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.883] getGlobalsAndPackages() ...
[10:30:49.883] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.883] Resolving globals: FALSE
[10:30:49.884] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:49.885] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.885] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.885] 
[10:30:49.886] getGlobalsAndPackages() ... DONE
[10:30:49.886] run() for ‘Future’ ...
[10:30:49.886] - state: ‘created’
[10:30:49.887] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.892] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.892]   - Field: ‘label’
[10:30:49.893]   - Field: ‘local’
[10:30:49.893]   - Field: ‘owner’
[10:30:49.893]   - Field: ‘envir’
[10:30:49.893]   - Field: ‘workers’
[10:30:49.893]   - Field: ‘packages’
[10:30:49.893]   - Field: ‘gc’
[10:30:49.894]   - Field: ‘job’
[10:30:49.894]   - Field: ‘conditions’
[10:30:49.894]   - Field: ‘expr’
[10:30:49.894]   - Field: ‘uuid’
[10:30:49.894]   - Field: ‘seed’
[10:30:49.894]   - Field: ‘version’
[10:30:49.894]   - Field: ‘result’
[10:30:49.895]   - Field: ‘asynchronous’
[10:30:49.895]   - Field: ‘calls’
[10:30:49.895]   - Field: ‘globals’
[10:30:49.895]   - Field: ‘stdout’
[10:30:49.895]   - Field: ‘earlySignal’
[10:30:49.895]   - Field: ‘lazy’
[10:30:49.895]   - Field: ‘state’
[10:30:49.896] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.896] - Launch lazy future ...
[10:30:49.896] Packages needed by the future expression (n = 0): <none>
[10:30:49.896] Packages needed by future strategies (n = 0): <none>
[10:30:49.897] {
[10:30:49.897]     {
[10:30:49.897]         {
[10:30:49.897]             ...future.startTime <- base::Sys.time()
[10:30:49.897]             {
[10:30:49.897]                 {
[10:30:49.897]                   {
[10:30:49.897]                     {
[10:30:49.897]                       base::local({
[10:30:49.897]                         has_future <- base::requireNamespace("future", 
[10:30:49.897]                           quietly = TRUE)
[10:30:49.897]                         if (has_future) {
[10:30:49.897]                           ns <- base::getNamespace("future")
[10:30:49.897]                           version <- ns[[".package"]][["version"]]
[10:30:49.897]                           if (is.null(version)) 
[10:30:49.897]                             version <- utils::packageVersion("future")
[10:30:49.897]                         }
[10:30:49.897]                         else {
[10:30:49.897]                           version <- NULL
[10:30:49.897]                         }
[10:30:49.897]                         if (!has_future || version < "1.8.0") {
[10:30:49.897]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.897]                             "", base::R.version$version.string), 
[10:30:49.897]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.897]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.897]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.897]                               "release", "version")], collapse = " "), 
[10:30:49.897]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.897]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.897]                             info)
[10:30:49.897]                           info <- base::paste(info, collapse = "; ")
[10:30:49.897]                           if (!has_future) {
[10:30:49.897]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.897]                               info)
[10:30:49.897]                           }
[10:30:49.897]                           else {
[10:30:49.897]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.897]                               info, version)
[10:30:49.897]                           }
[10:30:49.897]                           base::stop(msg)
[10:30:49.897]                         }
[10:30:49.897]                       })
[10:30:49.897]                     }
[10:30:49.897]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.897]                     base::options(mc.cores = 1L)
[10:30:49.897]                   }
[10:30:49.897]                   ...future.strategy.old <- future::plan("list")
[10:30:49.897]                   options(future.plan = NULL)
[10:30:49.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.897]                 }
[10:30:49.897]                 ...future.workdir <- getwd()
[10:30:49.897]             }
[10:30:49.897]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.897]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.897]         }
[10:30:49.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.897]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:49.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.897]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.897]             base::names(...future.oldOptions))
[10:30:49.897]     }
[10:30:49.897]     if (FALSE) {
[10:30:49.897]     }
[10:30:49.897]     else {
[10:30:49.897]         if (TRUE) {
[10:30:49.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.897]                 open = "w")
[10:30:49.897]         }
[10:30:49.897]         else {
[10:30:49.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.897]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.897]         }
[10:30:49.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.897]             base::sink(type = "output", split = FALSE)
[10:30:49.897]             base::close(...future.stdout)
[10:30:49.897]         }, add = TRUE)
[10:30:49.897]     }
[10:30:49.897]     ...future.frame <- base::sys.nframe()
[10:30:49.897]     ...future.conditions <- base::list()
[10:30:49.897]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.897]     if (FALSE) {
[10:30:49.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.897]     }
[10:30:49.897]     ...future.result <- base::tryCatch({
[10:30:49.897]         base::withCallingHandlers({
[10:30:49.897]             ...future.value <- base::withVisible(base::local({
[10:30:49.897]                 withCallingHandlers({
[10:30:49.897]                   {
[10:30:49.897]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.897]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.897]                       ...future.globals.maxSize)) {
[10:30:49.897]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.897]                       on.exit(options(oopts), add = TRUE)
[10:30:49.897]                     }
[10:30:49.897]                     {
[10:30:49.897]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.897]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.897]                         USE.NAMES = FALSE)
[10:30:49.897]                       do.call(mapply, args = args)
[10:30:49.897]                     }
[10:30:49.897]                   }
[10:30:49.897]                 }, immediateCondition = function(cond) {
[10:30:49.897]                   save_rds <- function (object, pathname, ...) 
[10:30:49.897]                   {
[10:30:49.897]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.897]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.897]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.897]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.897]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.897]                         fi_tmp[["mtime"]])
[10:30:49.897]                     }
[10:30:49.897]                     tryCatch({
[10:30:49.897]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.897]                     }, error = function(ex) {
[10:30:49.897]                       msg <- conditionMessage(ex)
[10:30:49.897]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.897]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.897]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.897]                         fi_tmp[["mtime"]], msg)
[10:30:49.897]                       ex$message <- msg
[10:30:49.897]                       stop(ex)
[10:30:49.897]                     })
[10:30:49.897]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.897]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.897]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.897]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.897]                       fi <- file.info(pathname)
[10:30:49.897]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.897]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.897]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.897]                         fi[["size"]], fi[["mtime"]])
[10:30:49.897]                       stop(msg)
[10:30:49.897]                     }
[10:30:49.897]                     invisible(pathname)
[10:30:49.897]                   }
[10:30:49.897]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.897]                     rootPath = tempdir()) 
[10:30:49.897]                   {
[10:30:49.897]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.897]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.897]                       tmpdir = path, fileext = ".rds")
[10:30:49.897]                     save_rds(obj, file)
[10:30:49.897]                   }
[10:30:49.897]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.897]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.897]                   {
[10:30:49.897]                     inherits <- base::inherits
[10:30:49.897]                     invokeRestart <- base::invokeRestart
[10:30:49.897]                     is.null <- base::is.null
[10:30:49.897]                     muffled <- FALSE
[10:30:49.897]                     if (inherits(cond, "message")) {
[10:30:49.897]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.897]                       if (muffled) 
[10:30:49.897]                         invokeRestart("muffleMessage")
[10:30:49.897]                     }
[10:30:49.897]                     else if (inherits(cond, "warning")) {
[10:30:49.897]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.897]                       if (muffled) 
[10:30:49.897]                         invokeRestart("muffleWarning")
[10:30:49.897]                     }
[10:30:49.897]                     else if (inherits(cond, "condition")) {
[10:30:49.897]                       if (!is.null(pattern)) {
[10:30:49.897]                         computeRestarts <- base::computeRestarts
[10:30:49.897]                         grepl <- base::grepl
[10:30:49.897]                         restarts <- computeRestarts(cond)
[10:30:49.897]                         for (restart in restarts) {
[10:30:49.897]                           name <- restart$name
[10:30:49.897]                           if (is.null(name)) 
[10:30:49.897]                             next
[10:30:49.897]                           if (!grepl(pattern, name)) 
[10:30:49.897]                             next
[10:30:49.897]                           invokeRestart(restart)
[10:30:49.897]                           muffled <- TRUE
[10:30:49.897]                           break
[10:30:49.897]                         }
[10:30:49.897]                       }
[10:30:49.897]                     }
[10:30:49.897]                     invisible(muffled)
[10:30:49.897]                   }
[10:30:49.897]                   muffleCondition(cond)
[10:30:49.897]                 })
[10:30:49.897]             }))
[10:30:49.897]             future::FutureResult(value = ...future.value$value, 
[10:30:49.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.897]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.897]                     ...future.globalenv.names))
[10:30:49.897]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.897]         }, condition = base::local({
[10:30:49.897]             c <- base::c
[10:30:49.897]             inherits <- base::inherits
[10:30:49.897]             invokeRestart <- base::invokeRestart
[10:30:49.897]             length <- base::length
[10:30:49.897]             list <- base::list
[10:30:49.897]             seq.int <- base::seq.int
[10:30:49.897]             signalCondition <- base::signalCondition
[10:30:49.897]             sys.calls <- base::sys.calls
[10:30:49.897]             `[[` <- base::`[[`
[10:30:49.897]             `+` <- base::`+`
[10:30:49.897]             `<<-` <- base::`<<-`
[10:30:49.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.897]                   3L)]
[10:30:49.897]             }
[10:30:49.897]             function(cond) {
[10:30:49.897]                 is_error <- inherits(cond, "error")
[10:30:49.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.897]                   NULL)
[10:30:49.897]                 if (is_error) {
[10:30:49.897]                   sessionInformation <- function() {
[10:30:49.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.897]                       search = base::search(), system = base::Sys.info())
[10:30:49.897]                   }
[10:30:49.897]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.897]                     cond$call), session = sessionInformation(), 
[10:30:49.897]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.897]                   signalCondition(cond)
[10:30:49.897]                 }
[10:30:49.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.897]                 "immediateCondition"))) {
[10:30:49.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.897]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.897]                   if (TRUE && !signal) {
[10:30:49.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.897]                     {
[10:30:49.897]                       inherits <- base::inherits
[10:30:49.897]                       invokeRestart <- base::invokeRestart
[10:30:49.897]                       is.null <- base::is.null
[10:30:49.897]                       muffled <- FALSE
[10:30:49.897]                       if (inherits(cond, "message")) {
[10:30:49.897]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.897]                         if (muffled) 
[10:30:49.897]                           invokeRestart("muffleMessage")
[10:30:49.897]                       }
[10:30:49.897]                       else if (inherits(cond, "warning")) {
[10:30:49.897]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.897]                         if (muffled) 
[10:30:49.897]                           invokeRestart("muffleWarning")
[10:30:49.897]                       }
[10:30:49.897]                       else if (inherits(cond, "condition")) {
[10:30:49.897]                         if (!is.null(pattern)) {
[10:30:49.897]                           computeRestarts <- base::computeRestarts
[10:30:49.897]                           grepl <- base::grepl
[10:30:49.897]                           restarts <- computeRestarts(cond)
[10:30:49.897]                           for (restart in restarts) {
[10:30:49.897]                             name <- restart$name
[10:30:49.897]                             if (is.null(name)) 
[10:30:49.897]                               next
[10:30:49.897]                             if (!grepl(pattern, name)) 
[10:30:49.897]                               next
[10:30:49.897]                             invokeRestart(restart)
[10:30:49.897]                             muffled <- TRUE
[10:30:49.897]                             break
[10:30:49.897]                           }
[10:30:49.897]                         }
[10:30:49.897]                       }
[10:30:49.897]                       invisible(muffled)
[10:30:49.897]                     }
[10:30:49.897]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.897]                   }
[10:30:49.897]                 }
[10:30:49.897]                 else {
[10:30:49.897]                   if (TRUE) {
[10:30:49.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.897]                     {
[10:30:49.897]                       inherits <- base::inherits
[10:30:49.897]                       invokeRestart <- base::invokeRestart
[10:30:49.897]                       is.null <- base::is.null
[10:30:49.897]                       muffled <- FALSE
[10:30:49.897]                       if (inherits(cond, "message")) {
[10:30:49.897]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.897]                         if (muffled) 
[10:30:49.897]                           invokeRestart("muffleMessage")
[10:30:49.897]                       }
[10:30:49.897]                       else if (inherits(cond, "warning")) {
[10:30:49.897]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.897]                         if (muffled) 
[10:30:49.897]                           invokeRestart("muffleWarning")
[10:30:49.897]                       }
[10:30:49.897]                       else if (inherits(cond, "condition")) {
[10:30:49.897]                         if (!is.null(pattern)) {
[10:30:49.897]                           computeRestarts <- base::computeRestarts
[10:30:49.897]                           grepl <- base::grepl
[10:30:49.897]                           restarts <- computeRestarts(cond)
[10:30:49.897]                           for (restart in restarts) {
[10:30:49.897]                             name <- restart$name
[10:30:49.897]                             if (is.null(name)) 
[10:30:49.897]                               next
[10:30:49.897]                             if (!grepl(pattern, name)) 
[10:30:49.897]                               next
[10:30:49.897]                             invokeRestart(restart)
[10:30:49.897]                             muffled <- TRUE
[10:30:49.897]                             break
[10:30:49.897]                           }
[10:30:49.897]                         }
[10:30:49.897]                       }
[10:30:49.897]                       invisible(muffled)
[10:30:49.897]                     }
[10:30:49.897]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.897]                   }
[10:30:49.897]                 }
[10:30:49.897]             }
[10:30:49.897]         }))
[10:30:49.897]     }, error = function(ex) {
[10:30:49.897]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.897]                 ...future.rng), started = ...future.startTime, 
[10:30:49.897]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.897]             version = "1.8"), class = "FutureResult")
[10:30:49.897]     }, finally = {
[10:30:49.897]         if (!identical(...future.workdir, getwd())) 
[10:30:49.897]             setwd(...future.workdir)
[10:30:49.897]         {
[10:30:49.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.897]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.897]             }
[10:30:49.897]             base::options(...future.oldOptions)
[10:30:49.897]             if (.Platform$OS.type == "windows") {
[10:30:49.897]                 old_names <- names(...future.oldEnvVars)
[10:30:49.897]                 envs <- base::Sys.getenv()
[10:30:49.897]                 names <- names(envs)
[10:30:49.897]                 common <- intersect(names, old_names)
[10:30:49.897]                 added <- setdiff(names, old_names)
[10:30:49.897]                 removed <- setdiff(old_names, names)
[10:30:49.897]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.897]                   envs[common]]
[10:30:49.897]                 NAMES <- toupper(changed)
[10:30:49.897]                 args <- list()
[10:30:49.897]                 for (kk in seq_along(NAMES)) {
[10:30:49.897]                   name <- changed[[kk]]
[10:30:49.897]                   NAME <- NAMES[[kk]]
[10:30:49.897]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.897]                     next
[10:30:49.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.897]                 }
[10:30:49.897]                 NAMES <- toupper(added)
[10:30:49.897]                 for (kk in seq_along(NAMES)) {
[10:30:49.897]                   name <- added[[kk]]
[10:30:49.897]                   NAME <- NAMES[[kk]]
[10:30:49.897]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.897]                     next
[10:30:49.897]                   args[[name]] <- ""
[10:30:49.897]                 }
[10:30:49.897]                 NAMES <- toupper(removed)
[10:30:49.897]                 for (kk in seq_along(NAMES)) {
[10:30:49.897]                   name <- removed[[kk]]
[10:30:49.897]                   NAME <- NAMES[[kk]]
[10:30:49.897]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.897]                     next
[10:30:49.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.897]                 }
[10:30:49.897]                 if (length(args) > 0) 
[10:30:49.897]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.897]             }
[10:30:49.897]             else {
[10:30:49.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.897]             }
[10:30:49.897]             {
[10:30:49.897]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.897]                   0L) {
[10:30:49.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.897]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.897]                   base::options(opts)
[10:30:49.897]                 }
[10:30:49.897]                 {
[10:30:49.897]                   {
[10:30:49.897]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.897]                     NULL
[10:30:49.897]                   }
[10:30:49.897]                   options(future.plan = NULL)
[10:30:49.897]                   if (is.na(NA_character_)) 
[10:30:49.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.897]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.897]                     .init = FALSE)
[10:30:49.897]                 }
[10:30:49.897]             }
[10:30:49.897]         }
[10:30:49.897]     })
[10:30:49.897]     if (TRUE) {
[10:30:49.897]         base::sink(type = "output", split = FALSE)
[10:30:49.897]         if (TRUE) {
[10:30:49.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.897]         }
[10:30:49.897]         else {
[10:30:49.897]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.897]         }
[10:30:49.897]         base::close(...future.stdout)
[10:30:49.897]         ...future.stdout <- NULL
[10:30:49.897]     }
[10:30:49.897]     ...future.result$conditions <- ...future.conditions
[10:30:49.897]     ...future.result$finished <- base::Sys.time()
[10:30:49.897]     ...future.result
[10:30:49.897] }
[10:30:49.900] assign_globals() ...
[10:30:49.900] List of 5
[10:30:49.900]  $ ...future.FUN            :function (C, k)  
[10:30:49.900]  $ MoreArgs                 : NULL
[10:30:49.900]  $ ...future.elements_ii    :List of 2
[10:30:49.900]   ..$ :List of 1
[10:30:49.900]   .. ..$ : chr "D"
[10:30:49.900]   ..$ :List of 1
[10:30:49.900]   .. ..$ : int 2
[10:30:49.900]  $ ...future.seeds_ii       : NULL
[10:30:49.900]  $ ...future.globals.maxSize: NULL
[10:30:49.900]  - attr(*, "where")=List of 5
[10:30:49.900]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.900]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.900]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.900]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.900]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.900]  - attr(*, "resolved")= logi FALSE
[10:30:49.900]  - attr(*, "total_size")= num 3488
[10:30:49.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.900]  - attr(*, "already-done")= logi TRUE
[10:30:49.907] - reassign environment for ‘...future.FUN’
[10:30:49.908] - copied ‘...future.FUN’ to environment
[10:30:49.908] - copied ‘MoreArgs’ to environment
[10:30:49.908] - copied ‘...future.elements_ii’ to environment
[10:30:49.908] - copied ‘...future.seeds_ii’ to environment
[10:30:49.908] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.908] assign_globals() ... done
[10:30:49.908] requestCore(): workers = 2
[10:30:49.909] Poll #1 (0): usedCores() = 2, workers = 2
[10:30:49.933] result() for MulticoreFuture ...
[10:30:49.933] result() for MulticoreFuture ...
[10:30:49.933] result() for MulticoreFuture ... done
[10:30:49.934] result() for MulticoreFuture ... done
[10:30:49.934] result() for MulticoreFuture ...
[10:30:49.934] result() for MulticoreFuture ... done
[10:30:49.936] MulticoreFuture started
[10:30:49.937] - Launch lazy future ... done
[10:30:49.937] run() for ‘MulticoreFuture’ ... done
[10:30:49.938] Created future:
[10:30:49.938] plan(): Setting new future strategy stack:
[10:30:49.938] List of future strategies:
[10:30:49.938] 1. sequential:
[10:30:49.938]    - args: function (..., envir = parent.frame())
[10:30:49.938]    - tweaked: FALSE
[10:30:49.938]    - call: NULL
[10:30:49.939] plan(): nbrOfWorkers() = 1
[10:30:49.942] plan(): Setting new future strategy stack:
[10:30:49.942] List of future strategies:
[10:30:49.942] 1. multicore:
[10:30:49.942]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:49.942]    - tweaked: FALSE
[10:30:49.942]    - call: plan(strategy)
[10:30:49.949] plan(): nbrOfWorkers() = 2
[10:30:49.938] MulticoreFuture:
[10:30:49.938] Label: ‘future_mapply-4’
[10:30:49.938] Expression:
[10:30:49.938] {
[10:30:49.938]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.938]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:49.938]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.938]         on.exit(options(oopts), add = TRUE)
[10:30:49.938]     }
[10:30:49.938]     {
[10:30:49.938]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.938]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:49.938]         do.call(mapply, args = args)
[10:30:49.938]     }
[10:30:49.938] }
[10:30:49.938] Lazy evaluation: FALSE
[10:30:49.938] Asynchronous evaluation: TRUE
[10:30:49.938] Local evaluation: TRUE
[10:30:49.938] Environment: R_GlobalEnv
[10:30:49.938] Capture standard output: TRUE
[10:30:49.938] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:49.938] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:49.938] Packages: <none>
[10:30:49.938] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:49.938] Resolved: TRUE
[10:30:49.938] Value: <not collected>
[10:30:49.938] Conditions captured: <none>
[10:30:49.938] Early signaling: FALSE
[10:30:49.938] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:49.938] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.950] Chunk #4 of 5 ... DONE
[10:30:49.950] Chunk #5 of 5 ...
[10:30:49.951]  - Finding globals in '...' for chunk #5 ...
[10:30:49.951] getGlobalsAndPackages() ...
[10:30:49.951] Searching for globals...
[10:30:49.952] 
[10:30:49.952] Searching for globals ... DONE
[10:30:49.952] - globals: [0] <none>
[10:30:49.952] getGlobalsAndPackages() ... DONE
[10:30:49.952]    + additional globals found: [n=0] 
[10:30:49.952]    + additional namespaces needed: [n=0] 
[10:30:49.952]  - Finding globals in '...' for chunk #5 ... DONE
[10:30:49.953]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:49.953]  - seeds: <none>
[10:30:49.953]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.953] getGlobalsAndPackages() ...
[10:30:49.953] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.954] Resolving globals: FALSE
[10:30:49.955] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:49.955] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:49.956] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:49.956] 
[10:30:49.956] getGlobalsAndPackages() ... DONE
[10:30:49.956] run() for ‘Future’ ...
[10:30:49.957] - state: ‘created’
[10:30:49.957] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:49.962] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:49.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:49.962]   - Field: ‘label’
[10:30:49.963]   - Field: ‘local’
[10:30:49.963]   - Field: ‘owner’
[10:30:49.963]   - Field: ‘envir’
[10:30:49.963]   - Field: ‘workers’
[10:30:49.963]   - Field: ‘packages’
[10:30:49.963]   - Field: ‘gc’
[10:30:49.964]   - Field: ‘job’
[10:30:49.964]   - Field: ‘conditions’
[10:30:49.964]   - Field: ‘expr’
[10:30:49.964]   - Field: ‘uuid’
[10:30:49.964]   - Field: ‘seed’
[10:30:49.964]   - Field: ‘version’
[10:30:49.965]   - Field: ‘result’
[10:30:49.965]   - Field: ‘asynchronous’
[10:30:49.965]   - Field: ‘calls’
[10:30:49.965]   - Field: ‘globals’
[10:30:49.965]   - Field: ‘stdout’
[10:30:49.965]   - Field: ‘earlySignal’
[10:30:49.965]   - Field: ‘lazy’
[10:30:49.966]   - Field: ‘state’
[10:30:49.966] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:49.966] - Launch lazy future ...
[10:30:49.966] Packages needed by the future expression (n = 0): <none>
[10:30:49.967] Packages needed by future strategies (n = 0): <none>
[10:30:49.971] {
[10:30:49.971]     {
[10:30:49.971]         {
[10:30:49.971]             ...future.startTime <- base::Sys.time()
[10:30:49.971]             {
[10:30:49.971]                 {
[10:30:49.971]                   {
[10:30:49.971]                     {
[10:30:49.971]                       base::local({
[10:30:49.971]                         has_future <- base::requireNamespace("future", 
[10:30:49.971]                           quietly = TRUE)
[10:30:49.971]                         if (has_future) {
[10:30:49.971]                           ns <- base::getNamespace("future")
[10:30:49.971]                           version <- ns[[".package"]][["version"]]
[10:30:49.971]                           if (is.null(version)) 
[10:30:49.971]                             version <- utils::packageVersion("future")
[10:30:49.971]                         }
[10:30:49.971]                         else {
[10:30:49.971]                           version <- NULL
[10:30:49.971]                         }
[10:30:49.971]                         if (!has_future || version < "1.8.0") {
[10:30:49.971]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:49.971]                             "", base::R.version$version.string), 
[10:30:49.971]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:49.971]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:49.971]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:49.971]                               "release", "version")], collapse = " "), 
[10:30:49.971]                             hostname = base::Sys.info()[["nodename"]])
[10:30:49.971]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:49.971]                             info)
[10:30:49.971]                           info <- base::paste(info, collapse = "; ")
[10:30:49.971]                           if (!has_future) {
[10:30:49.971]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:49.971]                               info)
[10:30:49.971]                           }
[10:30:49.971]                           else {
[10:30:49.971]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:49.971]                               info, version)
[10:30:49.971]                           }
[10:30:49.971]                           base::stop(msg)
[10:30:49.971]                         }
[10:30:49.971]                       })
[10:30:49.971]                     }
[10:30:49.971]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:49.971]                     base::options(mc.cores = 1L)
[10:30:49.971]                   }
[10:30:49.971]                   ...future.strategy.old <- future::plan("list")
[10:30:49.971]                   options(future.plan = NULL)
[10:30:49.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:49.971]                 }
[10:30:49.971]                 ...future.workdir <- getwd()
[10:30:49.971]             }
[10:30:49.971]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:49.971]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:49.971]         }
[10:30:49.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:49.971]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:49.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:49.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:49.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:49.971]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:49.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:49.971]             base::names(...future.oldOptions))
[10:30:49.971]     }
[10:30:49.971]     if (FALSE) {
[10:30:49.971]     }
[10:30:49.971]     else {
[10:30:49.971]         if (TRUE) {
[10:30:49.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:49.971]                 open = "w")
[10:30:49.971]         }
[10:30:49.971]         else {
[10:30:49.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:49.971]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:49.971]         }
[10:30:49.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:49.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:49.971]             base::sink(type = "output", split = FALSE)
[10:30:49.971]             base::close(...future.stdout)
[10:30:49.971]         }, add = TRUE)
[10:30:49.971]     }
[10:30:49.971]     ...future.frame <- base::sys.nframe()
[10:30:49.971]     ...future.conditions <- base::list()
[10:30:49.971]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:49.971]     if (FALSE) {
[10:30:49.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:49.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:49.971]     }
[10:30:49.971]     ...future.result <- base::tryCatch({
[10:30:49.971]         base::withCallingHandlers({
[10:30:49.971]             ...future.value <- base::withVisible(base::local({
[10:30:49.971]                 withCallingHandlers({
[10:30:49.971]                   {
[10:30:49.971]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:49.971]                     if (!identical(...future.globals.maxSize.org, 
[10:30:49.971]                       ...future.globals.maxSize)) {
[10:30:49.971]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:49.971]                       on.exit(options(oopts), add = TRUE)
[10:30:49.971]                     }
[10:30:49.971]                     {
[10:30:49.971]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:49.971]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:49.971]                         USE.NAMES = FALSE)
[10:30:49.971]                       do.call(mapply, args = args)
[10:30:49.971]                     }
[10:30:49.971]                   }
[10:30:49.971]                 }, immediateCondition = function(cond) {
[10:30:49.971]                   save_rds <- function (object, pathname, ...) 
[10:30:49.971]                   {
[10:30:49.971]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:49.971]                     if (file_test("-f", pathname_tmp)) {
[10:30:49.971]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.971]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:49.971]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.971]                         fi_tmp[["mtime"]])
[10:30:49.971]                     }
[10:30:49.971]                     tryCatch({
[10:30:49.971]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:49.971]                     }, error = function(ex) {
[10:30:49.971]                       msg <- conditionMessage(ex)
[10:30:49.971]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.971]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:49.971]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.971]                         fi_tmp[["mtime"]], msg)
[10:30:49.971]                       ex$message <- msg
[10:30:49.971]                       stop(ex)
[10:30:49.971]                     })
[10:30:49.971]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:49.971]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:49.971]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:49.971]                       fi_tmp <- file.info(pathname_tmp)
[10:30:49.971]                       fi <- file.info(pathname)
[10:30:49.971]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:49.971]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:49.971]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:49.971]                         fi[["size"]], fi[["mtime"]])
[10:30:49.971]                       stop(msg)
[10:30:49.971]                     }
[10:30:49.971]                     invisible(pathname)
[10:30:49.971]                   }
[10:30:49.971]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:49.971]                     rootPath = tempdir()) 
[10:30:49.971]                   {
[10:30:49.971]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:49.971]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:49.971]                       tmpdir = path, fileext = ".rds")
[10:30:49.971]                     save_rds(obj, file)
[10:30:49.971]                   }
[10:30:49.971]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:49.971]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.971]                   {
[10:30:49.971]                     inherits <- base::inherits
[10:30:49.971]                     invokeRestart <- base::invokeRestart
[10:30:49.971]                     is.null <- base::is.null
[10:30:49.971]                     muffled <- FALSE
[10:30:49.971]                     if (inherits(cond, "message")) {
[10:30:49.971]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:49.971]                       if (muffled) 
[10:30:49.971]                         invokeRestart("muffleMessage")
[10:30:49.971]                     }
[10:30:49.971]                     else if (inherits(cond, "warning")) {
[10:30:49.971]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:49.971]                       if (muffled) 
[10:30:49.971]                         invokeRestart("muffleWarning")
[10:30:49.971]                     }
[10:30:49.971]                     else if (inherits(cond, "condition")) {
[10:30:49.971]                       if (!is.null(pattern)) {
[10:30:49.971]                         computeRestarts <- base::computeRestarts
[10:30:49.971]                         grepl <- base::grepl
[10:30:49.971]                         restarts <- computeRestarts(cond)
[10:30:49.971]                         for (restart in restarts) {
[10:30:49.971]                           name <- restart$name
[10:30:49.971]                           if (is.null(name)) 
[10:30:49.971]                             next
[10:30:49.971]                           if (!grepl(pattern, name)) 
[10:30:49.971]                             next
[10:30:49.971]                           invokeRestart(restart)
[10:30:49.971]                           muffled <- TRUE
[10:30:49.971]                           break
[10:30:49.971]                         }
[10:30:49.971]                       }
[10:30:49.971]                     }
[10:30:49.971]                     invisible(muffled)
[10:30:49.971]                   }
[10:30:49.971]                   muffleCondition(cond)
[10:30:49.971]                 })
[10:30:49.971]             }))
[10:30:49.971]             future::FutureResult(value = ...future.value$value, 
[10:30:49.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.971]                   ...future.rng), globalenv = if (FALSE) 
[10:30:49.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:49.971]                     ...future.globalenv.names))
[10:30:49.971]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:49.971]         }, condition = base::local({
[10:30:49.971]             c <- base::c
[10:30:49.971]             inherits <- base::inherits
[10:30:49.971]             invokeRestart <- base::invokeRestart
[10:30:49.971]             length <- base::length
[10:30:49.971]             list <- base::list
[10:30:49.971]             seq.int <- base::seq.int
[10:30:49.971]             signalCondition <- base::signalCondition
[10:30:49.971]             sys.calls <- base::sys.calls
[10:30:49.971]             `[[` <- base::`[[`
[10:30:49.971]             `+` <- base::`+`
[10:30:49.971]             `<<-` <- base::`<<-`
[10:30:49.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:49.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:49.971]                   3L)]
[10:30:49.971]             }
[10:30:49.971]             function(cond) {
[10:30:49.971]                 is_error <- inherits(cond, "error")
[10:30:49.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:49.971]                   NULL)
[10:30:49.971]                 if (is_error) {
[10:30:49.971]                   sessionInformation <- function() {
[10:30:49.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:49.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:49.971]                       search = base::search(), system = base::Sys.info())
[10:30:49.971]                   }
[10:30:49.971]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:49.971]                     cond$call), session = sessionInformation(), 
[10:30:49.971]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:49.971]                   signalCondition(cond)
[10:30:49.971]                 }
[10:30:49.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:49.971]                 "immediateCondition"))) {
[10:30:49.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:49.971]                   ...future.conditions[[length(...future.conditions) + 
[10:30:49.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:49.971]                   if (TRUE && !signal) {
[10:30:49.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.971]                     {
[10:30:49.971]                       inherits <- base::inherits
[10:30:49.971]                       invokeRestart <- base::invokeRestart
[10:30:49.971]                       is.null <- base::is.null
[10:30:49.971]                       muffled <- FALSE
[10:30:49.971]                       if (inherits(cond, "message")) {
[10:30:49.971]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.971]                         if (muffled) 
[10:30:49.971]                           invokeRestart("muffleMessage")
[10:30:49.971]                       }
[10:30:49.971]                       else if (inherits(cond, "warning")) {
[10:30:49.971]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.971]                         if (muffled) 
[10:30:49.971]                           invokeRestart("muffleWarning")
[10:30:49.971]                       }
[10:30:49.971]                       else if (inherits(cond, "condition")) {
[10:30:49.971]                         if (!is.null(pattern)) {
[10:30:49.971]                           computeRestarts <- base::computeRestarts
[10:30:49.971]                           grepl <- base::grepl
[10:30:49.971]                           restarts <- computeRestarts(cond)
[10:30:49.971]                           for (restart in restarts) {
[10:30:49.971]                             name <- restart$name
[10:30:49.971]                             if (is.null(name)) 
[10:30:49.971]                               next
[10:30:49.971]                             if (!grepl(pattern, name)) 
[10:30:49.971]                               next
[10:30:49.971]                             invokeRestart(restart)
[10:30:49.971]                             muffled <- TRUE
[10:30:49.971]                             break
[10:30:49.971]                           }
[10:30:49.971]                         }
[10:30:49.971]                       }
[10:30:49.971]                       invisible(muffled)
[10:30:49.971]                     }
[10:30:49.971]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.971]                   }
[10:30:49.971]                 }
[10:30:49.971]                 else {
[10:30:49.971]                   if (TRUE) {
[10:30:49.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:49.971]                     {
[10:30:49.971]                       inherits <- base::inherits
[10:30:49.971]                       invokeRestart <- base::invokeRestart
[10:30:49.971]                       is.null <- base::is.null
[10:30:49.971]                       muffled <- FALSE
[10:30:49.971]                       if (inherits(cond, "message")) {
[10:30:49.971]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:49.971]                         if (muffled) 
[10:30:49.971]                           invokeRestart("muffleMessage")
[10:30:49.971]                       }
[10:30:49.971]                       else if (inherits(cond, "warning")) {
[10:30:49.971]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:49.971]                         if (muffled) 
[10:30:49.971]                           invokeRestart("muffleWarning")
[10:30:49.971]                       }
[10:30:49.971]                       else if (inherits(cond, "condition")) {
[10:30:49.971]                         if (!is.null(pattern)) {
[10:30:49.971]                           computeRestarts <- base::computeRestarts
[10:30:49.971]                           grepl <- base::grepl
[10:30:49.971]                           restarts <- computeRestarts(cond)
[10:30:49.971]                           for (restart in restarts) {
[10:30:49.971]                             name <- restart$name
[10:30:49.971]                             if (is.null(name)) 
[10:30:49.971]                               next
[10:30:49.971]                             if (!grepl(pattern, name)) 
[10:30:49.971]                               next
[10:30:49.971]                             invokeRestart(restart)
[10:30:49.971]                             muffled <- TRUE
[10:30:49.971]                             break
[10:30:49.971]                           }
[10:30:49.971]                         }
[10:30:49.971]                       }
[10:30:49.971]                       invisible(muffled)
[10:30:49.971]                     }
[10:30:49.971]                     muffleCondition(cond, pattern = "^muffle")
[10:30:49.971]                   }
[10:30:49.971]                 }
[10:30:49.971]             }
[10:30:49.971]         }))
[10:30:49.971]     }, error = function(ex) {
[10:30:49.971]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:49.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:49.971]                 ...future.rng), started = ...future.startTime, 
[10:30:49.971]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:49.971]             version = "1.8"), class = "FutureResult")
[10:30:49.971]     }, finally = {
[10:30:49.971]         if (!identical(...future.workdir, getwd())) 
[10:30:49.971]             setwd(...future.workdir)
[10:30:49.971]         {
[10:30:49.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:49.971]                 ...future.oldOptions$nwarnings <- NULL
[10:30:49.971]             }
[10:30:49.971]             base::options(...future.oldOptions)
[10:30:49.971]             if (.Platform$OS.type == "windows") {
[10:30:49.971]                 old_names <- names(...future.oldEnvVars)
[10:30:49.971]                 envs <- base::Sys.getenv()
[10:30:49.971]                 names <- names(envs)
[10:30:49.971]                 common <- intersect(names, old_names)
[10:30:49.971]                 added <- setdiff(names, old_names)
[10:30:49.971]                 removed <- setdiff(old_names, names)
[10:30:49.971]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:49.971]                   envs[common]]
[10:30:49.971]                 NAMES <- toupper(changed)
[10:30:49.971]                 args <- list()
[10:30:49.971]                 for (kk in seq_along(NAMES)) {
[10:30:49.971]                   name <- changed[[kk]]
[10:30:49.971]                   NAME <- NAMES[[kk]]
[10:30:49.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.971]                     next
[10:30:49.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.971]                 }
[10:30:49.971]                 NAMES <- toupper(added)
[10:30:49.971]                 for (kk in seq_along(NAMES)) {
[10:30:49.971]                   name <- added[[kk]]
[10:30:49.971]                   NAME <- NAMES[[kk]]
[10:30:49.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.971]                     next
[10:30:49.971]                   args[[name]] <- ""
[10:30:49.971]                 }
[10:30:49.971]                 NAMES <- toupper(removed)
[10:30:49.971]                 for (kk in seq_along(NAMES)) {
[10:30:49.971]                   name <- removed[[kk]]
[10:30:49.971]                   NAME <- NAMES[[kk]]
[10:30:49.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:49.971]                     next
[10:30:49.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:49.971]                 }
[10:30:49.971]                 if (length(args) > 0) 
[10:30:49.971]                   base::do.call(base::Sys.setenv, args = args)
[10:30:49.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:49.971]             }
[10:30:49.971]             else {
[10:30:49.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:49.971]             }
[10:30:49.971]             {
[10:30:49.971]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:49.971]                   0L) {
[10:30:49.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:49.971]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:49.971]                   base::options(opts)
[10:30:49.971]                 }
[10:30:49.971]                 {
[10:30:49.971]                   {
[10:30:49.971]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:49.971]                     NULL
[10:30:49.971]                   }
[10:30:49.971]                   options(future.plan = NULL)
[10:30:49.971]                   if (is.na(NA_character_)) 
[10:30:49.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:49.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:49.971]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:49.971]                     .init = FALSE)
[10:30:49.971]                 }
[10:30:49.971]             }
[10:30:49.971]         }
[10:30:49.971]     })
[10:30:49.971]     if (TRUE) {
[10:30:49.971]         base::sink(type = "output", split = FALSE)
[10:30:49.971]         if (TRUE) {
[10:30:49.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:49.971]         }
[10:30:49.971]         else {
[10:30:49.971]             ...future.result["stdout"] <- base::list(NULL)
[10:30:49.971]         }
[10:30:49.971]         base::close(...future.stdout)
[10:30:49.971]         ...future.stdout <- NULL
[10:30:49.971]     }
[10:30:49.971]     ...future.result$conditions <- ...future.conditions
[10:30:49.971]     ...future.result$finished <- base::Sys.time()
[10:30:49.971]     ...future.result
[10:30:49.971] }
[10:30:49.975] assign_globals() ...
[10:30:49.975] List of 5
[10:30:49.975]  $ ...future.FUN            :function (C, k)  
[10:30:49.975]  $ MoreArgs                 : NULL
[10:30:49.975]  $ ...future.elements_ii    :List of 2
[10:30:49.975]   ..$ :List of 1
[10:30:49.975]   .. ..$ : chr "E"
[10:30:49.975]   ..$ :List of 1
[10:30:49.975]   .. ..$ : int 1
[10:30:49.975]  $ ...future.seeds_ii       : NULL
[10:30:49.975]  $ ...future.globals.maxSize: NULL
[10:30:49.975]  - attr(*, "where")=List of 5
[10:30:49.975]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:49.975]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:49.975]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:49.975]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:49.975]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:49.975]  - attr(*, "resolved")= logi FALSE
[10:30:49.975]  - attr(*, "total_size")= num 3488
[10:30:49.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:49.975]  - attr(*, "already-done")= logi TRUE
[10:30:49.986] - reassign environment for ‘...future.FUN’
[10:30:49.986] - copied ‘...future.FUN’ to environment
[10:30:49.986] - copied ‘MoreArgs’ to environment
[10:30:49.986] - copied ‘...future.elements_ii’ to environment
[10:30:49.986] - copied ‘...future.seeds_ii’ to environment
[10:30:49.987] - copied ‘...future.globals.maxSize’ to environment
[10:30:49.987] assign_globals() ... done
[10:30:49.987] requestCore(): workers = 2
[10:30:49.987] Poll #1 (0): usedCores() = 2, workers = 2
[10:30:49.998] result() for MulticoreFuture ...
[10:30:49.999] result() for MulticoreFuture ...
[10:30:49.999] result() for MulticoreFuture ... done
[10:30:50.000] result() for MulticoreFuture ... done
[10:30:50.000] result() for MulticoreFuture ...
[10:30:50.000] result() for MulticoreFuture ... done
[10:30:50.003] MulticoreFuture started
[10:30:50.004] - Launch lazy future ... done
[10:30:50.004] run() for ‘MulticoreFuture’ ... done
[10:30:50.004] plan(): Setting new future strategy stack:
[10:30:50.004] Created future:
[10:30:50.004] List of future strategies:
[10:30:50.004] 1. sequential:
[10:30:50.004]    - args: function (..., envir = parent.frame())
[10:30:50.004]    - tweaked: FALSE
[10:30:50.004]    - call: NULL
[10:30:50.005] plan(): nbrOfWorkers() = 1
[10:30:50.008] plan(): Setting new future strategy stack:
[10:30:50.008] List of future strategies:
[10:30:50.008] 1. multicore:
[10:30:50.008]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.008]    - tweaked: FALSE
[10:30:50.008]    - call: plan(strategy)
[10:30:50.013] plan(): nbrOfWorkers() = 2
[10:30:50.005] MulticoreFuture:
[10:30:50.005] Label: ‘future_mapply-5’
[10:30:50.005] Expression:
[10:30:50.005] {
[10:30:50.005]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.005]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.005]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.005]         on.exit(options(oopts), add = TRUE)
[10:30:50.005]     }
[10:30:50.005]     {
[10:30:50.005]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.005]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.005]         do.call(mapply, args = args)
[10:30:50.005]     }
[10:30:50.005] }
[10:30:50.005] Lazy evaluation: FALSE
[10:30:50.005] Asynchronous evaluation: TRUE
[10:30:50.005] Local evaluation: TRUE
[10:30:50.005] Environment: R_GlobalEnv
[10:30:50.005] Capture standard output: TRUE
[10:30:50.005] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.005] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.005] Packages: <none>
[10:30:50.005] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.005] Resolved: TRUE
[10:30:50.005] Value: <not collected>
[10:30:50.005] Conditions captured: <none>
[10:30:50.005] Early signaling: FALSE
[10:30:50.005] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.005] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.014] Chunk #5 of 5 ... DONE
[10:30:50.015] Launching 5 futures (chunks) ... DONE
[10:30:50.015] Resolving 5 futures (chunks) ...
[10:30:50.015] resolve() on list ...
[10:30:50.015]  recursive: 0
[10:30:50.015]  length: 5
[10:30:50.015] 
[10:30:50.016] Future #1
[10:30:50.016] result() for MulticoreFuture ...
[10:30:50.016] result() for MulticoreFuture ... done
[10:30:50.016] result() for MulticoreFuture ...
[10:30:50.016] result() for MulticoreFuture ... done
[10:30:50.016] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:50.016] - nx: 5
[10:30:50.017] - relay: TRUE
[10:30:50.017] - stdout: TRUE
[10:30:50.017] - signal: TRUE
[10:30:50.017] - resignal: FALSE
[10:30:50.017] - force: TRUE
[10:30:50.017] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:30:50.017] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:30:50.018]  - until=1
[10:30:50.018]  - relaying element #1
[10:30:50.018] result() for MulticoreFuture ...
[10:30:50.018] result() for MulticoreFuture ... done
[10:30:50.018] result() for MulticoreFuture ...
[10:30:50.018] result() for MulticoreFuture ... done
[10:30:50.019] result() for MulticoreFuture ...
[10:30:50.019] result() for MulticoreFuture ... done
[10:30:50.019] result() for MulticoreFuture ...
[10:30:50.019] result() for MulticoreFuture ... done
[10:30:50.019] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:50.019] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:50.020] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:50.020]  length: 4 (resolved future 1)
[10:30:50.020] Future #2
[10:30:50.020] result() for MulticoreFuture ...
[10:30:50.020] result() for MulticoreFuture ... done
[10:30:50.020] result() for MulticoreFuture ...
[10:30:50.021] result() for MulticoreFuture ... done
[10:30:50.021] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:50.021] - nx: 5
[10:30:50.021] - relay: TRUE
[10:30:50.021] - stdout: TRUE
[10:30:50.021] - signal: TRUE
[10:30:50.022] - resignal: FALSE
[10:30:50.022] - force: TRUE
[10:30:50.022] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:50.022] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:50.022]  - until=2
[10:30:50.022]  - relaying element #2
[10:30:50.022] result() for MulticoreFuture ...
[10:30:50.022] result() for MulticoreFuture ... done
[10:30:50.023] result() for MulticoreFuture ...
[10:30:50.023] result() for MulticoreFuture ... done
[10:30:50.023] result() for MulticoreFuture ...
[10:30:50.023] result() for MulticoreFuture ... done
[10:30:50.023] result() for MulticoreFuture ...
[10:30:50.024] result() for MulticoreFuture ... done
[10:30:50.024] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:50.024] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:50.024] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:50.024]  length: 3 (resolved future 2)
[10:30:50.024] Future #3
[10:30:50.024] result() for MulticoreFuture ...
[10:30:50.025] result() for MulticoreFuture ... done
[10:30:50.025] result() for MulticoreFuture ...
[10:30:50.025] result() for MulticoreFuture ... done
[10:30:50.025] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:30:50.025] - nx: 5
[10:30:50.025] - relay: TRUE
[10:30:50.026] - stdout: TRUE
[10:30:50.026] - signal: TRUE
[10:30:50.026] - resignal: FALSE
[10:30:50.026] - force: TRUE
[10:30:50.026] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:50.026] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:50.026]  - until=3
[10:30:50.026]  - relaying element #3
[10:30:50.027] result() for MulticoreFuture ...
[10:30:50.027] result() for MulticoreFuture ... done
[10:30:50.027] result() for MulticoreFuture ...
[10:30:50.027] result() for MulticoreFuture ... done
[10:30:50.027] result() for MulticoreFuture ...
[10:30:50.027] result() for MulticoreFuture ... done
[10:30:50.028] result() for MulticoreFuture ...
[10:30:50.028] result() for MulticoreFuture ... done
[10:30:50.028] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:50.028] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:50.032] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:30:50.032]  length: 2 (resolved future 3)
[10:30:50.032] Future #4
[10:30:50.033] result() for MulticoreFuture ...
[10:30:50.034] result() for MulticoreFuture ...
[10:30:50.034] result() for MulticoreFuture ... done
[10:30:50.035] result() for MulticoreFuture ... done
[10:30:50.035] result() for MulticoreFuture ...
[10:30:50.035] result() for MulticoreFuture ... done
[10:30:50.035] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:30:50.036] - nx: 5
[10:30:50.036] - relay: TRUE
[10:30:50.036] - stdout: TRUE
[10:30:50.036] - signal: TRUE
[10:30:50.036] - resignal: FALSE
[10:30:50.037] - force: TRUE
[10:30:50.037] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:50.037] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:50.037]  - until=4
[10:30:50.038]  - relaying element #4
[10:30:50.038] result() for MulticoreFuture ...
[10:30:50.038] result() for MulticoreFuture ... done
[10:30:50.038] result() for MulticoreFuture ...
[10:30:50.038] result() for MulticoreFuture ... done
[10:30:50.039] result() for MulticoreFuture ...
[10:30:50.039] result() for MulticoreFuture ... done
[10:30:50.039] result() for MulticoreFuture ...
[10:30:50.039] result() for MulticoreFuture ... done
[10:30:50.040] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:50.040] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:50.040] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:30:50.040]  length: 1 (resolved future 4)
[10:30:50.041] Future #5
[10:30:50.041] result() for MulticoreFuture ...
[10:30:50.042] result() for MulticoreFuture ...
[10:30:50.042] result() for MulticoreFuture ... done
[10:30:50.042] result() for MulticoreFuture ... done
[10:30:50.042] result() for MulticoreFuture ...
[10:30:50.042] result() for MulticoreFuture ... done
[10:30:50.043] signalConditionsASAP(MulticoreFuture, pos=5) ...
[10:30:50.043] - nx: 5
[10:30:50.043] - relay: TRUE
[10:30:50.043] - stdout: TRUE
[10:30:50.043] - signal: TRUE
[10:30:50.043] - resignal: FALSE
[10:30:50.043] - force: TRUE
[10:30:50.043] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:50.043] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:50.044]  - until=5
[10:30:50.044]  - relaying element #5
[10:30:50.044] result() for MulticoreFuture ...
[10:30:50.044] result() for MulticoreFuture ... done
[10:30:50.044] result() for MulticoreFuture ...
[10:30:50.044] result() for MulticoreFuture ... done
[10:30:50.044] result() for MulticoreFuture ...
[10:30:50.045] result() for MulticoreFuture ... done
[10:30:50.045] result() for MulticoreFuture ...
[10:30:50.045] result() for MulticoreFuture ... done
[10:30:50.045] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:50.045] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:50.045] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[10:30:50.045]  length: 0 (resolved future 5)
[10:30:50.045] Relaying remaining futures
[10:30:50.046] signalConditionsASAP(NULL, pos=0) ...
[10:30:50.046] - nx: 5
[10:30:50.046] - relay: TRUE
[10:30:50.046] - stdout: TRUE
[10:30:50.046] - signal: TRUE
[10:30:50.046] - resignal: FALSE
[10:30:50.046] - force: TRUE
[10:30:50.046] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:50.046] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[10:30:50.047] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:50.047] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:50.047] signalConditionsASAP(NULL, pos=0) ... done
[10:30:50.047] resolve() on list ... DONE
[10:30:50.047] result() for MulticoreFuture ...
[10:30:50.047] result() for MulticoreFuture ... done
[10:30:50.047] result() for MulticoreFuture ...
[10:30:50.047] result() for MulticoreFuture ... done
[10:30:50.047] result() for MulticoreFuture ...
[10:30:50.047] result() for MulticoreFuture ... done
[10:30:50.048] result() for MulticoreFuture ...
[10:30:50.048] result() for MulticoreFuture ... done
[10:30:50.048] result() for MulticoreFuture ...
[10:30:50.048] result() for MulticoreFuture ... done
[10:30:50.048] result() for MulticoreFuture ...
[10:30:50.048] result() for MulticoreFuture ... done
[10:30:50.048] result() for MulticoreFuture ...
[10:30:50.048] result() for MulticoreFuture ... done
[10:30:50.048] result() for MulticoreFuture ...
[10:30:50.048] result() for MulticoreFuture ... done
[10:30:50.049] result() for MulticoreFuture ...
[10:30:50.049] result() for MulticoreFuture ... done
[10:30:50.049] result() for MulticoreFuture ...
[10:30:50.049] result() for MulticoreFuture ... done
[10:30:50.049]  - Number of value chunks collected: 5
[10:30:50.049] Resolving 5 futures (chunks) ... DONE
[10:30:50.049] Reducing values from 5 chunks ...
[10:30:50.049]  - Number of values collected after concatenation: 5
[10:30:50.049]  - Number of values expected: 5
[10:30:50.049] Reducing values from 5 chunks ... DONE
[10:30:50.050] future_mapply() ... DONE
[10:30:50.050] future_mapply() ...
[10:30:50.054] Number of chunks: 2
[10:30:50.054] getGlobalsAndPackagesXApply() ...
[10:30:50.055]  - future.globals: TRUE
[10:30:50.055] getGlobalsAndPackages() ...
[10:30:50.055] Searching for globals...
[10:30:50.056] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:50.056] Searching for globals ... DONE
[10:30:50.056] Resolving globals: FALSE
[10:30:50.057] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:50.057] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:50.057] - globals: [1] ‘FUN’
[10:30:50.057] 
[10:30:50.058] getGlobalsAndPackages() ... DONE
[10:30:50.058]  - globals found/used: [n=1] ‘FUN’
[10:30:50.058]  - needed namespaces: [n=0] 
[10:30:50.058] Finding globals ... DONE
[10:30:50.058] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:50.058] List of 2
[10:30:50.058]  $ ...future.FUN:function (C, k)  
[10:30:50.058]  $ MoreArgs     : list()
[10:30:50.058]  - attr(*, "where")=List of 2
[10:30:50.058]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:50.058]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:50.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.058]  - attr(*, "resolved")= logi FALSE
[10:30:50.058]  - attr(*, "total_size")= num NA
[10:30:50.061] Packages to be attached in all futures: [n=0] 
[10:30:50.063] getGlobalsAndPackagesXApply() ... DONE
[10:30:50.063] Number of futures (= number of chunks): 2
[10:30:50.064] Launching 2 futures (chunks) ...
[10:30:50.064] Chunk #1 of 2 ...
[10:30:50.064]  - Finding globals in '...' for chunk #1 ...
[10:30:50.064] getGlobalsAndPackages() ...
[10:30:50.064] Searching for globals...
[10:30:50.064] 
[10:30:50.065] Searching for globals ... DONE
[10:30:50.065] - globals: [0] <none>
[10:30:50.065] getGlobalsAndPackages() ... DONE
[10:30:50.065]    + additional globals found: [n=0] 
[10:30:50.065]    + additional namespaces needed: [n=0] 
[10:30:50.065]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:50.065]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:50.065]  - seeds: <none>
[10:30:50.066]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.066] getGlobalsAndPackages() ...
[10:30:50.066] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.066] Resolving globals: FALSE
[10:30:50.067] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:50.067] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:50.067] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.067] 
[10:30:50.068] getGlobalsAndPackages() ... DONE
[10:30:50.068] run() for ‘Future’ ...
[10:30:50.068] - state: ‘created’
[10:30:50.068] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.072] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.072] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.073]   - Field: ‘label’
[10:30:50.073]   - Field: ‘local’
[10:30:50.073]   - Field: ‘owner’
[10:30:50.073]   - Field: ‘envir’
[10:30:50.073]   - Field: ‘workers’
[10:30:50.073]   - Field: ‘packages’
[10:30:50.073]   - Field: ‘gc’
[10:30:50.073]   - Field: ‘job’
[10:30:50.073]   - Field: ‘conditions’
[10:30:50.074]   - Field: ‘expr’
[10:30:50.074]   - Field: ‘uuid’
[10:30:50.074]   - Field: ‘seed’
[10:30:50.074]   - Field: ‘version’
[10:30:50.074]   - Field: ‘result’
[10:30:50.074]   - Field: ‘asynchronous’
[10:30:50.074]   - Field: ‘calls’
[10:30:50.074]   - Field: ‘globals’
[10:30:50.074]   - Field: ‘stdout’
[10:30:50.074]   - Field: ‘earlySignal’
[10:30:50.074]   - Field: ‘lazy’
[10:30:50.075]   - Field: ‘state’
[10:30:50.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.075] - Launch lazy future ...
[10:30:50.075] Packages needed by the future expression (n = 0): <none>
[10:30:50.075] Packages needed by future strategies (n = 0): <none>
[10:30:50.076] {
[10:30:50.076]     {
[10:30:50.076]         {
[10:30:50.076]             ...future.startTime <- base::Sys.time()
[10:30:50.076]             {
[10:30:50.076]                 {
[10:30:50.076]                   {
[10:30:50.076]                     {
[10:30:50.076]                       base::local({
[10:30:50.076]                         has_future <- base::requireNamespace("future", 
[10:30:50.076]                           quietly = TRUE)
[10:30:50.076]                         if (has_future) {
[10:30:50.076]                           ns <- base::getNamespace("future")
[10:30:50.076]                           version <- ns[[".package"]][["version"]]
[10:30:50.076]                           if (is.null(version)) 
[10:30:50.076]                             version <- utils::packageVersion("future")
[10:30:50.076]                         }
[10:30:50.076]                         else {
[10:30:50.076]                           version <- NULL
[10:30:50.076]                         }
[10:30:50.076]                         if (!has_future || version < "1.8.0") {
[10:30:50.076]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.076]                             "", base::R.version$version.string), 
[10:30:50.076]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.076]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.076]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.076]                               "release", "version")], collapse = " "), 
[10:30:50.076]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.076]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.076]                             info)
[10:30:50.076]                           info <- base::paste(info, collapse = "; ")
[10:30:50.076]                           if (!has_future) {
[10:30:50.076]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.076]                               info)
[10:30:50.076]                           }
[10:30:50.076]                           else {
[10:30:50.076]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.076]                               info, version)
[10:30:50.076]                           }
[10:30:50.076]                           base::stop(msg)
[10:30:50.076]                         }
[10:30:50.076]                       })
[10:30:50.076]                     }
[10:30:50.076]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.076]                     base::options(mc.cores = 1L)
[10:30:50.076]                   }
[10:30:50.076]                   ...future.strategy.old <- future::plan("list")
[10:30:50.076]                   options(future.plan = NULL)
[10:30:50.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.076]                 }
[10:30:50.076]                 ...future.workdir <- getwd()
[10:30:50.076]             }
[10:30:50.076]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.076]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.076]         }
[10:30:50.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.076]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:50.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.076]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.076]             base::names(...future.oldOptions))
[10:30:50.076]     }
[10:30:50.076]     if (FALSE) {
[10:30:50.076]     }
[10:30:50.076]     else {
[10:30:50.076]         if (TRUE) {
[10:30:50.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.076]                 open = "w")
[10:30:50.076]         }
[10:30:50.076]         else {
[10:30:50.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.076]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.076]         }
[10:30:50.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.076]             base::sink(type = "output", split = FALSE)
[10:30:50.076]             base::close(...future.stdout)
[10:30:50.076]         }, add = TRUE)
[10:30:50.076]     }
[10:30:50.076]     ...future.frame <- base::sys.nframe()
[10:30:50.076]     ...future.conditions <- base::list()
[10:30:50.076]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.076]     if (FALSE) {
[10:30:50.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.076]     }
[10:30:50.076]     ...future.result <- base::tryCatch({
[10:30:50.076]         base::withCallingHandlers({
[10:30:50.076]             ...future.value <- base::withVisible(base::local({
[10:30:50.076]                 withCallingHandlers({
[10:30:50.076]                   {
[10:30:50.076]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.076]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.076]                       ...future.globals.maxSize)) {
[10:30:50.076]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.076]                       on.exit(options(oopts), add = TRUE)
[10:30:50.076]                     }
[10:30:50.076]                     {
[10:30:50.076]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.076]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.076]                         USE.NAMES = FALSE)
[10:30:50.076]                       do.call(mapply, args = args)
[10:30:50.076]                     }
[10:30:50.076]                   }
[10:30:50.076]                 }, immediateCondition = function(cond) {
[10:30:50.076]                   save_rds <- function (object, pathname, ...) 
[10:30:50.076]                   {
[10:30:50.076]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.076]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.076]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.076]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.076]                         fi_tmp[["mtime"]])
[10:30:50.076]                     }
[10:30:50.076]                     tryCatch({
[10:30:50.076]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.076]                     }, error = function(ex) {
[10:30:50.076]                       msg <- conditionMessage(ex)
[10:30:50.076]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.076]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.076]                         fi_tmp[["mtime"]], msg)
[10:30:50.076]                       ex$message <- msg
[10:30:50.076]                       stop(ex)
[10:30:50.076]                     })
[10:30:50.076]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.076]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.076]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.076]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.076]                       fi <- file.info(pathname)
[10:30:50.076]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.076]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.076]                         fi[["size"]], fi[["mtime"]])
[10:30:50.076]                       stop(msg)
[10:30:50.076]                     }
[10:30:50.076]                     invisible(pathname)
[10:30:50.076]                   }
[10:30:50.076]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.076]                     rootPath = tempdir()) 
[10:30:50.076]                   {
[10:30:50.076]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.076]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.076]                       tmpdir = path, fileext = ".rds")
[10:30:50.076]                     save_rds(obj, file)
[10:30:50.076]                   }
[10:30:50.076]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.076]                   {
[10:30:50.076]                     inherits <- base::inherits
[10:30:50.076]                     invokeRestart <- base::invokeRestart
[10:30:50.076]                     is.null <- base::is.null
[10:30:50.076]                     muffled <- FALSE
[10:30:50.076]                     if (inherits(cond, "message")) {
[10:30:50.076]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.076]                       if (muffled) 
[10:30:50.076]                         invokeRestart("muffleMessage")
[10:30:50.076]                     }
[10:30:50.076]                     else if (inherits(cond, "warning")) {
[10:30:50.076]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.076]                       if (muffled) 
[10:30:50.076]                         invokeRestart("muffleWarning")
[10:30:50.076]                     }
[10:30:50.076]                     else if (inherits(cond, "condition")) {
[10:30:50.076]                       if (!is.null(pattern)) {
[10:30:50.076]                         computeRestarts <- base::computeRestarts
[10:30:50.076]                         grepl <- base::grepl
[10:30:50.076]                         restarts <- computeRestarts(cond)
[10:30:50.076]                         for (restart in restarts) {
[10:30:50.076]                           name <- restart$name
[10:30:50.076]                           if (is.null(name)) 
[10:30:50.076]                             next
[10:30:50.076]                           if (!grepl(pattern, name)) 
[10:30:50.076]                             next
[10:30:50.076]                           invokeRestart(restart)
[10:30:50.076]                           muffled <- TRUE
[10:30:50.076]                           break
[10:30:50.076]                         }
[10:30:50.076]                       }
[10:30:50.076]                     }
[10:30:50.076]                     invisible(muffled)
[10:30:50.076]                   }
[10:30:50.076]                   muffleCondition(cond)
[10:30:50.076]                 })
[10:30:50.076]             }))
[10:30:50.076]             future::FutureResult(value = ...future.value$value, 
[10:30:50.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.076]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.076]                     ...future.globalenv.names))
[10:30:50.076]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.076]         }, condition = base::local({
[10:30:50.076]             c <- base::c
[10:30:50.076]             inherits <- base::inherits
[10:30:50.076]             invokeRestart <- base::invokeRestart
[10:30:50.076]             length <- base::length
[10:30:50.076]             list <- base::list
[10:30:50.076]             seq.int <- base::seq.int
[10:30:50.076]             signalCondition <- base::signalCondition
[10:30:50.076]             sys.calls <- base::sys.calls
[10:30:50.076]             `[[` <- base::`[[`
[10:30:50.076]             `+` <- base::`+`
[10:30:50.076]             `<<-` <- base::`<<-`
[10:30:50.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.076]                   3L)]
[10:30:50.076]             }
[10:30:50.076]             function(cond) {
[10:30:50.076]                 is_error <- inherits(cond, "error")
[10:30:50.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.076]                   NULL)
[10:30:50.076]                 if (is_error) {
[10:30:50.076]                   sessionInformation <- function() {
[10:30:50.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.076]                       search = base::search(), system = base::Sys.info())
[10:30:50.076]                   }
[10:30:50.076]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.076]                     cond$call), session = sessionInformation(), 
[10:30:50.076]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.076]                   signalCondition(cond)
[10:30:50.076]                 }
[10:30:50.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.076]                 "immediateCondition"))) {
[10:30:50.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.076]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.076]                   if (TRUE && !signal) {
[10:30:50.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.076]                     {
[10:30:50.076]                       inherits <- base::inherits
[10:30:50.076]                       invokeRestart <- base::invokeRestart
[10:30:50.076]                       is.null <- base::is.null
[10:30:50.076]                       muffled <- FALSE
[10:30:50.076]                       if (inherits(cond, "message")) {
[10:30:50.076]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.076]                         if (muffled) 
[10:30:50.076]                           invokeRestart("muffleMessage")
[10:30:50.076]                       }
[10:30:50.076]                       else if (inherits(cond, "warning")) {
[10:30:50.076]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.076]                         if (muffled) 
[10:30:50.076]                           invokeRestart("muffleWarning")
[10:30:50.076]                       }
[10:30:50.076]                       else if (inherits(cond, "condition")) {
[10:30:50.076]                         if (!is.null(pattern)) {
[10:30:50.076]                           computeRestarts <- base::computeRestarts
[10:30:50.076]                           grepl <- base::grepl
[10:30:50.076]                           restarts <- computeRestarts(cond)
[10:30:50.076]                           for (restart in restarts) {
[10:30:50.076]                             name <- restart$name
[10:30:50.076]                             if (is.null(name)) 
[10:30:50.076]                               next
[10:30:50.076]                             if (!grepl(pattern, name)) 
[10:30:50.076]                               next
[10:30:50.076]                             invokeRestart(restart)
[10:30:50.076]                             muffled <- TRUE
[10:30:50.076]                             break
[10:30:50.076]                           }
[10:30:50.076]                         }
[10:30:50.076]                       }
[10:30:50.076]                       invisible(muffled)
[10:30:50.076]                     }
[10:30:50.076]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.076]                   }
[10:30:50.076]                 }
[10:30:50.076]                 else {
[10:30:50.076]                   if (TRUE) {
[10:30:50.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.076]                     {
[10:30:50.076]                       inherits <- base::inherits
[10:30:50.076]                       invokeRestart <- base::invokeRestart
[10:30:50.076]                       is.null <- base::is.null
[10:30:50.076]                       muffled <- FALSE
[10:30:50.076]                       if (inherits(cond, "message")) {
[10:30:50.076]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.076]                         if (muffled) 
[10:30:50.076]                           invokeRestart("muffleMessage")
[10:30:50.076]                       }
[10:30:50.076]                       else if (inherits(cond, "warning")) {
[10:30:50.076]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.076]                         if (muffled) 
[10:30:50.076]                           invokeRestart("muffleWarning")
[10:30:50.076]                       }
[10:30:50.076]                       else if (inherits(cond, "condition")) {
[10:30:50.076]                         if (!is.null(pattern)) {
[10:30:50.076]                           computeRestarts <- base::computeRestarts
[10:30:50.076]                           grepl <- base::grepl
[10:30:50.076]                           restarts <- computeRestarts(cond)
[10:30:50.076]                           for (restart in restarts) {
[10:30:50.076]                             name <- restart$name
[10:30:50.076]                             if (is.null(name)) 
[10:30:50.076]                               next
[10:30:50.076]                             if (!grepl(pattern, name)) 
[10:30:50.076]                               next
[10:30:50.076]                             invokeRestart(restart)
[10:30:50.076]                             muffled <- TRUE
[10:30:50.076]                             break
[10:30:50.076]                           }
[10:30:50.076]                         }
[10:30:50.076]                       }
[10:30:50.076]                       invisible(muffled)
[10:30:50.076]                     }
[10:30:50.076]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.076]                   }
[10:30:50.076]                 }
[10:30:50.076]             }
[10:30:50.076]         }))
[10:30:50.076]     }, error = function(ex) {
[10:30:50.076]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.076]                 ...future.rng), started = ...future.startTime, 
[10:30:50.076]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.076]             version = "1.8"), class = "FutureResult")
[10:30:50.076]     }, finally = {
[10:30:50.076]         if (!identical(...future.workdir, getwd())) 
[10:30:50.076]             setwd(...future.workdir)
[10:30:50.076]         {
[10:30:50.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.076]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.076]             }
[10:30:50.076]             base::options(...future.oldOptions)
[10:30:50.076]             if (.Platform$OS.type == "windows") {
[10:30:50.076]                 old_names <- names(...future.oldEnvVars)
[10:30:50.076]                 envs <- base::Sys.getenv()
[10:30:50.076]                 names <- names(envs)
[10:30:50.076]                 common <- intersect(names, old_names)
[10:30:50.076]                 added <- setdiff(names, old_names)
[10:30:50.076]                 removed <- setdiff(old_names, names)
[10:30:50.076]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.076]                   envs[common]]
[10:30:50.076]                 NAMES <- toupper(changed)
[10:30:50.076]                 args <- list()
[10:30:50.076]                 for (kk in seq_along(NAMES)) {
[10:30:50.076]                   name <- changed[[kk]]
[10:30:50.076]                   NAME <- NAMES[[kk]]
[10:30:50.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.076]                     next
[10:30:50.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.076]                 }
[10:30:50.076]                 NAMES <- toupper(added)
[10:30:50.076]                 for (kk in seq_along(NAMES)) {
[10:30:50.076]                   name <- added[[kk]]
[10:30:50.076]                   NAME <- NAMES[[kk]]
[10:30:50.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.076]                     next
[10:30:50.076]                   args[[name]] <- ""
[10:30:50.076]                 }
[10:30:50.076]                 NAMES <- toupper(removed)
[10:30:50.076]                 for (kk in seq_along(NAMES)) {
[10:30:50.076]                   name <- removed[[kk]]
[10:30:50.076]                   NAME <- NAMES[[kk]]
[10:30:50.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.076]                     next
[10:30:50.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.076]                 }
[10:30:50.076]                 if (length(args) > 0) 
[10:30:50.076]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.076]             }
[10:30:50.076]             else {
[10:30:50.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.076]             }
[10:30:50.076]             {
[10:30:50.076]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.076]                   0L) {
[10:30:50.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.076]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.076]                   base::options(opts)
[10:30:50.076]                 }
[10:30:50.076]                 {
[10:30:50.076]                   {
[10:30:50.076]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.076]                     NULL
[10:30:50.076]                   }
[10:30:50.076]                   options(future.plan = NULL)
[10:30:50.076]                   if (is.na(NA_character_)) 
[10:30:50.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.076]                     .init = FALSE)
[10:30:50.076]                 }
[10:30:50.076]             }
[10:30:50.076]         }
[10:30:50.076]     })
[10:30:50.076]     if (TRUE) {
[10:30:50.076]         base::sink(type = "output", split = FALSE)
[10:30:50.076]         if (TRUE) {
[10:30:50.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.076]         }
[10:30:50.076]         else {
[10:30:50.076]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.076]         }
[10:30:50.076]         base::close(...future.stdout)
[10:30:50.076]         ...future.stdout <- NULL
[10:30:50.076]     }
[10:30:50.076]     ...future.result$conditions <- ...future.conditions
[10:30:50.076]     ...future.result$finished <- base::Sys.time()
[10:30:50.076]     ...future.result
[10:30:50.076] }
[10:30:50.078] assign_globals() ...
[10:30:50.078] List of 5
[10:30:50.078]  $ ...future.FUN            :function (C, k)  
[10:30:50.078]  $ MoreArgs                 : list()
[10:30:50.078]  $ ...future.elements_ii    :List of 2
[10:30:50.078]   ..$ :List of 2
[10:30:50.078]   .. ..$ : chr "A"
[10:30:50.078]   .. ..$ : chr "B"
[10:30:50.078]   ..$ :List of 2
[10:30:50.078]   .. ..$ : int 5
[10:30:50.078]   .. ..$ : int 4
[10:30:50.078]  $ ...future.seeds_ii       : NULL
[10:30:50.078]  $ ...future.globals.maxSize: NULL
[10:30:50.078]  - attr(*, "where")=List of 5
[10:30:50.078]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.078]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.078]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.078]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.078]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.078]  - attr(*, "resolved")= logi FALSE
[10:30:50.078]  - attr(*, "total_size")= num 3656
[10:30:50.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.078]  - attr(*, "already-done")= logi TRUE
[10:30:50.084] - reassign environment for ‘...future.FUN’
[10:30:50.084] - copied ‘...future.FUN’ to environment
[10:30:50.084] - copied ‘MoreArgs’ to environment
[10:30:50.084] - copied ‘...future.elements_ii’ to environment
[10:30:50.084] - copied ‘...future.seeds_ii’ to environment
[10:30:50.084] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.085] assign_globals() ... done
[10:30:50.085] requestCore(): workers = 2
[10:30:50.087] MulticoreFuture started
[10:30:50.087] - Launch lazy future ... done
[10:30:50.088] run() for ‘MulticoreFuture’ ... done
[10:30:50.088] Created future:
[10:30:50.088] plan(): Setting new future strategy stack:
[10:30:50.088] List of future strategies:
[10:30:50.088] 1. sequential:
[10:30:50.088]    - args: function (..., envir = parent.frame())
[10:30:50.088]    - tweaked: FALSE
[10:30:50.088]    - call: NULL
[10:30:50.089] plan(): nbrOfWorkers() = 1
[10:30:50.091] plan(): Setting new future strategy stack:
[10:30:50.092] List of future strategies:
[10:30:50.092] 1. multicore:
[10:30:50.092]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.092]    - tweaked: FALSE
[10:30:50.092]    - call: plan(strategy)
[10:30:50.088] MulticoreFuture:
[10:30:50.088] Label: ‘future_.mapply-1’
[10:30:50.088] Expression:
[10:30:50.088] {
[10:30:50.088]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.088]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.088]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.088]         on.exit(options(oopts), add = TRUE)
[10:30:50.088]     }
[10:30:50.088]     {
[10:30:50.088]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.088]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.088]         do.call(mapply, args = args)
[10:30:50.088]     }
[10:30:50.088] }
[10:30:50.088] Lazy evaluation: FALSE
[10:30:50.088] Asynchronous evaluation: TRUE
[10:30:50.088] Local evaluation: TRUE
[10:30:50.088] Environment: R_GlobalEnv
[10:30:50.088] Capture standard output: TRUE
[10:30:50.088] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.088] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.088] Packages: <none>
[10:30:50.088] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.088] Resolved: FALSE
[10:30:50.088] Value: <not collected>
[10:30:50.088] Conditions captured: <none>
[10:30:50.088] Early signaling: FALSE
[10:30:50.088] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.088] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.101] Chunk #1 of 2 ... DONE
[10:30:50.101] Chunk #2 of 2 ...
[10:30:50.101]  - Finding globals in '...' for chunk #2 ...
[10:30:50.102] getGlobalsAndPackages() ...
[10:30:50.101] plan(): nbrOfWorkers() = 2
[10:30:50.102] Searching for globals...
[10:30:50.102] 
[10:30:50.102] Searching for globals ... DONE
[10:30:50.103] - globals: [0] <none>
[10:30:50.103] getGlobalsAndPackages() ... DONE
[10:30:50.103]    + additional globals found: [n=0] 
[10:30:50.105]    + additional namespaces needed: [n=0] 
[10:30:50.106]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:50.106]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:50.106]  - seeds: <none>
[10:30:50.107]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.107] getGlobalsAndPackages() ...
[10:30:50.108] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.108] Resolving globals: FALSE
[10:30:50.109] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[10:30:50.111] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:50.111] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.111] 
[10:30:50.112] getGlobalsAndPackages() ... DONE
[10:30:50.112] run() for ‘Future’ ...
[10:30:50.113] - state: ‘created’
[10:30:50.113] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.119] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.119]   - Field: ‘label’
[10:30:50.120]   - Field: ‘local’
[10:30:50.120]   - Field: ‘owner’
[10:30:50.120]   - Field: ‘envir’
[10:30:50.120]   - Field: ‘workers’
[10:30:50.120]   - Field: ‘packages’
[10:30:50.120]   - Field: ‘gc’
[10:30:50.121]   - Field: ‘job’
[10:30:50.121]   - Field: ‘conditions’
[10:30:50.121]   - Field: ‘expr’
[10:30:50.121]   - Field: ‘uuid’
[10:30:50.121]   - Field: ‘seed’
[10:30:50.121]   - Field: ‘version’
[10:30:50.121]   - Field: ‘result’
[10:30:50.122]   - Field: ‘asynchronous’
[10:30:50.122]   - Field: ‘calls’
[10:30:50.122]   - Field: ‘globals’
[10:30:50.122]   - Field: ‘stdout’
[10:30:50.122]   - Field: ‘earlySignal’
[10:30:50.122]   - Field: ‘lazy’
[10:30:50.122]   - Field: ‘state’
[10:30:50.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.123] - Launch lazy future ...
[10:30:50.123] Packages needed by the future expression (n = 0): <none>
[10:30:50.124] Packages needed by future strategies (n = 0): <none>
[10:30:50.124] {
[10:30:50.124]     {
[10:30:50.124]         {
[10:30:50.124]             ...future.startTime <- base::Sys.time()
[10:30:50.124]             {
[10:30:50.124]                 {
[10:30:50.124]                   {
[10:30:50.124]                     {
[10:30:50.124]                       base::local({
[10:30:50.124]                         has_future <- base::requireNamespace("future", 
[10:30:50.124]                           quietly = TRUE)
[10:30:50.124]                         if (has_future) {
[10:30:50.124]                           ns <- base::getNamespace("future")
[10:30:50.124]                           version <- ns[[".package"]][["version"]]
[10:30:50.124]                           if (is.null(version)) 
[10:30:50.124]                             version <- utils::packageVersion("future")
[10:30:50.124]                         }
[10:30:50.124]                         else {
[10:30:50.124]                           version <- NULL
[10:30:50.124]                         }
[10:30:50.124]                         if (!has_future || version < "1.8.0") {
[10:30:50.124]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.124]                             "", base::R.version$version.string), 
[10:30:50.124]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.124]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.124]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.124]                               "release", "version")], collapse = " "), 
[10:30:50.124]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.124]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.124]                             info)
[10:30:50.124]                           info <- base::paste(info, collapse = "; ")
[10:30:50.124]                           if (!has_future) {
[10:30:50.124]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.124]                               info)
[10:30:50.124]                           }
[10:30:50.124]                           else {
[10:30:50.124]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.124]                               info, version)
[10:30:50.124]                           }
[10:30:50.124]                           base::stop(msg)
[10:30:50.124]                         }
[10:30:50.124]                       })
[10:30:50.124]                     }
[10:30:50.124]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.124]                     base::options(mc.cores = 1L)
[10:30:50.124]                   }
[10:30:50.124]                   ...future.strategy.old <- future::plan("list")
[10:30:50.124]                   options(future.plan = NULL)
[10:30:50.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.124]                 }
[10:30:50.124]                 ...future.workdir <- getwd()
[10:30:50.124]             }
[10:30:50.124]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.124]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.124]         }
[10:30:50.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.124]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:50.124]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.124]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.124]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.124]             base::names(...future.oldOptions))
[10:30:50.124]     }
[10:30:50.124]     if (FALSE) {
[10:30:50.124]     }
[10:30:50.124]     else {
[10:30:50.124]         if (TRUE) {
[10:30:50.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.124]                 open = "w")
[10:30:50.124]         }
[10:30:50.124]         else {
[10:30:50.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.124]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.124]         }
[10:30:50.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.124]             base::sink(type = "output", split = FALSE)
[10:30:50.124]             base::close(...future.stdout)
[10:30:50.124]         }, add = TRUE)
[10:30:50.124]     }
[10:30:50.124]     ...future.frame <- base::sys.nframe()
[10:30:50.124]     ...future.conditions <- base::list()
[10:30:50.124]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.124]     if (FALSE) {
[10:30:50.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.124]     }
[10:30:50.124]     ...future.result <- base::tryCatch({
[10:30:50.124]         base::withCallingHandlers({
[10:30:50.124]             ...future.value <- base::withVisible(base::local({
[10:30:50.124]                 withCallingHandlers({
[10:30:50.124]                   {
[10:30:50.124]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.124]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.124]                       ...future.globals.maxSize)) {
[10:30:50.124]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.124]                       on.exit(options(oopts), add = TRUE)
[10:30:50.124]                     }
[10:30:50.124]                     {
[10:30:50.124]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.124]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.124]                         USE.NAMES = FALSE)
[10:30:50.124]                       do.call(mapply, args = args)
[10:30:50.124]                     }
[10:30:50.124]                   }
[10:30:50.124]                 }, immediateCondition = function(cond) {
[10:30:50.124]                   save_rds <- function (object, pathname, ...) 
[10:30:50.124]                   {
[10:30:50.124]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.124]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.124]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.124]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.124]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.124]                         fi_tmp[["mtime"]])
[10:30:50.124]                     }
[10:30:50.124]                     tryCatch({
[10:30:50.124]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.124]                     }, error = function(ex) {
[10:30:50.124]                       msg <- conditionMessage(ex)
[10:30:50.124]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.124]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.124]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.124]                         fi_tmp[["mtime"]], msg)
[10:30:50.124]                       ex$message <- msg
[10:30:50.124]                       stop(ex)
[10:30:50.124]                     })
[10:30:50.124]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.124]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.124]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.124]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.124]                       fi <- file.info(pathname)
[10:30:50.124]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.124]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.124]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.124]                         fi[["size"]], fi[["mtime"]])
[10:30:50.124]                       stop(msg)
[10:30:50.124]                     }
[10:30:50.124]                     invisible(pathname)
[10:30:50.124]                   }
[10:30:50.124]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.124]                     rootPath = tempdir()) 
[10:30:50.124]                   {
[10:30:50.124]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.124]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.124]                       tmpdir = path, fileext = ".rds")
[10:30:50.124]                     save_rds(obj, file)
[10:30:50.124]                   }
[10:30:50.124]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.124]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.124]                   {
[10:30:50.124]                     inherits <- base::inherits
[10:30:50.124]                     invokeRestart <- base::invokeRestart
[10:30:50.124]                     is.null <- base::is.null
[10:30:50.124]                     muffled <- FALSE
[10:30:50.124]                     if (inherits(cond, "message")) {
[10:30:50.124]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.124]                       if (muffled) 
[10:30:50.124]                         invokeRestart("muffleMessage")
[10:30:50.124]                     }
[10:30:50.124]                     else if (inherits(cond, "warning")) {
[10:30:50.124]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.124]                       if (muffled) 
[10:30:50.124]                         invokeRestart("muffleWarning")
[10:30:50.124]                     }
[10:30:50.124]                     else if (inherits(cond, "condition")) {
[10:30:50.124]                       if (!is.null(pattern)) {
[10:30:50.124]                         computeRestarts <- base::computeRestarts
[10:30:50.124]                         grepl <- base::grepl
[10:30:50.124]                         restarts <- computeRestarts(cond)
[10:30:50.124]                         for (restart in restarts) {
[10:30:50.124]                           name <- restart$name
[10:30:50.124]                           if (is.null(name)) 
[10:30:50.124]                             next
[10:30:50.124]                           if (!grepl(pattern, name)) 
[10:30:50.124]                             next
[10:30:50.124]                           invokeRestart(restart)
[10:30:50.124]                           muffled <- TRUE
[10:30:50.124]                           break
[10:30:50.124]                         }
[10:30:50.124]                       }
[10:30:50.124]                     }
[10:30:50.124]                     invisible(muffled)
[10:30:50.124]                   }
[10:30:50.124]                   muffleCondition(cond)
[10:30:50.124]                 })
[10:30:50.124]             }))
[10:30:50.124]             future::FutureResult(value = ...future.value$value, 
[10:30:50.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.124]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.124]                     ...future.globalenv.names))
[10:30:50.124]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.124]         }, condition = base::local({
[10:30:50.124]             c <- base::c
[10:30:50.124]             inherits <- base::inherits
[10:30:50.124]             invokeRestart <- base::invokeRestart
[10:30:50.124]             length <- base::length
[10:30:50.124]             list <- base::list
[10:30:50.124]             seq.int <- base::seq.int
[10:30:50.124]             signalCondition <- base::signalCondition
[10:30:50.124]             sys.calls <- base::sys.calls
[10:30:50.124]             `[[` <- base::`[[`
[10:30:50.124]             `+` <- base::`+`
[10:30:50.124]             `<<-` <- base::`<<-`
[10:30:50.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.124]                   3L)]
[10:30:50.124]             }
[10:30:50.124]             function(cond) {
[10:30:50.124]                 is_error <- inherits(cond, "error")
[10:30:50.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.124]                   NULL)
[10:30:50.124]                 if (is_error) {
[10:30:50.124]                   sessionInformation <- function() {
[10:30:50.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.124]                       search = base::search(), system = base::Sys.info())
[10:30:50.124]                   }
[10:30:50.124]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.124]                     cond$call), session = sessionInformation(), 
[10:30:50.124]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.124]                   signalCondition(cond)
[10:30:50.124]                 }
[10:30:50.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.124]                 "immediateCondition"))) {
[10:30:50.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.124]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.124]                   if (TRUE && !signal) {
[10:30:50.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.124]                     {
[10:30:50.124]                       inherits <- base::inherits
[10:30:50.124]                       invokeRestart <- base::invokeRestart
[10:30:50.124]                       is.null <- base::is.null
[10:30:50.124]                       muffled <- FALSE
[10:30:50.124]                       if (inherits(cond, "message")) {
[10:30:50.124]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.124]                         if (muffled) 
[10:30:50.124]                           invokeRestart("muffleMessage")
[10:30:50.124]                       }
[10:30:50.124]                       else if (inherits(cond, "warning")) {
[10:30:50.124]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.124]                         if (muffled) 
[10:30:50.124]                           invokeRestart("muffleWarning")
[10:30:50.124]                       }
[10:30:50.124]                       else if (inherits(cond, "condition")) {
[10:30:50.124]                         if (!is.null(pattern)) {
[10:30:50.124]                           computeRestarts <- base::computeRestarts
[10:30:50.124]                           grepl <- base::grepl
[10:30:50.124]                           restarts <- computeRestarts(cond)
[10:30:50.124]                           for (restart in restarts) {
[10:30:50.124]                             name <- restart$name
[10:30:50.124]                             if (is.null(name)) 
[10:30:50.124]                               next
[10:30:50.124]                             if (!grepl(pattern, name)) 
[10:30:50.124]                               next
[10:30:50.124]                             invokeRestart(restart)
[10:30:50.124]                             muffled <- TRUE
[10:30:50.124]                             break
[10:30:50.124]                           }
[10:30:50.124]                         }
[10:30:50.124]                       }
[10:30:50.124]                       invisible(muffled)
[10:30:50.124]                     }
[10:30:50.124]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.124]                   }
[10:30:50.124]                 }
[10:30:50.124]                 else {
[10:30:50.124]                   if (TRUE) {
[10:30:50.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.124]                     {
[10:30:50.124]                       inherits <- base::inherits
[10:30:50.124]                       invokeRestart <- base::invokeRestart
[10:30:50.124]                       is.null <- base::is.null
[10:30:50.124]                       muffled <- FALSE
[10:30:50.124]                       if (inherits(cond, "message")) {
[10:30:50.124]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.124]                         if (muffled) 
[10:30:50.124]                           invokeRestart("muffleMessage")
[10:30:50.124]                       }
[10:30:50.124]                       else if (inherits(cond, "warning")) {
[10:30:50.124]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.124]                         if (muffled) 
[10:30:50.124]                           invokeRestart("muffleWarning")
[10:30:50.124]                       }
[10:30:50.124]                       else if (inherits(cond, "condition")) {
[10:30:50.124]                         if (!is.null(pattern)) {
[10:30:50.124]                           computeRestarts <- base::computeRestarts
[10:30:50.124]                           grepl <- base::grepl
[10:30:50.124]                           restarts <- computeRestarts(cond)
[10:30:50.124]                           for (restart in restarts) {
[10:30:50.124]                             name <- restart$name
[10:30:50.124]                             if (is.null(name)) 
[10:30:50.124]                               next
[10:30:50.124]                             if (!grepl(pattern, name)) 
[10:30:50.124]                               next
[10:30:50.124]                             invokeRestart(restart)
[10:30:50.124]                             muffled <- TRUE
[10:30:50.124]                             break
[10:30:50.124]                           }
[10:30:50.124]                         }
[10:30:50.124]                       }
[10:30:50.124]                       invisible(muffled)
[10:30:50.124]                     }
[10:30:50.124]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.124]                   }
[10:30:50.124]                 }
[10:30:50.124]             }
[10:30:50.124]         }))
[10:30:50.124]     }, error = function(ex) {
[10:30:50.124]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.124]                 ...future.rng), started = ...future.startTime, 
[10:30:50.124]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.124]             version = "1.8"), class = "FutureResult")
[10:30:50.124]     }, finally = {
[10:30:50.124]         if (!identical(...future.workdir, getwd())) 
[10:30:50.124]             setwd(...future.workdir)
[10:30:50.124]         {
[10:30:50.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.124]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.124]             }
[10:30:50.124]             base::options(...future.oldOptions)
[10:30:50.124]             if (.Platform$OS.type == "windows") {
[10:30:50.124]                 old_names <- names(...future.oldEnvVars)
[10:30:50.124]                 envs <- base::Sys.getenv()
[10:30:50.124]                 names <- names(envs)
[10:30:50.124]                 common <- intersect(names, old_names)
[10:30:50.124]                 added <- setdiff(names, old_names)
[10:30:50.124]                 removed <- setdiff(old_names, names)
[10:30:50.124]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.124]                   envs[common]]
[10:30:50.124]                 NAMES <- toupper(changed)
[10:30:50.124]                 args <- list()
[10:30:50.124]                 for (kk in seq_along(NAMES)) {
[10:30:50.124]                   name <- changed[[kk]]
[10:30:50.124]                   NAME <- NAMES[[kk]]
[10:30:50.124]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.124]                     next
[10:30:50.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.124]                 }
[10:30:50.124]                 NAMES <- toupper(added)
[10:30:50.124]                 for (kk in seq_along(NAMES)) {
[10:30:50.124]                   name <- added[[kk]]
[10:30:50.124]                   NAME <- NAMES[[kk]]
[10:30:50.124]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.124]                     next
[10:30:50.124]                   args[[name]] <- ""
[10:30:50.124]                 }
[10:30:50.124]                 NAMES <- toupper(removed)
[10:30:50.124]                 for (kk in seq_along(NAMES)) {
[10:30:50.124]                   name <- removed[[kk]]
[10:30:50.124]                   NAME <- NAMES[[kk]]
[10:30:50.124]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.124]                     next
[10:30:50.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.124]                 }
[10:30:50.124]                 if (length(args) > 0) 
[10:30:50.124]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.124]             }
[10:30:50.124]             else {
[10:30:50.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.124]             }
[10:30:50.124]             {
[10:30:50.124]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.124]                   0L) {
[10:30:50.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.124]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.124]                   base::options(opts)
[10:30:50.124]                 }
[10:30:50.124]                 {
[10:30:50.124]                   {
[10:30:50.124]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.124]                     NULL
[10:30:50.124]                   }
[10:30:50.124]                   options(future.plan = NULL)
[10:30:50.124]                   if (is.na(NA_character_)) 
[10:30:50.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.124]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.124]                     .init = FALSE)
[10:30:50.124]                 }
[10:30:50.124]             }
[10:30:50.124]         }
[10:30:50.124]     })
[10:30:50.124]     if (TRUE) {
[10:30:50.124]         base::sink(type = "output", split = FALSE)
[10:30:50.124]         if (TRUE) {
[10:30:50.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.124]         }
[10:30:50.124]         else {
[10:30:50.124]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.124]         }
[10:30:50.124]         base::close(...future.stdout)
[10:30:50.124]         ...future.stdout <- NULL
[10:30:50.124]     }
[10:30:50.124]     ...future.result$conditions <- ...future.conditions
[10:30:50.124]     ...future.result$finished <- base::Sys.time()
[10:30:50.124]     ...future.result
[10:30:50.124] }
[10:30:50.127] assign_globals() ...
[10:30:50.127] List of 5
[10:30:50.127]  $ ...future.FUN            :function (C, k)  
[10:30:50.127]  $ MoreArgs                 : list()
[10:30:50.127]  $ ...future.elements_ii    :List of 2
[10:30:50.127]   ..$ :List of 3
[10:30:50.127]   .. ..$ : chr "C"
[10:30:50.127]   .. ..$ : chr "D"
[10:30:50.127]   .. ..$ : chr "E"
[10:30:50.127]   ..$ :List of 3
[10:30:50.127]   .. ..$ : int 3
[10:30:50.127]   .. ..$ : int 2
[10:30:50.127]   .. ..$ : int 1
[10:30:50.127]  $ ...future.seeds_ii       : NULL
[10:30:50.127]  $ ...future.globals.maxSize: NULL
[10:30:50.127]  - attr(*, "where")=List of 5
[10:30:50.127]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.127]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.127]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.127]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.127]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.127]  - attr(*, "resolved")= logi FALSE
[10:30:50.127]  - attr(*, "total_size")= num 3824
[10:30:50.127]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.127]  - attr(*, "already-done")= logi TRUE
[10:30:50.135] - reassign environment for ‘...future.FUN’
[10:30:50.135] - copied ‘...future.FUN’ to environment
[10:30:50.135] - copied ‘MoreArgs’ to environment
[10:30:50.136] - copied ‘...future.elements_ii’ to environment
[10:30:50.136] - copied ‘...future.seeds_ii’ to environment
[10:30:50.136] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.136] assign_globals() ... done
[10:30:50.136] requestCore(): workers = 2
[10:30:50.139] MulticoreFuture started
[10:30:50.139] - Launch lazy future ... done
[10:30:50.139] run() for ‘MulticoreFuture’ ... done
[10:30:50.139] Created future:
[10:30:50.140] plan(): Setting new future strategy stack:
[10:30:50.140] List of future strategies:
[10:30:50.140] 1. sequential:
[10:30:50.140]    - args: function (..., envir = parent.frame())
[10:30:50.140]    - tweaked: FALSE
[10:30:50.140]    - call: NULL
[10:30:50.141] plan(): nbrOfWorkers() = 1
[10:30:50.143] plan(): Setting new future strategy stack:
[10:30:50.143] List of future strategies:
[10:30:50.143] 1. multicore:
[10:30:50.143]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.143]    - tweaked: FALSE
[10:30:50.143]    - call: plan(strategy)
[10:30:50.148] plan(): nbrOfWorkers() = 2
[10:30:50.140] MulticoreFuture:
[10:30:50.140] Label: ‘future_.mapply-2’
[10:30:50.140] Expression:
[10:30:50.140] {
[10:30:50.140]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.140]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.140]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.140]         on.exit(options(oopts), add = TRUE)
[10:30:50.140]     }
[10:30:50.140]     {
[10:30:50.140]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.140]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.140]         do.call(mapply, args = args)
[10:30:50.140]     }
[10:30:50.140] }
[10:30:50.140] Lazy evaluation: FALSE
[10:30:50.140] Asynchronous evaluation: TRUE
[10:30:50.140] Local evaluation: TRUE
[10:30:50.140] Environment: R_GlobalEnv
[10:30:50.140] Capture standard output: TRUE
[10:30:50.140] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.140] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.140] Packages: <none>
[10:30:50.140] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.140] Resolved: TRUE
[10:30:50.140] Value: <not collected>
[10:30:50.140] Conditions captured: <none>
[10:30:50.140] Early signaling: FALSE
[10:30:50.140] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.140] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.149] Chunk #2 of 2 ... DONE
[10:30:50.150] Launching 2 futures (chunks) ... DONE
[10:30:50.150] Resolving 2 futures (chunks) ...
[10:30:50.150] resolve() on list ...
[10:30:50.150]  recursive: 0
[10:30:50.150]  length: 2
[10:30:50.150] 
[10:30:50.151] Future #1
[10:30:50.151] result() for MulticoreFuture ...
[10:30:50.152] result() for MulticoreFuture ...
[10:30:50.152] result() for MulticoreFuture ... done
[10:30:50.152] result() for MulticoreFuture ... done
[10:30:50.152] result() for MulticoreFuture ...
[10:30:50.152] result() for MulticoreFuture ... done
[10:30:50.153] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:50.153] - nx: 2
[10:30:50.153] - relay: TRUE
[10:30:50.153] - stdout: TRUE
[10:30:50.157] - signal: TRUE
[10:30:50.157] - resignal: FALSE
[10:30:50.158] - force: TRUE
[10:30:50.158] - relayed: [n=2] FALSE, FALSE
[10:30:50.158] - queued futures: [n=2] FALSE, FALSE
[10:30:50.159]  - until=1
[10:30:50.159]  - relaying element #1
[10:30:50.160] result() for MulticoreFuture ...
[10:30:50.160] result() for MulticoreFuture ... done
[10:30:50.160] result() for MulticoreFuture ...
[10:30:50.161] result() for MulticoreFuture ... done
[10:30:50.161] result() for MulticoreFuture ...
[10:30:50.161] result() for MulticoreFuture ... done
[10:30:50.162] result() for MulticoreFuture ...
[10:30:50.162] result() for MulticoreFuture ... done
[10:30:50.162] - relayed: [n=2] TRUE, FALSE
[10:30:50.162] - queued futures: [n=2] TRUE, FALSE
[10:30:50.163] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:50.163]  length: 1 (resolved future 1)
[10:30:50.164] Future #2
[10:30:50.164] result() for MulticoreFuture ...
[10:30:50.165] result() for MulticoreFuture ...
[10:30:50.165] result() for MulticoreFuture ... done
[10:30:50.166] result() for MulticoreFuture ... done
[10:30:50.166] result() for MulticoreFuture ...
[10:30:50.166] result() for MulticoreFuture ... done
[10:30:50.166] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:50.166] - nx: 2
[10:30:50.167] - relay: TRUE
[10:30:50.167] - stdout: TRUE
[10:30:50.167] - signal: TRUE
[10:30:50.167] - resignal: FALSE
[10:30:50.167] - force: TRUE
[10:30:50.167] - relayed: [n=2] TRUE, FALSE
[10:30:50.167] - queued futures: [n=2] TRUE, FALSE
[10:30:50.168]  - until=2
[10:30:50.168]  - relaying element #2
[10:30:50.168] result() for MulticoreFuture ...
[10:30:50.168] result() for MulticoreFuture ... done
[10:30:50.168] result() for MulticoreFuture ...
[10:30:50.168] result() for MulticoreFuture ... done
[10:30:50.169] result() for MulticoreFuture ...
[10:30:50.169] result() for MulticoreFuture ... done
[10:30:50.169] result() for MulticoreFuture ...
[10:30:50.169] result() for MulticoreFuture ... done
[10:30:50.169] - relayed: [n=2] TRUE, TRUE
[10:30:50.169] - queued futures: [n=2] TRUE, TRUE
[10:30:50.169] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:50.169]  length: 0 (resolved future 2)
[10:30:50.170] Relaying remaining futures
[10:30:50.170] signalConditionsASAP(NULL, pos=0) ...
[10:30:50.170] - nx: 2
[10:30:50.170] - relay: TRUE
[10:30:50.170] - stdout: TRUE
[10:30:50.170] - signal: TRUE
[10:30:50.170] - resignal: FALSE
[10:30:50.170] - force: TRUE
[10:30:50.170] - relayed: [n=2] TRUE, TRUE
[10:30:50.171] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:50.171] - relayed: [n=2] TRUE, TRUE
[10:30:50.171] - queued futures: [n=2] TRUE, TRUE
[10:30:50.171] signalConditionsASAP(NULL, pos=0) ... done
[10:30:50.171] resolve() on list ... DONE
[10:30:50.171] result() for MulticoreFuture ...
[10:30:50.171] result() for MulticoreFuture ... done
[10:30:50.171] result() for MulticoreFuture ...
[10:30:50.172] result() for MulticoreFuture ... done
[10:30:50.172] result() for MulticoreFuture ...
[10:30:50.172] result() for MulticoreFuture ... done
[10:30:50.172] result() for MulticoreFuture ...
[10:30:50.172] result() for MulticoreFuture ... done
[10:30:50.172]  - Number of value chunks collected: 2
[10:30:50.172] Resolving 2 futures (chunks) ... DONE
[10:30:50.172] Reducing values from 2 chunks ...
[10:30:50.173]  - Number of values collected after concatenation: 5
[10:30:50.173]  - Number of values expected: 5
[10:30:50.173] Reducing values from 2 chunks ... DONE
[10:30:50.173] future_mapply() ... DONE
[10:30:50.173] future_mapply() ...
[10:30:50.178] Number of chunks: 3
[10:30:50.178] Index remapping (attribute 'ordering'): [n = 5] 3, 2, 4, 5, 1
[10:30:50.178] getGlobalsAndPackagesXApply() ...
[10:30:50.178]  - future.globals: TRUE
[10:30:50.178] getGlobalsAndPackages() ...
[10:30:50.178] Searching for globals...
[10:30:50.180] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:50.180] Searching for globals ... DONE
[10:30:50.180] Resolving globals: FALSE
[10:30:50.180] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:50.181] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:50.181] - globals: [1] ‘FUN’
[10:30:50.181] 
[10:30:50.181] getGlobalsAndPackages() ... DONE
[10:30:50.181]  - globals found/used: [n=1] ‘FUN’
[10:30:50.181]  - needed namespaces: [n=0] 
[10:30:50.181] Finding globals ... DONE
[10:30:50.182] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:50.182] List of 2
[10:30:50.182]  $ ...future.FUN:function (C, k)  
[10:30:50.182]  $ MoreArgs     : NULL
[10:30:50.182]  - attr(*, "where")=List of 2
[10:30:50.182]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:50.182]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:50.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.182]  - attr(*, "resolved")= logi FALSE
[10:30:50.182]  - attr(*, "total_size")= num NA
[10:30:50.185] Packages to be attached in all futures: [n=0] 
[10:30:50.185] getGlobalsAndPackagesXApply() ... DONE
[10:30:50.185] Number of futures (= number of chunks): 3
[10:30:50.185] Launching 3 futures (chunks) ...
[10:30:50.185] Chunk #1 of 3 ...
[10:30:50.185]  - Finding globals in '...' for chunk #1 ...
[10:30:50.185] getGlobalsAndPackages() ...
[10:30:50.186] Searching for globals...
[10:30:50.186] 
[10:30:50.186] Searching for globals ... DONE
[10:30:50.186] - globals: [0] <none>
[10:30:50.186] getGlobalsAndPackages() ... DONE
[10:30:50.186]    + additional globals found: [n=0] 
[10:30:50.186]    + additional namespaces needed: [n=0] 
[10:30:50.186]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:50.187]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:30:50.187]  - seeds: <none>
[10:30:50.187]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.187] getGlobalsAndPackages() ...
[10:30:50.187] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.187] Resolving globals: FALSE
[10:30:50.190] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:50.191] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:50.191] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.191] 
[10:30:50.191] getGlobalsAndPackages() ... DONE
[10:30:50.192] run() for ‘Future’ ...
[10:30:50.192] - state: ‘created’
[10:30:50.192] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.196] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.197] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.197]   - Field: ‘label’
[10:30:50.197]   - Field: ‘local’
[10:30:50.197]   - Field: ‘owner’
[10:30:50.197]   - Field: ‘envir’
[10:30:50.197]   - Field: ‘workers’
[10:30:50.198]   - Field: ‘packages’
[10:30:50.198]   - Field: ‘gc’
[10:30:50.198]   - Field: ‘job’
[10:30:50.198]   - Field: ‘conditions’
[10:30:50.198]   - Field: ‘expr’
[10:30:50.198]   - Field: ‘uuid’
[10:30:50.198]   - Field: ‘seed’
[10:30:50.198]   - Field: ‘version’
[10:30:50.199]   - Field: ‘result’
[10:30:50.199]   - Field: ‘asynchronous’
[10:30:50.199]   - Field: ‘calls’
[10:30:50.199]   - Field: ‘globals’
[10:30:50.199]   - Field: ‘stdout’
[10:30:50.199]   - Field: ‘earlySignal’
[10:30:50.199]   - Field: ‘lazy’
[10:30:50.199]   - Field: ‘state’
[10:30:50.199] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.199] - Launch lazy future ...
[10:30:50.200] Packages needed by the future expression (n = 0): <none>
[10:30:50.200] Packages needed by future strategies (n = 0): <none>
[10:30:50.200] {
[10:30:50.200]     {
[10:30:50.200]         {
[10:30:50.200]             ...future.startTime <- base::Sys.time()
[10:30:50.200]             {
[10:30:50.200]                 {
[10:30:50.200]                   {
[10:30:50.200]                     {
[10:30:50.200]                       base::local({
[10:30:50.200]                         has_future <- base::requireNamespace("future", 
[10:30:50.200]                           quietly = TRUE)
[10:30:50.200]                         if (has_future) {
[10:30:50.200]                           ns <- base::getNamespace("future")
[10:30:50.200]                           version <- ns[[".package"]][["version"]]
[10:30:50.200]                           if (is.null(version)) 
[10:30:50.200]                             version <- utils::packageVersion("future")
[10:30:50.200]                         }
[10:30:50.200]                         else {
[10:30:50.200]                           version <- NULL
[10:30:50.200]                         }
[10:30:50.200]                         if (!has_future || version < "1.8.0") {
[10:30:50.200]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.200]                             "", base::R.version$version.string), 
[10:30:50.200]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.200]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.200]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.200]                               "release", "version")], collapse = " "), 
[10:30:50.200]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.200]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.200]                             info)
[10:30:50.200]                           info <- base::paste(info, collapse = "; ")
[10:30:50.200]                           if (!has_future) {
[10:30:50.200]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.200]                               info)
[10:30:50.200]                           }
[10:30:50.200]                           else {
[10:30:50.200]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.200]                               info, version)
[10:30:50.200]                           }
[10:30:50.200]                           base::stop(msg)
[10:30:50.200]                         }
[10:30:50.200]                       })
[10:30:50.200]                     }
[10:30:50.200]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.200]                     base::options(mc.cores = 1L)
[10:30:50.200]                   }
[10:30:50.200]                   ...future.strategy.old <- future::plan("list")
[10:30:50.200]                   options(future.plan = NULL)
[10:30:50.200]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.200]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.200]                 }
[10:30:50.200]                 ...future.workdir <- getwd()
[10:30:50.200]             }
[10:30:50.200]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.200]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.200]         }
[10:30:50.200]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.200]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:30:50.200]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.200]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.200]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.200]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.200]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.200]             base::names(...future.oldOptions))
[10:30:50.200]     }
[10:30:50.200]     if (FALSE) {
[10:30:50.200]     }
[10:30:50.200]     else {
[10:30:50.200]         if (TRUE) {
[10:30:50.200]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.200]                 open = "w")
[10:30:50.200]         }
[10:30:50.200]         else {
[10:30:50.200]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.200]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.200]         }
[10:30:50.200]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.200]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.200]             base::sink(type = "output", split = FALSE)
[10:30:50.200]             base::close(...future.stdout)
[10:30:50.200]         }, add = TRUE)
[10:30:50.200]     }
[10:30:50.200]     ...future.frame <- base::sys.nframe()
[10:30:50.200]     ...future.conditions <- base::list()
[10:30:50.200]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.200]     if (FALSE) {
[10:30:50.200]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.200]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.200]     }
[10:30:50.200]     ...future.result <- base::tryCatch({
[10:30:50.200]         base::withCallingHandlers({
[10:30:50.200]             ...future.value <- base::withVisible(base::local({
[10:30:50.200]                 withCallingHandlers({
[10:30:50.200]                   {
[10:30:50.200]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.200]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.200]                       ...future.globals.maxSize)) {
[10:30:50.200]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.200]                       on.exit(options(oopts), add = TRUE)
[10:30:50.200]                     }
[10:30:50.200]                     {
[10:30:50.200]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.200]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.200]                         USE.NAMES = FALSE)
[10:30:50.200]                       do.call(mapply, args = args)
[10:30:50.200]                     }
[10:30:50.200]                   }
[10:30:50.200]                 }, immediateCondition = function(cond) {
[10:30:50.200]                   save_rds <- function (object, pathname, ...) 
[10:30:50.200]                   {
[10:30:50.200]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.200]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.200]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.200]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.200]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.200]                         fi_tmp[["mtime"]])
[10:30:50.200]                     }
[10:30:50.200]                     tryCatch({
[10:30:50.200]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.200]                     }, error = function(ex) {
[10:30:50.200]                       msg <- conditionMessage(ex)
[10:30:50.200]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.200]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.200]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.200]                         fi_tmp[["mtime"]], msg)
[10:30:50.200]                       ex$message <- msg
[10:30:50.200]                       stop(ex)
[10:30:50.200]                     })
[10:30:50.200]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.200]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.200]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.200]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.200]                       fi <- file.info(pathname)
[10:30:50.200]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.200]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.200]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.200]                         fi[["size"]], fi[["mtime"]])
[10:30:50.200]                       stop(msg)
[10:30:50.200]                     }
[10:30:50.200]                     invisible(pathname)
[10:30:50.200]                   }
[10:30:50.200]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.200]                     rootPath = tempdir()) 
[10:30:50.200]                   {
[10:30:50.200]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.200]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.200]                       tmpdir = path, fileext = ".rds")
[10:30:50.200]                     save_rds(obj, file)
[10:30:50.200]                   }
[10:30:50.200]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.200]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.200]                   {
[10:30:50.200]                     inherits <- base::inherits
[10:30:50.200]                     invokeRestart <- base::invokeRestart
[10:30:50.200]                     is.null <- base::is.null
[10:30:50.200]                     muffled <- FALSE
[10:30:50.200]                     if (inherits(cond, "message")) {
[10:30:50.200]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.200]                       if (muffled) 
[10:30:50.200]                         invokeRestart("muffleMessage")
[10:30:50.200]                     }
[10:30:50.200]                     else if (inherits(cond, "warning")) {
[10:30:50.200]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.200]                       if (muffled) 
[10:30:50.200]                         invokeRestart("muffleWarning")
[10:30:50.200]                     }
[10:30:50.200]                     else if (inherits(cond, "condition")) {
[10:30:50.200]                       if (!is.null(pattern)) {
[10:30:50.200]                         computeRestarts <- base::computeRestarts
[10:30:50.200]                         grepl <- base::grepl
[10:30:50.200]                         restarts <- computeRestarts(cond)
[10:30:50.200]                         for (restart in restarts) {
[10:30:50.200]                           name <- restart$name
[10:30:50.200]                           if (is.null(name)) 
[10:30:50.200]                             next
[10:30:50.200]                           if (!grepl(pattern, name)) 
[10:30:50.200]                             next
[10:30:50.200]                           invokeRestart(restart)
[10:30:50.200]                           muffled <- TRUE
[10:30:50.200]                           break
[10:30:50.200]                         }
[10:30:50.200]                       }
[10:30:50.200]                     }
[10:30:50.200]                     invisible(muffled)
[10:30:50.200]                   }
[10:30:50.200]                   muffleCondition(cond)
[10:30:50.200]                 })
[10:30:50.200]             }))
[10:30:50.200]             future::FutureResult(value = ...future.value$value, 
[10:30:50.200]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.200]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.200]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.200]                     ...future.globalenv.names))
[10:30:50.200]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.200]         }, condition = base::local({
[10:30:50.200]             c <- base::c
[10:30:50.200]             inherits <- base::inherits
[10:30:50.200]             invokeRestart <- base::invokeRestart
[10:30:50.200]             length <- base::length
[10:30:50.200]             list <- base::list
[10:30:50.200]             seq.int <- base::seq.int
[10:30:50.200]             signalCondition <- base::signalCondition
[10:30:50.200]             sys.calls <- base::sys.calls
[10:30:50.200]             `[[` <- base::`[[`
[10:30:50.200]             `+` <- base::`+`
[10:30:50.200]             `<<-` <- base::`<<-`
[10:30:50.200]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.200]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.200]                   3L)]
[10:30:50.200]             }
[10:30:50.200]             function(cond) {
[10:30:50.200]                 is_error <- inherits(cond, "error")
[10:30:50.200]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.200]                   NULL)
[10:30:50.200]                 if (is_error) {
[10:30:50.200]                   sessionInformation <- function() {
[10:30:50.200]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.200]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.200]                       search = base::search(), system = base::Sys.info())
[10:30:50.200]                   }
[10:30:50.200]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.200]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.200]                     cond$call), session = sessionInformation(), 
[10:30:50.200]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.200]                   signalCondition(cond)
[10:30:50.200]                 }
[10:30:50.200]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.200]                 "immediateCondition"))) {
[10:30:50.200]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.200]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.200]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.200]                   if (TRUE && !signal) {
[10:30:50.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.200]                     {
[10:30:50.200]                       inherits <- base::inherits
[10:30:50.200]                       invokeRestart <- base::invokeRestart
[10:30:50.200]                       is.null <- base::is.null
[10:30:50.200]                       muffled <- FALSE
[10:30:50.200]                       if (inherits(cond, "message")) {
[10:30:50.200]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.200]                         if (muffled) 
[10:30:50.200]                           invokeRestart("muffleMessage")
[10:30:50.200]                       }
[10:30:50.200]                       else if (inherits(cond, "warning")) {
[10:30:50.200]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.200]                         if (muffled) 
[10:30:50.200]                           invokeRestart("muffleWarning")
[10:30:50.200]                       }
[10:30:50.200]                       else if (inherits(cond, "condition")) {
[10:30:50.200]                         if (!is.null(pattern)) {
[10:30:50.200]                           computeRestarts <- base::computeRestarts
[10:30:50.200]                           grepl <- base::grepl
[10:30:50.200]                           restarts <- computeRestarts(cond)
[10:30:50.200]                           for (restart in restarts) {
[10:30:50.200]                             name <- restart$name
[10:30:50.200]                             if (is.null(name)) 
[10:30:50.200]                               next
[10:30:50.200]                             if (!grepl(pattern, name)) 
[10:30:50.200]                               next
[10:30:50.200]                             invokeRestart(restart)
[10:30:50.200]                             muffled <- TRUE
[10:30:50.200]                             break
[10:30:50.200]                           }
[10:30:50.200]                         }
[10:30:50.200]                       }
[10:30:50.200]                       invisible(muffled)
[10:30:50.200]                     }
[10:30:50.200]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.200]                   }
[10:30:50.200]                 }
[10:30:50.200]                 else {
[10:30:50.200]                   if (TRUE) {
[10:30:50.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.200]                     {
[10:30:50.200]                       inherits <- base::inherits
[10:30:50.200]                       invokeRestart <- base::invokeRestart
[10:30:50.200]                       is.null <- base::is.null
[10:30:50.200]                       muffled <- FALSE
[10:30:50.200]                       if (inherits(cond, "message")) {
[10:30:50.200]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.200]                         if (muffled) 
[10:30:50.200]                           invokeRestart("muffleMessage")
[10:30:50.200]                       }
[10:30:50.200]                       else if (inherits(cond, "warning")) {
[10:30:50.200]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.200]                         if (muffled) 
[10:30:50.200]                           invokeRestart("muffleWarning")
[10:30:50.200]                       }
[10:30:50.200]                       else if (inherits(cond, "condition")) {
[10:30:50.200]                         if (!is.null(pattern)) {
[10:30:50.200]                           computeRestarts <- base::computeRestarts
[10:30:50.200]                           grepl <- base::grepl
[10:30:50.200]                           restarts <- computeRestarts(cond)
[10:30:50.200]                           for (restart in restarts) {
[10:30:50.200]                             name <- restart$name
[10:30:50.200]                             if (is.null(name)) 
[10:30:50.200]                               next
[10:30:50.200]                             if (!grepl(pattern, name)) 
[10:30:50.200]                               next
[10:30:50.200]                             invokeRestart(restart)
[10:30:50.200]                             muffled <- TRUE
[10:30:50.200]                             break
[10:30:50.200]                           }
[10:30:50.200]                         }
[10:30:50.200]                       }
[10:30:50.200]                       invisible(muffled)
[10:30:50.200]                     }
[10:30:50.200]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.200]                   }
[10:30:50.200]                 }
[10:30:50.200]             }
[10:30:50.200]         }))
[10:30:50.200]     }, error = function(ex) {
[10:30:50.200]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.200]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.200]                 ...future.rng), started = ...future.startTime, 
[10:30:50.200]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.200]             version = "1.8"), class = "FutureResult")
[10:30:50.200]     }, finally = {
[10:30:50.200]         if (!identical(...future.workdir, getwd())) 
[10:30:50.200]             setwd(...future.workdir)
[10:30:50.200]         {
[10:30:50.200]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.200]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.200]             }
[10:30:50.200]             base::options(...future.oldOptions)
[10:30:50.200]             if (.Platform$OS.type == "windows") {
[10:30:50.200]                 old_names <- names(...future.oldEnvVars)
[10:30:50.200]                 envs <- base::Sys.getenv()
[10:30:50.200]                 names <- names(envs)
[10:30:50.200]                 common <- intersect(names, old_names)
[10:30:50.200]                 added <- setdiff(names, old_names)
[10:30:50.200]                 removed <- setdiff(old_names, names)
[10:30:50.200]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.200]                   envs[common]]
[10:30:50.200]                 NAMES <- toupper(changed)
[10:30:50.200]                 args <- list()
[10:30:50.200]                 for (kk in seq_along(NAMES)) {
[10:30:50.200]                   name <- changed[[kk]]
[10:30:50.200]                   NAME <- NAMES[[kk]]
[10:30:50.200]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.200]                     next
[10:30:50.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.200]                 }
[10:30:50.200]                 NAMES <- toupper(added)
[10:30:50.200]                 for (kk in seq_along(NAMES)) {
[10:30:50.200]                   name <- added[[kk]]
[10:30:50.200]                   NAME <- NAMES[[kk]]
[10:30:50.200]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.200]                     next
[10:30:50.200]                   args[[name]] <- ""
[10:30:50.200]                 }
[10:30:50.200]                 NAMES <- toupper(removed)
[10:30:50.200]                 for (kk in seq_along(NAMES)) {
[10:30:50.200]                   name <- removed[[kk]]
[10:30:50.200]                   NAME <- NAMES[[kk]]
[10:30:50.200]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.200]                     next
[10:30:50.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.200]                 }
[10:30:50.200]                 if (length(args) > 0) 
[10:30:50.200]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.200]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.200]             }
[10:30:50.200]             else {
[10:30:50.200]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.200]             }
[10:30:50.200]             {
[10:30:50.200]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.200]                   0L) {
[10:30:50.200]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.200]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.200]                   base::options(opts)
[10:30:50.200]                 }
[10:30:50.200]                 {
[10:30:50.200]                   {
[10:30:50.200]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.200]                     NULL
[10:30:50.200]                   }
[10:30:50.200]                   options(future.plan = NULL)
[10:30:50.200]                   if (is.na(NA_character_)) 
[10:30:50.200]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.200]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.200]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.200]                     .init = FALSE)
[10:30:50.200]                 }
[10:30:50.200]             }
[10:30:50.200]         }
[10:30:50.200]     })
[10:30:50.200]     if (TRUE) {
[10:30:50.200]         base::sink(type = "output", split = FALSE)
[10:30:50.200]         if (TRUE) {
[10:30:50.200]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.200]         }
[10:30:50.200]         else {
[10:30:50.200]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.200]         }
[10:30:50.200]         base::close(...future.stdout)
[10:30:50.200]         ...future.stdout <- NULL
[10:30:50.200]     }
[10:30:50.200]     ...future.result$conditions <- ...future.conditions
[10:30:50.200]     ...future.result$finished <- base::Sys.time()
[10:30:50.200]     ...future.result
[10:30:50.200] }
[10:30:50.203] assign_globals() ...
[10:30:50.203] List of 5
[10:30:50.203]  $ ...future.FUN            :function (C, k)  
[10:30:50.203]  $ MoreArgs                 : NULL
[10:30:50.203]  $ ...future.elements_ii    :List of 2
[10:30:50.203]   ..$ :List of 2
[10:30:50.203]   .. ..$ : chr "C"
[10:30:50.203]   .. ..$ : chr "B"
[10:30:50.203]   ..$ :List of 2
[10:30:50.203]   .. ..$ : int 3
[10:30:50.203]   .. ..$ : int 4
[10:30:50.203]  $ ...future.seeds_ii       : NULL
[10:30:50.203]  $ ...future.globals.maxSize: NULL
[10:30:50.203]  - attr(*, "where")=List of 5
[10:30:50.203]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.203]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.203]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.203]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.203]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.203]  - attr(*, "resolved")= logi FALSE
[10:30:50.203]  - attr(*, "total_size")= num 3656
[10:30:50.203]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.203]  - attr(*, "already-done")= logi TRUE
[10:30:50.209] - reassign environment for ‘...future.FUN’
[10:30:50.209] - copied ‘...future.FUN’ to environment
[10:30:50.209] - copied ‘MoreArgs’ to environment
[10:30:50.209] - copied ‘...future.elements_ii’ to environment
[10:30:50.209] - copied ‘...future.seeds_ii’ to environment
[10:30:50.209] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.209] assign_globals() ... done
[10:30:50.209] requestCore(): workers = 2
[10:30:50.212] MulticoreFuture started
[10:30:50.212] - Launch lazy future ... done
[10:30:50.212] run() for ‘MulticoreFuture’ ... done
[10:30:50.213] Created future:
[10:30:50.213] plan(): Setting new future strategy stack:
[10:30:50.213] List of future strategies:
[10:30:50.213] 1. sequential:
[10:30:50.213]    - args: function (..., envir = parent.frame())
[10:30:50.213]    - tweaked: FALSE
[10:30:50.213]    - call: NULL
[10:30:50.214] plan(): nbrOfWorkers() = 1
[10:30:50.216] plan(): Setting new future strategy stack:
[10:30:50.216] List of future strategies:
[10:30:50.216] 1. multicore:
[10:30:50.216]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.216]    - tweaked: FALSE
[10:30:50.216]    - call: plan(strategy)
[10:30:50.222] plan(): nbrOfWorkers() = 2
[10:30:50.213] MulticoreFuture:
[10:30:50.213] Label: ‘future_mapply-1’
[10:30:50.213] Expression:
[10:30:50.213] {
[10:30:50.213]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.213]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.213]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.213]         on.exit(options(oopts), add = TRUE)
[10:30:50.213]     }
[10:30:50.213]     {
[10:30:50.213]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.213]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.213]         do.call(mapply, args = args)
[10:30:50.213]     }
[10:30:50.213] }
[10:30:50.213] Lazy evaluation: FALSE
[10:30:50.213] Asynchronous evaluation: TRUE
[10:30:50.213] Local evaluation: TRUE
[10:30:50.213] Environment: R_GlobalEnv
[10:30:50.213] Capture standard output: TRUE
[10:30:50.213] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.213] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.213] Packages: <none>
[10:30:50.213] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.213] Resolved: TRUE
[10:30:50.213] Value: <not collected>
[10:30:50.213] Conditions captured: <none>
[10:30:50.213] Early signaling: FALSE
[10:30:50.213] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.213] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.223] Chunk #1 of 3 ... DONE
[10:30:50.223] Chunk #2 of 3 ...
[10:30:50.223]  - Finding globals in '...' for chunk #2 ...
[10:30:50.223] getGlobalsAndPackages() ...
[10:30:50.223] Searching for globals...
[10:30:50.224] 
[10:30:50.224] Searching for globals ... DONE
[10:30:50.224] - globals: [0] <none>
[10:30:50.224] getGlobalsAndPackages() ... DONE
[10:30:50.225]    + additional globals found: [n=0] 
[10:30:50.225]    + additional namespaces needed: [n=0] 
[10:30:50.225]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:50.225]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:30:50.225]  - seeds: <none>
[10:30:50.225]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.226] getGlobalsAndPackages() ...
[10:30:50.226] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.226] Resolving globals: FALSE
[10:30:50.227] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:50.228] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:50.228] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.228] 
[10:30:50.228] getGlobalsAndPackages() ... DONE
[10:30:50.229] run() for ‘Future’ ...
[10:30:50.229] - state: ‘created’
[10:30:50.233] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.240] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.241]   - Field: ‘label’
[10:30:50.241]   - Field: ‘local’
[10:30:50.241]   - Field: ‘owner’
[10:30:50.242]   - Field: ‘envir’
[10:30:50.242]   - Field: ‘workers’
[10:30:50.242]   - Field: ‘packages’
[10:30:50.242]   - Field: ‘gc’
[10:30:50.243]   - Field: ‘job’
[10:30:50.243]   - Field: ‘conditions’
[10:30:50.243]   - Field: ‘expr’
[10:30:50.243]   - Field: ‘uuid’
[10:30:50.244]   - Field: ‘seed’
[10:30:50.244]   - Field: ‘version’
[10:30:50.244]   - Field: ‘result’
[10:30:50.244]   - Field: ‘asynchronous’
[10:30:50.244]   - Field: ‘calls’
[10:30:50.245]   - Field: ‘globals’
[10:30:50.245]   - Field: ‘stdout’
[10:30:50.245]   - Field: ‘earlySignal’
[10:30:50.246]   - Field: ‘lazy’
[10:30:50.246]   - Field: ‘state’
[10:30:50.246] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.246] - Launch lazy future ...
[10:30:50.247] Packages needed by the future expression (n = 0): <none>
[10:30:50.247] Packages needed by future strategies (n = 0): <none>
[10:30:50.248] {
[10:30:50.248]     {
[10:30:50.248]         {
[10:30:50.248]             ...future.startTime <- base::Sys.time()
[10:30:50.248]             {
[10:30:50.248]                 {
[10:30:50.248]                   {
[10:30:50.248]                     {
[10:30:50.248]                       base::local({
[10:30:50.248]                         has_future <- base::requireNamespace("future", 
[10:30:50.248]                           quietly = TRUE)
[10:30:50.248]                         if (has_future) {
[10:30:50.248]                           ns <- base::getNamespace("future")
[10:30:50.248]                           version <- ns[[".package"]][["version"]]
[10:30:50.248]                           if (is.null(version)) 
[10:30:50.248]                             version <- utils::packageVersion("future")
[10:30:50.248]                         }
[10:30:50.248]                         else {
[10:30:50.248]                           version <- NULL
[10:30:50.248]                         }
[10:30:50.248]                         if (!has_future || version < "1.8.0") {
[10:30:50.248]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.248]                             "", base::R.version$version.string), 
[10:30:50.248]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.248]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.248]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.248]                               "release", "version")], collapse = " "), 
[10:30:50.248]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.248]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.248]                             info)
[10:30:50.248]                           info <- base::paste(info, collapse = "; ")
[10:30:50.248]                           if (!has_future) {
[10:30:50.248]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.248]                               info)
[10:30:50.248]                           }
[10:30:50.248]                           else {
[10:30:50.248]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.248]                               info, version)
[10:30:50.248]                           }
[10:30:50.248]                           base::stop(msg)
[10:30:50.248]                         }
[10:30:50.248]                       })
[10:30:50.248]                     }
[10:30:50.248]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.248]                     base::options(mc.cores = 1L)
[10:30:50.248]                   }
[10:30:50.248]                   ...future.strategy.old <- future::plan("list")
[10:30:50.248]                   options(future.plan = NULL)
[10:30:50.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.248]                 }
[10:30:50.248]                 ...future.workdir <- getwd()
[10:30:50.248]             }
[10:30:50.248]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.248]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.248]         }
[10:30:50.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.248]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:30:50.248]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.248]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.248]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.248]             base::names(...future.oldOptions))
[10:30:50.248]     }
[10:30:50.248]     if (FALSE) {
[10:30:50.248]     }
[10:30:50.248]     else {
[10:30:50.248]         if (TRUE) {
[10:30:50.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.248]                 open = "w")
[10:30:50.248]         }
[10:30:50.248]         else {
[10:30:50.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.248]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.248]         }
[10:30:50.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.248]             base::sink(type = "output", split = FALSE)
[10:30:50.248]             base::close(...future.stdout)
[10:30:50.248]         }, add = TRUE)
[10:30:50.248]     }
[10:30:50.248]     ...future.frame <- base::sys.nframe()
[10:30:50.248]     ...future.conditions <- base::list()
[10:30:50.248]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.248]     if (FALSE) {
[10:30:50.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.248]     }
[10:30:50.248]     ...future.result <- base::tryCatch({
[10:30:50.248]         base::withCallingHandlers({
[10:30:50.248]             ...future.value <- base::withVisible(base::local({
[10:30:50.248]                 withCallingHandlers({
[10:30:50.248]                   {
[10:30:50.248]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.248]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.248]                       ...future.globals.maxSize)) {
[10:30:50.248]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.248]                       on.exit(options(oopts), add = TRUE)
[10:30:50.248]                     }
[10:30:50.248]                     {
[10:30:50.248]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.248]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.248]                         USE.NAMES = FALSE)
[10:30:50.248]                       do.call(mapply, args = args)
[10:30:50.248]                     }
[10:30:50.248]                   }
[10:30:50.248]                 }, immediateCondition = function(cond) {
[10:30:50.248]                   save_rds <- function (object, pathname, ...) 
[10:30:50.248]                   {
[10:30:50.248]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.248]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.248]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.248]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.248]                         fi_tmp[["mtime"]])
[10:30:50.248]                     }
[10:30:50.248]                     tryCatch({
[10:30:50.248]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.248]                     }, error = function(ex) {
[10:30:50.248]                       msg <- conditionMessage(ex)
[10:30:50.248]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.248]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.248]                         fi_tmp[["mtime"]], msg)
[10:30:50.248]                       ex$message <- msg
[10:30:50.248]                       stop(ex)
[10:30:50.248]                     })
[10:30:50.248]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.248]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.248]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.248]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.248]                       fi <- file.info(pathname)
[10:30:50.248]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.248]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.248]                         fi[["size"]], fi[["mtime"]])
[10:30:50.248]                       stop(msg)
[10:30:50.248]                     }
[10:30:50.248]                     invisible(pathname)
[10:30:50.248]                   }
[10:30:50.248]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.248]                     rootPath = tempdir()) 
[10:30:50.248]                   {
[10:30:50.248]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.248]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.248]                       tmpdir = path, fileext = ".rds")
[10:30:50.248]                     save_rds(obj, file)
[10:30:50.248]                   }
[10:30:50.248]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.248]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.248]                   {
[10:30:50.248]                     inherits <- base::inherits
[10:30:50.248]                     invokeRestart <- base::invokeRestart
[10:30:50.248]                     is.null <- base::is.null
[10:30:50.248]                     muffled <- FALSE
[10:30:50.248]                     if (inherits(cond, "message")) {
[10:30:50.248]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.248]                       if (muffled) 
[10:30:50.248]                         invokeRestart("muffleMessage")
[10:30:50.248]                     }
[10:30:50.248]                     else if (inherits(cond, "warning")) {
[10:30:50.248]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.248]                       if (muffled) 
[10:30:50.248]                         invokeRestart("muffleWarning")
[10:30:50.248]                     }
[10:30:50.248]                     else if (inherits(cond, "condition")) {
[10:30:50.248]                       if (!is.null(pattern)) {
[10:30:50.248]                         computeRestarts <- base::computeRestarts
[10:30:50.248]                         grepl <- base::grepl
[10:30:50.248]                         restarts <- computeRestarts(cond)
[10:30:50.248]                         for (restart in restarts) {
[10:30:50.248]                           name <- restart$name
[10:30:50.248]                           if (is.null(name)) 
[10:30:50.248]                             next
[10:30:50.248]                           if (!grepl(pattern, name)) 
[10:30:50.248]                             next
[10:30:50.248]                           invokeRestart(restart)
[10:30:50.248]                           muffled <- TRUE
[10:30:50.248]                           break
[10:30:50.248]                         }
[10:30:50.248]                       }
[10:30:50.248]                     }
[10:30:50.248]                     invisible(muffled)
[10:30:50.248]                   }
[10:30:50.248]                   muffleCondition(cond)
[10:30:50.248]                 })
[10:30:50.248]             }))
[10:30:50.248]             future::FutureResult(value = ...future.value$value, 
[10:30:50.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.248]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.248]                     ...future.globalenv.names))
[10:30:50.248]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.248]         }, condition = base::local({
[10:30:50.248]             c <- base::c
[10:30:50.248]             inherits <- base::inherits
[10:30:50.248]             invokeRestart <- base::invokeRestart
[10:30:50.248]             length <- base::length
[10:30:50.248]             list <- base::list
[10:30:50.248]             seq.int <- base::seq.int
[10:30:50.248]             signalCondition <- base::signalCondition
[10:30:50.248]             sys.calls <- base::sys.calls
[10:30:50.248]             `[[` <- base::`[[`
[10:30:50.248]             `+` <- base::`+`
[10:30:50.248]             `<<-` <- base::`<<-`
[10:30:50.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.248]                   3L)]
[10:30:50.248]             }
[10:30:50.248]             function(cond) {
[10:30:50.248]                 is_error <- inherits(cond, "error")
[10:30:50.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.248]                   NULL)
[10:30:50.248]                 if (is_error) {
[10:30:50.248]                   sessionInformation <- function() {
[10:30:50.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.248]                       search = base::search(), system = base::Sys.info())
[10:30:50.248]                   }
[10:30:50.248]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.248]                     cond$call), session = sessionInformation(), 
[10:30:50.248]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.248]                   signalCondition(cond)
[10:30:50.248]                 }
[10:30:50.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.248]                 "immediateCondition"))) {
[10:30:50.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.248]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.248]                   if (TRUE && !signal) {
[10:30:50.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.248]                     {
[10:30:50.248]                       inherits <- base::inherits
[10:30:50.248]                       invokeRestart <- base::invokeRestart
[10:30:50.248]                       is.null <- base::is.null
[10:30:50.248]                       muffled <- FALSE
[10:30:50.248]                       if (inherits(cond, "message")) {
[10:30:50.248]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.248]                         if (muffled) 
[10:30:50.248]                           invokeRestart("muffleMessage")
[10:30:50.248]                       }
[10:30:50.248]                       else if (inherits(cond, "warning")) {
[10:30:50.248]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.248]                         if (muffled) 
[10:30:50.248]                           invokeRestart("muffleWarning")
[10:30:50.248]                       }
[10:30:50.248]                       else if (inherits(cond, "condition")) {
[10:30:50.248]                         if (!is.null(pattern)) {
[10:30:50.248]                           computeRestarts <- base::computeRestarts
[10:30:50.248]                           grepl <- base::grepl
[10:30:50.248]                           restarts <- computeRestarts(cond)
[10:30:50.248]                           for (restart in restarts) {
[10:30:50.248]                             name <- restart$name
[10:30:50.248]                             if (is.null(name)) 
[10:30:50.248]                               next
[10:30:50.248]                             if (!grepl(pattern, name)) 
[10:30:50.248]                               next
[10:30:50.248]                             invokeRestart(restart)
[10:30:50.248]                             muffled <- TRUE
[10:30:50.248]                             break
[10:30:50.248]                           }
[10:30:50.248]                         }
[10:30:50.248]                       }
[10:30:50.248]                       invisible(muffled)
[10:30:50.248]                     }
[10:30:50.248]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.248]                   }
[10:30:50.248]                 }
[10:30:50.248]                 else {
[10:30:50.248]                   if (TRUE) {
[10:30:50.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.248]                     {
[10:30:50.248]                       inherits <- base::inherits
[10:30:50.248]                       invokeRestart <- base::invokeRestart
[10:30:50.248]                       is.null <- base::is.null
[10:30:50.248]                       muffled <- FALSE
[10:30:50.248]                       if (inherits(cond, "message")) {
[10:30:50.248]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.248]                         if (muffled) 
[10:30:50.248]                           invokeRestart("muffleMessage")
[10:30:50.248]                       }
[10:30:50.248]                       else if (inherits(cond, "warning")) {
[10:30:50.248]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.248]                         if (muffled) 
[10:30:50.248]                           invokeRestart("muffleWarning")
[10:30:50.248]                       }
[10:30:50.248]                       else if (inherits(cond, "condition")) {
[10:30:50.248]                         if (!is.null(pattern)) {
[10:30:50.248]                           computeRestarts <- base::computeRestarts
[10:30:50.248]                           grepl <- base::grepl
[10:30:50.248]                           restarts <- computeRestarts(cond)
[10:30:50.248]                           for (restart in restarts) {
[10:30:50.248]                             name <- restart$name
[10:30:50.248]                             if (is.null(name)) 
[10:30:50.248]                               next
[10:30:50.248]                             if (!grepl(pattern, name)) 
[10:30:50.248]                               next
[10:30:50.248]                             invokeRestart(restart)
[10:30:50.248]                             muffled <- TRUE
[10:30:50.248]                             break
[10:30:50.248]                           }
[10:30:50.248]                         }
[10:30:50.248]                       }
[10:30:50.248]                       invisible(muffled)
[10:30:50.248]                     }
[10:30:50.248]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.248]                   }
[10:30:50.248]                 }
[10:30:50.248]             }
[10:30:50.248]         }))
[10:30:50.248]     }, error = function(ex) {
[10:30:50.248]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.248]                 ...future.rng), started = ...future.startTime, 
[10:30:50.248]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.248]             version = "1.8"), class = "FutureResult")
[10:30:50.248]     }, finally = {
[10:30:50.248]         if (!identical(...future.workdir, getwd())) 
[10:30:50.248]             setwd(...future.workdir)
[10:30:50.248]         {
[10:30:50.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.248]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.248]             }
[10:30:50.248]             base::options(...future.oldOptions)
[10:30:50.248]             if (.Platform$OS.type == "windows") {
[10:30:50.248]                 old_names <- names(...future.oldEnvVars)
[10:30:50.248]                 envs <- base::Sys.getenv()
[10:30:50.248]                 names <- names(envs)
[10:30:50.248]                 common <- intersect(names, old_names)
[10:30:50.248]                 added <- setdiff(names, old_names)
[10:30:50.248]                 removed <- setdiff(old_names, names)
[10:30:50.248]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.248]                   envs[common]]
[10:30:50.248]                 NAMES <- toupper(changed)
[10:30:50.248]                 args <- list()
[10:30:50.248]                 for (kk in seq_along(NAMES)) {
[10:30:50.248]                   name <- changed[[kk]]
[10:30:50.248]                   NAME <- NAMES[[kk]]
[10:30:50.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.248]                     next
[10:30:50.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.248]                 }
[10:30:50.248]                 NAMES <- toupper(added)
[10:30:50.248]                 for (kk in seq_along(NAMES)) {
[10:30:50.248]                   name <- added[[kk]]
[10:30:50.248]                   NAME <- NAMES[[kk]]
[10:30:50.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.248]                     next
[10:30:50.248]                   args[[name]] <- ""
[10:30:50.248]                 }
[10:30:50.248]                 NAMES <- toupper(removed)
[10:30:50.248]                 for (kk in seq_along(NAMES)) {
[10:30:50.248]                   name <- removed[[kk]]
[10:30:50.248]                   NAME <- NAMES[[kk]]
[10:30:50.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.248]                     next
[10:30:50.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.248]                 }
[10:30:50.248]                 if (length(args) > 0) 
[10:30:50.248]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.248]             }
[10:30:50.248]             else {
[10:30:50.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.248]             }
[10:30:50.248]             {
[10:30:50.248]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.248]                   0L) {
[10:30:50.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.248]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.248]                   base::options(opts)
[10:30:50.248]                 }
[10:30:50.248]                 {
[10:30:50.248]                   {
[10:30:50.248]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.248]                     NULL
[10:30:50.248]                   }
[10:30:50.248]                   options(future.plan = NULL)
[10:30:50.248]                   if (is.na(NA_character_)) 
[10:30:50.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.248]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.248]                     .init = FALSE)
[10:30:50.248]                 }
[10:30:50.248]             }
[10:30:50.248]         }
[10:30:50.248]     })
[10:30:50.248]     if (TRUE) {
[10:30:50.248]         base::sink(type = "output", split = FALSE)
[10:30:50.248]         if (TRUE) {
[10:30:50.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.248]         }
[10:30:50.248]         else {
[10:30:50.248]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.248]         }
[10:30:50.248]         base::close(...future.stdout)
[10:30:50.248]         ...future.stdout <- NULL
[10:30:50.248]     }
[10:30:50.248]     ...future.result$conditions <- ...future.conditions
[10:30:50.248]     ...future.result$finished <- base::Sys.time()
[10:30:50.248]     ...future.result
[10:30:50.248] }
[10:30:50.251] assign_globals() ...
[10:30:50.251] List of 5
[10:30:50.251]  $ ...future.FUN            :function (C, k)  
[10:30:50.251]  $ MoreArgs                 : NULL
[10:30:50.251]  $ ...future.elements_ii    :List of 2
[10:30:50.251]   ..$ :List of 1
[10:30:50.251]   .. ..$ : chr "D"
[10:30:50.251]   ..$ :List of 1
[10:30:50.251]   .. ..$ : int 2
[10:30:50.251]  $ ...future.seeds_ii       : NULL
[10:30:50.251]  $ ...future.globals.maxSize: NULL
[10:30:50.251]  - attr(*, "where")=List of 5
[10:30:50.251]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.251]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.251]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.251]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.251]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.251]  - attr(*, "resolved")= logi FALSE
[10:30:50.251]  - attr(*, "total_size")= num 3488
[10:30:50.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.251]  - attr(*, "already-done")= logi TRUE
[10:30:50.259] - reassign environment for ‘...future.FUN’
[10:30:50.259] - copied ‘...future.FUN’ to environment
[10:30:50.259] - copied ‘MoreArgs’ to environment
[10:30:50.259] - copied ‘...future.elements_ii’ to environment
[10:30:50.260] - copied ‘...future.seeds_ii’ to environment
[10:30:50.260] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.260] assign_globals() ... done
[10:30:50.260] requestCore(): workers = 2
[10:30:50.262] MulticoreFuture started
[10:30:50.263] - Launch lazy future ... done
[10:30:50.263] run() for ‘MulticoreFuture’ ... done
[10:30:50.263] Created future:
[10:30:50.263] plan(): Setting new future strategy stack:
[10:30:50.264] List of future strategies:
[10:30:50.264] 1. sequential:
[10:30:50.264]    - args: function (..., envir = parent.frame())
[10:30:50.264]    - tweaked: FALSE
[10:30:50.264]    - call: NULL
[10:30:50.265] plan(): nbrOfWorkers() = 1
[10:30:50.267] plan(): Setting new future strategy stack:
[10:30:50.267] List of future strategies:
[10:30:50.267] 1. multicore:
[10:30:50.267]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.267]    - tweaked: FALSE
[10:30:50.267]    - call: plan(strategy)
[10:30:50.272] plan(): nbrOfWorkers() = 2
[10:30:50.263] MulticoreFuture:
[10:30:50.263] Label: ‘future_mapply-2’
[10:30:50.263] Expression:
[10:30:50.263] {
[10:30:50.263]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.263]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.263]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.263]         on.exit(options(oopts), add = TRUE)
[10:30:50.263]     }
[10:30:50.263]     {
[10:30:50.263]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.263]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.263]         do.call(mapply, args = args)
[10:30:50.263]     }
[10:30:50.263] }
[10:30:50.263] Lazy evaluation: FALSE
[10:30:50.263] Asynchronous evaluation: TRUE
[10:30:50.263] Local evaluation: TRUE
[10:30:50.263] Environment: R_GlobalEnv
[10:30:50.263] Capture standard output: TRUE
[10:30:50.263] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.263] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.263] Packages: <none>
[10:30:50.263] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.263] Resolved: TRUE
[10:30:50.263] Value: <not collected>
[10:30:50.263] Conditions captured: <none>
[10:30:50.263] Early signaling: FALSE
[10:30:50.263] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.263] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.273] Chunk #2 of 3 ... DONE
[10:30:50.274] Chunk #3 of 3 ...
[10:30:50.274]  - Finding globals in '...' for chunk #3 ...
[10:30:50.274] getGlobalsAndPackages() ...
[10:30:50.274] Searching for globals...
[10:30:50.275] 
[10:30:50.275] Searching for globals ... DONE
[10:30:50.275] - globals: [0] <none>
[10:30:50.275] getGlobalsAndPackages() ... DONE
[10:30:50.275]    + additional globals found: [n=0] 
[10:30:50.276]    + additional namespaces needed: [n=0] 
[10:30:50.276]  - Finding globals in '...' for chunk #3 ... DONE
[10:30:50.276]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:30:50.276]  - seeds: <none>
[10:30:50.276]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.276] getGlobalsAndPackages() ...
[10:30:50.276] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.277] Resolving globals: FALSE
[10:30:50.278] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:50.278] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:50.279] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.279] 
[10:30:50.279] getGlobalsAndPackages() ... DONE
[10:30:50.279] run() for ‘Future’ ...
[10:30:50.280] - state: ‘created’
[10:30:50.280] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.285] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.285] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.285]   - Field: ‘label’
[10:30:50.285]   - Field: ‘local’
[10:30:50.285]   - Field: ‘owner’
[10:30:50.289]   - Field: ‘envir’
[10:30:50.290]   - Field: ‘workers’
[10:30:50.290]   - Field: ‘packages’
[10:30:50.290]   - Field: ‘gc’
[10:30:50.291]   - Field: ‘job’
[10:30:50.291]   - Field: ‘conditions’
[10:30:50.291]   - Field: ‘expr’
[10:30:50.292]   - Field: ‘uuid’
[10:30:50.292]   - Field: ‘seed’
[10:30:50.292]   - Field: ‘version’
[10:30:50.292]   - Field: ‘result’
[10:30:50.293]   - Field: ‘asynchronous’
[10:30:50.293]   - Field: ‘calls’
[10:30:50.293]   - Field: ‘globals’
[10:30:50.293]   - Field: ‘stdout’
[10:30:50.294]   - Field: ‘earlySignal’
[10:30:50.294]   - Field: ‘lazy’
[10:30:50.294]   - Field: ‘state’
[10:30:50.294] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.295] - Launch lazy future ...
[10:30:50.295] Packages needed by the future expression (n = 0): <none>
[10:30:50.296] Packages needed by future strategies (n = 0): <none>
[10:30:50.297] {
[10:30:50.297]     {
[10:30:50.297]         {
[10:30:50.297]             ...future.startTime <- base::Sys.time()
[10:30:50.297]             {
[10:30:50.297]                 {
[10:30:50.297]                   {
[10:30:50.297]                     {
[10:30:50.297]                       base::local({
[10:30:50.297]                         has_future <- base::requireNamespace("future", 
[10:30:50.297]                           quietly = TRUE)
[10:30:50.297]                         if (has_future) {
[10:30:50.297]                           ns <- base::getNamespace("future")
[10:30:50.297]                           version <- ns[[".package"]][["version"]]
[10:30:50.297]                           if (is.null(version)) 
[10:30:50.297]                             version <- utils::packageVersion("future")
[10:30:50.297]                         }
[10:30:50.297]                         else {
[10:30:50.297]                           version <- NULL
[10:30:50.297]                         }
[10:30:50.297]                         if (!has_future || version < "1.8.0") {
[10:30:50.297]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.297]                             "", base::R.version$version.string), 
[10:30:50.297]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.297]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.297]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.297]                               "release", "version")], collapse = " "), 
[10:30:50.297]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.297]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.297]                             info)
[10:30:50.297]                           info <- base::paste(info, collapse = "; ")
[10:30:50.297]                           if (!has_future) {
[10:30:50.297]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.297]                               info)
[10:30:50.297]                           }
[10:30:50.297]                           else {
[10:30:50.297]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.297]                               info, version)
[10:30:50.297]                           }
[10:30:50.297]                           base::stop(msg)
[10:30:50.297]                         }
[10:30:50.297]                       })
[10:30:50.297]                     }
[10:30:50.297]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.297]                     base::options(mc.cores = 1L)
[10:30:50.297]                   }
[10:30:50.297]                   ...future.strategy.old <- future::plan("list")
[10:30:50.297]                   options(future.plan = NULL)
[10:30:50.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.297]                 }
[10:30:50.297]                 ...future.workdir <- getwd()
[10:30:50.297]             }
[10:30:50.297]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.297]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.297]         }
[10:30:50.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.297]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:30:50.297]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.297]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.297]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.297]             base::names(...future.oldOptions))
[10:30:50.297]     }
[10:30:50.297]     if (FALSE) {
[10:30:50.297]     }
[10:30:50.297]     else {
[10:30:50.297]         if (TRUE) {
[10:30:50.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.297]                 open = "w")
[10:30:50.297]         }
[10:30:50.297]         else {
[10:30:50.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.297]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.297]         }
[10:30:50.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.297]             base::sink(type = "output", split = FALSE)
[10:30:50.297]             base::close(...future.stdout)
[10:30:50.297]         }, add = TRUE)
[10:30:50.297]     }
[10:30:50.297]     ...future.frame <- base::sys.nframe()
[10:30:50.297]     ...future.conditions <- base::list()
[10:30:50.297]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.297]     if (FALSE) {
[10:30:50.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.297]     }
[10:30:50.297]     ...future.result <- base::tryCatch({
[10:30:50.297]         base::withCallingHandlers({
[10:30:50.297]             ...future.value <- base::withVisible(base::local({
[10:30:50.297]                 withCallingHandlers({
[10:30:50.297]                   {
[10:30:50.297]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.297]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.297]                       ...future.globals.maxSize)) {
[10:30:50.297]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.297]                       on.exit(options(oopts), add = TRUE)
[10:30:50.297]                     }
[10:30:50.297]                     {
[10:30:50.297]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.297]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.297]                         USE.NAMES = FALSE)
[10:30:50.297]                       do.call(mapply, args = args)
[10:30:50.297]                     }
[10:30:50.297]                   }
[10:30:50.297]                 }, immediateCondition = function(cond) {
[10:30:50.297]                   save_rds <- function (object, pathname, ...) 
[10:30:50.297]                   {
[10:30:50.297]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.297]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.297]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.297]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.297]                         fi_tmp[["mtime"]])
[10:30:50.297]                     }
[10:30:50.297]                     tryCatch({
[10:30:50.297]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.297]                     }, error = function(ex) {
[10:30:50.297]                       msg <- conditionMessage(ex)
[10:30:50.297]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.297]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.297]                         fi_tmp[["mtime"]], msg)
[10:30:50.297]                       ex$message <- msg
[10:30:50.297]                       stop(ex)
[10:30:50.297]                     })
[10:30:50.297]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.297]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.297]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.297]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.297]                       fi <- file.info(pathname)
[10:30:50.297]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.297]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.297]                         fi[["size"]], fi[["mtime"]])
[10:30:50.297]                       stop(msg)
[10:30:50.297]                     }
[10:30:50.297]                     invisible(pathname)
[10:30:50.297]                   }
[10:30:50.297]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.297]                     rootPath = tempdir()) 
[10:30:50.297]                   {
[10:30:50.297]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.297]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.297]                       tmpdir = path, fileext = ".rds")
[10:30:50.297]                     save_rds(obj, file)
[10:30:50.297]                   }
[10:30:50.297]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.297]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.297]                   {
[10:30:50.297]                     inherits <- base::inherits
[10:30:50.297]                     invokeRestart <- base::invokeRestart
[10:30:50.297]                     is.null <- base::is.null
[10:30:50.297]                     muffled <- FALSE
[10:30:50.297]                     if (inherits(cond, "message")) {
[10:30:50.297]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.297]                       if (muffled) 
[10:30:50.297]                         invokeRestart("muffleMessage")
[10:30:50.297]                     }
[10:30:50.297]                     else if (inherits(cond, "warning")) {
[10:30:50.297]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.297]                       if (muffled) 
[10:30:50.297]                         invokeRestart("muffleWarning")
[10:30:50.297]                     }
[10:30:50.297]                     else if (inherits(cond, "condition")) {
[10:30:50.297]                       if (!is.null(pattern)) {
[10:30:50.297]                         computeRestarts <- base::computeRestarts
[10:30:50.297]                         grepl <- base::grepl
[10:30:50.297]                         restarts <- computeRestarts(cond)
[10:30:50.297]                         for (restart in restarts) {
[10:30:50.297]                           name <- restart$name
[10:30:50.297]                           if (is.null(name)) 
[10:30:50.297]                             next
[10:30:50.297]                           if (!grepl(pattern, name)) 
[10:30:50.297]                             next
[10:30:50.297]                           invokeRestart(restart)
[10:30:50.297]                           muffled <- TRUE
[10:30:50.297]                           break
[10:30:50.297]                         }
[10:30:50.297]                       }
[10:30:50.297]                     }
[10:30:50.297]                     invisible(muffled)
[10:30:50.297]                   }
[10:30:50.297]                   muffleCondition(cond)
[10:30:50.297]                 })
[10:30:50.297]             }))
[10:30:50.297]             future::FutureResult(value = ...future.value$value, 
[10:30:50.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.297]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.297]                     ...future.globalenv.names))
[10:30:50.297]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.297]         }, condition = base::local({
[10:30:50.297]             c <- base::c
[10:30:50.297]             inherits <- base::inherits
[10:30:50.297]             invokeRestart <- base::invokeRestart
[10:30:50.297]             length <- base::length
[10:30:50.297]             list <- base::list
[10:30:50.297]             seq.int <- base::seq.int
[10:30:50.297]             signalCondition <- base::signalCondition
[10:30:50.297]             sys.calls <- base::sys.calls
[10:30:50.297]             `[[` <- base::`[[`
[10:30:50.297]             `+` <- base::`+`
[10:30:50.297]             `<<-` <- base::`<<-`
[10:30:50.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.297]                   3L)]
[10:30:50.297]             }
[10:30:50.297]             function(cond) {
[10:30:50.297]                 is_error <- inherits(cond, "error")
[10:30:50.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.297]                   NULL)
[10:30:50.297]                 if (is_error) {
[10:30:50.297]                   sessionInformation <- function() {
[10:30:50.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.297]                       search = base::search(), system = base::Sys.info())
[10:30:50.297]                   }
[10:30:50.297]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.297]                     cond$call), session = sessionInformation(), 
[10:30:50.297]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.297]                   signalCondition(cond)
[10:30:50.297]                 }
[10:30:50.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.297]                 "immediateCondition"))) {
[10:30:50.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.297]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.297]                   if (TRUE && !signal) {
[10:30:50.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.297]                     {
[10:30:50.297]                       inherits <- base::inherits
[10:30:50.297]                       invokeRestart <- base::invokeRestart
[10:30:50.297]                       is.null <- base::is.null
[10:30:50.297]                       muffled <- FALSE
[10:30:50.297]                       if (inherits(cond, "message")) {
[10:30:50.297]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.297]                         if (muffled) 
[10:30:50.297]                           invokeRestart("muffleMessage")
[10:30:50.297]                       }
[10:30:50.297]                       else if (inherits(cond, "warning")) {
[10:30:50.297]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.297]                         if (muffled) 
[10:30:50.297]                           invokeRestart("muffleWarning")
[10:30:50.297]                       }
[10:30:50.297]                       else if (inherits(cond, "condition")) {
[10:30:50.297]                         if (!is.null(pattern)) {
[10:30:50.297]                           computeRestarts <- base::computeRestarts
[10:30:50.297]                           grepl <- base::grepl
[10:30:50.297]                           restarts <- computeRestarts(cond)
[10:30:50.297]                           for (restart in restarts) {
[10:30:50.297]                             name <- restart$name
[10:30:50.297]                             if (is.null(name)) 
[10:30:50.297]                               next
[10:30:50.297]                             if (!grepl(pattern, name)) 
[10:30:50.297]                               next
[10:30:50.297]                             invokeRestart(restart)
[10:30:50.297]                             muffled <- TRUE
[10:30:50.297]                             break
[10:30:50.297]                           }
[10:30:50.297]                         }
[10:30:50.297]                       }
[10:30:50.297]                       invisible(muffled)
[10:30:50.297]                     }
[10:30:50.297]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.297]                   }
[10:30:50.297]                 }
[10:30:50.297]                 else {
[10:30:50.297]                   if (TRUE) {
[10:30:50.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.297]                     {
[10:30:50.297]                       inherits <- base::inherits
[10:30:50.297]                       invokeRestart <- base::invokeRestart
[10:30:50.297]                       is.null <- base::is.null
[10:30:50.297]                       muffled <- FALSE
[10:30:50.297]                       if (inherits(cond, "message")) {
[10:30:50.297]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.297]                         if (muffled) 
[10:30:50.297]                           invokeRestart("muffleMessage")
[10:30:50.297]                       }
[10:30:50.297]                       else if (inherits(cond, "warning")) {
[10:30:50.297]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.297]                         if (muffled) 
[10:30:50.297]                           invokeRestart("muffleWarning")
[10:30:50.297]                       }
[10:30:50.297]                       else if (inherits(cond, "condition")) {
[10:30:50.297]                         if (!is.null(pattern)) {
[10:30:50.297]                           computeRestarts <- base::computeRestarts
[10:30:50.297]                           grepl <- base::grepl
[10:30:50.297]                           restarts <- computeRestarts(cond)
[10:30:50.297]                           for (restart in restarts) {
[10:30:50.297]                             name <- restart$name
[10:30:50.297]                             if (is.null(name)) 
[10:30:50.297]                               next
[10:30:50.297]                             if (!grepl(pattern, name)) 
[10:30:50.297]                               next
[10:30:50.297]                             invokeRestart(restart)
[10:30:50.297]                             muffled <- TRUE
[10:30:50.297]                             break
[10:30:50.297]                           }
[10:30:50.297]                         }
[10:30:50.297]                       }
[10:30:50.297]                       invisible(muffled)
[10:30:50.297]                     }
[10:30:50.297]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.297]                   }
[10:30:50.297]                 }
[10:30:50.297]             }
[10:30:50.297]         }))
[10:30:50.297]     }, error = function(ex) {
[10:30:50.297]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.297]                 ...future.rng), started = ...future.startTime, 
[10:30:50.297]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.297]             version = "1.8"), class = "FutureResult")
[10:30:50.297]     }, finally = {
[10:30:50.297]         if (!identical(...future.workdir, getwd())) 
[10:30:50.297]             setwd(...future.workdir)
[10:30:50.297]         {
[10:30:50.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.297]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.297]             }
[10:30:50.297]             base::options(...future.oldOptions)
[10:30:50.297]             if (.Platform$OS.type == "windows") {
[10:30:50.297]                 old_names <- names(...future.oldEnvVars)
[10:30:50.297]                 envs <- base::Sys.getenv()
[10:30:50.297]                 names <- names(envs)
[10:30:50.297]                 common <- intersect(names, old_names)
[10:30:50.297]                 added <- setdiff(names, old_names)
[10:30:50.297]                 removed <- setdiff(old_names, names)
[10:30:50.297]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.297]                   envs[common]]
[10:30:50.297]                 NAMES <- toupper(changed)
[10:30:50.297]                 args <- list()
[10:30:50.297]                 for (kk in seq_along(NAMES)) {
[10:30:50.297]                   name <- changed[[kk]]
[10:30:50.297]                   NAME <- NAMES[[kk]]
[10:30:50.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.297]                     next
[10:30:50.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.297]                 }
[10:30:50.297]                 NAMES <- toupper(added)
[10:30:50.297]                 for (kk in seq_along(NAMES)) {
[10:30:50.297]                   name <- added[[kk]]
[10:30:50.297]                   NAME <- NAMES[[kk]]
[10:30:50.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.297]                     next
[10:30:50.297]                   args[[name]] <- ""
[10:30:50.297]                 }
[10:30:50.297]                 NAMES <- toupper(removed)
[10:30:50.297]                 for (kk in seq_along(NAMES)) {
[10:30:50.297]                   name <- removed[[kk]]
[10:30:50.297]                   NAME <- NAMES[[kk]]
[10:30:50.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.297]                     next
[10:30:50.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.297]                 }
[10:30:50.297]                 if (length(args) > 0) 
[10:30:50.297]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.297]             }
[10:30:50.297]             else {
[10:30:50.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.297]             }
[10:30:50.297]             {
[10:30:50.297]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.297]                   0L) {
[10:30:50.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.297]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.297]                   base::options(opts)
[10:30:50.297]                 }
[10:30:50.297]                 {
[10:30:50.297]                   {
[10:30:50.297]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.297]                     NULL
[10:30:50.297]                   }
[10:30:50.297]                   options(future.plan = NULL)
[10:30:50.297]                   if (is.na(NA_character_)) 
[10:30:50.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.297]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.297]                     .init = FALSE)
[10:30:50.297]                 }
[10:30:50.297]             }
[10:30:50.297]         }
[10:30:50.297]     })
[10:30:50.297]     if (TRUE) {
[10:30:50.297]         base::sink(type = "output", split = FALSE)
[10:30:50.297]         if (TRUE) {
[10:30:50.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.297]         }
[10:30:50.297]         else {
[10:30:50.297]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.297]         }
[10:30:50.297]         base::close(...future.stdout)
[10:30:50.297]         ...future.stdout <- NULL
[10:30:50.297]     }
[10:30:50.297]     ...future.result$conditions <- ...future.conditions
[10:30:50.297]     ...future.result$finished <- base::Sys.time()
[10:30:50.297]     ...future.result
[10:30:50.297] }
[10:30:50.300] assign_globals() ...
[10:30:50.300] List of 5
[10:30:50.300]  $ ...future.FUN            :function (C, k)  
[10:30:50.300]  $ MoreArgs                 : NULL
[10:30:50.300]  $ ...future.elements_ii    :List of 2
[10:30:50.300]   ..$ :List of 2
[10:30:50.300]   .. ..$ : chr "E"
[10:30:50.300]   .. ..$ : chr "A"
[10:30:50.300]   ..$ :List of 2
[10:30:50.300]   .. ..$ : int 1
[10:30:50.300]   .. ..$ : int 5
[10:30:50.300]  $ ...future.seeds_ii       : NULL
[10:30:50.300]  $ ...future.globals.maxSize: NULL
[10:30:50.300]  - attr(*, "where")=List of 5
[10:30:50.300]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.300]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.300]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.300]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.300]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.300]  - attr(*, "resolved")= logi FALSE
[10:30:50.300]  - attr(*, "total_size")= num 3656
[10:30:50.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.300]  - attr(*, "already-done")= logi TRUE
[10:30:50.309] - reassign environment for ‘...future.FUN’
[10:30:50.310] - copied ‘...future.FUN’ to environment
[10:30:50.310] - copied ‘MoreArgs’ to environment
[10:30:50.310] - copied ‘...future.elements_ii’ to environment
[10:30:50.310] - copied ‘...future.seeds_ii’ to environment
[10:30:50.310] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.310] assign_globals() ... done
[10:30:50.310] requestCore(): workers = 2
[10:30:50.311] Poll #1 (0): usedCores() = 2, workers = 2
[10:30:50.321] result() for MulticoreFuture ...
[10:30:50.322] result() for MulticoreFuture ...
[10:30:50.322] result() for MulticoreFuture ... done
[10:30:50.322] result() for MulticoreFuture ... done
[10:30:50.323] result() for MulticoreFuture ...
[10:30:50.323] result() for MulticoreFuture ... done
[10:30:50.326] MulticoreFuture started
[10:30:50.327] - Launch lazy future ... done
[10:30:50.327] run() for ‘MulticoreFuture’ ... done
[10:30:50.327] Created future:
[10:30:50.327] plan(): Setting new future strategy stack:
[10:30:50.327] List of future strategies:
[10:30:50.327] 1. sequential:
[10:30:50.327]    - args: function (..., envir = parent.frame())
[10:30:50.327]    - tweaked: FALSE
[10:30:50.327]    - call: NULL
[10:30:50.328] plan(): nbrOfWorkers() = 1
[10:30:50.330] plan(): Setting new future strategy stack:
[10:30:50.330] List of future strategies:
[10:30:50.330] 1. multicore:
[10:30:50.330]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.330]    - tweaked: FALSE
[10:30:50.330]    - call: plan(strategy)
[10:30:50.337] plan(): nbrOfWorkers() = 2
[10:30:50.327] MulticoreFuture:
[10:30:50.327] Label: ‘future_mapply-3’
[10:30:50.327] Expression:
[10:30:50.327] {
[10:30:50.327]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.327]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.327]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.327]         on.exit(options(oopts), add = TRUE)
[10:30:50.327]     }
[10:30:50.327]     {
[10:30:50.327]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.327]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.327]         do.call(mapply, args = args)
[10:30:50.327]     }
[10:30:50.327] }
[10:30:50.327] Lazy evaluation: FALSE
[10:30:50.327] Asynchronous evaluation: TRUE
[10:30:50.327] Local evaluation: TRUE
[10:30:50.327] Environment: R_GlobalEnv
[10:30:50.327] Capture standard output: TRUE
[10:30:50.327] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.327] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.327] Packages: <none>
[10:30:50.327] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.327] Resolved: TRUE
[10:30:50.327] Value: <not collected>
[10:30:50.327] Conditions captured: <none>
[10:30:50.327] Early signaling: FALSE
[10:30:50.327] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.327] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.338] Chunk #3 of 3 ... DONE
[10:30:50.338] Launching 3 futures (chunks) ... DONE
[10:30:50.338] Resolving 3 futures (chunks) ...
[10:30:50.338] resolve() on list ...
[10:30:50.338]  recursive: 0
[10:30:50.339]  length: 3
[10:30:50.339] 
[10:30:50.339] Future #1
[10:30:50.339] result() for MulticoreFuture ...
[10:30:50.339] result() for MulticoreFuture ... done
[10:30:50.339] result() for MulticoreFuture ...
[10:30:50.339] result() for MulticoreFuture ... done
[10:30:50.340] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:50.340] - nx: 3
[10:30:50.340] - relay: TRUE
[10:30:50.340] - stdout: TRUE
[10:30:50.340] - signal: TRUE
[10:30:50.340] - resignal: FALSE
[10:30:50.340] - force: TRUE
[10:30:50.341] - relayed: [n=3] FALSE, FALSE, FALSE
[10:30:50.341] - queued futures: [n=3] FALSE, FALSE, FALSE
[10:30:50.341]  - until=1
[10:30:50.341]  - relaying element #1
[10:30:50.341] result() for MulticoreFuture ...
[10:30:50.342] result() for MulticoreFuture ... done
[10:30:50.342] result() for MulticoreFuture ...
[10:30:50.342] result() for MulticoreFuture ... done
[10:30:50.342] result() for MulticoreFuture ...
[10:30:50.342] result() for MulticoreFuture ... done
[10:30:50.342] result() for MulticoreFuture ...
[10:30:50.343] result() for MulticoreFuture ... done
[10:30:50.343] - relayed: [n=3] TRUE, FALSE, FALSE
[10:30:50.343] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:30:50.343] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:50.343]  length: 2 (resolved future 1)
[10:30:50.344] Future #2
[10:30:50.344] result() for MulticoreFuture ...
[10:30:50.345] result() for MulticoreFuture ...
[10:30:50.345] result() for MulticoreFuture ... done
[10:30:50.345] result() for MulticoreFuture ... done
[10:30:50.345] result() for MulticoreFuture ...
[10:30:50.345] result() for MulticoreFuture ... done
[10:30:50.346] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:50.346] - nx: 3
[10:30:50.346] - relay: TRUE
[10:30:50.346] - stdout: TRUE
[10:30:50.346] - signal: TRUE
[10:30:50.346] - resignal: FALSE
[10:30:50.350] - force: TRUE
[10:30:50.351] - relayed: [n=3] TRUE, FALSE, FALSE
[10:30:50.351] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:30:50.351]  - until=2
[10:30:50.352]  - relaying element #2
[10:30:50.352] result() for MulticoreFuture ...
[10:30:50.352] result() for MulticoreFuture ... done
[10:30:50.353] result() for MulticoreFuture ...
[10:30:50.353] result() for MulticoreFuture ... done
[10:30:50.353] result() for MulticoreFuture ...
[10:30:50.354] result() for MulticoreFuture ... done
[10:30:50.354] result() for MulticoreFuture ...
[10:30:50.354] result() for MulticoreFuture ... done
[10:30:50.354] - relayed: [n=3] TRUE, TRUE, FALSE
[10:30:50.355] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:30:50.355] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:50.355]  length: 1 (resolved future 2)
[10:30:50.356] Future #3
[10:30:50.356] result() for MulticoreFuture ...
[10:30:50.357] result() for MulticoreFuture ...
[10:30:50.358] result() for MulticoreFuture ... done
[10:30:50.358] result() for MulticoreFuture ... done
[10:30:50.358] result() for MulticoreFuture ...
[10:30:50.358] result() for MulticoreFuture ... done
[10:30:50.358] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:30:50.359] - nx: 3
[10:30:50.359] - relay: TRUE
[10:30:50.359] - stdout: TRUE
[10:30:50.359] - signal: TRUE
[10:30:50.359] - resignal: FALSE
[10:30:50.359] - force: TRUE
[10:30:50.360] - relayed: [n=3] TRUE, TRUE, FALSE
[10:30:50.360] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:30:50.360]  - until=3
[10:30:50.360]  - relaying element #3
[10:30:50.360] result() for MulticoreFuture ...
[10:30:50.360] result() for MulticoreFuture ... done
[10:30:50.361] result() for MulticoreFuture ...
[10:30:50.361] result() for MulticoreFuture ... done
[10:30:50.361] result() for MulticoreFuture ...
[10:30:50.361] result() for MulticoreFuture ... done
[10:30:50.361] result() for MulticoreFuture ...
[10:30:50.361] result() for MulticoreFuture ... done
[10:30:50.361] - relayed: [n=3] TRUE, TRUE, TRUE
[10:30:50.362] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:30:50.362] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:30:50.362]  length: 0 (resolved future 3)
[10:30:50.362] Relaying remaining futures
[10:30:50.362] signalConditionsASAP(NULL, pos=0) ...
[10:30:50.362] - nx: 3
[10:30:50.362] - relay: TRUE
[10:30:50.362] - stdout: TRUE
[10:30:50.362] - signal: TRUE
[10:30:50.362] - resignal: FALSE
[10:30:50.363] - force: TRUE
[10:30:50.363] - relayed: [n=3] TRUE, TRUE, TRUE
[10:30:50.363] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[10:30:50.363] - relayed: [n=3] TRUE, TRUE, TRUE
[10:30:50.363] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:30:50.363] signalConditionsASAP(NULL, pos=0) ... done
[10:30:50.363] resolve() on list ... DONE
[10:30:50.364] result() for MulticoreFuture ...
[10:30:50.364] result() for MulticoreFuture ... done
[10:30:50.364] result() for MulticoreFuture ...
[10:30:50.364] result() for MulticoreFuture ... done
[10:30:50.364] result() for MulticoreFuture ...
[10:30:50.364] result() for MulticoreFuture ... done
[10:30:50.364] result() for MulticoreFuture ...
[10:30:50.364] result() for MulticoreFuture ... done
[10:30:50.364] result() for MulticoreFuture ...
[10:30:50.365] result() for MulticoreFuture ... done
[10:30:50.365] result() for MulticoreFuture ...
[10:30:50.365] result() for MulticoreFuture ... done
[10:30:50.365]  - Number of value chunks collected: 3
[10:30:50.365] Resolving 3 futures (chunks) ... DONE
[10:30:50.365] Reducing values from 3 chunks ...
[10:30:50.365]  - Number of values collected after concatenation: 5
[10:30:50.366]  - Number of values expected: 5
[10:30:50.366] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 2, 1, 3, 4
[10:30:50.366] Reducing values from 3 chunks ... DONE
[10:30:50.366] future_mapply() ... DONE
[10:30:50.366] future_mapply() ...
[10:30:50.371] Number of chunks: 2
[10:30:50.371] getGlobalsAndPackagesXApply() ...
[10:30:50.371]  - future.globals: TRUE
[10:30:50.371] getGlobalsAndPackages() ...
[10:30:50.371] Searching for globals...
[10:30:50.373] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:50.373] Searching for globals ... DONE
[10:30:50.373] Resolving globals: FALSE
[10:30:50.374] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:50.374] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:50.374] - globals: [1] ‘FUN’
[10:30:50.375] 
[10:30:50.375] getGlobalsAndPackages() ... DONE
[10:30:50.375]  - globals found/used: [n=1] ‘FUN’
[10:30:50.375]  - needed namespaces: [n=0] 
[10:30:50.375] Finding globals ... DONE
[10:30:50.375] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:50.375] List of 2
[10:30:50.375]  $ ...future.FUN:function (C, k)  
[10:30:50.375]  $ MoreArgs     : list()
[10:30:50.375]  - attr(*, "where")=List of 2
[10:30:50.375]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:50.375]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:50.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.375]  - attr(*, "resolved")= logi FALSE
[10:30:50.375]  - attr(*, "total_size")= num NA
[10:30:50.378] Packages to be attached in all futures: [n=0] 
[10:30:50.378] getGlobalsAndPackagesXApply() ... DONE
[10:30:50.378] Number of futures (= number of chunks): 2
[10:30:50.379] Launching 2 futures (chunks) ...
[10:30:50.379] Chunk #1 of 2 ...
[10:30:50.379]  - Finding globals in '...' for chunk #1 ...
[10:30:50.379] getGlobalsAndPackages() ...
[10:30:50.379] Searching for globals...
[10:30:50.379] 
[10:30:50.379] Searching for globals ... DONE
[10:30:50.380] - globals: [0] <none>
[10:30:50.380] getGlobalsAndPackages() ... DONE
[10:30:50.380]    + additional globals found: [n=0] 
[10:30:50.380]    + additional namespaces needed: [n=0] 
[10:30:50.380]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:50.380]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:50.383]  - seeds: <none>
[10:30:50.383]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.383] getGlobalsAndPackages() ...
[10:30:50.383] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.383] Resolving globals: FALSE
[10:30:50.384] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:50.384] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:50.385] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.385] 
[10:30:50.385] getGlobalsAndPackages() ... DONE
[10:30:50.385] run() for ‘Future’ ...
[10:30:50.385] - state: ‘created’
[10:30:50.386] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.390] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.390]   - Field: ‘label’
[10:30:50.390]   - Field: ‘local’
[10:30:50.390]   - Field: ‘owner’
[10:30:50.391]   - Field: ‘envir’
[10:30:50.391]   - Field: ‘workers’
[10:30:50.391]   - Field: ‘packages’
[10:30:50.391]   - Field: ‘gc’
[10:30:50.391]   - Field: ‘job’
[10:30:50.391]   - Field: ‘conditions’
[10:30:50.391]   - Field: ‘expr’
[10:30:50.391]   - Field: ‘uuid’
[10:30:50.391]   - Field: ‘seed’
[10:30:50.392]   - Field: ‘version’
[10:30:50.392]   - Field: ‘result’
[10:30:50.392]   - Field: ‘asynchronous’
[10:30:50.392]   - Field: ‘calls’
[10:30:50.392]   - Field: ‘globals’
[10:30:50.392]   - Field: ‘stdout’
[10:30:50.392]   - Field: ‘earlySignal’
[10:30:50.392]   - Field: ‘lazy’
[10:30:50.392]   - Field: ‘state’
[10:30:50.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.392] - Launch lazy future ...
[10:30:50.393] Packages needed by the future expression (n = 0): <none>
[10:30:50.393] Packages needed by future strategies (n = 0): <none>
[10:30:50.393] {
[10:30:50.393]     {
[10:30:50.393]         {
[10:30:50.393]             ...future.startTime <- base::Sys.time()
[10:30:50.393]             {
[10:30:50.393]                 {
[10:30:50.393]                   {
[10:30:50.393]                     {
[10:30:50.393]                       base::local({
[10:30:50.393]                         has_future <- base::requireNamespace("future", 
[10:30:50.393]                           quietly = TRUE)
[10:30:50.393]                         if (has_future) {
[10:30:50.393]                           ns <- base::getNamespace("future")
[10:30:50.393]                           version <- ns[[".package"]][["version"]]
[10:30:50.393]                           if (is.null(version)) 
[10:30:50.393]                             version <- utils::packageVersion("future")
[10:30:50.393]                         }
[10:30:50.393]                         else {
[10:30:50.393]                           version <- NULL
[10:30:50.393]                         }
[10:30:50.393]                         if (!has_future || version < "1.8.0") {
[10:30:50.393]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.393]                             "", base::R.version$version.string), 
[10:30:50.393]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.393]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.393]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.393]                               "release", "version")], collapse = " "), 
[10:30:50.393]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.393]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.393]                             info)
[10:30:50.393]                           info <- base::paste(info, collapse = "; ")
[10:30:50.393]                           if (!has_future) {
[10:30:50.393]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.393]                               info)
[10:30:50.393]                           }
[10:30:50.393]                           else {
[10:30:50.393]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.393]                               info, version)
[10:30:50.393]                           }
[10:30:50.393]                           base::stop(msg)
[10:30:50.393]                         }
[10:30:50.393]                       })
[10:30:50.393]                     }
[10:30:50.393]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.393]                     base::options(mc.cores = 1L)
[10:30:50.393]                   }
[10:30:50.393]                   ...future.strategy.old <- future::plan("list")
[10:30:50.393]                   options(future.plan = NULL)
[10:30:50.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.393]                 }
[10:30:50.393]                 ...future.workdir <- getwd()
[10:30:50.393]             }
[10:30:50.393]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.393]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.393]         }
[10:30:50.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.393]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:50.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.393]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.393]             base::names(...future.oldOptions))
[10:30:50.393]     }
[10:30:50.393]     if (FALSE) {
[10:30:50.393]     }
[10:30:50.393]     else {
[10:30:50.393]         if (TRUE) {
[10:30:50.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.393]                 open = "w")
[10:30:50.393]         }
[10:30:50.393]         else {
[10:30:50.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.393]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.393]         }
[10:30:50.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.393]             base::sink(type = "output", split = FALSE)
[10:30:50.393]             base::close(...future.stdout)
[10:30:50.393]         }, add = TRUE)
[10:30:50.393]     }
[10:30:50.393]     ...future.frame <- base::sys.nframe()
[10:30:50.393]     ...future.conditions <- base::list()
[10:30:50.393]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.393]     if (FALSE) {
[10:30:50.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.393]     }
[10:30:50.393]     ...future.result <- base::tryCatch({
[10:30:50.393]         base::withCallingHandlers({
[10:30:50.393]             ...future.value <- base::withVisible(base::local({
[10:30:50.393]                 withCallingHandlers({
[10:30:50.393]                   {
[10:30:50.393]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.393]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.393]                       ...future.globals.maxSize)) {
[10:30:50.393]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.393]                       on.exit(options(oopts), add = TRUE)
[10:30:50.393]                     }
[10:30:50.393]                     {
[10:30:50.393]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.393]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.393]                         USE.NAMES = FALSE)
[10:30:50.393]                       do.call(mapply, args = args)
[10:30:50.393]                     }
[10:30:50.393]                   }
[10:30:50.393]                 }, immediateCondition = function(cond) {
[10:30:50.393]                   save_rds <- function (object, pathname, ...) 
[10:30:50.393]                   {
[10:30:50.393]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.393]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.393]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.393]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.393]                         fi_tmp[["mtime"]])
[10:30:50.393]                     }
[10:30:50.393]                     tryCatch({
[10:30:50.393]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.393]                     }, error = function(ex) {
[10:30:50.393]                       msg <- conditionMessage(ex)
[10:30:50.393]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.393]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.393]                         fi_tmp[["mtime"]], msg)
[10:30:50.393]                       ex$message <- msg
[10:30:50.393]                       stop(ex)
[10:30:50.393]                     })
[10:30:50.393]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.393]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.393]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.393]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.393]                       fi <- file.info(pathname)
[10:30:50.393]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.393]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.393]                         fi[["size"]], fi[["mtime"]])
[10:30:50.393]                       stop(msg)
[10:30:50.393]                     }
[10:30:50.393]                     invisible(pathname)
[10:30:50.393]                   }
[10:30:50.393]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.393]                     rootPath = tempdir()) 
[10:30:50.393]                   {
[10:30:50.393]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.393]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.393]                       tmpdir = path, fileext = ".rds")
[10:30:50.393]                     save_rds(obj, file)
[10:30:50.393]                   }
[10:30:50.393]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.393]                   {
[10:30:50.393]                     inherits <- base::inherits
[10:30:50.393]                     invokeRestart <- base::invokeRestart
[10:30:50.393]                     is.null <- base::is.null
[10:30:50.393]                     muffled <- FALSE
[10:30:50.393]                     if (inherits(cond, "message")) {
[10:30:50.393]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.393]                       if (muffled) 
[10:30:50.393]                         invokeRestart("muffleMessage")
[10:30:50.393]                     }
[10:30:50.393]                     else if (inherits(cond, "warning")) {
[10:30:50.393]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.393]                       if (muffled) 
[10:30:50.393]                         invokeRestart("muffleWarning")
[10:30:50.393]                     }
[10:30:50.393]                     else if (inherits(cond, "condition")) {
[10:30:50.393]                       if (!is.null(pattern)) {
[10:30:50.393]                         computeRestarts <- base::computeRestarts
[10:30:50.393]                         grepl <- base::grepl
[10:30:50.393]                         restarts <- computeRestarts(cond)
[10:30:50.393]                         for (restart in restarts) {
[10:30:50.393]                           name <- restart$name
[10:30:50.393]                           if (is.null(name)) 
[10:30:50.393]                             next
[10:30:50.393]                           if (!grepl(pattern, name)) 
[10:30:50.393]                             next
[10:30:50.393]                           invokeRestart(restart)
[10:30:50.393]                           muffled <- TRUE
[10:30:50.393]                           break
[10:30:50.393]                         }
[10:30:50.393]                       }
[10:30:50.393]                     }
[10:30:50.393]                     invisible(muffled)
[10:30:50.393]                   }
[10:30:50.393]                   muffleCondition(cond)
[10:30:50.393]                 })
[10:30:50.393]             }))
[10:30:50.393]             future::FutureResult(value = ...future.value$value, 
[10:30:50.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.393]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.393]                     ...future.globalenv.names))
[10:30:50.393]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.393]         }, condition = base::local({
[10:30:50.393]             c <- base::c
[10:30:50.393]             inherits <- base::inherits
[10:30:50.393]             invokeRestart <- base::invokeRestart
[10:30:50.393]             length <- base::length
[10:30:50.393]             list <- base::list
[10:30:50.393]             seq.int <- base::seq.int
[10:30:50.393]             signalCondition <- base::signalCondition
[10:30:50.393]             sys.calls <- base::sys.calls
[10:30:50.393]             `[[` <- base::`[[`
[10:30:50.393]             `+` <- base::`+`
[10:30:50.393]             `<<-` <- base::`<<-`
[10:30:50.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.393]                   3L)]
[10:30:50.393]             }
[10:30:50.393]             function(cond) {
[10:30:50.393]                 is_error <- inherits(cond, "error")
[10:30:50.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.393]                   NULL)
[10:30:50.393]                 if (is_error) {
[10:30:50.393]                   sessionInformation <- function() {
[10:30:50.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.393]                       search = base::search(), system = base::Sys.info())
[10:30:50.393]                   }
[10:30:50.393]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.393]                     cond$call), session = sessionInformation(), 
[10:30:50.393]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.393]                   signalCondition(cond)
[10:30:50.393]                 }
[10:30:50.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.393]                 "immediateCondition"))) {
[10:30:50.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.393]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.393]                   if (TRUE && !signal) {
[10:30:50.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.393]                     {
[10:30:50.393]                       inherits <- base::inherits
[10:30:50.393]                       invokeRestart <- base::invokeRestart
[10:30:50.393]                       is.null <- base::is.null
[10:30:50.393]                       muffled <- FALSE
[10:30:50.393]                       if (inherits(cond, "message")) {
[10:30:50.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.393]                         if (muffled) 
[10:30:50.393]                           invokeRestart("muffleMessage")
[10:30:50.393]                       }
[10:30:50.393]                       else if (inherits(cond, "warning")) {
[10:30:50.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.393]                         if (muffled) 
[10:30:50.393]                           invokeRestart("muffleWarning")
[10:30:50.393]                       }
[10:30:50.393]                       else if (inherits(cond, "condition")) {
[10:30:50.393]                         if (!is.null(pattern)) {
[10:30:50.393]                           computeRestarts <- base::computeRestarts
[10:30:50.393]                           grepl <- base::grepl
[10:30:50.393]                           restarts <- computeRestarts(cond)
[10:30:50.393]                           for (restart in restarts) {
[10:30:50.393]                             name <- restart$name
[10:30:50.393]                             if (is.null(name)) 
[10:30:50.393]                               next
[10:30:50.393]                             if (!grepl(pattern, name)) 
[10:30:50.393]                               next
[10:30:50.393]                             invokeRestart(restart)
[10:30:50.393]                             muffled <- TRUE
[10:30:50.393]                             break
[10:30:50.393]                           }
[10:30:50.393]                         }
[10:30:50.393]                       }
[10:30:50.393]                       invisible(muffled)
[10:30:50.393]                     }
[10:30:50.393]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.393]                   }
[10:30:50.393]                 }
[10:30:50.393]                 else {
[10:30:50.393]                   if (TRUE) {
[10:30:50.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.393]                     {
[10:30:50.393]                       inherits <- base::inherits
[10:30:50.393]                       invokeRestart <- base::invokeRestart
[10:30:50.393]                       is.null <- base::is.null
[10:30:50.393]                       muffled <- FALSE
[10:30:50.393]                       if (inherits(cond, "message")) {
[10:30:50.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.393]                         if (muffled) 
[10:30:50.393]                           invokeRestart("muffleMessage")
[10:30:50.393]                       }
[10:30:50.393]                       else if (inherits(cond, "warning")) {
[10:30:50.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.393]                         if (muffled) 
[10:30:50.393]                           invokeRestart("muffleWarning")
[10:30:50.393]                       }
[10:30:50.393]                       else if (inherits(cond, "condition")) {
[10:30:50.393]                         if (!is.null(pattern)) {
[10:30:50.393]                           computeRestarts <- base::computeRestarts
[10:30:50.393]                           grepl <- base::grepl
[10:30:50.393]                           restarts <- computeRestarts(cond)
[10:30:50.393]                           for (restart in restarts) {
[10:30:50.393]                             name <- restart$name
[10:30:50.393]                             if (is.null(name)) 
[10:30:50.393]                               next
[10:30:50.393]                             if (!grepl(pattern, name)) 
[10:30:50.393]                               next
[10:30:50.393]                             invokeRestart(restart)
[10:30:50.393]                             muffled <- TRUE
[10:30:50.393]                             break
[10:30:50.393]                           }
[10:30:50.393]                         }
[10:30:50.393]                       }
[10:30:50.393]                       invisible(muffled)
[10:30:50.393]                     }
[10:30:50.393]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.393]                   }
[10:30:50.393]                 }
[10:30:50.393]             }
[10:30:50.393]         }))
[10:30:50.393]     }, error = function(ex) {
[10:30:50.393]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.393]                 ...future.rng), started = ...future.startTime, 
[10:30:50.393]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.393]             version = "1.8"), class = "FutureResult")
[10:30:50.393]     }, finally = {
[10:30:50.393]         if (!identical(...future.workdir, getwd())) 
[10:30:50.393]             setwd(...future.workdir)
[10:30:50.393]         {
[10:30:50.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.393]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.393]             }
[10:30:50.393]             base::options(...future.oldOptions)
[10:30:50.393]             if (.Platform$OS.type == "windows") {
[10:30:50.393]                 old_names <- names(...future.oldEnvVars)
[10:30:50.393]                 envs <- base::Sys.getenv()
[10:30:50.393]                 names <- names(envs)
[10:30:50.393]                 common <- intersect(names, old_names)
[10:30:50.393]                 added <- setdiff(names, old_names)
[10:30:50.393]                 removed <- setdiff(old_names, names)
[10:30:50.393]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.393]                   envs[common]]
[10:30:50.393]                 NAMES <- toupper(changed)
[10:30:50.393]                 args <- list()
[10:30:50.393]                 for (kk in seq_along(NAMES)) {
[10:30:50.393]                   name <- changed[[kk]]
[10:30:50.393]                   NAME <- NAMES[[kk]]
[10:30:50.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.393]                     next
[10:30:50.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.393]                 }
[10:30:50.393]                 NAMES <- toupper(added)
[10:30:50.393]                 for (kk in seq_along(NAMES)) {
[10:30:50.393]                   name <- added[[kk]]
[10:30:50.393]                   NAME <- NAMES[[kk]]
[10:30:50.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.393]                     next
[10:30:50.393]                   args[[name]] <- ""
[10:30:50.393]                 }
[10:30:50.393]                 NAMES <- toupper(removed)
[10:30:50.393]                 for (kk in seq_along(NAMES)) {
[10:30:50.393]                   name <- removed[[kk]]
[10:30:50.393]                   NAME <- NAMES[[kk]]
[10:30:50.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.393]                     next
[10:30:50.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.393]                 }
[10:30:50.393]                 if (length(args) > 0) 
[10:30:50.393]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.393]             }
[10:30:50.393]             else {
[10:30:50.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.393]             }
[10:30:50.393]             {
[10:30:50.393]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.393]                   0L) {
[10:30:50.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.393]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.393]                   base::options(opts)
[10:30:50.393]                 }
[10:30:50.393]                 {
[10:30:50.393]                   {
[10:30:50.393]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.393]                     NULL
[10:30:50.393]                   }
[10:30:50.393]                   options(future.plan = NULL)
[10:30:50.393]                   if (is.na(NA_character_)) 
[10:30:50.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.393]                     .init = FALSE)
[10:30:50.393]                 }
[10:30:50.393]             }
[10:30:50.393]         }
[10:30:50.393]     })
[10:30:50.393]     if (TRUE) {
[10:30:50.393]         base::sink(type = "output", split = FALSE)
[10:30:50.393]         if (TRUE) {
[10:30:50.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.393]         }
[10:30:50.393]         else {
[10:30:50.393]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.393]         }
[10:30:50.393]         base::close(...future.stdout)
[10:30:50.393]         ...future.stdout <- NULL
[10:30:50.393]     }
[10:30:50.393]     ...future.result$conditions <- ...future.conditions
[10:30:50.393]     ...future.result$finished <- base::Sys.time()
[10:30:50.393]     ...future.result
[10:30:50.393] }
[10:30:50.396] assign_globals() ...
[10:30:50.396] List of 5
[10:30:50.396]  $ ...future.FUN            :function (C, k)  
[10:30:50.396]  $ MoreArgs                 : list()
[10:30:50.396]  $ ...future.elements_ii    :List of 2
[10:30:50.396]   ..$ :List of 2
[10:30:50.396]   .. ..$ : chr "A"
[10:30:50.396]   .. ..$ : chr "B"
[10:30:50.396]   ..$ :List of 2
[10:30:50.396]   .. ..$ : int 5
[10:30:50.396]   .. ..$ : int 4
[10:30:50.396]  $ ...future.seeds_ii       : NULL
[10:30:50.396]  $ ...future.globals.maxSize: NULL
[10:30:50.396]  - attr(*, "where")=List of 5
[10:30:50.396]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.396]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.396]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.396]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.396]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.396]  - attr(*, "resolved")= logi FALSE
[10:30:50.396]  - attr(*, "total_size")= num 3656
[10:30:50.396]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.396]  - attr(*, "already-done")= logi TRUE
[10:30:50.402] - reassign environment for ‘...future.FUN’
[10:30:50.402] - copied ‘...future.FUN’ to environment
[10:30:50.402] - copied ‘MoreArgs’ to environment
[10:30:50.402] - copied ‘...future.elements_ii’ to environment
[10:30:50.402] - copied ‘...future.seeds_ii’ to environment
[10:30:50.402] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.402] assign_globals() ... done
[10:30:50.403] requestCore(): workers = 2
[10:30:50.405] MulticoreFuture started
[10:30:50.406] - Launch lazy future ... done
[10:30:50.406] run() for ‘MulticoreFuture’ ... done
[10:30:50.406] plan(): Setting new future strategy stack:
[10:30:50.406] Created future:
[10:30:50.406] List of future strategies:
[10:30:50.406] 1. sequential:
[10:30:50.406]    - args: function (..., envir = parent.frame())
[10:30:50.406]    - tweaked: FALSE
[10:30:50.406]    - call: NULL
[10:30:50.407] plan(): nbrOfWorkers() = 1
[10:30:50.410] plan(): Setting new future strategy stack:
[10:30:50.410] List of future strategies:
[10:30:50.410] 1. multicore:
[10:30:50.410]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.410]    - tweaked: FALSE
[10:30:50.410]    - call: plan(strategy)
[10:30:50.415] plan(): nbrOfWorkers() = 2
[10:30:50.407] MulticoreFuture:
[10:30:50.407] Label: ‘future_.mapply-1’
[10:30:50.407] Expression:
[10:30:50.407] {
[10:30:50.407]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.407]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.407]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.407]         on.exit(options(oopts), add = TRUE)
[10:30:50.407]     }
[10:30:50.407]     {
[10:30:50.407]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.407]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.407]         do.call(mapply, args = args)
[10:30:50.407]     }
[10:30:50.407] }
[10:30:50.407] Lazy evaluation: FALSE
[10:30:50.407] Asynchronous evaluation: TRUE
[10:30:50.407] Local evaluation: TRUE
[10:30:50.407] Environment: R_GlobalEnv
[10:30:50.407] Capture standard output: TRUE
[10:30:50.407] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.407] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.407] Packages: <none>
[10:30:50.407] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.407] Resolved: TRUE
[10:30:50.407] Value: <not collected>
[10:30:50.407] Conditions captured: <none>
[10:30:50.407] Early signaling: FALSE
[10:30:50.407] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.407] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.416] Chunk #1 of 2 ... DONE
[10:30:50.416] Chunk #2 of 2 ...
[10:30:50.417]  - Finding globals in '...' for chunk #2 ...
[10:30:50.417] getGlobalsAndPackages() ...
[10:30:50.417] Searching for globals...
[10:30:50.418] 
[10:30:50.418] Searching for globals ... DONE
[10:30:50.418] - globals: [0] <none>
[10:30:50.418] getGlobalsAndPackages() ... DONE
[10:30:50.418]    + additional globals found: [n=0] 
[10:30:50.418]    + additional namespaces needed: [n=0] 
[10:30:50.418]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:50.418]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:50.419]  - seeds: <none>
[10:30:50.419]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.419] getGlobalsAndPackages() ...
[10:30:50.419] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.419] Resolving globals: FALSE
[10:30:50.424] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[10:30:50.425] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:50.426] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.426] 
[10:30:50.427] getGlobalsAndPackages() ... DONE
[10:30:50.428] run() for ‘Future’ ...
[10:30:50.428] - state: ‘created’
[10:30:50.428] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.435] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.435]   - Field: ‘label’
[10:30:50.436]   - Field: ‘local’
[10:30:50.436]   - Field: ‘owner’
[10:30:50.436]   - Field: ‘envir’
[10:30:50.436]   - Field: ‘workers’
[10:30:50.437]   - Field: ‘packages’
[10:30:50.437]   - Field: ‘gc’
[10:30:50.437]   - Field: ‘job’
[10:30:50.437]   - Field: ‘conditions’
[10:30:50.438]   - Field: ‘expr’
[10:30:50.438]   - Field: ‘uuid’
[10:30:50.438]   - Field: ‘seed’
[10:30:50.438]   - Field: ‘version’
[10:30:50.438]   - Field: ‘result’
[10:30:50.439]   - Field: ‘asynchronous’
[10:30:50.439]   - Field: ‘calls’
[10:30:50.439]   - Field: ‘globals’
[10:30:50.439]   - Field: ‘stdout’
[10:30:50.439]   - Field: ‘earlySignal’
[10:30:50.439]   - Field: ‘lazy’
[10:30:50.440]   - Field: ‘state’
[10:30:50.440] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.440] - Launch lazy future ...
[10:30:50.440] Packages needed by the future expression (n = 0): <none>
[10:30:50.441] Packages needed by future strategies (n = 0): <none>
[10:30:50.441] {
[10:30:50.441]     {
[10:30:50.441]         {
[10:30:50.441]             ...future.startTime <- base::Sys.time()
[10:30:50.441]             {
[10:30:50.441]                 {
[10:30:50.441]                   {
[10:30:50.441]                     {
[10:30:50.441]                       base::local({
[10:30:50.441]                         has_future <- base::requireNamespace("future", 
[10:30:50.441]                           quietly = TRUE)
[10:30:50.441]                         if (has_future) {
[10:30:50.441]                           ns <- base::getNamespace("future")
[10:30:50.441]                           version <- ns[[".package"]][["version"]]
[10:30:50.441]                           if (is.null(version)) 
[10:30:50.441]                             version <- utils::packageVersion("future")
[10:30:50.441]                         }
[10:30:50.441]                         else {
[10:30:50.441]                           version <- NULL
[10:30:50.441]                         }
[10:30:50.441]                         if (!has_future || version < "1.8.0") {
[10:30:50.441]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.441]                             "", base::R.version$version.string), 
[10:30:50.441]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.441]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.441]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.441]                               "release", "version")], collapse = " "), 
[10:30:50.441]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.441]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.441]                             info)
[10:30:50.441]                           info <- base::paste(info, collapse = "; ")
[10:30:50.441]                           if (!has_future) {
[10:30:50.441]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.441]                               info)
[10:30:50.441]                           }
[10:30:50.441]                           else {
[10:30:50.441]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.441]                               info, version)
[10:30:50.441]                           }
[10:30:50.441]                           base::stop(msg)
[10:30:50.441]                         }
[10:30:50.441]                       })
[10:30:50.441]                     }
[10:30:50.441]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.441]                     base::options(mc.cores = 1L)
[10:30:50.441]                   }
[10:30:50.441]                   ...future.strategy.old <- future::plan("list")
[10:30:50.441]                   options(future.plan = NULL)
[10:30:50.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.441]                 }
[10:30:50.441]                 ...future.workdir <- getwd()
[10:30:50.441]             }
[10:30:50.441]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.441]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.441]         }
[10:30:50.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.441]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:50.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.441]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.441]             base::names(...future.oldOptions))
[10:30:50.441]     }
[10:30:50.441]     if (FALSE) {
[10:30:50.441]     }
[10:30:50.441]     else {
[10:30:50.441]         if (TRUE) {
[10:30:50.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.441]                 open = "w")
[10:30:50.441]         }
[10:30:50.441]         else {
[10:30:50.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.441]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.441]         }
[10:30:50.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.441]             base::sink(type = "output", split = FALSE)
[10:30:50.441]             base::close(...future.stdout)
[10:30:50.441]         }, add = TRUE)
[10:30:50.441]     }
[10:30:50.441]     ...future.frame <- base::sys.nframe()
[10:30:50.441]     ...future.conditions <- base::list()
[10:30:50.441]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.441]     if (FALSE) {
[10:30:50.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.441]     }
[10:30:50.441]     ...future.result <- base::tryCatch({
[10:30:50.441]         base::withCallingHandlers({
[10:30:50.441]             ...future.value <- base::withVisible(base::local({
[10:30:50.441]                 withCallingHandlers({
[10:30:50.441]                   {
[10:30:50.441]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.441]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.441]                       ...future.globals.maxSize)) {
[10:30:50.441]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.441]                       on.exit(options(oopts), add = TRUE)
[10:30:50.441]                     }
[10:30:50.441]                     {
[10:30:50.441]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.441]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.441]                         USE.NAMES = FALSE)
[10:30:50.441]                       do.call(mapply, args = args)
[10:30:50.441]                     }
[10:30:50.441]                   }
[10:30:50.441]                 }, immediateCondition = function(cond) {
[10:30:50.441]                   save_rds <- function (object, pathname, ...) 
[10:30:50.441]                   {
[10:30:50.441]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.441]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.441]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.441]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.441]                         fi_tmp[["mtime"]])
[10:30:50.441]                     }
[10:30:50.441]                     tryCatch({
[10:30:50.441]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.441]                     }, error = function(ex) {
[10:30:50.441]                       msg <- conditionMessage(ex)
[10:30:50.441]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.441]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.441]                         fi_tmp[["mtime"]], msg)
[10:30:50.441]                       ex$message <- msg
[10:30:50.441]                       stop(ex)
[10:30:50.441]                     })
[10:30:50.441]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.441]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.441]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.441]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.441]                       fi <- file.info(pathname)
[10:30:50.441]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.441]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.441]                         fi[["size"]], fi[["mtime"]])
[10:30:50.441]                       stop(msg)
[10:30:50.441]                     }
[10:30:50.441]                     invisible(pathname)
[10:30:50.441]                   }
[10:30:50.441]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.441]                     rootPath = tempdir()) 
[10:30:50.441]                   {
[10:30:50.441]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.441]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.441]                       tmpdir = path, fileext = ".rds")
[10:30:50.441]                     save_rds(obj, file)
[10:30:50.441]                   }
[10:30:50.441]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.441]                   {
[10:30:50.441]                     inherits <- base::inherits
[10:30:50.441]                     invokeRestart <- base::invokeRestart
[10:30:50.441]                     is.null <- base::is.null
[10:30:50.441]                     muffled <- FALSE
[10:30:50.441]                     if (inherits(cond, "message")) {
[10:30:50.441]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.441]                       if (muffled) 
[10:30:50.441]                         invokeRestart("muffleMessage")
[10:30:50.441]                     }
[10:30:50.441]                     else if (inherits(cond, "warning")) {
[10:30:50.441]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.441]                       if (muffled) 
[10:30:50.441]                         invokeRestart("muffleWarning")
[10:30:50.441]                     }
[10:30:50.441]                     else if (inherits(cond, "condition")) {
[10:30:50.441]                       if (!is.null(pattern)) {
[10:30:50.441]                         computeRestarts <- base::computeRestarts
[10:30:50.441]                         grepl <- base::grepl
[10:30:50.441]                         restarts <- computeRestarts(cond)
[10:30:50.441]                         for (restart in restarts) {
[10:30:50.441]                           name <- restart$name
[10:30:50.441]                           if (is.null(name)) 
[10:30:50.441]                             next
[10:30:50.441]                           if (!grepl(pattern, name)) 
[10:30:50.441]                             next
[10:30:50.441]                           invokeRestart(restart)
[10:30:50.441]                           muffled <- TRUE
[10:30:50.441]                           break
[10:30:50.441]                         }
[10:30:50.441]                       }
[10:30:50.441]                     }
[10:30:50.441]                     invisible(muffled)
[10:30:50.441]                   }
[10:30:50.441]                   muffleCondition(cond)
[10:30:50.441]                 })
[10:30:50.441]             }))
[10:30:50.441]             future::FutureResult(value = ...future.value$value, 
[10:30:50.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.441]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.441]                     ...future.globalenv.names))
[10:30:50.441]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.441]         }, condition = base::local({
[10:30:50.441]             c <- base::c
[10:30:50.441]             inherits <- base::inherits
[10:30:50.441]             invokeRestart <- base::invokeRestart
[10:30:50.441]             length <- base::length
[10:30:50.441]             list <- base::list
[10:30:50.441]             seq.int <- base::seq.int
[10:30:50.441]             signalCondition <- base::signalCondition
[10:30:50.441]             sys.calls <- base::sys.calls
[10:30:50.441]             `[[` <- base::`[[`
[10:30:50.441]             `+` <- base::`+`
[10:30:50.441]             `<<-` <- base::`<<-`
[10:30:50.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.441]                   3L)]
[10:30:50.441]             }
[10:30:50.441]             function(cond) {
[10:30:50.441]                 is_error <- inherits(cond, "error")
[10:30:50.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.441]                   NULL)
[10:30:50.441]                 if (is_error) {
[10:30:50.441]                   sessionInformation <- function() {
[10:30:50.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.441]                       search = base::search(), system = base::Sys.info())
[10:30:50.441]                   }
[10:30:50.441]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.441]                     cond$call), session = sessionInformation(), 
[10:30:50.441]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.441]                   signalCondition(cond)
[10:30:50.441]                 }
[10:30:50.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.441]                 "immediateCondition"))) {
[10:30:50.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.441]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.441]                   if (TRUE && !signal) {
[10:30:50.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.441]                     {
[10:30:50.441]                       inherits <- base::inherits
[10:30:50.441]                       invokeRestart <- base::invokeRestart
[10:30:50.441]                       is.null <- base::is.null
[10:30:50.441]                       muffled <- FALSE
[10:30:50.441]                       if (inherits(cond, "message")) {
[10:30:50.441]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.441]                         if (muffled) 
[10:30:50.441]                           invokeRestart("muffleMessage")
[10:30:50.441]                       }
[10:30:50.441]                       else if (inherits(cond, "warning")) {
[10:30:50.441]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.441]                         if (muffled) 
[10:30:50.441]                           invokeRestart("muffleWarning")
[10:30:50.441]                       }
[10:30:50.441]                       else if (inherits(cond, "condition")) {
[10:30:50.441]                         if (!is.null(pattern)) {
[10:30:50.441]                           computeRestarts <- base::computeRestarts
[10:30:50.441]                           grepl <- base::grepl
[10:30:50.441]                           restarts <- computeRestarts(cond)
[10:30:50.441]                           for (restart in restarts) {
[10:30:50.441]                             name <- restart$name
[10:30:50.441]                             if (is.null(name)) 
[10:30:50.441]                               next
[10:30:50.441]                             if (!grepl(pattern, name)) 
[10:30:50.441]                               next
[10:30:50.441]                             invokeRestart(restart)
[10:30:50.441]                             muffled <- TRUE
[10:30:50.441]                             break
[10:30:50.441]                           }
[10:30:50.441]                         }
[10:30:50.441]                       }
[10:30:50.441]                       invisible(muffled)
[10:30:50.441]                     }
[10:30:50.441]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.441]                   }
[10:30:50.441]                 }
[10:30:50.441]                 else {
[10:30:50.441]                   if (TRUE) {
[10:30:50.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.441]                     {
[10:30:50.441]                       inherits <- base::inherits
[10:30:50.441]                       invokeRestart <- base::invokeRestart
[10:30:50.441]                       is.null <- base::is.null
[10:30:50.441]                       muffled <- FALSE
[10:30:50.441]                       if (inherits(cond, "message")) {
[10:30:50.441]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.441]                         if (muffled) 
[10:30:50.441]                           invokeRestart("muffleMessage")
[10:30:50.441]                       }
[10:30:50.441]                       else if (inherits(cond, "warning")) {
[10:30:50.441]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.441]                         if (muffled) 
[10:30:50.441]                           invokeRestart("muffleWarning")
[10:30:50.441]                       }
[10:30:50.441]                       else if (inherits(cond, "condition")) {
[10:30:50.441]                         if (!is.null(pattern)) {
[10:30:50.441]                           computeRestarts <- base::computeRestarts
[10:30:50.441]                           grepl <- base::grepl
[10:30:50.441]                           restarts <- computeRestarts(cond)
[10:30:50.441]                           for (restart in restarts) {
[10:30:50.441]                             name <- restart$name
[10:30:50.441]                             if (is.null(name)) 
[10:30:50.441]                               next
[10:30:50.441]                             if (!grepl(pattern, name)) 
[10:30:50.441]                               next
[10:30:50.441]                             invokeRestart(restart)
[10:30:50.441]                             muffled <- TRUE
[10:30:50.441]                             break
[10:30:50.441]                           }
[10:30:50.441]                         }
[10:30:50.441]                       }
[10:30:50.441]                       invisible(muffled)
[10:30:50.441]                     }
[10:30:50.441]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.441]                   }
[10:30:50.441]                 }
[10:30:50.441]             }
[10:30:50.441]         }))
[10:30:50.441]     }, error = function(ex) {
[10:30:50.441]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.441]                 ...future.rng), started = ...future.startTime, 
[10:30:50.441]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.441]             version = "1.8"), class = "FutureResult")
[10:30:50.441]     }, finally = {
[10:30:50.441]         if (!identical(...future.workdir, getwd())) 
[10:30:50.441]             setwd(...future.workdir)
[10:30:50.441]         {
[10:30:50.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.441]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.441]             }
[10:30:50.441]             base::options(...future.oldOptions)
[10:30:50.441]             if (.Platform$OS.type == "windows") {
[10:30:50.441]                 old_names <- names(...future.oldEnvVars)
[10:30:50.441]                 envs <- base::Sys.getenv()
[10:30:50.441]                 names <- names(envs)
[10:30:50.441]                 common <- intersect(names, old_names)
[10:30:50.441]                 added <- setdiff(names, old_names)
[10:30:50.441]                 removed <- setdiff(old_names, names)
[10:30:50.441]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.441]                   envs[common]]
[10:30:50.441]                 NAMES <- toupper(changed)
[10:30:50.441]                 args <- list()
[10:30:50.441]                 for (kk in seq_along(NAMES)) {
[10:30:50.441]                   name <- changed[[kk]]
[10:30:50.441]                   NAME <- NAMES[[kk]]
[10:30:50.441]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.441]                     next
[10:30:50.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.441]                 }
[10:30:50.441]                 NAMES <- toupper(added)
[10:30:50.441]                 for (kk in seq_along(NAMES)) {
[10:30:50.441]                   name <- added[[kk]]
[10:30:50.441]                   NAME <- NAMES[[kk]]
[10:30:50.441]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.441]                     next
[10:30:50.441]                   args[[name]] <- ""
[10:30:50.441]                 }
[10:30:50.441]                 NAMES <- toupper(removed)
[10:30:50.441]                 for (kk in seq_along(NAMES)) {
[10:30:50.441]                   name <- removed[[kk]]
[10:30:50.441]                   NAME <- NAMES[[kk]]
[10:30:50.441]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.441]                     next
[10:30:50.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.441]                 }
[10:30:50.441]                 if (length(args) > 0) 
[10:30:50.441]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.441]             }
[10:30:50.441]             else {
[10:30:50.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.441]             }
[10:30:50.441]             {
[10:30:50.441]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.441]                   0L) {
[10:30:50.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.441]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.441]                   base::options(opts)
[10:30:50.441]                 }
[10:30:50.441]                 {
[10:30:50.441]                   {
[10:30:50.441]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.441]                     NULL
[10:30:50.441]                   }
[10:30:50.441]                   options(future.plan = NULL)
[10:30:50.441]                   if (is.na(NA_character_)) 
[10:30:50.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.441]                     .init = FALSE)
[10:30:50.441]                 }
[10:30:50.441]             }
[10:30:50.441]         }
[10:30:50.441]     })
[10:30:50.441]     if (TRUE) {
[10:30:50.441]         base::sink(type = "output", split = FALSE)
[10:30:50.441]         if (TRUE) {
[10:30:50.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.441]         }
[10:30:50.441]         else {
[10:30:50.441]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.441]         }
[10:30:50.441]         base::close(...future.stdout)
[10:30:50.441]         ...future.stdout <- NULL
[10:30:50.441]     }
[10:30:50.441]     ...future.result$conditions <- ...future.conditions
[10:30:50.441]     ...future.result$finished <- base::Sys.time()
[10:30:50.441]     ...future.result
[10:30:50.441] }
[10:30:50.444] assign_globals() ...
[10:30:50.444] List of 5
[10:30:50.444]  $ ...future.FUN            :function (C, k)  
[10:30:50.444]  $ MoreArgs                 : list()
[10:30:50.444]  $ ...future.elements_ii    :List of 2
[10:30:50.444]   ..$ :List of 3
[10:30:50.444]   .. ..$ : chr "C"
[10:30:50.444]   .. ..$ : chr "D"
[10:30:50.444]   .. ..$ : chr "E"
[10:30:50.444]   ..$ :List of 3
[10:30:50.444]   .. ..$ : int 3
[10:30:50.444]   .. ..$ : int 2
[10:30:50.444]   .. ..$ : int 1
[10:30:50.444]  $ ...future.seeds_ii       : NULL
[10:30:50.444]  $ ...future.globals.maxSize: NULL
[10:30:50.444]  - attr(*, "where")=List of 5
[10:30:50.444]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.444]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.444]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.444]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.444]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.444]  - attr(*, "resolved")= logi FALSE
[10:30:50.444]  - attr(*, "total_size")= num 3824
[10:30:50.444]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.444]  - attr(*, "already-done")= logi TRUE
[10:30:50.453] - reassign environment for ‘...future.FUN’
[10:30:50.453] - copied ‘...future.FUN’ to environment
[10:30:50.453] - copied ‘MoreArgs’ to environment
[10:30:50.453] - copied ‘...future.elements_ii’ to environment
[10:30:50.453] - copied ‘...future.seeds_ii’ to environment
[10:30:50.454] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.454] assign_globals() ... done
[10:30:50.454] requestCore(): workers = 2
[10:30:50.456] MulticoreFuture started
[10:30:50.457] - Launch lazy future ... done
[10:30:50.457] run() for ‘MulticoreFuture’ ... done
[10:30:50.457] Created future:
[10:30:50.457] plan(): Setting new future strategy stack:
[10:30:50.458] List of future strategies:
[10:30:50.458] 1. sequential:
[10:30:50.458]    - args: function (..., envir = parent.frame())
[10:30:50.458]    - tweaked: FALSE
[10:30:50.458]    - call: NULL
[10:30:50.458] plan(): nbrOfWorkers() = 1
[10:30:50.460] plan(): Setting new future strategy stack:
[10:30:50.460] List of future strategies:
[10:30:50.460] 1. multicore:
[10:30:50.460]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.460]    - tweaked: FALSE
[10:30:50.460]    - call: plan(strategy)
[10:30:50.466] plan(): nbrOfWorkers() = 2
[10:30:50.457] MulticoreFuture:
[10:30:50.457] Label: ‘future_.mapply-2’
[10:30:50.457] Expression:
[10:30:50.457] {
[10:30:50.457]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.457]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.457]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.457]         on.exit(options(oopts), add = TRUE)
[10:30:50.457]     }
[10:30:50.457]     {
[10:30:50.457]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.457]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.457]         do.call(mapply, args = args)
[10:30:50.457]     }
[10:30:50.457] }
[10:30:50.457] Lazy evaluation: FALSE
[10:30:50.457] Asynchronous evaluation: TRUE
[10:30:50.457] Local evaluation: TRUE
[10:30:50.457] Environment: R_GlobalEnv
[10:30:50.457] Capture standard output: TRUE
[10:30:50.457] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.457] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.457] Packages: <none>
[10:30:50.457] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.457] Resolved: TRUE
[10:30:50.457] Value: <not collected>
[10:30:50.457] Conditions captured: <none>
[10:30:50.457] Early signaling: FALSE
[10:30:50.457] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.457] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.467] Chunk #2 of 2 ... DONE
[10:30:50.467] Launching 2 futures (chunks) ... DONE
[10:30:50.467] Resolving 2 futures (chunks) ...
[10:30:50.468] resolve() on list ...
[10:30:50.468]  recursive: 0
[10:30:50.468]  length: 2
[10:30:50.468] 
[10:30:50.468] Future #1
[10:30:50.468] result() for MulticoreFuture ...
[10:30:50.469] result() for MulticoreFuture ...
[10:30:50.470] result() for MulticoreFuture ... done
[10:30:50.470] result() for MulticoreFuture ... done
[10:30:50.470] result() for MulticoreFuture ...
[10:30:50.470] result() for MulticoreFuture ... done
[10:30:50.470] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:50.471] - nx: 2
[10:30:50.471] - relay: TRUE
[10:30:50.471] - stdout: TRUE
[10:30:50.471] - signal: TRUE
[10:30:50.471] - resignal: FALSE
[10:30:50.471] - force: TRUE
[10:30:50.472] - relayed: [n=2] FALSE, FALSE
[10:30:50.476] - queued futures: [n=2] FALSE, FALSE
[10:30:50.476]  - until=1
[10:30:50.477]  - relaying element #1
[10:30:50.477] result() for MulticoreFuture ...
[10:30:50.477] result() for MulticoreFuture ... done
[10:30:50.478] result() for MulticoreFuture ...
[10:30:50.478] result() for MulticoreFuture ... done
[10:30:50.479] result() for MulticoreFuture ...
[10:30:50.479] result() for MulticoreFuture ... done
[10:30:50.479] result() for MulticoreFuture ...
[10:30:50.480] result() for MulticoreFuture ... done
[10:30:50.480] - relayed: [n=2] TRUE, FALSE
[10:30:50.480] - queued futures: [n=2] TRUE, FALSE
[10:30:50.480] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:50.481]  length: 1 (resolved future 1)
[10:30:50.481] Future #2
[10:30:50.482] result() for MulticoreFuture ...
[10:30:50.483] result() for MulticoreFuture ...
[10:30:50.483] result() for MulticoreFuture ... done
[10:30:50.483] result() for MulticoreFuture ... done
[10:30:50.483] result() for MulticoreFuture ...
[10:30:50.484] result() for MulticoreFuture ... done
[10:30:50.484] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:50.484] - nx: 2
[10:30:50.484] - relay: TRUE
[10:30:50.484] - stdout: TRUE
[10:30:50.485] - signal: TRUE
[10:30:50.485] - resignal: FALSE
[10:30:50.485] - force: TRUE
[10:30:50.485] - relayed: [n=2] TRUE, FALSE
[10:30:50.485] - queued futures: [n=2] TRUE, FALSE
[10:30:50.485]  - until=2
[10:30:50.486]  - relaying element #2
[10:30:50.486] result() for MulticoreFuture ...
[10:30:50.486] result() for MulticoreFuture ... done
[10:30:50.486] result() for MulticoreFuture ...
[10:30:50.486] result() for MulticoreFuture ... done
[10:30:50.486] result() for MulticoreFuture ...
[10:30:50.487] result() for MulticoreFuture ... done
[10:30:50.487] result() for MulticoreFuture ...
[10:30:50.487] result() for MulticoreFuture ... done
[10:30:50.487] - relayed: [n=2] TRUE, TRUE
[10:30:50.487] - queued futures: [n=2] TRUE, TRUE
[10:30:50.487] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:50.487]  length: 0 (resolved future 2)
[10:30:50.487] Relaying remaining futures
[10:30:50.487] signalConditionsASAP(NULL, pos=0) ...
[10:30:50.488] - nx: 2
[10:30:50.488] - relay: TRUE
[10:30:50.488] - stdout: TRUE
[10:30:50.488] - signal: TRUE
[10:30:50.488] - resignal: FALSE
[10:30:50.488] - force: TRUE
[10:30:50.488] - relayed: [n=2] TRUE, TRUE
[10:30:50.488] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:50.488] - relayed: [n=2] TRUE, TRUE
[10:30:50.489] - queued futures: [n=2] TRUE, TRUE
[10:30:50.489] signalConditionsASAP(NULL, pos=0) ... done
[10:30:50.489] resolve() on list ... DONE
[10:30:50.489] result() for MulticoreFuture ...
[10:30:50.489] result() for MulticoreFuture ... done
[10:30:50.489] result() for MulticoreFuture ...
[10:30:50.489] result() for MulticoreFuture ... done
[10:30:50.490] result() for MulticoreFuture ...
[10:30:50.490] result() for MulticoreFuture ... done
[10:30:50.490] result() for MulticoreFuture ...
[10:30:50.490] result() for MulticoreFuture ... done
[10:30:50.490]  - Number of value chunks collected: 2
[10:30:50.490] Resolving 2 futures (chunks) ... DONE
[10:30:50.490] Reducing values from 2 chunks ...
[10:30:50.490]  - Number of values collected after concatenation: 5
[10:30:50.490]  - Number of values expected: 5
[10:30:50.491] Reducing values from 2 chunks ... DONE
[10:30:50.491] future_mapply() ... DONE
[10:30:50.491] future_mapply() ...
[10:30:50.495] Number of chunks: 2
[10:30:50.495] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:30:50.496] getGlobalsAndPackagesXApply() ...
[10:30:50.496]  - future.globals: TRUE
[10:30:50.496] getGlobalsAndPackages() ...
[10:30:50.496] Searching for globals...
[10:30:50.497] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:50.498] Searching for globals ... DONE
[10:30:50.498] Resolving globals: FALSE
[10:30:50.498] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:50.499] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:50.499] - globals: [1] ‘FUN’
[10:30:50.499] 
[10:30:50.499] getGlobalsAndPackages() ... DONE
[10:30:50.499]  - globals found/used: [n=1] ‘FUN’
[10:30:50.499]  - needed namespaces: [n=0] 
[10:30:50.499] Finding globals ... DONE
[10:30:50.499] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:50.500] List of 2
[10:30:50.500]  $ ...future.FUN:function (C, k)  
[10:30:50.500]  $ MoreArgs     : NULL
[10:30:50.500]  - attr(*, "where")=List of 2
[10:30:50.500]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:50.500]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:50.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.500]  - attr(*, "resolved")= logi FALSE
[10:30:50.500]  - attr(*, "total_size")= num NA
[10:30:50.502] Packages to be attached in all futures: [n=0] 
[10:30:50.502] getGlobalsAndPackagesXApply() ... DONE
[10:30:50.503] Number of futures (= number of chunks): 2
[10:30:50.503] Launching 2 futures (chunks) ...
[10:30:50.503] Chunk #1 of 2 ...
[10:30:50.503]  - Finding globals in '...' for chunk #1 ...
[10:30:50.503] getGlobalsAndPackages() ...
[10:30:50.503] Searching for globals...
[10:30:50.504] 
[10:30:50.504] Searching for globals ... DONE
[10:30:50.504] - globals: [0] <none>
[10:30:50.504] getGlobalsAndPackages() ... DONE
[10:30:50.504]    + additional globals found: [n=0] 
[10:30:50.504]    + additional namespaces needed: [n=0] 
[10:30:50.504]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:50.504]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:50.504]  - seeds: <none>
[10:30:50.504]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.505] getGlobalsAndPackages() ...
[10:30:50.507] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.507] Resolving globals: FALSE
[10:30:50.508] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:50.508] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:50.508] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.509] 
[10:30:50.509] getGlobalsAndPackages() ... DONE
[10:30:50.509] run() for ‘Future’ ...
[10:30:50.509] - state: ‘created’
[10:30:50.509] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.513] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.514] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.514]   - Field: ‘label’
[10:30:50.514]   - Field: ‘local’
[10:30:50.514]   - Field: ‘owner’
[10:30:50.514]   - Field: ‘envir’
[10:30:50.514]   - Field: ‘workers’
[10:30:50.514]   - Field: ‘packages’
[10:30:50.514]   - Field: ‘gc’
[10:30:50.515]   - Field: ‘job’
[10:30:50.515]   - Field: ‘conditions’
[10:30:50.515]   - Field: ‘expr’
[10:30:50.515]   - Field: ‘uuid’
[10:30:50.515]   - Field: ‘seed’
[10:30:50.515]   - Field: ‘version’
[10:30:50.515]   - Field: ‘result’
[10:30:50.515]   - Field: ‘asynchronous’
[10:30:50.515]   - Field: ‘calls’
[10:30:50.515]   - Field: ‘globals’
[10:30:50.516]   - Field: ‘stdout’
[10:30:50.516]   - Field: ‘earlySignal’
[10:30:50.516]   - Field: ‘lazy’
[10:30:50.516]   - Field: ‘state’
[10:30:50.516] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.516] - Launch lazy future ...
[10:30:50.516] Packages needed by the future expression (n = 0): <none>
[10:30:50.516] Packages needed by future strategies (n = 0): <none>
[10:30:50.517] {
[10:30:50.517]     {
[10:30:50.517]         {
[10:30:50.517]             ...future.startTime <- base::Sys.time()
[10:30:50.517]             {
[10:30:50.517]                 {
[10:30:50.517]                   {
[10:30:50.517]                     {
[10:30:50.517]                       base::local({
[10:30:50.517]                         has_future <- base::requireNamespace("future", 
[10:30:50.517]                           quietly = TRUE)
[10:30:50.517]                         if (has_future) {
[10:30:50.517]                           ns <- base::getNamespace("future")
[10:30:50.517]                           version <- ns[[".package"]][["version"]]
[10:30:50.517]                           if (is.null(version)) 
[10:30:50.517]                             version <- utils::packageVersion("future")
[10:30:50.517]                         }
[10:30:50.517]                         else {
[10:30:50.517]                           version <- NULL
[10:30:50.517]                         }
[10:30:50.517]                         if (!has_future || version < "1.8.0") {
[10:30:50.517]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.517]                             "", base::R.version$version.string), 
[10:30:50.517]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.517]                               "release", "version")], collapse = " "), 
[10:30:50.517]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.517]                             info)
[10:30:50.517]                           info <- base::paste(info, collapse = "; ")
[10:30:50.517]                           if (!has_future) {
[10:30:50.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.517]                               info)
[10:30:50.517]                           }
[10:30:50.517]                           else {
[10:30:50.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.517]                               info, version)
[10:30:50.517]                           }
[10:30:50.517]                           base::stop(msg)
[10:30:50.517]                         }
[10:30:50.517]                       })
[10:30:50.517]                     }
[10:30:50.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.517]                     base::options(mc.cores = 1L)
[10:30:50.517]                   }
[10:30:50.517]                   ...future.strategy.old <- future::plan("list")
[10:30:50.517]                   options(future.plan = NULL)
[10:30:50.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.517]                 }
[10:30:50.517]                 ...future.workdir <- getwd()
[10:30:50.517]             }
[10:30:50.517]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.517]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.517]         }
[10:30:50.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.517]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:50.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.517]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.517]             base::names(...future.oldOptions))
[10:30:50.517]     }
[10:30:50.517]     if (FALSE) {
[10:30:50.517]     }
[10:30:50.517]     else {
[10:30:50.517]         if (TRUE) {
[10:30:50.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.517]                 open = "w")
[10:30:50.517]         }
[10:30:50.517]         else {
[10:30:50.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.517]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.517]         }
[10:30:50.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.517]             base::sink(type = "output", split = FALSE)
[10:30:50.517]             base::close(...future.stdout)
[10:30:50.517]         }, add = TRUE)
[10:30:50.517]     }
[10:30:50.517]     ...future.frame <- base::sys.nframe()
[10:30:50.517]     ...future.conditions <- base::list()
[10:30:50.517]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.517]     if (FALSE) {
[10:30:50.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.517]     }
[10:30:50.517]     ...future.result <- base::tryCatch({
[10:30:50.517]         base::withCallingHandlers({
[10:30:50.517]             ...future.value <- base::withVisible(base::local({
[10:30:50.517]                 withCallingHandlers({
[10:30:50.517]                   {
[10:30:50.517]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.517]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.517]                       ...future.globals.maxSize)) {
[10:30:50.517]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.517]                       on.exit(options(oopts), add = TRUE)
[10:30:50.517]                     }
[10:30:50.517]                     {
[10:30:50.517]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.517]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.517]                         USE.NAMES = FALSE)
[10:30:50.517]                       do.call(mapply, args = args)
[10:30:50.517]                     }
[10:30:50.517]                   }
[10:30:50.517]                 }, immediateCondition = function(cond) {
[10:30:50.517]                   save_rds <- function (object, pathname, ...) 
[10:30:50.517]                   {
[10:30:50.517]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.517]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.517]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.517]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.517]                         fi_tmp[["mtime"]])
[10:30:50.517]                     }
[10:30:50.517]                     tryCatch({
[10:30:50.517]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.517]                     }, error = function(ex) {
[10:30:50.517]                       msg <- conditionMessage(ex)
[10:30:50.517]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.517]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.517]                         fi_tmp[["mtime"]], msg)
[10:30:50.517]                       ex$message <- msg
[10:30:50.517]                       stop(ex)
[10:30:50.517]                     })
[10:30:50.517]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.517]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.517]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.517]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.517]                       fi <- file.info(pathname)
[10:30:50.517]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.517]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.517]                         fi[["size"]], fi[["mtime"]])
[10:30:50.517]                       stop(msg)
[10:30:50.517]                     }
[10:30:50.517]                     invisible(pathname)
[10:30:50.517]                   }
[10:30:50.517]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.517]                     rootPath = tempdir()) 
[10:30:50.517]                   {
[10:30:50.517]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.517]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.517]                       tmpdir = path, fileext = ".rds")
[10:30:50.517]                     save_rds(obj, file)
[10:30:50.517]                   }
[10:30:50.517]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.517]                   {
[10:30:50.517]                     inherits <- base::inherits
[10:30:50.517]                     invokeRestart <- base::invokeRestart
[10:30:50.517]                     is.null <- base::is.null
[10:30:50.517]                     muffled <- FALSE
[10:30:50.517]                     if (inherits(cond, "message")) {
[10:30:50.517]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.517]                       if (muffled) 
[10:30:50.517]                         invokeRestart("muffleMessage")
[10:30:50.517]                     }
[10:30:50.517]                     else if (inherits(cond, "warning")) {
[10:30:50.517]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.517]                       if (muffled) 
[10:30:50.517]                         invokeRestart("muffleWarning")
[10:30:50.517]                     }
[10:30:50.517]                     else if (inherits(cond, "condition")) {
[10:30:50.517]                       if (!is.null(pattern)) {
[10:30:50.517]                         computeRestarts <- base::computeRestarts
[10:30:50.517]                         grepl <- base::grepl
[10:30:50.517]                         restarts <- computeRestarts(cond)
[10:30:50.517]                         for (restart in restarts) {
[10:30:50.517]                           name <- restart$name
[10:30:50.517]                           if (is.null(name)) 
[10:30:50.517]                             next
[10:30:50.517]                           if (!grepl(pattern, name)) 
[10:30:50.517]                             next
[10:30:50.517]                           invokeRestart(restart)
[10:30:50.517]                           muffled <- TRUE
[10:30:50.517]                           break
[10:30:50.517]                         }
[10:30:50.517]                       }
[10:30:50.517]                     }
[10:30:50.517]                     invisible(muffled)
[10:30:50.517]                   }
[10:30:50.517]                   muffleCondition(cond)
[10:30:50.517]                 })
[10:30:50.517]             }))
[10:30:50.517]             future::FutureResult(value = ...future.value$value, 
[10:30:50.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.517]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.517]                     ...future.globalenv.names))
[10:30:50.517]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.517]         }, condition = base::local({
[10:30:50.517]             c <- base::c
[10:30:50.517]             inherits <- base::inherits
[10:30:50.517]             invokeRestart <- base::invokeRestart
[10:30:50.517]             length <- base::length
[10:30:50.517]             list <- base::list
[10:30:50.517]             seq.int <- base::seq.int
[10:30:50.517]             signalCondition <- base::signalCondition
[10:30:50.517]             sys.calls <- base::sys.calls
[10:30:50.517]             `[[` <- base::`[[`
[10:30:50.517]             `+` <- base::`+`
[10:30:50.517]             `<<-` <- base::`<<-`
[10:30:50.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.517]                   3L)]
[10:30:50.517]             }
[10:30:50.517]             function(cond) {
[10:30:50.517]                 is_error <- inherits(cond, "error")
[10:30:50.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.517]                   NULL)
[10:30:50.517]                 if (is_error) {
[10:30:50.517]                   sessionInformation <- function() {
[10:30:50.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.517]                       search = base::search(), system = base::Sys.info())
[10:30:50.517]                   }
[10:30:50.517]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.517]                     cond$call), session = sessionInformation(), 
[10:30:50.517]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.517]                   signalCondition(cond)
[10:30:50.517]                 }
[10:30:50.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.517]                 "immediateCondition"))) {
[10:30:50.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.517]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.517]                   if (TRUE && !signal) {
[10:30:50.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.517]                     {
[10:30:50.517]                       inherits <- base::inherits
[10:30:50.517]                       invokeRestart <- base::invokeRestart
[10:30:50.517]                       is.null <- base::is.null
[10:30:50.517]                       muffled <- FALSE
[10:30:50.517]                       if (inherits(cond, "message")) {
[10:30:50.517]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.517]                         if (muffled) 
[10:30:50.517]                           invokeRestart("muffleMessage")
[10:30:50.517]                       }
[10:30:50.517]                       else if (inherits(cond, "warning")) {
[10:30:50.517]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.517]                         if (muffled) 
[10:30:50.517]                           invokeRestart("muffleWarning")
[10:30:50.517]                       }
[10:30:50.517]                       else if (inherits(cond, "condition")) {
[10:30:50.517]                         if (!is.null(pattern)) {
[10:30:50.517]                           computeRestarts <- base::computeRestarts
[10:30:50.517]                           grepl <- base::grepl
[10:30:50.517]                           restarts <- computeRestarts(cond)
[10:30:50.517]                           for (restart in restarts) {
[10:30:50.517]                             name <- restart$name
[10:30:50.517]                             if (is.null(name)) 
[10:30:50.517]                               next
[10:30:50.517]                             if (!grepl(pattern, name)) 
[10:30:50.517]                               next
[10:30:50.517]                             invokeRestart(restart)
[10:30:50.517]                             muffled <- TRUE
[10:30:50.517]                             break
[10:30:50.517]                           }
[10:30:50.517]                         }
[10:30:50.517]                       }
[10:30:50.517]                       invisible(muffled)
[10:30:50.517]                     }
[10:30:50.517]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.517]                   }
[10:30:50.517]                 }
[10:30:50.517]                 else {
[10:30:50.517]                   if (TRUE) {
[10:30:50.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.517]                     {
[10:30:50.517]                       inherits <- base::inherits
[10:30:50.517]                       invokeRestart <- base::invokeRestart
[10:30:50.517]                       is.null <- base::is.null
[10:30:50.517]                       muffled <- FALSE
[10:30:50.517]                       if (inherits(cond, "message")) {
[10:30:50.517]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.517]                         if (muffled) 
[10:30:50.517]                           invokeRestart("muffleMessage")
[10:30:50.517]                       }
[10:30:50.517]                       else if (inherits(cond, "warning")) {
[10:30:50.517]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.517]                         if (muffled) 
[10:30:50.517]                           invokeRestart("muffleWarning")
[10:30:50.517]                       }
[10:30:50.517]                       else if (inherits(cond, "condition")) {
[10:30:50.517]                         if (!is.null(pattern)) {
[10:30:50.517]                           computeRestarts <- base::computeRestarts
[10:30:50.517]                           grepl <- base::grepl
[10:30:50.517]                           restarts <- computeRestarts(cond)
[10:30:50.517]                           for (restart in restarts) {
[10:30:50.517]                             name <- restart$name
[10:30:50.517]                             if (is.null(name)) 
[10:30:50.517]                               next
[10:30:50.517]                             if (!grepl(pattern, name)) 
[10:30:50.517]                               next
[10:30:50.517]                             invokeRestart(restart)
[10:30:50.517]                             muffled <- TRUE
[10:30:50.517]                             break
[10:30:50.517]                           }
[10:30:50.517]                         }
[10:30:50.517]                       }
[10:30:50.517]                       invisible(muffled)
[10:30:50.517]                     }
[10:30:50.517]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.517]                   }
[10:30:50.517]                 }
[10:30:50.517]             }
[10:30:50.517]         }))
[10:30:50.517]     }, error = function(ex) {
[10:30:50.517]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.517]                 ...future.rng), started = ...future.startTime, 
[10:30:50.517]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.517]             version = "1.8"), class = "FutureResult")
[10:30:50.517]     }, finally = {
[10:30:50.517]         if (!identical(...future.workdir, getwd())) 
[10:30:50.517]             setwd(...future.workdir)
[10:30:50.517]         {
[10:30:50.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.517]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.517]             }
[10:30:50.517]             base::options(...future.oldOptions)
[10:30:50.517]             if (.Platform$OS.type == "windows") {
[10:30:50.517]                 old_names <- names(...future.oldEnvVars)
[10:30:50.517]                 envs <- base::Sys.getenv()
[10:30:50.517]                 names <- names(envs)
[10:30:50.517]                 common <- intersect(names, old_names)
[10:30:50.517]                 added <- setdiff(names, old_names)
[10:30:50.517]                 removed <- setdiff(old_names, names)
[10:30:50.517]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.517]                   envs[common]]
[10:30:50.517]                 NAMES <- toupper(changed)
[10:30:50.517]                 args <- list()
[10:30:50.517]                 for (kk in seq_along(NAMES)) {
[10:30:50.517]                   name <- changed[[kk]]
[10:30:50.517]                   NAME <- NAMES[[kk]]
[10:30:50.517]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.517]                     next
[10:30:50.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.517]                 }
[10:30:50.517]                 NAMES <- toupper(added)
[10:30:50.517]                 for (kk in seq_along(NAMES)) {
[10:30:50.517]                   name <- added[[kk]]
[10:30:50.517]                   NAME <- NAMES[[kk]]
[10:30:50.517]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.517]                     next
[10:30:50.517]                   args[[name]] <- ""
[10:30:50.517]                 }
[10:30:50.517]                 NAMES <- toupper(removed)
[10:30:50.517]                 for (kk in seq_along(NAMES)) {
[10:30:50.517]                   name <- removed[[kk]]
[10:30:50.517]                   NAME <- NAMES[[kk]]
[10:30:50.517]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.517]                     next
[10:30:50.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.517]                 }
[10:30:50.517]                 if (length(args) > 0) 
[10:30:50.517]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.517]             }
[10:30:50.517]             else {
[10:30:50.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.517]             }
[10:30:50.517]             {
[10:30:50.517]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.517]                   0L) {
[10:30:50.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.517]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.517]                   base::options(opts)
[10:30:50.517]                 }
[10:30:50.517]                 {
[10:30:50.517]                   {
[10:30:50.517]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.517]                     NULL
[10:30:50.517]                   }
[10:30:50.517]                   options(future.plan = NULL)
[10:30:50.517]                   if (is.na(NA_character_)) 
[10:30:50.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.517]                     .init = FALSE)
[10:30:50.517]                 }
[10:30:50.517]             }
[10:30:50.517]         }
[10:30:50.517]     })
[10:30:50.517]     if (TRUE) {
[10:30:50.517]         base::sink(type = "output", split = FALSE)
[10:30:50.517]         if (TRUE) {
[10:30:50.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.517]         }
[10:30:50.517]         else {
[10:30:50.517]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.517]         }
[10:30:50.517]         base::close(...future.stdout)
[10:30:50.517]         ...future.stdout <- NULL
[10:30:50.517]     }
[10:30:50.517]     ...future.result$conditions <- ...future.conditions
[10:30:50.517]     ...future.result$finished <- base::Sys.time()
[10:30:50.517]     ...future.result
[10:30:50.517] }
[10:30:50.519] assign_globals() ...
[10:30:50.519] List of 5
[10:30:50.519]  $ ...future.FUN            :function (C, k)  
[10:30:50.519]  $ MoreArgs                 : NULL
[10:30:50.519]  $ ...future.elements_ii    :List of 2
[10:30:50.519]   ..$ :List of 2
[10:30:50.519]   .. ..$ : chr "E"
[10:30:50.519]   .. ..$ : chr "D"
[10:30:50.519]   ..$ :List of 2
[10:30:50.519]   .. ..$ : int 1
[10:30:50.519]   .. ..$ : int 2
[10:30:50.519]  $ ...future.seeds_ii       : NULL
[10:30:50.519]  $ ...future.globals.maxSize: NULL
[10:30:50.519]  - attr(*, "where")=List of 5
[10:30:50.519]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.519]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.519]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.519]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.519]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.519]  - attr(*, "resolved")= logi FALSE
[10:30:50.519]  - attr(*, "total_size")= num 3656
[10:30:50.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.519]  - attr(*, "already-done")= logi TRUE
[10:30:50.525] - reassign environment for ‘...future.FUN’
[10:30:50.525] - copied ‘...future.FUN’ to environment
[10:30:50.525] - copied ‘MoreArgs’ to environment
[10:30:50.526] - copied ‘...future.elements_ii’ to environment
[10:30:50.526] - copied ‘...future.seeds_ii’ to environment
[10:30:50.526] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.526] assign_globals() ... done
[10:30:50.526] requestCore(): workers = 2
[10:30:50.528] MulticoreFuture started
[10:30:50.529] - Launch lazy future ... done
[10:30:50.529] run() for ‘MulticoreFuture’ ... done
[10:30:50.529] Created future:
[10:30:50.529] plan(): Setting new future strategy stack:
[10:30:50.530] List of future strategies:
[10:30:50.530] 1. sequential:
[10:30:50.530]    - args: function (..., envir = parent.frame())
[10:30:50.530]    - tweaked: FALSE
[10:30:50.530]    - call: NULL
[10:30:50.530] plan(): nbrOfWorkers() = 1
[10:30:50.533] plan(): Setting new future strategy stack:
[10:30:50.533] List of future strategies:
[10:30:50.533] 1. multicore:
[10:30:50.533]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.533]    - tweaked: FALSE
[10:30:50.533]    - call: plan(strategy)
[10:30:50.538] plan(): nbrOfWorkers() = 2
[10:30:50.529] MulticoreFuture:
[10:30:50.529] Label: ‘future_mapply-1’
[10:30:50.529] Expression:
[10:30:50.529] {
[10:30:50.529]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.529]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.529]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.529]         on.exit(options(oopts), add = TRUE)
[10:30:50.529]     }
[10:30:50.529]     {
[10:30:50.529]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.529]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.529]         do.call(mapply, args = args)
[10:30:50.529]     }
[10:30:50.529] }
[10:30:50.529] Lazy evaluation: FALSE
[10:30:50.529] Asynchronous evaluation: TRUE
[10:30:50.529] Local evaluation: TRUE
[10:30:50.529] Environment: R_GlobalEnv
[10:30:50.529] Capture standard output: TRUE
[10:30:50.529] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.529] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.529] Packages: <none>
[10:30:50.529] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.529] Resolved: TRUE
[10:30:50.529] Value: <not collected>
[10:30:50.529] Conditions captured: <none>
[10:30:50.529] Early signaling: FALSE
[10:30:50.529] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.529] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.540] Chunk #1 of 2 ... DONE
[10:30:50.540] Chunk #2 of 2 ...
[10:30:50.540]  - Finding globals in '...' for chunk #2 ...
[10:30:50.540] getGlobalsAndPackages() ...
[10:30:50.540] Searching for globals...
[10:30:50.541] 
[10:30:50.541] Searching for globals ... DONE
[10:30:50.541] - globals: [0] <none>
[10:30:50.541] getGlobalsAndPackages() ... DONE
[10:30:50.541]    + additional globals found: [n=0] 
[10:30:50.542]    + additional namespaces needed: [n=0] 
[10:30:50.542]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:50.542]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:50.542]  - seeds: <none>
[10:30:50.542]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.542] getGlobalsAndPackages() ...
[10:30:50.543] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.543] Resolving globals: FALSE
[10:30:50.548] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[10:30:50.549] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:50.550] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.550] 
[10:30:50.551] getGlobalsAndPackages() ... DONE
[10:30:50.552] run() for ‘Future’ ...
[10:30:50.552] - state: ‘created’
[10:30:50.552] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.558] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.559]   - Field: ‘label’
[10:30:50.559]   - Field: ‘local’
[10:30:50.559]   - Field: ‘owner’
[10:30:50.559]   - Field: ‘envir’
[10:30:50.560]   - Field: ‘workers’
[10:30:50.560]   - Field: ‘packages’
[10:30:50.560]   - Field: ‘gc’
[10:30:50.560]   - Field: ‘job’
[10:30:50.561]   - Field: ‘conditions’
[10:30:50.561]   - Field: ‘expr’
[10:30:50.561]   - Field: ‘uuid’
[10:30:50.561]   - Field: ‘seed’
[10:30:50.561]   - Field: ‘version’
[10:30:50.562]   - Field: ‘result’
[10:30:50.562]   - Field: ‘asynchronous’
[10:30:50.562]   - Field: ‘calls’
[10:30:50.562]   - Field: ‘globals’
[10:30:50.562]   - Field: ‘stdout’
[10:30:50.562]   - Field: ‘earlySignal’
[10:30:50.563]   - Field: ‘lazy’
[10:30:50.563]   - Field: ‘state’
[10:30:50.563] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.563] - Launch lazy future ...
[10:30:50.563] Packages needed by the future expression (n = 0): <none>
[10:30:50.564] Packages needed by future strategies (n = 0): <none>
[10:30:50.564] {
[10:30:50.564]     {
[10:30:50.564]         {
[10:30:50.564]             ...future.startTime <- base::Sys.time()
[10:30:50.564]             {
[10:30:50.564]                 {
[10:30:50.564]                   {
[10:30:50.564]                     {
[10:30:50.564]                       base::local({
[10:30:50.564]                         has_future <- base::requireNamespace("future", 
[10:30:50.564]                           quietly = TRUE)
[10:30:50.564]                         if (has_future) {
[10:30:50.564]                           ns <- base::getNamespace("future")
[10:30:50.564]                           version <- ns[[".package"]][["version"]]
[10:30:50.564]                           if (is.null(version)) 
[10:30:50.564]                             version <- utils::packageVersion("future")
[10:30:50.564]                         }
[10:30:50.564]                         else {
[10:30:50.564]                           version <- NULL
[10:30:50.564]                         }
[10:30:50.564]                         if (!has_future || version < "1.8.0") {
[10:30:50.564]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.564]                             "", base::R.version$version.string), 
[10:30:50.564]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.564]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.564]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.564]                               "release", "version")], collapse = " "), 
[10:30:50.564]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.564]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.564]                             info)
[10:30:50.564]                           info <- base::paste(info, collapse = "; ")
[10:30:50.564]                           if (!has_future) {
[10:30:50.564]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.564]                               info)
[10:30:50.564]                           }
[10:30:50.564]                           else {
[10:30:50.564]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.564]                               info, version)
[10:30:50.564]                           }
[10:30:50.564]                           base::stop(msg)
[10:30:50.564]                         }
[10:30:50.564]                       })
[10:30:50.564]                     }
[10:30:50.564]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.564]                     base::options(mc.cores = 1L)
[10:30:50.564]                   }
[10:30:50.564]                   ...future.strategy.old <- future::plan("list")
[10:30:50.564]                   options(future.plan = NULL)
[10:30:50.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.564]                 }
[10:30:50.564]                 ...future.workdir <- getwd()
[10:30:50.564]             }
[10:30:50.564]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.564]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.564]         }
[10:30:50.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.564]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:50.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.564]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.564]             base::names(...future.oldOptions))
[10:30:50.564]     }
[10:30:50.564]     if (FALSE) {
[10:30:50.564]     }
[10:30:50.564]     else {
[10:30:50.564]         if (TRUE) {
[10:30:50.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.564]                 open = "w")
[10:30:50.564]         }
[10:30:50.564]         else {
[10:30:50.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.564]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.564]         }
[10:30:50.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.564]             base::sink(type = "output", split = FALSE)
[10:30:50.564]             base::close(...future.stdout)
[10:30:50.564]         }, add = TRUE)
[10:30:50.564]     }
[10:30:50.564]     ...future.frame <- base::sys.nframe()
[10:30:50.564]     ...future.conditions <- base::list()
[10:30:50.564]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.564]     if (FALSE) {
[10:30:50.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.564]     }
[10:30:50.564]     ...future.result <- base::tryCatch({
[10:30:50.564]         base::withCallingHandlers({
[10:30:50.564]             ...future.value <- base::withVisible(base::local({
[10:30:50.564]                 withCallingHandlers({
[10:30:50.564]                   {
[10:30:50.564]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.564]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.564]                       ...future.globals.maxSize)) {
[10:30:50.564]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.564]                       on.exit(options(oopts), add = TRUE)
[10:30:50.564]                     }
[10:30:50.564]                     {
[10:30:50.564]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.564]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.564]                         USE.NAMES = FALSE)
[10:30:50.564]                       do.call(mapply, args = args)
[10:30:50.564]                     }
[10:30:50.564]                   }
[10:30:50.564]                 }, immediateCondition = function(cond) {
[10:30:50.564]                   save_rds <- function (object, pathname, ...) 
[10:30:50.564]                   {
[10:30:50.564]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.564]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.564]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.564]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.564]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.564]                         fi_tmp[["mtime"]])
[10:30:50.564]                     }
[10:30:50.564]                     tryCatch({
[10:30:50.564]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.564]                     }, error = function(ex) {
[10:30:50.564]                       msg <- conditionMessage(ex)
[10:30:50.564]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.564]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.564]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.564]                         fi_tmp[["mtime"]], msg)
[10:30:50.564]                       ex$message <- msg
[10:30:50.564]                       stop(ex)
[10:30:50.564]                     })
[10:30:50.564]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.564]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.564]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.564]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.564]                       fi <- file.info(pathname)
[10:30:50.564]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.564]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.564]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.564]                         fi[["size"]], fi[["mtime"]])
[10:30:50.564]                       stop(msg)
[10:30:50.564]                     }
[10:30:50.564]                     invisible(pathname)
[10:30:50.564]                   }
[10:30:50.564]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.564]                     rootPath = tempdir()) 
[10:30:50.564]                   {
[10:30:50.564]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.564]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.564]                       tmpdir = path, fileext = ".rds")
[10:30:50.564]                     save_rds(obj, file)
[10:30:50.564]                   }
[10:30:50.564]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.564]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.564]                   {
[10:30:50.564]                     inherits <- base::inherits
[10:30:50.564]                     invokeRestart <- base::invokeRestart
[10:30:50.564]                     is.null <- base::is.null
[10:30:50.564]                     muffled <- FALSE
[10:30:50.564]                     if (inherits(cond, "message")) {
[10:30:50.564]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.564]                       if (muffled) 
[10:30:50.564]                         invokeRestart("muffleMessage")
[10:30:50.564]                     }
[10:30:50.564]                     else if (inherits(cond, "warning")) {
[10:30:50.564]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.564]                       if (muffled) 
[10:30:50.564]                         invokeRestart("muffleWarning")
[10:30:50.564]                     }
[10:30:50.564]                     else if (inherits(cond, "condition")) {
[10:30:50.564]                       if (!is.null(pattern)) {
[10:30:50.564]                         computeRestarts <- base::computeRestarts
[10:30:50.564]                         grepl <- base::grepl
[10:30:50.564]                         restarts <- computeRestarts(cond)
[10:30:50.564]                         for (restart in restarts) {
[10:30:50.564]                           name <- restart$name
[10:30:50.564]                           if (is.null(name)) 
[10:30:50.564]                             next
[10:30:50.564]                           if (!grepl(pattern, name)) 
[10:30:50.564]                             next
[10:30:50.564]                           invokeRestart(restart)
[10:30:50.564]                           muffled <- TRUE
[10:30:50.564]                           break
[10:30:50.564]                         }
[10:30:50.564]                       }
[10:30:50.564]                     }
[10:30:50.564]                     invisible(muffled)
[10:30:50.564]                   }
[10:30:50.564]                   muffleCondition(cond)
[10:30:50.564]                 })
[10:30:50.564]             }))
[10:30:50.564]             future::FutureResult(value = ...future.value$value, 
[10:30:50.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.564]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.564]                     ...future.globalenv.names))
[10:30:50.564]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.564]         }, condition = base::local({
[10:30:50.564]             c <- base::c
[10:30:50.564]             inherits <- base::inherits
[10:30:50.564]             invokeRestart <- base::invokeRestart
[10:30:50.564]             length <- base::length
[10:30:50.564]             list <- base::list
[10:30:50.564]             seq.int <- base::seq.int
[10:30:50.564]             signalCondition <- base::signalCondition
[10:30:50.564]             sys.calls <- base::sys.calls
[10:30:50.564]             `[[` <- base::`[[`
[10:30:50.564]             `+` <- base::`+`
[10:30:50.564]             `<<-` <- base::`<<-`
[10:30:50.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.564]                   3L)]
[10:30:50.564]             }
[10:30:50.564]             function(cond) {
[10:30:50.564]                 is_error <- inherits(cond, "error")
[10:30:50.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.564]                   NULL)
[10:30:50.564]                 if (is_error) {
[10:30:50.564]                   sessionInformation <- function() {
[10:30:50.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.564]                       search = base::search(), system = base::Sys.info())
[10:30:50.564]                   }
[10:30:50.564]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.564]                     cond$call), session = sessionInformation(), 
[10:30:50.564]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.564]                   signalCondition(cond)
[10:30:50.564]                 }
[10:30:50.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.564]                 "immediateCondition"))) {
[10:30:50.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.564]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.564]                   if (TRUE && !signal) {
[10:30:50.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.564]                     {
[10:30:50.564]                       inherits <- base::inherits
[10:30:50.564]                       invokeRestart <- base::invokeRestart
[10:30:50.564]                       is.null <- base::is.null
[10:30:50.564]                       muffled <- FALSE
[10:30:50.564]                       if (inherits(cond, "message")) {
[10:30:50.564]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.564]                         if (muffled) 
[10:30:50.564]                           invokeRestart("muffleMessage")
[10:30:50.564]                       }
[10:30:50.564]                       else if (inherits(cond, "warning")) {
[10:30:50.564]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.564]                         if (muffled) 
[10:30:50.564]                           invokeRestart("muffleWarning")
[10:30:50.564]                       }
[10:30:50.564]                       else if (inherits(cond, "condition")) {
[10:30:50.564]                         if (!is.null(pattern)) {
[10:30:50.564]                           computeRestarts <- base::computeRestarts
[10:30:50.564]                           grepl <- base::grepl
[10:30:50.564]                           restarts <- computeRestarts(cond)
[10:30:50.564]                           for (restart in restarts) {
[10:30:50.564]                             name <- restart$name
[10:30:50.564]                             if (is.null(name)) 
[10:30:50.564]                               next
[10:30:50.564]                             if (!grepl(pattern, name)) 
[10:30:50.564]                               next
[10:30:50.564]                             invokeRestart(restart)
[10:30:50.564]                             muffled <- TRUE
[10:30:50.564]                             break
[10:30:50.564]                           }
[10:30:50.564]                         }
[10:30:50.564]                       }
[10:30:50.564]                       invisible(muffled)
[10:30:50.564]                     }
[10:30:50.564]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.564]                   }
[10:30:50.564]                 }
[10:30:50.564]                 else {
[10:30:50.564]                   if (TRUE) {
[10:30:50.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.564]                     {
[10:30:50.564]                       inherits <- base::inherits
[10:30:50.564]                       invokeRestart <- base::invokeRestart
[10:30:50.564]                       is.null <- base::is.null
[10:30:50.564]                       muffled <- FALSE
[10:30:50.564]                       if (inherits(cond, "message")) {
[10:30:50.564]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.564]                         if (muffled) 
[10:30:50.564]                           invokeRestart("muffleMessage")
[10:30:50.564]                       }
[10:30:50.564]                       else if (inherits(cond, "warning")) {
[10:30:50.564]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.564]                         if (muffled) 
[10:30:50.564]                           invokeRestart("muffleWarning")
[10:30:50.564]                       }
[10:30:50.564]                       else if (inherits(cond, "condition")) {
[10:30:50.564]                         if (!is.null(pattern)) {
[10:30:50.564]                           computeRestarts <- base::computeRestarts
[10:30:50.564]                           grepl <- base::grepl
[10:30:50.564]                           restarts <- computeRestarts(cond)
[10:30:50.564]                           for (restart in restarts) {
[10:30:50.564]                             name <- restart$name
[10:30:50.564]                             if (is.null(name)) 
[10:30:50.564]                               next
[10:30:50.564]                             if (!grepl(pattern, name)) 
[10:30:50.564]                               next
[10:30:50.564]                             invokeRestart(restart)
[10:30:50.564]                             muffled <- TRUE
[10:30:50.564]                             break
[10:30:50.564]                           }
[10:30:50.564]                         }
[10:30:50.564]                       }
[10:30:50.564]                       invisible(muffled)
[10:30:50.564]                     }
[10:30:50.564]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.564]                   }
[10:30:50.564]                 }
[10:30:50.564]             }
[10:30:50.564]         }))
[10:30:50.564]     }, error = function(ex) {
[10:30:50.564]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.564]                 ...future.rng), started = ...future.startTime, 
[10:30:50.564]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.564]             version = "1.8"), class = "FutureResult")
[10:30:50.564]     }, finally = {
[10:30:50.564]         if (!identical(...future.workdir, getwd())) 
[10:30:50.564]             setwd(...future.workdir)
[10:30:50.564]         {
[10:30:50.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.564]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.564]             }
[10:30:50.564]             base::options(...future.oldOptions)
[10:30:50.564]             if (.Platform$OS.type == "windows") {
[10:30:50.564]                 old_names <- names(...future.oldEnvVars)
[10:30:50.564]                 envs <- base::Sys.getenv()
[10:30:50.564]                 names <- names(envs)
[10:30:50.564]                 common <- intersect(names, old_names)
[10:30:50.564]                 added <- setdiff(names, old_names)
[10:30:50.564]                 removed <- setdiff(old_names, names)
[10:30:50.564]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.564]                   envs[common]]
[10:30:50.564]                 NAMES <- toupper(changed)
[10:30:50.564]                 args <- list()
[10:30:50.564]                 for (kk in seq_along(NAMES)) {
[10:30:50.564]                   name <- changed[[kk]]
[10:30:50.564]                   NAME <- NAMES[[kk]]
[10:30:50.564]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.564]                     next
[10:30:50.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.564]                 }
[10:30:50.564]                 NAMES <- toupper(added)
[10:30:50.564]                 for (kk in seq_along(NAMES)) {
[10:30:50.564]                   name <- added[[kk]]
[10:30:50.564]                   NAME <- NAMES[[kk]]
[10:30:50.564]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.564]                     next
[10:30:50.564]                   args[[name]] <- ""
[10:30:50.564]                 }
[10:30:50.564]                 NAMES <- toupper(removed)
[10:30:50.564]                 for (kk in seq_along(NAMES)) {
[10:30:50.564]                   name <- removed[[kk]]
[10:30:50.564]                   NAME <- NAMES[[kk]]
[10:30:50.564]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.564]                     next
[10:30:50.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.564]                 }
[10:30:50.564]                 if (length(args) > 0) 
[10:30:50.564]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.564]             }
[10:30:50.564]             else {
[10:30:50.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.564]             }
[10:30:50.564]             {
[10:30:50.564]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.564]                   0L) {
[10:30:50.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.564]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.564]                   base::options(opts)
[10:30:50.564]                 }
[10:30:50.564]                 {
[10:30:50.564]                   {
[10:30:50.564]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.564]                     NULL
[10:30:50.564]                   }
[10:30:50.564]                   options(future.plan = NULL)
[10:30:50.564]                   if (is.na(NA_character_)) 
[10:30:50.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.564]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.564]                     .init = FALSE)
[10:30:50.564]                 }
[10:30:50.564]             }
[10:30:50.564]         }
[10:30:50.564]     })
[10:30:50.564]     if (TRUE) {
[10:30:50.564]         base::sink(type = "output", split = FALSE)
[10:30:50.564]         if (TRUE) {
[10:30:50.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.564]         }
[10:30:50.564]         else {
[10:30:50.564]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.564]         }
[10:30:50.564]         base::close(...future.stdout)
[10:30:50.564]         ...future.stdout <- NULL
[10:30:50.564]     }
[10:30:50.564]     ...future.result$conditions <- ...future.conditions
[10:30:50.564]     ...future.result$finished <- base::Sys.time()
[10:30:50.564]     ...future.result
[10:30:50.564] }
[10:30:50.567] assign_globals() ...
[10:30:50.567] List of 5
[10:30:50.567]  $ ...future.FUN            :function (C, k)  
[10:30:50.567]  $ MoreArgs                 : NULL
[10:30:50.567]  $ ...future.elements_ii    :List of 2
[10:30:50.567]   ..$ :List of 3
[10:30:50.567]   .. ..$ : chr "C"
[10:30:50.567]   .. ..$ : chr "B"
[10:30:50.567]   .. ..$ : chr "A"
[10:30:50.567]   ..$ :List of 3
[10:30:50.567]   .. ..$ : int 3
[10:30:50.567]   .. ..$ : int 4
[10:30:50.567]   .. ..$ : int 5
[10:30:50.567]  $ ...future.seeds_ii       : NULL
[10:30:50.567]  $ ...future.globals.maxSize: NULL
[10:30:50.567]  - attr(*, "where")=List of 5
[10:30:50.567]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.567]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.567]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.567]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.567]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.567]  - attr(*, "resolved")= logi FALSE
[10:30:50.567]  - attr(*, "total_size")= num 3824
[10:30:50.567]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.567]  - attr(*, "already-done")= logi TRUE
[10:30:50.576] - reassign environment for ‘...future.FUN’
[10:30:50.576] - copied ‘...future.FUN’ to environment
[10:30:50.576] - copied ‘MoreArgs’ to environment
[10:30:50.576] - copied ‘...future.elements_ii’ to environment
[10:30:50.577] - copied ‘...future.seeds_ii’ to environment
[10:30:50.577] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.577] assign_globals() ... done
[10:30:50.577] requestCore(): workers = 2
[10:30:50.580] MulticoreFuture started
[10:30:50.580] - Launch lazy future ... done
[10:30:50.580] run() for ‘MulticoreFuture’ ... done
[10:30:50.580] Created future:
[10:30:50.581] plan(): Setting new future strategy stack:
[10:30:50.581] List of future strategies:
[10:30:50.581] 1. sequential:
[10:30:50.581]    - args: function (..., envir = parent.frame())
[10:30:50.581]    - tweaked: FALSE
[10:30:50.581]    - call: NULL
[10:30:50.582] plan(): nbrOfWorkers() = 1
[10:30:50.584] plan(): Setting new future strategy stack:
[10:30:50.584] List of future strategies:
[10:30:50.584] 1. multicore:
[10:30:50.584]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.584]    - tweaked: FALSE
[10:30:50.584]    - call: plan(strategy)
[10:30:50.590] plan(): nbrOfWorkers() = 2
[10:30:50.581] MulticoreFuture:
[10:30:50.581] Label: ‘future_mapply-2’
[10:30:50.581] Expression:
[10:30:50.581] {
[10:30:50.581]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.581]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.581]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.581]         on.exit(options(oopts), add = TRUE)
[10:30:50.581]     }
[10:30:50.581]     {
[10:30:50.581]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.581]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.581]         do.call(mapply, args = args)
[10:30:50.581]     }
[10:30:50.581] }
[10:30:50.581] Lazy evaluation: FALSE
[10:30:50.581] Asynchronous evaluation: TRUE
[10:30:50.581] Local evaluation: TRUE
[10:30:50.581] Environment: R_GlobalEnv
[10:30:50.581] Capture standard output: TRUE
[10:30:50.581] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.581] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.581] Packages: <none>
[10:30:50.581] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.581] Resolved: TRUE
[10:30:50.581] Value: <not collected>
[10:30:50.581] Conditions captured: <none>
[10:30:50.581] Early signaling: FALSE
[10:30:50.581] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.581] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.592] Chunk #2 of 2 ... DONE
[10:30:50.592] Launching 2 futures (chunks) ... DONE
[10:30:50.592] Resolving 2 futures (chunks) ...
[10:30:50.592] resolve() on list ...
[10:30:50.592]  recursive: 0
[10:30:50.592]  length: 2
[10:30:50.593] 
[10:30:50.593] Future #1
[10:30:50.593] result() for MulticoreFuture ...
[10:30:50.594] result() for MulticoreFuture ...
[10:30:50.594] result() for MulticoreFuture ... done
[10:30:50.595] result() for MulticoreFuture ... done
[10:30:50.595] result() for MulticoreFuture ...
[10:30:50.595] result() for MulticoreFuture ... done
[10:30:50.595] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:50.595] - nx: 2
[10:30:50.595] - relay: TRUE
[10:30:50.596] - stdout: TRUE
[10:30:50.596] - signal: TRUE
[10:30:50.600] - resignal: FALSE
[10:30:50.600] - force: TRUE
[10:30:50.601] - relayed: [n=2] FALSE, FALSE
[10:30:50.601] - queued futures: [n=2] FALSE, FALSE
[10:30:50.602]  - until=1
[10:30:50.602]  - relaying element #1
[10:30:50.602] result() for MulticoreFuture ...
[10:30:50.603] result() for MulticoreFuture ... done
[10:30:50.603] result() for MulticoreFuture ...
[10:30:50.603] result() for MulticoreFuture ... done
[10:30:50.604] result() for MulticoreFuture ...
[10:30:50.604] result() for MulticoreFuture ... done
[10:30:50.604] result() for MulticoreFuture ...
[10:30:50.605] result() for MulticoreFuture ... done
[10:30:50.605] - relayed: [n=2] TRUE, FALSE
[10:30:50.605] - queued futures: [n=2] TRUE, FALSE
[10:30:50.605] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:50.606]  length: 1 (resolved future 1)
[10:30:50.606] Future #2
[10:30:50.607] result() for MulticoreFuture ...
[10:30:50.608] result() for MulticoreFuture ...
[10:30:50.608] result() for MulticoreFuture ... done
[10:30:50.608] result() for MulticoreFuture ... done
[10:30:50.608] result() for MulticoreFuture ...
[10:30:50.609] result() for MulticoreFuture ... done
[10:30:50.609] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:50.609] - nx: 2
[10:30:50.609] - relay: TRUE
[10:30:50.609] - stdout: TRUE
[10:30:50.610] - signal: TRUE
[10:30:50.610] - resignal: FALSE
[10:30:50.610] - force: TRUE
[10:30:50.610] - relayed: [n=2] TRUE, FALSE
[10:30:50.610] - queued futures: [n=2] TRUE, FALSE
[10:30:50.610]  - until=2
[10:30:50.611]  - relaying element #2
[10:30:50.611] result() for MulticoreFuture ...
[10:30:50.611] result() for MulticoreFuture ... done
[10:30:50.611] result() for MulticoreFuture ...
[10:30:50.611] result() for MulticoreFuture ... done
[10:30:50.611] result() for MulticoreFuture ...
[10:30:50.611] result() for MulticoreFuture ... done
[10:30:50.612] result() for MulticoreFuture ...
[10:30:50.612] result() for MulticoreFuture ... done
[10:30:50.612] - relayed: [n=2] TRUE, TRUE
[10:30:50.612] - queued futures: [n=2] TRUE, TRUE
[10:30:50.612] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:50.612]  length: 0 (resolved future 2)
[10:30:50.612] Relaying remaining futures
[10:30:50.612] signalConditionsASAP(NULL, pos=0) ...
[10:30:50.612] - nx: 2
[10:30:50.613] - relay: TRUE
[10:30:50.613] - stdout: TRUE
[10:30:50.613] - signal: TRUE
[10:30:50.613] - resignal: FALSE
[10:30:50.613] - force: TRUE
[10:30:50.613] - relayed: [n=2] TRUE, TRUE
[10:30:50.613] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:50.613] - relayed: [n=2] TRUE, TRUE
[10:30:50.614] - queued futures: [n=2] TRUE, TRUE
[10:30:50.614] signalConditionsASAP(NULL, pos=0) ... done
[10:30:50.614] resolve() on list ... DONE
[10:30:50.614] result() for MulticoreFuture ...
[10:30:50.614] result() for MulticoreFuture ... done
[10:30:50.614] result() for MulticoreFuture ...
[10:30:50.614] result() for MulticoreFuture ... done
[10:30:50.614] result() for MulticoreFuture ...
[10:30:50.614] result() for MulticoreFuture ... done
[10:30:50.615] result() for MulticoreFuture ...
[10:30:50.615] result() for MulticoreFuture ... done
[10:30:50.615]  - Number of value chunks collected: 2
[10:30:50.615] Resolving 2 futures (chunks) ... DONE
[10:30:50.615] Reducing values from 2 chunks ...
[10:30:50.615]  - Number of values collected after concatenation: 5
[10:30:50.615]  - Number of values expected: 5
[10:30:50.615] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:30:50.616] Reducing values from 2 chunks ... DONE
[10:30:50.616] future_mapply() ... DONE
[10:30:50.616] future_mapply() ...
[10:30:50.621] Number of chunks: 2
[10:30:50.621] getGlobalsAndPackagesXApply() ...
[10:30:50.621]  - future.globals: TRUE
[10:30:50.621] getGlobalsAndPackages() ...
[10:30:50.621] Searching for globals...
[10:30:50.623] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:50.623] Searching for globals ... DONE
[10:30:50.623] Resolving globals: FALSE
[10:30:50.623] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:50.624] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:50.624] - globals: [1] ‘FUN’
[10:30:50.624] 
[10:30:50.624] getGlobalsAndPackages() ... DONE
[10:30:50.624]  - globals found/used: [n=1] ‘FUN’
[10:30:50.624]  - needed namespaces: [n=0] 
[10:30:50.624] Finding globals ... DONE
[10:30:50.624] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:50.625] List of 2
[10:30:50.625]  $ ...future.FUN:function (C, k)  
[10:30:50.625]  $ MoreArgs     : list()
[10:30:50.625]  - attr(*, "where")=List of 2
[10:30:50.625]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:50.625]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:50.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.625]  - attr(*, "resolved")= logi FALSE
[10:30:50.625]  - attr(*, "total_size")= num NA
[10:30:50.627] Packages to be attached in all futures: [n=0] 
[10:30:50.627] getGlobalsAndPackagesXApply() ... DONE
[10:30:50.628] Number of futures (= number of chunks): 2
[10:30:50.628] Launching 2 futures (chunks) ...
[10:30:50.628] Chunk #1 of 2 ...
[10:30:50.628]  - Finding globals in '...' for chunk #1 ...
[10:30:50.628] getGlobalsAndPackages() ...
[10:30:50.628] Searching for globals...
[10:30:50.629] 
[10:30:50.629] Searching for globals ... DONE
[10:30:50.629] - globals: [0] <none>
[10:30:50.629] getGlobalsAndPackages() ... DONE
[10:30:50.631]    + additional globals found: [n=0] 
[10:30:50.632]    + additional namespaces needed: [n=0] 
[10:30:50.632]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:50.632]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:50.632]  - seeds: <none>
[10:30:50.632]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.632] getGlobalsAndPackages() ...
[10:30:50.632] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.633] Resolving globals: FALSE
[10:30:50.633] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:50.634] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:50.634] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.634] 
[10:30:50.634] getGlobalsAndPackages() ... DONE
[10:30:50.635] run() for ‘Future’ ...
[10:30:50.635] - state: ‘created’
[10:30:50.635] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.639] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.639]   - Field: ‘label’
[10:30:50.640]   - Field: ‘local’
[10:30:50.640]   - Field: ‘owner’
[10:30:50.640]   - Field: ‘envir’
[10:30:50.640]   - Field: ‘workers’
[10:30:50.640]   - Field: ‘packages’
[10:30:50.640]   - Field: ‘gc’
[10:30:50.640]   - Field: ‘job’
[10:30:50.640]   - Field: ‘conditions’
[10:30:50.640]   - Field: ‘expr’
[10:30:50.640]   - Field: ‘uuid’
[10:30:50.641]   - Field: ‘seed’
[10:30:50.641]   - Field: ‘version’
[10:30:50.641]   - Field: ‘result’
[10:30:50.641]   - Field: ‘asynchronous’
[10:30:50.641]   - Field: ‘calls’
[10:30:50.641]   - Field: ‘globals’
[10:30:50.641]   - Field: ‘stdout’
[10:30:50.641]   - Field: ‘earlySignal’
[10:30:50.641]   - Field: ‘lazy’
[10:30:50.642]   - Field: ‘state’
[10:30:50.642] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.642] - Launch lazy future ...
[10:30:50.642] Packages needed by the future expression (n = 0): <none>
[10:30:50.642] Packages needed by future strategies (n = 0): <none>
[10:30:50.643] {
[10:30:50.643]     {
[10:30:50.643]         {
[10:30:50.643]             ...future.startTime <- base::Sys.time()
[10:30:50.643]             {
[10:30:50.643]                 {
[10:30:50.643]                   {
[10:30:50.643]                     {
[10:30:50.643]                       base::local({
[10:30:50.643]                         has_future <- base::requireNamespace("future", 
[10:30:50.643]                           quietly = TRUE)
[10:30:50.643]                         if (has_future) {
[10:30:50.643]                           ns <- base::getNamespace("future")
[10:30:50.643]                           version <- ns[[".package"]][["version"]]
[10:30:50.643]                           if (is.null(version)) 
[10:30:50.643]                             version <- utils::packageVersion("future")
[10:30:50.643]                         }
[10:30:50.643]                         else {
[10:30:50.643]                           version <- NULL
[10:30:50.643]                         }
[10:30:50.643]                         if (!has_future || version < "1.8.0") {
[10:30:50.643]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.643]                             "", base::R.version$version.string), 
[10:30:50.643]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.643]                               "release", "version")], collapse = " "), 
[10:30:50.643]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.643]                             info)
[10:30:50.643]                           info <- base::paste(info, collapse = "; ")
[10:30:50.643]                           if (!has_future) {
[10:30:50.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.643]                               info)
[10:30:50.643]                           }
[10:30:50.643]                           else {
[10:30:50.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.643]                               info, version)
[10:30:50.643]                           }
[10:30:50.643]                           base::stop(msg)
[10:30:50.643]                         }
[10:30:50.643]                       })
[10:30:50.643]                     }
[10:30:50.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.643]                     base::options(mc.cores = 1L)
[10:30:50.643]                   }
[10:30:50.643]                   ...future.strategy.old <- future::plan("list")
[10:30:50.643]                   options(future.plan = NULL)
[10:30:50.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.643]                 }
[10:30:50.643]                 ...future.workdir <- getwd()
[10:30:50.643]             }
[10:30:50.643]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.643]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.643]         }
[10:30:50.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.643]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:50.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.643]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.643]             base::names(...future.oldOptions))
[10:30:50.643]     }
[10:30:50.643]     if (FALSE) {
[10:30:50.643]     }
[10:30:50.643]     else {
[10:30:50.643]         if (TRUE) {
[10:30:50.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.643]                 open = "w")
[10:30:50.643]         }
[10:30:50.643]         else {
[10:30:50.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.643]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.643]         }
[10:30:50.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.643]             base::sink(type = "output", split = FALSE)
[10:30:50.643]             base::close(...future.stdout)
[10:30:50.643]         }, add = TRUE)
[10:30:50.643]     }
[10:30:50.643]     ...future.frame <- base::sys.nframe()
[10:30:50.643]     ...future.conditions <- base::list()
[10:30:50.643]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.643]     if (FALSE) {
[10:30:50.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.643]     }
[10:30:50.643]     ...future.result <- base::tryCatch({
[10:30:50.643]         base::withCallingHandlers({
[10:30:50.643]             ...future.value <- base::withVisible(base::local({
[10:30:50.643]                 withCallingHandlers({
[10:30:50.643]                   {
[10:30:50.643]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.643]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.643]                       ...future.globals.maxSize)) {
[10:30:50.643]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.643]                       on.exit(options(oopts), add = TRUE)
[10:30:50.643]                     }
[10:30:50.643]                     {
[10:30:50.643]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.643]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.643]                         USE.NAMES = FALSE)
[10:30:50.643]                       do.call(mapply, args = args)
[10:30:50.643]                     }
[10:30:50.643]                   }
[10:30:50.643]                 }, immediateCondition = function(cond) {
[10:30:50.643]                   save_rds <- function (object, pathname, ...) 
[10:30:50.643]                   {
[10:30:50.643]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.643]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.643]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.643]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.643]                         fi_tmp[["mtime"]])
[10:30:50.643]                     }
[10:30:50.643]                     tryCatch({
[10:30:50.643]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.643]                     }, error = function(ex) {
[10:30:50.643]                       msg <- conditionMessage(ex)
[10:30:50.643]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.643]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.643]                         fi_tmp[["mtime"]], msg)
[10:30:50.643]                       ex$message <- msg
[10:30:50.643]                       stop(ex)
[10:30:50.643]                     })
[10:30:50.643]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.643]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.643]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.643]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.643]                       fi <- file.info(pathname)
[10:30:50.643]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.643]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.643]                         fi[["size"]], fi[["mtime"]])
[10:30:50.643]                       stop(msg)
[10:30:50.643]                     }
[10:30:50.643]                     invisible(pathname)
[10:30:50.643]                   }
[10:30:50.643]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.643]                     rootPath = tempdir()) 
[10:30:50.643]                   {
[10:30:50.643]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.643]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.643]                       tmpdir = path, fileext = ".rds")
[10:30:50.643]                     save_rds(obj, file)
[10:30:50.643]                   }
[10:30:50.643]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.643]                   {
[10:30:50.643]                     inherits <- base::inherits
[10:30:50.643]                     invokeRestart <- base::invokeRestart
[10:30:50.643]                     is.null <- base::is.null
[10:30:50.643]                     muffled <- FALSE
[10:30:50.643]                     if (inherits(cond, "message")) {
[10:30:50.643]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.643]                       if (muffled) 
[10:30:50.643]                         invokeRestart("muffleMessage")
[10:30:50.643]                     }
[10:30:50.643]                     else if (inherits(cond, "warning")) {
[10:30:50.643]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.643]                       if (muffled) 
[10:30:50.643]                         invokeRestart("muffleWarning")
[10:30:50.643]                     }
[10:30:50.643]                     else if (inherits(cond, "condition")) {
[10:30:50.643]                       if (!is.null(pattern)) {
[10:30:50.643]                         computeRestarts <- base::computeRestarts
[10:30:50.643]                         grepl <- base::grepl
[10:30:50.643]                         restarts <- computeRestarts(cond)
[10:30:50.643]                         for (restart in restarts) {
[10:30:50.643]                           name <- restart$name
[10:30:50.643]                           if (is.null(name)) 
[10:30:50.643]                             next
[10:30:50.643]                           if (!grepl(pattern, name)) 
[10:30:50.643]                             next
[10:30:50.643]                           invokeRestart(restart)
[10:30:50.643]                           muffled <- TRUE
[10:30:50.643]                           break
[10:30:50.643]                         }
[10:30:50.643]                       }
[10:30:50.643]                     }
[10:30:50.643]                     invisible(muffled)
[10:30:50.643]                   }
[10:30:50.643]                   muffleCondition(cond)
[10:30:50.643]                 })
[10:30:50.643]             }))
[10:30:50.643]             future::FutureResult(value = ...future.value$value, 
[10:30:50.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.643]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.643]                     ...future.globalenv.names))
[10:30:50.643]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.643]         }, condition = base::local({
[10:30:50.643]             c <- base::c
[10:30:50.643]             inherits <- base::inherits
[10:30:50.643]             invokeRestart <- base::invokeRestart
[10:30:50.643]             length <- base::length
[10:30:50.643]             list <- base::list
[10:30:50.643]             seq.int <- base::seq.int
[10:30:50.643]             signalCondition <- base::signalCondition
[10:30:50.643]             sys.calls <- base::sys.calls
[10:30:50.643]             `[[` <- base::`[[`
[10:30:50.643]             `+` <- base::`+`
[10:30:50.643]             `<<-` <- base::`<<-`
[10:30:50.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.643]                   3L)]
[10:30:50.643]             }
[10:30:50.643]             function(cond) {
[10:30:50.643]                 is_error <- inherits(cond, "error")
[10:30:50.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.643]                   NULL)
[10:30:50.643]                 if (is_error) {
[10:30:50.643]                   sessionInformation <- function() {
[10:30:50.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.643]                       search = base::search(), system = base::Sys.info())
[10:30:50.643]                   }
[10:30:50.643]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.643]                     cond$call), session = sessionInformation(), 
[10:30:50.643]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.643]                   signalCondition(cond)
[10:30:50.643]                 }
[10:30:50.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.643]                 "immediateCondition"))) {
[10:30:50.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.643]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.643]                   if (TRUE && !signal) {
[10:30:50.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.643]                     {
[10:30:50.643]                       inherits <- base::inherits
[10:30:50.643]                       invokeRestart <- base::invokeRestart
[10:30:50.643]                       is.null <- base::is.null
[10:30:50.643]                       muffled <- FALSE
[10:30:50.643]                       if (inherits(cond, "message")) {
[10:30:50.643]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.643]                         if (muffled) 
[10:30:50.643]                           invokeRestart("muffleMessage")
[10:30:50.643]                       }
[10:30:50.643]                       else if (inherits(cond, "warning")) {
[10:30:50.643]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.643]                         if (muffled) 
[10:30:50.643]                           invokeRestart("muffleWarning")
[10:30:50.643]                       }
[10:30:50.643]                       else if (inherits(cond, "condition")) {
[10:30:50.643]                         if (!is.null(pattern)) {
[10:30:50.643]                           computeRestarts <- base::computeRestarts
[10:30:50.643]                           grepl <- base::grepl
[10:30:50.643]                           restarts <- computeRestarts(cond)
[10:30:50.643]                           for (restart in restarts) {
[10:30:50.643]                             name <- restart$name
[10:30:50.643]                             if (is.null(name)) 
[10:30:50.643]                               next
[10:30:50.643]                             if (!grepl(pattern, name)) 
[10:30:50.643]                               next
[10:30:50.643]                             invokeRestart(restart)
[10:30:50.643]                             muffled <- TRUE
[10:30:50.643]                             break
[10:30:50.643]                           }
[10:30:50.643]                         }
[10:30:50.643]                       }
[10:30:50.643]                       invisible(muffled)
[10:30:50.643]                     }
[10:30:50.643]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.643]                   }
[10:30:50.643]                 }
[10:30:50.643]                 else {
[10:30:50.643]                   if (TRUE) {
[10:30:50.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.643]                     {
[10:30:50.643]                       inherits <- base::inherits
[10:30:50.643]                       invokeRestart <- base::invokeRestart
[10:30:50.643]                       is.null <- base::is.null
[10:30:50.643]                       muffled <- FALSE
[10:30:50.643]                       if (inherits(cond, "message")) {
[10:30:50.643]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.643]                         if (muffled) 
[10:30:50.643]                           invokeRestart("muffleMessage")
[10:30:50.643]                       }
[10:30:50.643]                       else if (inherits(cond, "warning")) {
[10:30:50.643]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.643]                         if (muffled) 
[10:30:50.643]                           invokeRestart("muffleWarning")
[10:30:50.643]                       }
[10:30:50.643]                       else if (inherits(cond, "condition")) {
[10:30:50.643]                         if (!is.null(pattern)) {
[10:30:50.643]                           computeRestarts <- base::computeRestarts
[10:30:50.643]                           grepl <- base::grepl
[10:30:50.643]                           restarts <- computeRestarts(cond)
[10:30:50.643]                           for (restart in restarts) {
[10:30:50.643]                             name <- restart$name
[10:30:50.643]                             if (is.null(name)) 
[10:30:50.643]                               next
[10:30:50.643]                             if (!grepl(pattern, name)) 
[10:30:50.643]                               next
[10:30:50.643]                             invokeRestart(restart)
[10:30:50.643]                             muffled <- TRUE
[10:30:50.643]                             break
[10:30:50.643]                           }
[10:30:50.643]                         }
[10:30:50.643]                       }
[10:30:50.643]                       invisible(muffled)
[10:30:50.643]                     }
[10:30:50.643]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.643]                   }
[10:30:50.643]                 }
[10:30:50.643]             }
[10:30:50.643]         }))
[10:30:50.643]     }, error = function(ex) {
[10:30:50.643]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.643]                 ...future.rng), started = ...future.startTime, 
[10:30:50.643]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.643]             version = "1.8"), class = "FutureResult")
[10:30:50.643]     }, finally = {
[10:30:50.643]         if (!identical(...future.workdir, getwd())) 
[10:30:50.643]             setwd(...future.workdir)
[10:30:50.643]         {
[10:30:50.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.643]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.643]             }
[10:30:50.643]             base::options(...future.oldOptions)
[10:30:50.643]             if (.Platform$OS.type == "windows") {
[10:30:50.643]                 old_names <- names(...future.oldEnvVars)
[10:30:50.643]                 envs <- base::Sys.getenv()
[10:30:50.643]                 names <- names(envs)
[10:30:50.643]                 common <- intersect(names, old_names)
[10:30:50.643]                 added <- setdiff(names, old_names)
[10:30:50.643]                 removed <- setdiff(old_names, names)
[10:30:50.643]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.643]                   envs[common]]
[10:30:50.643]                 NAMES <- toupper(changed)
[10:30:50.643]                 args <- list()
[10:30:50.643]                 for (kk in seq_along(NAMES)) {
[10:30:50.643]                   name <- changed[[kk]]
[10:30:50.643]                   NAME <- NAMES[[kk]]
[10:30:50.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.643]                     next
[10:30:50.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.643]                 }
[10:30:50.643]                 NAMES <- toupper(added)
[10:30:50.643]                 for (kk in seq_along(NAMES)) {
[10:30:50.643]                   name <- added[[kk]]
[10:30:50.643]                   NAME <- NAMES[[kk]]
[10:30:50.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.643]                     next
[10:30:50.643]                   args[[name]] <- ""
[10:30:50.643]                 }
[10:30:50.643]                 NAMES <- toupper(removed)
[10:30:50.643]                 for (kk in seq_along(NAMES)) {
[10:30:50.643]                   name <- removed[[kk]]
[10:30:50.643]                   NAME <- NAMES[[kk]]
[10:30:50.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.643]                     next
[10:30:50.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.643]                 }
[10:30:50.643]                 if (length(args) > 0) 
[10:30:50.643]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.643]             }
[10:30:50.643]             else {
[10:30:50.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.643]             }
[10:30:50.643]             {
[10:30:50.643]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.643]                   0L) {
[10:30:50.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.643]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.643]                   base::options(opts)
[10:30:50.643]                 }
[10:30:50.643]                 {
[10:30:50.643]                   {
[10:30:50.643]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.643]                     NULL
[10:30:50.643]                   }
[10:30:50.643]                   options(future.plan = NULL)
[10:30:50.643]                   if (is.na(NA_character_)) 
[10:30:50.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.643]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.643]                     .init = FALSE)
[10:30:50.643]                 }
[10:30:50.643]             }
[10:30:50.643]         }
[10:30:50.643]     })
[10:30:50.643]     if (TRUE) {
[10:30:50.643]         base::sink(type = "output", split = FALSE)
[10:30:50.643]         if (TRUE) {
[10:30:50.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.643]         }
[10:30:50.643]         else {
[10:30:50.643]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.643]         }
[10:30:50.643]         base::close(...future.stdout)
[10:30:50.643]         ...future.stdout <- NULL
[10:30:50.643]     }
[10:30:50.643]     ...future.result$conditions <- ...future.conditions
[10:30:50.643]     ...future.result$finished <- base::Sys.time()
[10:30:50.643]     ...future.result
[10:30:50.643] }
[10:30:50.645] assign_globals() ...
[10:30:50.645] List of 5
[10:30:50.645]  $ ...future.FUN            :function (C, k)  
[10:30:50.645]  $ MoreArgs                 : list()
[10:30:50.645]  $ ...future.elements_ii    :List of 2
[10:30:50.645]   ..$ :List of 2
[10:30:50.645]   .. ..$ : chr "A"
[10:30:50.645]   .. ..$ : chr "B"
[10:30:50.645]   ..$ :List of 2
[10:30:50.645]   .. ..$ : int 5
[10:30:50.645]   .. ..$ : int 4
[10:30:50.645]  $ ...future.seeds_ii       : NULL
[10:30:50.645]  $ ...future.globals.maxSize: NULL
[10:30:50.645]  - attr(*, "where")=List of 5
[10:30:50.645]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.645]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.645]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.645]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.645]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.645]  - attr(*, "resolved")= logi FALSE
[10:30:50.645]  - attr(*, "total_size")= num 3656
[10:30:50.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.645]  - attr(*, "already-done")= logi TRUE
[10:30:50.651] - reassign environment for ‘...future.FUN’
[10:30:50.651] - copied ‘...future.FUN’ to environment
[10:30:50.651] - copied ‘MoreArgs’ to environment
[10:30:50.651] - copied ‘...future.elements_ii’ to environment
[10:30:50.651] - copied ‘...future.seeds_ii’ to environment
[10:30:50.652] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.652] assign_globals() ... done
[10:30:50.652] requestCore(): workers = 2
[10:30:50.654] MulticoreFuture started
[10:30:50.655] - Launch lazy future ... done
[10:30:50.655] run() for ‘MulticoreFuture’ ... done
[10:30:50.655] Created future:
[10:30:50.655] plan(): Setting new future strategy stack:
[10:30:50.656] List of future strategies:
[10:30:50.656] 1. sequential:
[10:30:50.656]    - args: function (..., envir = parent.frame())
[10:30:50.656]    - tweaked: FALSE
[10:30:50.656]    - call: NULL
[10:30:50.656] plan(): nbrOfWorkers() = 1
[10:30:50.659] plan(): Setting new future strategy stack:
[10:30:50.659] List of future strategies:
[10:30:50.659] 1. multicore:
[10:30:50.659]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.659]    - tweaked: FALSE
[10:30:50.659]    - call: plan(strategy)
[10:30:50.655] MulticoreFuture:
[10:30:50.655] Label: ‘future_.mapply-1’
[10:30:50.655] Expression:
[10:30:50.655] {
[10:30:50.655]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.655]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.655]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.655]         on.exit(options(oopts), add = TRUE)
[10:30:50.655]     }
[10:30:50.655]     {
[10:30:50.655]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.655]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.655]         do.call(mapply, args = args)
[10:30:50.655]     }
[10:30:50.655] }
[10:30:50.655] Lazy evaluation: FALSE
[10:30:50.655] Asynchronous evaluation: TRUE
[10:30:50.655] Local evaluation: TRUE
[10:30:50.655] Environment: R_GlobalEnv
[10:30:50.655] Capture standard output: TRUE
[10:30:50.655] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.655] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.655] Packages: <none>
[10:30:50.655] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.655] Resolved: FALSE
[10:30:50.655] Value: <not collected>
[10:30:50.655] Conditions captured: <none>
[10:30:50.655] Early signaling: FALSE
[10:30:50.655] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.655] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.668] Chunk #1 of 2 ... DONE
[10:30:50.669] Chunk #2 of 2 ...
[10:30:50.669]  - Finding globals in '...' for chunk #2 ...
[10:30:50.669] getGlobalsAndPackages() ...
[10:30:50.670] Searching for globals...
[10:30:50.670] 
[10:30:50.670] Searching for globals ... DONE
[10:30:50.671] - globals: [0] <none>
[10:30:50.671] getGlobalsAndPackages() ... DONE
[10:30:50.671]    + additional globals found: [n=0] 
[10:30:50.671]    + additional namespaces needed: [n=0] 
[10:30:50.664] plan(): nbrOfWorkers() = 2
[10:30:50.671]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:50.677]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:50.677]  - seeds: <none>
[10:30:50.678]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.678] getGlobalsAndPackages() ...
[10:30:50.678] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.678] Resolving globals: FALSE
[10:30:50.679] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[10:30:50.680] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:50.680] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.680] 
[10:30:50.680] getGlobalsAndPackages() ... DONE
[10:30:50.681] run() for ‘Future’ ...
[10:30:50.681] - state: ‘created’
[10:30:50.682] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.687] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.688] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.688]   - Field: ‘label’
[10:30:50.688]   - Field: ‘local’
[10:30:50.688]   - Field: ‘owner’
[10:30:50.689]   - Field: ‘envir’
[10:30:50.689]   - Field: ‘workers’
[10:30:50.689]   - Field: ‘packages’
[10:30:50.689]   - Field: ‘gc’
[10:30:50.689]   - Field: ‘job’
[10:30:50.690]   - Field: ‘conditions’
[10:30:50.690]   - Field: ‘expr’
[10:30:50.690]   - Field: ‘uuid’
[10:30:50.690]   - Field: ‘seed’
[10:30:50.690]   - Field: ‘version’
[10:30:50.691]   - Field: ‘result’
[10:30:50.691]   - Field: ‘asynchronous’
[10:30:50.691]   - Field: ‘calls’
[10:30:50.691]   - Field: ‘globals’
[10:30:50.691]   - Field: ‘stdout’
[10:30:50.691]   - Field: ‘earlySignal’
[10:30:50.692]   - Field: ‘lazy’
[10:30:50.692]   - Field: ‘state’
[10:30:50.692] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.692] - Launch lazy future ...
[10:30:50.692] Packages needed by the future expression (n = 0): <none>
[10:30:50.693] Packages needed by future strategies (n = 0): <none>
[10:30:50.693] {
[10:30:50.693]     {
[10:30:50.693]         {
[10:30:50.693]             ...future.startTime <- base::Sys.time()
[10:30:50.693]             {
[10:30:50.693]                 {
[10:30:50.693]                   {
[10:30:50.693]                     {
[10:30:50.693]                       base::local({
[10:30:50.693]                         has_future <- base::requireNamespace("future", 
[10:30:50.693]                           quietly = TRUE)
[10:30:50.693]                         if (has_future) {
[10:30:50.693]                           ns <- base::getNamespace("future")
[10:30:50.693]                           version <- ns[[".package"]][["version"]]
[10:30:50.693]                           if (is.null(version)) 
[10:30:50.693]                             version <- utils::packageVersion("future")
[10:30:50.693]                         }
[10:30:50.693]                         else {
[10:30:50.693]                           version <- NULL
[10:30:50.693]                         }
[10:30:50.693]                         if (!has_future || version < "1.8.0") {
[10:30:50.693]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.693]                             "", base::R.version$version.string), 
[10:30:50.693]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.693]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.693]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.693]                               "release", "version")], collapse = " "), 
[10:30:50.693]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.693]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.693]                             info)
[10:30:50.693]                           info <- base::paste(info, collapse = "; ")
[10:30:50.693]                           if (!has_future) {
[10:30:50.693]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.693]                               info)
[10:30:50.693]                           }
[10:30:50.693]                           else {
[10:30:50.693]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.693]                               info, version)
[10:30:50.693]                           }
[10:30:50.693]                           base::stop(msg)
[10:30:50.693]                         }
[10:30:50.693]                       })
[10:30:50.693]                     }
[10:30:50.693]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.693]                     base::options(mc.cores = 1L)
[10:30:50.693]                   }
[10:30:50.693]                   ...future.strategy.old <- future::plan("list")
[10:30:50.693]                   options(future.plan = NULL)
[10:30:50.693]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.693]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.693]                 }
[10:30:50.693]                 ...future.workdir <- getwd()
[10:30:50.693]             }
[10:30:50.693]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.693]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.693]         }
[10:30:50.693]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.693]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:50.693]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.693]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.693]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.693]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.693]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.693]             base::names(...future.oldOptions))
[10:30:50.693]     }
[10:30:50.693]     if (FALSE) {
[10:30:50.693]     }
[10:30:50.693]     else {
[10:30:50.693]         if (TRUE) {
[10:30:50.693]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.693]                 open = "w")
[10:30:50.693]         }
[10:30:50.693]         else {
[10:30:50.693]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.693]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.693]         }
[10:30:50.693]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.693]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.693]             base::sink(type = "output", split = FALSE)
[10:30:50.693]             base::close(...future.stdout)
[10:30:50.693]         }, add = TRUE)
[10:30:50.693]     }
[10:30:50.693]     ...future.frame <- base::sys.nframe()
[10:30:50.693]     ...future.conditions <- base::list()
[10:30:50.693]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.693]     if (FALSE) {
[10:30:50.693]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.693]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.693]     }
[10:30:50.693]     ...future.result <- base::tryCatch({
[10:30:50.693]         base::withCallingHandlers({
[10:30:50.693]             ...future.value <- base::withVisible(base::local({
[10:30:50.693]                 withCallingHandlers({
[10:30:50.693]                   {
[10:30:50.693]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.693]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.693]                       ...future.globals.maxSize)) {
[10:30:50.693]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.693]                       on.exit(options(oopts), add = TRUE)
[10:30:50.693]                     }
[10:30:50.693]                     {
[10:30:50.693]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.693]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.693]                         USE.NAMES = FALSE)
[10:30:50.693]                       do.call(mapply, args = args)
[10:30:50.693]                     }
[10:30:50.693]                   }
[10:30:50.693]                 }, immediateCondition = function(cond) {
[10:30:50.693]                   save_rds <- function (object, pathname, ...) 
[10:30:50.693]                   {
[10:30:50.693]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.693]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.693]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.693]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.693]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.693]                         fi_tmp[["mtime"]])
[10:30:50.693]                     }
[10:30:50.693]                     tryCatch({
[10:30:50.693]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.693]                     }, error = function(ex) {
[10:30:50.693]                       msg <- conditionMessage(ex)
[10:30:50.693]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.693]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.693]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.693]                         fi_tmp[["mtime"]], msg)
[10:30:50.693]                       ex$message <- msg
[10:30:50.693]                       stop(ex)
[10:30:50.693]                     })
[10:30:50.693]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.693]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.693]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.693]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.693]                       fi <- file.info(pathname)
[10:30:50.693]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.693]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.693]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.693]                         fi[["size"]], fi[["mtime"]])
[10:30:50.693]                       stop(msg)
[10:30:50.693]                     }
[10:30:50.693]                     invisible(pathname)
[10:30:50.693]                   }
[10:30:50.693]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.693]                     rootPath = tempdir()) 
[10:30:50.693]                   {
[10:30:50.693]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.693]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.693]                       tmpdir = path, fileext = ".rds")
[10:30:50.693]                     save_rds(obj, file)
[10:30:50.693]                   }
[10:30:50.693]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.693]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.693]                   {
[10:30:50.693]                     inherits <- base::inherits
[10:30:50.693]                     invokeRestart <- base::invokeRestart
[10:30:50.693]                     is.null <- base::is.null
[10:30:50.693]                     muffled <- FALSE
[10:30:50.693]                     if (inherits(cond, "message")) {
[10:30:50.693]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.693]                       if (muffled) 
[10:30:50.693]                         invokeRestart("muffleMessage")
[10:30:50.693]                     }
[10:30:50.693]                     else if (inherits(cond, "warning")) {
[10:30:50.693]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.693]                       if (muffled) 
[10:30:50.693]                         invokeRestart("muffleWarning")
[10:30:50.693]                     }
[10:30:50.693]                     else if (inherits(cond, "condition")) {
[10:30:50.693]                       if (!is.null(pattern)) {
[10:30:50.693]                         computeRestarts <- base::computeRestarts
[10:30:50.693]                         grepl <- base::grepl
[10:30:50.693]                         restarts <- computeRestarts(cond)
[10:30:50.693]                         for (restart in restarts) {
[10:30:50.693]                           name <- restart$name
[10:30:50.693]                           if (is.null(name)) 
[10:30:50.693]                             next
[10:30:50.693]                           if (!grepl(pattern, name)) 
[10:30:50.693]                             next
[10:30:50.693]                           invokeRestart(restart)
[10:30:50.693]                           muffled <- TRUE
[10:30:50.693]                           break
[10:30:50.693]                         }
[10:30:50.693]                       }
[10:30:50.693]                     }
[10:30:50.693]                     invisible(muffled)
[10:30:50.693]                   }
[10:30:50.693]                   muffleCondition(cond)
[10:30:50.693]                 })
[10:30:50.693]             }))
[10:30:50.693]             future::FutureResult(value = ...future.value$value, 
[10:30:50.693]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.693]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.693]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.693]                     ...future.globalenv.names))
[10:30:50.693]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.693]         }, condition = base::local({
[10:30:50.693]             c <- base::c
[10:30:50.693]             inherits <- base::inherits
[10:30:50.693]             invokeRestart <- base::invokeRestart
[10:30:50.693]             length <- base::length
[10:30:50.693]             list <- base::list
[10:30:50.693]             seq.int <- base::seq.int
[10:30:50.693]             signalCondition <- base::signalCondition
[10:30:50.693]             sys.calls <- base::sys.calls
[10:30:50.693]             `[[` <- base::`[[`
[10:30:50.693]             `+` <- base::`+`
[10:30:50.693]             `<<-` <- base::`<<-`
[10:30:50.693]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.693]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.693]                   3L)]
[10:30:50.693]             }
[10:30:50.693]             function(cond) {
[10:30:50.693]                 is_error <- inherits(cond, "error")
[10:30:50.693]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.693]                   NULL)
[10:30:50.693]                 if (is_error) {
[10:30:50.693]                   sessionInformation <- function() {
[10:30:50.693]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.693]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.693]                       search = base::search(), system = base::Sys.info())
[10:30:50.693]                   }
[10:30:50.693]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.693]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.693]                     cond$call), session = sessionInformation(), 
[10:30:50.693]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.693]                   signalCondition(cond)
[10:30:50.693]                 }
[10:30:50.693]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.693]                 "immediateCondition"))) {
[10:30:50.693]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.693]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.693]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.693]                   if (TRUE && !signal) {
[10:30:50.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.693]                     {
[10:30:50.693]                       inherits <- base::inherits
[10:30:50.693]                       invokeRestart <- base::invokeRestart
[10:30:50.693]                       is.null <- base::is.null
[10:30:50.693]                       muffled <- FALSE
[10:30:50.693]                       if (inherits(cond, "message")) {
[10:30:50.693]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.693]                         if (muffled) 
[10:30:50.693]                           invokeRestart("muffleMessage")
[10:30:50.693]                       }
[10:30:50.693]                       else if (inherits(cond, "warning")) {
[10:30:50.693]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.693]                         if (muffled) 
[10:30:50.693]                           invokeRestart("muffleWarning")
[10:30:50.693]                       }
[10:30:50.693]                       else if (inherits(cond, "condition")) {
[10:30:50.693]                         if (!is.null(pattern)) {
[10:30:50.693]                           computeRestarts <- base::computeRestarts
[10:30:50.693]                           grepl <- base::grepl
[10:30:50.693]                           restarts <- computeRestarts(cond)
[10:30:50.693]                           for (restart in restarts) {
[10:30:50.693]                             name <- restart$name
[10:30:50.693]                             if (is.null(name)) 
[10:30:50.693]                               next
[10:30:50.693]                             if (!grepl(pattern, name)) 
[10:30:50.693]                               next
[10:30:50.693]                             invokeRestart(restart)
[10:30:50.693]                             muffled <- TRUE
[10:30:50.693]                             break
[10:30:50.693]                           }
[10:30:50.693]                         }
[10:30:50.693]                       }
[10:30:50.693]                       invisible(muffled)
[10:30:50.693]                     }
[10:30:50.693]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.693]                   }
[10:30:50.693]                 }
[10:30:50.693]                 else {
[10:30:50.693]                   if (TRUE) {
[10:30:50.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.693]                     {
[10:30:50.693]                       inherits <- base::inherits
[10:30:50.693]                       invokeRestart <- base::invokeRestart
[10:30:50.693]                       is.null <- base::is.null
[10:30:50.693]                       muffled <- FALSE
[10:30:50.693]                       if (inherits(cond, "message")) {
[10:30:50.693]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.693]                         if (muffled) 
[10:30:50.693]                           invokeRestart("muffleMessage")
[10:30:50.693]                       }
[10:30:50.693]                       else if (inherits(cond, "warning")) {
[10:30:50.693]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.693]                         if (muffled) 
[10:30:50.693]                           invokeRestart("muffleWarning")
[10:30:50.693]                       }
[10:30:50.693]                       else if (inherits(cond, "condition")) {
[10:30:50.693]                         if (!is.null(pattern)) {
[10:30:50.693]                           computeRestarts <- base::computeRestarts
[10:30:50.693]                           grepl <- base::grepl
[10:30:50.693]                           restarts <- computeRestarts(cond)
[10:30:50.693]                           for (restart in restarts) {
[10:30:50.693]                             name <- restart$name
[10:30:50.693]                             if (is.null(name)) 
[10:30:50.693]                               next
[10:30:50.693]                             if (!grepl(pattern, name)) 
[10:30:50.693]                               next
[10:30:50.693]                             invokeRestart(restart)
[10:30:50.693]                             muffled <- TRUE
[10:30:50.693]                             break
[10:30:50.693]                           }
[10:30:50.693]                         }
[10:30:50.693]                       }
[10:30:50.693]                       invisible(muffled)
[10:30:50.693]                     }
[10:30:50.693]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.693]                   }
[10:30:50.693]                 }
[10:30:50.693]             }
[10:30:50.693]         }))
[10:30:50.693]     }, error = function(ex) {
[10:30:50.693]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.693]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.693]                 ...future.rng), started = ...future.startTime, 
[10:30:50.693]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.693]             version = "1.8"), class = "FutureResult")
[10:30:50.693]     }, finally = {
[10:30:50.693]         if (!identical(...future.workdir, getwd())) 
[10:30:50.693]             setwd(...future.workdir)
[10:30:50.693]         {
[10:30:50.693]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.693]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.693]             }
[10:30:50.693]             base::options(...future.oldOptions)
[10:30:50.693]             if (.Platform$OS.type == "windows") {
[10:30:50.693]                 old_names <- names(...future.oldEnvVars)
[10:30:50.693]                 envs <- base::Sys.getenv()
[10:30:50.693]                 names <- names(envs)
[10:30:50.693]                 common <- intersect(names, old_names)
[10:30:50.693]                 added <- setdiff(names, old_names)
[10:30:50.693]                 removed <- setdiff(old_names, names)
[10:30:50.693]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.693]                   envs[common]]
[10:30:50.693]                 NAMES <- toupper(changed)
[10:30:50.693]                 args <- list()
[10:30:50.693]                 for (kk in seq_along(NAMES)) {
[10:30:50.693]                   name <- changed[[kk]]
[10:30:50.693]                   NAME <- NAMES[[kk]]
[10:30:50.693]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.693]                     next
[10:30:50.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.693]                 }
[10:30:50.693]                 NAMES <- toupper(added)
[10:30:50.693]                 for (kk in seq_along(NAMES)) {
[10:30:50.693]                   name <- added[[kk]]
[10:30:50.693]                   NAME <- NAMES[[kk]]
[10:30:50.693]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.693]                     next
[10:30:50.693]                   args[[name]] <- ""
[10:30:50.693]                 }
[10:30:50.693]                 NAMES <- toupper(removed)
[10:30:50.693]                 for (kk in seq_along(NAMES)) {
[10:30:50.693]                   name <- removed[[kk]]
[10:30:50.693]                   NAME <- NAMES[[kk]]
[10:30:50.693]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.693]                     next
[10:30:50.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.693]                 }
[10:30:50.693]                 if (length(args) > 0) 
[10:30:50.693]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.693]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.693]             }
[10:30:50.693]             else {
[10:30:50.693]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.693]             }
[10:30:50.693]             {
[10:30:50.693]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.693]                   0L) {
[10:30:50.693]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.693]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.693]                   base::options(opts)
[10:30:50.693]                 }
[10:30:50.693]                 {
[10:30:50.693]                   {
[10:30:50.693]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.693]                     NULL
[10:30:50.693]                   }
[10:30:50.693]                   options(future.plan = NULL)
[10:30:50.693]                   if (is.na(NA_character_)) 
[10:30:50.693]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.693]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.693]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.693]                     .init = FALSE)
[10:30:50.693]                 }
[10:30:50.693]             }
[10:30:50.693]         }
[10:30:50.693]     })
[10:30:50.693]     if (TRUE) {
[10:30:50.693]         base::sink(type = "output", split = FALSE)
[10:30:50.693]         if (TRUE) {
[10:30:50.693]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.693]         }
[10:30:50.693]         else {
[10:30:50.693]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.693]         }
[10:30:50.693]         base::close(...future.stdout)
[10:30:50.693]         ...future.stdout <- NULL
[10:30:50.693]     }
[10:30:50.693]     ...future.result$conditions <- ...future.conditions
[10:30:50.693]     ...future.result$finished <- base::Sys.time()
[10:30:50.693]     ...future.result
[10:30:50.693] }
[10:30:50.696] assign_globals() ...
[10:30:50.696] List of 5
[10:30:50.696]  $ ...future.FUN            :function (C, k)  
[10:30:50.696]  $ MoreArgs                 : list()
[10:30:50.696]  $ ...future.elements_ii    :List of 2
[10:30:50.696]   ..$ :List of 3
[10:30:50.696]   .. ..$ : chr "C"
[10:30:50.696]   .. ..$ : chr "D"
[10:30:50.696]   .. ..$ : chr "E"
[10:30:50.696]   ..$ :List of 3
[10:30:50.696]   .. ..$ : int 3
[10:30:50.696]   .. ..$ : int 2
[10:30:50.696]   .. ..$ : int 1
[10:30:50.696]  $ ...future.seeds_ii       : NULL
[10:30:50.696]  $ ...future.globals.maxSize: NULL
[10:30:50.696]  - attr(*, "where")=List of 5
[10:30:50.696]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.696]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.696]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.696]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.696]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.696]  - attr(*, "resolved")= logi FALSE
[10:30:50.696]  - attr(*, "total_size")= num 3824
[10:30:50.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.696]  - attr(*, "already-done")= logi TRUE
[10:30:50.704] - reassign environment for ‘...future.FUN’
[10:30:50.704] - copied ‘...future.FUN’ to environment
[10:30:50.704] - copied ‘MoreArgs’ to environment
[10:30:50.704] - copied ‘...future.elements_ii’ to environment
[10:30:50.705] - copied ‘...future.seeds_ii’ to environment
[10:30:50.705] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.705] assign_globals() ... done
[10:30:50.705] requestCore(): workers = 2
[10:30:50.707] MulticoreFuture started
[10:30:50.708] - Launch lazy future ... done
[10:30:50.708] run() for ‘MulticoreFuture’ ... done
[10:30:50.708] Created future:
[10:30:50.709] plan(): Setting new future strategy stack:
[10:30:50.709] List of future strategies:
[10:30:50.709] 1. sequential:
[10:30:50.709]    - args: function (..., envir = parent.frame())
[10:30:50.709]    - tweaked: FALSE
[10:30:50.709]    - call: NULL
[10:30:50.710] plan(): nbrOfWorkers() = 1
[10:30:50.712] plan(): Setting new future strategy stack:
[10:30:50.712] List of future strategies:
[10:30:50.712] 1. multicore:
[10:30:50.712]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.712]    - tweaked: FALSE
[10:30:50.712]    - call: plan(strategy)
[10:30:50.718] plan(): nbrOfWorkers() = 2
[10:30:50.709] MulticoreFuture:
[10:30:50.709] Label: ‘future_.mapply-2’
[10:30:50.709] Expression:
[10:30:50.709] {
[10:30:50.709]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.709]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.709]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.709]         on.exit(options(oopts), add = TRUE)
[10:30:50.709]     }
[10:30:50.709]     {
[10:30:50.709]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.709]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.709]         do.call(mapply, args = args)
[10:30:50.709]     }
[10:30:50.709] }
[10:30:50.709] Lazy evaluation: FALSE
[10:30:50.709] Asynchronous evaluation: TRUE
[10:30:50.709] Local evaluation: TRUE
[10:30:50.709] Environment: R_GlobalEnv
[10:30:50.709] Capture standard output: TRUE
[10:30:50.709] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.709] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.709] Packages: <none>
[10:30:50.709] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.709] Resolved: TRUE
[10:30:50.709] Value: <not collected>
[10:30:50.709] Conditions captured: <none>
[10:30:50.709] Early signaling: FALSE
[10:30:50.709] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.709] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.719] Chunk #2 of 2 ... DONE
[10:30:50.719] Launching 2 futures (chunks) ... DONE
[10:30:50.719] Resolving 2 futures (chunks) ...
[10:30:50.719] resolve() on list ...
[10:30:50.720]  recursive: 0
[10:30:50.720]  length: 2
[10:30:50.720] 
[10:30:50.720] Future #1
[10:30:50.720] result() for MulticoreFuture ...
[10:30:50.721] result() for MulticoreFuture ...
[10:30:50.722] result() for MulticoreFuture ... done
[10:30:50.722] result() for MulticoreFuture ... done
[10:30:50.722] result() for MulticoreFuture ...
[10:30:50.722] result() for MulticoreFuture ... done
[10:30:50.722] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:50.723] - nx: 2
[10:30:50.723] - relay: TRUE
[10:30:50.723] - stdout: TRUE
[10:30:50.723] - signal: TRUE
[10:30:50.723] - resignal: FALSE
[10:30:50.724] - force: TRUE
[10:30:50.728] - relayed: [n=2] FALSE, FALSE
[10:30:50.729] - queued futures: [n=2] FALSE, FALSE
[10:30:50.729]  - until=1
[10:30:50.730]  - relaying element #1
[10:30:50.730] result() for MulticoreFuture ...
[10:30:50.730] result() for MulticoreFuture ... done
[10:30:50.731] result() for MulticoreFuture ...
[10:30:50.731] result() for MulticoreFuture ... done
[10:30:50.731] result() for MulticoreFuture ...
[10:30:50.732] result() for MulticoreFuture ... done
[10:30:50.732] result() for MulticoreFuture ...
[10:30:50.732] result() for MulticoreFuture ... done
[10:30:50.733] - relayed: [n=2] TRUE, FALSE
[10:30:50.733] - queued futures: [n=2] TRUE, FALSE
[10:30:50.733] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:50.733]  length: 1 (resolved future 1)
[10:30:50.734] Future #2
[10:30:50.734] result() for MulticoreFuture ...
[10:30:50.735] result() for MulticoreFuture ...
[10:30:50.736] result() for MulticoreFuture ... done
[10:30:50.736] result() for MulticoreFuture ... done
[10:30:50.736] result() for MulticoreFuture ...
[10:30:50.736] result() for MulticoreFuture ... done
[10:30:50.736] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:50.737] - nx: 2
[10:30:50.737] - relay: TRUE
[10:30:50.737] - stdout: TRUE
[10:30:50.737] - signal: TRUE
[10:30:50.737] - resignal: FALSE
[10:30:50.737] - force: TRUE
[10:30:50.738] - relayed: [n=2] TRUE, FALSE
[10:30:50.738] - queued futures: [n=2] TRUE, FALSE
[10:30:50.738]  - until=2
[10:30:50.738]  - relaying element #2
[10:30:50.738] result() for MulticoreFuture ...
[10:30:50.738] result() for MulticoreFuture ... done
[10:30:50.739] result() for MulticoreFuture ...
[10:30:50.739] result() for MulticoreFuture ... done
[10:30:50.739] result() for MulticoreFuture ...
[10:30:50.739] result() for MulticoreFuture ... done
[10:30:50.739] result() for MulticoreFuture ...
[10:30:50.739] result() for MulticoreFuture ... done
[10:30:50.740] - relayed: [n=2] TRUE, TRUE
[10:30:50.740] - queued futures: [n=2] TRUE, TRUE
[10:30:50.740] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:50.740]  length: 0 (resolved future 2)
[10:30:50.740] Relaying remaining futures
[10:30:50.741] signalConditionsASAP(NULL, pos=0) ...
[10:30:50.741] - nx: 2
[10:30:50.741] - relay: TRUE
[10:30:50.741] - stdout: TRUE
[10:30:50.741] - signal: TRUE
[10:30:50.741] - resignal: FALSE
[10:30:50.742] - force: TRUE
[10:30:50.742] - relayed: [n=2] TRUE, TRUE
[10:30:50.742] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:50.742] - relayed: [n=2] TRUE, TRUE
[10:30:50.742] - queued futures: [n=2] TRUE, TRUE
[10:30:50.742] signalConditionsASAP(NULL, pos=0) ... done
[10:30:50.742] resolve() on list ... DONE
[10:30:50.743] result() for MulticoreFuture ...
[10:30:50.743] result() for MulticoreFuture ... done
[10:30:50.743] result() for MulticoreFuture ...
[10:30:50.743] result() for MulticoreFuture ... done
[10:30:50.743] result() for MulticoreFuture ...
[10:30:50.743] result() for MulticoreFuture ... done
[10:30:50.744] result() for MulticoreFuture ...
[10:30:50.744] result() for MulticoreFuture ... done
[10:30:50.744]  - Number of value chunks collected: 2
[10:30:50.744] Resolving 2 futures (chunks) ... DONE
[10:30:50.744] Reducing values from 2 chunks ...
[10:30:50.744]  - Number of values collected after concatenation: 5
[10:30:50.745]  - Number of values expected: 5
[10:30:50.745] Reducing values from 2 chunks ... DONE
[10:30:50.745] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[10:30:50.746] future_mapply() ...
[10:30:50.751] Number of chunks: 1
[10:30:50.751] getGlobalsAndPackagesXApply() ...
[10:30:50.751]  - future.globals: TRUE
[10:30:50.751] getGlobalsAndPackages() ...
[10:30:50.751] Searching for globals...
[10:30:50.753] - globals found: [1] ‘FUN’
[10:30:50.753] Searching for globals ... DONE
[10:30:50.753] Resolving globals: FALSE
[10:30:50.753] The total size of the 1 globals is 848 bytes (848 bytes)
[10:30:50.754] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:30:50.754] - globals: [1] ‘FUN’
[10:30:50.754] 
[10:30:50.754] getGlobalsAndPackages() ... DONE
[10:30:50.754]  - globals found/used: [n=1] ‘FUN’
[10:30:50.754]  - needed namespaces: [n=0] 
[10:30:50.754] Finding globals ... DONE
[10:30:50.754] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:50.755] List of 2
[10:30:50.755]  $ ...future.FUN:function (x)  
[10:30:50.755]  $ MoreArgs     : NULL
[10:30:50.755]  - attr(*, "where")=List of 2
[10:30:50.755]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:50.755]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:50.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.755]  - attr(*, "resolved")= logi FALSE
[10:30:50.755]  - attr(*, "total_size")= num NA
[10:30:50.757] Packages to be attached in all futures: [n=0] 
[10:30:50.758] getGlobalsAndPackagesXApply() ... DONE
[10:30:50.758] Number of futures (= number of chunks): 1
[10:30:50.758] Launching 1 futures (chunks) ...
[10:30:50.758] Chunk #1 of 1 ...
[10:30:50.758]  - Finding globals in '...' for chunk #1 ...
[10:30:50.758] getGlobalsAndPackages() ...
[10:30:50.758] Searching for globals...
[10:30:50.759] 
[10:30:50.759] Searching for globals ... DONE
[10:30:50.759] - globals: [0] <none>
[10:30:50.759] getGlobalsAndPackages() ... DONE
[10:30:50.759]    + additional globals found: [n=0] 
[10:30:50.759]    + additional namespaces needed: [n=0] 
[10:30:50.759]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:50.759]  - seeds: <none>
[10:30:50.759]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.760] getGlobalsAndPackages() ...
[10:30:50.760] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.760] Resolving globals: FALSE
[10:30:50.760] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[10:30:50.761] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:50.761] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.761] 
[10:30:50.761] getGlobalsAndPackages() ... DONE
[10:30:50.761] run() for ‘Future’ ...
[10:30:50.764] - state: ‘created’
[10:30:50.764] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.769] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.769]   - Field: ‘label’
[10:30:50.769]   - Field: ‘local’
[10:30:50.769]   - Field: ‘owner’
[10:30:50.769]   - Field: ‘envir’
[10:30:50.770]   - Field: ‘workers’
[10:30:50.770]   - Field: ‘packages’
[10:30:50.770]   - Field: ‘gc’
[10:30:50.770]   - Field: ‘job’
[10:30:50.770]   - Field: ‘conditions’
[10:30:50.770]   - Field: ‘expr’
[10:30:50.770]   - Field: ‘uuid’
[10:30:50.770]   - Field: ‘seed’
[10:30:50.771]   - Field: ‘version’
[10:30:50.771]   - Field: ‘result’
[10:30:50.771]   - Field: ‘asynchronous’
[10:30:50.771]   - Field: ‘calls’
[10:30:50.771]   - Field: ‘globals’
[10:30:50.771]   - Field: ‘stdout’
[10:30:50.771]   - Field: ‘earlySignal’
[10:30:50.771]   - Field: ‘lazy’
[10:30:50.772]   - Field: ‘state’
[10:30:50.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.772] - Launch lazy future ...
[10:30:50.772] Packages needed by the future expression (n = 0): <none>
[10:30:50.772] Packages needed by future strategies (n = 0): <none>
[10:30:50.773] {
[10:30:50.773]     {
[10:30:50.773]         {
[10:30:50.773]             ...future.startTime <- base::Sys.time()
[10:30:50.773]             {
[10:30:50.773]                 {
[10:30:50.773]                   {
[10:30:50.773]                     {
[10:30:50.773]                       base::local({
[10:30:50.773]                         has_future <- base::requireNamespace("future", 
[10:30:50.773]                           quietly = TRUE)
[10:30:50.773]                         if (has_future) {
[10:30:50.773]                           ns <- base::getNamespace("future")
[10:30:50.773]                           version <- ns[[".package"]][["version"]]
[10:30:50.773]                           if (is.null(version)) 
[10:30:50.773]                             version <- utils::packageVersion("future")
[10:30:50.773]                         }
[10:30:50.773]                         else {
[10:30:50.773]                           version <- NULL
[10:30:50.773]                         }
[10:30:50.773]                         if (!has_future || version < "1.8.0") {
[10:30:50.773]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.773]                             "", base::R.version$version.string), 
[10:30:50.773]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.773]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.773]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.773]                               "release", "version")], collapse = " "), 
[10:30:50.773]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.773]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.773]                             info)
[10:30:50.773]                           info <- base::paste(info, collapse = "; ")
[10:30:50.773]                           if (!has_future) {
[10:30:50.773]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.773]                               info)
[10:30:50.773]                           }
[10:30:50.773]                           else {
[10:30:50.773]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.773]                               info, version)
[10:30:50.773]                           }
[10:30:50.773]                           base::stop(msg)
[10:30:50.773]                         }
[10:30:50.773]                       })
[10:30:50.773]                     }
[10:30:50.773]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.773]                     base::options(mc.cores = 1L)
[10:30:50.773]                   }
[10:30:50.773]                   ...future.strategy.old <- future::plan("list")
[10:30:50.773]                   options(future.plan = NULL)
[10:30:50.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.773]                 }
[10:30:50.773]                 ...future.workdir <- getwd()
[10:30:50.773]             }
[10:30:50.773]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.773]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.773]         }
[10:30:50.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.773]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:50.773]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.773]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.773]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.773]             base::names(...future.oldOptions))
[10:30:50.773]     }
[10:30:50.773]     if (FALSE) {
[10:30:50.773]     }
[10:30:50.773]     else {
[10:30:50.773]         if (TRUE) {
[10:30:50.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.773]                 open = "w")
[10:30:50.773]         }
[10:30:50.773]         else {
[10:30:50.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.773]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.773]         }
[10:30:50.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.773]             base::sink(type = "output", split = FALSE)
[10:30:50.773]             base::close(...future.stdout)
[10:30:50.773]         }, add = TRUE)
[10:30:50.773]     }
[10:30:50.773]     ...future.frame <- base::sys.nframe()
[10:30:50.773]     ...future.conditions <- base::list()
[10:30:50.773]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.773]     if (FALSE) {
[10:30:50.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.773]     }
[10:30:50.773]     ...future.result <- base::tryCatch({
[10:30:50.773]         base::withCallingHandlers({
[10:30:50.773]             ...future.value <- base::withVisible(base::local({
[10:30:50.773]                 withCallingHandlers({
[10:30:50.773]                   {
[10:30:50.773]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.773]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.773]                       ...future.globals.maxSize)) {
[10:30:50.773]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.773]                       on.exit(options(oopts), add = TRUE)
[10:30:50.773]                     }
[10:30:50.773]                     {
[10:30:50.773]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.773]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.773]                         USE.NAMES = FALSE)
[10:30:50.773]                       do.call(mapply, args = args)
[10:30:50.773]                     }
[10:30:50.773]                   }
[10:30:50.773]                 }, immediateCondition = function(cond) {
[10:30:50.773]                   save_rds <- function (object, pathname, ...) 
[10:30:50.773]                   {
[10:30:50.773]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.773]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.773]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.773]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.773]                         fi_tmp[["mtime"]])
[10:30:50.773]                     }
[10:30:50.773]                     tryCatch({
[10:30:50.773]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.773]                     }, error = function(ex) {
[10:30:50.773]                       msg <- conditionMessage(ex)
[10:30:50.773]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.773]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.773]                         fi_tmp[["mtime"]], msg)
[10:30:50.773]                       ex$message <- msg
[10:30:50.773]                       stop(ex)
[10:30:50.773]                     })
[10:30:50.773]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.773]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.773]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.773]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.773]                       fi <- file.info(pathname)
[10:30:50.773]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.773]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.773]                         fi[["size"]], fi[["mtime"]])
[10:30:50.773]                       stop(msg)
[10:30:50.773]                     }
[10:30:50.773]                     invisible(pathname)
[10:30:50.773]                   }
[10:30:50.773]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.773]                     rootPath = tempdir()) 
[10:30:50.773]                   {
[10:30:50.773]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.773]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.773]                       tmpdir = path, fileext = ".rds")
[10:30:50.773]                     save_rds(obj, file)
[10:30:50.773]                   }
[10:30:50.773]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.773]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.773]                   {
[10:30:50.773]                     inherits <- base::inherits
[10:30:50.773]                     invokeRestart <- base::invokeRestart
[10:30:50.773]                     is.null <- base::is.null
[10:30:50.773]                     muffled <- FALSE
[10:30:50.773]                     if (inherits(cond, "message")) {
[10:30:50.773]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.773]                       if (muffled) 
[10:30:50.773]                         invokeRestart("muffleMessage")
[10:30:50.773]                     }
[10:30:50.773]                     else if (inherits(cond, "warning")) {
[10:30:50.773]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.773]                       if (muffled) 
[10:30:50.773]                         invokeRestart("muffleWarning")
[10:30:50.773]                     }
[10:30:50.773]                     else if (inherits(cond, "condition")) {
[10:30:50.773]                       if (!is.null(pattern)) {
[10:30:50.773]                         computeRestarts <- base::computeRestarts
[10:30:50.773]                         grepl <- base::grepl
[10:30:50.773]                         restarts <- computeRestarts(cond)
[10:30:50.773]                         for (restart in restarts) {
[10:30:50.773]                           name <- restart$name
[10:30:50.773]                           if (is.null(name)) 
[10:30:50.773]                             next
[10:30:50.773]                           if (!grepl(pattern, name)) 
[10:30:50.773]                             next
[10:30:50.773]                           invokeRestart(restart)
[10:30:50.773]                           muffled <- TRUE
[10:30:50.773]                           break
[10:30:50.773]                         }
[10:30:50.773]                       }
[10:30:50.773]                     }
[10:30:50.773]                     invisible(muffled)
[10:30:50.773]                   }
[10:30:50.773]                   muffleCondition(cond)
[10:30:50.773]                 })
[10:30:50.773]             }))
[10:30:50.773]             future::FutureResult(value = ...future.value$value, 
[10:30:50.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.773]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.773]                     ...future.globalenv.names))
[10:30:50.773]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.773]         }, condition = base::local({
[10:30:50.773]             c <- base::c
[10:30:50.773]             inherits <- base::inherits
[10:30:50.773]             invokeRestart <- base::invokeRestart
[10:30:50.773]             length <- base::length
[10:30:50.773]             list <- base::list
[10:30:50.773]             seq.int <- base::seq.int
[10:30:50.773]             signalCondition <- base::signalCondition
[10:30:50.773]             sys.calls <- base::sys.calls
[10:30:50.773]             `[[` <- base::`[[`
[10:30:50.773]             `+` <- base::`+`
[10:30:50.773]             `<<-` <- base::`<<-`
[10:30:50.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.773]                   3L)]
[10:30:50.773]             }
[10:30:50.773]             function(cond) {
[10:30:50.773]                 is_error <- inherits(cond, "error")
[10:30:50.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.773]                   NULL)
[10:30:50.773]                 if (is_error) {
[10:30:50.773]                   sessionInformation <- function() {
[10:30:50.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.773]                       search = base::search(), system = base::Sys.info())
[10:30:50.773]                   }
[10:30:50.773]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.773]                     cond$call), session = sessionInformation(), 
[10:30:50.773]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.773]                   signalCondition(cond)
[10:30:50.773]                 }
[10:30:50.773]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.773]                 "immediateCondition"))) {
[10:30:50.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.773]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.773]                   if (TRUE && !signal) {
[10:30:50.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.773]                     {
[10:30:50.773]                       inherits <- base::inherits
[10:30:50.773]                       invokeRestart <- base::invokeRestart
[10:30:50.773]                       is.null <- base::is.null
[10:30:50.773]                       muffled <- FALSE
[10:30:50.773]                       if (inherits(cond, "message")) {
[10:30:50.773]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.773]                         if (muffled) 
[10:30:50.773]                           invokeRestart("muffleMessage")
[10:30:50.773]                       }
[10:30:50.773]                       else if (inherits(cond, "warning")) {
[10:30:50.773]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.773]                         if (muffled) 
[10:30:50.773]                           invokeRestart("muffleWarning")
[10:30:50.773]                       }
[10:30:50.773]                       else if (inherits(cond, "condition")) {
[10:30:50.773]                         if (!is.null(pattern)) {
[10:30:50.773]                           computeRestarts <- base::computeRestarts
[10:30:50.773]                           grepl <- base::grepl
[10:30:50.773]                           restarts <- computeRestarts(cond)
[10:30:50.773]                           for (restart in restarts) {
[10:30:50.773]                             name <- restart$name
[10:30:50.773]                             if (is.null(name)) 
[10:30:50.773]                               next
[10:30:50.773]                             if (!grepl(pattern, name)) 
[10:30:50.773]                               next
[10:30:50.773]                             invokeRestart(restart)
[10:30:50.773]                             muffled <- TRUE
[10:30:50.773]                             break
[10:30:50.773]                           }
[10:30:50.773]                         }
[10:30:50.773]                       }
[10:30:50.773]                       invisible(muffled)
[10:30:50.773]                     }
[10:30:50.773]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.773]                   }
[10:30:50.773]                 }
[10:30:50.773]                 else {
[10:30:50.773]                   if (TRUE) {
[10:30:50.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.773]                     {
[10:30:50.773]                       inherits <- base::inherits
[10:30:50.773]                       invokeRestart <- base::invokeRestart
[10:30:50.773]                       is.null <- base::is.null
[10:30:50.773]                       muffled <- FALSE
[10:30:50.773]                       if (inherits(cond, "message")) {
[10:30:50.773]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.773]                         if (muffled) 
[10:30:50.773]                           invokeRestart("muffleMessage")
[10:30:50.773]                       }
[10:30:50.773]                       else if (inherits(cond, "warning")) {
[10:30:50.773]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.773]                         if (muffled) 
[10:30:50.773]                           invokeRestart("muffleWarning")
[10:30:50.773]                       }
[10:30:50.773]                       else if (inherits(cond, "condition")) {
[10:30:50.773]                         if (!is.null(pattern)) {
[10:30:50.773]                           computeRestarts <- base::computeRestarts
[10:30:50.773]                           grepl <- base::grepl
[10:30:50.773]                           restarts <- computeRestarts(cond)
[10:30:50.773]                           for (restart in restarts) {
[10:30:50.773]                             name <- restart$name
[10:30:50.773]                             if (is.null(name)) 
[10:30:50.773]                               next
[10:30:50.773]                             if (!grepl(pattern, name)) 
[10:30:50.773]                               next
[10:30:50.773]                             invokeRestart(restart)
[10:30:50.773]                             muffled <- TRUE
[10:30:50.773]                             break
[10:30:50.773]                           }
[10:30:50.773]                         }
[10:30:50.773]                       }
[10:30:50.773]                       invisible(muffled)
[10:30:50.773]                     }
[10:30:50.773]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.773]                   }
[10:30:50.773]                 }
[10:30:50.773]             }
[10:30:50.773]         }))
[10:30:50.773]     }, error = function(ex) {
[10:30:50.773]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.773]                 ...future.rng), started = ...future.startTime, 
[10:30:50.773]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.773]             version = "1.8"), class = "FutureResult")
[10:30:50.773]     }, finally = {
[10:30:50.773]         if (!identical(...future.workdir, getwd())) 
[10:30:50.773]             setwd(...future.workdir)
[10:30:50.773]         {
[10:30:50.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.773]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.773]             }
[10:30:50.773]             base::options(...future.oldOptions)
[10:30:50.773]             if (.Platform$OS.type == "windows") {
[10:30:50.773]                 old_names <- names(...future.oldEnvVars)
[10:30:50.773]                 envs <- base::Sys.getenv()
[10:30:50.773]                 names <- names(envs)
[10:30:50.773]                 common <- intersect(names, old_names)
[10:30:50.773]                 added <- setdiff(names, old_names)
[10:30:50.773]                 removed <- setdiff(old_names, names)
[10:30:50.773]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.773]                   envs[common]]
[10:30:50.773]                 NAMES <- toupper(changed)
[10:30:50.773]                 args <- list()
[10:30:50.773]                 for (kk in seq_along(NAMES)) {
[10:30:50.773]                   name <- changed[[kk]]
[10:30:50.773]                   NAME <- NAMES[[kk]]
[10:30:50.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.773]                     next
[10:30:50.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.773]                 }
[10:30:50.773]                 NAMES <- toupper(added)
[10:30:50.773]                 for (kk in seq_along(NAMES)) {
[10:30:50.773]                   name <- added[[kk]]
[10:30:50.773]                   NAME <- NAMES[[kk]]
[10:30:50.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.773]                     next
[10:30:50.773]                   args[[name]] <- ""
[10:30:50.773]                 }
[10:30:50.773]                 NAMES <- toupper(removed)
[10:30:50.773]                 for (kk in seq_along(NAMES)) {
[10:30:50.773]                   name <- removed[[kk]]
[10:30:50.773]                   NAME <- NAMES[[kk]]
[10:30:50.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.773]                     next
[10:30:50.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.773]                 }
[10:30:50.773]                 if (length(args) > 0) 
[10:30:50.773]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.773]             }
[10:30:50.773]             else {
[10:30:50.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.773]             }
[10:30:50.773]             {
[10:30:50.773]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.773]                   0L) {
[10:30:50.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.773]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.773]                   base::options(opts)
[10:30:50.773]                 }
[10:30:50.773]                 {
[10:30:50.773]                   {
[10:30:50.773]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.773]                     NULL
[10:30:50.773]                   }
[10:30:50.773]                   options(future.plan = NULL)
[10:30:50.773]                   if (is.na(NA_character_)) 
[10:30:50.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.773]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.773]                     .init = FALSE)
[10:30:50.773]                 }
[10:30:50.773]             }
[10:30:50.773]         }
[10:30:50.773]     })
[10:30:50.773]     if (TRUE) {
[10:30:50.773]         base::sink(type = "output", split = FALSE)
[10:30:50.773]         if (TRUE) {
[10:30:50.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.773]         }
[10:30:50.773]         else {
[10:30:50.773]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.773]         }
[10:30:50.773]         base::close(...future.stdout)
[10:30:50.773]         ...future.stdout <- NULL
[10:30:50.773]     }
[10:30:50.773]     ...future.result$conditions <- ...future.conditions
[10:30:50.773]     ...future.result$finished <- base::Sys.time()
[10:30:50.773]     ...future.result
[10:30:50.773] }
[10:30:50.775] assign_globals() ...
[10:30:50.775] List of 5
[10:30:50.775]  $ ...future.FUN            :function (x)  
[10:30:50.775]  $ MoreArgs                 : NULL
[10:30:50.775]  $ ...future.elements_ii    :List of 1
[10:30:50.775]   ..$ :List of 1
[10:30:50.775]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:30:50.775]  $ ...future.seeds_ii       : NULL
[10:30:50.775]  $ ...future.globals.maxSize: NULL
[10:30:50.775]  - attr(*, "where")=List of 5
[10:30:50.775]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.775]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.775]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.775]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.775]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.775]  - attr(*, "resolved")= logi FALSE
[10:30:50.775]  - attr(*, "total_size")= num 1128
[10:30:50.775]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.775]  - attr(*, "already-done")= logi TRUE
[10:30:50.780] - copied ‘...future.FUN’ to environment
[10:30:50.781] - copied ‘MoreArgs’ to environment
[10:30:50.781] - copied ‘...future.elements_ii’ to environment
[10:30:50.781] - copied ‘...future.seeds_ii’ to environment
[10:30:50.781] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.781] assign_globals() ... done
[10:30:50.781] requestCore(): workers = 2
[10:30:50.783] MulticoreFuture started
[10:30:50.784] - Launch lazy future ... done
[10:30:50.784] run() for ‘MulticoreFuture’ ... done
[10:30:50.784] Created future:
[10:30:50.785] plan(): Setting new future strategy stack:
[10:30:50.785] List of future strategies:
[10:30:50.785] 1. sequential:
[10:30:50.785]    - args: function (..., envir = parent.frame())
[10:30:50.785]    - tweaked: FALSE
[10:30:50.785]    - call: NULL
[10:30:50.786] plan(): nbrOfWorkers() = 1
[10:30:50.788] plan(): Setting new future strategy stack:
[10:30:50.788] List of future strategies:
[10:30:50.788] 1. multicore:
[10:30:50.788]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.788]    - tweaked: FALSE
[10:30:50.788]    - call: plan(strategy)
[10:30:50.793] plan(): nbrOfWorkers() = 2
[10:30:50.784] MulticoreFuture:
[10:30:50.784] Label: ‘future_mapply-1’
[10:30:50.784] Expression:
[10:30:50.784] {
[10:30:50.784]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.784]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.784]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.784]         on.exit(options(oopts), add = TRUE)
[10:30:50.784]     }
[10:30:50.784]     {
[10:30:50.784]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.784]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.784]         do.call(mapply, args = args)
[10:30:50.784]     }
[10:30:50.784] }
[10:30:50.784] Lazy evaluation: FALSE
[10:30:50.784] Asynchronous evaluation: TRUE
[10:30:50.784] Local evaluation: TRUE
[10:30:50.784] Environment: R_GlobalEnv
[10:30:50.784] Capture standard output: TRUE
[10:30:50.784] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.784] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.784] Packages: <none>
[10:30:50.784] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.784] Resolved: TRUE
[10:30:50.784] Value: <not collected>
[10:30:50.784] Conditions captured: <none>
[10:30:50.784] Early signaling: FALSE
[10:30:50.784] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.784] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.794] Chunk #1 of 1 ... DONE
[10:30:50.794] Launching 1 futures (chunks) ... DONE
[10:30:50.795] Resolving 1 futures (chunks) ...
[10:30:50.795] resolve() on list ...
[10:30:50.795]  recursive: 0
[10:30:50.795]  length: 1
[10:30:50.795] 
[10:30:50.796] Future #1
[10:30:50.796] result() for MulticoreFuture ...
[10:30:50.797] result() for MulticoreFuture ...
[10:30:50.797] result() for MulticoreFuture ... done
[10:30:50.797] result() for MulticoreFuture ... done
[10:30:50.797] result() for MulticoreFuture ...
[10:30:50.797] result() for MulticoreFuture ... done
[10:30:50.798] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:50.798] - nx: 1
[10:30:50.798] - relay: TRUE
[10:30:50.798] - stdout: TRUE
[10:30:50.798] - signal: TRUE
[10:30:50.798] - resignal: FALSE
[10:30:50.798] - force: TRUE
[10:30:50.798] - relayed: [n=1] FALSE
[10:30:50.798] - queued futures: [n=1] FALSE
[10:30:50.799]  - until=1
[10:30:50.799]  - relaying element #1
[10:30:50.799] result() for MulticoreFuture ...
[10:30:50.799] result() for MulticoreFuture ... done
[10:30:50.799] result() for MulticoreFuture ...
[10:30:50.799] result() for MulticoreFuture ... done
[10:30:50.799] result() for MulticoreFuture ...
[10:30:50.800] result() for MulticoreFuture ... done
[10:30:50.800] result() for MulticoreFuture ...
[10:30:50.800] result() for MulticoreFuture ... done
[10:30:50.800] - relayed: [n=1] TRUE
[10:30:50.800] - queued futures: [n=1] TRUE
[10:30:50.800] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:50.800]  length: 0 (resolved future 1)
[10:30:50.800] Relaying remaining futures
[10:30:50.800] signalConditionsASAP(NULL, pos=0) ...
[10:30:50.801] - nx: 1
[10:30:50.801] - relay: TRUE
[10:30:50.801] - stdout: TRUE
[10:30:50.801] - signal: TRUE
[10:30:50.801] - resignal: FALSE
[10:30:50.801] - force: TRUE
[10:30:50.801] - relayed: [n=1] TRUE
[10:30:50.801] - queued futures: [n=1] TRUE
 - flush all
[10:30:50.802] - relayed: [n=1] TRUE
[10:30:50.802] - queued futures: [n=1] TRUE
[10:30:50.802] signalConditionsASAP(NULL, pos=0) ... done
[10:30:50.802] resolve() on list ... DONE
[10:30:50.802] result() for MulticoreFuture ...
[10:30:50.802] result() for MulticoreFuture ... done
[10:30:50.802] result() for MulticoreFuture ...
[10:30:50.802] result() for MulticoreFuture ... done
[10:30:50.803]  - Number of value chunks collected: 1
[10:30:50.803] Resolving 1 futures (chunks) ... DONE
[10:30:50.803] Reducing values from 1 chunks ...
[10:30:50.806]  - Number of values collected after concatenation: 1
[10:30:50.806]  - Number of values expected: 1
[10:30:50.806] Reducing values from 1 chunks ... DONE
[10:30:50.806] future_mapply() ... DONE
[10:30:50.807] future_mapply() ...
[10:30:50.811] Number of chunks: 1
[10:30:50.812] getGlobalsAndPackagesXApply() ...
[10:30:50.812]  - future.globals: TRUE
[10:30:50.812] getGlobalsAndPackages() ...
[10:30:50.812] Searching for globals...
[10:30:50.814] - globals found: [1] ‘FUN’
[10:30:50.814] Searching for globals ... DONE
[10:30:50.814] Resolving globals: FALSE
[10:30:50.815] The total size of the 1 globals is 848 bytes (848 bytes)
[10:30:50.815] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:30:50.815] - globals: [1] ‘FUN’
[10:30:50.816] 
[10:30:50.816] getGlobalsAndPackages() ... DONE
[10:30:50.816]  - globals found/used: [n=1] ‘FUN’
[10:30:50.816]  - needed namespaces: [n=0] 
[10:30:50.816] Finding globals ... DONE
[10:30:50.816] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:50.817] List of 2
[10:30:50.817]  $ ...future.FUN:function (x)  
[10:30:50.817]  $ MoreArgs     : list()
[10:30:50.817]  - attr(*, "where")=List of 2
[10:30:50.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:50.817]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:50.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.817]  - attr(*, "resolved")= logi FALSE
[10:30:50.817]  - attr(*, "total_size")= num NA
[10:30:50.820] Packages to be attached in all futures: [n=0] 
[10:30:50.820] getGlobalsAndPackagesXApply() ... DONE
[10:30:50.820] Number of futures (= number of chunks): 1
[10:30:50.821] Launching 1 futures (chunks) ...
[10:30:50.821] Chunk #1 of 1 ...
[10:30:50.821]  - Finding globals in '...' for chunk #1 ...
[10:30:50.821] getGlobalsAndPackages() ...
[10:30:50.821] Searching for globals...
[10:30:50.822] 
[10:30:50.822] Searching for globals ... DONE
[10:30:50.822] - globals: [0] <none>
[10:30:50.822] getGlobalsAndPackages() ... DONE
[10:30:50.822]    + additional globals found: [n=0] 
[10:30:50.822]    + additional namespaces needed: [n=0] 
[10:30:50.822]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:50.822]  - seeds: <none>
[10:30:50.822]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.823] getGlobalsAndPackages() ...
[10:30:50.823] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.823] Resolving globals: FALSE
[10:30:50.823] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[10:30:50.824] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:50.824] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.824] 
[10:30:50.824] getGlobalsAndPackages() ... DONE
[10:30:50.825] run() for ‘Future’ ...
[10:30:50.825] - state: ‘created’
[10:30:50.825] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.829] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.829] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.829]   - Field: ‘label’
[10:30:50.829]   - Field: ‘local’
[10:30:50.829]   - Field: ‘owner’
[10:30:50.829]   - Field: ‘envir’
[10:30:50.829]   - Field: ‘workers’
[10:30:50.830]   - Field: ‘packages’
[10:30:50.830]   - Field: ‘gc’
[10:30:50.830]   - Field: ‘job’
[10:30:50.830]   - Field: ‘conditions’
[10:30:50.830]   - Field: ‘expr’
[10:30:50.830]   - Field: ‘uuid’
[10:30:50.830]   - Field: ‘seed’
[10:30:50.830]   - Field: ‘version’
[10:30:50.830]   - Field: ‘result’
[10:30:50.830]   - Field: ‘asynchronous’
[10:30:50.831]   - Field: ‘calls’
[10:30:50.831]   - Field: ‘globals’
[10:30:50.831]   - Field: ‘stdout’
[10:30:50.831]   - Field: ‘earlySignal’
[10:30:50.831]   - Field: ‘lazy’
[10:30:50.831]   - Field: ‘state’
[10:30:50.831] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.831] - Launch lazy future ...
[10:30:50.831] Packages needed by the future expression (n = 0): <none>
[10:30:50.832] Packages needed by future strategies (n = 0): <none>
[10:30:50.832] {
[10:30:50.832]     {
[10:30:50.832]         {
[10:30:50.832]             ...future.startTime <- base::Sys.time()
[10:30:50.832]             {
[10:30:50.832]                 {
[10:30:50.832]                   {
[10:30:50.832]                     {
[10:30:50.832]                       base::local({
[10:30:50.832]                         has_future <- base::requireNamespace("future", 
[10:30:50.832]                           quietly = TRUE)
[10:30:50.832]                         if (has_future) {
[10:30:50.832]                           ns <- base::getNamespace("future")
[10:30:50.832]                           version <- ns[[".package"]][["version"]]
[10:30:50.832]                           if (is.null(version)) 
[10:30:50.832]                             version <- utils::packageVersion("future")
[10:30:50.832]                         }
[10:30:50.832]                         else {
[10:30:50.832]                           version <- NULL
[10:30:50.832]                         }
[10:30:50.832]                         if (!has_future || version < "1.8.0") {
[10:30:50.832]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.832]                             "", base::R.version$version.string), 
[10:30:50.832]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.832]                               "release", "version")], collapse = " "), 
[10:30:50.832]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.832]                             info)
[10:30:50.832]                           info <- base::paste(info, collapse = "; ")
[10:30:50.832]                           if (!has_future) {
[10:30:50.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.832]                               info)
[10:30:50.832]                           }
[10:30:50.832]                           else {
[10:30:50.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.832]                               info, version)
[10:30:50.832]                           }
[10:30:50.832]                           base::stop(msg)
[10:30:50.832]                         }
[10:30:50.832]                       })
[10:30:50.832]                     }
[10:30:50.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.832]                     base::options(mc.cores = 1L)
[10:30:50.832]                   }
[10:30:50.832]                   ...future.strategy.old <- future::plan("list")
[10:30:50.832]                   options(future.plan = NULL)
[10:30:50.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.832]                 }
[10:30:50.832]                 ...future.workdir <- getwd()
[10:30:50.832]             }
[10:30:50.832]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.832]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.832]         }
[10:30:50.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:50.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.832]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.832]             base::names(...future.oldOptions))
[10:30:50.832]     }
[10:30:50.832]     if (FALSE) {
[10:30:50.832]     }
[10:30:50.832]     else {
[10:30:50.832]         if (TRUE) {
[10:30:50.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.832]                 open = "w")
[10:30:50.832]         }
[10:30:50.832]         else {
[10:30:50.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.832]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.832]         }
[10:30:50.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.832]             base::sink(type = "output", split = FALSE)
[10:30:50.832]             base::close(...future.stdout)
[10:30:50.832]         }, add = TRUE)
[10:30:50.832]     }
[10:30:50.832]     ...future.frame <- base::sys.nframe()
[10:30:50.832]     ...future.conditions <- base::list()
[10:30:50.832]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.832]     if (FALSE) {
[10:30:50.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.832]     }
[10:30:50.832]     ...future.result <- base::tryCatch({
[10:30:50.832]         base::withCallingHandlers({
[10:30:50.832]             ...future.value <- base::withVisible(base::local({
[10:30:50.832]                 withCallingHandlers({
[10:30:50.832]                   {
[10:30:50.832]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.832]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.832]                       ...future.globals.maxSize)) {
[10:30:50.832]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.832]                       on.exit(options(oopts), add = TRUE)
[10:30:50.832]                     }
[10:30:50.832]                     {
[10:30:50.832]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.832]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.832]                         USE.NAMES = FALSE)
[10:30:50.832]                       do.call(mapply, args = args)
[10:30:50.832]                     }
[10:30:50.832]                   }
[10:30:50.832]                 }, immediateCondition = function(cond) {
[10:30:50.832]                   save_rds <- function (object, pathname, ...) 
[10:30:50.832]                   {
[10:30:50.832]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.832]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.832]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.832]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.832]                         fi_tmp[["mtime"]])
[10:30:50.832]                     }
[10:30:50.832]                     tryCatch({
[10:30:50.832]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.832]                     }, error = function(ex) {
[10:30:50.832]                       msg <- conditionMessage(ex)
[10:30:50.832]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.832]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.832]                         fi_tmp[["mtime"]], msg)
[10:30:50.832]                       ex$message <- msg
[10:30:50.832]                       stop(ex)
[10:30:50.832]                     })
[10:30:50.832]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.832]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.832]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.832]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.832]                       fi <- file.info(pathname)
[10:30:50.832]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.832]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.832]                         fi[["size"]], fi[["mtime"]])
[10:30:50.832]                       stop(msg)
[10:30:50.832]                     }
[10:30:50.832]                     invisible(pathname)
[10:30:50.832]                   }
[10:30:50.832]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.832]                     rootPath = tempdir()) 
[10:30:50.832]                   {
[10:30:50.832]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.832]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.832]                       tmpdir = path, fileext = ".rds")
[10:30:50.832]                     save_rds(obj, file)
[10:30:50.832]                   }
[10:30:50.832]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.832]                   {
[10:30:50.832]                     inherits <- base::inherits
[10:30:50.832]                     invokeRestart <- base::invokeRestart
[10:30:50.832]                     is.null <- base::is.null
[10:30:50.832]                     muffled <- FALSE
[10:30:50.832]                     if (inherits(cond, "message")) {
[10:30:50.832]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.832]                       if (muffled) 
[10:30:50.832]                         invokeRestart("muffleMessage")
[10:30:50.832]                     }
[10:30:50.832]                     else if (inherits(cond, "warning")) {
[10:30:50.832]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.832]                       if (muffled) 
[10:30:50.832]                         invokeRestart("muffleWarning")
[10:30:50.832]                     }
[10:30:50.832]                     else if (inherits(cond, "condition")) {
[10:30:50.832]                       if (!is.null(pattern)) {
[10:30:50.832]                         computeRestarts <- base::computeRestarts
[10:30:50.832]                         grepl <- base::grepl
[10:30:50.832]                         restarts <- computeRestarts(cond)
[10:30:50.832]                         for (restart in restarts) {
[10:30:50.832]                           name <- restart$name
[10:30:50.832]                           if (is.null(name)) 
[10:30:50.832]                             next
[10:30:50.832]                           if (!grepl(pattern, name)) 
[10:30:50.832]                             next
[10:30:50.832]                           invokeRestart(restart)
[10:30:50.832]                           muffled <- TRUE
[10:30:50.832]                           break
[10:30:50.832]                         }
[10:30:50.832]                       }
[10:30:50.832]                     }
[10:30:50.832]                     invisible(muffled)
[10:30:50.832]                   }
[10:30:50.832]                   muffleCondition(cond)
[10:30:50.832]                 })
[10:30:50.832]             }))
[10:30:50.832]             future::FutureResult(value = ...future.value$value, 
[10:30:50.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.832]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.832]                     ...future.globalenv.names))
[10:30:50.832]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.832]         }, condition = base::local({
[10:30:50.832]             c <- base::c
[10:30:50.832]             inherits <- base::inherits
[10:30:50.832]             invokeRestart <- base::invokeRestart
[10:30:50.832]             length <- base::length
[10:30:50.832]             list <- base::list
[10:30:50.832]             seq.int <- base::seq.int
[10:30:50.832]             signalCondition <- base::signalCondition
[10:30:50.832]             sys.calls <- base::sys.calls
[10:30:50.832]             `[[` <- base::`[[`
[10:30:50.832]             `+` <- base::`+`
[10:30:50.832]             `<<-` <- base::`<<-`
[10:30:50.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.832]                   3L)]
[10:30:50.832]             }
[10:30:50.832]             function(cond) {
[10:30:50.832]                 is_error <- inherits(cond, "error")
[10:30:50.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.832]                   NULL)
[10:30:50.832]                 if (is_error) {
[10:30:50.832]                   sessionInformation <- function() {
[10:30:50.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.832]                       search = base::search(), system = base::Sys.info())
[10:30:50.832]                   }
[10:30:50.832]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.832]                     cond$call), session = sessionInformation(), 
[10:30:50.832]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.832]                   signalCondition(cond)
[10:30:50.832]                 }
[10:30:50.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.832]                 "immediateCondition"))) {
[10:30:50.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.832]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.832]                   if (TRUE && !signal) {
[10:30:50.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.832]                     {
[10:30:50.832]                       inherits <- base::inherits
[10:30:50.832]                       invokeRestart <- base::invokeRestart
[10:30:50.832]                       is.null <- base::is.null
[10:30:50.832]                       muffled <- FALSE
[10:30:50.832]                       if (inherits(cond, "message")) {
[10:30:50.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.832]                         if (muffled) 
[10:30:50.832]                           invokeRestart("muffleMessage")
[10:30:50.832]                       }
[10:30:50.832]                       else if (inherits(cond, "warning")) {
[10:30:50.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.832]                         if (muffled) 
[10:30:50.832]                           invokeRestart("muffleWarning")
[10:30:50.832]                       }
[10:30:50.832]                       else if (inherits(cond, "condition")) {
[10:30:50.832]                         if (!is.null(pattern)) {
[10:30:50.832]                           computeRestarts <- base::computeRestarts
[10:30:50.832]                           grepl <- base::grepl
[10:30:50.832]                           restarts <- computeRestarts(cond)
[10:30:50.832]                           for (restart in restarts) {
[10:30:50.832]                             name <- restart$name
[10:30:50.832]                             if (is.null(name)) 
[10:30:50.832]                               next
[10:30:50.832]                             if (!grepl(pattern, name)) 
[10:30:50.832]                               next
[10:30:50.832]                             invokeRestart(restart)
[10:30:50.832]                             muffled <- TRUE
[10:30:50.832]                             break
[10:30:50.832]                           }
[10:30:50.832]                         }
[10:30:50.832]                       }
[10:30:50.832]                       invisible(muffled)
[10:30:50.832]                     }
[10:30:50.832]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.832]                   }
[10:30:50.832]                 }
[10:30:50.832]                 else {
[10:30:50.832]                   if (TRUE) {
[10:30:50.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.832]                     {
[10:30:50.832]                       inherits <- base::inherits
[10:30:50.832]                       invokeRestart <- base::invokeRestart
[10:30:50.832]                       is.null <- base::is.null
[10:30:50.832]                       muffled <- FALSE
[10:30:50.832]                       if (inherits(cond, "message")) {
[10:30:50.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.832]                         if (muffled) 
[10:30:50.832]                           invokeRestart("muffleMessage")
[10:30:50.832]                       }
[10:30:50.832]                       else if (inherits(cond, "warning")) {
[10:30:50.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.832]                         if (muffled) 
[10:30:50.832]                           invokeRestart("muffleWarning")
[10:30:50.832]                       }
[10:30:50.832]                       else if (inherits(cond, "condition")) {
[10:30:50.832]                         if (!is.null(pattern)) {
[10:30:50.832]                           computeRestarts <- base::computeRestarts
[10:30:50.832]                           grepl <- base::grepl
[10:30:50.832]                           restarts <- computeRestarts(cond)
[10:30:50.832]                           for (restart in restarts) {
[10:30:50.832]                             name <- restart$name
[10:30:50.832]                             if (is.null(name)) 
[10:30:50.832]                               next
[10:30:50.832]                             if (!grepl(pattern, name)) 
[10:30:50.832]                               next
[10:30:50.832]                             invokeRestart(restart)
[10:30:50.832]                             muffled <- TRUE
[10:30:50.832]                             break
[10:30:50.832]                           }
[10:30:50.832]                         }
[10:30:50.832]                       }
[10:30:50.832]                       invisible(muffled)
[10:30:50.832]                     }
[10:30:50.832]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.832]                   }
[10:30:50.832]                 }
[10:30:50.832]             }
[10:30:50.832]         }))
[10:30:50.832]     }, error = function(ex) {
[10:30:50.832]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.832]                 ...future.rng), started = ...future.startTime, 
[10:30:50.832]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.832]             version = "1.8"), class = "FutureResult")
[10:30:50.832]     }, finally = {
[10:30:50.832]         if (!identical(...future.workdir, getwd())) 
[10:30:50.832]             setwd(...future.workdir)
[10:30:50.832]         {
[10:30:50.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.832]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.832]             }
[10:30:50.832]             base::options(...future.oldOptions)
[10:30:50.832]             if (.Platform$OS.type == "windows") {
[10:30:50.832]                 old_names <- names(...future.oldEnvVars)
[10:30:50.832]                 envs <- base::Sys.getenv()
[10:30:50.832]                 names <- names(envs)
[10:30:50.832]                 common <- intersect(names, old_names)
[10:30:50.832]                 added <- setdiff(names, old_names)
[10:30:50.832]                 removed <- setdiff(old_names, names)
[10:30:50.832]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.832]                   envs[common]]
[10:30:50.832]                 NAMES <- toupper(changed)
[10:30:50.832]                 args <- list()
[10:30:50.832]                 for (kk in seq_along(NAMES)) {
[10:30:50.832]                   name <- changed[[kk]]
[10:30:50.832]                   NAME <- NAMES[[kk]]
[10:30:50.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.832]                     next
[10:30:50.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.832]                 }
[10:30:50.832]                 NAMES <- toupper(added)
[10:30:50.832]                 for (kk in seq_along(NAMES)) {
[10:30:50.832]                   name <- added[[kk]]
[10:30:50.832]                   NAME <- NAMES[[kk]]
[10:30:50.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.832]                     next
[10:30:50.832]                   args[[name]] <- ""
[10:30:50.832]                 }
[10:30:50.832]                 NAMES <- toupper(removed)
[10:30:50.832]                 for (kk in seq_along(NAMES)) {
[10:30:50.832]                   name <- removed[[kk]]
[10:30:50.832]                   NAME <- NAMES[[kk]]
[10:30:50.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.832]                     next
[10:30:50.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.832]                 }
[10:30:50.832]                 if (length(args) > 0) 
[10:30:50.832]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.832]             }
[10:30:50.832]             else {
[10:30:50.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.832]             }
[10:30:50.832]             {
[10:30:50.832]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.832]                   0L) {
[10:30:50.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.832]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.832]                   base::options(opts)
[10:30:50.832]                 }
[10:30:50.832]                 {
[10:30:50.832]                   {
[10:30:50.832]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.832]                     NULL
[10:30:50.832]                   }
[10:30:50.832]                   options(future.plan = NULL)
[10:30:50.832]                   if (is.na(NA_character_)) 
[10:30:50.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.832]                     .init = FALSE)
[10:30:50.832]                 }
[10:30:50.832]             }
[10:30:50.832]         }
[10:30:50.832]     })
[10:30:50.832]     if (TRUE) {
[10:30:50.832]         base::sink(type = "output", split = FALSE)
[10:30:50.832]         if (TRUE) {
[10:30:50.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.832]         }
[10:30:50.832]         else {
[10:30:50.832]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.832]         }
[10:30:50.832]         base::close(...future.stdout)
[10:30:50.832]         ...future.stdout <- NULL
[10:30:50.832]     }
[10:30:50.832]     ...future.result$conditions <- ...future.conditions
[10:30:50.832]     ...future.result$finished <- base::Sys.time()
[10:30:50.832]     ...future.result
[10:30:50.832] }
[10:30:50.835] assign_globals() ...
[10:30:50.835] List of 5
[10:30:50.835]  $ ...future.FUN            :function (x)  
[10:30:50.835]  $ MoreArgs                 : list()
[10:30:50.835]  $ ...future.elements_ii    :List of 1
[10:30:50.835]   ..$ :List of 1
[10:30:50.835]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:30:50.835]  $ ...future.seeds_ii       : NULL
[10:30:50.835]  $ ...future.globals.maxSize: NULL
[10:30:50.835]  - attr(*, "where")=List of 5
[10:30:50.835]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.835]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.835]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.835]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.835]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.835]  - attr(*, "resolved")= logi FALSE
[10:30:50.835]  - attr(*, "total_size")= num 1128
[10:30:50.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.835]  - attr(*, "already-done")= logi TRUE
[10:30:50.843] - copied ‘...future.FUN’ to environment
[10:30:50.843] - copied ‘MoreArgs’ to environment
[10:30:50.843] - copied ‘...future.elements_ii’ to environment
[10:30:50.843] - copied ‘...future.seeds_ii’ to environment
[10:30:50.843] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.843] assign_globals() ... done
[10:30:50.843] requestCore(): workers = 2
[10:30:50.846] MulticoreFuture started
[10:30:50.847] - Launch lazy future ... done
[10:30:50.847] plan(): Setting new future strategy stack:
[10:30:50.847] run() for ‘MulticoreFuture’ ... done
[10:30:50.848] Created future:
[10:30:50.848] List of future strategies:
[10:30:50.848] 1. sequential:
[10:30:50.848]    - args: function (..., envir = parent.frame())
[10:30:50.848]    - tweaked: FALSE
[10:30:50.848]    - call: NULL
[10:30:50.849] plan(): nbrOfWorkers() = 1
[10:30:50.852] plan(): Setting new future strategy stack:
[10:30:50.853] List of future strategies:
[10:30:50.853] 1. multicore:
[10:30:50.853]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.853]    - tweaked: FALSE
[10:30:50.853]    - call: plan(strategy)
[10:30:50.859] plan(): nbrOfWorkers() = 2
[10:30:50.849] MulticoreFuture:
[10:30:50.849] Label: ‘future_.mapply-1’
[10:30:50.849] Expression:
[10:30:50.849] {
[10:30:50.849]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.849]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.849]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.849]         on.exit(options(oopts), add = TRUE)
[10:30:50.849]     }
[10:30:50.849]     {
[10:30:50.849]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.849]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.849]         do.call(mapply, args = args)
[10:30:50.849]     }
[10:30:50.849] }
[10:30:50.849] Lazy evaluation: FALSE
[10:30:50.849] Asynchronous evaluation: TRUE
[10:30:50.849] Local evaluation: TRUE
[10:30:50.849] Environment: R_GlobalEnv
[10:30:50.849] Capture standard output: TRUE
[10:30:50.849] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.849] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.849] Packages: <none>
[10:30:50.849] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.849] Resolved: TRUE
[10:30:50.849] Value: <not collected>
[10:30:50.849] Conditions captured: <none>
[10:30:50.849] Early signaling: FALSE
[10:30:50.849] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.849] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.861] Chunk #1 of 1 ... DONE
[10:30:50.861] Launching 1 futures (chunks) ... DONE
[10:30:50.861] Resolving 1 futures (chunks) ...
[10:30:50.862] resolve() on list ...
[10:30:50.862]  recursive: 0
[10:30:50.862]  length: 1
[10:30:50.862] 
[10:30:50.862] Future #1
[10:30:50.863] result() for MulticoreFuture ...
[10:30:50.863] result() for MulticoreFuture ...
[10:30:50.864] result() for MulticoreFuture ... done
[10:30:50.864] result() for MulticoreFuture ... done
[10:30:50.864] result() for MulticoreFuture ...
[10:30:50.864] result() for MulticoreFuture ... done
[10:30:50.864] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:50.864] - nx: 1
[10:30:50.865] - relay: TRUE
[10:30:50.865] - stdout: TRUE
[10:30:50.865] - signal: TRUE
[10:30:50.865] - resignal: FALSE
[10:30:50.865] - force: TRUE
[10:30:50.865] - relayed: [n=1] FALSE
[10:30:50.865] - queued futures: [n=1] FALSE
[10:30:50.865]  - until=1
[10:30:50.866]  - relaying element #1
[10:30:50.866] result() for MulticoreFuture ...
[10:30:50.866] result() for MulticoreFuture ... done
[10:30:50.866] result() for MulticoreFuture ...
[10:30:50.866] result() for MulticoreFuture ... done
[10:30:50.866] result() for MulticoreFuture ...
[10:30:50.867] result() for MulticoreFuture ... done
[10:30:50.867] result() for MulticoreFuture ...
[10:30:50.867] result() for MulticoreFuture ... done
[10:30:50.867] - relayed: [n=1] TRUE
[10:30:50.867] - queued futures: [n=1] TRUE
[10:30:50.867] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:50.867]  length: 0 (resolved future 1)
[10:30:50.867] Relaying remaining futures
[10:30:50.868] signalConditionsASAP(NULL, pos=0) ...
[10:30:50.868] - nx: 1
[10:30:50.868] - relay: TRUE
[10:30:50.868] - stdout: TRUE
[10:30:50.868] - signal: TRUE
[10:30:50.868] - resignal: FALSE
[10:30:50.868] - force: TRUE
[10:30:50.868] - relayed: [n=1] TRUE
[10:30:50.868] - queued futures: [n=1] TRUE
 - flush all
[10:30:50.869] - relayed: [n=1] TRUE
[10:30:50.869] - queued futures: [n=1] TRUE
[10:30:50.869] signalConditionsASAP(NULL, pos=0) ... done
[10:30:50.869] resolve() on list ... DONE
[10:30:50.869] result() for MulticoreFuture ...
[10:30:50.869] result() for MulticoreFuture ... done
[10:30:50.869] result() for MulticoreFuture ...
[10:30:50.869] result() for MulticoreFuture ... done
[10:30:50.870]  - Number of value chunks collected: 1
[10:30:50.870] Resolving 1 futures (chunks) ... DONE
[10:30:50.870] Reducing values from 1 chunks ...
[10:30:50.870]  - Number of values collected after concatenation: 1
[10:30:50.870]  - Number of values expected: 1
[10:30:50.870] Reducing values from 1 chunks ... DONE
[10:30:50.870] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[10:30:50.871] future_mapply() ...
[10:30:50.875] Number of chunks: 2
[10:30:50.875] getGlobalsAndPackagesXApply() ...
[10:30:50.875]  - future.globals: TRUE
[10:30:50.875] getGlobalsAndPackages() ...
[10:30:50.875] Searching for globals...
[10:30:50.876] - globals found: [1] ‘FUN’
[10:30:50.877] Searching for globals ... DONE
[10:30:50.877] Resolving globals: FALSE
[10:30:50.877] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[10:30:50.878] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[10:30:50.878] - globals: [1] ‘FUN’
[10:30:50.878] 
[10:30:50.878] getGlobalsAndPackages() ... DONE
[10:30:50.878]  - globals found/used: [n=1] ‘FUN’
[10:30:50.878]  - needed namespaces: [n=0] 
[10:30:50.878] Finding globals ... DONE
[10:30:50.878] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:50.879] List of 2
[10:30:50.879]  $ ...future.FUN:function (x, y)  
[10:30:50.879]  $ MoreArgs     :List of 1
[10:30:50.879]   ..$ y: int [1:2] 3 4
[10:30:50.879]  - attr(*, "where")=List of 2
[10:30:50.879]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:50.879]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:50.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.879]  - attr(*, "resolved")= logi FALSE
[10:30:50.879]  - attr(*, "total_size")= num NA
[10:30:50.885] Packages to be attached in all futures: [n=0] 
[10:30:50.885] getGlobalsAndPackagesXApply() ... DONE
[10:30:50.886] Number of futures (= number of chunks): 2
[10:30:50.886] Launching 2 futures (chunks) ...
[10:30:50.886] Chunk #1 of 2 ...
[10:30:50.886]  - Finding globals in '...' for chunk #1 ...
[10:30:50.886] getGlobalsAndPackages() ...
[10:30:50.886] Searching for globals...
[10:30:50.887] 
[10:30:50.887] Searching for globals ... DONE
[10:30:50.887] - globals: [0] <none>
[10:30:50.887] getGlobalsAndPackages() ... DONE
[10:30:50.887]    + additional globals found: [n=0] 
[10:30:50.887]    + additional namespaces needed: [n=0] 
[10:30:50.888]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:50.888]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:50.888]  - seeds: <none>
[10:30:50.888]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.888] getGlobalsAndPackages() ...
[10:30:50.888] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.888] Resolving globals: FALSE
[10:30:50.889] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[10:30:50.890] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[10:30:50.890] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.890] 
[10:30:50.890] getGlobalsAndPackages() ... DONE
[10:30:50.891] run() for ‘Future’ ...
[10:30:50.891] - state: ‘created’
[10:30:50.891] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.895] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.895] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.895]   - Field: ‘label’
[10:30:50.895]   - Field: ‘local’
[10:30:50.896]   - Field: ‘owner’
[10:30:50.896]   - Field: ‘envir’
[10:30:50.896]   - Field: ‘workers’
[10:30:50.896]   - Field: ‘packages’
[10:30:50.896]   - Field: ‘gc’
[10:30:50.896]   - Field: ‘job’
[10:30:50.896]   - Field: ‘conditions’
[10:30:50.896]   - Field: ‘expr’
[10:30:50.896]   - Field: ‘uuid’
[10:30:50.897]   - Field: ‘seed’
[10:30:50.897]   - Field: ‘version’
[10:30:50.897]   - Field: ‘result’
[10:30:50.897]   - Field: ‘asynchronous’
[10:30:50.897]   - Field: ‘calls’
[10:30:50.897]   - Field: ‘globals’
[10:30:50.897]   - Field: ‘stdout’
[10:30:50.898]   - Field: ‘earlySignal’
[10:30:50.898]   - Field: ‘lazy’
[10:30:50.898]   - Field: ‘state’
[10:30:50.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.898] - Launch lazy future ...
[10:30:50.898] Packages needed by the future expression (n = 0): <none>
[10:30:50.898] Packages needed by future strategies (n = 0): <none>
[10:30:50.899] {
[10:30:50.899]     {
[10:30:50.899]         {
[10:30:50.899]             ...future.startTime <- base::Sys.time()
[10:30:50.899]             {
[10:30:50.899]                 {
[10:30:50.899]                   {
[10:30:50.899]                     {
[10:30:50.899]                       base::local({
[10:30:50.899]                         has_future <- base::requireNamespace("future", 
[10:30:50.899]                           quietly = TRUE)
[10:30:50.899]                         if (has_future) {
[10:30:50.899]                           ns <- base::getNamespace("future")
[10:30:50.899]                           version <- ns[[".package"]][["version"]]
[10:30:50.899]                           if (is.null(version)) 
[10:30:50.899]                             version <- utils::packageVersion("future")
[10:30:50.899]                         }
[10:30:50.899]                         else {
[10:30:50.899]                           version <- NULL
[10:30:50.899]                         }
[10:30:50.899]                         if (!has_future || version < "1.8.0") {
[10:30:50.899]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.899]                             "", base::R.version$version.string), 
[10:30:50.899]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.899]                               "release", "version")], collapse = " "), 
[10:30:50.899]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.899]                             info)
[10:30:50.899]                           info <- base::paste(info, collapse = "; ")
[10:30:50.899]                           if (!has_future) {
[10:30:50.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.899]                               info)
[10:30:50.899]                           }
[10:30:50.899]                           else {
[10:30:50.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.899]                               info, version)
[10:30:50.899]                           }
[10:30:50.899]                           base::stop(msg)
[10:30:50.899]                         }
[10:30:50.899]                       })
[10:30:50.899]                     }
[10:30:50.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.899]                     base::options(mc.cores = 1L)
[10:30:50.899]                   }
[10:30:50.899]                   ...future.strategy.old <- future::plan("list")
[10:30:50.899]                   options(future.plan = NULL)
[10:30:50.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.899]                 }
[10:30:50.899]                 ...future.workdir <- getwd()
[10:30:50.899]             }
[10:30:50.899]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.899]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.899]         }
[10:30:50.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.899]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:50.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.899]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.899]             base::names(...future.oldOptions))
[10:30:50.899]     }
[10:30:50.899]     if (FALSE) {
[10:30:50.899]     }
[10:30:50.899]     else {
[10:30:50.899]         if (TRUE) {
[10:30:50.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.899]                 open = "w")
[10:30:50.899]         }
[10:30:50.899]         else {
[10:30:50.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.899]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.899]         }
[10:30:50.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.899]             base::sink(type = "output", split = FALSE)
[10:30:50.899]             base::close(...future.stdout)
[10:30:50.899]         }, add = TRUE)
[10:30:50.899]     }
[10:30:50.899]     ...future.frame <- base::sys.nframe()
[10:30:50.899]     ...future.conditions <- base::list()
[10:30:50.899]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.899]     if (FALSE) {
[10:30:50.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.899]     }
[10:30:50.899]     ...future.result <- base::tryCatch({
[10:30:50.899]         base::withCallingHandlers({
[10:30:50.899]             ...future.value <- base::withVisible(base::local({
[10:30:50.899]                 withCallingHandlers({
[10:30:50.899]                   {
[10:30:50.899]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.899]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.899]                       ...future.globals.maxSize)) {
[10:30:50.899]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.899]                       on.exit(options(oopts), add = TRUE)
[10:30:50.899]                     }
[10:30:50.899]                     {
[10:30:50.899]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.899]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.899]                         USE.NAMES = FALSE)
[10:30:50.899]                       do.call(mapply, args = args)
[10:30:50.899]                     }
[10:30:50.899]                   }
[10:30:50.899]                 }, immediateCondition = function(cond) {
[10:30:50.899]                   save_rds <- function (object, pathname, ...) 
[10:30:50.899]                   {
[10:30:50.899]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.899]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.899]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.899]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.899]                         fi_tmp[["mtime"]])
[10:30:50.899]                     }
[10:30:50.899]                     tryCatch({
[10:30:50.899]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.899]                     }, error = function(ex) {
[10:30:50.899]                       msg <- conditionMessage(ex)
[10:30:50.899]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.899]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.899]                         fi_tmp[["mtime"]], msg)
[10:30:50.899]                       ex$message <- msg
[10:30:50.899]                       stop(ex)
[10:30:50.899]                     })
[10:30:50.899]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.899]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.899]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.899]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.899]                       fi <- file.info(pathname)
[10:30:50.899]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.899]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.899]                         fi[["size"]], fi[["mtime"]])
[10:30:50.899]                       stop(msg)
[10:30:50.899]                     }
[10:30:50.899]                     invisible(pathname)
[10:30:50.899]                   }
[10:30:50.899]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.899]                     rootPath = tempdir()) 
[10:30:50.899]                   {
[10:30:50.899]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.899]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.899]                       tmpdir = path, fileext = ".rds")
[10:30:50.899]                     save_rds(obj, file)
[10:30:50.899]                   }
[10:30:50.899]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.899]                   {
[10:30:50.899]                     inherits <- base::inherits
[10:30:50.899]                     invokeRestart <- base::invokeRestart
[10:30:50.899]                     is.null <- base::is.null
[10:30:50.899]                     muffled <- FALSE
[10:30:50.899]                     if (inherits(cond, "message")) {
[10:30:50.899]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.899]                       if (muffled) 
[10:30:50.899]                         invokeRestart("muffleMessage")
[10:30:50.899]                     }
[10:30:50.899]                     else if (inherits(cond, "warning")) {
[10:30:50.899]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.899]                       if (muffled) 
[10:30:50.899]                         invokeRestart("muffleWarning")
[10:30:50.899]                     }
[10:30:50.899]                     else if (inherits(cond, "condition")) {
[10:30:50.899]                       if (!is.null(pattern)) {
[10:30:50.899]                         computeRestarts <- base::computeRestarts
[10:30:50.899]                         grepl <- base::grepl
[10:30:50.899]                         restarts <- computeRestarts(cond)
[10:30:50.899]                         for (restart in restarts) {
[10:30:50.899]                           name <- restart$name
[10:30:50.899]                           if (is.null(name)) 
[10:30:50.899]                             next
[10:30:50.899]                           if (!grepl(pattern, name)) 
[10:30:50.899]                             next
[10:30:50.899]                           invokeRestart(restart)
[10:30:50.899]                           muffled <- TRUE
[10:30:50.899]                           break
[10:30:50.899]                         }
[10:30:50.899]                       }
[10:30:50.899]                     }
[10:30:50.899]                     invisible(muffled)
[10:30:50.899]                   }
[10:30:50.899]                   muffleCondition(cond)
[10:30:50.899]                 })
[10:30:50.899]             }))
[10:30:50.899]             future::FutureResult(value = ...future.value$value, 
[10:30:50.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.899]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.899]                     ...future.globalenv.names))
[10:30:50.899]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.899]         }, condition = base::local({
[10:30:50.899]             c <- base::c
[10:30:50.899]             inherits <- base::inherits
[10:30:50.899]             invokeRestart <- base::invokeRestart
[10:30:50.899]             length <- base::length
[10:30:50.899]             list <- base::list
[10:30:50.899]             seq.int <- base::seq.int
[10:30:50.899]             signalCondition <- base::signalCondition
[10:30:50.899]             sys.calls <- base::sys.calls
[10:30:50.899]             `[[` <- base::`[[`
[10:30:50.899]             `+` <- base::`+`
[10:30:50.899]             `<<-` <- base::`<<-`
[10:30:50.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.899]                   3L)]
[10:30:50.899]             }
[10:30:50.899]             function(cond) {
[10:30:50.899]                 is_error <- inherits(cond, "error")
[10:30:50.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.899]                   NULL)
[10:30:50.899]                 if (is_error) {
[10:30:50.899]                   sessionInformation <- function() {
[10:30:50.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.899]                       search = base::search(), system = base::Sys.info())
[10:30:50.899]                   }
[10:30:50.899]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.899]                     cond$call), session = sessionInformation(), 
[10:30:50.899]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.899]                   signalCondition(cond)
[10:30:50.899]                 }
[10:30:50.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.899]                 "immediateCondition"))) {
[10:30:50.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.899]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.899]                   if (TRUE && !signal) {
[10:30:50.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.899]                     {
[10:30:50.899]                       inherits <- base::inherits
[10:30:50.899]                       invokeRestart <- base::invokeRestart
[10:30:50.899]                       is.null <- base::is.null
[10:30:50.899]                       muffled <- FALSE
[10:30:50.899]                       if (inherits(cond, "message")) {
[10:30:50.899]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.899]                         if (muffled) 
[10:30:50.899]                           invokeRestart("muffleMessage")
[10:30:50.899]                       }
[10:30:50.899]                       else if (inherits(cond, "warning")) {
[10:30:50.899]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.899]                         if (muffled) 
[10:30:50.899]                           invokeRestart("muffleWarning")
[10:30:50.899]                       }
[10:30:50.899]                       else if (inherits(cond, "condition")) {
[10:30:50.899]                         if (!is.null(pattern)) {
[10:30:50.899]                           computeRestarts <- base::computeRestarts
[10:30:50.899]                           grepl <- base::grepl
[10:30:50.899]                           restarts <- computeRestarts(cond)
[10:30:50.899]                           for (restart in restarts) {
[10:30:50.899]                             name <- restart$name
[10:30:50.899]                             if (is.null(name)) 
[10:30:50.899]                               next
[10:30:50.899]                             if (!grepl(pattern, name)) 
[10:30:50.899]                               next
[10:30:50.899]                             invokeRestart(restart)
[10:30:50.899]                             muffled <- TRUE
[10:30:50.899]                             break
[10:30:50.899]                           }
[10:30:50.899]                         }
[10:30:50.899]                       }
[10:30:50.899]                       invisible(muffled)
[10:30:50.899]                     }
[10:30:50.899]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.899]                   }
[10:30:50.899]                 }
[10:30:50.899]                 else {
[10:30:50.899]                   if (TRUE) {
[10:30:50.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.899]                     {
[10:30:50.899]                       inherits <- base::inherits
[10:30:50.899]                       invokeRestart <- base::invokeRestart
[10:30:50.899]                       is.null <- base::is.null
[10:30:50.899]                       muffled <- FALSE
[10:30:50.899]                       if (inherits(cond, "message")) {
[10:30:50.899]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.899]                         if (muffled) 
[10:30:50.899]                           invokeRestart("muffleMessage")
[10:30:50.899]                       }
[10:30:50.899]                       else if (inherits(cond, "warning")) {
[10:30:50.899]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.899]                         if (muffled) 
[10:30:50.899]                           invokeRestart("muffleWarning")
[10:30:50.899]                       }
[10:30:50.899]                       else if (inherits(cond, "condition")) {
[10:30:50.899]                         if (!is.null(pattern)) {
[10:30:50.899]                           computeRestarts <- base::computeRestarts
[10:30:50.899]                           grepl <- base::grepl
[10:30:50.899]                           restarts <- computeRestarts(cond)
[10:30:50.899]                           for (restart in restarts) {
[10:30:50.899]                             name <- restart$name
[10:30:50.899]                             if (is.null(name)) 
[10:30:50.899]                               next
[10:30:50.899]                             if (!grepl(pattern, name)) 
[10:30:50.899]                               next
[10:30:50.899]                             invokeRestart(restart)
[10:30:50.899]                             muffled <- TRUE
[10:30:50.899]                             break
[10:30:50.899]                           }
[10:30:50.899]                         }
[10:30:50.899]                       }
[10:30:50.899]                       invisible(muffled)
[10:30:50.899]                     }
[10:30:50.899]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.899]                   }
[10:30:50.899]                 }
[10:30:50.899]             }
[10:30:50.899]         }))
[10:30:50.899]     }, error = function(ex) {
[10:30:50.899]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.899]                 ...future.rng), started = ...future.startTime, 
[10:30:50.899]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.899]             version = "1.8"), class = "FutureResult")
[10:30:50.899]     }, finally = {
[10:30:50.899]         if (!identical(...future.workdir, getwd())) 
[10:30:50.899]             setwd(...future.workdir)
[10:30:50.899]         {
[10:30:50.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.899]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.899]             }
[10:30:50.899]             base::options(...future.oldOptions)
[10:30:50.899]             if (.Platform$OS.type == "windows") {
[10:30:50.899]                 old_names <- names(...future.oldEnvVars)
[10:30:50.899]                 envs <- base::Sys.getenv()
[10:30:50.899]                 names <- names(envs)
[10:30:50.899]                 common <- intersect(names, old_names)
[10:30:50.899]                 added <- setdiff(names, old_names)
[10:30:50.899]                 removed <- setdiff(old_names, names)
[10:30:50.899]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.899]                   envs[common]]
[10:30:50.899]                 NAMES <- toupper(changed)
[10:30:50.899]                 args <- list()
[10:30:50.899]                 for (kk in seq_along(NAMES)) {
[10:30:50.899]                   name <- changed[[kk]]
[10:30:50.899]                   NAME <- NAMES[[kk]]
[10:30:50.899]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.899]                     next
[10:30:50.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.899]                 }
[10:30:50.899]                 NAMES <- toupper(added)
[10:30:50.899]                 for (kk in seq_along(NAMES)) {
[10:30:50.899]                   name <- added[[kk]]
[10:30:50.899]                   NAME <- NAMES[[kk]]
[10:30:50.899]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.899]                     next
[10:30:50.899]                   args[[name]] <- ""
[10:30:50.899]                 }
[10:30:50.899]                 NAMES <- toupper(removed)
[10:30:50.899]                 for (kk in seq_along(NAMES)) {
[10:30:50.899]                   name <- removed[[kk]]
[10:30:50.899]                   NAME <- NAMES[[kk]]
[10:30:50.899]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.899]                     next
[10:30:50.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.899]                 }
[10:30:50.899]                 if (length(args) > 0) 
[10:30:50.899]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.899]             }
[10:30:50.899]             else {
[10:30:50.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.899]             }
[10:30:50.899]             {
[10:30:50.899]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.899]                   0L) {
[10:30:50.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.899]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.899]                   base::options(opts)
[10:30:50.899]                 }
[10:30:50.899]                 {
[10:30:50.899]                   {
[10:30:50.899]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.899]                     NULL
[10:30:50.899]                   }
[10:30:50.899]                   options(future.plan = NULL)
[10:30:50.899]                   if (is.na(NA_character_)) 
[10:30:50.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.899]                     .init = FALSE)
[10:30:50.899]                 }
[10:30:50.899]             }
[10:30:50.899]         }
[10:30:50.899]     })
[10:30:50.899]     if (TRUE) {
[10:30:50.899]         base::sink(type = "output", split = FALSE)
[10:30:50.899]         if (TRUE) {
[10:30:50.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.899]         }
[10:30:50.899]         else {
[10:30:50.899]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.899]         }
[10:30:50.899]         base::close(...future.stdout)
[10:30:50.899]         ...future.stdout <- NULL
[10:30:50.899]     }
[10:30:50.899]     ...future.result$conditions <- ...future.conditions
[10:30:50.899]     ...future.result$finished <- base::Sys.time()
[10:30:50.899]     ...future.result
[10:30:50.899] }
[10:30:50.902] assign_globals() ...
[10:30:50.902] List of 5
[10:30:50.902]  $ ...future.FUN            :function (x, y)  
[10:30:50.902]  $ MoreArgs                 :List of 1
[10:30:50.902]   ..$ y: int [1:2] 3 4
[10:30:50.902]  $ ...future.elements_ii    :List of 1
[10:30:50.902]   ..$ x:List of 1
[10:30:50.902]   .. ..$ : int 1
[10:30:50.902]  $ ...future.seeds_ii       : NULL
[10:30:50.902]  $ ...future.globals.maxSize: NULL
[10:30:50.902]  - attr(*, "where")=List of 5
[10:30:50.902]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.902]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.902]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.902]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.902]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.902]  - attr(*, "resolved")= logi FALSE
[10:30:50.902]  - attr(*, "total_size")= num 1816
[10:30:50.902]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.902]  - attr(*, "already-done")= logi TRUE
[10:30:50.909] - reassign environment for ‘...future.FUN’
[10:30:50.909] - copied ‘...future.FUN’ to environment
[10:30:50.909] - copied ‘MoreArgs’ to environment
[10:30:50.909] - copied ‘...future.elements_ii’ to environment
[10:30:50.909] - copied ‘...future.seeds_ii’ to environment
[10:30:50.909] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.910] assign_globals() ... done
[10:30:50.910] requestCore(): workers = 2
[10:30:50.912] MulticoreFuture started
[10:30:50.912] - Launch lazy future ... done
[10:30:50.913] run() for ‘MulticoreFuture’ ... done
[10:30:50.913] Created future:
[10:30:50.913] plan(): Setting new future strategy stack:
[10:30:50.913] List of future strategies:
[10:30:50.913] 1. sequential:
[10:30:50.913]    - args: function (..., envir = parent.frame())
[10:30:50.913]    - tweaked: FALSE
[10:30:50.913]    - call: NULL
[10:30:50.914] plan(): nbrOfWorkers() = 1
[10:30:50.916] plan(): Setting new future strategy stack:
[10:30:50.916] List of future strategies:
[10:30:50.916] 1. multicore:
[10:30:50.916]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.916]    - tweaked: FALSE
[10:30:50.916]    - call: plan(strategy)
[10:30:50.913] MulticoreFuture:
[10:30:50.913] Label: ‘future_mapply-1’
[10:30:50.913] Expression:
[10:30:50.913] {
[10:30:50.913]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.913]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.913]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.913]         on.exit(options(oopts), add = TRUE)
[10:30:50.913]     }
[10:30:50.913]     {
[10:30:50.913]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.913]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.913]         do.call(mapply, args = args)
[10:30:50.913]     }
[10:30:50.913] }
[10:30:50.913] Lazy evaluation: FALSE
[10:30:50.913] Asynchronous evaluation: TRUE
[10:30:50.913] Local evaluation: TRUE
[10:30:50.913] Environment: R_GlobalEnv
[10:30:50.913] Capture standard output: TRUE
[10:30:50.913] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.913] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.913] Packages: <none>
[10:30:50.913] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.913] Resolved: FALSE
[10:30:50.913] Value: <not collected>
[10:30:50.913] Conditions captured: <none>
[10:30:50.913] Early signaling: FALSE
[10:30:50.913] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.913] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.926] Chunk #1 of 2 ... DONE
[10:30:50.926] Chunk #2 of 2 ...
[10:30:50.926]  - Finding globals in '...' for chunk #2 ...
[10:30:50.926] getGlobalsAndPackages() ...
[10:30:50.926] Searching for globals...
[10:30:50.928] plan(): nbrOfWorkers() = 2
[10:30:50.930] 
[10:30:50.930] Searching for globals ... DONE
[10:30:50.931] - globals: [0] <none>
[10:30:50.931] getGlobalsAndPackages() ... DONE
[10:30:50.931]    + additional globals found: [n=0] 
[10:30:50.931]    + additional namespaces needed: [n=0] 
[10:30:50.932]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:50.932]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:50.932]  - seeds: <none>
[10:30:50.932]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.933] getGlobalsAndPackages() ...
[10:30:50.933] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.933] Resolving globals: FALSE
[10:30:50.935] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[10:30:50.936] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[10:30:50.936] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:50.936] 
[10:30:50.937] getGlobalsAndPackages() ... DONE
[10:30:50.937] run() for ‘Future’ ...
[10:30:50.938] - state: ‘created’
[10:30:50.938] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:50.944] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.944] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:50.944]   - Field: ‘label’
[10:30:50.944]   - Field: ‘local’
[10:30:50.944]   - Field: ‘owner’
[10:30:50.945]   - Field: ‘envir’
[10:30:50.945]   - Field: ‘workers’
[10:30:50.945]   - Field: ‘packages’
[10:30:50.945]   - Field: ‘gc’
[10:30:50.946]   - Field: ‘job’
[10:30:50.946]   - Field: ‘conditions’
[10:30:50.946]   - Field: ‘expr’
[10:30:50.946]   - Field: ‘uuid’
[10:30:50.946]   - Field: ‘seed’
[10:30:50.946]   - Field: ‘version’
[10:30:50.947]   - Field: ‘result’
[10:30:50.947]   - Field: ‘asynchronous’
[10:30:50.947]   - Field: ‘calls’
[10:30:50.947]   - Field: ‘globals’
[10:30:50.947]   - Field: ‘stdout’
[10:30:50.947]   - Field: ‘earlySignal’
[10:30:50.947]   - Field: ‘lazy’
[10:30:50.947]   - Field: ‘state’
[10:30:50.948] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:50.948] - Launch lazy future ...
[10:30:50.948] Packages needed by the future expression (n = 0): <none>
[10:30:50.948] Packages needed by future strategies (n = 0): <none>
[10:30:50.949] {
[10:30:50.949]     {
[10:30:50.949]         {
[10:30:50.949]             ...future.startTime <- base::Sys.time()
[10:30:50.949]             {
[10:30:50.949]                 {
[10:30:50.949]                   {
[10:30:50.949]                     {
[10:30:50.949]                       base::local({
[10:30:50.949]                         has_future <- base::requireNamespace("future", 
[10:30:50.949]                           quietly = TRUE)
[10:30:50.949]                         if (has_future) {
[10:30:50.949]                           ns <- base::getNamespace("future")
[10:30:50.949]                           version <- ns[[".package"]][["version"]]
[10:30:50.949]                           if (is.null(version)) 
[10:30:50.949]                             version <- utils::packageVersion("future")
[10:30:50.949]                         }
[10:30:50.949]                         else {
[10:30:50.949]                           version <- NULL
[10:30:50.949]                         }
[10:30:50.949]                         if (!has_future || version < "1.8.0") {
[10:30:50.949]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:50.949]                             "", base::R.version$version.string), 
[10:30:50.949]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:50.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:50.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:50.949]                               "release", "version")], collapse = " "), 
[10:30:50.949]                             hostname = base::Sys.info()[["nodename"]])
[10:30:50.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:50.949]                             info)
[10:30:50.949]                           info <- base::paste(info, collapse = "; ")
[10:30:50.949]                           if (!has_future) {
[10:30:50.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:50.949]                               info)
[10:30:50.949]                           }
[10:30:50.949]                           else {
[10:30:50.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:50.949]                               info, version)
[10:30:50.949]                           }
[10:30:50.949]                           base::stop(msg)
[10:30:50.949]                         }
[10:30:50.949]                       })
[10:30:50.949]                     }
[10:30:50.949]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:50.949]                     base::options(mc.cores = 1L)
[10:30:50.949]                   }
[10:30:50.949]                   ...future.strategy.old <- future::plan("list")
[10:30:50.949]                   options(future.plan = NULL)
[10:30:50.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:50.949]                 }
[10:30:50.949]                 ...future.workdir <- getwd()
[10:30:50.949]             }
[10:30:50.949]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:50.949]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:50.949]         }
[10:30:50.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:50.949]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:50.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:50.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:50.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:50.949]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:50.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:50.949]             base::names(...future.oldOptions))
[10:30:50.949]     }
[10:30:50.949]     if (FALSE) {
[10:30:50.949]     }
[10:30:50.949]     else {
[10:30:50.949]         if (TRUE) {
[10:30:50.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:50.949]                 open = "w")
[10:30:50.949]         }
[10:30:50.949]         else {
[10:30:50.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:50.949]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:50.949]         }
[10:30:50.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:50.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:50.949]             base::sink(type = "output", split = FALSE)
[10:30:50.949]             base::close(...future.stdout)
[10:30:50.949]         }, add = TRUE)
[10:30:50.949]     }
[10:30:50.949]     ...future.frame <- base::sys.nframe()
[10:30:50.949]     ...future.conditions <- base::list()
[10:30:50.949]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:50.949]     if (FALSE) {
[10:30:50.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:50.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:50.949]     }
[10:30:50.949]     ...future.result <- base::tryCatch({
[10:30:50.949]         base::withCallingHandlers({
[10:30:50.949]             ...future.value <- base::withVisible(base::local({
[10:30:50.949]                 withCallingHandlers({
[10:30:50.949]                   {
[10:30:50.949]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.949]                     if (!identical(...future.globals.maxSize.org, 
[10:30:50.949]                       ...future.globals.maxSize)) {
[10:30:50.949]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.949]                       on.exit(options(oopts), add = TRUE)
[10:30:50.949]                     }
[10:30:50.949]                     {
[10:30:50.949]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.949]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:50.949]                         USE.NAMES = FALSE)
[10:30:50.949]                       do.call(mapply, args = args)
[10:30:50.949]                     }
[10:30:50.949]                   }
[10:30:50.949]                 }, immediateCondition = function(cond) {
[10:30:50.949]                   save_rds <- function (object, pathname, ...) 
[10:30:50.949]                   {
[10:30:50.949]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:50.949]                     if (file_test("-f", pathname_tmp)) {
[10:30:50.949]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.949]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:50.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.949]                         fi_tmp[["mtime"]])
[10:30:50.949]                     }
[10:30:50.949]                     tryCatch({
[10:30:50.949]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:50.949]                     }, error = function(ex) {
[10:30:50.949]                       msg <- conditionMessage(ex)
[10:30:50.949]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.949]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:50.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.949]                         fi_tmp[["mtime"]], msg)
[10:30:50.949]                       ex$message <- msg
[10:30:50.949]                       stop(ex)
[10:30:50.949]                     })
[10:30:50.949]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:50.949]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:50.949]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:50.949]                       fi_tmp <- file.info(pathname_tmp)
[10:30:50.949]                       fi <- file.info(pathname)
[10:30:50.949]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:50.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:50.949]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:50.949]                         fi[["size"]], fi[["mtime"]])
[10:30:50.949]                       stop(msg)
[10:30:50.949]                     }
[10:30:50.949]                     invisible(pathname)
[10:30:50.949]                   }
[10:30:50.949]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:50.949]                     rootPath = tempdir()) 
[10:30:50.949]                   {
[10:30:50.949]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:50.949]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:50.949]                       tmpdir = path, fileext = ".rds")
[10:30:50.949]                     save_rds(obj, file)
[10:30:50.949]                   }
[10:30:50.949]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:50.949]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.949]                   {
[10:30:50.949]                     inherits <- base::inherits
[10:30:50.949]                     invokeRestart <- base::invokeRestart
[10:30:50.949]                     is.null <- base::is.null
[10:30:50.949]                     muffled <- FALSE
[10:30:50.949]                     if (inherits(cond, "message")) {
[10:30:50.949]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:50.949]                       if (muffled) 
[10:30:50.949]                         invokeRestart("muffleMessage")
[10:30:50.949]                     }
[10:30:50.949]                     else if (inherits(cond, "warning")) {
[10:30:50.949]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:50.949]                       if (muffled) 
[10:30:50.949]                         invokeRestart("muffleWarning")
[10:30:50.949]                     }
[10:30:50.949]                     else if (inherits(cond, "condition")) {
[10:30:50.949]                       if (!is.null(pattern)) {
[10:30:50.949]                         computeRestarts <- base::computeRestarts
[10:30:50.949]                         grepl <- base::grepl
[10:30:50.949]                         restarts <- computeRestarts(cond)
[10:30:50.949]                         for (restart in restarts) {
[10:30:50.949]                           name <- restart$name
[10:30:50.949]                           if (is.null(name)) 
[10:30:50.949]                             next
[10:30:50.949]                           if (!grepl(pattern, name)) 
[10:30:50.949]                             next
[10:30:50.949]                           invokeRestart(restart)
[10:30:50.949]                           muffled <- TRUE
[10:30:50.949]                           break
[10:30:50.949]                         }
[10:30:50.949]                       }
[10:30:50.949]                     }
[10:30:50.949]                     invisible(muffled)
[10:30:50.949]                   }
[10:30:50.949]                   muffleCondition(cond)
[10:30:50.949]                 })
[10:30:50.949]             }))
[10:30:50.949]             future::FutureResult(value = ...future.value$value, 
[10:30:50.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.949]                   ...future.rng), globalenv = if (FALSE) 
[10:30:50.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:50.949]                     ...future.globalenv.names))
[10:30:50.949]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:50.949]         }, condition = base::local({
[10:30:50.949]             c <- base::c
[10:30:50.949]             inherits <- base::inherits
[10:30:50.949]             invokeRestart <- base::invokeRestart
[10:30:50.949]             length <- base::length
[10:30:50.949]             list <- base::list
[10:30:50.949]             seq.int <- base::seq.int
[10:30:50.949]             signalCondition <- base::signalCondition
[10:30:50.949]             sys.calls <- base::sys.calls
[10:30:50.949]             `[[` <- base::`[[`
[10:30:50.949]             `+` <- base::`+`
[10:30:50.949]             `<<-` <- base::`<<-`
[10:30:50.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:50.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:50.949]                   3L)]
[10:30:50.949]             }
[10:30:50.949]             function(cond) {
[10:30:50.949]                 is_error <- inherits(cond, "error")
[10:30:50.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:50.949]                   NULL)
[10:30:50.949]                 if (is_error) {
[10:30:50.949]                   sessionInformation <- function() {
[10:30:50.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:50.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:50.949]                       search = base::search(), system = base::Sys.info())
[10:30:50.949]                   }
[10:30:50.949]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:50.949]                     cond$call), session = sessionInformation(), 
[10:30:50.949]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:50.949]                   signalCondition(cond)
[10:30:50.949]                 }
[10:30:50.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:50.949]                 "immediateCondition"))) {
[10:30:50.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:50.949]                   ...future.conditions[[length(...future.conditions) + 
[10:30:50.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:50.949]                   if (TRUE && !signal) {
[10:30:50.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.949]                     {
[10:30:50.949]                       inherits <- base::inherits
[10:30:50.949]                       invokeRestart <- base::invokeRestart
[10:30:50.949]                       is.null <- base::is.null
[10:30:50.949]                       muffled <- FALSE
[10:30:50.949]                       if (inherits(cond, "message")) {
[10:30:50.949]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.949]                         if (muffled) 
[10:30:50.949]                           invokeRestart("muffleMessage")
[10:30:50.949]                       }
[10:30:50.949]                       else if (inherits(cond, "warning")) {
[10:30:50.949]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.949]                         if (muffled) 
[10:30:50.949]                           invokeRestart("muffleWarning")
[10:30:50.949]                       }
[10:30:50.949]                       else if (inherits(cond, "condition")) {
[10:30:50.949]                         if (!is.null(pattern)) {
[10:30:50.949]                           computeRestarts <- base::computeRestarts
[10:30:50.949]                           grepl <- base::grepl
[10:30:50.949]                           restarts <- computeRestarts(cond)
[10:30:50.949]                           for (restart in restarts) {
[10:30:50.949]                             name <- restart$name
[10:30:50.949]                             if (is.null(name)) 
[10:30:50.949]                               next
[10:30:50.949]                             if (!grepl(pattern, name)) 
[10:30:50.949]                               next
[10:30:50.949]                             invokeRestart(restart)
[10:30:50.949]                             muffled <- TRUE
[10:30:50.949]                             break
[10:30:50.949]                           }
[10:30:50.949]                         }
[10:30:50.949]                       }
[10:30:50.949]                       invisible(muffled)
[10:30:50.949]                     }
[10:30:50.949]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.949]                   }
[10:30:50.949]                 }
[10:30:50.949]                 else {
[10:30:50.949]                   if (TRUE) {
[10:30:50.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:50.949]                     {
[10:30:50.949]                       inherits <- base::inherits
[10:30:50.949]                       invokeRestart <- base::invokeRestart
[10:30:50.949]                       is.null <- base::is.null
[10:30:50.949]                       muffled <- FALSE
[10:30:50.949]                       if (inherits(cond, "message")) {
[10:30:50.949]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:50.949]                         if (muffled) 
[10:30:50.949]                           invokeRestart("muffleMessage")
[10:30:50.949]                       }
[10:30:50.949]                       else if (inherits(cond, "warning")) {
[10:30:50.949]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:50.949]                         if (muffled) 
[10:30:50.949]                           invokeRestart("muffleWarning")
[10:30:50.949]                       }
[10:30:50.949]                       else if (inherits(cond, "condition")) {
[10:30:50.949]                         if (!is.null(pattern)) {
[10:30:50.949]                           computeRestarts <- base::computeRestarts
[10:30:50.949]                           grepl <- base::grepl
[10:30:50.949]                           restarts <- computeRestarts(cond)
[10:30:50.949]                           for (restart in restarts) {
[10:30:50.949]                             name <- restart$name
[10:30:50.949]                             if (is.null(name)) 
[10:30:50.949]                               next
[10:30:50.949]                             if (!grepl(pattern, name)) 
[10:30:50.949]                               next
[10:30:50.949]                             invokeRestart(restart)
[10:30:50.949]                             muffled <- TRUE
[10:30:50.949]                             break
[10:30:50.949]                           }
[10:30:50.949]                         }
[10:30:50.949]                       }
[10:30:50.949]                       invisible(muffled)
[10:30:50.949]                     }
[10:30:50.949]                     muffleCondition(cond, pattern = "^muffle")
[10:30:50.949]                   }
[10:30:50.949]                 }
[10:30:50.949]             }
[10:30:50.949]         }))
[10:30:50.949]     }, error = function(ex) {
[10:30:50.949]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:50.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:50.949]                 ...future.rng), started = ...future.startTime, 
[10:30:50.949]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:50.949]             version = "1.8"), class = "FutureResult")
[10:30:50.949]     }, finally = {
[10:30:50.949]         if (!identical(...future.workdir, getwd())) 
[10:30:50.949]             setwd(...future.workdir)
[10:30:50.949]         {
[10:30:50.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:50.949]                 ...future.oldOptions$nwarnings <- NULL
[10:30:50.949]             }
[10:30:50.949]             base::options(...future.oldOptions)
[10:30:50.949]             if (.Platform$OS.type == "windows") {
[10:30:50.949]                 old_names <- names(...future.oldEnvVars)
[10:30:50.949]                 envs <- base::Sys.getenv()
[10:30:50.949]                 names <- names(envs)
[10:30:50.949]                 common <- intersect(names, old_names)
[10:30:50.949]                 added <- setdiff(names, old_names)
[10:30:50.949]                 removed <- setdiff(old_names, names)
[10:30:50.949]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:50.949]                   envs[common]]
[10:30:50.949]                 NAMES <- toupper(changed)
[10:30:50.949]                 args <- list()
[10:30:50.949]                 for (kk in seq_along(NAMES)) {
[10:30:50.949]                   name <- changed[[kk]]
[10:30:50.949]                   NAME <- NAMES[[kk]]
[10:30:50.949]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.949]                     next
[10:30:50.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.949]                 }
[10:30:50.949]                 NAMES <- toupper(added)
[10:30:50.949]                 for (kk in seq_along(NAMES)) {
[10:30:50.949]                   name <- added[[kk]]
[10:30:50.949]                   NAME <- NAMES[[kk]]
[10:30:50.949]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.949]                     next
[10:30:50.949]                   args[[name]] <- ""
[10:30:50.949]                 }
[10:30:50.949]                 NAMES <- toupper(removed)
[10:30:50.949]                 for (kk in seq_along(NAMES)) {
[10:30:50.949]                   name <- removed[[kk]]
[10:30:50.949]                   NAME <- NAMES[[kk]]
[10:30:50.949]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:50.949]                     next
[10:30:50.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:50.949]                 }
[10:30:50.949]                 if (length(args) > 0) 
[10:30:50.949]                   base::do.call(base::Sys.setenv, args = args)
[10:30:50.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:50.949]             }
[10:30:50.949]             else {
[10:30:50.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:50.949]             }
[10:30:50.949]             {
[10:30:50.949]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:50.949]                   0L) {
[10:30:50.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:50.949]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:50.949]                   base::options(opts)
[10:30:50.949]                 }
[10:30:50.949]                 {
[10:30:50.949]                   {
[10:30:50.949]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:50.949]                     NULL
[10:30:50.949]                   }
[10:30:50.949]                   options(future.plan = NULL)
[10:30:50.949]                   if (is.na(NA_character_)) 
[10:30:50.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:50.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:50.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:50.949]                     .init = FALSE)
[10:30:50.949]                 }
[10:30:50.949]             }
[10:30:50.949]         }
[10:30:50.949]     })
[10:30:50.949]     if (TRUE) {
[10:30:50.949]         base::sink(type = "output", split = FALSE)
[10:30:50.949]         if (TRUE) {
[10:30:50.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:50.949]         }
[10:30:50.949]         else {
[10:30:50.949]             ...future.result["stdout"] <- base::list(NULL)
[10:30:50.949]         }
[10:30:50.949]         base::close(...future.stdout)
[10:30:50.949]         ...future.stdout <- NULL
[10:30:50.949]     }
[10:30:50.949]     ...future.result$conditions <- ...future.conditions
[10:30:50.949]     ...future.result$finished <- base::Sys.time()
[10:30:50.949]     ...future.result
[10:30:50.949] }
[10:30:50.952] assign_globals() ...
[10:30:50.952] List of 5
[10:30:50.952]  $ ...future.FUN            :function (x, y)  
[10:30:50.952]  $ MoreArgs                 :List of 1
[10:30:50.952]   ..$ y: int [1:2] 3 4
[10:30:50.952]  $ ...future.elements_ii    :List of 1
[10:30:50.952]   ..$ x:List of 1
[10:30:50.952]   .. ..$ : int 2
[10:30:50.952]  $ ...future.seeds_ii       : NULL
[10:30:50.952]  $ ...future.globals.maxSize: NULL
[10:30:50.952]  - attr(*, "where")=List of 5
[10:30:50.952]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:50.952]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:50.952]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:50.952]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:50.952]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:50.952]  - attr(*, "resolved")= logi FALSE
[10:30:50.952]  - attr(*, "total_size")= num 1816
[10:30:50.952]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:50.952]  - attr(*, "already-done")= logi TRUE
[10:30:50.959] - reassign environment for ‘...future.FUN’
[10:30:50.959] - copied ‘...future.FUN’ to environment
[10:30:50.959] - copied ‘MoreArgs’ to environment
[10:30:50.959] - copied ‘...future.elements_ii’ to environment
[10:30:50.959] - copied ‘...future.seeds_ii’ to environment
[10:30:50.959] - copied ‘...future.globals.maxSize’ to environment
[10:30:50.960] assign_globals() ... done
[10:30:50.960] requestCore(): workers = 2
[10:30:50.962] MulticoreFuture started
[10:30:50.962] - Launch lazy future ... done
[10:30:50.963] run() for ‘MulticoreFuture’ ... done
[10:30:50.963] Created future:
[10:30:50.963] plan(): Setting new future strategy stack:
[10:30:50.963] List of future strategies:
[10:30:50.963] 1. sequential:
[10:30:50.963]    - args: function (..., envir = parent.frame())
[10:30:50.963]    - tweaked: FALSE
[10:30:50.963]    - call: NULL
[10:30:50.964] plan(): nbrOfWorkers() = 1
[10:30:50.966] plan(): Setting new future strategy stack:
[10:30:50.967] List of future strategies:
[10:30:50.967] 1. multicore:
[10:30:50.967]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:50.967]    - tweaked: FALSE
[10:30:50.967]    - call: plan(strategy)
[10:30:50.972] plan(): nbrOfWorkers() = 2
[10:30:50.963] MulticoreFuture:
[10:30:50.963] Label: ‘future_mapply-2’
[10:30:50.963] Expression:
[10:30:50.963] {
[10:30:50.963]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:50.963]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:50.963]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:50.963]         on.exit(options(oopts), add = TRUE)
[10:30:50.963]     }
[10:30:50.963]     {
[10:30:50.963]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:50.963]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:50.963]         do.call(mapply, args = args)
[10:30:50.963]     }
[10:30:50.963] }
[10:30:50.963] Lazy evaluation: FALSE
[10:30:50.963] Asynchronous evaluation: TRUE
[10:30:50.963] Local evaluation: TRUE
[10:30:50.963] Environment: R_GlobalEnv
[10:30:50.963] Capture standard output: TRUE
[10:30:50.963] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:50.963] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:50.963] Packages: <none>
[10:30:50.963] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:50.963] Resolved: TRUE
[10:30:50.963] Value: <not collected>
[10:30:50.963] Conditions captured: <none>
[10:30:50.963] Early signaling: FALSE
[10:30:50.963] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:50.963] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:50.973] Chunk #2 of 2 ... DONE
[10:30:50.974] Launching 2 futures (chunks) ... DONE
[10:30:50.974] Resolving 2 futures (chunks) ...
[10:30:50.974] resolve() on list ...
[10:30:50.974]  recursive: 0
[10:30:50.974]  length: 2
[10:30:50.974] 
[10:30:50.975] Future #1
[10:30:50.975] result() for MulticoreFuture ...
[10:30:50.976] result() for MulticoreFuture ...
[10:30:50.976] result() for MulticoreFuture ... done
[10:30:50.976] result() for MulticoreFuture ... done
[10:30:50.976] result() for MulticoreFuture ...
[10:30:50.976] result() for MulticoreFuture ... done
[10:30:50.977] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:50.977] - nx: 2
[10:30:50.977] - relay: TRUE
[10:30:50.977] - stdout: TRUE
[10:30:50.977] - signal: TRUE
[10:30:50.977] - resignal: FALSE
[10:30:50.977] - force: TRUE
[10:30:50.978] - relayed: [n=2] FALSE, FALSE
[10:30:50.982] - queued futures: [n=2] FALSE, FALSE
[10:30:50.983]  - until=1
[10:30:50.983]  - relaying element #1
[10:30:50.983] result() for MulticoreFuture ...
[10:30:50.984] result() for MulticoreFuture ... done
[10:30:50.984] result() for MulticoreFuture ...
[10:30:50.984] result() for MulticoreFuture ... done
[10:30:50.985] result() for MulticoreFuture ...
[10:30:50.985] result() for MulticoreFuture ... done
[10:30:50.986] result() for MulticoreFuture ...
[10:30:50.986] result() for MulticoreFuture ... done
[10:30:50.986] - relayed: [n=2] TRUE, FALSE
[10:30:50.986] - queued futures: [n=2] TRUE, FALSE
[10:30:50.987] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:50.987]  length: 1 (resolved future 1)
[10:30:50.988] Future #2
[10:30:50.988] result() for MulticoreFuture ...
[10:30:50.989] result() for MulticoreFuture ...
[10:30:50.989] result() for MulticoreFuture ... done
[10:30:50.990] result() for MulticoreFuture ... done
[10:30:50.990] result() for MulticoreFuture ...
[10:30:50.990] result() for MulticoreFuture ... done
[10:30:50.990] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:50.990] - nx: 2
[10:30:50.991] - relay: TRUE
[10:30:50.991] - stdout: TRUE
[10:30:50.991] - signal: TRUE
[10:30:50.991] - resignal: FALSE
[10:30:50.991] - force: TRUE
[10:30:50.991] - relayed: [n=2] TRUE, FALSE
[10:30:50.991] - queued futures: [n=2] TRUE, FALSE
[10:30:50.992]  - until=2
[10:30:50.992]  - relaying element #2
[10:30:50.992] result() for MulticoreFuture ...
[10:30:50.992] result() for MulticoreFuture ... done
[10:30:50.992] result() for MulticoreFuture ...
[10:30:50.992] result() for MulticoreFuture ... done
[10:30:50.993] result() for MulticoreFuture ...
[10:30:50.993] result() for MulticoreFuture ... done
[10:30:50.993] result() for MulticoreFuture ...
[10:30:50.993] result() for MulticoreFuture ... done
[10:30:50.993] - relayed: [n=2] TRUE, TRUE
[10:30:50.993] - queued futures: [n=2] TRUE, TRUE
[10:30:50.994] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:50.994]  length: 0 (resolved future 2)
[10:30:50.994] Relaying remaining futures
[10:30:50.994] signalConditionsASAP(NULL, pos=0) ...
[10:30:50.994] - nx: 2
[10:30:50.994] - relay: TRUE
[10:30:50.994] - stdout: TRUE
[10:30:50.995] - signal: TRUE
[10:30:50.995] - resignal: FALSE
[10:30:50.995] - force: TRUE
[10:30:50.995] - relayed: [n=2] TRUE, TRUE
[10:30:50.995] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:50.995] - relayed: [n=2] TRUE, TRUE
[10:30:50.995] - queued futures: [n=2] TRUE, TRUE
[10:30:50.995] signalConditionsASAP(NULL, pos=0) ... done
[10:30:50.995] resolve() on list ... DONE
[10:30:50.996] result() for MulticoreFuture ...
[10:30:50.996] result() for MulticoreFuture ... done
[10:30:50.996] result() for MulticoreFuture ...
[10:30:50.996] result() for MulticoreFuture ... done
[10:30:50.996] result() for MulticoreFuture ...
[10:30:50.996] result() for MulticoreFuture ... done
[10:30:50.996] result() for MulticoreFuture ...
[10:30:50.996] result() for MulticoreFuture ... done
[10:30:50.997]  - Number of value chunks collected: 2
[10:30:50.997] Resolving 2 futures (chunks) ... DONE
[10:30:50.997] Reducing values from 2 chunks ...
[10:30:50.997]  - Number of values collected after concatenation: 2
[10:30:50.997]  - Number of values expected: 2
[10:30:50.997] Reducing values from 2 chunks ... DONE
[10:30:50.997] future_mapply() ... DONE
[10:30:50.998] future_mapply() ...
[10:30:50.998] Generating random seeds ...
[10:30:50.998] Generating random seed streams for 2 elements ...
[10:30:50.998] Generating random seed streams for 2 elements ... DONE
[10:30:50.998] Generating random seeds ... DONE
[10:30:50.998] Will set RNG state on exit: 10407, -1742510359, 1660488923, 1604207875, 952779669, 124690337, -1120608747
[10:30:51.003] Number of chunks: 2
[10:30:51.003] getGlobalsAndPackagesXApply() ...
[10:30:51.003]  - future.globals: TRUE
[10:30:51.003] getGlobalsAndPackages() ...
[10:30:51.004] Searching for globals...
[10:30:51.005] - globals found: [1] ‘FUN’
[10:30:51.005] Searching for globals ... DONE
[10:30:51.005] Resolving globals: FALSE
[10:30:51.005] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[10:30:51.006] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[10:30:51.006] - globals: [1] ‘FUN’
[10:30:51.006] 
[10:30:51.006] getGlobalsAndPackages() ... DONE
[10:30:51.006]  - globals found/used: [n=1] ‘FUN’
[10:30:51.006]  - needed namespaces: [n=0] 
[10:30:51.006] Finding globals ... DONE
[10:30:51.007] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:51.007] List of 2
[10:30:51.007]  $ ...future.FUN:function (x, y)  
[10:30:51.007]  $ MoreArgs     :List of 1
[10:30:51.007]   ..$ y: int [1:2] 3 4
[10:30:51.007]  - attr(*, "where")=List of 2
[10:30:51.007]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:51.007]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:51.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.007]  - attr(*, "resolved")= logi FALSE
[10:30:51.007]  - attr(*, "total_size")= num NA
[10:30:51.010] Packages to be attached in all futures: [n=0] 
[10:30:51.010] getGlobalsAndPackagesXApply() ... DONE
[10:30:51.010] Number of futures (= number of chunks): 2
[10:30:51.011] Launching 2 futures (chunks) ...
[10:30:51.011] Chunk #1 of 2 ...
[10:30:51.011]  - Finding globals in '...' for chunk #1 ...
[10:30:51.011] getGlobalsAndPackages() ...
[10:30:51.011] Searching for globals...
[10:30:51.011] 
[10:30:51.011] Searching for globals ... DONE
[10:30:51.012] - globals: [0] <none>
[10:30:51.012] getGlobalsAndPackages() ... DONE
[10:30:51.012]    + additional globals found: [n=0] 
[10:30:51.012]    + additional namespaces needed: [n=0] 
[10:30:51.012]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:51.012]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.012]  - seeds: [1] <seeds>
[10:30:51.012]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.015] getGlobalsAndPackages() ...
[10:30:51.015] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.015] Resolving globals: FALSE
[10:30:51.016] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[10:30:51.016] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:51.017] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.017] 
[10:30:51.017] getGlobalsAndPackages() ... DONE
[10:30:51.017] run() for ‘Future’ ...
[10:30:51.017] - state: ‘created’
[10:30:51.018] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.022] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.022] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.022]   - Field: ‘label’
[10:30:51.022]   - Field: ‘local’
[10:30:51.022]   - Field: ‘owner’
[10:30:51.023]   - Field: ‘envir’
[10:30:51.023]   - Field: ‘workers’
[10:30:51.023]   - Field: ‘packages’
[10:30:51.023]   - Field: ‘gc’
[10:30:51.023]   - Field: ‘job’
[10:30:51.023]   - Field: ‘conditions’
[10:30:51.023]   - Field: ‘expr’
[10:30:51.023]   - Field: ‘uuid’
[10:30:51.023]   - Field: ‘seed’
[10:30:51.024]   - Field: ‘version’
[10:30:51.024]   - Field: ‘result’
[10:30:51.024]   - Field: ‘asynchronous’
[10:30:51.024]   - Field: ‘calls’
[10:30:51.024]   - Field: ‘globals’
[10:30:51.024]   - Field: ‘stdout’
[10:30:51.024]   - Field: ‘earlySignal’
[10:30:51.024]   - Field: ‘lazy’
[10:30:51.025]   - Field: ‘state’
[10:30:51.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.025] - Launch lazy future ...
[10:30:51.025] Packages needed by the future expression (n = 0): <none>
[10:30:51.025] Packages needed by future strategies (n = 0): <none>
[10:30:51.026] {
[10:30:51.026]     {
[10:30:51.026]         {
[10:30:51.026]             ...future.startTime <- base::Sys.time()
[10:30:51.026]             {
[10:30:51.026]                 {
[10:30:51.026]                   {
[10:30:51.026]                     {
[10:30:51.026]                       base::local({
[10:30:51.026]                         has_future <- base::requireNamespace("future", 
[10:30:51.026]                           quietly = TRUE)
[10:30:51.026]                         if (has_future) {
[10:30:51.026]                           ns <- base::getNamespace("future")
[10:30:51.026]                           version <- ns[[".package"]][["version"]]
[10:30:51.026]                           if (is.null(version)) 
[10:30:51.026]                             version <- utils::packageVersion("future")
[10:30:51.026]                         }
[10:30:51.026]                         else {
[10:30:51.026]                           version <- NULL
[10:30:51.026]                         }
[10:30:51.026]                         if (!has_future || version < "1.8.0") {
[10:30:51.026]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.026]                             "", base::R.version$version.string), 
[10:30:51.026]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:51.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:51.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.026]                               "release", "version")], collapse = " "), 
[10:30:51.026]                             hostname = base::Sys.info()[["nodename"]])
[10:30:51.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.026]                             info)
[10:30:51.026]                           info <- base::paste(info, collapse = "; ")
[10:30:51.026]                           if (!has_future) {
[10:30:51.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.026]                               info)
[10:30:51.026]                           }
[10:30:51.026]                           else {
[10:30:51.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.026]                               info, version)
[10:30:51.026]                           }
[10:30:51.026]                           base::stop(msg)
[10:30:51.026]                         }
[10:30:51.026]                       })
[10:30:51.026]                     }
[10:30:51.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.026]                     base::options(mc.cores = 1L)
[10:30:51.026]                   }
[10:30:51.026]                   ...future.strategy.old <- future::plan("list")
[10:30:51.026]                   options(future.plan = NULL)
[10:30:51.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.026]                 }
[10:30:51.026]                 ...future.workdir <- getwd()
[10:30:51.026]             }
[10:30:51.026]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.026]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.026]         }
[10:30:51.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.026]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.026]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.026]             base::names(...future.oldOptions))
[10:30:51.026]     }
[10:30:51.026]     if (FALSE) {
[10:30:51.026]     }
[10:30:51.026]     else {
[10:30:51.026]         if (TRUE) {
[10:30:51.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.026]                 open = "w")
[10:30:51.026]         }
[10:30:51.026]         else {
[10:30:51.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.026]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.026]         }
[10:30:51.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.026]             base::sink(type = "output", split = FALSE)
[10:30:51.026]             base::close(...future.stdout)
[10:30:51.026]         }, add = TRUE)
[10:30:51.026]     }
[10:30:51.026]     ...future.frame <- base::sys.nframe()
[10:30:51.026]     ...future.conditions <- base::list()
[10:30:51.026]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.026]     if (FALSE) {
[10:30:51.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.026]     }
[10:30:51.026]     ...future.result <- base::tryCatch({
[10:30:51.026]         base::withCallingHandlers({
[10:30:51.026]             ...future.value <- base::withVisible(base::local({
[10:30:51.026]                 withCallingHandlers({
[10:30:51.026]                   {
[10:30:51.026]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.026]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.026]                       ...future.globals.maxSize)) {
[10:30:51.026]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.026]                       on.exit(options(oopts), add = TRUE)
[10:30:51.026]                     }
[10:30:51.026]                     {
[10:30:51.026]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:51.026]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:51.026]                           envir = globalenv(), inherits = FALSE)
[10:30:51.026]                         ...future.FUN(...)
[10:30:51.026]                       }
[10:30:51.026]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:51.026]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:51.026]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.026]                         USE.NAMES = FALSE)
[10:30:51.026]                       do.call(mapply, args = args)
[10:30:51.026]                     }
[10:30:51.026]                   }
[10:30:51.026]                 }, immediateCondition = function(cond) {
[10:30:51.026]                   save_rds <- function (object, pathname, ...) 
[10:30:51.026]                   {
[10:30:51.026]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.026]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.026]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.026]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.026]                         fi_tmp[["mtime"]])
[10:30:51.026]                     }
[10:30:51.026]                     tryCatch({
[10:30:51.026]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.026]                     }, error = function(ex) {
[10:30:51.026]                       msg <- conditionMessage(ex)
[10:30:51.026]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.026]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.026]                         fi_tmp[["mtime"]], msg)
[10:30:51.026]                       ex$message <- msg
[10:30:51.026]                       stop(ex)
[10:30:51.026]                     })
[10:30:51.026]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.026]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.026]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.026]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.026]                       fi <- file.info(pathname)
[10:30:51.026]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.026]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.026]                         fi[["size"]], fi[["mtime"]])
[10:30:51.026]                       stop(msg)
[10:30:51.026]                     }
[10:30:51.026]                     invisible(pathname)
[10:30:51.026]                   }
[10:30:51.026]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.026]                     rootPath = tempdir()) 
[10:30:51.026]                   {
[10:30:51.026]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.026]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.026]                       tmpdir = path, fileext = ".rds")
[10:30:51.026]                     save_rds(obj, file)
[10:30:51.026]                   }
[10:30:51.026]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.026]                   {
[10:30:51.026]                     inherits <- base::inherits
[10:30:51.026]                     invokeRestart <- base::invokeRestart
[10:30:51.026]                     is.null <- base::is.null
[10:30:51.026]                     muffled <- FALSE
[10:30:51.026]                     if (inherits(cond, "message")) {
[10:30:51.026]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.026]                       if (muffled) 
[10:30:51.026]                         invokeRestart("muffleMessage")
[10:30:51.026]                     }
[10:30:51.026]                     else if (inherits(cond, "warning")) {
[10:30:51.026]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.026]                       if (muffled) 
[10:30:51.026]                         invokeRestart("muffleWarning")
[10:30:51.026]                     }
[10:30:51.026]                     else if (inherits(cond, "condition")) {
[10:30:51.026]                       if (!is.null(pattern)) {
[10:30:51.026]                         computeRestarts <- base::computeRestarts
[10:30:51.026]                         grepl <- base::grepl
[10:30:51.026]                         restarts <- computeRestarts(cond)
[10:30:51.026]                         for (restart in restarts) {
[10:30:51.026]                           name <- restart$name
[10:30:51.026]                           if (is.null(name)) 
[10:30:51.026]                             next
[10:30:51.026]                           if (!grepl(pattern, name)) 
[10:30:51.026]                             next
[10:30:51.026]                           invokeRestart(restart)
[10:30:51.026]                           muffled <- TRUE
[10:30:51.026]                           break
[10:30:51.026]                         }
[10:30:51.026]                       }
[10:30:51.026]                     }
[10:30:51.026]                     invisible(muffled)
[10:30:51.026]                   }
[10:30:51.026]                   muffleCondition(cond)
[10:30:51.026]                 })
[10:30:51.026]             }))
[10:30:51.026]             future::FutureResult(value = ...future.value$value, 
[10:30:51.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.026]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.026]                     ...future.globalenv.names))
[10:30:51.026]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.026]         }, condition = base::local({
[10:30:51.026]             c <- base::c
[10:30:51.026]             inherits <- base::inherits
[10:30:51.026]             invokeRestart <- base::invokeRestart
[10:30:51.026]             length <- base::length
[10:30:51.026]             list <- base::list
[10:30:51.026]             seq.int <- base::seq.int
[10:30:51.026]             signalCondition <- base::signalCondition
[10:30:51.026]             sys.calls <- base::sys.calls
[10:30:51.026]             `[[` <- base::`[[`
[10:30:51.026]             `+` <- base::`+`
[10:30:51.026]             `<<-` <- base::`<<-`
[10:30:51.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.026]                   3L)]
[10:30:51.026]             }
[10:30:51.026]             function(cond) {
[10:30:51.026]                 is_error <- inherits(cond, "error")
[10:30:51.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.026]                   NULL)
[10:30:51.026]                 if (is_error) {
[10:30:51.026]                   sessionInformation <- function() {
[10:30:51.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.026]                       search = base::search(), system = base::Sys.info())
[10:30:51.026]                   }
[10:30:51.026]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.026]                     cond$call), session = sessionInformation(), 
[10:30:51.026]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.026]                   signalCondition(cond)
[10:30:51.026]                 }
[10:30:51.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.026]                 "immediateCondition"))) {
[10:30:51.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.026]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.026]                   if (TRUE && !signal) {
[10:30:51.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.026]                     {
[10:30:51.026]                       inherits <- base::inherits
[10:30:51.026]                       invokeRestart <- base::invokeRestart
[10:30:51.026]                       is.null <- base::is.null
[10:30:51.026]                       muffled <- FALSE
[10:30:51.026]                       if (inherits(cond, "message")) {
[10:30:51.026]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.026]                         if (muffled) 
[10:30:51.026]                           invokeRestart("muffleMessage")
[10:30:51.026]                       }
[10:30:51.026]                       else if (inherits(cond, "warning")) {
[10:30:51.026]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.026]                         if (muffled) 
[10:30:51.026]                           invokeRestart("muffleWarning")
[10:30:51.026]                       }
[10:30:51.026]                       else if (inherits(cond, "condition")) {
[10:30:51.026]                         if (!is.null(pattern)) {
[10:30:51.026]                           computeRestarts <- base::computeRestarts
[10:30:51.026]                           grepl <- base::grepl
[10:30:51.026]                           restarts <- computeRestarts(cond)
[10:30:51.026]                           for (restart in restarts) {
[10:30:51.026]                             name <- restart$name
[10:30:51.026]                             if (is.null(name)) 
[10:30:51.026]                               next
[10:30:51.026]                             if (!grepl(pattern, name)) 
[10:30:51.026]                               next
[10:30:51.026]                             invokeRestart(restart)
[10:30:51.026]                             muffled <- TRUE
[10:30:51.026]                             break
[10:30:51.026]                           }
[10:30:51.026]                         }
[10:30:51.026]                       }
[10:30:51.026]                       invisible(muffled)
[10:30:51.026]                     }
[10:30:51.026]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.026]                   }
[10:30:51.026]                 }
[10:30:51.026]                 else {
[10:30:51.026]                   if (TRUE) {
[10:30:51.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.026]                     {
[10:30:51.026]                       inherits <- base::inherits
[10:30:51.026]                       invokeRestart <- base::invokeRestart
[10:30:51.026]                       is.null <- base::is.null
[10:30:51.026]                       muffled <- FALSE
[10:30:51.026]                       if (inherits(cond, "message")) {
[10:30:51.026]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.026]                         if (muffled) 
[10:30:51.026]                           invokeRestart("muffleMessage")
[10:30:51.026]                       }
[10:30:51.026]                       else if (inherits(cond, "warning")) {
[10:30:51.026]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.026]                         if (muffled) 
[10:30:51.026]                           invokeRestart("muffleWarning")
[10:30:51.026]                       }
[10:30:51.026]                       else if (inherits(cond, "condition")) {
[10:30:51.026]                         if (!is.null(pattern)) {
[10:30:51.026]                           computeRestarts <- base::computeRestarts
[10:30:51.026]                           grepl <- base::grepl
[10:30:51.026]                           restarts <- computeRestarts(cond)
[10:30:51.026]                           for (restart in restarts) {
[10:30:51.026]                             name <- restart$name
[10:30:51.026]                             if (is.null(name)) 
[10:30:51.026]                               next
[10:30:51.026]                             if (!grepl(pattern, name)) 
[10:30:51.026]                               next
[10:30:51.026]                             invokeRestart(restart)
[10:30:51.026]                             muffled <- TRUE
[10:30:51.026]                             break
[10:30:51.026]                           }
[10:30:51.026]                         }
[10:30:51.026]                       }
[10:30:51.026]                       invisible(muffled)
[10:30:51.026]                     }
[10:30:51.026]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.026]                   }
[10:30:51.026]                 }
[10:30:51.026]             }
[10:30:51.026]         }))
[10:30:51.026]     }, error = function(ex) {
[10:30:51.026]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.026]                 ...future.rng), started = ...future.startTime, 
[10:30:51.026]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.026]             version = "1.8"), class = "FutureResult")
[10:30:51.026]     }, finally = {
[10:30:51.026]         if (!identical(...future.workdir, getwd())) 
[10:30:51.026]             setwd(...future.workdir)
[10:30:51.026]         {
[10:30:51.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.026]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.026]             }
[10:30:51.026]             base::options(...future.oldOptions)
[10:30:51.026]             if (.Platform$OS.type == "windows") {
[10:30:51.026]                 old_names <- names(...future.oldEnvVars)
[10:30:51.026]                 envs <- base::Sys.getenv()
[10:30:51.026]                 names <- names(envs)
[10:30:51.026]                 common <- intersect(names, old_names)
[10:30:51.026]                 added <- setdiff(names, old_names)
[10:30:51.026]                 removed <- setdiff(old_names, names)
[10:30:51.026]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.026]                   envs[common]]
[10:30:51.026]                 NAMES <- toupper(changed)
[10:30:51.026]                 args <- list()
[10:30:51.026]                 for (kk in seq_along(NAMES)) {
[10:30:51.026]                   name <- changed[[kk]]
[10:30:51.026]                   NAME <- NAMES[[kk]]
[10:30:51.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.026]                     next
[10:30:51.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.026]                 }
[10:30:51.026]                 NAMES <- toupper(added)
[10:30:51.026]                 for (kk in seq_along(NAMES)) {
[10:30:51.026]                   name <- added[[kk]]
[10:30:51.026]                   NAME <- NAMES[[kk]]
[10:30:51.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.026]                     next
[10:30:51.026]                   args[[name]] <- ""
[10:30:51.026]                 }
[10:30:51.026]                 NAMES <- toupper(removed)
[10:30:51.026]                 for (kk in seq_along(NAMES)) {
[10:30:51.026]                   name <- removed[[kk]]
[10:30:51.026]                   NAME <- NAMES[[kk]]
[10:30:51.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.026]                     next
[10:30:51.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.026]                 }
[10:30:51.026]                 if (length(args) > 0) 
[10:30:51.026]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.026]             }
[10:30:51.026]             else {
[10:30:51.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.026]             }
[10:30:51.026]             {
[10:30:51.026]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.026]                   0L) {
[10:30:51.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.026]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.026]                   base::options(opts)
[10:30:51.026]                 }
[10:30:51.026]                 {
[10:30:51.026]                   {
[10:30:51.026]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.026]                     NULL
[10:30:51.026]                   }
[10:30:51.026]                   options(future.plan = NULL)
[10:30:51.026]                   if (is.na(NA_character_)) 
[10:30:51.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.026]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.026]                     .init = FALSE)
[10:30:51.026]                 }
[10:30:51.026]             }
[10:30:51.026]         }
[10:30:51.026]     })
[10:30:51.026]     if (TRUE) {
[10:30:51.026]         base::sink(type = "output", split = FALSE)
[10:30:51.026]         if (TRUE) {
[10:30:51.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.026]         }
[10:30:51.026]         else {
[10:30:51.026]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.026]         }
[10:30:51.026]         base::close(...future.stdout)
[10:30:51.026]         ...future.stdout <- NULL
[10:30:51.026]     }
[10:30:51.026]     ...future.result$conditions <- ...future.conditions
[10:30:51.026]     ...future.result$finished <- base::Sys.time()
[10:30:51.026]     ...future.result
[10:30:51.026] }
[10:30:51.028] assign_globals() ...
[10:30:51.028] List of 5
[10:30:51.028]  $ ...future.FUN            :function (x, y)  
[10:30:51.028]  $ MoreArgs                 :List of 1
[10:30:51.028]   ..$ y: int [1:2] 3 4
[10:30:51.028]  $ ...future.elements_ii    :List of 1
[10:30:51.028]   ..$ x:List of 1
[10:30:51.028]   .. ..$ : int 1
[10:30:51.028]  $ ...future.seeds_ii       :List of 1
[10:30:51.028]   ..$ : int [1:7] 10407 837332117 -1244734919 -625399479 470618360 2018864569 -1597735319
[10:30:51.028]  $ ...future.globals.maxSize: NULL
[10:30:51.028]  - attr(*, "where")=List of 5
[10:30:51.028]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.028]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.028]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.028]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.028]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.028]  - attr(*, "resolved")= logi FALSE
[10:30:51.028]  - attr(*, "total_size")= num 1896
[10:30:51.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.028]  - attr(*, "already-done")= logi TRUE
[10:30:51.034] - reassign environment for ‘...future.FUN’
[10:30:51.034] - copied ‘...future.FUN’ to environment
[10:30:51.034] - copied ‘MoreArgs’ to environment
[10:30:51.034] - copied ‘...future.elements_ii’ to environment
[10:30:51.034] - copied ‘...future.seeds_ii’ to environment
[10:30:51.034] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.035] assign_globals() ... done
[10:30:51.035] requestCore(): workers = 2
[10:30:51.037] MulticoreFuture started
[10:30:51.038] - Launch lazy future ... done
[10:30:51.038] run() for ‘MulticoreFuture’ ... done
[10:30:51.038] Created future:
[10:30:51.038] plan(): Setting new future strategy stack:
[10:30:51.038] List of future strategies:
[10:30:51.038] 1. sequential:
[10:30:51.038]    - args: function (..., envir = parent.frame())
[10:30:51.038]    - tweaked: FALSE
[10:30:51.038]    - call: NULL
[10:30:51.039] plan(): nbrOfWorkers() = 1
[10:30:51.041] plan(): Setting new future strategy stack:
[10:30:51.042] List of future strategies:
[10:30:51.042] 1. multicore:
[10:30:51.042]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.042]    - tweaked: FALSE
[10:30:51.042]    - call: plan(strategy)
[10:30:51.048] plan(): nbrOfWorkers() = 2
[10:30:51.038] MulticoreFuture:
[10:30:51.038] Label: ‘future_mapply-1’
[10:30:51.038] Expression:
[10:30:51.038] {
[10:30:51.038]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.038]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.038]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.038]         on.exit(options(oopts), add = TRUE)
[10:30:51.038]     }
[10:30:51.038]     {
[10:30:51.038]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:51.038]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:51.038]                 inherits = FALSE)
[10:30:51.038]             ...future.FUN(...)
[10:30:51.038]         }
[10:30:51.038]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:51.038]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:51.038]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.038]         do.call(mapply, args = args)
[10:30:51.038]     }
[10:30:51.038] }
[10:30:51.038] Lazy evaluation: FALSE
[10:30:51.038] Asynchronous evaluation: TRUE
[10:30:51.038] Local evaluation: TRUE
[10:30:51.038] Environment: R_GlobalEnv
[10:30:51.038] Capture standard output: TRUE
[10:30:51.038] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.038] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.038] Packages: <none>
[10:30:51.038] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:51.038] Resolved: TRUE
[10:30:51.038] Value: <not collected>
[10:30:51.038] Conditions captured: <none>
[10:30:51.038] Early signaling: FALSE
[10:30:51.038] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.038] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.049] Chunk #1 of 2 ... DONE
[10:30:51.049] Chunk #2 of 2 ...
[10:30:51.049]  - Finding globals in '...' for chunk #2 ...
[10:30:51.049] getGlobalsAndPackages() ...
[10:30:51.050] Searching for globals...
[10:30:51.050] 
[10:30:51.050] Searching for globals ... DONE
[10:30:51.050] - globals: [0] <none>
[10:30:51.051] getGlobalsAndPackages() ... DONE
[10:30:51.051]    + additional globals found: [n=0] 
[10:30:51.051]    + additional namespaces needed: [n=0] 
[10:30:51.051]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:51.051]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.051]  - seeds: [1] <seeds>
[10:30:51.051]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.052] getGlobalsAndPackages() ...
[10:30:51.052] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.052] Resolving globals: FALSE
[10:30:51.053] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[10:30:51.054] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:51.058] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.058] 
[10:30:51.059] getGlobalsAndPackages() ... DONE
[10:30:51.060] run() for ‘Future’ ...
[10:30:51.060] - state: ‘created’
[10:30:51.061] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.067] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.067] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.067]   - Field: ‘label’
[10:30:51.068]   - Field: ‘local’
[10:30:51.068]   - Field: ‘owner’
[10:30:51.068]   - Field: ‘envir’
[10:30:51.068]   - Field: ‘workers’
[10:30:51.069]   - Field: ‘packages’
[10:30:51.069]   - Field: ‘gc’
[10:30:51.069]   - Field: ‘job’
[10:30:51.069]   - Field: ‘conditions’
[10:30:51.070]   - Field: ‘expr’
[10:30:51.070]   - Field: ‘uuid’
[10:30:51.070]   - Field: ‘seed’
[10:30:51.070]   - Field: ‘version’
[10:30:51.070]   - Field: ‘result’
[10:30:51.071]   - Field: ‘asynchronous’
[10:30:51.071]   - Field: ‘calls’
[10:30:51.071]   - Field: ‘globals’
[10:30:51.071]   - Field: ‘stdout’
[10:30:51.071]   - Field: ‘earlySignal’
[10:30:51.072]   - Field: ‘lazy’
[10:30:51.072]   - Field: ‘state’
[10:30:51.072] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.072] - Launch lazy future ...
[10:30:51.073] Packages needed by the future expression (n = 0): <none>
[10:30:51.073] Packages needed by future strategies (n = 0): <none>
[10:30:51.074] {
[10:30:51.074]     {
[10:30:51.074]         {
[10:30:51.074]             ...future.startTime <- base::Sys.time()
[10:30:51.074]             {
[10:30:51.074]                 {
[10:30:51.074]                   {
[10:30:51.074]                     {
[10:30:51.074]                       base::local({
[10:30:51.074]                         has_future <- base::requireNamespace("future", 
[10:30:51.074]                           quietly = TRUE)
[10:30:51.074]                         if (has_future) {
[10:30:51.074]                           ns <- base::getNamespace("future")
[10:30:51.074]                           version <- ns[[".package"]][["version"]]
[10:30:51.074]                           if (is.null(version)) 
[10:30:51.074]                             version <- utils::packageVersion("future")
[10:30:51.074]                         }
[10:30:51.074]                         else {
[10:30:51.074]                           version <- NULL
[10:30:51.074]                         }
[10:30:51.074]                         if (!has_future || version < "1.8.0") {
[10:30:51.074]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.074]                             "", base::R.version$version.string), 
[10:30:51.074]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:51.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:51.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.074]                               "release", "version")], collapse = " "), 
[10:30:51.074]                             hostname = base::Sys.info()[["nodename"]])
[10:30:51.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.074]                             info)
[10:30:51.074]                           info <- base::paste(info, collapse = "; ")
[10:30:51.074]                           if (!has_future) {
[10:30:51.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.074]                               info)
[10:30:51.074]                           }
[10:30:51.074]                           else {
[10:30:51.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.074]                               info, version)
[10:30:51.074]                           }
[10:30:51.074]                           base::stop(msg)
[10:30:51.074]                         }
[10:30:51.074]                       })
[10:30:51.074]                     }
[10:30:51.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.074]                     base::options(mc.cores = 1L)
[10:30:51.074]                   }
[10:30:51.074]                   ...future.strategy.old <- future::plan("list")
[10:30:51.074]                   options(future.plan = NULL)
[10:30:51.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.074]                 }
[10:30:51.074]                 ...future.workdir <- getwd()
[10:30:51.074]             }
[10:30:51.074]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.074]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.074]         }
[10:30:51.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.074]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.074]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.074]             base::names(...future.oldOptions))
[10:30:51.074]     }
[10:30:51.074]     if (FALSE) {
[10:30:51.074]     }
[10:30:51.074]     else {
[10:30:51.074]         if (TRUE) {
[10:30:51.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.074]                 open = "w")
[10:30:51.074]         }
[10:30:51.074]         else {
[10:30:51.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.074]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.074]         }
[10:30:51.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.074]             base::sink(type = "output", split = FALSE)
[10:30:51.074]             base::close(...future.stdout)
[10:30:51.074]         }, add = TRUE)
[10:30:51.074]     }
[10:30:51.074]     ...future.frame <- base::sys.nframe()
[10:30:51.074]     ...future.conditions <- base::list()
[10:30:51.074]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.074]     if (FALSE) {
[10:30:51.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.074]     }
[10:30:51.074]     ...future.result <- base::tryCatch({
[10:30:51.074]         base::withCallingHandlers({
[10:30:51.074]             ...future.value <- base::withVisible(base::local({
[10:30:51.074]                 withCallingHandlers({
[10:30:51.074]                   {
[10:30:51.074]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.074]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.074]                       ...future.globals.maxSize)) {
[10:30:51.074]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.074]                       on.exit(options(oopts), add = TRUE)
[10:30:51.074]                     }
[10:30:51.074]                     {
[10:30:51.074]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:51.074]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:51.074]                           envir = globalenv(), inherits = FALSE)
[10:30:51.074]                         ...future.FUN(...)
[10:30:51.074]                       }
[10:30:51.074]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:51.074]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:51.074]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.074]                         USE.NAMES = FALSE)
[10:30:51.074]                       do.call(mapply, args = args)
[10:30:51.074]                     }
[10:30:51.074]                   }
[10:30:51.074]                 }, immediateCondition = function(cond) {
[10:30:51.074]                   save_rds <- function (object, pathname, ...) 
[10:30:51.074]                   {
[10:30:51.074]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.074]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.074]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.074]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.074]                         fi_tmp[["mtime"]])
[10:30:51.074]                     }
[10:30:51.074]                     tryCatch({
[10:30:51.074]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.074]                     }, error = function(ex) {
[10:30:51.074]                       msg <- conditionMessage(ex)
[10:30:51.074]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.074]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.074]                         fi_tmp[["mtime"]], msg)
[10:30:51.074]                       ex$message <- msg
[10:30:51.074]                       stop(ex)
[10:30:51.074]                     })
[10:30:51.074]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.074]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.074]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.074]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.074]                       fi <- file.info(pathname)
[10:30:51.074]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.074]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.074]                         fi[["size"]], fi[["mtime"]])
[10:30:51.074]                       stop(msg)
[10:30:51.074]                     }
[10:30:51.074]                     invisible(pathname)
[10:30:51.074]                   }
[10:30:51.074]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.074]                     rootPath = tempdir()) 
[10:30:51.074]                   {
[10:30:51.074]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.074]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.074]                       tmpdir = path, fileext = ".rds")
[10:30:51.074]                     save_rds(obj, file)
[10:30:51.074]                   }
[10:30:51.074]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.074]                   {
[10:30:51.074]                     inherits <- base::inherits
[10:30:51.074]                     invokeRestart <- base::invokeRestart
[10:30:51.074]                     is.null <- base::is.null
[10:30:51.074]                     muffled <- FALSE
[10:30:51.074]                     if (inherits(cond, "message")) {
[10:30:51.074]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.074]                       if (muffled) 
[10:30:51.074]                         invokeRestart("muffleMessage")
[10:30:51.074]                     }
[10:30:51.074]                     else if (inherits(cond, "warning")) {
[10:30:51.074]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.074]                       if (muffled) 
[10:30:51.074]                         invokeRestart("muffleWarning")
[10:30:51.074]                     }
[10:30:51.074]                     else if (inherits(cond, "condition")) {
[10:30:51.074]                       if (!is.null(pattern)) {
[10:30:51.074]                         computeRestarts <- base::computeRestarts
[10:30:51.074]                         grepl <- base::grepl
[10:30:51.074]                         restarts <- computeRestarts(cond)
[10:30:51.074]                         for (restart in restarts) {
[10:30:51.074]                           name <- restart$name
[10:30:51.074]                           if (is.null(name)) 
[10:30:51.074]                             next
[10:30:51.074]                           if (!grepl(pattern, name)) 
[10:30:51.074]                             next
[10:30:51.074]                           invokeRestart(restart)
[10:30:51.074]                           muffled <- TRUE
[10:30:51.074]                           break
[10:30:51.074]                         }
[10:30:51.074]                       }
[10:30:51.074]                     }
[10:30:51.074]                     invisible(muffled)
[10:30:51.074]                   }
[10:30:51.074]                   muffleCondition(cond)
[10:30:51.074]                 })
[10:30:51.074]             }))
[10:30:51.074]             future::FutureResult(value = ...future.value$value, 
[10:30:51.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.074]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.074]                     ...future.globalenv.names))
[10:30:51.074]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.074]         }, condition = base::local({
[10:30:51.074]             c <- base::c
[10:30:51.074]             inherits <- base::inherits
[10:30:51.074]             invokeRestart <- base::invokeRestart
[10:30:51.074]             length <- base::length
[10:30:51.074]             list <- base::list
[10:30:51.074]             seq.int <- base::seq.int
[10:30:51.074]             signalCondition <- base::signalCondition
[10:30:51.074]             sys.calls <- base::sys.calls
[10:30:51.074]             `[[` <- base::`[[`
[10:30:51.074]             `+` <- base::`+`
[10:30:51.074]             `<<-` <- base::`<<-`
[10:30:51.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.074]                   3L)]
[10:30:51.074]             }
[10:30:51.074]             function(cond) {
[10:30:51.074]                 is_error <- inherits(cond, "error")
[10:30:51.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.074]                   NULL)
[10:30:51.074]                 if (is_error) {
[10:30:51.074]                   sessionInformation <- function() {
[10:30:51.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.074]                       search = base::search(), system = base::Sys.info())
[10:30:51.074]                   }
[10:30:51.074]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.074]                     cond$call), session = sessionInformation(), 
[10:30:51.074]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.074]                   signalCondition(cond)
[10:30:51.074]                 }
[10:30:51.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.074]                 "immediateCondition"))) {
[10:30:51.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.074]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.074]                   if (TRUE && !signal) {
[10:30:51.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.074]                     {
[10:30:51.074]                       inherits <- base::inherits
[10:30:51.074]                       invokeRestart <- base::invokeRestart
[10:30:51.074]                       is.null <- base::is.null
[10:30:51.074]                       muffled <- FALSE
[10:30:51.074]                       if (inherits(cond, "message")) {
[10:30:51.074]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.074]                         if (muffled) 
[10:30:51.074]                           invokeRestart("muffleMessage")
[10:30:51.074]                       }
[10:30:51.074]                       else if (inherits(cond, "warning")) {
[10:30:51.074]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.074]                         if (muffled) 
[10:30:51.074]                           invokeRestart("muffleWarning")
[10:30:51.074]                       }
[10:30:51.074]                       else if (inherits(cond, "condition")) {
[10:30:51.074]                         if (!is.null(pattern)) {
[10:30:51.074]                           computeRestarts <- base::computeRestarts
[10:30:51.074]                           grepl <- base::grepl
[10:30:51.074]                           restarts <- computeRestarts(cond)
[10:30:51.074]                           for (restart in restarts) {
[10:30:51.074]                             name <- restart$name
[10:30:51.074]                             if (is.null(name)) 
[10:30:51.074]                               next
[10:30:51.074]                             if (!grepl(pattern, name)) 
[10:30:51.074]                               next
[10:30:51.074]                             invokeRestart(restart)
[10:30:51.074]                             muffled <- TRUE
[10:30:51.074]                             break
[10:30:51.074]                           }
[10:30:51.074]                         }
[10:30:51.074]                       }
[10:30:51.074]                       invisible(muffled)
[10:30:51.074]                     }
[10:30:51.074]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.074]                   }
[10:30:51.074]                 }
[10:30:51.074]                 else {
[10:30:51.074]                   if (TRUE) {
[10:30:51.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.074]                     {
[10:30:51.074]                       inherits <- base::inherits
[10:30:51.074]                       invokeRestart <- base::invokeRestart
[10:30:51.074]                       is.null <- base::is.null
[10:30:51.074]                       muffled <- FALSE
[10:30:51.074]                       if (inherits(cond, "message")) {
[10:30:51.074]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.074]                         if (muffled) 
[10:30:51.074]                           invokeRestart("muffleMessage")
[10:30:51.074]                       }
[10:30:51.074]                       else if (inherits(cond, "warning")) {
[10:30:51.074]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.074]                         if (muffled) 
[10:30:51.074]                           invokeRestart("muffleWarning")
[10:30:51.074]                       }
[10:30:51.074]                       else if (inherits(cond, "condition")) {
[10:30:51.074]                         if (!is.null(pattern)) {
[10:30:51.074]                           computeRestarts <- base::computeRestarts
[10:30:51.074]                           grepl <- base::grepl
[10:30:51.074]                           restarts <- computeRestarts(cond)
[10:30:51.074]                           for (restart in restarts) {
[10:30:51.074]                             name <- restart$name
[10:30:51.074]                             if (is.null(name)) 
[10:30:51.074]                               next
[10:30:51.074]                             if (!grepl(pattern, name)) 
[10:30:51.074]                               next
[10:30:51.074]                             invokeRestart(restart)
[10:30:51.074]                             muffled <- TRUE
[10:30:51.074]                             break
[10:30:51.074]                           }
[10:30:51.074]                         }
[10:30:51.074]                       }
[10:30:51.074]                       invisible(muffled)
[10:30:51.074]                     }
[10:30:51.074]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.074]                   }
[10:30:51.074]                 }
[10:30:51.074]             }
[10:30:51.074]         }))
[10:30:51.074]     }, error = function(ex) {
[10:30:51.074]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.074]                 ...future.rng), started = ...future.startTime, 
[10:30:51.074]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.074]             version = "1.8"), class = "FutureResult")
[10:30:51.074]     }, finally = {
[10:30:51.074]         if (!identical(...future.workdir, getwd())) 
[10:30:51.074]             setwd(...future.workdir)
[10:30:51.074]         {
[10:30:51.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.074]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.074]             }
[10:30:51.074]             base::options(...future.oldOptions)
[10:30:51.074]             if (.Platform$OS.type == "windows") {
[10:30:51.074]                 old_names <- names(...future.oldEnvVars)
[10:30:51.074]                 envs <- base::Sys.getenv()
[10:30:51.074]                 names <- names(envs)
[10:30:51.074]                 common <- intersect(names, old_names)
[10:30:51.074]                 added <- setdiff(names, old_names)
[10:30:51.074]                 removed <- setdiff(old_names, names)
[10:30:51.074]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.074]                   envs[common]]
[10:30:51.074]                 NAMES <- toupper(changed)
[10:30:51.074]                 args <- list()
[10:30:51.074]                 for (kk in seq_along(NAMES)) {
[10:30:51.074]                   name <- changed[[kk]]
[10:30:51.074]                   NAME <- NAMES[[kk]]
[10:30:51.074]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.074]                     next
[10:30:51.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.074]                 }
[10:30:51.074]                 NAMES <- toupper(added)
[10:30:51.074]                 for (kk in seq_along(NAMES)) {
[10:30:51.074]                   name <- added[[kk]]
[10:30:51.074]                   NAME <- NAMES[[kk]]
[10:30:51.074]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.074]                     next
[10:30:51.074]                   args[[name]] <- ""
[10:30:51.074]                 }
[10:30:51.074]                 NAMES <- toupper(removed)
[10:30:51.074]                 for (kk in seq_along(NAMES)) {
[10:30:51.074]                   name <- removed[[kk]]
[10:30:51.074]                   NAME <- NAMES[[kk]]
[10:30:51.074]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.074]                     next
[10:30:51.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.074]                 }
[10:30:51.074]                 if (length(args) > 0) 
[10:30:51.074]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.074]             }
[10:30:51.074]             else {
[10:30:51.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.074]             }
[10:30:51.074]             {
[10:30:51.074]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.074]                   0L) {
[10:30:51.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.074]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.074]                   base::options(opts)
[10:30:51.074]                 }
[10:30:51.074]                 {
[10:30:51.074]                   {
[10:30:51.074]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.074]                     NULL
[10:30:51.074]                   }
[10:30:51.074]                   options(future.plan = NULL)
[10:30:51.074]                   if (is.na(NA_character_)) 
[10:30:51.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.074]                     .init = FALSE)
[10:30:51.074]                 }
[10:30:51.074]             }
[10:30:51.074]         }
[10:30:51.074]     })
[10:30:51.074]     if (TRUE) {
[10:30:51.074]         base::sink(type = "output", split = FALSE)
[10:30:51.074]         if (TRUE) {
[10:30:51.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.074]         }
[10:30:51.074]         else {
[10:30:51.074]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.074]         }
[10:30:51.074]         base::close(...future.stdout)
[10:30:51.074]         ...future.stdout <- NULL
[10:30:51.074]     }
[10:30:51.074]     ...future.result$conditions <- ...future.conditions
[10:30:51.074]     ...future.result$finished <- base::Sys.time()
[10:30:51.074]     ...future.result
[10:30:51.074] }
[10:30:51.077] assign_globals() ...
[10:30:51.077] List of 5
[10:30:51.077]  $ ...future.FUN            :function (x, y)  
[10:30:51.077]  $ MoreArgs                 :List of 1
[10:30:51.077]   ..$ y: int [1:2] 3 4
[10:30:51.077]  $ ...future.elements_ii    :List of 1
[10:30:51.077]   ..$ x:List of 1
[10:30:51.077]   .. ..$ : int 2
[10:30:51.077]  $ ...future.seeds_ii       :List of 1
[10:30:51.077]   ..$ : int [1:7] 10407 -1348069453 237432952 -1714907232 84215365 1881213664 1826822297
[10:30:51.077]  $ ...future.globals.maxSize: NULL
[10:30:51.077]  - attr(*, "where")=List of 5
[10:30:51.077]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.077]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.077]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.077]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.077]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.077]  - attr(*, "resolved")= logi FALSE
[10:30:51.077]  - attr(*, "total_size")= num 1896
[10:30:51.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.077]  - attr(*, "already-done")= logi TRUE
[10:30:51.085] - reassign environment for ‘...future.FUN’
[10:30:51.085] - copied ‘...future.FUN’ to environment
[10:30:51.085] - copied ‘MoreArgs’ to environment
[10:30:51.085] - copied ‘...future.elements_ii’ to environment
[10:30:51.086] - copied ‘...future.seeds_ii’ to environment
[10:30:51.086] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.086] assign_globals() ... done
[10:30:51.086] requestCore(): workers = 2
[10:30:51.088] MulticoreFuture started
[10:30:51.089] - Launch lazy future ... done
[10:30:51.089] run() for ‘MulticoreFuture’ ... done
[10:30:51.089] Created future:
[10:30:51.090] plan(): Setting new future strategy stack:
[10:30:51.090] List of future strategies:
[10:30:51.090] 1. sequential:
[10:30:51.090]    - args: function (..., envir = parent.frame())
[10:30:51.090]    - tweaked: FALSE
[10:30:51.090]    - call: NULL
[10:30:51.091] plan(): nbrOfWorkers() = 1
[10:30:51.093] plan(): Setting new future strategy stack:
[10:30:51.093] List of future strategies:
[10:30:51.093] 1. multicore:
[10:30:51.093]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.093]    - tweaked: FALSE
[10:30:51.093]    - call: plan(strategy)
[10:30:51.098] plan(): nbrOfWorkers() = 2
[10:30:51.090] MulticoreFuture:
[10:30:51.090] Label: ‘future_mapply-2’
[10:30:51.090] Expression:
[10:30:51.090] {
[10:30:51.090]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.090]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.090]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.090]         on.exit(options(oopts), add = TRUE)
[10:30:51.090]     }
[10:30:51.090]     {
[10:30:51.090]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:51.090]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:51.090]                 inherits = FALSE)
[10:30:51.090]             ...future.FUN(...)
[10:30:51.090]         }
[10:30:51.090]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:51.090]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:51.090]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.090]         do.call(mapply, args = args)
[10:30:51.090]     }
[10:30:51.090] }
[10:30:51.090] Lazy evaluation: FALSE
[10:30:51.090] Asynchronous evaluation: TRUE
[10:30:51.090] Local evaluation: TRUE
[10:30:51.090] Environment: R_GlobalEnv
[10:30:51.090] Capture standard output: TRUE
[10:30:51.090] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.090] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.090] Packages: <none>
[10:30:51.090] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:51.090] Resolved: TRUE
[10:30:51.090] Value: <not collected>
[10:30:51.090] Conditions captured: <none>
[10:30:51.090] Early signaling: FALSE
[10:30:51.090] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.090] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.099] Chunk #2 of 2 ... DONE
[10:30:51.100] Launching 2 futures (chunks) ... DONE
[10:30:51.100] Resolving 2 futures (chunks) ...
[10:30:51.100] resolve() on list ...
[10:30:51.100]  recursive: 0
[10:30:51.100]  length: 2
[10:30:51.100] 
[10:30:51.101] Future #1
[10:30:51.101] result() for MulticoreFuture ...
[10:30:51.102] result() for MulticoreFuture ...
[10:30:51.102] result() for MulticoreFuture ... done
[10:30:51.102] result() for MulticoreFuture ... done
[10:30:51.102] result() for MulticoreFuture ...
[10:30:51.102] result() for MulticoreFuture ... done
[10:30:51.103] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:51.103] - nx: 2
[10:30:51.103] - relay: TRUE
[10:30:51.103] - stdout: TRUE
[10:30:51.103] - signal: TRUE
[10:30:51.103] - resignal: FALSE
[10:30:51.103] - force: TRUE
[10:30:51.104] - relayed: [n=2] FALSE, FALSE
[10:30:51.104] - queued futures: [n=2] FALSE, FALSE
[10:30:51.104]  - until=1
[10:30:51.104]  - relaying element #1
[10:30:51.104] result() for MulticoreFuture ...
[10:30:51.104] result() for MulticoreFuture ... done
[10:30:51.104] result() for MulticoreFuture ...
[10:30:51.105] result() for MulticoreFuture ... done
[10:30:51.105] result() for MulticoreFuture ...
[10:30:51.105] result() for MulticoreFuture ... done
[10:30:51.105] result() for MulticoreFuture ...
[10:30:51.105] result() for MulticoreFuture ... done
[10:30:51.105] - relayed: [n=2] TRUE, FALSE
[10:30:51.106] - queued futures: [n=2] TRUE, FALSE
[10:30:51.110] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:51.110]  length: 1 (resolved future 1)
[10:30:51.111] Future #2
[10:30:51.111] result() for MulticoreFuture ...
[10:30:51.113] result() for MulticoreFuture ...
[10:30:51.113] result() for MulticoreFuture ... done
[10:30:51.114] result() for MulticoreFuture ... done
[10:30:51.114] result() for MulticoreFuture ...
[10:30:51.114] result() for MulticoreFuture ... done
[10:30:51.115] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:51.115] - nx: 2
[10:30:51.115] - relay: TRUE
[10:30:51.115] - stdout: TRUE
[10:30:51.116] - signal: TRUE
[10:30:51.116] - resignal: FALSE
[10:30:51.116] - force: TRUE
[10:30:51.116] - relayed: [n=2] TRUE, FALSE
[10:30:51.116] - queued futures: [n=2] TRUE, FALSE
[10:30:51.116]  - until=2
[10:30:51.117]  - relaying element #2
[10:30:51.117] result() for MulticoreFuture ...
[10:30:51.117] result() for MulticoreFuture ... done
[10:30:51.117] result() for MulticoreFuture ...
[10:30:51.117] result() for MulticoreFuture ... done
[10:30:51.117] result() for MulticoreFuture ...
[10:30:51.118] result() for MulticoreFuture ... done
[10:30:51.118] result() for MulticoreFuture ...
[10:30:51.118] result() for MulticoreFuture ... done
[10:30:51.118] - relayed: [n=2] TRUE, TRUE
[10:30:51.118] - queued futures: [n=2] TRUE, TRUE
[10:30:51.118] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:51.119]  length: 0 (resolved future 2)
[10:30:51.119] Relaying remaining futures
[10:30:51.119] signalConditionsASAP(NULL, pos=0) ...
[10:30:51.119] - nx: 2
[10:30:51.119] - relay: TRUE
[10:30:51.119] - stdout: TRUE
[10:30:51.119] - signal: TRUE
[10:30:51.120] - resignal: FALSE
[10:30:51.120] - force: TRUE
[10:30:51.120] - relayed: [n=2] TRUE, TRUE
[10:30:51.120] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:51.120] - relayed: [n=2] TRUE, TRUE
[10:30:51.120] - queued futures: [n=2] TRUE, TRUE
[10:30:51.120] signalConditionsASAP(NULL, pos=0) ... done
[10:30:51.121] resolve() on list ... DONE
[10:30:51.121] result() for MulticoreFuture ...
[10:30:51.121] result() for MulticoreFuture ... done
[10:30:51.121] result() for MulticoreFuture ...
[10:30:51.121] result() for MulticoreFuture ... done
[10:30:51.121] result() for MulticoreFuture ...
[10:30:51.121] result() for MulticoreFuture ... done
[10:30:51.122] result() for MulticoreFuture ...
[10:30:51.122] result() for MulticoreFuture ... done
[10:30:51.122]  - Number of value chunks collected: 2
[10:30:51.122] Resolving 2 futures (chunks) ... DONE
[10:30:51.122] Reducing values from 2 chunks ...
[10:30:51.122]  - Number of values collected after concatenation: 2
[10:30:51.122]  - Number of values expected: 2
[10:30:51.122] Reducing values from 2 chunks ... DONE
[10:30:51.123] future_mapply() ... DONE
[10:30:51.123] future_mapply() ...
[10:30:51.127] Number of chunks: 2
[10:30:51.127] getGlobalsAndPackagesXApply() ...
[10:30:51.127]  - future.globals: TRUE
[10:30:51.128] getGlobalsAndPackages() ...
[10:30:51.128] Searching for globals...
[10:30:51.129] - globals found: [1] ‘FUN’
[10:30:51.129] Searching for globals ... DONE
[10:30:51.129] Resolving globals: FALSE
[10:30:51.130] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[10:30:51.130] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[10:30:51.130] - globals: [1] ‘FUN’
[10:30:51.130] 
[10:30:51.130] getGlobalsAndPackages() ... DONE
[10:30:51.131]  - globals found/used: [n=1] ‘FUN’
[10:30:51.131]  - needed namespaces: [n=0] 
[10:30:51.131] Finding globals ... DONE
[10:30:51.131] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:51.131] List of 2
[10:30:51.131]  $ ...future.FUN:function (x, y)  
[10:30:51.131]  $ MoreArgs     :List of 1
[10:30:51.131]   ..$ y: int [1:2] 3 4
[10:30:51.131]  - attr(*, "where")=List of 2
[10:30:51.131]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:51.131]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:51.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.131]  - attr(*, "resolved")= logi FALSE
[10:30:51.131]  - attr(*, "total_size")= num NA
[10:30:51.134] Packages to be attached in all futures: [n=0] 
[10:30:51.134] getGlobalsAndPackagesXApply() ... DONE
[10:30:51.135] Number of futures (= number of chunks): 2
[10:30:51.135] Launching 2 futures (chunks) ...
[10:30:51.135] Chunk #1 of 2 ...
[10:30:51.135]  - Finding globals in '...' for chunk #1 ...
[10:30:51.135] getGlobalsAndPackages() ...
[10:30:51.135] Searching for globals...
[10:30:51.135] 
[10:30:51.136] Searching for globals ... DONE
[10:30:51.136] - globals: [0] <none>
[10:30:51.136] getGlobalsAndPackages() ... DONE
[10:30:51.136]    + additional globals found: [n=0] 
[10:30:51.136]    + additional namespaces needed: [n=0] 
[10:30:51.136]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:51.136]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.136]  - seeds: <none>
[10:30:51.136]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.136] getGlobalsAndPackages() ...
[10:30:51.137] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.137] Resolving globals: FALSE
[10:30:51.137] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[10:30:51.138] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[10:30:51.138] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.138] 
[10:30:51.138] getGlobalsAndPackages() ... DONE
[10:30:51.141] run() for ‘Future’ ...
[10:30:51.141] - state: ‘created’
[10:30:51.141] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.145] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.145] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.145]   - Field: ‘label’
[10:30:51.146]   - Field: ‘local’
[10:30:51.146]   - Field: ‘owner’
[10:30:51.146]   - Field: ‘envir’
[10:30:51.146]   - Field: ‘workers’
[10:30:51.146]   - Field: ‘packages’
[10:30:51.146]   - Field: ‘gc’
[10:30:51.146]   - Field: ‘job’
[10:30:51.146]   - Field: ‘conditions’
[10:30:51.147]   - Field: ‘expr’
[10:30:51.147]   - Field: ‘uuid’
[10:30:51.147]   - Field: ‘seed’
[10:30:51.147]   - Field: ‘version’
[10:30:51.147]   - Field: ‘result’
[10:30:51.147]   - Field: ‘asynchronous’
[10:30:51.147]   - Field: ‘calls’
[10:30:51.147]   - Field: ‘globals’
[10:30:51.148]   - Field: ‘stdout’
[10:30:51.148]   - Field: ‘earlySignal’
[10:30:51.148]   - Field: ‘lazy’
[10:30:51.148]   - Field: ‘state’
[10:30:51.148] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.148] - Launch lazy future ...
[10:30:51.148] Packages needed by the future expression (n = 0): <none>
[10:30:51.149] Packages needed by future strategies (n = 0): <none>
[10:30:51.149] {
[10:30:51.149]     {
[10:30:51.149]         {
[10:30:51.149]             ...future.startTime <- base::Sys.time()
[10:30:51.149]             {
[10:30:51.149]                 {
[10:30:51.149]                   {
[10:30:51.149]                     {
[10:30:51.149]                       base::local({
[10:30:51.149]                         has_future <- base::requireNamespace("future", 
[10:30:51.149]                           quietly = TRUE)
[10:30:51.149]                         if (has_future) {
[10:30:51.149]                           ns <- base::getNamespace("future")
[10:30:51.149]                           version <- ns[[".package"]][["version"]]
[10:30:51.149]                           if (is.null(version)) 
[10:30:51.149]                             version <- utils::packageVersion("future")
[10:30:51.149]                         }
[10:30:51.149]                         else {
[10:30:51.149]                           version <- NULL
[10:30:51.149]                         }
[10:30:51.149]                         if (!has_future || version < "1.8.0") {
[10:30:51.149]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.149]                             "", base::R.version$version.string), 
[10:30:51.149]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:51.149]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:51.149]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.149]                               "release", "version")], collapse = " "), 
[10:30:51.149]                             hostname = base::Sys.info()[["nodename"]])
[10:30:51.149]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.149]                             info)
[10:30:51.149]                           info <- base::paste(info, collapse = "; ")
[10:30:51.149]                           if (!has_future) {
[10:30:51.149]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.149]                               info)
[10:30:51.149]                           }
[10:30:51.149]                           else {
[10:30:51.149]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.149]                               info, version)
[10:30:51.149]                           }
[10:30:51.149]                           base::stop(msg)
[10:30:51.149]                         }
[10:30:51.149]                       })
[10:30:51.149]                     }
[10:30:51.149]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.149]                     base::options(mc.cores = 1L)
[10:30:51.149]                   }
[10:30:51.149]                   ...future.strategy.old <- future::plan("list")
[10:30:51.149]                   options(future.plan = NULL)
[10:30:51.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.149]                 }
[10:30:51.149]                 ...future.workdir <- getwd()
[10:30:51.149]             }
[10:30:51.149]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.149]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.149]         }
[10:30:51.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.149]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.149]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.149]             base::names(...future.oldOptions))
[10:30:51.149]     }
[10:30:51.149]     if (FALSE) {
[10:30:51.149]     }
[10:30:51.149]     else {
[10:30:51.149]         if (TRUE) {
[10:30:51.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.149]                 open = "w")
[10:30:51.149]         }
[10:30:51.149]         else {
[10:30:51.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.149]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.149]         }
[10:30:51.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.149]             base::sink(type = "output", split = FALSE)
[10:30:51.149]             base::close(...future.stdout)
[10:30:51.149]         }, add = TRUE)
[10:30:51.149]     }
[10:30:51.149]     ...future.frame <- base::sys.nframe()
[10:30:51.149]     ...future.conditions <- base::list()
[10:30:51.149]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.149]     if (FALSE) {
[10:30:51.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.149]     }
[10:30:51.149]     ...future.result <- base::tryCatch({
[10:30:51.149]         base::withCallingHandlers({
[10:30:51.149]             ...future.value <- base::withVisible(base::local({
[10:30:51.149]                 withCallingHandlers({
[10:30:51.149]                   {
[10:30:51.149]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.149]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.149]                       ...future.globals.maxSize)) {
[10:30:51.149]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.149]                       on.exit(options(oopts), add = TRUE)
[10:30:51.149]                     }
[10:30:51.149]                     {
[10:30:51.149]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.149]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.149]                         USE.NAMES = FALSE)
[10:30:51.149]                       do.call(mapply, args = args)
[10:30:51.149]                     }
[10:30:51.149]                   }
[10:30:51.149]                 }, immediateCondition = function(cond) {
[10:30:51.149]                   save_rds <- function (object, pathname, ...) 
[10:30:51.149]                   {
[10:30:51.149]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.149]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.149]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.149]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.149]                         fi_tmp[["mtime"]])
[10:30:51.149]                     }
[10:30:51.149]                     tryCatch({
[10:30:51.149]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.149]                     }, error = function(ex) {
[10:30:51.149]                       msg <- conditionMessage(ex)
[10:30:51.149]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.149]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.149]                         fi_tmp[["mtime"]], msg)
[10:30:51.149]                       ex$message <- msg
[10:30:51.149]                       stop(ex)
[10:30:51.149]                     })
[10:30:51.149]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.149]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.149]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.149]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.149]                       fi <- file.info(pathname)
[10:30:51.149]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.149]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.149]                         fi[["size"]], fi[["mtime"]])
[10:30:51.149]                       stop(msg)
[10:30:51.149]                     }
[10:30:51.149]                     invisible(pathname)
[10:30:51.149]                   }
[10:30:51.149]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.149]                     rootPath = tempdir()) 
[10:30:51.149]                   {
[10:30:51.149]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.149]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.149]                       tmpdir = path, fileext = ".rds")
[10:30:51.149]                     save_rds(obj, file)
[10:30:51.149]                   }
[10:30:51.149]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.149]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.149]                   {
[10:30:51.149]                     inherits <- base::inherits
[10:30:51.149]                     invokeRestart <- base::invokeRestart
[10:30:51.149]                     is.null <- base::is.null
[10:30:51.149]                     muffled <- FALSE
[10:30:51.149]                     if (inherits(cond, "message")) {
[10:30:51.149]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.149]                       if (muffled) 
[10:30:51.149]                         invokeRestart("muffleMessage")
[10:30:51.149]                     }
[10:30:51.149]                     else if (inherits(cond, "warning")) {
[10:30:51.149]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.149]                       if (muffled) 
[10:30:51.149]                         invokeRestart("muffleWarning")
[10:30:51.149]                     }
[10:30:51.149]                     else if (inherits(cond, "condition")) {
[10:30:51.149]                       if (!is.null(pattern)) {
[10:30:51.149]                         computeRestarts <- base::computeRestarts
[10:30:51.149]                         grepl <- base::grepl
[10:30:51.149]                         restarts <- computeRestarts(cond)
[10:30:51.149]                         for (restart in restarts) {
[10:30:51.149]                           name <- restart$name
[10:30:51.149]                           if (is.null(name)) 
[10:30:51.149]                             next
[10:30:51.149]                           if (!grepl(pattern, name)) 
[10:30:51.149]                             next
[10:30:51.149]                           invokeRestart(restart)
[10:30:51.149]                           muffled <- TRUE
[10:30:51.149]                           break
[10:30:51.149]                         }
[10:30:51.149]                       }
[10:30:51.149]                     }
[10:30:51.149]                     invisible(muffled)
[10:30:51.149]                   }
[10:30:51.149]                   muffleCondition(cond)
[10:30:51.149]                 })
[10:30:51.149]             }))
[10:30:51.149]             future::FutureResult(value = ...future.value$value, 
[10:30:51.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.149]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.149]                     ...future.globalenv.names))
[10:30:51.149]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.149]         }, condition = base::local({
[10:30:51.149]             c <- base::c
[10:30:51.149]             inherits <- base::inherits
[10:30:51.149]             invokeRestart <- base::invokeRestart
[10:30:51.149]             length <- base::length
[10:30:51.149]             list <- base::list
[10:30:51.149]             seq.int <- base::seq.int
[10:30:51.149]             signalCondition <- base::signalCondition
[10:30:51.149]             sys.calls <- base::sys.calls
[10:30:51.149]             `[[` <- base::`[[`
[10:30:51.149]             `+` <- base::`+`
[10:30:51.149]             `<<-` <- base::`<<-`
[10:30:51.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.149]                   3L)]
[10:30:51.149]             }
[10:30:51.149]             function(cond) {
[10:30:51.149]                 is_error <- inherits(cond, "error")
[10:30:51.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.149]                   NULL)
[10:30:51.149]                 if (is_error) {
[10:30:51.149]                   sessionInformation <- function() {
[10:30:51.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.149]                       search = base::search(), system = base::Sys.info())
[10:30:51.149]                   }
[10:30:51.149]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.149]                     cond$call), session = sessionInformation(), 
[10:30:51.149]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.149]                   signalCondition(cond)
[10:30:51.149]                 }
[10:30:51.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.149]                 "immediateCondition"))) {
[10:30:51.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.149]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.149]                   if (TRUE && !signal) {
[10:30:51.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.149]                     {
[10:30:51.149]                       inherits <- base::inherits
[10:30:51.149]                       invokeRestart <- base::invokeRestart
[10:30:51.149]                       is.null <- base::is.null
[10:30:51.149]                       muffled <- FALSE
[10:30:51.149]                       if (inherits(cond, "message")) {
[10:30:51.149]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.149]                         if (muffled) 
[10:30:51.149]                           invokeRestart("muffleMessage")
[10:30:51.149]                       }
[10:30:51.149]                       else if (inherits(cond, "warning")) {
[10:30:51.149]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.149]                         if (muffled) 
[10:30:51.149]                           invokeRestart("muffleWarning")
[10:30:51.149]                       }
[10:30:51.149]                       else if (inherits(cond, "condition")) {
[10:30:51.149]                         if (!is.null(pattern)) {
[10:30:51.149]                           computeRestarts <- base::computeRestarts
[10:30:51.149]                           grepl <- base::grepl
[10:30:51.149]                           restarts <- computeRestarts(cond)
[10:30:51.149]                           for (restart in restarts) {
[10:30:51.149]                             name <- restart$name
[10:30:51.149]                             if (is.null(name)) 
[10:30:51.149]                               next
[10:30:51.149]                             if (!grepl(pattern, name)) 
[10:30:51.149]                               next
[10:30:51.149]                             invokeRestart(restart)
[10:30:51.149]                             muffled <- TRUE
[10:30:51.149]                             break
[10:30:51.149]                           }
[10:30:51.149]                         }
[10:30:51.149]                       }
[10:30:51.149]                       invisible(muffled)
[10:30:51.149]                     }
[10:30:51.149]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.149]                   }
[10:30:51.149]                 }
[10:30:51.149]                 else {
[10:30:51.149]                   if (TRUE) {
[10:30:51.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.149]                     {
[10:30:51.149]                       inherits <- base::inherits
[10:30:51.149]                       invokeRestart <- base::invokeRestart
[10:30:51.149]                       is.null <- base::is.null
[10:30:51.149]                       muffled <- FALSE
[10:30:51.149]                       if (inherits(cond, "message")) {
[10:30:51.149]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.149]                         if (muffled) 
[10:30:51.149]                           invokeRestart("muffleMessage")
[10:30:51.149]                       }
[10:30:51.149]                       else if (inherits(cond, "warning")) {
[10:30:51.149]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.149]                         if (muffled) 
[10:30:51.149]                           invokeRestart("muffleWarning")
[10:30:51.149]                       }
[10:30:51.149]                       else if (inherits(cond, "condition")) {
[10:30:51.149]                         if (!is.null(pattern)) {
[10:30:51.149]                           computeRestarts <- base::computeRestarts
[10:30:51.149]                           grepl <- base::grepl
[10:30:51.149]                           restarts <- computeRestarts(cond)
[10:30:51.149]                           for (restart in restarts) {
[10:30:51.149]                             name <- restart$name
[10:30:51.149]                             if (is.null(name)) 
[10:30:51.149]                               next
[10:30:51.149]                             if (!grepl(pattern, name)) 
[10:30:51.149]                               next
[10:30:51.149]                             invokeRestart(restart)
[10:30:51.149]                             muffled <- TRUE
[10:30:51.149]                             break
[10:30:51.149]                           }
[10:30:51.149]                         }
[10:30:51.149]                       }
[10:30:51.149]                       invisible(muffled)
[10:30:51.149]                     }
[10:30:51.149]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.149]                   }
[10:30:51.149]                 }
[10:30:51.149]             }
[10:30:51.149]         }))
[10:30:51.149]     }, error = function(ex) {
[10:30:51.149]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.149]                 ...future.rng), started = ...future.startTime, 
[10:30:51.149]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.149]             version = "1.8"), class = "FutureResult")
[10:30:51.149]     }, finally = {
[10:30:51.149]         if (!identical(...future.workdir, getwd())) 
[10:30:51.149]             setwd(...future.workdir)
[10:30:51.149]         {
[10:30:51.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.149]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.149]             }
[10:30:51.149]             base::options(...future.oldOptions)
[10:30:51.149]             if (.Platform$OS.type == "windows") {
[10:30:51.149]                 old_names <- names(...future.oldEnvVars)
[10:30:51.149]                 envs <- base::Sys.getenv()
[10:30:51.149]                 names <- names(envs)
[10:30:51.149]                 common <- intersect(names, old_names)
[10:30:51.149]                 added <- setdiff(names, old_names)
[10:30:51.149]                 removed <- setdiff(old_names, names)
[10:30:51.149]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.149]                   envs[common]]
[10:30:51.149]                 NAMES <- toupper(changed)
[10:30:51.149]                 args <- list()
[10:30:51.149]                 for (kk in seq_along(NAMES)) {
[10:30:51.149]                   name <- changed[[kk]]
[10:30:51.149]                   NAME <- NAMES[[kk]]
[10:30:51.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.149]                     next
[10:30:51.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.149]                 }
[10:30:51.149]                 NAMES <- toupper(added)
[10:30:51.149]                 for (kk in seq_along(NAMES)) {
[10:30:51.149]                   name <- added[[kk]]
[10:30:51.149]                   NAME <- NAMES[[kk]]
[10:30:51.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.149]                     next
[10:30:51.149]                   args[[name]] <- ""
[10:30:51.149]                 }
[10:30:51.149]                 NAMES <- toupper(removed)
[10:30:51.149]                 for (kk in seq_along(NAMES)) {
[10:30:51.149]                   name <- removed[[kk]]
[10:30:51.149]                   NAME <- NAMES[[kk]]
[10:30:51.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.149]                     next
[10:30:51.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.149]                 }
[10:30:51.149]                 if (length(args) > 0) 
[10:30:51.149]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.149]             }
[10:30:51.149]             else {
[10:30:51.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.149]             }
[10:30:51.149]             {
[10:30:51.149]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.149]                   0L) {
[10:30:51.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.149]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.149]                   base::options(opts)
[10:30:51.149]                 }
[10:30:51.149]                 {
[10:30:51.149]                   {
[10:30:51.149]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.149]                     NULL
[10:30:51.149]                   }
[10:30:51.149]                   options(future.plan = NULL)
[10:30:51.149]                   if (is.na(NA_character_)) 
[10:30:51.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.149]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.149]                     .init = FALSE)
[10:30:51.149]                 }
[10:30:51.149]             }
[10:30:51.149]         }
[10:30:51.149]     })
[10:30:51.149]     if (TRUE) {
[10:30:51.149]         base::sink(type = "output", split = FALSE)
[10:30:51.149]         if (TRUE) {
[10:30:51.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.149]         }
[10:30:51.149]         else {
[10:30:51.149]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.149]         }
[10:30:51.149]         base::close(...future.stdout)
[10:30:51.149]         ...future.stdout <- NULL
[10:30:51.149]     }
[10:30:51.149]     ...future.result$conditions <- ...future.conditions
[10:30:51.149]     ...future.result$finished <- base::Sys.time()
[10:30:51.149]     ...future.result
[10:30:51.149] }
[10:30:51.152] assign_globals() ...
[10:30:51.152] List of 5
[10:30:51.152]  $ ...future.FUN            :function (x, y)  
[10:30:51.152]  $ MoreArgs                 :List of 1
[10:30:51.152]   ..$ y: int [1:2] 3 4
[10:30:51.152]  $ ...future.elements_ii    :List of 1
[10:30:51.152]   ..$ x:List of 1
[10:30:51.152]   .. ..$ : int 1
[10:30:51.152]  $ ...future.seeds_ii       : NULL
[10:30:51.152]  $ ...future.globals.maxSize: NULL
[10:30:51.152]  - attr(*, "where")=List of 5
[10:30:51.152]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.152]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.152]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.152]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.152]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.152]  - attr(*, "resolved")= logi FALSE
[10:30:51.152]  - attr(*, "total_size")= num 1816
[10:30:51.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.152]  - attr(*, "already-done")= logi TRUE
[10:30:51.157] - reassign environment for ‘...future.FUN’
[10:30:51.157] - copied ‘...future.FUN’ to environment
[10:30:51.157] - copied ‘MoreArgs’ to environment
[10:30:51.157] - copied ‘...future.elements_ii’ to environment
[10:30:51.157] - copied ‘...future.seeds_ii’ to environment
[10:30:51.157] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.158] assign_globals() ... done
[10:30:51.158] requestCore(): workers = 2
[10:30:51.160] MulticoreFuture started
[10:30:51.160] - Launch lazy future ... done
[10:30:51.161] run() for ‘MulticoreFuture’ ... done
[10:30:51.161] Created future:
[10:30:51.161] plan(): Setting new future strategy stack:
[10:30:51.161] List of future strategies:
[10:30:51.161] 1. sequential:
[10:30:51.161]    - args: function (..., envir = parent.frame())
[10:30:51.161]    - tweaked: FALSE
[10:30:51.161]    - call: NULL
[10:30:51.162] plan(): nbrOfWorkers() = 1
[10:30:51.164] plan(): Setting new future strategy stack:
[10:30:51.164] List of future strategies:
[10:30:51.164] 1. multicore:
[10:30:51.164]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.164]    - tweaked: FALSE
[10:30:51.164]    - call: plan(strategy)
[10:30:51.170] plan(): nbrOfWorkers() = 2
[10:30:51.161] MulticoreFuture:
[10:30:51.161] Label: ‘future_.mapply-1’
[10:30:51.161] Expression:
[10:30:51.161] {
[10:30:51.161]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.161]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.161]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.161]         on.exit(options(oopts), add = TRUE)
[10:30:51.161]     }
[10:30:51.161]     {
[10:30:51.161]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.161]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.161]         do.call(mapply, args = args)
[10:30:51.161]     }
[10:30:51.161] }
[10:30:51.161] Lazy evaluation: FALSE
[10:30:51.161] Asynchronous evaluation: TRUE
[10:30:51.161] Local evaluation: TRUE
[10:30:51.161] Environment: R_GlobalEnv
[10:30:51.161] Capture standard output: TRUE
[10:30:51.161] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.161] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.161] Packages: <none>
[10:30:51.161] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:51.161] Resolved: TRUE
[10:30:51.161] Value: <not collected>
[10:30:51.161] Conditions captured: <none>
[10:30:51.161] Early signaling: FALSE
[10:30:51.161] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.161] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.171] Chunk #1 of 2 ... DONE
[10:30:51.172] Chunk #2 of 2 ...
[10:30:51.172]  - Finding globals in '...' for chunk #2 ...
[10:30:51.172] getGlobalsAndPackages() ...
[10:30:51.172] Searching for globals...
[10:30:51.173] 
[10:30:51.173] Searching for globals ... DONE
[10:30:51.173] - globals: [0] <none>
[10:30:51.173] getGlobalsAndPackages() ... DONE
[10:30:51.173]    + additional globals found: [n=0] 
[10:30:51.174]    + additional namespaces needed: [n=0] 
[10:30:51.174]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:51.174]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.174]  - seeds: <none>
[10:30:51.174]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.174] getGlobalsAndPackages() ...
[10:30:51.174] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.175] Resolving globals: FALSE
[10:30:51.176] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[10:30:51.176] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[10:30:51.177] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.177] 
[10:30:51.177] getGlobalsAndPackages() ... DONE
[10:30:51.178] run() for ‘Future’ ...
[10:30:51.178] - state: ‘created’
[10:30:51.178] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.188] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.189]   - Field: ‘label’
[10:30:51.189]   - Field: ‘local’
[10:30:51.189]   - Field: ‘owner’
[10:30:51.190]   - Field: ‘envir’
[10:30:51.190]   - Field: ‘workers’
[10:30:51.190]   - Field: ‘packages’
[10:30:51.191]   - Field: ‘gc’
[10:30:51.191]   - Field: ‘job’
[10:30:51.191]   - Field: ‘conditions’
[10:30:51.191]   - Field: ‘expr’
[10:30:51.191]   - Field: ‘uuid’
[10:30:51.192]   - Field: ‘seed’
[10:30:51.192]   - Field: ‘version’
[10:30:51.192]   - Field: ‘result’
[10:30:51.192]   - Field: ‘asynchronous’
[10:30:51.193]   - Field: ‘calls’
[10:30:51.193]   - Field: ‘globals’
[10:30:51.193]   - Field: ‘stdout’
[10:30:51.193]   - Field: ‘earlySignal’
[10:30:51.194]   - Field: ‘lazy’
[10:30:51.194]   - Field: ‘state’
[10:30:51.194] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.194] - Launch lazy future ...
[10:30:51.195] Packages needed by the future expression (n = 0): <none>
[10:30:51.195] Packages needed by future strategies (n = 0): <none>
[10:30:51.196] {
[10:30:51.196]     {
[10:30:51.196]         {
[10:30:51.196]             ...future.startTime <- base::Sys.time()
[10:30:51.196]             {
[10:30:51.196]                 {
[10:30:51.196]                   {
[10:30:51.196]                     {
[10:30:51.196]                       base::local({
[10:30:51.196]                         has_future <- base::requireNamespace("future", 
[10:30:51.196]                           quietly = TRUE)
[10:30:51.196]                         if (has_future) {
[10:30:51.196]                           ns <- base::getNamespace("future")
[10:30:51.196]                           version <- ns[[".package"]][["version"]]
[10:30:51.196]                           if (is.null(version)) 
[10:30:51.196]                             version <- utils::packageVersion("future")
[10:30:51.196]                         }
[10:30:51.196]                         else {
[10:30:51.196]                           version <- NULL
[10:30:51.196]                         }
[10:30:51.196]                         if (!has_future || version < "1.8.0") {
[10:30:51.196]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.196]                             "", base::R.version$version.string), 
[10:30:51.196]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:51.196]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:51.196]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.196]                               "release", "version")], collapse = " "), 
[10:30:51.196]                             hostname = base::Sys.info()[["nodename"]])
[10:30:51.196]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.196]                             info)
[10:30:51.196]                           info <- base::paste(info, collapse = "; ")
[10:30:51.196]                           if (!has_future) {
[10:30:51.196]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.196]                               info)
[10:30:51.196]                           }
[10:30:51.196]                           else {
[10:30:51.196]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.196]                               info, version)
[10:30:51.196]                           }
[10:30:51.196]                           base::stop(msg)
[10:30:51.196]                         }
[10:30:51.196]                       })
[10:30:51.196]                     }
[10:30:51.196]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.196]                     base::options(mc.cores = 1L)
[10:30:51.196]                   }
[10:30:51.196]                   ...future.strategy.old <- future::plan("list")
[10:30:51.196]                   options(future.plan = NULL)
[10:30:51.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.196]                 }
[10:30:51.196]                 ...future.workdir <- getwd()
[10:30:51.196]             }
[10:30:51.196]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.196]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.196]         }
[10:30:51.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.196]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.196]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.196]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.196]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.196]             base::names(...future.oldOptions))
[10:30:51.196]     }
[10:30:51.196]     if (FALSE) {
[10:30:51.196]     }
[10:30:51.196]     else {
[10:30:51.196]         if (TRUE) {
[10:30:51.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.196]                 open = "w")
[10:30:51.196]         }
[10:30:51.196]         else {
[10:30:51.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.196]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.196]         }
[10:30:51.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.196]             base::sink(type = "output", split = FALSE)
[10:30:51.196]             base::close(...future.stdout)
[10:30:51.196]         }, add = TRUE)
[10:30:51.196]     }
[10:30:51.196]     ...future.frame <- base::sys.nframe()
[10:30:51.196]     ...future.conditions <- base::list()
[10:30:51.196]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.196]     if (FALSE) {
[10:30:51.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.196]     }
[10:30:51.196]     ...future.result <- base::tryCatch({
[10:30:51.196]         base::withCallingHandlers({
[10:30:51.196]             ...future.value <- base::withVisible(base::local({
[10:30:51.196]                 withCallingHandlers({
[10:30:51.196]                   {
[10:30:51.196]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.196]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.196]                       ...future.globals.maxSize)) {
[10:30:51.196]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.196]                       on.exit(options(oopts), add = TRUE)
[10:30:51.196]                     }
[10:30:51.196]                     {
[10:30:51.196]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.196]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.196]                         USE.NAMES = FALSE)
[10:30:51.196]                       do.call(mapply, args = args)
[10:30:51.196]                     }
[10:30:51.196]                   }
[10:30:51.196]                 }, immediateCondition = function(cond) {
[10:30:51.196]                   save_rds <- function (object, pathname, ...) 
[10:30:51.196]                   {
[10:30:51.196]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.196]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.196]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.196]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.196]                         fi_tmp[["mtime"]])
[10:30:51.196]                     }
[10:30:51.196]                     tryCatch({
[10:30:51.196]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.196]                     }, error = function(ex) {
[10:30:51.196]                       msg <- conditionMessage(ex)
[10:30:51.196]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.196]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.196]                         fi_tmp[["mtime"]], msg)
[10:30:51.196]                       ex$message <- msg
[10:30:51.196]                       stop(ex)
[10:30:51.196]                     })
[10:30:51.196]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.196]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.196]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.196]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.196]                       fi <- file.info(pathname)
[10:30:51.196]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.196]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.196]                         fi[["size"]], fi[["mtime"]])
[10:30:51.196]                       stop(msg)
[10:30:51.196]                     }
[10:30:51.196]                     invisible(pathname)
[10:30:51.196]                   }
[10:30:51.196]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.196]                     rootPath = tempdir()) 
[10:30:51.196]                   {
[10:30:51.196]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.196]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.196]                       tmpdir = path, fileext = ".rds")
[10:30:51.196]                     save_rds(obj, file)
[10:30:51.196]                   }
[10:30:51.196]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.196]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.196]                   {
[10:30:51.196]                     inherits <- base::inherits
[10:30:51.196]                     invokeRestart <- base::invokeRestart
[10:30:51.196]                     is.null <- base::is.null
[10:30:51.196]                     muffled <- FALSE
[10:30:51.196]                     if (inherits(cond, "message")) {
[10:30:51.196]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.196]                       if (muffled) 
[10:30:51.196]                         invokeRestart("muffleMessage")
[10:30:51.196]                     }
[10:30:51.196]                     else if (inherits(cond, "warning")) {
[10:30:51.196]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.196]                       if (muffled) 
[10:30:51.196]                         invokeRestart("muffleWarning")
[10:30:51.196]                     }
[10:30:51.196]                     else if (inherits(cond, "condition")) {
[10:30:51.196]                       if (!is.null(pattern)) {
[10:30:51.196]                         computeRestarts <- base::computeRestarts
[10:30:51.196]                         grepl <- base::grepl
[10:30:51.196]                         restarts <- computeRestarts(cond)
[10:30:51.196]                         for (restart in restarts) {
[10:30:51.196]                           name <- restart$name
[10:30:51.196]                           if (is.null(name)) 
[10:30:51.196]                             next
[10:30:51.196]                           if (!grepl(pattern, name)) 
[10:30:51.196]                             next
[10:30:51.196]                           invokeRestart(restart)
[10:30:51.196]                           muffled <- TRUE
[10:30:51.196]                           break
[10:30:51.196]                         }
[10:30:51.196]                       }
[10:30:51.196]                     }
[10:30:51.196]                     invisible(muffled)
[10:30:51.196]                   }
[10:30:51.196]                   muffleCondition(cond)
[10:30:51.196]                 })
[10:30:51.196]             }))
[10:30:51.196]             future::FutureResult(value = ...future.value$value, 
[10:30:51.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.196]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.196]                     ...future.globalenv.names))
[10:30:51.196]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.196]         }, condition = base::local({
[10:30:51.196]             c <- base::c
[10:30:51.196]             inherits <- base::inherits
[10:30:51.196]             invokeRestart <- base::invokeRestart
[10:30:51.196]             length <- base::length
[10:30:51.196]             list <- base::list
[10:30:51.196]             seq.int <- base::seq.int
[10:30:51.196]             signalCondition <- base::signalCondition
[10:30:51.196]             sys.calls <- base::sys.calls
[10:30:51.196]             `[[` <- base::`[[`
[10:30:51.196]             `+` <- base::`+`
[10:30:51.196]             `<<-` <- base::`<<-`
[10:30:51.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.196]                   3L)]
[10:30:51.196]             }
[10:30:51.196]             function(cond) {
[10:30:51.196]                 is_error <- inherits(cond, "error")
[10:30:51.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.196]                   NULL)
[10:30:51.196]                 if (is_error) {
[10:30:51.196]                   sessionInformation <- function() {
[10:30:51.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.196]                       search = base::search(), system = base::Sys.info())
[10:30:51.196]                   }
[10:30:51.196]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.196]                     cond$call), session = sessionInformation(), 
[10:30:51.196]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.196]                   signalCondition(cond)
[10:30:51.196]                 }
[10:30:51.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.196]                 "immediateCondition"))) {
[10:30:51.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.196]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.196]                   if (TRUE && !signal) {
[10:30:51.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.196]                     {
[10:30:51.196]                       inherits <- base::inherits
[10:30:51.196]                       invokeRestart <- base::invokeRestart
[10:30:51.196]                       is.null <- base::is.null
[10:30:51.196]                       muffled <- FALSE
[10:30:51.196]                       if (inherits(cond, "message")) {
[10:30:51.196]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.196]                         if (muffled) 
[10:30:51.196]                           invokeRestart("muffleMessage")
[10:30:51.196]                       }
[10:30:51.196]                       else if (inherits(cond, "warning")) {
[10:30:51.196]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.196]                         if (muffled) 
[10:30:51.196]                           invokeRestart("muffleWarning")
[10:30:51.196]                       }
[10:30:51.196]                       else if (inherits(cond, "condition")) {
[10:30:51.196]                         if (!is.null(pattern)) {
[10:30:51.196]                           computeRestarts <- base::computeRestarts
[10:30:51.196]                           grepl <- base::grepl
[10:30:51.196]                           restarts <- computeRestarts(cond)
[10:30:51.196]                           for (restart in restarts) {
[10:30:51.196]                             name <- restart$name
[10:30:51.196]                             if (is.null(name)) 
[10:30:51.196]                               next
[10:30:51.196]                             if (!grepl(pattern, name)) 
[10:30:51.196]                               next
[10:30:51.196]                             invokeRestart(restart)
[10:30:51.196]                             muffled <- TRUE
[10:30:51.196]                             break
[10:30:51.196]                           }
[10:30:51.196]                         }
[10:30:51.196]                       }
[10:30:51.196]                       invisible(muffled)
[10:30:51.196]                     }
[10:30:51.196]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.196]                   }
[10:30:51.196]                 }
[10:30:51.196]                 else {
[10:30:51.196]                   if (TRUE) {
[10:30:51.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.196]                     {
[10:30:51.196]                       inherits <- base::inherits
[10:30:51.196]                       invokeRestart <- base::invokeRestart
[10:30:51.196]                       is.null <- base::is.null
[10:30:51.196]                       muffled <- FALSE
[10:30:51.196]                       if (inherits(cond, "message")) {
[10:30:51.196]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.196]                         if (muffled) 
[10:30:51.196]                           invokeRestart("muffleMessage")
[10:30:51.196]                       }
[10:30:51.196]                       else if (inherits(cond, "warning")) {
[10:30:51.196]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.196]                         if (muffled) 
[10:30:51.196]                           invokeRestart("muffleWarning")
[10:30:51.196]                       }
[10:30:51.196]                       else if (inherits(cond, "condition")) {
[10:30:51.196]                         if (!is.null(pattern)) {
[10:30:51.196]                           computeRestarts <- base::computeRestarts
[10:30:51.196]                           grepl <- base::grepl
[10:30:51.196]                           restarts <- computeRestarts(cond)
[10:30:51.196]                           for (restart in restarts) {
[10:30:51.196]                             name <- restart$name
[10:30:51.196]                             if (is.null(name)) 
[10:30:51.196]                               next
[10:30:51.196]                             if (!grepl(pattern, name)) 
[10:30:51.196]                               next
[10:30:51.196]                             invokeRestart(restart)
[10:30:51.196]                             muffled <- TRUE
[10:30:51.196]                             break
[10:30:51.196]                           }
[10:30:51.196]                         }
[10:30:51.196]                       }
[10:30:51.196]                       invisible(muffled)
[10:30:51.196]                     }
[10:30:51.196]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.196]                   }
[10:30:51.196]                 }
[10:30:51.196]             }
[10:30:51.196]         }))
[10:30:51.196]     }, error = function(ex) {
[10:30:51.196]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.196]                 ...future.rng), started = ...future.startTime, 
[10:30:51.196]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.196]             version = "1.8"), class = "FutureResult")
[10:30:51.196]     }, finally = {
[10:30:51.196]         if (!identical(...future.workdir, getwd())) 
[10:30:51.196]             setwd(...future.workdir)
[10:30:51.196]         {
[10:30:51.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.196]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.196]             }
[10:30:51.196]             base::options(...future.oldOptions)
[10:30:51.196]             if (.Platform$OS.type == "windows") {
[10:30:51.196]                 old_names <- names(...future.oldEnvVars)
[10:30:51.196]                 envs <- base::Sys.getenv()
[10:30:51.196]                 names <- names(envs)
[10:30:51.196]                 common <- intersect(names, old_names)
[10:30:51.196]                 added <- setdiff(names, old_names)
[10:30:51.196]                 removed <- setdiff(old_names, names)
[10:30:51.196]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.196]                   envs[common]]
[10:30:51.196]                 NAMES <- toupper(changed)
[10:30:51.196]                 args <- list()
[10:30:51.196]                 for (kk in seq_along(NAMES)) {
[10:30:51.196]                   name <- changed[[kk]]
[10:30:51.196]                   NAME <- NAMES[[kk]]
[10:30:51.196]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.196]                     next
[10:30:51.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.196]                 }
[10:30:51.196]                 NAMES <- toupper(added)
[10:30:51.196]                 for (kk in seq_along(NAMES)) {
[10:30:51.196]                   name <- added[[kk]]
[10:30:51.196]                   NAME <- NAMES[[kk]]
[10:30:51.196]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.196]                     next
[10:30:51.196]                   args[[name]] <- ""
[10:30:51.196]                 }
[10:30:51.196]                 NAMES <- toupper(removed)
[10:30:51.196]                 for (kk in seq_along(NAMES)) {
[10:30:51.196]                   name <- removed[[kk]]
[10:30:51.196]                   NAME <- NAMES[[kk]]
[10:30:51.196]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.196]                     next
[10:30:51.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.196]                 }
[10:30:51.196]                 if (length(args) > 0) 
[10:30:51.196]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.196]             }
[10:30:51.196]             else {
[10:30:51.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.196]             }
[10:30:51.196]             {
[10:30:51.196]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.196]                   0L) {
[10:30:51.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.196]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.196]                   base::options(opts)
[10:30:51.196]                 }
[10:30:51.196]                 {
[10:30:51.196]                   {
[10:30:51.196]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.196]                     NULL
[10:30:51.196]                   }
[10:30:51.196]                   options(future.plan = NULL)
[10:30:51.196]                   if (is.na(NA_character_)) 
[10:30:51.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.196]                     .init = FALSE)
[10:30:51.196]                 }
[10:30:51.196]             }
[10:30:51.196]         }
[10:30:51.196]     })
[10:30:51.196]     if (TRUE) {
[10:30:51.196]         base::sink(type = "output", split = FALSE)
[10:30:51.196]         if (TRUE) {
[10:30:51.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.196]         }
[10:30:51.196]         else {
[10:30:51.196]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.196]         }
[10:30:51.196]         base::close(...future.stdout)
[10:30:51.196]         ...future.stdout <- NULL
[10:30:51.196]     }
[10:30:51.196]     ...future.result$conditions <- ...future.conditions
[10:30:51.196]     ...future.result$finished <- base::Sys.time()
[10:30:51.196]     ...future.result
[10:30:51.196] }
[10:30:51.199] assign_globals() ...
[10:30:51.199] List of 5
[10:30:51.199]  $ ...future.FUN            :function (x, y)  
[10:30:51.199]  $ MoreArgs                 :List of 1
[10:30:51.199]   ..$ y: int [1:2] 3 4
[10:30:51.199]  $ ...future.elements_ii    :List of 1
[10:30:51.199]   ..$ x:List of 1
[10:30:51.199]   .. ..$ : int 2
[10:30:51.199]  $ ...future.seeds_ii       : NULL
[10:30:51.199]  $ ...future.globals.maxSize: NULL
[10:30:51.199]  - attr(*, "where")=List of 5
[10:30:51.199]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.199]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.199]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.199]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.199]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.199]  - attr(*, "resolved")= logi FALSE
[10:30:51.199]  - attr(*, "total_size")= num 1816
[10:30:51.199]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.199]  - attr(*, "already-done")= logi TRUE
[10:30:51.208] - reassign environment for ‘...future.FUN’
[10:30:51.208] - copied ‘...future.FUN’ to environment
[10:30:51.208] - copied ‘MoreArgs’ to environment
[10:30:51.208] - copied ‘...future.elements_ii’ to environment
[10:30:51.209] - copied ‘...future.seeds_ii’ to environment
[10:30:51.209] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.209] assign_globals() ... done
[10:30:51.209] requestCore(): workers = 2
[10:30:51.212] MulticoreFuture started
[10:30:51.212] - Launch lazy future ... done
[10:30:51.212] run() for ‘MulticoreFuture’ ... done
[10:30:51.213] Created future:
[10:30:51.213] plan(): Setting new future strategy stack:
[10:30:51.213] List of future strategies:
[10:30:51.213] 1. sequential:
[10:30:51.213]    - args: function (..., envir = parent.frame())
[10:30:51.213]    - tweaked: FALSE
[10:30:51.213]    - call: NULL
[10:30:51.214] plan(): nbrOfWorkers() = 1
[10:30:51.216] plan(): Setting new future strategy stack:
[10:30:51.216] List of future strategies:
[10:30:51.216] 1. multicore:
[10:30:51.216]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.216]    - tweaked: FALSE
[10:30:51.216]    - call: plan(strategy)
[10:30:51.221] plan(): nbrOfWorkers() = 2
[10:30:51.213] MulticoreFuture:
[10:30:51.213] Label: ‘future_.mapply-2’
[10:30:51.213] Expression:
[10:30:51.213] {
[10:30:51.213]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.213]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.213]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.213]         on.exit(options(oopts), add = TRUE)
[10:30:51.213]     }
[10:30:51.213]     {
[10:30:51.213]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.213]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.213]         do.call(mapply, args = args)
[10:30:51.213]     }
[10:30:51.213] }
[10:30:51.213] Lazy evaluation: FALSE
[10:30:51.213] Asynchronous evaluation: TRUE
[10:30:51.213] Local evaluation: TRUE
[10:30:51.213] Environment: R_GlobalEnv
[10:30:51.213] Capture standard output: TRUE
[10:30:51.213] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.213] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.213] Packages: <none>
[10:30:51.213] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:51.213] Resolved: TRUE
[10:30:51.213] Value: <not collected>
[10:30:51.213] Conditions captured: <none>
[10:30:51.213] Early signaling: FALSE
[10:30:51.213] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.213] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.222] Chunk #2 of 2 ... DONE
[10:30:51.223] Launching 2 futures (chunks) ... DONE
[10:30:51.223] Resolving 2 futures (chunks) ...
[10:30:51.223] resolve() on list ...
[10:30:51.223]  recursive: 0
[10:30:51.223]  length: 2
[10:30:51.223] 
[10:30:51.224] Future #1
[10:30:51.224] result() for MulticoreFuture ...
[10:30:51.225] result() for MulticoreFuture ...
[10:30:51.225] result() for MulticoreFuture ... done
[10:30:51.225] result() for MulticoreFuture ... done
[10:30:51.225] result() for MulticoreFuture ...
[10:30:51.225] result() for MulticoreFuture ... done
[10:30:51.226] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:51.226] - nx: 2
[10:30:51.226] - relay: TRUE
[10:30:51.226] - stdout: TRUE
[10:30:51.226] - signal: TRUE
[10:30:51.226] - resignal: FALSE
[10:30:51.226] - force: TRUE
[10:30:51.227] - relayed: [n=2] FALSE, FALSE
[10:30:51.227] - queued futures: [n=2] FALSE, FALSE
[10:30:51.227]  - until=1
[10:30:51.227]  - relaying element #1
[10:30:51.227] result() for MulticoreFuture ...
[10:30:51.227] result() for MulticoreFuture ... done
[10:30:51.227] result() for MulticoreFuture ...
[10:30:51.228] result() for MulticoreFuture ... done
[10:30:51.228] result() for MulticoreFuture ...
[10:30:51.228] result() for MulticoreFuture ... done
[10:30:51.228] result() for MulticoreFuture ...
[10:30:51.228] result() for MulticoreFuture ... done
[10:30:51.228] - relayed: [n=2] TRUE, FALSE
[10:30:51.229] - queued futures: [n=2] TRUE, FALSE
[10:30:51.229] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:51.229]  length: 1 (resolved future 1)
[10:30:51.229] Future #2
[10:30:51.230] result() for MulticoreFuture ...
[10:30:51.230] result() for MulticoreFuture ...
[10:30:51.230] result() for MulticoreFuture ... done
[10:30:51.231] result() for MulticoreFuture ... done
[10:30:51.231] result() for MulticoreFuture ...
[10:30:51.231] result() for MulticoreFuture ... done
[10:30:51.231] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:51.231] - nx: 2
[10:30:51.231] - relay: TRUE
[10:30:51.231] - stdout: TRUE
[10:30:51.232] - signal: TRUE
[10:30:51.235] - resignal: FALSE
[10:30:51.235] - force: TRUE
[10:30:51.235] - relayed: [n=2] TRUE, FALSE
[10:30:51.235] - queued futures: [n=2] TRUE, FALSE
[10:30:51.236]  - until=2
[10:30:51.236]  - relaying element #2
[10:30:51.236] result() for MulticoreFuture ...
[10:30:51.236] result() for MulticoreFuture ... done
[10:30:51.237] result() for MulticoreFuture ...
[10:30:51.237] result() for MulticoreFuture ... done
[10:30:51.237] result() for MulticoreFuture ...
[10:30:51.237] result() for MulticoreFuture ... done
[10:30:51.237] result() for MulticoreFuture ...
[10:30:51.238] result() for MulticoreFuture ... done
[10:30:51.238] - relayed: [n=2] TRUE, TRUE
[10:30:51.238] - queued futures: [n=2] TRUE, TRUE
[10:30:51.238] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:51.238]  length: 0 (resolved future 2)
[10:30:51.238] Relaying remaining futures
[10:30:51.238] signalConditionsASAP(NULL, pos=0) ...
[10:30:51.239] - nx: 2
[10:30:51.239] - relay: TRUE
[10:30:51.239] - stdout: TRUE
[10:30:51.239] - signal: TRUE
[10:30:51.239] - resignal: FALSE
[10:30:51.239] - force: TRUE
[10:30:51.239] - relayed: [n=2] TRUE, TRUE
[10:30:51.240] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:51.240] - relayed: [n=2] TRUE, TRUE
[10:30:51.240] - queued futures: [n=2] TRUE, TRUE
[10:30:51.240] signalConditionsASAP(NULL, pos=0) ... done
[10:30:51.240] resolve() on list ... DONE
[10:30:51.240] result() for MulticoreFuture ...
[10:30:51.241] result() for MulticoreFuture ... done
[10:30:51.241] result() for MulticoreFuture ...
[10:30:51.241] result() for MulticoreFuture ... done
[10:30:51.241] result() for MulticoreFuture ...
[10:30:51.241] result() for MulticoreFuture ... done
[10:30:51.241] result() for MulticoreFuture ...
[10:30:51.242] result() for MulticoreFuture ... done
[10:30:51.242]  - Number of value chunks collected: 2
[10:30:51.242] Resolving 2 futures (chunks) ... DONE
[10:30:51.242] Reducing values from 2 chunks ...
[10:30:51.242]  - Number of values collected after concatenation: 2
[10:30:51.242]  - Number of values expected: 2
[10:30:51.242] Reducing values from 2 chunks ... DONE
[10:30:51.243] future_mapply() ... DONE
- Recycle arguments to same length ...
[10:30:51.243] future_mapply() ...
[10:30:51.247] Number of chunks: 2
[10:30:51.248] getGlobalsAndPackagesXApply() ...
[10:30:51.248]  - future.globals: TRUE
[10:30:51.248] getGlobalsAndPackages() ...
[10:30:51.248] Searching for globals...
[10:30:51.249] - globals found: [1] ‘FUN’
[10:30:51.249] Searching for globals ... DONE
[10:30:51.249] Resolving globals: FALSE
[10:30:51.250] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:51.250] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:51.250] - globals: [1] ‘FUN’
[10:30:51.250] 
[10:30:51.250] getGlobalsAndPackages() ... DONE
[10:30:51.250]  - globals found/used: [n=1] ‘FUN’
[10:30:51.251]  - needed namespaces: [n=0] 
[10:30:51.251] Finding globals ... DONE
[10:30:51.251] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:51.251] List of 2
[10:30:51.251]  $ ...future.FUN:function (x, ...)  
[10:30:51.251]  $ MoreArgs     : NULL
[10:30:51.251]  - attr(*, "where")=List of 2
[10:30:51.251]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:51.251]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:51.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.251]  - attr(*, "resolved")= logi FALSE
[10:30:51.251]  - attr(*, "total_size")= num NA
[10:30:51.254] Packages to be attached in all futures: [n=0] 
[10:30:51.254] getGlobalsAndPackagesXApply() ... DONE
[10:30:51.254] Number of futures (= number of chunks): 2
[10:30:51.254] Launching 2 futures (chunks) ...
[10:30:51.254] Chunk #1 of 2 ...
[10:30:51.255]  - Finding globals in '...' for chunk #1 ...
[10:30:51.255] getGlobalsAndPackages() ...
[10:30:51.255] Searching for globals...
[10:30:51.255] 
[10:30:51.255] Searching for globals ... DONE
[10:30:51.255] - globals: [0] <none>
[10:30:51.255] getGlobalsAndPackages() ... DONE
[10:30:51.256]    + additional globals found: [n=0] 
[10:30:51.256]    + additional namespaces needed: [n=0] 
[10:30:51.256]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:51.256]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.256]  - seeds: <none>
[10:30:51.256]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.256] getGlobalsAndPackages() ...
[10:30:51.256] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.256] Resolving globals: FALSE
[10:30:51.257] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:51.257] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:51.257] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.258] 
[10:30:51.258] getGlobalsAndPackages() ... DONE
[10:30:51.258] run() for ‘Future’ ...
[10:30:51.258] - state: ‘created’
[10:30:51.258] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.262] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.262] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.262]   - Field: ‘label’
[10:30:51.262]   - Field: ‘local’
[10:30:51.263]   - Field: ‘owner’
[10:30:51.265]   - Field: ‘envir’
[10:30:51.265]   - Field: ‘workers’
[10:30:51.265]   - Field: ‘packages’
[10:30:51.265]   - Field: ‘gc’
[10:30:51.266]   - Field: ‘job’
[10:30:51.266]   - Field: ‘conditions’
[10:30:51.266]   - Field: ‘expr’
[10:30:51.266]   - Field: ‘uuid’
[10:30:51.266]   - Field: ‘seed’
[10:30:51.266]   - Field: ‘version’
[10:30:51.266]   - Field: ‘result’
[10:30:51.266]   - Field: ‘asynchronous’
[10:30:51.267]   - Field: ‘calls’
[10:30:51.267]   - Field: ‘globals’
[10:30:51.267]   - Field: ‘stdout’
[10:30:51.267]   - Field: ‘earlySignal’
[10:30:51.267]   - Field: ‘lazy’
[10:30:51.267]   - Field: ‘state’
[10:30:51.267] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.267] - Launch lazy future ...
[10:30:51.268] Packages needed by the future expression (n = 0): <none>
[10:30:51.268] Packages needed by future strategies (n = 0): <none>
[10:30:51.268] {
[10:30:51.268]     {
[10:30:51.268]         {
[10:30:51.268]             ...future.startTime <- base::Sys.time()
[10:30:51.268]             {
[10:30:51.268]                 {
[10:30:51.268]                   {
[10:30:51.268]                     {
[10:30:51.268]                       base::local({
[10:30:51.268]                         has_future <- base::requireNamespace("future", 
[10:30:51.268]                           quietly = TRUE)
[10:30:51.268]                         if (has_future) {
[10:30:51.268]                           ns <- base::getNamespace("future")
[10:30:51.268]                           version <- ns[[".package"]][["version"]]
[10:30:51.268]                           if (is.null(version)) 
[10:30:51.268]                             version <- utils::packageVersion("future")
[10:30:51.268]                         }
[10:30:51.268]                         else {
[10:30:51.268]                           version <- NULL
[10:30:51.268]                         }
[10:30:51.268]                         if (!has_future || version < "1.8.0") {
[10:30:51.268]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.268]                             "", base::R.version$version.string), 
[10:30:51.268]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:51.268]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:51.268]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.268]                               "release", "version")], collapse = " "), 
[10:30:51.268]                             hostname = base::Sys.info()[["nodename"]])
[10:30:51.268]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.268]                             info)
[10:30:51.268]                           info <- base::paste(info, collapse = "; ")
[10:30:51.268]                           if (!has_future) {
[10:30:51.268]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.268]                               info)
[10:30:51.268]                           }
[10:30:51.268]                           else {
[10:30:51.268]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.268]                               info, version)
[10:30:51.268]                           }
[10:30:51.268]                           base::stop(msg)
[10:30:51.268]                         }
[10:30:51.268]                       })
[10:30:51.268]                     }
[10:30:51.268]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.268]                     base::options(mc.cores = 1L)
[10:30:51.268]                   }
[10:30:51.268]                   ...future.strategy.old <- future::plan("list")
[10:30:51.268]                   options(future.plan = NULL)
[10:30:51.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.268]                 }
[10:30:51.268]                 ...future.workdir <- getwd()
[10:30:51.268]             }
[10:30:51.268]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.268]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.268]         }
[10:30:51.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.268]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.268]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.268]             base::names(...future.oldOptions))
[10:30:51.268]     }
[10:30:51.268]     if (FALSE) {
[10:30:51.268]     }
[10:30:51.268]     else {
[10:30:51.268]         if (TRUE) {
[10:30:51.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.268]                 open = "w")
[10:30:51.268]         }
[10:30:51.268]         else {
[10:30:51.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.268]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.268]         }
[10:30:51.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.268]             base::sink(type = "output", split = FALSE)
[10:30:51.268]             base::close(...future.stdout)
[10:30:51.268]         }, add = TRUE)
[10:30:51.268]     }
[10:30:51.268]     ...future.frame <- base::sys.nframe()
[10:30:51.268]     ...future.conditions <- base::list()
[10:30:51.268]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.268]     if (FALSE) {
[10:30:51.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.268]     }
[10:30:51.268]     ...future.result <- base::tryCatch({
[10:30:51.268]         base::withCallingHandlers({
[10:30:51.268]             ...future.value <- base::withVisible(base::local({
[10:30:51.268]                 withCallingHandlers({
[10:30:51.268]                   {
[10:30:51.268]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.268]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.268]                       ...future.globals.maxSize)) {
[10:30:51.268]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.268]                       on.exit(options(oopts), add = TRUE)
[10:30:51.268]                     }
[10:30:51.268]                     {
[10:30:51.268]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.268]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.268]                         USE.NAMES = FALSE)
[10:30:51.268]                       do.call(mapply, args = args)
[10:30:51.268]                     }
[10:30:51.268]                   }
[10:30:51.268]                 }, immediateCondition = function(cond) {
[10:30:51.268]                   save_rds <- function (object, pathname, ...) 
[10:30:51.268]                   {
[10:30:51.268]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.268]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.268]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.268]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.268]                         fi_tmp[["mtime"]])
[10:30:51.268]                     }
[10:30:51.268]                     tryCatch({
[10:30:51.268]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.268]                     }, error = function(ex) {
[10:30:51.268]                       msg <- conditionMessage(ex)
[10:30:51.268]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.268]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.268]                         fi_tmp[["mtime"]], msg)
[10:30:51.268]                       ex$message <- msg
[10:30:51.268]                       stop(ex)
[10:30:51.268]                     })
[10:30:51.268]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.268]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.268]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.268]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.268]                       fi <- file.info(pathname)
[10:30:51.268]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.268]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.268]                         fi[["size"]], fi[["mtime"]])
[10:30:51.268]                       stop(msg)
[10:30:51.268]                     }
[10:30:51.268]                     invisible(pathname)
[10:30:51.268]                   }
[10:30:51.268]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.268]                     rootPath = tempdir()) 
[10:30:51.268]                   {
[10:30:51.268]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.268]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.268]                       tmpdir = path, fileext = ".rds")
[10:30:51.268]                     save_rds(obj, file)
[10:30:51.268]                   }
[10:30:51.268]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.268]                   {
[10:30:51.268]                     inherits <- base::inherits
[10:30:51.268]                     invokeRestart <- base::invokeRestart
[10:30:51.268]                     is.null <- base::is.null
[10:30:51.268]                     muffled <- FALSE
[10:30:51.268]                     if (inherits(cond, "message")) {
[10:30:51.268]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.268]                       if (muffled) 
[10:30:51.268]                         invokeRestart("muffleMessage")
[10:30:51.268]                     }
[10:30:51.268]                     else if (inherits(cond, "warning")) {
[10:30:51.268]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.268]                       if (muffled) 
[10:30:51.268]                         invokeRestart("muffleWarning")
[10:30:51.268]                     }
[10:30:51.268]                     else if (inherits(cond, "condition")) {
[10:30:51.268]                       if (!is.null(pattern)) {
[10:30:51.268]                         computeRestarts <- base::computeRestarts
[10:30:51.268]                         grepl <- base::grepl
[10:30:51.268]                         restarts <- computeRestarts(cond)
[10:30:51.268]                         for (restart in restarts) {
[10:30:51.268]                           name <- restart$name
[10:30:51.268]                           if (is.null(name)) 
[10:30:51.268]                             next
[10:30:51.268]                           if (!grepl(pattern, name)) 
[10:30:51.268]                             next
[10:30:51.268]                           invokeRestart(restart)
[10:30:51.268]                           muffled <- TRUE
[10:30:51.268]                           break
[10:30:51.268]                         }
[10:30:51.268]                       }
[10:30:51.268]                     }
[10:30:51.268]                     invisible(muffled)
[10:30:51.268]                   }
[10:30:51.268]                   muffleCondition(cond)
[10:30:51.268]                 })
[10:30:51.268]             }))
[10:30:51.268]             future::FutureResult(value = ...future.value$value, 
[10:30:51.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.268]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.268]                     ...future.globalenv.names))
[10:30:51.268]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.268]         }, condition = base::local({
[10:30:51.268]             c <- base::c
[10:30:51.268]             inherits <- base::inherits
[10:30:51.268]             invokeRestart <- base::invokeRestart
[10:30:51.268]             length <- base::length
[10:30:51.268]             list <- base::list
[10:30:51.268]             seq.int <- base::seq.int
[10:30:51.268]             signalCondition <- base::signalCondition
[10:30:51.268]             sys.calls <- base::sys.calls
[10:30:51.268]             `[[` <- base::`[[`
[10:30:51.268]             `+` <- base::`+`
[10:30:51.268]             `<<-` <- base::`<<-`
[10:30:51.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.268]                   3L)]
[10:30:51.268]             }
[10:30:51.268]             function(cond) {
[10:30:51.268]                 is_error <- inherits(cond, "error")
[10:30:51.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.268]                   NULL)
[10:30:51.268]                 if (is_error) {
[10:30:51.268]                   sessionInformation <- function() {
[10:30:51.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.268]                       search = base::search(), system = base::Sys.info())
[10:30:51.268]                   }
[10:30:51.268]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.268]                     cond$call), session = sessionInformation(), 
[10:30:51.268]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.268]                   signalCondition(cond)
[10:30:51.268]                 }
[10:30:51.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.268]                 "immediateCondition"))) {
[10:30:51.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.268]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.268]                   if (TRUE && !signal) {
[10:30:51.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.268]                     {
[10:30:51.268]                       inherits <- base::inherits
[10:30:51.268]                       invokeRestart <- base::invokeRestart
[10:30:51.268]                       is.null <- base::is.null
[10:30:51.268]                       muffled <- FALSE
[10:30:51.268]                       if (inherits(cond, "message")) {
[10:30:51.268]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.268]                         if (muffled) 
[10:30:51.268]                           invokeRestart("muffleMessage")
[10:30:51.268]                       }
[10:30:51.268]                       else if (inherits(cond, "warning")) {
[10:30:51.268]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.268]                         if (muffled) 
[10:30:51.268]                           invokeRestart("muffleWarning")
[10:30:51.268]                       }
[10:30:51.268]                       else if (inherits(cond, "condition")) {
[10:30:51.268]                         if (!is.null(pattern)) {
[10:30:51.268]                           computeRestarts <- base::computeRestarts
[10:30:51.268]                           grepl <- base::grepl
[10:30:51.268]                           restarts <- computeRestarts(cond)
[10:30:51.268]                           for (restart in restarts) {
[10:30:51.268]                             name <- restart$name
[10:30:51.268]                             if (is.null(name)) 
[10:30:51.268]                               next
[10:30:51.268]                             if (!grepl(pattern, name)) 
[10:30:51.268]                               next
[10:30:51.268]                             invokeRestart(restart)
[10:30:51.268]                             muffled <- TRUE
[10:30:51.268]                             break
[10:30:51.268]                           }
[10:30:51.268]                         }
[10:30:51.268]                       }
[10:30:51.268]                       invisible(muffled)
[10:30:51.268]                     }
[10:30:51.268]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.268]                   }
[10:30:51.268]                 }
[10:30:51.268]                 else {
[10:30:51.268]                   if (TRUE) {
[10:30:51.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.268]                     {
[10:30:51.268]                       inherits <- base::inherits
[10:30:51.268]                       invokeRestart <- base::invokeRestart
[10:30:51.268]                       is.null <- base::is.null
[10:30:51.268]                       muffled <- FALSE
[10:30:51.268]                       if (inherits(cond, "message")) {
[10:30:51.268]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.268]                         if (muffled) 
[10:30:51.268]                           invokeRestart("muffleMessage")
[10:30:51.268]                       }
[10:30:51.268]                       else if (inherits(cond, "warning")) {
[10:30:51.268]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.268]                         if (muffled) 
[10:30:51.268]                           invokeRestart("muffleWarning")
[10:30:51.268]                       }
[10:30:51.268]                       else if (inherits(cond, "condition")) {
[10:30:51.268]                         if (!is.null(pattern)) {
[10:30:51.268]                           computeRestarts <- base::computeRestarts
[10:30:51.268]                           grepl <- base::grepl
[10:30:51.268]                           restarts <- computeRestarts(cond)
[10:30:51.268]                           for (restart in restarts) {
[10:30:51.268]                             name <- restart$name
[10:30:51.268]                             if (is.null(name)) 
[10:30:51.268]                               next
[10:30:51.268]                             if (!grepl(pattern, name)) 
[10:30:51.268]                               next
[10:30:51.268]                             invokeRestart(restart)
[10:30:51.268]                             muffled <- TRUE
[10:30:51.268]                             break
[10:30:51.268]                           }
[10:30:51.268]                         }
[10:30:51.268]                       }
[10:30:51.268]                       invisible(muffled)
[10:30:51.268]                     }
[10:30:51.268]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.268]                   }
[10:30:51.268]                 }
[10:30:51.268]             }
[10:30:51.268]         }))
[10:30:51.268]     }, error = function(ex) {
[10:30:51.268]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.268]                 ...future.rng), started = ...future.startTime, 
[10:30:51.268]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.268]             version = "1.8"), class = "FutureResult")
[10:30:51.268]     }, finally = {
[10:30:51.268]         if (!identical(...future.workdir, getwd())) 
[10:30:51.268]             setwd(...future.workdir)
[10:30:51.268]         {
[10:30:51.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.268]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.268]             }
[10:30:51.268]             base::options(...future.oldOptions)
[10:30:51.268]             if (.Platform$OS.type == "windows") {
[10:30:51.268]                 old_names <- names(...future.oldEnvVars)
[10:30:51.268]                 envs <- base::Sys.getenv()
[10:30:51.268]                 names <- names(envs)
[10:30:51.268]                 common <- intersect(names, old_names)
[10:30:51.268]                 added <- setdiff(names, old_names)
[10:30:51.268]                 removed <- setdiff(old_names, names)
[10:30:51.268]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.268]                   envs[common]]
[10:30:51.268]                 NAMES <- toupper(changed)
[10:30:51.268]                 args <- list()
[10:30:51.268]                 for (kk in seq_along(NAMES)) {
[10:30:51.268]                   name <- changed[[kk]]
[10:30:51.268]                   NAME <- NAMES[[kk]]
[10:30:51.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.268]                     next
[10:30:51.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.268]                 }
[10:30:51.268]                 NAMES <- toupper(added)
[10:30:51.268]                 for (kk in seq_along(NAMES)) {
[10:30:51.268]                   name <- added[[kk]]
[10:30:51.268]                   NAME <- NAMES[[kk]]
[10:30:51.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.268]                     next
[10:30:51.268]                   args[[name]] <- ""
[10:30:51.268]                 }
[10:30:51.268]                 NAMES <- toupper(removed)
[10:30:51.268]                 for (kk in seq_along(NAMES)) {
[10:30:51.268]                   name <- removed[[kk]]
[10:30:51.268]                   NAME <- NAMES[[kk]]
[10:30:51.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.268]                     next
[10:30:51.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.268]                 }
[10:30:51.268]                 if (length(args) > 0) 
[10:30:51.268]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.268]             }
[10:30:51.268]             else {
[10:30:51.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.268]             }
[10:30:51.268]             {
[10:30:51.268]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.268]                   0L) {
[10:30:51.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.268]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.268]                   base::options(opts)
[10:30:51.268]                 }
[10:30:51.268]                 {
[10:30:51.268]                   {
[10:30:51.268]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.268]                     NULL
[10:30:51.268]                   }
[10:30:51.268]                   options(future.plan = NULL)
[10:30:51.268]                   if (is.na(NA_character_)) 
[10:30:51.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.268]                     .init = FALSE)
[10:30:51.268]                 }
[10:30:51.268]             }
[10:30:51.268]         }
[10:30:51.268]     })
[10:30:51.268]     if (TRUE) {
[10:30:51.268]         base::sink(type = "output", split = FALSE)
[10:30:51.268]         if (TRUE) {
[10:30:51.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.268]         }
[10:30:51.268]         else {
[10:30:51.268]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.268]         }
[10:30:51.268]         base::close(...future.stdout)
[10:30:51.268]         ...future.stdout <- NULL
[10:30:51.268]     }
[10:30:51.268]     ...future.result$conditions <- ...future.conditions
[10:30:51.268]     ...future.result$finished <- base::Sys.time()
[10:30:51.268]     ...future.result
[10:30:51.268] }
[10:30:51.271] assign_globals() ...
[10:30:51.271] List of 5
[10:30:51.271]  $ ...future.FUN            :function (x, ...)  
[10:30:51.271]  $ MoreArgs                 : NULL
[10:30:51.271]  $ ...future.elements_ii    :List of 2
[10:30:51.271]   ..$ :List of 2
[10:30:51.271]   .. ..$ : int 1
[10:30:51.271]   .. ..$ : int 2
[10:30:51.271]   ..$ :List of 2
[10:30:51.271]   .. ..$ : int 2
[10:30:51.271]   .. ..$ : int 1
[10:30:51.271]  $ ...future.seeds_ii       : NULL
[10:30:51.271]  $ ...future.globals.maxSize: NULL
[10:30:51.271]  - attr(*, "where")=List of 5
[10:30:51.271]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.271]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.271]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.271]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.271]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.271]  - attr(*, "resolved")= logi FALSE
[10:30:51.271]  - attr(*, "total_size")= num 280
[10:30:51.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.271]  - attr(*, "already-done")= logi TRUE
[10:30:51.277] - copied ‘...future.FUN’ to environment
[10:30:51.277] - copied ‘MoreArgs’ to environment
[10:30:51.278] - copied ‘...future.elements_ii’ to environment
[10:30:51.278] - copied ‘...future.seeds_ii’ to environment
[10:30:51.278] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.278] assign_globals() ... done
[10:30:51.278] requestCore(): workers = 2
[10:30:51.280] MulticoreFuture started
[10:30:51.281] - Launch lazy future ... done
[10:30:51.281] run() for ‘MulticoreFuture’ ... done
[10:30:51.281] Created future:
[10:30:51.281] plan(): Setting new future strategy stack:
[10:30:51.282] List of future strategies:
[10:30:51.282] 1. sequential:
[10:30:51.282]    - args: function (..., envir = parent.frame())
[10:30:51.282]    - tweaked: FALSE
[10:30:51.282]    - call: NULL
[10:30:51.282] plan(): nbrOfWorkers() = 1
[10:30:51.284] plan(): Setting new future strategy stack:
[10:30:51.285] List of future strategies:
[10:30:51.285] 1. multicore:
[10:30:51.285]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.285]    - tweaked: FALSE
[10:30:51.285]    - call: plan(strategy)
[10:30:51.290] plan(): nbrOfWorkers() = 2
[10:30:51.281] MulticoreFuture:
[10:30:51.281] Label: ‘future_mapply-1’
[10:30:51.281] Expression:
[10:30:51.281] {
[10:30:51.281]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.281]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.281]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.281]         on.exit(options(oopts), add = TRUE)
[10:30:51.281]     }
[10:30:51.281]     {
[10:30:51.281]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.281]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.281]         do.call(mapply, args = args)
[10:30:51.281]     }
[10:30:51.281] }
[10:30:51.281] Lazy evaluation: FALSE
[10:30:51.281] Asynchronous evaluation: TRUE
[10:30:51.281] Local evaluation: TRUE
[10:30:51.281] Environment: R_GlobalEnv
[10:30:51.281] Capture standard output: TRUE
[10:30:51.281] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.281] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.281] Packages: <none>
[10:30:51.281] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:51.281] Resolved: TRUE
[10:30:51.281] Value: <not collected>
[10:30:51.281] Conditions captured: <none>
[10:30:51.281] Early signaling: FALSE
[10:30:51.281] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.281] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.291] Chunk #1 of 2 ... DONE
[10:30:51.291] Chunk #2 of 2 ...
[10:30:51.291]  - Finding globals in '...' for chunk #2 ...
[10:30:51.292] getGlobalsAndPackages() ...
[10:30:51.292] Searching for globals...
[10:30:51.292] 
[10:30:51.292] Searching for globals ... DONE
[10:30:51.293] - globals: [0] <none>
[10:30:51.293] getGlobalsAndPackages() ... DONE
[10:30:51.293]    + additional globals found: [n=0] 
[10:30:51.293]    + additional namespaces needed: [n=0] 
[10:30:51.293]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:51.293]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.294]  - seeds: <none>
[10:30:51.294]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.294] getGlobalsAndPackages() ...
[10:30:51.294] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.294] Resolving globals: FALSE
[10:30:51.295] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:51.296] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:51.296] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.296] 
[10:30:51.296] getGlobalsAndPackages() ... DONE
[10:30:51.297] run() for ‘Future’ ...
[10:30:51.297] - state: ‘created’
[10:30:51.297] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.302] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.302] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.303]   - Field: ‘label’
[10:30:51.303]   - Field: ‘local’
[10:30:51.303]   - Field: ‘owner’
[10:30:51.306]   - Field: ‘envir’
[10:30:51.307]   - Field: ‘workers’
[10:30:51.307]   - Field: ‘packages’
[10:30:51.307]   - Field: ‘gc’
[10:30:51.308]   - Field: ‘job’
[10:30:51.308]   - Field: ‘conditions’
[10:30:51.308]   - Field: ‘expr’
[10:30:51.309]   - Field: ‘uuid’
[10:30:51.309]   - Field: ‘seed’
[10:30:51.309]   - Field: ‘version’
[10:30:51.310]   - Field: ‘result’
[10:30:51.310]   - Field: ‘asynchronous’
[10:30:51.310]   - Field: ‘calls’
[10:30:51.310]   - Field: ‘globals’
[10:30:51.311]   - Field: ‘stdout’
[10:30:51.311]   - Field: ‘earlySignal’
[10:30:51.311]   - Field: ‘lazy’
[10:30:51.311]   - Field: ‘state’
[10:30:51.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.312] - Launch lazy future ...
[10:30:51.312] Packages needed by the future expression (n = 0): <none>
[10:30:51.313] Packages needed by future strategies (n = 0): <none>
[10:30:51.314] {
[10:30:51.314]     {
[10:30:51.314]         {
[10:30:51.314]             ...future.startTime <- base::Sys.time()
[10:30:51.314]             {
[10:30:51.314]                 {
[10:30:51.314]                   {
[10:30:51.314]                     {
[10:30:51.314]                       base::local({
[10:30:51.314]                         has_future <- base::requireNamespace("future", 
[10:30:51.314]                           quietly = TRUE)
[10:30:51.314]                         if (has_future) {
[10:30:51.314]                           ns <- base::getNamespace("future")
[10:30:51.314]                           version <- ns[[".package"]][["version"]]
[10:30:51.314]                           if (is.null(version)) 
[10:30:51.314]                             version <- utils::packageVersion("future")
[10:30:51.314]                         }
[10:30:51.314]                         else {
[10:30:51.314]                           version <- NULL
[10:30:51.314]                         }
[10:30:51.314]                         if (!has_future || version < "1.8.0") {
[10:30:51.314]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.314]                             "", base::R.version$version.string), 
[10:30:51.314]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:51.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:51.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.314]                               "release", "version")], collapse = " "), 
[10:30:51.314]                             hostname = base::Sys.info()[["nodename"]])
[10:30:51.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.314]                             info)
[10:30:51.314]                           info <- base::paste(info, collapse = "; ")
[10:30:51.314]                           if (!has_future) {
[10:30:51.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.314]                               info)
[10:30:51.314]                           }
[10:30:51.314]                           else {
[10:30:51.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.314]                               info, version)
[10:30:51.314]                           }
[10:30:51.314]                           base::stop(msg)
[10:30:51.314]                         }
[10:30:51.314]                       })
[10:30:51.314]                     }
[10:30:51.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.314]                     base::options(mc.cores = 1L)
[10:30:51.314]                   }
[10:30:51.314]                   ...future.strategy.old <- future::plan("list")
[10:30:51.314]                   options(future.plan = NULL)
[10:30:51.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.314]                 }
[10:30:51.314]                 ...future.workdir <- getwd()
[10:30:51.314]             }
[10:30:51.314]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.314]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.314]         }
[10:30:51.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.314]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.314]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.314]             base::names(...future.oldOptions))
[10:30:51.314]     }
[10:30:51.314]     if (FALSE) {
[10:30:51.314]     }
[10:30:51.314]     else {
[10:30:51.314]         if (TRUE) {
[10:30:51.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.314]                 open = "w")
[10:30:51.314]         }
[10:30:51.314]         else {
[10:30:51.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.314]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.314]         }
[10:30:51.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.314]             base::sink(type = "output", split = FALSE)
[10:30:51.314]             base::close(...future.stdout)
[10:30:51.314]         }, add = TRUE)
[10:30:51.314]     }
[10:30:51.314]     ...future.frame <- base::sys.nframe()
[10:30:51.314]     ...future.conditions <- base::list()
[10:30:51.314]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.314]     if (FALSE) {
[10:30:51.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.314]     }
[10:30:51.314]     ...future.result <- base::tryCatch({
[10:30:51.314]         base::withCallingHandlers({
[10:30:51.314]             ...future.value <- base::withVisible(base::local({
[10:30:51.314]                 withCallingHandlers({
[10:30:51.314]                   {
[10:30:51.314]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.314]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.314]                       ...future.globals.maxSize)) {
[10:30:51.314]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.314]                       on.exit(options(oopts), add = TRUE)
[10:30:51.314]                     }
[10:30:51.314]                     {
[10:30:51.314]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.314]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.314]                         USE.NAMES = FALSE)
[10:30:51.314]                       do.call(mapply, args = args)
[10:30:51.314]                     }
[10:30:51.314]                   }
[10:30:51.314]                 }, immediateCondition = function(cond) {
[10:30:51.314]                   save_rds <- function (object, pathname, ...) 
[10:30:51.314]                   {
[10:30:51.314]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.314]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.314]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.314]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.314]                         fi_tmp[["mtime"]])
[10:30:51.314]                     }
[10:30:51.314]                     tryCatch({
[10:30:51.314]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.314]                     }, error = function(ex) {
[10:30:51.314]                       msg <- conditionMessage(ex)
[10:30:51.314]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.314]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.314]                         fi_tmp[["mtime"]], msg)
[10:30:51.314]                       ex$message <- msg
[10:30:51.314]                       stop(ex)
[10:30:51.314]                     })
[10:30:51.314]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.314]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.314]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.314]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.314]                       fi <- file.info(pathname)
[10:30:51.314]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.314]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.314]                         fi[["size"]], fi[["mtime"]])
[10:30:51.314]                       stop(msg)
[10:30:51.314]                     }
[10:30:51.314]                     invisible(pathname)
[10:30:51.314]                   }
[10:30:51.314]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.314]                     rootPath = tempdir()) 
[10:30:51.314]                   {
[10:30:51.314]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.314]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.314]                       tmpdir = path, fileext = ".rds")
[10:30:51.314]                     save_rds(obj, file)
[10:30:51.314]                   }
[10:30:51.314]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.314]                   {
[10:30:51.314]                     inherits <- base::inherits
[10:30:51.314]                     invokeRestart <- base::invokeRestart
[10:30:51.314]                     is.null <- base::is.null
[10:30:51.314]                     muffled <- FALSE
[10:30:51.314]                     if (inherits(cond, "message")) {
[10:30:51.314]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.314]                       if (muffled) 
[10:30:51.314]                         invokeRestart("muffleMessage")
[10:30:51.314]                     }
[10:30:51.314]                     else if (inherits(cond, "warning")) {
[10:30:51.314]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.314]                       if (muffled) 
[10:30:51.314]                         invokeRestart("muffleWarning")
[10:30:51.314]                     }
[10:30:51.314]                     else if (inherits(cond, "condition")) {
[10:30:51.314]                       if (!is.null(pattern)) {
[10:30:51.314]                         computeRestarts <- base::computeRestarts
[10:30:51.314]                         grepl <- base::grepl
[10:30:51.314]                         restarts <- computeRestarts(cond)
[10:30:51.314]                         for (restart in restarts) {
[10:30:51.314]                           name <- restart$name
[10:30:51.314]                           if (is.null(name)) 
[10:30:51.314]                             next
[10:30:51.314]                           if (!grepl(pattern, name)) 
[10:30:51.314]                             next
[10:30:51.314]                           invokeRestart(restart)
[10:30:51.314]                           muffled <- TRUE
[10:30:51.314]                           break
[10:30:51.314]                         }
[10:30:51.314]                       }
[10:30:51.314]                     }
[10:30:51.314]                     invisible(muffled)
[10:30:51.314]                   }
[10:30:51.314]                   muffleCondition(cond)
[10:30:51.314]                 })
[10:30:51.314]             }))
[10:30:51.314]             future::FutureResult(value = ...future.value$value, 
[10:30:51.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.314]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.314]                     ...future.globalenv.names))
[10:30:51.314]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.314]         }, condition = base::local({
[10:30:51.314]             c <- base::c
[10:30:51.314]             inherits <- base::inherits
[10:30:51.314]             invokeRestart <- base::invokeRestart
[10:30:51.314]             length <- base::length
[10:30:51.314]             list <- base::list
[10:30:51.314]             seq.int <- base::seq.int
[10:30:51.314]             signalCondition <- base::signalCondition
[10:30:51.314]             sys.calls <- base::sys.calls
[10:30:51.314]             `[[` <- base::`[[`
[10:30:51.314]             `+` <- base::`+`
[10:30:51.314]             `<<-` <- base::`<<-`
[10:30:51.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.314]                   3L)]
[10:30:51.314]             }
[10:30:51.314]             function(cond) {
[10:30:51.314]                 is_error <- inherits(cond, "error")
[10:30:51.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.314]                   NULL)
[10:30:51.314]                 if (is_error) {
[10:30:51.314]                   sessionInformation <- function() {
[10:30:51.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.314]                       search = base::search(), system = base::Sys.info())
[10:30:51.314]                   }
[10:30:51.314]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.314]                     cond$call), session = sessionInformation(), 
[10:30:51.314]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.314]                   signalCondition(cond)
[10:30:51.314]                 }
[10:30:51.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.314]                 "immediateCondition"))) {
[10:30:51.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.314]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.314]                   if (TRUE && !signal) {
[10:30:51.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.314]                     {
[10:30:51.314]                       inherits <- base::inherits
[10:30:51.314]                       invokeRestart <- base::invokeRestart
[10:30:51.314]                       is.null <- base::is.null
[10:30:51.314]                       muffled <- FALSE
[10:30:51.314]                       if (inherits(cond, "message")) {
[10:30:51.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.314]                         if (muffled) 
[10:30:51.314]                           invokeRestart("muffleMessage")
[10:30:51.314]                       }
[10:30:51.314]                       else if (inherits(cond, "warning")) {
[10:30:51.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.314]                         if (muffled) 
[10:30:51.314]                           invokeRestart("muffleWarning")
[10:30:51.314]                       }
[10:30:51.314]                       else if (inherits(cond, "condition")) {
[10:30:51.314]                         if (!is.null(pattern)) {
[10:30:51.314]                           computeRestarts <- base::computeRestarts
[10:30:51.314]                           grepl <- base::grepl
[10:30:51.314]                           restarts <- computeRestarts(cond)
[10:30:51.314]                           for (restart in restarts) {
[10:30:51.314]                             name <- restart$name
[10:30:51.314]                             if (is.null(name)) 
[10:30:51.314]                               next
[10:30:51.314]                             if (!grepl(pattern, name)) 
[10:30:51.314]                               next
[10:30:51.314]                             invokeRestart(restart)
[10:30:51.314]                             muffled <- TRUE
[10:30:51.314]                             break
[10:30:51.314]                           }
[10:30:51.314]                         }
[10:30:51.314]                       }
[10:30:51.314]                       invisible(muffled)
[10:30:51.314]                     }
[10:30:51.314]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.314]                   }
[10:30:51.314]                 }
[10:30:51.314]                 else {
[10:30:51.314]                   if (TRUE) {
[10:30:51.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.314]                     {
[10:30:51.314]                       inherits <- base::inherits
[10:30:51.314]                       invokeRestart <- base::invokeRestart
[10:30:51.314]                       is.null <- base::is.null
[10:30:51.314]                       muffled <- FALSE
[10:30:51.314]                       if (inherits(cond, "message")) {
[10:30:51.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.314]                         if (muffled) 
[10:30:51.314]                           invokeRestart("muffleMessage")
[10:30:51.314]                       }
[10:30:51.314]                       else if (inherits(cond, "warning")) {
[10:30:51.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.314]                         if (muffled) 
[10:30:51.314]                           invokeRestart("muffleWarning")
[10:30:51.314]                       }
[10:30:51.314]                       else if (inherits(cond, "condition")) {
[10:30:51.314]                         if (!is.null(pattern)) {
[10:30:51.314]                           computeRestarts <- base::computeRestarts
[10:30:51.314]                           grepl <- base::grepl
[10:30:51.314]                           restarts <- computeRestarts(cond)
[10:30:51.314]                           for (restart in restarts) {
[10:30:51.314]                             name <- restart$name
[10:30:51.314]                             if (is.null(name)) 
[10:30:51.314]                               next
[10:30:51.314]                             if (!grepl(pattern, name)) 
[10:30:51.314]                               next
[10:30:51.314]                             invokeRestart(restart)
[10:30:51.314]                             muffled <- TRUE
[10:30:51.314]                             break
[10:30:51.314]                           }
[10:30:51.314]                         }
[10:30:51.314]                       }
[10:30:51.314]                       invisible(muffled)
[10:30:51.314]                     }
[10:30:51.314]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.314]                   }
[10:30:51.314]                 }
[10:30:51.314]             }
[10:30:51.314]         }))
[10:30:51.314]     }, error = function(ex) {
[10:30:51.314]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.314]                 ...future.rng), started = ...future.startTime, 
[10:30:51.314]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.314]             version = "1.8"), class = "FutureResult")
[10:30:51.314]     }, finally = {
[10:30:51.314]         if (!identical(...future.workdir, getwd())) 
[10:30:51.314]             setwd(...future.workdir)
[10:30:51.314]         {
[10:30:51.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.314]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.314]             }
[10:30:51.314]             base::options(...future.oldOptions)
[10:30:51.314]             if (.Platform$OS.type == "windows") {
[10:30:51.314]                 old_names <- names(...future.oldEnvVars)
[10:30:51.314]                 envs <- base::Sys.getenv()
[10:30:51.314]                 names <- names(envs)
[10:30:51.314]                 common <- intersect(names, old_names)
[10:30:51.314]                 added <- setdiff(names, old_names)
[10:30:51.314]                 removed <- setdiff(old_names, names)
[10:30:51.314]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.314]                   envs[common]]
[10:30:51.314]                 NAMES <- toupper(changed)
[10:30:51.314]                 args <- list()
[10:30:51.314]                 for (kk in seq_along(NAMES)) {
[10:30:51.314]                   name <- changed[[kk]]
[10:30:51.314]                   NAME <- NAMES[[kk]]
[10:30:51.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.314]                     next
[10:30:51.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.314]                 }
[10:30:51.314]                 NAMES <- toupper(added)
[10:30:51.314]                 for (kk in seq_along(NAMES)) {
[10:30:51.314]                   name <- added[[kk]]
[10:30:51.314]                   NAME <- NAMES[[kk]]
[10:30:51.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.314]                     next
[10:30:51.314]                   args[[name]] <- ""
[10:30:51.314]                 }
[10:30:51.314]                 NAMES <- toupper(removed)
[10:30:51.314]                 for (kk in seq_along(NAMES)) {
[10:30:51.314]                   name <- removed[[kk]]
[10:30:51.314]                   NAME <- NAMES[[kk]]
[10:30:51.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.314]                     next
[10:30:51.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.314]                 }
[10:30:51.314]                 if (length(args) > 0) 
[10:30:51.314]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.314]             }
[10:30:51.314]             else {
[10:30:51.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.314]             }
[10:30:51.314]             {
[10:30:51.314]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.314]                   0L) {
[10:30:51.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.314]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.314]                   base::options(opts)
[10:30:51.314]                 }
[10:30:51.314]                 {
[10:30:51.314]                   {
[10:30:51.314]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.314]                     NULL
[10:30:51.314]                   }
[10:30:51.314]                   options(future.plan = NULL)
[10:30:51.314]                   if (is.na(NA_character_)) 
[10:30:51.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.314]                     .init = FALSE)
[10:30:51.314]                 }
[10:30:51.314]             }
[10:30:51.314]         }
[10:30:51.314]     })
[10:30:51.314]     if (TRUE) {
[10:30:51.314]         base::sink(type = "output", split = FALSE)
[10:30:51.314]         if (TRUE) {
[10:30:51.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.314]         }
[10:30:51.314]         else {
[10:30:51.314]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.314]         }
[10:30:51.314]         base::close(...future.stdout)
[10:30:51.314]         ...future.stdout <- NULL
[10:30:51.314]     }
[10:30:51.314]     ...future.result$conditions <- ...future.conditions
[10:30:51.314]     ...future.result$finished <- base::Sys.time()
[10:30:51.314]     ...future.result
[10:30:51.314] }
[10:30:51.317] assign_globals() ...
[10:30:51.317] List of 5
[10:30:51.317]  $ ...future.FUN            :function (x, ...)  
[10:30:51.317]  $ MoreArgs                 : NULL
[10:30:51.317]  $ ...future.elements_ii    :List of 2
[10:30:51.317]   ..$ :List of 2
[10:30:51.317]   .. ..$ : int 3
[10:30:51.317]   .. ..$ : int 4
[10:30:51.317]   ..$ :List of 2
[10:30:51.317]   .. ..$ : int 2
[10:30:51.317]   .. ..$ : int 1
[10:30:51.317]  $ ...future.seeds_ii       : NULL
[10:30:51.317]  $ ...future.globals.maxSize: NULL
[10:30:51.317]  - attr(*, "where")=List of 5
[10:30:51.317]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.317]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.317]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.317]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.317]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.317]  - attr(*, "resolved")= logi FALSE
[10:30:51.317]  - attr(*, "total_size")= num 280
[10:30:51.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.317]  - attr(*, "already-done")= logi TRUE
[10:30:51.327] - copied ‘...future.FUN’ to environment
[10:30:51.327] - copied ‘MoreArgs’ to environment
[10:30:51.327] - copied ‘...future.elements_ii’ to environment
[10:30:51.327] - copied ‘...future.seeds_ii’ to environment
[10:30:51.327] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.328] assign_globals() ... done
[10:30:51.328] requestCore(): workers = 2
[10:30:51.330] MulticoreFuture started
[10:30:51.331] - Launch lazy future ... done
[10:30:51.331] run() for ‘MulticoreFuture’ ... done
[10:30:51.331] Created future:
[10:30:51.331] plan(): Setting new future strategy stack:
[10:30:51.332] List of future strategies:
[10:30:51.332] 1. sequential:
[10:30:51.332]    - args: function (..., envir = parent.frame())
[10:30:51.332]    - tweaked: FALSE
[10:30:51.332]    - call: NULL
[10:30:51.332] plan(): nbrOfWorkers() = 1
[10:30:51.334] plan(): Setting new future strategy stack:
[10:30:51.335] List of future strategies:
[10:30:51.335] 1. multicore:
[10:30:51.335]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.335]    - tweaked: FALSE
[10:30:51.335]    - call: plan(strategy)
[10:30:51.340] plan(): nbrOfWorkers() = 2
[10:30:51.331] MulticoreFuture:
[10:30:51.331] Label: ‘future_mapply-2’
[10:30:51.331] Expression:
[10:30:51.331] {
[10:30:51.331]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.331]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.331]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.331]         on.exit(options(oopts), add = TRUE)
[10:30:51.331]     }
[10:30:51.331]     {
[10:30:51.331]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.331]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.331]         do.call(mapply, args = args)
[10:30:51.331]     }
[10:30:51.331] }
[10:30:51.331] Lazy evaluation: FALSE
[10:30:51.331] Asynchronous evaluation: TRUE
[10:30:51.331] Local evaluation: TRUE
[10:30:51.331] Environment: R_GlobalEnv
[10:30:51.331] Capture standard output: TRUE
[10:30:51.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.331] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.331] Packages: <none>
[10:30:51.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:51.331] Resolved: TRUE
[10:30:51.331] Value: <not collected>
[10:30:51.331] Conditions captured: <none>
[10:30:51.331] Early signaling: FALSE
[10:30:51.331] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.331] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.341] Chunk #2 of 2 ... DONE
[10:30:51.341] Launching 2 futures (chunks) ... DONE
[10:30:51.341] Resolving 2 futures (chunks) ...
[10:30:51.342] resolve() on list ...
[10:30:51.342]  recursive: 0
[10:30:51.342]  length: 2
[10:30:51.342] 
[10:30:51.342] Future #1
[10:30:51.343] result() for MulticoreFuture ...
[10:30:51.344] result() for MulticoreFuture ...
[10:30:51.344] result() for MulticoreFuture ... done
[10:30:51.344] result() for MulticoreFuture ... done
[10:30:51.344] result() for MulticoreFuture ...
[10:30:51.344] result() for MulticoreFuture ... done
[10:30:51.344] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:51.345] - nx: 2
[10:30:51.345] - relay: TRUE
[10:30:51.345] - stdout: TRUE
[10:30:51.345] - signal: TRUE
[10:30:51.345] - resignal: FALSE
[10:30:51.345] - force: TRUE
[10:30:51.345] - relayed: [n=2] FALSE, FALSE
[10:30:51.346] - queued futures: [n=2] FALSE, FALSE
[10:30:51.346]  - until=1
[10:30:51.346]  - relaying element #1
[10:30:51.346] result() for MulticoreFuture ...
[10:30:51.346] result() for MulticoreFuture ... done
[10:30:51.346] result() for MulticoreFuture ...
[10:30:51.347] result() for MulticoreFuture ... done
[10:30:51.347] result() for MulticoreFuture ...
[10:30:51.347] result() for MulticoreFuture ... done
[10:30:51.347] result() for MulticoreFuture ...
[10:30:51.347] result() for MulticoreFuture ... done
[10:30:51.347] - relayed: [n=2] TRUE, FALSE
[10:30:51.348] - queued futures: [n=2] TRUE, FALSE
[10:30:51.348] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:51.348]  length: 1 (resolved future 1)
[10:30:51.348] Future #2
[10:30:51.348] result() for MulticoreFuture ...
[10:30:51.349] result() for MulticoreFuture ...
[10:30:51.349] result() for MulticoreFuture ... done
[10:30:51.350] result() for MulticoreFuture ... done
[10:30:51.350] result() for MulticoreFuture ...
[10:30:51.350] result() for MulticoreFuture ... done
[10:30:51.350] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:51.350] - nx: 2
[10:30:51.355] - relay: TRUE
[10:30:51.356] - stdout: TRUE
[10:30:51.356] - signal: TRUE
[10:30:51.356] - resignal: FALSE
[10:30:51.356] - force: TRUE
[10:30:51.356] - relayed: [n=2] TRUE, FALSE
[10:30:51.356] - queued futures: [n=2] TRUE, FALSE
[10:30:51.356]  - until=2
[10:30:51.356]  - relaying element #2
[10:30:51.357] result() for MulticoreFuture ...
[10:30:51.357] result() for MulticoreFuture ... done
[10:30:51.357] result() for MulticoreFuture ...
[10:30:51.357] result() for MulticoreFuture ... done
[10:30:51.357] result() for MulticoreFuture ...
[10:30:51.357] result() for MulticoreFuture ... done
[10:30:51.358] result() for MulticoreFuture ...
[10:30:51.358] result() for MulticoreFuture ... done
[10:30:51.358] - relayed: [n=2] TRUE, TRUE
[10:30:51.358] - queued futures: [n=2] TRUE, TRUE
[10:30:51.358] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:51.358]  length: 0 (resolved future 2)
[10:30:51.359] Relaying remaining futures
[10:30:51.359] signalConditionsASAP(NULL, pos=0) ...
[10:30:51.359] - nx: 2
[10:30:51.359] - relay: TRUE
[10:30:51.359] - stdout: TRUE
[10:30:51.359] - signal: TRUE
[10:30:51.359] - resignal: FALSE
[10:30:51.359] - force: TRUE
[10:30:51.360] - relayed: [n=2] TRUE, TRUE
[10:30:51.360] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:51.360] - relayed: [n=2] TRUE, TRUE
[10:30:51.360] - queued futures: [n=2] TRUE, TRUE
[10:30:51.360] signalConditionsASAP(NULL, pos=0) ... done
[10:30:51.360] resolve() on list ... DONE
[10:30:51.361] result() for MulticoreFuture ...
[10:30:51.361] result() for MulticoreFuture ... done
[10:30:51.361] result() for MulticoreFuture ...
[10:30:51.361] result() for MulticoreFuture ... done
[10:30:51.361] result() for MulticoreFuture ...
[10:30:51.361] result() for MulticoreFuture ... done
[10:30:51.361] result() for MulticoreFuture ...
[10:30:51.362] result() for MulticoreFuture ... done
[10:30:51.362]  - Number of value chunks collected: 2
[10:30:51.362] Resolving 2 futures (chunks) ... DONE
[10:30:51.362] Reducing values from 2 chunks ...
[10:30:51.362]  - Number of values collected after concatenation: 4
[10:30:51.362]  - Number of values expected: 4
[10:30:51.362] Reducing values from 2 chunks ... DONE
[10:30:51.363] future_mapply() ... DONE
- Parallel RNG ...
[10:30:51.363] future_mapply() ...
[10:30:51.363] Generating random seeds ...
[10:30:51.363] Generating random seed streams for 4 elements ...
[10:30:51.363] Generating random seed streams for 4 elements ... DONE
[10:30:51.364] Generating random seeds ... DONE
[10:30:51.364] Will set RNG state on exit: 10407, 1604207875, 707153646, -1375918297, -1120608747, -1168343264, 77692634
[10:30:51.368] Number of chunks: 2
[10:30:51.368] getGlobalsAndPackagesXApply() ...
[10:30:51.368]  - future.globals: TRUE
[10:30:51.368] getGlobalsAndPackages() ...
[10:30:51.369] Searching for globals...
[10:30:51.370] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:30:51.370] Searching for globals ... DONE
[10:30:51.371] Resolving globals: FALSE
[10:30:51.371] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[10:30:51.372] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[10:30:51.372] - globals: [1] ‘FUN’
[10:30:51.372] - packages: [1] ‘stats’
[10:30:51.372] getGlobalsAndPackages() ... DONE
[10:30:51.372]  - globals found/used: [n=1] ‘FUN’
[10:30:51.372]  - needed namespaces: [n=1] ‘stats’
[10:30:51.372] Finding globals ... DONE
[10:30:51.373] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:51.373] List of 2
[10:30:51.373]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:30:51.373]  $ MoreArgs     :List of 1
[10:30:51.373]   ..$ min: num 1
[10:30:51.373]  - attr(*, "where")=List of 2
[10:30:51.373]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:51.373]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:51.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.373]  - attr(*, "resolved")= logi FALSE
[10:30:51.373]  - attr(*, "total_size")= num NA
[10:30:51.376] Packages to be attached in all futures: [n=1] ‘stats’
[10:30:51.376] getGlobalsAndPackagesXApply() ... DONE
[10:30:51.376] Number of futures (= number of chunks): 2
[10:30:51.376] Launching 2 futures (chunks) ...
[10:30:51.376] Chunk #1 of 2 ...
[10:30:51.376]  - Finding globals in '...' for chunk #1 ...
[10:30:51.376] getGlobalsAndPackages() ...
[10:30:51.377] Searching for globals...
[10:30:51.377] 
[10:30:51.377] Searching for globals ... DONE
[10:30:51.377] - globals: [0] <none>
[10:30:51.377] getGlobalsAndPackages() ... DONE
[10:30:51.377]    + additional globals found: [n=0] 
[10:30:51.377]    + additional namespaces needed: [n=0] 
[10:30:51.378]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:51.378]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.378]  - seeds: [2] <seeds>
[10:30:51.378]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.378] getGlobalsAndPackages() ...
[10:30:51.378] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.378] Resolving globals: FALSE
[10:30:51.379] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[10:30:51.379] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[10:30:51.379] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.379] - packages: [1] ‘stats’
[10:30:51.380] getGlobalsAndPackages() ... DONE
[10:30:51.380] run() for ‘Future’ ...
[10:30:51.380] - state: ‘created’
[10:30:51.380] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.387] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.387] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.387]   - Field: ‘label’
[10:30:51.388]   - Field: ‘local’
[10:30:51.388]   - Field: ‘owner’
[10:30:51.388]   - Field: ‘envir’
[10:30:51.388]   - Field: ‘workers’
[10:30:51.388]   - Field: ‘packages’
[10:30:51.388]   - Field: ‘gc’
[10:30:51.388]   - Field: ‘job’
[10:30:51.388]   - Field: ‘conditions’
[10:30:51.389]   - Field: ‘expr’
[10:30:51.389]   - Field: ‘uuid’
[10:30:51.389]   - Field: ‘seed’
[10:30:51.389]   - Field: ‘version’
[10:30:51.389]   - Field: ‘result’
[10:30:51.389]   - Field: ‘asynchronous’
[10:30:51.389]   - Field: ‘calls’
[10:30:51.390]   - Field: ‘globals’
[10:30:51.390]   - Field: ‘stdout’
[10:30:51.390]   - Field: ‘earlySignal’
[10:30:51.390]   - Field: ‘lazy’
[10:30:51.390]   - Field: ‘state’
[10:30:51.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.390] - Launch lazy future ...
[10:30:51.391] Packages needed by the future expression (n = 1): ‘stats’
[10:30:51.391] Packages needed by future strategies (n = 0): <none>
[10:30:51.391] {
[10:30:51.391]     {
[10:30:51.391]         {
[10:30:51.391]             ...future.startTime <- base::Sys.time()
[10:30:51.391]             {
[10:30:51.391]                 {
[10:30:51.391]                   {
[10:30:51.391]                     {
[10:30:51.391]                       {
[10:30:51.391]                         base::local({
[10:30:51.391]                           has_future <- base::requireNamespace("future", 
[10:30:51.391]                             quietly = TRUE)
[10:30:51.391]                           if (has_future) {
[10:30:51.391]                             ns <- base::getNamespace("future")
[10:30:51.391]                             version <- ns[[".package"]][["version"]]
[10:30:51.391]                             if (is.null(version)) 
[10:30:51.391]                               version <- utils::packageVersion("future")
[10:30:51.391]                           }
[10:30:51.391]                           else {
[10:30:51.391]                             version <- NULL
[10:30:51.391]                           }
[10:30:51.391]                           if (!has_future || version < "1.8.0") {
[10:30:51.391]                             info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.391]                               "", base::R.version$version.string), 
[10:30:51.391]                               platform = base::sprintf("%s (%s-bit)", 
[10:30:51.391]                                 base::R.version$platform, 8 * 
[10:30:51.391]                                   base::.Machine$sizeof.pointer), 
[10:30:51.391]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.391]                                 "release", "version")], collapse = " "), 
[10:30:51.391]                               hostname = base::Sys.info()[["nodename"]])
[10:30:51.391]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.391]                               info)
[10:30:51.391]                             info <- base::paste(info, collapse = "; ")
[10:30:51.391]                             if (!has_future) {
[10:30:51.391]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.391]                                 info)
[10:30:51.391]                             }
[10:30:51.391]                             else {
[10:30:51.391]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.391]                                 info, version)
[10:30:51.391]                             }
[10:30:51.391]                             base::stop(msg)
[10:30:51.391]                           }
[10:30:51.391]                         })
[10:30:51.391]                       }
[10:30:51.391]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.391]                       base::options(mc.cores = 1L)
[10:30:51.391]                     }
[10:30:51.391]                     base::local({
[10:30:51.391]                       for (pkg in "stats") {
[10:30:51.391]                         base::loadNamespace(pkg)
[10:30:51.391]                         base::library(pkg, character.only = TRUE)
[10:30:51.391]                       }
[10:30:51.391]                     })
[10:30:51.391]                   }
[10:30:51.391]                   ...future.strategy.old <- future::plan("list")
[10:30:51.391]                   options(future.plan = NULL)
[10:30:51.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.391]                 }
[10:30:51.391]                 ...future.workdir <- getwd()
[10:30:51.391]             }
[10:30:51.391]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.391]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.391]         }
[10:30:51.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.391]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.391]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.391]             base::names(...future.oldOptions))
[10:30:51.391]     }
[10:30:51.391]     if (FALSE) {
[10:30:51.391]     }
[10:30:51.391]     else {
[10:30:51.391]         if (TRUE) {
[10:30:51.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.391]                 open = "w")
[10:30:51.391]         }
[10:30:51.391]         else {
[10:30:51.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.391]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.391]         }
[10:30:51.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.391]             base::sink(type = "output", split = FALSE)
[10:30:51.391]             base::close(...future.stdout)
[10:30:51.391]         }, add = TRUE)
[10:30:51.391]     }
[10:30:51.391]     ...future.frame <- base::sys.nframe()
[10:30:51.391]     ...future.conditions <- base::list()
[10:30:51.391]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.391]     if (FALSE) {
[10:30:51.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.391]     }
[10:30:51.391]     ...future.result <- base::tryCatch({
[10:30:51.391]         base::withCallingHandlers({
[10:30:51.391]             ...future.value <- base::withVisible(base::local({
[10:30:51.391]                 withCallingHandlers({
[10:30:51.391]                   {
[10:30:51.391]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.391]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.391]                       ...future.globals.maxSize)) {
[10:30:51.391]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.391]                       on.exit(options(oopts), add = TRUE)
[10:30:51.391]                     }
[10:30:51.391]                     {
[10:30:51.391]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:51.391]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:51.391]                           envir = globalenv(), inherits = FALSE)
[10:30:51.391]                         ...future.FUN(...)
[10:30:51.391]                       }
[10:30:51.391]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:51.391]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:51.391]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.391]                         USE.NAMES = FALSE)
[10:30:51.391]                       do.call(mapply, args = args)
[10:30:51.391]                     }
[10:30:51.391]                   }
[10:30:51.391]                 }, immediateCondition = function(cond) {
[10:30:51.391]                   save_rds <- function (object, pathname, ...) 
[10:30:51.391]                   {
[10:30:51.391]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.391]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.391]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.391]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.391]                         fi_tmp[["mtime"]])
[10:30:51.391]                     }
[10:30:51.391]                     tryCatch({
[10:30:51.391]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.391]                     }, error = function(ex) {
[10:30:51.391]                       msg <- conditionMessage(ex)
[10:30:51.391]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.391]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.391]                         fi_tmp[["mtime"]], msg)
[10:30:51.391]                       ex$message <- msg
[10:30:51.391]                       stop(ex)
[10:30:51.391]                     })
[10:30:51.391]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.391]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.391]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.391]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.391]                       fi <- file.info(pathname)
[10:30:51.391]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.391]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.391]                         fi[["size"]], fi[["mtime"]])
[10:30:51.391]                       stop(msg)
[10:30:51.391]                     }
[10:30:51.391]                     invisible(pathname)
[10:30:51.391]                   }
[10:30:51.391]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.391]                     rootPath = tempdir()) 
[10:30:51.391]                   {
[10:30:51.391]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.391]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.391]                       tmpdir = path, fileext = ".rds")
[10:30:51.391]                     save_rds(obj, file)
[10:30:51.391]                   }
[10:30:51.391]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.391]                   {
[10:30:51.391]                     inherits <- base::inherits
[10:30:51.391]                     invokeRestart <- base::invokeRestart
[10:30:51.391]                     is.null <- base::is.null
[10:30:51.391]                     muffled <- FALSE
[10:30:51.391]                     if (inherits(cond, "message")) {
[10:30:51.391]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.391]                       if (muffled) 
[10:30:51.391]                         invokeRestart("muffleMessage")
[10:30:51.391]                     }
[10:30:51.391]                     else if (inherits(cond, "warning")) {
[10:30:51.391]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.391]                       if (muffled) 
[10:30:51.391]                         invokeRestart("muffleWarning")
[10:30:51.391]                     }
[10:30:51.391]                     else if (inherits(cond, "condition")) {
[10:30:51.391]                       if (!is.null(pattern)) {
[10:30:51.391]                         computeRestarts <- base::computeRestarts
[10:30:51.391]                         grepl <- base::grepl
[10:30:51.391]                         restarts <- computeRestarts(cond)
[10:30:51.391]                         for (restart in restarts) {
[10:30:51.391]                           name <- restart$name
[10:30:51.391]                           if (is.null(name)) 
[10:30:51.391]                             next
[10:30:51.391]                           if (!grepl(pattern, name)) 
[10:30:51.391]                             next
[10:30:51.391]                           invokeRestart(restart)
[10:30:51.391]                           muffled <- TRUE
[10:30:51.391]                           break
[10:30:51.391]                         }
[10:30:51.391]                       }
[10:30:51.391]                     }
[10:30:51.391]                     invisible(muffled)
[10:30:51.391]                   }
[10:30:51.391]                   muffleCondition(cond)
[10:30:51.391]                 })
[10:30:51.391]             }))
[10:30:51.391]             future::FutureResult(value = ...future.value$value, 
[10:30:51.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.391]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.391]                     ...future.globalenv.names))
[10:30:51.391]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.391]         }, condition = base::local({
[10:30:51.391]             c <- base::c
[10:30:51.391]             inherits <- base::inherits
[10:30:51.391]             invokeRestart <- base::invokeRestart
[10:30:51.391]             length <- base::length
[10:30:51.391]             list <- base::list
[10:30:51.391]             seq.int <- base::seq.int
[10:30:51.391]             signalCondition <- base::signalCondition
[10:30:51.391]             sys.calls <- base::sys.calls
[10:30:51.391]             `[[` <- base::`[[`
[10:30:51.391]             `+` <- base::`+`
[10:30:51.391]             `<<-` <- base::`<<-`
[10:30:51.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.391]                   3L)]
[10:30:51.391]             }
[10:30:51.391]             function(cond) {
[10:30:51.391]                 is_error <- inherits(cond, "error")
[10:30:51.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.391]                   NULL)
[10:30:51.391]                 if (is_error) {
[10:30:51.391]                   sessionInformation <- function() {
[10:30:51.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.391]                       search = base::search(), system = base::Sys.info())
[10:30:51.391]                   }
[10:30:51.391]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.391]                     cond$call), session = sessionInformation(), 
[10:30:51.391]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.391]                   signalCondition(cond)
[10:30:51.391]                 }
[10:30:51.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.391]                 "immediateCondition"))) {
[10:30:51.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.391]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.391]                   if (TRUE && !signal) {
[10:30:51.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.391]                     {
[10:30:51.391]                       inherits <- base::inherits
[10:30:51.391]                       invokeRestart <- base::invokeRestart
[10:30:51.391]                       is.null <- base::is.null
[10:30:51.391]                       muffled <- FALSE
[10:30:51.391]                       if (inherits(cond, "message")) {
[10:30:51.391]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.391]                         if (muffled) 
[10:30:51.391]                           invokeRestart("muffleMessage")
[10:30:51.391]                       }
[10:30:51.391]                       else if (inherits(cond, "warning")) {
[10:30:51.391]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.391]                         if (muffled) 
[10:30:51.391]                           invokeRestart("muffleWarning")
[10:30:51.391]                       }
[10:30:51.391]                       else if (inherits(cond, "condition")) {
[10:30:51.391]                         if (!is.null(pattern)) {
[10:30:51.391]                           computeRestarts <- base::computeRestarts
[10:30:51.391]                           grepl <- base::grepl
[10:30:51.391]                           restarts <- computeRestarts(cond)
[10:30:51.391]                           for (restart in restarts) {
[10:30:51.391]                             name <- restart$name
[10:30:51.391]                             if (is.null(name)) 
[10:30:51.391]                               next
[10:30:51.391]                             if (!grepl(pattern, name)) 
[10:30:51.391]                               next
[10:30:51.391]                             invokeRestart(restart)
[10:30:51.391]                             muffled <- TRUE
[10:30:51.391]                             break
[10:30:51.391]                           }
[10:30:51.391]                         }
[10:30:51.391]                       }
[10:30:51.391]                       invisible(muffled)
[10:30:51.391]                     }
[10:30:51.391]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.391]                   }
[10:30:51.391]                 }
[10:30:51.391]                 else {
[10:30:51.391]                   if (TRUE) {
[10:30:51.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.391]                     {
[10:30:51.391]                       inherits <- base::inherits
[10:30:51.391]                       invokeRestart <- base::invokeRestart
[10:30:51.391]                       is.null <- base::is.null
[10:30:51.391]                       muffled <- FALSE
[10:30:51.391]                       if (inherits(cond, "message")) {
[10:30:51.391]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.391]                         if (muffled) 
[10:30:51.391]                           invokeRestart("muffleMessage")
[10:30:51.391]                       }
[10:30:51.391]                       else if (inherits(cond, "warning")) {
[10:30:51.391]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.391]                         if (muffled) 
[10:30:51.391]                           invokeRestart("muffleWarning")
[10:30:51.391]                       }
[10:30:51.391]                       else if (inherits(cond, "condition")) {
[10:30:51.391]                         if (!is.null(pattern)) {
[10:30:51.391]                           computeRestarts <- base::computeRestarts
[10:30:51.391]                           grepl <- base::grepl
[10:30:51.391]                           restarts <- computeRestarts(cond)
[10:30:51.391]                           for (restart in restarts) {
[10:30:51.391]                             name <- restart$name
[10:30:51.391]                             if (is.null(name)) 
[10:30:51.391]                               next
[10:30:51.391]                             if (!grepl(pattern, name)) 
[10:30:51.391]                               next
[10:30:51.391]                             invokeRestart(restart)
[10:30:51.391]                             muffled <- TRUE
[10:30:51.391]                             break
[10:30:51.391]                           }
[10:30:51.391]                         }
[10:30:51.391]                       }
[10:30:51.391]                       invisible(muffled)
[10:30:51.391]                     }
[10:30:51.391]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.391]                   }
[10:30:51.391]                 }
[10:30:51.391]             }
[10:30:51.391]         }))
[10:30:51.391]     }, error = function(ex) {
[10:30:51.391]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.391]                 ...future.rng), started = ...future.startTime, 
[10:30:51.391]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.391]             version = "1.8"), class = "FutureResult")
[10:30:51.391]     }, finally = {
[10:30:51.391]         if (!identical(...future.workdir, getwd())) 
[10:30:51.391]             setwd(...future.workdir)
[10:30:51.391]         {
[10:30:51.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.391]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.391]             }
[10:30:51.391]             base::options(...future.oldOptions)
[10:30:51.391]             if (.Platform$OS.type == "windows") {
[10:30:51.391]                 old_names <- names(...future.oldEnvVars)
[10:30:51.391]                 envs <- base::Sys.getenv()
[10:30:51.391]                 names <- names(envs)
[10:30:51.391]                 common <- intersect(names, old_names)
[10:30:51.391]                 added <- setdiff(names, old_names)
[10:30:51.391]                 removed <- setdiff(old_names, names)
[10:30:51.391]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.391]                   envs[common]]
[10:30:51.391]                 NAMES <- toupper(changed)
[10:30:51.391]                 args <- list()
[10:30:51.391]                 for (kk in seq_along(NAMES)) {
[10:30:51.391]                   name <- changed[[kk]]
[10:30:51.391]                   NAME <- NAMES[[kk]]
[10:30:51.391]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.391]                     next
[10:30:51.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.391]                 }
[10:30:51.391]                 NAMES <- toupper(added)
[10:30:51.391]                 for (kk in seq_along(NAMES)) {
[10:30:51.391]                   name <- added[[kk]]
[10:30:51.391]                   NAME <- NAMES[[kk]]
[10:30:51.391]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.391]                     next
[10:30:51.391]                   args[[name]] <- ""
[10:30:51.391]                 }
[10:30:51.391]                 NAMES <- toupper(removed)
[10:30:51.391]                 for (kk in seq_along(NAMES)) {
[10:30:51.391]                   name <- removed[[kk]]
[10:30:51.391]                   NAME <- NAMES[[kk]]
[10:30:51.391]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.391]                     next
[10:30:51.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.391]                 }
[10:30:51.391]                 if (length(args) > 0) 
[10:30:51.391]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.391]             }
[10:30:51.391]             else {
[10:30:51.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.391]             }
[10:30:51.391]             {
[10:30:51.391]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.391]                   0L) {
[10:30:51.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.391]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.391]                   base::options(opts)
[10:30:51.391]                 }
[10:30:51.391]                 {
[10:30:51.391]                   {
[10:30:51.391]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.391]                     NULL
[10:30:51.391]                   }
[10:30:51.391]                   options(future.plan = NULL)
[10:30:51.391]                   if (is.na(NA_character_)) 
[10:30:51.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.391]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.391]                     .init = FALSE)
[10:30:51.391]                 }
[10:30:51.391]             }
[10:30:51.391]         }
[10:30:51.391]     })
[10:30:51.391]     if (TRUE) {
[10:30:51.391]         base::sink(type = "output", split = FALSE)
[10:30:51.391]         if (TRUE) {
[10:30:51.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.391]         }
[10:30:51.391]         else {
[10:30:51.391]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.391]         }
[10:30:51.391]         base::close(...future.stdout)
[10:30:51.391]         ...future.stdout <- NULL
[10:30:51.391]     }
[10:30:51.391]     ...future.result$conditions <- ...future.conditions
[10:30:51.391]     ...future.result$finished <- base::Sys.time()
[10:30:51.391]     ...future.result
[10:30:51.391] }
[10:30:51.394] assign_globals() ...
[10:30:51.394] List of 5
[10:30:51.394]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:30:51.394]  $ MoreArgs                 :List of 1
[10:30:51.394]   ..$ min: num 1
[10:30:51.394]  $ ...future.elements_ii    :List of 2
[10:30:51.394]   ..$ n  :List of 2
[10:30:51.394]   .. ..$ : int 1
[10:30:51.394]   .. ..$ : int 2
[10:30:51.394]   ..$ max:List of 2
[10:30:51.394]   .. ..$ : int 2
[10:30:51.394]   .. ..$ : int 3
[10:30:51.394]  $ ...future.seeds_ii       :List of 2
[10:30:51.394]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:30:51.394]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:30:51.394]  $ ...future.globals.maxSize: NULL
[10:30:51.394]  - attr(*, "where")=List of 5
[10:30:51.394]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.394]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.394]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.394]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.394]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.394]  - attr(*, "resolved")= logi FALSE
[10:30:51.394]  - attr(*, "total_size")= num 2528
[10:30:51.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.394]  - attr(*, "already-done")= logi TRUE
[10:30:51.402] - copied ‘...future.FUN’ to environment
[10:30:51.402] - copied ‘MoreArgs’ to environment
[10:30:51.402] - copied ‘...future.elements_ii’ to environment
[10:30:51.402] - copied ‘...future.seeds_ii’ to environment
[10:30:51.402] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.402] assign_globals() ... done
[10:30:51.402] requestCore(): workers = 2
[10:30:51.405] MulticoreFuture started
[10:30:51.405] - Launch lazy future ... done
[10:30:51.405] run() for ‘MulticoreFuture’ ... done
[10:30:51.406] Created future:
[10:30:51.406] plan(): Setting new future strategy stack:
[10:30:51.406] List of future strategies:
[10:30:51.406] 1. sequential:
[10:30:51.406]    - args: function (..., envir = parent.frame())
[10:30:51.406]    - tweaked: FALSE
[10:30:51.406]    - call: NULL
[10:30:51.407] plan(): nbrOfWorkers() = 1
[10:30:51.409] plan(): Setting new future strategy stack:
[10:30:51.410] List of future strategies:
[10:30:51.410] 1. multicore:
[10:30:51.410]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.410]    - tweaked: FALSE
[10:30:51.410]    - call: plan(strategy)
[10:30:51.415] plan(): nbrOfWorkers() = 2
[10:30:51.406] MulticoreFuture:
[10:30:51.406] Label: ‘future_mapply-1’
[10:30:51.406] Expression:
[10:30:51.406] {
[10:30:51.406]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.406]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.406]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.406]         on.exit(options(oopts), add = TRUE)
[10:30:51.406]     }
[10:30:51.406]     {
[10:30:51.406]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:51.406]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:51.406]                 inherits = FALSE)
[10:30:51.406]             ...future.FUN(...)
[10:30:51.406]         }
[10:30:51.406]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:51.406]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:51.406]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.406]         do.call(mapply, args = args)
[10:30:51.406]     }
[10:30:51.406] }
[10:30:51.406] Lazy evaluation: FALSE
[10:30:51.406] Asynchronous evaluation: TRUE
[10:30:51.406] Local evaluation: TRUE
[10:30:51.406] Environment: R_GlobalEnv
[10:30:51.406] Capture standard output: TRUE
[10:30:51.406] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.406] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.406] Packages: 1 packages (‘stats’)
[10:30:51.406] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:51.406] Resolved: TRUE
[10:30:51.406] Value: <not collected>
[10:30:51.406] Conditions captured: <none>
[10:30:51.406] Early signaling: FALSE
[10:30:51.406] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.406] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.416] Chunk #1 of 2 ... DONE
[10:30:51.416] Chunk #2 of 2 ...
[10:30:51.417]  - Finding globals in '...' for chunk #2 ...
[10:30:51.417] getGlobalsAndPackages() ...
[10:30:51.417] Searching for globals...
[10:30:51.418] 
[10:30:51.418] Searching for globals ... DONE
[10:30:51.418] - globals: [0] <none>
[10:30:51.418] getGlobalsAndPackages() ... DONE
[10:30:51.418]    + additional globals found: [n=0] 
[10:30:51.418]    + additional namespaces needed: [n=0] 
[10:30:51.418]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:51.418]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.419]  - seeds: [2] <seeds>
[10:30:51.419]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.419] getGlobalsAndPackages() ...
[10:30:51.419] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.419] Resolving globals: FALSE
[10:30:51.420] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[10:30:51.421] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[10:30:51.422] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.426] - packages: [1] ‘stats’
[10:30:51.426] getGlobalsAndPackages() ... DONE
[10:30:51.427] run() for ‘Future’ ...
[10:30:51.428] - state: ‘created’
[10:30:51.428] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.435] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.435]   - Field: ‘label’
[10:30:51.436]   - Field: ‘local’
[10:30:51.436]   - Field: ‘owner’
[10:30:51.436]   - Field: ‘envir’
[10:30:51.436]   - Field: ‘workers’
[10:30:51.437]   - Field: ‘packages’
[10:30:51.437]   - Field: ‘gc’
[10:30:51.437]   - Field: ‘job’
[10:30:51.437]   - Field: ‘conditions’
[10:30:51.438]   - Field: ‘expr’
[10:30:51.438]   - Field: ‘uuid’
[10:30:51.438]   - Field: ‘seed’
[10:30:51.438]   - Field: ‘version’
[10:30:51.438]   - Field: ‘result’
[10:30:51.439]   - Field: ‘asynchronous’
[10:30:51.439]   - Field: ‘calls’
[10:30:51.439]   - Field: ‘globals’
[10:30:51.439]   - Field: ‘stdout’
[10:30:51.439]   - Field: ‘earlySignal’
[10:30:51.440]   - Field: ‘lazy’
[10:30:51.440]   - Field: ‘state’
[10:30:51.440] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.440] - Launch lazy future ...
[10:30:51.441] Packages needed by the future expression (n = 1): ‘stats’
[10:30:51.441] Packages needed by future strategies (n = 0): <none>
[10:30:51.442] {
[10:30:51.442]     {
[10:30:51.442]         {
[10:30:51.442]             ...future.startTime <- base::Sys.time()
[10:30:51.442]             {
[10:30:51.442]                 {
[10:30:51.442]                   {
[10:30:51.442]                     {
[10:30:51.442]                       {
[10:30:51.442]                         base::local({
[10:30:51.442]                           has_future <- base::requireNamespace("future", 
[10:30:51.442]                             quietly = TRUE)
[10:30:51.442]                           if (has_future) {
[10:30:51.442]                             ns <- base::getNamespace("future")
[10:30:51.442]                             version <- ns[[".package"]][["version"]]
[10:30:51.442]                             if (is.null(version)) 
[10:30:51.442]                               version <- utils::packageVersion("future")
[10:30:51.442]                           }
[10:30:51.442]                           else {
[10:30:51.442]                             version <- NULL
[10:30:51.442]                           }
[10:30:51.442]                           if (!has_future || version < "1.8.0") {
[10:30:51.442]                             info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.442]                               "", base::R.version$version.string), 
[10:30:51.442]                               platform = base::sprintf("%s (%s-bit)", 
[10:30:51.442]                                 base::R.version$platform, 8 * 
[10:30:51.442]                                   base::.Machine$sizeof.pointer), 
[10:30:51.442]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.442]                                 "release", "version")], collapse = " "), 
[10:30:51.442]                               hostname = base::Sys.info()[["nodename"]])
[10:30:51.442]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.442]                               info)
[10:30:51.442]                             info <- base::paste(info, collapse = "; ")
[10:30:51.442]                             if (!has_future) {
[10:30:51.442]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.442]                                 info)
[10:30:51.442]                             }
[10:30:51.442]                             else {
[10:30:51.442]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.442]                                 info, version)
[10:30:51.442]                             }
[10:30:51.442]                             base::stop(msg)
[10:30:51.442]                           }
[10:30:51.442]                         })
[10:30:51.442]                       }
[10:30:51.442]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.442]                       base::options(mc.cores = 1L)
[10:30:51.442]                     }
[10:30:51.442]                     base::local({
[10:30:51.442]                       for (pkg in "stats") {
[10:30:51.442]                         base::loadNamespace(pkg)
[10:30:51.442]                         base::library(pkg, character.only = TRUE)
[10:30:51.442]                       }
[10:30:51.442]                     })
[10:30:51.442]                   }
[10:30:51.442]                   ...future.strategy.old <- future::plan("list")
[10:30:51.442]                   options(future.plan = NULL)
[10:30:51.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.442]                 }
[10:30:51.442]                 ...future.workdir <- getwd()
[10:30:51.442]             }
[10:30:51.442]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.442]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.442]         }
[10:30:51.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.442]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.442]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.442]             base::names(...future.oldOptions))
[10:30:51.442]     }
[10:30:51.442]     if (FALSE) {
[10:30:51.442]     }
[10:30:51.442]     else {
[10:30:51.442]         if (TRUE) {
[10:30:51.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.442]                 open = "w")
[10:30:51.442]         }
[10:30:51.442]         else {
[10:30:51.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.442]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.442]         }
[10:30:51.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.442]             base::sink(type = "output", split = FALSE)
[10:30:51.442]             base::close(...future.stdout)
[10:30:51.442]         }, add = TRUE)
[10:30:51.442]     }
[10:30:51.442]     ...future.frame <- base::sys.nframe()
[10:30:51.442]     ...future.conditions <- base::list()
[10:30:51.442]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.442]     if (FALSE) {
[10:30:51.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.442]     }
[10:30:51.442]     ...future.result <- base::tryCatch({
[10:30:51.442]         base::withCallingHandlers({
[10:30:51.442]             ...future.value <- base::withVisible(base::local({
[10:30:51.442]                 withCallingHandlers({
[10:30:51.442]                   {
[10:30:51.442]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.442]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.442]                       ...future.globals.maxSize)) {
[10:30:51.442]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.442]                       on.exit(options(oopts), add = TRUE)
[10:30:51.442]                     }
[10:30:51.442]                     {
[10:30:51.442]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:51.442]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:51.442]                           envir = globalenv(), inherits = FALSE)
[10:30:51.442]                         ...future.FUN(...)
[10:30:51.442]                       }
[10:30:51.442]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:51.442]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:51.442]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.442]                         USE.NAMES = FALSE)
[10:30:51.442]                       do.call(mapply, args = args)
[10:30:51.442]                     }
[10:30:51.442]                   }
[10:30:51.442]                 }, immediateCondition = function(cond) {
[10:30:51.442]                   save_rds <- function (object, pathname, ...) 
[10:30:51.442]                   {
[10:30:51.442]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.442]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.442]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.442]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.442]                         fi_tmp[["mtime"]])
[10:30:51.442]                     }
[10:30:51.442]                     tryCatch({
[10:30:51.442]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.442]                     }, error = function(ex) {
[10:30:51.442]                       msg <- conditionMessage(ex)
[10:30:51.442]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.442]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.442]                         fi_tmp[["mtime"]], msg)
[10:30:51.442]                       ex$message <- msg
[10:30:51.442]                       stop(ex)
[10:30:51.442]                     })
[10:30:51.442]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.442]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.442]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.442]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.442]                       fi <- file.info(pathname)
[10:30:51.442]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.442]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.442]                         fi[["size"]], fi[["mtime"]])
[10:30:51.442]                       stop(msg)
[10:30:51.442]                     }
[10:30:51.442]                     invisible(pathname)
[10:30:51.442]                   }
[10:30:51.442]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.442]                     rootPath = tempdir()) 
[10:30:51.442]                   {
[10:30:51.442]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.442]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.442]                       tmpdir = path, fileext = ".rds")
[10:30:51.442]                     save_rds(obj, file)
[10:30:51.442]                   }
[10:30:51.442]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.442]                   {
[10:30:51.442]                     inherits <- base::inherits
[10:30:51.442]                     invokeRestart <- base::invokeRestart
[10:30:51.442]                     is.null <- base::is.null
[10:30:51.442]                     muffled <- FALSE
[10:30:51.442]                     if (inherits(cond, "message")) {
[10:30:51.442]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.442]                       if (muffled) 
[10:30:51.442]                         invokeRestart("muffleMessage")
[10:30:51.442]                     }
[10:30:51.442]                     else if (inherits(cond, "warning")) {
[10:30:51.442]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.442]                       if (muffled) 
[10:30:51.442]                         invokeRestart("muffleWarning")
[10:30:51.442]                     }
[10:30:51.442]                     else if (inherits(cond, "condition")) {
[10:30:51.442]                       if (!is.null(pattern)) {
[10:30:51.442]                         computeRestarts <- base::computeRestarts
[10:30:51.442]                         grepl <- base::grepl
[10:30:51.442]                         restarts <- computeRestarts(cond)
[10:30:51.442]                         for (restart in restarts) {
[10:30:51.442]                           name <- restart$name
[10:30:51.442]                           if (is.null(name)) 
[10:30:51.442]                             next
[10:30:51.442]                           if (!grepl(pattern, name)) 
[10:30:51.442]                             next
[10:30:51.442]                           invokeRestart(restart)
[10:30:51.442]                           muffled <- TRUE
[10:30:51.442]                           break
[10:30:51.442]                         }
[10:30:51.442]                       }
[10:30:51.442]                     }
[10:30:51.442]                     invisible(muffled)
[10:30:51.442]                   }
[10:30:51.442]                   muffleCondition(cond)
[10:30:51.442]                 })
[10:30:51.442]             }))
[10:30:51.442]             future::FutureResult(value = ...future.value$value, 
[10:30:51.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.442]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.442]                     ...future.globalenv.names))
[10:30:51.442]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.442]         }, condition = base::local({
[10:30:51.442]             c <- base::c
[10:30:51.442]             inherits <- base::inherits
[10:30:51.442]             invokeRestart <- base::invokeRestart
[10:30:51.442]             length <- base::length
[10:30:51.442]             list <- base::list
[10:30:51.442]             seq.int <- base::seq.int
[10:30:51.442]             signalCondition <- base::signalCondition
[10:30:51.442]             sys.calls <- base::sys.calls
[10:30:51.442]             `[[` <- base::`[[`
[10:30:51.442]             `+` <- base::`+`
[10:30:51.442]             `<<-` <- base::`<<-`
[10:30:51.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.442]                   3L)]
[10:30:51.442]             }
[10:30:51.442]             function(cond) {
[10:30:51.442]                 is_error <- inherits(cond, "error")
[10:30:51.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.442]                   NULL)
[10:30:51.442]                 if (is_error) {
[10:30:51.442]                   sessionInformation <- function() {
[10:30:51.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.442]                       search = base::search(), system = base::Sys.info())
[10:30:51.442]                   }
[10:30:51.442]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.442]                     cond$call), session = sessionInformation(), 
[10:30:51.442]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.442]                   signalCondition(cond)
[10:30:51.442]                 }
[10:30:51.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.442]                 "immediateCondition"))) {
[10:30:51.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.442]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.442]                   if (TRUE && !signal) {
[10:30:51.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.442]                     {
[10:30:51.442]                       inherits <- base::inherits
[10:30:51.442]                       invokeRestart <- base::invokeRestart
[10:30:51.442]                       is.null <- base::is.null
[10:30:51.442]                       muffled <- FALSE
[10:30:51.442]                       if (inherits(cond, "message")) {
[10:30:51.442]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.442]                         if (muffled) 
[10:30:51.442]                           invokeRestart("muffleMessage")
[10:30:51.442]                       }
[10:30:51.442]                       else if (inherits(cond, "warning")) {
[10:30:51.442]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.442]                         if (muffled) 
[10:30:51.442]                           invokeRestart("muffleWarning")
[10:30:51.442]                       }
[10:30:51.442]                       else if (inherits(cond, "condition")) {
[10:30:51.442]                         if (!is.null(pattern)) {
[10:30:51.442]                           computeRestarts <- base::computeRestarts
[10:30:51.442]                           grepl <- base::grepl
[10:30:51.442]                           restarts <- computeRestarts(cond)
[10:30:51.442]                           for (restart in restarts) {
[10:30:51.442]                             name <- restart$name
[10:30:51.442]                             if (is.null(name)) 
[10:30:51.442]                               next
[10:30:51.442]                             if (!grepl(pattern, name)) 
[10:30:51.442]                               next
[10:30:51.442]                             invokeRestart(restart)
[10:30:51.442]                             muffled <- TRUE
[10:30:51.442]                             break
[10:30:51.442]                           }
[10:30:51.442]                         }
[10:30:51.442]                       }
[10:30:51.442]                       invisible(muffled)
[10:30:51.442]                     }
[10:30:51.442]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.442]                   }
[10:30:51.442]                 }
[10:30:51.442]                 else {
[10:30:51.442]                   if (TRUE) {
[10:30:51.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.442]                     {
[10:30:51.442]                       inherits <- base::inherits
[10:30:51.442]                       invokeRestart <- base::invokeRestart
[10:30:51.442]                       is.null <- base::is.null
[10:30:51.442]                       muffled <- FALSE
[10:30:51.442]                       if (inherits(cond, "message")) {
[10:30:51.442]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.442]                         if (muffled) 
[10:30:51.442]                           invokeRestart("muffleMessage")
[10:30:51.442]                       }
[10:30:51.442]                       else if (inherits(cond, "warning")) {
[10:30:51.442]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.442]                         if (muffled) 
[10:30:51.442]                           invokeRestart("muffleWarning")
[10:30:51.442]                       }
[10:30:51.442]                       else if (inherits(cond, "condition")) {
[10:30:51.442]                         if (!is.null(pattern)) {
[10:30:51.442]                           computeRestarts <- base::computeRestarts
[10:30:51.442]                           grepl <- base::grepl
[10:30:51.442]                           restarts <- computeRestarts(cond)
[10:30:51.442]                           for (restart in restarts) {
[10:30:51.442]                             name <- restart$name
[10:30:51.442]                             if (is.null(name)) 
[10:30:51.442]                               next
[10:30:51.442]                             if (!grepl(pattern, name)) 
[10:30:51.442]                               next
[10:30:51.442]                             invokeRestart(restart)
[10:30:51.442]                             muffled <- TRUE
[10:30:51.442]                             break
[10:30:51.442]                           }
[10:30:51.442]                         }
[10:30:51.442]                       }
[10:30:51.442]                       invisible(muffled)
[10:30:51.442]                     }
[10:30:51.442]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.442]                   }
[10:30:51.442]                 }
[10:30:51.442]             }
[10:30:51.442]         }))
[10:30:51.442]     }, error = function(ex) {
[10:30:51.442]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.442]                 ...future.rng), started = ...future.startTime, 
[10:30:51.442]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.442]             version = "1.8"), class = "FutureResult")
[10:30:51.442]     }, finally = {
[10:30:51.442]         if (!identical(...future.workdir, getwd())) 
[10:30:51.442]             setwd(...future.workdir)
[10:30:51.442]         {
[10:30:51.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.442]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.442]             }
[10:30:51.442]             base::options(...future.oldOptions)
[10:30:51.442]             if (.Platform$OS.type == "windows") {
[10:30:51.442]                 old_names <- names(...future.oldEnvVars)
[10:30:51.442]                 envs <- base::Sys.getenv()
[10:30:51.442]                 names <- names(envs)
[10:30:51.442]                 common <- intersect(names, old_names)
[10:30:51.442]                 added <- setdiff(names, old_names)
[10:30:51.442]                 removed <- setdiff(old_names, names)
[10:30:51.442]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.442]                   envs[common]]
[10:30:51.442]                 NAMES <- toupper(changed)
[10:30:51.442]                 args <- list()
[10:30:51.442]                 for (kk in seq_along(NAMES)) {
[10:30:51.442]                   name <- changed[[kk]]
[10:30:51.442]                   NAME <- NAMES[[kk]]
[10:30:51.442]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.442]                     next
[10:30:51.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.442]                 }
[10:30:51.442]                 NAMES <- toupper(added)
[10:30:51.442]                 for (kk in seq_along(NAMES)) {
[10:30:51.442]                   name <- added[[kk]]
[10:30:51.442]                   NAME <- NAMES[[kk]]
[10:30:51.442]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.442]                     next
[10:30:51.442]                   args[[name]] <- ""
[10:30:51.442]                 }
[10:30:51.442]                 NAMES <- toupper(removed)
[10:30:51.442]                 for (kk in seq_along(NAMES)) {
[10:30:51.442]                   name <- removed[[kk]]
[10:30:51.442]                   NAME <- NAMES[[kk]]
[10:30:51.442]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.442]                     next
[10:30:51.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.442]                 }
[10:30:51.442]                 if (length(args) > 0) 
[10:30:51.442]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.442]             }
[10:30:51.442]             else {
[10:30:51.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.442]             }
[10:30:51.442]             {
[10:30:51.442]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.442]                   0L) {
[10:30:51.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.442]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.442]                   base::options(opts)
[10:30:51.442]                 }
[10:30:51.442]                 {
[10:30:51.442]                   {
[10:30:51.442]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.442]                     NULL
[10:30:51.442]                   }
[10:30:51.442]                   options(future.plan = NULL)
[10:30:51.442]                   if (is.na(NA_character_)) 
[10:30:51.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.442]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.442]                     .init = FALSE)
[10:30:51.442]                 }
[10:30:51.442]             }
[10:30:51.442]         }
[10:30:51.442]     })
[10:30:51.442]     if (TRUE) {
[10:30:51.442]         base::sink(type = "output", split = FALSE)
[10:30:51.442]         if (TRUE) {
[10:30:51.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.442]         }
[10:30:51.442]         else {
[10:30:51.442]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.442]         }
[10:30:51.442]         base::close(...future.stdout)
[10:30:51.442]         ...future.stdout <- NULL
[10:30:51.442]     }
[10:30:51.442]     ...future.result$conditions <- ...future.conditions
[10:30:51.442]     ...future.result$finished <- base::Sys.time()
[10:30:51.442]     ...future.result
[10:30:51.442] }
[10:30:51.445] assign_globals() ...
[10:30:51.445] List of 5
[10:30:51.445]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:30:51.445]  $ MoreArgs                 :List of 1
[10:30:51.445]   ..$ min: num 1
[10:30:51.445]  $ ...future.elements_ii    :List of 2
[10:30:51.445]   ..$ n  :List of 2
[10:30:51.445]   .. ..$ : int 3
[10:30:51.445]   .. ..$ : int 4
[10:30:51.445]   ..$ max:List of 2
[10:30:51.445]   .. ..$ : int 4
[10:30:51.445]   .. ..$ : int 5
[10:30:51.445]  $ ...future.seeds_ii       :List of 2
[10:30:51.445]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[10:30:51.445]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[10:30:51.445]  $ ...future.globals.maxSize: NULL
[10:30:51.445]  - attr(*, "where")=List of 5
[10:30:51.445]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.445]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.445]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.445]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.445]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.445]  - attr(*, "resolved")= logi FALSE
[10:30:51.445]  - attr(*, "total_size")= num 2528
[10:30:51.445]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.445]  - attr(*, "already-done")= logi TRUE
[10:30:51.455] - copied ‘...future.FUN’ to environment
[10:30:51.455] - copied ‘MoreArgs’ to environment
[10:30:51.455] - copied ‘...future.elements_ii’ to environment
[10:30:51.456] - copied ‘...future.seeds_ii’ to environment
[10:30:51.456] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.456] assign_globals() ... done
[10:30:51.456] requestCore(): workers = 2
[10:30:51.458] MulticoreFuture started
[10:30:51.459] - Launch lazy future ... done
[10:30:51.459] run() for ‘MulticoreFuture’ ... done
[10:30:51.459] Created future:
[10:30:51.460] plan(): Setting new future strategy stack:
[10:30:51.460] List of future strategies:
[10:30:51.460] 1. sequential:
[10:30:51.460]    - args: function (..., envir = parent.frame())
[10:30:51.460]    - tweaked: FALSE
[10:30:51.460]    - call: NULL
[10:30:51.461] plan(): nbrOfWorkers() = 1
[10:30:51.463] plan(): Setting new future strategy stack:
[10:30:51.463] List of future strategies:
[10:30:51.463] 1. multicore:
[10:30:51.463]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.463]    - tweaked: FALSE
[10:30:51.463]    - call: plan(strategy)
[10:30:51.469] plan(): nbrOfWorkers() = 2
[10:30:51.460] MulticoreFuture:
[10:30:51.460] Label: ‘future_mapply-2’
[10:30:51.460] Expression:
[10:30:51.460] {
[10:30:51.460]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.460]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.460]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.460]         on.exit(options(oopts), add = TRUE)
[10:30:51.460]     }
[10:30:51.460]     {
[10:30:51.460]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:51.460]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:51.460]                 inherits = FALSE)
[10:30:51.460]             ...future.FUN(...)
[10:30:51.460]         }
[10:30:51.460]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:51.460]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:51.460]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.460]         do.call(mapply, args = args)
[10:30:51.460]     }
[10:30:51.460] }
[10:30:51.460] Lazy evaluation: FALSE
[10:30:51.460] Asynchronous evaluation: TRUE
[10:30:51.460] Local evaluation: TRUE
[10:30:51.460] Environment: R_GlobalEnv
[10:30:51.460] Capture standard output: TRUE
[10:30:51.460] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.460] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.460] Packages: 1 packages (‘stats’)
[10:30:51.460] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:51.460] Resolved: TRUE
[10:30:51.460] Value: <not collected>
[10:30:51.460] Conditions captured: <none>
[10:30:51.460] Early signaling: FALSE
[10:30:51.460] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.460] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.470] Chunk #2 of 2 ... DONE
[10:30:51.470] Launching 2 futures (chunks) ... DONE
[10:30:51.470] Resolving 2 futures (chunks) ...
[10:30:51.470] resolve() on list ...
[10:30:51.470]  recursive: 0
[10:30:51.471]  length: 2
[10:30:51.471] 
[10:30:51.471] Future #1
[10:30:51.471] result() for MulticoreFuture ...
[10:30:51.472] result() for MulticoreFuture ...
[10:30:51.472] result() for MulticoreFuture ... done
[10:30:51.472] result() for MulticoreFuture ... done
[10:30:51.473] result() for MulticoreFuture ...
[10:30:51.473] result() for MulticoreFuture ... done
[10:30:51.473] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:51.473] - nx: 2
[10:30:51.473] - relay: TRUE
[10:30:51.473] - stdout: TRUE
[10:30:51.474] - signal: TRUE
[10:30:51.478] - resignal: FALSE
[10:30:51.478] - force: TRUE
[10:30:51.478] - relayed: [n=2] FALSE, FALSE
[10:30:51.479] - queued futures: [n=2] FALSE, FALSE
[10:30:51.479]  - until=1
[10:30:51.480]  - relaying element #1
[10:30:51.480] result() for MulticoreFuture ...
[10:30:51.480] result() for MulticoreFuture ... done
[10:30:51.481] result() for MulticoreFuture ...
[10:30:51.481] result() for MulticoreFuture ... done
[10:30:51.481] result() for MulticoreFuture ...
[10:30:51.482] result() for MulticoreFuture ... done
[10:30:51.482] result() for MulticoreFuture ...
[10:30:51.482] result() for MulticoreFuture ... done
[10:30:51.483] - relayed: [n=2] TRUE, FALSE
[10:30:51.483] - queued futures: [n=2] TRUE, FALSE
[10:30:51.483] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:51.484]  length: 1 (resolved future 1)
[10:30:51.484] Future #2
[10:30:51.484] result() for MulticoreFuture ...
[10:30:51.485] result() for MulticoreFuture ...
[10:30:51.486] result() for MulticoreFuture ... done
[10:30:51.486] result() for MulticoreFuture ... done
[10:30:51.486] result() for MulticoreFuture ...
[10:30:51.486] result() for MulticoreFuture ... done
[10:30:51.487] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:51.487] - nx: 2
[10:30:51.487] - relay: TRUE
[10:30:51.487] - stdout: TRUE
[10:30:51.487] - signal: TRUE
[10:30:51.487] - resignal: FALSE
[10:30:51.488] - force: TRUE
[10:30:51.488] - relayed: [n=2] TRUE, FALSE
[10:30:51.488] - queued futures: [n=2] TRUE, FALSE
[10:30:51.488]  - until=2
[10:30:51.488]  - relaying element #2
[10:30:51.488] result() for MulticoreFuture ...
[10:30:51.489] result() for MulticoreFuture ... done
[10:30:51.489] result() for MulticoreFuture ...
[10:30:51.489] result() for MulticoreFuture ... done
[10:30:51.489] result() for MulticoreFuture ...
[10:30:51.489] result() for MulticoreFuture ... done
[10:30:51.489] result() for MulticoreFuture ...
[10:30:51.490] result() for MulticoreFuture ... done
[10:30:51.490] - relayed: [n=2] TRUE, TRUE
[10:30:51.490] - queued futures: [n=2] TRUE, TRUE
[10:30:51.490] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:51.490]  length: 0 (resolved future 2)
[10:30:51.490] Relaying remaining futures
[10:30:51.490] signalConditionsASAP(NULL, pos=0) ...
[10:30:51.491] - nx: 2
[10:30:51.491] - relay: TRUE
[10:30:51.491] - stdout: TRUE
[10:30:51.491] - signal: TRUE
[10:30:51.491] - resignal: FALSE
[10:30:51.491] - force: TRUE
[10:30:51.491] - relayed: [n=2] TRUE, TRUE
[10:30:51.491] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:51.492] - relayed: [n=2] TRUE, TRUE
[10:30:51.492] - queued futures: [n=2] TRUE, TRUE
[10:30:51.492] signalConditionsASAP(NULL, pos=0) ... done
[10:30:51.492] resolve() on list ... DONE
[10:30:51.492] result() for MulticoreFuture ...
[10:30:51.492] result() for MulticoreFuture ... done
[10:30:51.492] result() for MulticoreFuture ...
[10:30:51.492] result() for MulticoreFuture ... done
[10:30:51.493] result() for MulticoreFuture ...
[10:30:51.493] result() for MulticoreFuture ... done
[10:30:51.493] result() for MulticoreFuture ...
[10:30:51.493] result() for MulticoreFuture ... done
[10:30:51.493]  - Number of value chunks collected: 2
[10:30:51.493] Resolving 2 futures (chunks) ... DONE
[10:30:51.493] Reducing values from 2 chunks ...
[10:30:51.493]  - Number of values collected after concatenation: 4
[10:30:51.494]  - Number of values expected: 4
[10:30:51.494] Reducing values from 2 chunks ... DONE
[10:30:51.494] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[10:30:51.495] future_mapply() ...
[10:30:51.499] Number of chunks: 2
[10:30:51.499] getGlobalsAndPackagesXApply() ...
[10:30:51.500]  - future.globals: TRUE
[10:30:51.500] getGlobalsAndPackages() ...
[10:30:51.500] Searching for globals...
[10:30:51.501] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:30:51.501] Searching for globals ... DONE
[10:30:51.501] Resolving globals: FALSE
[10:30:51.502] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[10:30:51.502] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[10:30:51.502] - globals: [1] ‘FUN’
[10:30:51.503] - packages: [1] ‘stats’
[10:30:51.503] getGlobalsAndPackages() ... DONE
[10:30:51.503]  - globals found/used: [n=1] ‘FUN’
[10:30:51.503]  - needed namespaces: [n=1] ‘stats’
[10:30:51.503] Finding globals ... DONE
[10:30:51.503] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:51.503] List of 2
[10:30:51.503]  $ ...future.FUN:function (x, w, ...)  
[10:30:51.503]  $ MoreArgs     : NULL
[10:30:51.503]  - attr(*, "where")=List of 2
[10:30:51.503]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:51.503]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:51.503]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.503]  - attr(*, "resolved")= logi FALSE
[10:30:51.503]  - attr(*, "total_size")= num NA
[10:30:51.507] Packages to be attached in all futures: [n=1] ‘stats’
[10:30:51.507] getGlobalsAndPackagesXApply() ... DONE
[10:30:51.507] Number of futures (= number of chunks): 2
[10:30:51.507] Launching 2 futures (chunks) ...
[10:30:51.508] Chunk #1 of 2 ...
[10:30:51.508]  - Finding globals in '...' for chunk #1 ...
[10:30:51.508] getGlobalsAndPackages() ...
[10:30:51.508] Searching for globals...
[10:30:51.509] 
[10:30:51.509] Searching for globals ... DONE
[10:30:51.509] - globals: [0] <none>
[10:30:51.510] getGlobalsAndPackages() ... DONE
[10:30:51.510]    + additional globals found: [n=0] 
[10:30:51.510]    + additional namespaces needed: [n=0] 
[10:30:51.510]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:51.514]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.514]  - seeds: <none>
[10:30:51.514]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.515] getGlobalsAndPackages() ...
[10:30:51.515] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.515] Resolving globals: FALSE
[10:30:51.516] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[10:30:51.517] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:51.517] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.518] - packages: [1] ‘stats’
[10:30:51.518] getGlobalsAndPackages() ... DONE
[10:30:51.518] run() for ‘Future’ ...
[10:30:51.519] - state: ‘created’
[10:30:51.519] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.524] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.524] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.524]   - Field: ‘label’
[10:30:51.524]   - Field: ‘local’
[10:30:51.524]   - Field: ‘owner’
[10:30:51.524]   - Field: ‘envir’
[10:30:51.524]   - Field: ‘workers’
[10:30:51.524]   - Field: ‘packages’
[10:30:51.525]   - Field: ‘gc’
[10:30:51.525]   - Field: ‘job’
[10:30:51.525]   - Field: ‘conditions’
[10:30:51.525]   - Field: ‘expr’
[10:30:51.525]   - Field: ‘uuid’
[10:30:51.525]   - Field: ‘seed’
[10:30:51.525]   - Field: ‘version’
[10:30:51.525]   - Field: ‘result’
[10:30:51.526]   - Field: ‘asynchronous’
[10:30:51.526]   - Field: ‘calls’
[10:30:51.526]   - Field: ‘globals’
[10:30:51.526]   - Field: ‘stdout’
[10:30:51.526]   - Field: ‘earlySignal’
[10:30:51.526]   - Field: ‘lazy’
[10:30:51.526]   - Field: ‘state’
[10:30:51.526] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.527] - Launch lazy future ...
[10:30:51.527] Packages needed by the future expression (n = 1): ‘stats’
[10:30:51.527] Packages needed by future strategies (n = 0): <none>
[10:30:51.528] {
[10:30:51.528]     {
[10:30:51.528]         {
[10:30:51.528]             ...future.startTime <- base::Sys.time()
[10:30:51.528]             {
[10:30:51.528]                 {
[10:30:51.528]                   {
[10:30:51.528]                     {
[10:30:51.528]                       {
[10:30:51.528]                         base::local({
[10:30:51.528]                           has_future <- base::requireNamespace("future", 
[10:30:51.528]                             quietly = TRUE)
[10:30:51.528]                           if (has_future) {
[10:30:51.528]                             ns <- base::getNamespace("future")
[10:30:51.528]                             version <- ns[[".package"]][["version"]]
[10:30:51.528]                             if (is.null(version)) 
[10:30:51.528]                               version <- utils::packageVersion("future")
[10:30:51.528]                           }
[10:30:51.528]                           else {
[10:30:51.528]                             version <- NULL
[10:30:51.528]                           }
[10:30:51.528]                           if (!has_future || version < "1.8.0") {
[10:30:51.528]                             info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.528]                               "", base::R.version$version.string), 
[10:30:51.528]                               platform = base::sprintf("%s (%s-bit)", 
[10:30:51.528]                                 base::R.version$platform, 8 * 
[10:30:51.528]                                   base::.Machine$sizeof.pointer), 
[10:30:51.528]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.528]                                 "release", "version")], collapse = " "), 
[10:30:51.528]                               hostname = base::Sys.info()[["nodename"]])
[10:30:51.528]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.528]                               info)
[10:30:51.528]                             info <- base::paste(info, collapse = "; ")
[10:30:51.528]                             if (!has_future) {
[10:30:51.528]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.528]                                 info)
[10:30:51.528]                             }
[10:30:51.528]                             else {
[10:30:51.528]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.528]                                 info, version)
[10:30:51.528]                             }
[10:30:51.528]                             base::stop(msg)
[10:30:51.528]                           }
[10:30:51.528]                         })
[10:30:51.528]                       }
[10:30:51.528]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.528]                       base::options(mc.cores = 1L)
[10:30:51.528]                     }
[10:30:51.528]                     base::local({
[10:30:51.528]                       for (pkg in "stats") {
[10:30:51.528]                         base::loadNamespace(pkg)
[10:30:51.528]                         base::library(pkg, character.only = TRUE)
[10:30:51.528]                       }
[10:30:51.528]                     })
[10:30:51.528]                   }
[10:30:51.528]                   ...future.strategy.old <- future::plan("list")
[10:30:51.528]                   options(future.plan = NULL)
[10:30:51.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.528]                 }
[10:30:51.528]                 ...future.workdir <- getwd()
[10:30:51.528]             }
[10:30:51.528]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.528]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.528]         }
[10:30:51.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.528]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.528]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.528]             base::names(...future.oldOptions))
[10:30:51.528]     }
[10:30:51.528]     if (FALSE) {
[10:30:51.528]     }
[10:30:51.528]     else {
[10:30:51.528]         if (TRUE) {
[10:30:51.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.528]                 open = "w")
[10:30:51.528]         }
[10:30:51.528]         else {
[10:30:51.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.528]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.528]         }
[10:30:51.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.528]             base::sink(type = "output", split = FALSE)
[10:30:51.528]             base::close(...future.stdout)
[10:30:51.528]         }, add = TRUE)
[10:30:51.528]     }
[10:30:51.528]     ...future.frame <- base::sys.nframe()
[10:30:51.528]     ...future.conditions <- base::list()
[10:30:51.528]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.528]     if (FALSE) {
[10:30:51.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.528]     }
[10:30:51.528]     ...future.result <- base::tryCatch({
[10:30:51.528]         base::withCallingHandlers({
[10:30:51.528]             ...future.value <- base::withVisible(base::local({
[10:30:51.528]                 withCallingHandlers({
[10:30:51.528]                   {
[10:30:51.528]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.528]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.528]                       ...future.globals.maxSize)) {
[10:30:51.528]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.528]                       on.exit(options(oopts), add = TRUE)
[10:30:51.528]                     }
[10:30:51.528]                     {
[10:30:51.528]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.528]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.528]                         USE.NAMES = FALSE)
[10:30:51.528]                       do.call(mapply, args = args)
[10:30:51.528]                     }
[10:30:51.528]                   }
[10:30:51.528]                 }, immediateCondition = function(cond) {
[10:30:51.528]                   save_rds <- function (object, pathname, ...) 
[10:30:51.528]                   {
[10:30:51.528]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.528]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.528]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.528]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.528]                         fi_tmp[["mtime"]])
[10:30:51.528]                     }
[10:30:51.528]                     tryCatch({
[10:30:51.528]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.528]                     }, error = function(ex) {
[10:30:51.528]                       msg <- conditionMessage(ex)
[10:30:51.528]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.528]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.528]                         fi_tmp[["mtime"]], msg)
[10:30:51.528]                       ex$message <- msg
[10:30:51.528]                       stop(ex)
[10:30:51.528]                     })
[10:30:51.528]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.528]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.528]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.528]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.528]                       fi <- file.info(pathname)
[10:30:51.528]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.528]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.528]                         fi[["size"]], fi[["mtime"]])
[10:30:51.528]                       stop(msg)
[10:30:51.528]                     }
[10:30:51.528]                     invisible(pathname)
[10:30:51.528]                   }
[10:30:51.528]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.528]                     rootPath = tempdir()) 
[10:30:51.528]                   {
[10:30:51.528]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.528]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.528]                       tmpdir = path, fileext = ".rds")
[10:30:51.528]                     save_rds(obj, file)
[10:30:51.528]                   }
[10:30:51.528]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.528]                   {
[10:30:51.528]                     inherits <- base::inherits
[10:30:51.528]                     invokeRestart <- base::invokeRestart
[10:30:51.528]                     is.null <- base::is.null
[10:30:51.528]                     muffled <- FALSE
[10:30:51.528]                     if (inherits(cond, "message")) {
[10:30:51.528]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.528]                       if (muffled) 
[10:30:51.528]                         invokeRestart("muffleMessage")
[10:30:51.528]                     }
[10:30:51.528]                     else if (inherits(cond, "warning")) {
[10:30:51.528]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.528]                       if (muffled) 
[10:30:51.528]                         invokeRestart("muffleWarning")
[10:30:51.528]                     }
[10:30:51.528]                     else if (inherits(cond, "condition")) {
[10:30:51.528]                       if (!is.null(pattern)) {
[10:30:51.528]                         computeRestarts <- base::computeRestarts
[10:30:51.528]                         grepl <- base::grepl
[10:30:51.528]                         restarts <- computeRestarts(cond)
[10:30:51.528]                         for (restart in restarts) {
[10:30:51.528]                           name <- restart$name
[10:30:51.528]                           if (is.null(name)) 
[10:30:51.528]                             next
[10:30:51.528]                           if (!grepl(pattern, name)) 
[10:30:51.528]                             next
[10:30:51.528]                           invokeRestart(restart)
[10:30:51.528]                           muffled <- TRUE
[10:30:51.528]                           break
[10:30:51.528]                         }
[10:30:51.528]                       }
[10:30:51.528]                     }
[10:30:51.528]                     invisible(muffled)
[10:30:51.528]                   }
[10:30:51.528]                   muffleCondition(cond)
[10:30:51.528]                 })
[10:30:51.528]             }))
[10:30:51.528]             future::FutureResult(value = ...future.value$value, 
[10:30:51.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.528]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.528]                     ...future.globalenv.names))
[10:30:51.528]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.528]         }, condition = base::local({
[10:30:51.528]             c <- base::c
[10:30:51.528]             inherits <- base::inherits
[10:30:51.528]             invokeRestart <- base::invokeRestart
[10:30:51.528]             length <- base::length
[10:30:51.528]             list <- base::list
[10:30:51.528]             seq.int <- base::seq.int
[10:30:51.528]             signalCondition <- base::signalCondition
[10:30:51.528]             sys.calls <- base::sys.calls
[10:30:51.528]             `[[` <- base::`[[`
[10:30:51.528]             `+` <- base::`+`
[10:30:51.528]             `<<-` <- base::`<<-`
[10:30:51.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.528]                   3L)]
[10:30:51.528]             }
[10:30:51.528]             function(cond) {
[10:30:51.528]                 is_error <- inherits(cond, "error")
[10:30:51.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.528]                   NULL)
[10:30:51.528]                 if (is_error) {
[10:30:51.528]                   sessionInformation <- function() {
[10:30:51.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.528]                       search = base::search(), system = base::Sys.info())
[10:30:51.528]                   }
[10:30:51.528]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.528]                     cond$call), session = sessionInformation(), 
[10:30:51.528]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.528]                   signalCondition(cond)
[10:30:51.528]                 }
[10:30:51.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.528]                 "immediateCondition"))) {
[10:30:51.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.528]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.528]                   if (TRUE && !signal) {
[10:30:51.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.528]                     {
[10:30:51.528]                       inherits <- base::inherits
[10:30:51.528]                       invokeRestart <- base::invokeRestart
[10:30:51.528]                       is.null <- base::is.null
[10:30:51.528]                       muffled <- FALSE
[10:30:51.528]                       if (inherits(cond, "message")) {
[10:30:51.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.528]                         if (muffled) 
[10:30:51.528]                           invokeRestart("muffleMessage")
[10:30:51.528]                       }
[10:30:51.528]                       else if (inherits(cond, "warning")) {
[10:30:51.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.528]                         if (muffled) 
[10:30:51.528]                           invokeRestart("muffleWarning")
[10:30:51.528]                       }
[10:30:51.528]                       else if (inherits(cond, "condition")) {
[10:30:51.528]                         if (!is.null(pattern)) {
[10:30:51.528]                           computeRestarts <- base::computeRestarts
[10:30:51.528]                           grepl <- base::grepl
[10:30:51.528]                           restarts <- computeRestarts(cond)
[10:30:51.528]                           for (restart in restarts) {
[10:30:51.528]                             name <- restart$name
[10:30:51.528]                             if (is.null(name)) 
[10:30:51.528]                               next
[10:30:51.528]                             if (!grepl(pattern, name)) 
[10:30:51.528]                               next
[10:30:51.528]                             invokeRestart(restart)
[10:30:51.528]                             muffled <- TRUE
[10:30:51.528]                             break
[10:30:51.528]                           }
[10:30:51.528]                         }
[10:30:51.528]                       }
[10:30:51.528]                       invisible(muffled)
[10:30:51.528]                     }
[10:30:51.528]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.528]                   }
[10:30:51.528]                 }
[10:30:51.528]                 else {
[10:30:51.528]                   if (TRUE) {
[10:30:51.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.528]                     {
[10:30:51.528]                       inherits <- base::inherits
[10:30:51.528]                       invokeRestart <- base::invokeRestart
[10:30:51.528]                       is.null <- base::is.null
[10:30:51.528]                       muffled <- FALSE
[10:30:51.528]                       if (inherits(cond, "message")) {
[10:30:51.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.528]                         if (muffled) 
[10:30:51.528]                           invokeRestart("muffleMessage")
[10:30:51.528]                       }
[10:30:51.528]                       else if (inherits(cond, "warning")) {
[10:30:51.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.528]                         if (muffled) 
[10:30:51.528]                           invokeRestart("muffleWarning")
[10:30:51.528]                       }
[10:30:51.528]                       else if (inherits(cond, "condition")) {
[10:30:51.528]                         if (!is.null(pattern)) {
[10:30:51.528]                           computeRestarts <- base::computeRestarts
[10:30:51.528]                           grepl <- base::grepl
[10:30:51.528]                           restarts <- computeRestarts(cond)
[10:30:51.528]                           for (restart in restarts) {
[10:30:51.528]                             name <- restart$name
[10:30:51.528]                             if (is.null(name)) 
[10:30:51.528]                               next
[10:30:51.528]                             if (!grepl(pattern, name)) 
[10:30:51.528]                               next
[10:30:51.528]                             invokeRestart(restart)
[10:30:51.528]                             muffled <- TRUE
[10:30:51.528]                             break
[10:30:51.528]                           }
[10:30:51.528]                         }
[10:30:51.528]                       }
[10:30:51.528]                       invisible(muffled)
[10:30:51.528]                     }
[10:30:51.528]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.528]                   }
[10:30:51.528]                 }
[10:30:51.528]             }
[10:30:51.528]         }))
[10:30:51.528]     }, error = function(ex) {
[10:30:51.528]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.528]                 ...future.rng), started = ...future.startTime, 
[10:30:51.528]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.528]             version = "1.8"), class = "FutureResult")
[10:30:51.528]     }, finally = {
[10:30:51.528]         if (!identical(...future.workdir, getwd())) 
[10:30:51.528]             setwd(...future.workdir)
[10:30:51.528]         {
[10:30:51.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.528]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.528]             }
[10:30:51.528]             base::options(...future.oldOptions)
[10:30:51.528]             if (.Platform$OS.type == "windows") {
[10:30:51.528]                 old_names <- names(...future.oldEnvVars)
[10:30:51.528]                 envs <- base::Sys.getenv()
[10:30:51.528]                 names <- names(envs)
[10:30:51.528]                 common <- intersect(names, old_names)
[10:30:51.528]                 added <- setdiff(names, old_names)
[10:30:51.528]                 removed <- setdiff(old_names, names)
[10:30:51.528]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.528]                   envs[common]]
[10:30:51.528]                 NAMES <- toupper(changed)
[10:30:51.528]                 args <- list()
[10:30:51.528]                 for (kk in seq_along(NAMES)) {
[10:30:51.528]                   name <- changed[[kk]]
[10:30:51.528]                   NAME <- NAMES[[kk]]
[10:30:51.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.528]                     next
[10:30:51.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.528]                 }
[10:30:51.528]                 NAMES <- toupper(added)
[10:30:51.528]                 for (kk in seq_along(NAMES)) {
[10:30:51.528]                   name <- added[[kk]]
[10:30:51.528]                   NAME <- NAMES[[kk]]
[10:30:51.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.528]                     next
[10:30:51.528]                   args[[name]] <- ""
[10:30:51.528]                 }
[10:30:51.528]                 NAMES <- toupper(removed)
[10:30:51.528]                 for (kk in seq_along(NAMES)) {
[10:30:51.528]                   name <- removed[[kk]]
[10:30:51.528]                   NAME <- NAMES[[kk]]
[10:30:51.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.528]                     next
[10:30:51.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.528]                 }
[10:30:51.528]                 if (length(args) > 0) 
[10:30:51.528]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.528]             }
[10:30:51.528]             else {
[10:30:51.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.528]             }
[10:30:51.528]             {
[10:30:51.528]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.528]                   0L) {
[10:30:51.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.528]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.528]                   base::options(opts)
[10:30:51.528]                 }
[10:30:51.528]                 {
[10:30:51.528]                   {
[10:30:51.528]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.528]                     NULL
[10:30:51.528]                   }
[10:30:51.528]                   options(future.plan = NULL)
[10:30:51.528]                   if (is.na(NA_character_)) 
[10:30:51.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.528]                     .init = FALSE)
[10:30:51.528]                 }
[10:30:51.528]             }
[10:30:51.528]         }
[10:30:51.528]     })
[10:30:51.528]     if (TRUE) {
[10:30:51.528]         base::sink(type = "output", split = FALSE)
[10:30:51.528]         if (TRUE) {
[10:30:51.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.528]         }
[10:30:51.528]         else {
[10:30:51.528]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.528]         }
[10:30:51.528]         base::close(...future.stdout)
[10:30:51.528]         ...future.stdout <- NULL
[10:30:51.528]     }
[10:30:51.528]     ...future.result$conditions <- ...future.conditions
[10:30:51.528]     ...future.result$finished <- base::Sys.time()
[10:30:51.528]     ...future.result
[10:30:51.528] }
[10:30:51.530] assign_globals() ...
[10:30:51.530] List of 5
[10:30:51.530]  $ ...future.FUN            :function (x, w, ...)  
[10:30:51.530]  $ MoreArgs                 : NULL
[10:30:51.530]  $ ...future.elements_ii    :List of 2
[10:30:51.530]   ..$ :List of 2
[10:30:51.530]   .. ..$ : num [1:10] 0.336 0.682 0.217 0.212 0.751 ...
[10:30:51.530]   .. ..$ : num [1:10] 0.712 0.695 0.601 0.432 0.679 ...
[10:30:51.530]   ..$ :List of 2
[10:30:51.530]   .. ..$ : num [1:10] 7 4 7 8 6 6 5 4 5 8
[10:30:51.530]   .. ..$ : num [1:10] 6 7 4 5 5 6 4 3 6 7
[10:30:51.530]  $ ...future.seeds_ii       : NULL
[10:30:51.530]  $ ...future.globals.maxSize: NULL
[10:30:51.530]  - attr(*, "where")=List of 5
[10:30:51.530]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.530]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.530]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.530]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.530]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.530]  - attr(*, "resolved")= logi FALSE
[10:30:51.530]  - attr(*, "total_size")= num 2120
[10:30:51.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.530]  - attr(*, "already-done")= logi TRUE
[10:30:51.538] - copied ‘...future.FUN’ to environment
[10:30:51.538] - copied ‘MoreArgs’ to environment
[10:30:51.538] - copied ‘...future.elements_ii’ to environment
[10:30:51.539] - copied ‘...future.seeds_ii’ to environment
[10:30:51.539] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.539] assign_globals() ... done
[10:30:51.539] requestCore(): workers = 2
[10:30:51.542] MulticoreFuture started
[10:30:51.543] - Launch lazy future ... done
[10:30:51.543] run() for ‘MulticoreFuture’ ... done
[10:30:51.544] Created future:
[10:30:51.544] plan(): Setting new future strategy stack:
[10:30:51.544] List of future strategies:
[10:30:51.544] 1. sequential:
[10:30:51.544]    - args: function (..., envir = parent.frame())
[10:30:51.544]    - tweaked: FALSE
[10:30:51.544]    - call: NULL
[10:30:51.545] plan(): nbrOfWorkers() = 1
[10:30:51.548] plan(): Setting new future strategy stack:
[10:30:51.548] List of future strategies:
[10:30:51.548] 1. multicore:
[10:30:51.548]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.548]    - tweaked: FALSE
[10:30:51.548]    - call: plan(strategy)
[10:30:51.544] MulticoreFuture:
[10:30:51.544] Label: ‘future_Map-1’
[10:30:51.544] Expression:
[10:30:51.544] {
[10:30:51.544]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.544]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.544]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.544]         on.exit(options(oopts), add = TRUE)
[10:30:51.544]     }
[10:30:51.544]     {
[10:30:51.544]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.544]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.544]         do.call(mapply, args = args)
[10:30:51.544]     }
[10:30:51.544] }
[10:30:51.544] Lazy evaluation: FALSE
[10:30:51.544] Asynchronous evaluation: TRUE
[10:30:51.544] Local evaluation: TRUE
[10:30:51.544] Environment: R_GlobalEnv
[10:30:51.544] Capture standard output: TRUE
[10:30:51.544] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.544] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.544] Packages: 1 packages (‘stats’)
[10:30:51.544] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:51.544] Resolved: FALSE
[10:30:51.544] Value: <not collected>
[10:30:51.544] Conditions captured: <none>
[10:30:51.544] Early signaling: FALSE
[10:30:51.544] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.544] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.557] Chunk #1 of 2 ... DONE
[10:30:51.558] Chunk #2 of 2 ...
[10:30:51.558]  - Finding globals in '...' for chunk #2 ...
[10:30:51.558] getGlobalsAndPackages() ...
[10:30:51.559] Searching for globals...
[10:30:51.559] plan(): nbrOfWorkers() = 2
[10:30:51.559] 
[10:30:51.560] Searching for globals ... DONE
[10:30:51.560] - globals: [0] <none>
[10:30:51.560] getGlobalsAndPackages() ... DONE
[10:30:51.560]    + additional globals found: [n=0] 
[10:30:51.560]    + additional namespaces needed: [n=0] 
[10:30:51.561]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:51.564]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.565]  - seeds: <none>
[10:30:51.565]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.565] getGlobalsAndPackages() ...
[10:30:51.566] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.567] Resolving globals: FALSE
[10:30:51.569] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[10:30:51.570] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:51.570] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.571] - packages: [1] ‘stats’
[10:30:51.571] getGlobalsAndPackages() ... DONE
[10:30:51.572] run() for ‘Future’ ...
[10:30:51.572] - state: ‘created’
[10:30:51.572] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.578] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.579]   - Field: ‘label’
[10:30:51.579]   - Field: ‘local’
[10:30:51.579]   - Field: ‘owner’
[10:30:51.579]   - Field: ‘envir’
[10:30:51.580]   - Field: ‘workers’
[10:30:51.580]   - Field: ‘packages’
[10:30:51.580]   - Field: ‘gc’
[10:30:51.580]   - Field: ‘job’
[10:30:51.580]   - Field: ‘conditions’
[10:30:51.581]   - Field: ‘expr’
[10:30:51.581]   - Field: ‘uuid’
[10:30:51.581]   - Field: ‘seed’
[10:30:51.581]   - Field: ‘version’
[10:30:51.581]   - Field: ‘result’
[10:30:51.582]   - Field: ‘asynchronous’
[10:30:51.582]   - Field: ‘calls’
[10:30:51.582]   - Field: ‘globals’
[10:30:51.582]   - Field: ‘stdout’
[10:30:51.582]   - Field: ‘earlySignal’
[10:30:51.583]   - Field: ‘lazy’
[10:30:51.583]   - Field: ‘state’
[10:30:51.583] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.583] - Launch lazy future ...
[10:30:51.584] Packages needed by the future expression (n = 1): ‘stats’
[10:30:51.584] Packages needed by future strategies (n = 0): <none>
[10:30:51.585] {
[10:30:51.585]     {
[10:30:51.585]         {
[10:30:51.585]             ...future.startTime <- base::Sys.time()
[10:30:51.585]             {
[10:30:51.585]                 {
[10:30:51.585]                   {
[10:30:51.585]                     {
[10:30:51.585]                       {
[10:30:51.585]                         base::local({
[10:30:51.585]                           has_future <- base::requireNamespace("future", 
[10:30:51.585]                             quietly = TRUE)
[10:30:51.585]                           if (has_future) {
[10:30:51.585]                             ns <- base::getNamespace("future")
[10:30:51.585]                             version <- ns[[".package"]][["version"]]
[10:30:51.585]                             if (is.null(version)) 
[10:30:51.585]                               version <- utils::packageVersion("future")
[10:30:51.585]                           }
[10:30:51.585]                           else {
[10:30:51.585]                             version <- NULL
[10:30:51.585]                           }
[10:30:51.585]                           if (!has_future || version < "1.8.0") {
[10:30:51.585]                             info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.585]                               "", base::R.version$version.string), 
[10:30:51.585]                               platform = base::sprintf("%s (%s-bit)", 
[10:30:51.585]                                 base::R.version$platform, 8 * 
[10:30:51.585]                                   base::.Machine$sizeof.pointer), 
[10:30:51.585]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.585]                                 "release", "version")], collapse = " "), 
[10:30:51.585]                               hostname = base::Sys.info()[["nodename"]])
[10:30:51.585]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.585]                               info)
[10:30:51.585]                             info <- base::paste(info, collapse = "; ")
[10:30:51.585]                             if (!has_future) {
[10:30:51.585]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.585]                                 info)
[10:30:51.585]                             }
[10:30:51.585]                             else {
[10:30:51.585]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.585]                                 info, version)
[10:30:51.585]                             }
[10:30:51.585]                             base::stop(msg)
[10:30:51.585]                           }
[10:30:51.585]                         })
[10:30:51.585]                       }
[10:30:51.585]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.585]                       base::options(mc.cores = 1L)
[10:30:51.585]                     }
[10:30:51.585]                     base::local({
[10:30:51.585]                       for (pkg in "stats") {
[10:30:51.585]                         base::loadNamespace(pkg)
[10:30:51.585]                         base::library(pkg, character.only = TRUE)
[10:30:51.585]                       }
[10:30:51.585]                     })
[10:30:51.585]                   }
[10:30:51.585]                   ...future.strategy.old <- future::plan("list")
[10:30:51.585]                   options(future.plan = NULL)
[10:30:51.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.585]                 }
[10:30:51.585]                 ...future.workdir <- getwd()
[10:30:51.585]             }
[10:30:51.585]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.585]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.585]         }
[10:30:51.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.585]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.585]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.585]             base::names(...future.oldOptions))
[10:30:51.585]     }
[10:30:51.585]     if (FALSE) {
[10:30:51.585]     }
[10:30:51.585]     else {
[10:30:51.585]         if (TRUE) {
[10:30:51.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.585]                 open = "w")
[10:30:51.585]         }
[10:30:51.585]         else {
[10:30:51.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.585]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.585]         }
[10:30:51.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.585]             base::sink(type = "output", split = FALSE)
[10:30:51.585]             base::close(...future.stdout)
[10:30:51.585]         }, add = TRUE)
[10:30:51.585]     }
[10:30:51.585]     ...future.frame <- base::sys.nframe()
[10:30:51.585]     ...future.conditions <- base::list()
[10:30:51.585]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.585]     if (FALSE) {
[10:30:51.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.585]     }
[10:30:51.585]     ...future.result <- base::tryCatch({
[10:30:51.585]         base::withCallingHandlers({
[10:30:51.585]             ...future.value <- base::withVisible(base::local({
[10:30:51.585]                 withCallingHandlers({
[10:30:51.585]                   {
[10:30:51.585]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.585]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.585]                       ...future.globals.maxSize)) {
[10:30:51.585]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.585]                       on.exit(options(oopts), add = TRUE)
[10:30:51.585]                     }
[10:30:51.585]                     {
[10:30:51.585]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.585]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.585]                         USE.NAMES = FALSE)
[10:30:51.585]                       do.call(mapply, args = args)
[10:30:51.585]                     }
[10:30:51.585]                   }
[10:30:51.585]                 }, immediateCondition = function(cond) {
[10:30:51.585]                   save_rds <- function (object, pathname, ...) 
[10:30:51.585]                   {
[10:30:51.585]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.585]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.585]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.585]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.585]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.585]                         fi_tmp[["mtime"]])
[10:30:51.585]                     }
[10:30:51.585]                     tryCatch({
[10:30:51.585]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.585]                     }, error = function(ex) {
[10:30:51.585]                       msg <- conditionMessage(ex)
[10:30:51.585]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.585]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.585]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.585]                         fi_tmp[["mtime"]], msg)
[10:30:51.585]                       ex$message <- msg
[10:30:51.585]                       stop(ex)
[10:30:51.585]                     })
[10:30:51.585]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.585]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.585]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.585]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.585]                       fi <- file.info(pathname)
[10:30:51.585]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.585]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.585]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.585]                         fi[["size"]], fi[["mtime"]])
[10:30:51.585]                       stop(msg)
[10:30:51.585]                     }
[10:30:51.585]                     invisible(pathname)
[10:30:51.585]                   }
[10:30:51.585]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.585]                     rootPath = tempdir()) 
[10:30:51.585]                   {
[10:30:51.585]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.585]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.585]                       tmpdir = path, fileext = ".rds")
[10:30:51.585]                     save_rds(obj, file)
[10:30:51.585]                   }
[10:30:51.585]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.585]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.585]                   {
[10:30:51.585]                     inherits <- base::inherits
[10:30:51.585]                     invokeRestart <- base::invokeRestart
[10:30:51.585]                     is.null <- base::is.null
[10:30:51.585]                     muffled <- FALSE
[10:30:51.585]                     if (inherits(cond, "message")) {
[10:30:51.585]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.585]                       if (muffled) 
[10:30:51.585]                         invokeRestart("muffleMessage")
[10:30:51.585]                     }
[10:30:51.585]                     else if (inherits(cond, "warning")) {
[10:30:51.585]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.585]                       if (muffled) 
[10:30:51.585]                         invokeRestart("muffleWarning")
[10:30:51.585]                     }
[10:30:51.585]                     else if (inherits(cond, "condition")) {
[10:30:51.585]                       if (!is.null(pattern)) {
[10:30:51.585]                         computeRestarts <- base::computeRestarts
[10:30:51.585]                         grepl <- base::grepl
[10:30:51.585]                         restarts <- computeRestarts(cond)
[10:30:51.585]                         for (restart in restarts) {
[10:30:51.585]                           name <- restart$name
[10:30:51.585]                           if (is.null(name)) 
[10:30:51.585]                             next
[10:30:51.585]                           if (!grepl(pattern, name)) 
[10:30:51.585]                             next
[10:30:51.585]                           invokeRestart(restart)
[10:30:51.585]                           muffled <- TRUE
[10:30:51.585]                           break
[10:30:51.585]                         }
[10:30:51.585]                       }
[10:30:51.585]                     }
[10:30:51.585]                     invisible(muffled)
[10:30:51.585]                   }
[10:30:51.585]                   muffleCondition(cond)
[10:30:51.585]                 })
[10:30:51.585]             }))
[10:30:51.585]             future::FutureResult(value = ...future.value$value, 
[10:30:51.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.585]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.585]                     ...future.globalenv.names))
[10:30:51.585]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.585]         }, condition = base::local({
[10:30:51.585]             c <- base::c
[10:30:51.585]             inherits <- base::inherits
[10:30:51.585]             invokeRestart <- base::invokeRestart
[10:30:51.585]             length <- base::length
[10:30:51.585]             list <- base::list
[10:30:51.585]             seq.int <- base::seq.int
[10:30:51.585]             signalCondition <- base::signalCondition
[10:30:51.585]             sys.calls <- base::sys.calls
[10:30:51.585]             `[[` <- base::`[[`
[10:30:51.585]             `+` <- base::`+`
[10:30:51.585]             `<<-` <- base::`<<-`
[10:30:51.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.585]                   3L)]
[10:30:51.585]             }
[10:30:51.585]             function(cond) {
[10:30:51.585]                 is_error <- inherits(cond, "error")
[10:30:51.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.585]                   NULL)
[10:30:51.585]                 if (is_error) {
[10:30:51.585]                   sessionInformation <- function() {
[10:30:51.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.585]                       search = base::search(), system = base::Sys.info())
[10:30:51.585]                   }
[10:30:51.585]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.585]                     cond$call), session = sessionInformation(), 
[10:30:51.585]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.585]                   signalCondition(cond)
[10:30:51.585]                 }
[10:30:51.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.585]                 "immediateCondition"))) {
[10:30:51.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.585]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.585]                   if (TRUE && !signal) {
[10:30:51.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.585]                     {
[10:30:51.585]                       inherits <- base::inherits
[10:30:51.585]                       invokeRestart <- base::invokeRestart
[10:30:51.585]                       is.null <- base::is.null
[10:30:51.585]                       muffled <- FALSE
[10:30:51.585]                       if (inherits(cond, "message")) {
[10:30:51.585]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.585]                         if (muffled) 
[10:30:51.585]                           invokeRestart("muffleMessage")
[10:30:51.585]                       }
[10:30:51.585]                       else if (inherits(cond, "warning")) {
[10:30:51.585]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.585]                         if (muffled) 
[10:30:51.585]                           invokeRestart("muffleWarning")
[10:30:51.585]                       }
[10:30:51.585]                       else if (inherits(cond, "condition")) {
[10:30:51.585]                         if (!is.null(pattern)) {
[10:30:51.585]                           computeRestarts <- base::computeRestarts
[10:30:51.585]                           grepl <- base::grepl
[10:30:51.585]                           restarts <- computeRestarts(cond)
[10:30:51.585]                           for (restart in restarts) {
[10:30:51.585]                             name <- restart$name
[10:30:51.585]                             if (is.null(name)) 
[10:30:51.585]                               next
[10:30:51.585]                             if (!grepl(pattern, name)) 
[10:30:51.585]                               next
[10:30:51.585]                             invokeRestart(restart)
[10:30:51.585]                             muffled <- TRUE
[10:30:51.585]                             break
[10:30:51.585]                           }
[10:30:51.585]                         }
[10:30:51.585]                       }
[10:30:51.585]                       invisible(muffled)
[10:30:51.585]                     }
[10:30:51.585]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.585]                   }
[10:30:51.585]                 }
[10:30:51.585]                 else {
[10:30:51.585]                   if (TRUE) {
[10:30:51.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.585]                     {
[10:30:51.585]                       inherits <- base::inherits
[10:30:51.585]                       invokeRestart <- base::invokeRestart
[10:30:51.585]                       is.null <- base::is.null
[10:30:51.585]                       muffled <- FALSE
[10:30:51.585]                       if (inherits(cond, "message")) {
[10:30:51.585]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.585]                         if (muffled) 
[10:30:51.585]                           invokeRestart("muffleMessage")
[10:30:51.585]                       }
[10:30:51.585]                       else if (inherits(cond, "warning")) {
[10:30:51.585]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.585]                         if (muffled) 
[10:30:51.585]                           invokeRestart("muffleWarning")
[10:30:51.585]                       }
[10:30:51.585]                       else if (inherits(cond, "condition")) {
[10:30:51.585]                         if (!is.null(pattern)) {
[10:30:51.585]                           computeRestarts <- base::computeRestarts
[10:30:51.585]                           grepl <- base::grepl
[10:30:51.585]                           restarts <- computeRestarts(cond)
[10:30:51.585]                           for (restart in restarts) {
[10:30:51.585]                             name <- restart$name
[10:30:51.585]                             if (is.null(name)) 
[10:30:51.585]                               next
[10:30:51.585]                             if (!grepl(pattern, name)) 
[10:30:51.585]                               next
[10:30:51.585]                             invokeRestart(restart)
[10:30:51.585]                             muffled <- TRUE
[10:30:51.585]                             break
[10:30:51.585]                           }
[10:30:51.585]                         }
[10:30:51.585]                       }
[10:30:51.585]                       invisible(muffled)
[10:30:51.585]                     }
[10:30:51.585]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.585]                   }
[10:30:51.585]                 }
[10:30:51.585]             }
[10:30:51.585]         }))
[10:30:51.585]     }, error = function(ex) {
[10:30:51.585]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.585]                 ...future.rng), started = ...future.startTime, 
[10:30:51.585]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.585]             version = "1.8"), class = "FutureResult")
[10:30:51.585]     }, finally = {
[10:30:51.585]         if (!identical(...future.workdir, getwd())) 
[10:30:51.585]             setwd(...future.workdir)
[10:30:51.585]         {
[10:30:51.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.585]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.585]             }
[10:30:51.585]             base::options(...future.oldOptions)
[10:30:51.585]             if (.Platform$OS.type == "windows") {
[10:30:51.585]                 old_names <- names(...future.oldEnvVars)
[10:30:51.585]                 envs <- base::Sys.getenv()
[10:30:51.585]                 names <- names(envs)
[10:30:51.585]                 common <- intersect(names, old_names)
[10:30:51.585]                 added <- setdiff(names, old_names)
[10:30:51.585]                 removed <- setdiff(old_names, names)
[10:30:51.585]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.585]                   envs[common]]
[10:30:51.585]                 NAMES <- toupper(changed)
[10:30:51.585]                 args <- list()
[10:30:51.585]                 for (kk in seq_along(NAMES)) {
[10:30:51.585]                   name <- changed[[kk]]
[10:30:51.585]                   NAME <- NAMES[[kk]]
[10:30:51.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.585]                     next
[10:30:51.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.585]                 }
[10:30:51.585]                 NAMES <- toupper(added)
[10:30:51.585]                 for (kk in seq_along(NAMES)) {
[10:30:51.585]                   name <- added[[kk]]
[10:30:51.585]                   NAME <- NAMES[[kk]]
[10:30:51.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.585]                     next
[10:30:51.585]                   args[[name]] <- ""
[10:30:51.585]                 }
[10:30:51.585]                 NAMES <- toupper(removed)
[10:30:51.585]                 for (kk in seq_along(NAMES)) {
[10:30:51.585]                   name <- removed[[kk]]
[10:30:51.585]                   NAME <- NAMES[[kk]]
[10:30:51.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.585]                     next
[10:30:51.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.585]                 }
[10:30:51.585]                 if (length(args) > 0) 
[10:30:51.585]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.585]             }
[10:30:51.585]             else {
[10:30:51.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.585]             }
[10:30:51.585]             {
[10:30:51.585]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.585]                   0L) {
[10:30:51.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.585]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.585]                   base::options(opts)
[10:30:51.585]                 }
[10:30:51.585]                 {
[10:30:51.585]                   {
[10:30:51.585]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.585]                     NULL
[10:30:51.585]                   }
[10:30:51.585]                   options(future.plan = NULL)
[10:30:51.585]                   if (is.na(NA_character_)) 
[10:30:51.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.585]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.585]                     .init = FALSE)
[10:30:51.585]                 }
[10:30:51.585]             }
[10:30:51.585]         }
[10:30:51.585]     })
[10:30:51.585]     if (TRUE) {
[10:30:51.585]         base::sink(type = "output", split = FALSE)
[10:30:51.585]         if (TRUE) {
[10:30:51.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.585]         }
[10:30:51.585]         else {
[10:30:51.585]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.585]         }
[10:30:51.585]         base::close(...future.stdout)
[10:30:51.585]         ...future.stdout <- NULL
[10:30:51.585]     }
[10:30:51.585]     ...future.result$conditions <- ...future.conditions
[10:30:51.585]     ...future.result$finished <- base::Sys.time()
[10:30:51.585]     ...future.result
[10:30:51.585] }
[10:30:51.588] assign_globals() ...
[10:30:51.588] List of 5
[10:30:51.588]  $ ...future.FUN            :function (x, w, ...)  
[10:30:51.588]  $ MoreArgs                 : NULL
[10:30:51.588]  $ ...future.elements_ii    :List of 2
[10:30:51.588]   ..$ :List of 3
[10:30:51.588]   .. ..$ : num [1:10] 0.604 0.505 0.688 0.628 0.863 ...
[10:30:51.588]   .. ..$ : num [1:10] 0.377 0.476 0.943 0.491 0.777 ...
[10:30:51.588]   .. ..$ : num [1:10] 0.7634 0.8201 0.3831 0.0932 0.2364 ...
[10:30:51.588]   ..$ :List of 3
[10:30:51.588]   .. ..$ : num [1:10] 5 4 3 6 8 9 7 5 5 6
[10:30:51.588]   .. ..$ : num [1:10] 10 7 4 10 4 6 7 7 7 8
[10:30:51.588]   .. ..$ : num [1:10] 6 3 7 9 3 8 9 7 5 7
[10:30:51.588]  $ ...future.seeds_ii       : NULL
[10:30:51.588]  $ ...future.globals.maxSize: NULL
[10:30:51.588]  - attr(*, "where")=List of 5
[10:30:51.588]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.588]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.588]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.588]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.588]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.588]  - attr(*, "resolved")= logi FALSE
[10:30:51.588]  - attr(*, "total_size")= num 2472
[10:30:51.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.588]  - attr(*, "already-done")= logi TRUE
[10:30:51.596] - copied ‘...future.FUN’ to environment
[10:30:51.597] - copied ‘MoreArgs’ to environment
[10:30:51.597] - copied ‘...future.elements_ii’ to environment
[10:30:51.597] - copied ‘...future.seeds_ii’ to environment
[10:30:51.597] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.597] assign_globals() ... done
[10:30:51.597] requestCore(): workers = 2
[10:30:51.600] MulticoreFuture started
[10:30:51.600] - Launch lazy future ... done
[10:30:51.600] run() for ‘MulticoreFuture’ ... done
[10:30:51.601] Created future:
[10:30:51.601] plan(): Setting new future strategy stack:
[10:30:51.601] List of future strategies:
[10:30:51.601] 1. sequential:
[10:30:51.601]    - args: function (..., envir = parent.frame())
[10:30:51.601]    - tweaked: FALSE
[10:30:51.601]    - call: NULL
[10:30:51.602] plan(): nbrOfWorkers() = 1
[10:30:51.604] plan(): Setting new future strategy stack:
[10:30:51.604] List of future strategies:
[10:30:51.604] 1. multicore:
[10:30:51.604]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.604]    - tweaked: FALSE
[10:30:51.604]    - call: plan(strategy)
[10:30:51.601] MulticoreFuture:
[10:30:51.601] Label: ‘future_Map-2’
[10:30:51.601] Expression:
[10:30:51.601] {
[10:30:51.601]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.601]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.601]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.601]         on.exit(options(oopts), add = TRUE)
[10:30:51.601]     }
[10:30:51.601]     {
[10:30:51.601]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.601]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.601]         do.call(mapply, args = args)
[10:30:51.601]     }
[10:30:51.601] }
[10:30:51.601] Lazy evaluation: FALSE
[10:30:51.601] Asynchronous evaluation: TRUE
[10:30:51.601] Local evaluation: TRUE
[10:30:51.601] Environment: R_GlobalEnv
[10:30:51.601] Capture standard output: TRUE
[10:30:51.601] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.601] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.601] Packages: 1 packages (‘stats’)
[10:30:51.601] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:51.601] Resolved: FALSE
[10:30:51.601] Value: <not collected>
[10:30:51.601] Conditions captured: <none>
[10:30:51.601] Early signaling: FALSE
[10:30:51.601] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.601] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.614] Chunk #2 of 2 ... DONE
[10:30:51.614] Launching 2 futures (chunks) ... DONE
[10:30:51.614] Resolving 2 futures (chunks) ...
[10:30:51.614] resolve() on list ...
[10:30:51.614]  recursive: 0
[10:30:51.615]  length: 2
[10:30:51.615] 
[10:30:51.665] plan(): nbrOfWorkers() = 2
[10:30:51.665] Future #1
[10:30:51.665] result() for MulticoreFuture ...
[10:30:51.666] result() for MulticoreFuture ...
[10:30:51.666] result() for MulticoreFuture ... done
[10:30:51.666] result() for MulticoreFuture ... done
[10:30:51.666] result() for MulticoreFuture ...
[10:30:51.666] result() for MulticoreFuture ... done
[10:30:51.667] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:51.667] - nx: 2
[10:30:51.667] - relay: TRUE
[10:30:51.667] - stdout: TRUE
[10:30:51.667] - signal: TRUE
[10:30:51.667] - resignal: FALSE
[10:30:51.667] - force: TRUE
[10:30:51.667] - relayed: [n=2] FALSE, FALSE
[10:30:51.668] - queued futures: [n=2] FALSE, FALSE
[10:30:51.668]  - until=1
[10:30:51.668]  - relaying element #1
[10:30:51.668] result() for MulticoreFuture ...
[10:30:51.668] result() for MulticoreFuture ... done
[10:30:51.668] result() for MulticoreFuture ...
[10:30:51.668] result() for MulticoreFuture ... done
[10:30:51.668] result() for MulticoreFuture ...
[10:30:51.669] result() for MulticoreFuture ... done
[10:30:51.669] result() for MulticoreFuture ...
[10:30:51.669] result() for MulticoreFuture ... done
[10:30:51.669] - relayed: [n=2] TRUE, FALSE
[10:30:51.669] - queued futures: [n=2] TRUE, FALSE
[10:30:51.669] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:51.669]  length: 1 (resolved future 1)
[10:30:51.670] Future #2
[10:30:51.670] result() for MulticoreFuture ...
[10:30:51.670] result() for MulticoreFuture ...
[10:30:51.671] result() for MulticoreFuture ... done
[10:30:51.671] result() for MulticoreFuture ... done
[10:30:51.671] result() for MulticoreFuture ...
[10:30:51.671] result() for MulticoreFuture ... done
[10:30:51.671] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:51.671] - nx: 2
[10:30:51.671] - relay: TRUE
[10:30:51.671] - stdout: TRUE
[10:30:51.672] - signal: TRUE
[10:30:51.672] - resignal: FALSE
[10:30:51.672] - force: TRUE
[10:30:51.672] - relayed: [n=2] TRUE, FALSE
[10:30:51.672] - queued futures: [n=2] TRUE, FALSE
[10:30:51.672]  - until=2
[10:30:51.672]  - relaying element #2
[10:30:51.672] result() for MulticoreFuture ...
[10:30:51.672] result() for MulticoreFuture ... done
[10:30:51.673] result() for MulticoreFuture ...
[10:30:51.673] result() for MulticoreFuture ... done
[10:30:51.673] result() for MulticoreFuture ...
[10:30:51.673] result() for MulticoreFuture ... done
[10:30:51.673] result() for MulticoreFuture ...
[10:30:51.673] result() for MulticoreFuture ... done
[10:30:51.673] - relayed: [n=2] TRUE, TRUE
[10:30:51.673] - queued futures: [n=2] TRUE, TRUE
[10:30:51.673] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:51.673]  length: 0 (resolved future 2)
[10:30:51.674] Relaying remaining futures
[10:30:51.674] signalConditionsASAP(NULL, pos=0) ...
[10:30:51.674] - nx: 2
[10:30:51.674] - relay: TRUE
[10:30:51.674] - stdout: TRUE
[10:30:51.674] - signal: TRUE
[10:30:51.674] - resignal: FALSE
[10:30:51.674] - force: TRUE
[10:30:51.674] - relayed: [n=2] TRUE, TRUE
[10:30:51.674] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:51.674] - relayed: [n=2] TRUE, TRUE
[10:30:51.674] - queued futures: [n=2] TRUE, TRUE
[10:30:51.675] signalConditionsASAP(NULL, pos=0) ... done
[10:30:51.675] resolve() on list ... DONE
[10:30:51.675] result() for MulticoreFuture ...
[10:30:51.675] result() for MulticoreFuture ... done
[10:30:51.675] result() for MulticoreFuture ...
[10:30:51.675] result() for MulticoreFuture ... done
[10:30:51.675] result() for MulticoreFuture ...
[10:30:51.675] result() for MulticoreFuture ... done
[10:30:51.675] result() for MulticoreFuture ...
[10:30:51.675] result() for MulticoreFuture ... done
[10:30:51.675]  - Number of value chunks collected: 2
[10:30:51.676] Resolving 2 futures (chunks) ... DONE
[10:30:51.676] Reducing values from 2 chunks ...
[10:30:51.676]  - Number of values collected after concatenation: 5
[10:30:51.676]  - Number of values expected: 5
[10:30:51.676] Reducing values from 2 chunks ... DONE
[10:30:51.676] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[10:30:51.678] future_mapply() ...
[10:30:51.682] Number of chunks: 2
[10:30:51.682] getGlobalsAndPackagesXApply() ...
[10:30:51.682]  - future.globals: TRUE
[10:30:51.682] getGlobalsAndPackages() ...
[10:30:51.682] Searching for globals...
[10:30:51.683] - globals found: [1] ‘FUN’
[10:30:51.683] Searching for globals ... DONE
[10:30:51.683] Resolving globals: FALSE
[10:30:51.683] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:51.684] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:51.684] - globals: [1] ‘FUN’
[10:30:51.684] 
[10:30:51.684] getGlobalsAndPackages() ... DONE
[10:30:51.684]  - globals found/used: [n=1] ‘FUN’
[10:30:51.684]  - needed namespaces: [n=0] 
[10:30:51.684] Finding globals ... DONE
[10:30:51.685] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:51.685] List of 2
[10:30:51.685]  $ ...future.FUN:function (e1, e2)  
[10:30:51.685]  $ MoreArgs     : NULL
[10:30:51.685]  - attr(*, "where")=List of 2
[10:30:51.685]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:51.685]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:51.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.685]  - attr(*, "resolved")= logi FALSE
[10:30:51.685]  - attr(*, "total_size")= num NA
[10:30:51.687] Packages to be attached in all futures: [n=0] 
[10:30:51.687] getGlobalsAndPackagesXApply() ... DONE
[10:30:51.687] Number of futures (= number of chunks): 2
[10:30:51.688] Launching 2 futures (chunks) ...
[10:30:51.688] Chunk #1 of 2 ...
[10:30:51.688]  - Finding globals in '...' for chunk #1 ...
[10:30:51.688] getGlobalsAndPackages() ...
[10:30:51.688] Searching for globals...
[10:30:51.688] 
[10:30:51.688] Searching for globals ... DONE
[10:30:51.688] - globals: [0] <none>
[10:30:51.689] getGlobalsAndPackages() ... DONE
[10:30:51.689]    + additional globals found: [n=0] 
[10:30:51.689]    + additional namespaces needed: [n=0] 
[10:30:51.689]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:51.689]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.689]  - seeds: <none>
[10:30:51.689]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.689] getGlobalsAndPackages() ...
[10:30:51.689] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.689] Resolving globals: FALSE
[10:30:51.690] The total size of the 5 globals is 168 bytes (168 bytes)
[10:30:51.690] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:51.690] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.691] 
[10:30:51.691] getGlobalsAndPackages() ... DONE
[10:30:51.691] run() for ‘Future’ ...
[10:30:51.691] - state: ‘created’
[10:30:51.691] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.695] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.695] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.695]   - Field: ‘label’
[10:30:51.695]   - Field: ‘local’
[10:30:51.695]   - Field: ‘owner’
[10:30:51.695]   - Field: ‘envir’
[10:30:51.696]   - Field: ‘workers’
[10:30:51.696]   - Field: ‘packages’
[10:30:51.696]   - Field: ‘gc’
[10:30:51.696]   - Field: ‘job’
[10:30:51.696]   - Field: ‘conditions’
[10:30:51.696]   - Field: ‘expr’
[10:30:51.696]   - Field: ‘uuid’
[10:30:51.696]   - Field: ‘seed’
[10:30:51.696]   - Field: ‘version’
[10:30:51.696]   - Field: ‘result’
[10:30:51.696]   - Field: ‘asynchronous’
[10:30:51.697]   - Field: ‘calls’
[10:30:51.697]   - Field: ‘globals’
[10:30:51.697]   - Field: ‘stdout’
[10:30:51.697]   - Field: ‘earlySignal’
[10:30:51.697]   - Field: ‘lazy’
[10:30:51.697]   - Field: ‘state’
[10:30:51.697] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.697] - Launch lazy future ...
[10:30:51.698] Packages needed by the future expression (n = 0): <none>
[10:30:51.698] Packages needed by future strategies (n = 0): <none>
[10:30:51.698] {
[10:30:51.698]     {
[10:30:51.698]         {
[10:30:51.698]             ...future.startTime <- base::Sys.time()
[10:30:51.698]             {
[10:30:51.698]                 {
[10:30:51.698]                   {
[10:30:51.698]                     {
[10:30:51.698]                       base::local({
[10:30:51.698]                         has_future <- base::requireNamespace("future", 
[10:30:51.698]                           quietly = TRUE)
[10:30:51.698]                         if (has_future) {
[10:30:51.698]                           ns <- base::getNamespace("future")
[10:30:51.698]                           version <- ns[[".package"]][["version"]]
[10:30:51.698]                           if (is.null(version)) 
[10:30:51.698]                             version <- utils::packageVersion("future")
[10:30:51.698]                         }
[10:30:51.698]                         else {
[10:30:51.698]                           version <- NULL
[10:30:51.698]                         }
[10:30:51.698]                         if (!has_future || version < "1.8.0") {
[10:30:51.698]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.698]                             "", base::R.version$version.string), 
[10:30:51.698]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:51.698]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:51.698]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.698]                               "release", "version")], collapse = " "), 
[10:30:51.698]                             hostname = base::Sys.info()[["nodename"]])
[10:30:51.698]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.698]                             info)
[10:30:51.698]                           info <- base::paste(info, collapse = "; ")
[10:30:51.698]                           if (!has_future) {
[10:30:51.698]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.698]                               info)
[10:30:51.698]                           }
[10:30:51.698]                           else {
[10:30:51.698]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.698]                               info, version)
[10:30:51.698]                           }
[10:30:51.698]                           base::stop(msg)
[10:30:51.698]                         }
[10:30:51.698]                       })
[10:30:51.698]                     }
[10:30:51.698]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.698]                     base::options(mc.cores = 1L)
[10:30:51.698]                   }
[10:30:51.698]                   ...future.strategy.old <- future::plan("list")
[10:30:51.698]                   options(future.plan = NULL)
[10:30:51.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.698]                 }
[10:30:51.698]                 ...future.workdir <- getwd()
[10:30:51.698]             }
[10:30:51.698]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.698]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.698]         }
[10:30:51.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.698]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.698]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.698]             base::names(...future.oldOptions))
[10:30:51.698]     }
[10:30:51.698]     if (FALSE) {
[10:30:51.698]     }
[10:30:51.698]     else {
[10:30:51.698]         if (TRUE) {
[10:30:51.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.698]                 open = "w")
[10:30:51.698]         }
[10:30:51.698]         else {
[10:30:51.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.698]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.698]         }
[10:30:51.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.698]             base::sink(type = "output", split = FALSE)
[10:30:51.698]             base::close(...future.stdout)
[10:30:51.698]         }, add = TRUE)
[10:30:51.698]     }
[10:30:51.698]     ...future.frame <- base::sys.nframe()
[10:30:51.698]     ...future.conditions <- base::list()
[10:30:51.698]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.698]     if (FALSE) {
[10:30:51.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.698]     }
[10:30:51.698]     ...future.result <- base::tryCatch({
[10:30:51.698]         base::withCallingHandlers({
[10:30:51.698]             ...future.value <- base::withVisible(base::local({
[10:30:51.698]                 withCallingHandlers({
[10:30:51.698]                   {
[10:30:51.698]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.698]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.698]                       ...future.globals.maxSize)) {
[10:30:51.698]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.698]                       on.exit(options(oopts), add = TRUE)
[10:30:51.698]                     }
[10:30:51.698]                     {
[10:30:51.698]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.698]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.698]                         USE.NAMES = FALSE)
[10:30:51.698]                       do.call(mapply, args = args)
[10:30:51.698]                     }
[10:30:51.698]                   }
[10:30:51.698]                 }, immediateCondition = function(cond) {
[10:30:51.698]                   save_rds <- function (object, pathname, ...) 
[10:30:51.698]                   {
[10:30:51.698]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.698]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.698]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.698]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.698]                         fi_tmp[["mtime"]])
[10:30:51.698]                     }
[10:30:51.698]                     tryCatch({
[10:30:51.698]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.698]                     }, error = function(ex) {
[10:30:51.698]                       msg <- conditionMessage(ex)
[10:30:51.698]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.698]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.698]                         fi_tmp[["mtime"]], msg)
[10:30:51.698]                       ex$message <- msg
[10:30:51.698]                       stop(ex)
[10:30:51.698]                     })
[10:30:51.698]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.698]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.698]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.698]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.698]                       fi <- file.info(pathname)
[10:30:51.698]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.698]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.698]                         fi[["size"]], fi[["mtime"]])
[10:30:51.698]                       stop(msg)
[10:30:51.698]                     }
[10:30:51.698]                     invisible(pathname)
[10:30:51.698]                   }
[10:30:51.698]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.698]                     rootPath = tempdir()) 
[10:30:51.698]                   {
[10:30:51.698]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.698]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.698]                       tmpdir = path, fileext = ".rds")
[10:30:51.698]                     save_rds(obj, file)
[10:30:51.698]                   }
[10:30:51.698]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.698]                   {
[10:30:51.698]                     inherits <- base::inherits
[10:30:51.698]                     invokeRestart <- base::invokeRestart
[10:30:51.698]                     is.null <- base::is.null
[10:30:51.698]                     muffled <- FALSE
[10:30:51.698]                     if (inherits(cond, "message")) {
[10:30:51.698]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.698]                       if (muffled) 
[10:30:51.698]                         invokeRestart("muffleMessage")
[10:30:51.698]                     }
[10:30:51.698]                     else if (inherits(cond, "warning")) {
[10:30:51.698]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.698]                       if (muffled) 
[10:30:51.698]                         invokeRestart("muffleWarning")
[10:30:51.698]                     }
[10:30:51.698]                     else if (inherits(cond, "condition")) {
[10:30:51.698]                       if (!is.null(pattern)) {
[10:30:51.698]                         computeRestarts <- base::computeRestarts
[10:30:51.698]                         grepl <- base::grepl
[10:30:51.698]                         restarts <- computeRestarts(cond)
[10:30:51.698]                         for (restart in restarts) {
[10:30:51.698]                           name <- restart$name
[10:30:51.698]                           if (is.null(name)) 
[10:30:51.698]                             next
[10:30:51.698]                           if (!grepl(pattern, name)) 
[10:30:51.698]                             next
[10:30:51.698]                           invokeRestart(restart)
[10:30:51.698]                           muffled <- TRUE
[10:30:51.698]                           break
[10:30:51.698]                         }
[10:30:51.698]                       }
[10:30:51.698]                     }
[10:30:51.698]                     invisible(muffled)
[10:30:51.698]                   }
[10:30:51.698]                   muffleCondition(cond)
[10:30:51.698]                 })
[10:30:51.698]             }))
[10:30:51.698]             future::FutureResult(value = ...future.value$value, 
[10:30:51.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.698]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.698]                     ...future.globalenv.names))
[10:30:51.698]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.698]         }, condition = base::local({
[10:30:51.698]             c <- base::c
[10:30:51.698]             inherits <- base::inherits
[10:30:51.698]             invokeRestart <- base::invokeRestart
[10:30:51.698]             length <- base::length
[10:30:51.698]             list <- base::list
[10:30:51.698]             seq.int <- base::seq.int
[10:30:51.698]             signalCondition <- base::signalCondition
[10:30:51.698]             sys.calls <- base::sys.calls
[10:30:51.698]             `[[` <- base::`[[`
[10:30:51.698]             `+` <- base::`+`
[10:30:51.698]             `<<-` <- base::`<<-`
[10:30:51.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.698]                   3L)]
[10:30:51.698]             }
[10:30:51.698]             function(cond) {
[10:30:51.698]                 is_error <- inherits(cond, "error")
[10:30:51.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.698]                   NULL)
[10:30:51.698]                 if (is_error) {
[10:30:51.698]                   sessionInformation <- function() {
[10:30:51.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.698]                       search = base::search(), system = base::Sys.info())
[10:30:51.698]                   }
[10:30:51.698]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.698]                     cond$call), session = sessionInformation(), 
[10:30:51.698]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.698]                   signalCondition(cond)
[10:30:51.698]                 }
[10:30:51.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.698]                 "immediateCondition"))) {
[10:30:51.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.698]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.698]                   if (TRUE && !signal) {
[10:30:51.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.698]                     {
[10:30:51.698]                       inherits <- base::inherits
[10:30:51.698]                       invokeRestart <- base::invokeRestart
[10:30:51.698]                       is.null <- base::is.null
[10:30:51.698]                       muffled <- FALSE
[10:30:51.698]                       if (inherits(cond, "message")) {
[10:30:51.698]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.698]                         if (muffled) 
[10:30:51.698]                           invokeRestart("muffleMessage")
[10:30:51.698]                       }
[10:30:51.698]                       else if (inherits(cond, "warning")) {
[10:30:51.698]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.698]                         if (muffled) 
[10:30:51.698]                           invokeRestart("muffleWarning")
[10:30:51.698]                       }
[10:30:51.698]                       else if (inherits(cond, "condition")) {
[10:30:51.698]                         if (!is.null(pattern)) {
[10:30:51.698]                           computeRestarts <- base::computeRestarts
[10:30:51.698]                           grepl <- base::grepl
[10:30:51.698]                           restarts <- computeRestarts(cond)
[10:30:51.698]                           for (restart in restarts) {
[10:30:51.698]                             name <- restart$name
[10:30:51.698]                             if (is.null(name)) 
[10:30:51.698]                               next
[10:30:51.698]                             if (!grepl(pattern, name)) 
[10:30:51.698]                               next
[10:30:51.698]                             invokeRestart(restart)
[10:30:51.698]                             muffled <- TRUE
[10:30:51.698]                             break
[10:30:51.698]                           }
[10:30:51.698]                         }
[10:30:51.698]                       }
[10:30:51.698]                       invisible(muffled)
[10:30:51.698]                     }
[10:30:51.698]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.698]                   }
[10:30:51.698]                 }
[10:30:51.698]                 else {
[10:30:51.698]                   if (TRUE) {
[10:30:51.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.698]                     {
[10:30:51.698]                       inherits <- base::inherits
[10:30:51.698]                       invokeRestart <- base::invokeRestart
[10:30:51.698]                       is.null <- base::is.null
[10:30:51.698]                       muffled <- FALSE
[10:30:51.698]                       if (inherits(cond, "message")) {
[10:30:51.698]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.698]                         if (muffled) 
[10:30:51.698]                           invokeRestart("muffleMessage")
[10:30:51.698]                       }
[10:30:51.698]                       else if (inherits(cond, "warning")) {
[10:30:51.698]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.698]                         if (muffled) 
[10:30:51.698]                           invokeRestart("muffleWarning")
[10:30:51.698]                       }
[10:30:51.698]                       else if (inherits(cond, "condition")) {
[10:30:51.698]                         if (!is.null(pattern)) {
[10:30:51.698]                           computeRestarts <- base::computeRestarts
[10:30:51.698]                           grepl <- base::grepl
[10:30:51.698]                           restarts <- computeRestarts(cond)
[10:30:51.698]                           for (restart in restarts) {
[10:30:51.698]                             name <- restart$name
[10:30:51.698]                             if (is.null(name)) 
[10:30:51.698]                               next
[10:30:51.698]                             if (!grepl(pattern, name)) 
[10:30:51.698]                               next
[10:30:51.698]                             invokeRestart(restart)
[10:30:51.698]                             muffled <- TRUE
[10:30:51.698]                             break
[10:30:51.698]                           }
[10:30:51.698]                         }
[10:30:51.698]                       }
[10:30:51.698]                       invisible(muffled)
[10:30:51.698]                     }
[10:30:51.698]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.698]                   }
[10:30:51.698]                 }
[10:30:51.698]             }
[10:30:51.698]         }))
[10:30:51.698]     }, error = function(ex) {
[10:30:51.698]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.698]                 ...future.rng), started = ...future.startTime, 
[10:30:51.698]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.698]             version = "1.8"), class = "FutureResult")
[10:30:51.698]     }, finally = {
[10:30:51.698]         if (!identical(...future.workdir, getwd())) 
[10:30:51.698]             setwd(...future.workdir)
[10:30:51.698]         {
[10:30:51.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.698]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.698]             }
[10:30:51.698]             base::options(...future.oldOptions)
[10:30:51.698]             if (.Platform$OS.type == "windows") {
[10:30:51.698]                 old_names <- names(...future.oldEnvVars)
[10:30:51.698]                 envs <- base::Sys.getenv()
[10:30:51.698]                 names <- names(envs)
[10:30:51.698]                 common <- intersect(names, old_names)
[10:30:51.698]                 added <- setdiff(names, old_names)
[10:30:51.698]                 removed <- setdiff(old_names, names)
[10:30:51.698]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.698]                   envs[common]]
[10:30:51.698]                 NAMES <- toupper(changed)
[10:30:51.698]                 args <- list()
[10:30:51.698]                 for (kk in seq_along(NAMES)) {
[10:30:51.698]                   name <- changed[[kk]]
[10:30:51.698]                   NAME <- NAMES[[kk]]
[10:30:51.698]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.698]                     next
[10:30:51.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.698]                 }
[10:30:51.698]                 NAMES <- toupper(added)
[10:30:51.698]                 for (kk in seq_along(NAMES)) {
[10:30:51.698]                   name <- added[[kk]]
[10:30:51.698]                   NAME <- NAMES[[kk]]
[10:30:51.698]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.698]                     next
[10:30:51.698]                   args[[name]] <- ""
[10:30:51.698]                 }
[10:30:51.698]                 NAMES <- toupper(removed)
[10:30:51.698]                 for (kk in seq_along(NAMES)) {
[10:30:51.698]                   name <- removed[[kk]]
[10:30:51.698]                   NAME <- NAMES[[kk]]
[10:30:51.698]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.698]                     next
[10:30:51.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.698]                 }
[10:30:51.698]                 if (length(args) > 0) 
[10:30:51.698]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.698]             }
[10:30:51.698]             else {
[10:30:51.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.698]             }
[10:30:51.698]             {
[10:30:51.698]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.698]                   0L) {
[10:30:51.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.698]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.698]                   base::options(opts)
[10:30:51.698]                 }
[10:30:51.698]                 {
[10:30:51.698]                   {
[10:30:51.698]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.698]                     NULL
[10:30:51.698]                   }
[10:30:51.698]                   options(future.plan = NULL)
[10:30:51.698]                   if (is.na(NA_character_)) 
[10:30:51.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.698]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.698]                     .init = FALSE)
[10:30:51.698]                 }
[10:30:51.698]             }
[10:30:51.698]         }
[10:30:51.698]     })
[10:30:51.698]     if (TRUE) {
[10:30:51.698]         base::sink(type = "output", split = FALSE)
[10:30:51.698]         if (TRUE) {
[10:30:51.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.698]         }
[10:30:51.698]         else {
[10:30:51.698]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.698]         }
[10:30:51.698]         base::close(...future.stdout)
[10:30:51.698]         ...future.stdout <- NULL
[10:30:51.698]     }
[10:30:51.698]     ...future.result$conditions <- ...future.conditions
[10:30:51.698]     ...future.result$finished <- base::Sys.time()
[10:30:51.698]     ...future.result
[10:30:51.698] }
[10:30:51.700] assign_globals() ...
[10:30:51.700] List of 5
[10:30:51.700]  $ ...future.FUN            :function (e1, e2)  
[10:30:51.700]  $ MoreArgs                 : NULL
[10:30:51.700]  $ ...future.elements_ii    :List of 2
[10:30:51.700]   ..$ :List of 1
[10:30:51.700]   .. ..$ : num 1
[10:30:51.700]   ..$ :List of 1
[10:30:51.700]   .. ..$ : int 1
[10:30:51.700]  $ ...future.seeds_ii       : NULL
[10:30:51.700]  $ ...future.globals.maxSize: NULL
[10:30:51.700]  - attr(*, "where")=List of 5
[10:30:51.700]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.700]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.700]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.700]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.700]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.700]  - attr(*, "resolved")= logi FALSE
[10:30:51.700]  - attr(*, "total_size")= num 168
[10:30:51.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.700]  - attr(*, "already-done")= logi TRUE
[10:30:51.706] - copied ‘...future.FUN’ to environment
[10:30:51.706] - copied ‘MoreArgs’ to environment
[10:30:51.706] - copied ‘...future.elements_ii’ to environment
[10:30:51.706] - copied ‘...future.seeds_ii’ to environment
[10:30:51.706] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.706] assign_globals() ... done
[10:30:51.707] requestCore(): workers = 2
[10:30:51.709] MulticoreFuture started
[10:30:51.709] - Launch lazy future ... done
[10:30:51.709] run() for ‘MulticoreFuture’ ... done
[10:30:51.710] Created future:
[10:30:51.710] plan(): Setting new future strategy stack:
[10:30:51.710] List of future strategies:
[10:30:51.710] 1. sequential:
[10:30:51.710]    - args: function (..., envir = parent.frame())
[10:30:51.710]    - tweaked: FALSE
[10:30:51.710]    - call: NULL
[10:30:51.711] plan(): nbrOfWorkers() = 1
[10:30:51.713] plan(): Setting new future strategy stack:
[10:30:51.713] List of future strategies:
[10:30:51.713] 1. multicore:
[10:30:51.713]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.713]    - tweaked: FALSE
[10:30:51.713]    - call: plan(strategy)
[10:30:51.718] plan(): nbrOfWorkers() = 2
[10:30:51.710] MulticoreFuture:
[10:30:51.710] Label: ‘future_Map-1’
[10:30:51.710] Expression:
[10:30:51.710] {
[10:30:51.710]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.710]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.710]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.710]         on.exit(options(oopts), add = TRUE)
[10:30:51.710]     }
[10:30:51.710]     {
[10:30:51.710]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.710]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.710]         do.call(mapply, args = args)
[10:30:51.710]     }
[10:30:51.710] }
[10:30:51.710] Lazy evaluation: FALSE
[10:30:51.710] Asynchronous evaluation: TRUE
[10:30:51.710] Local evaluation: TRUE
[10:30:51.710] Environment: R_GlobalEnv
[10:30:51.710] Capture standard output: TRUE
[10:30:51.710] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.710] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.710] Packages: <none>
[10:30:51.710] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:51.710] Resolved: TRUE
[10:30:51.710] Value: <not collected>
[10:30:51.710] Conditions captured: <none>
[10:30:51.710] Early signaling: FALSE
[10:30:51.710] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.710] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.719] Chunk #1 of 2 ... DONE
[10:30:51.720] Chunk #2 of 2 ...
[10:30:51.720]  - Finding globals in '...' for chunk #2 ...
[10:30:51.720] getGlobalsAndPackages() ...
[10:30:51.720] Searching for globals...
[10:30:51.721] 
[10:30:51.721] Searching for globals ... DONE
[10:30:51.721] - globals: [0] <none>
[10:30:51.721] getGlobalsAndPackages() ... DONE
[10:30:51.721]    + additional globals found: [n=0] 
[10:30:51.722]    + additional namespaces needed: [n=0] 
[10:30:51.722]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:51.722]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.722]  - seeds: <none>
[10:30:51.722]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.722] getGlobalsAndPackages() ...
[10:30:51.722] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.723] Resolving globals: FALSE
[10:30:51.723] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:51.724] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:51.724] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.725] 
[10:30:51.725] getGlobalsAndPackages() ... DONE
[10:30:51.725] run() for ‘Future’ ...
[10:30:51.725] - state: ‘created’
[10:30:51.726] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.730] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.730] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.731]   - Field: ‘label’
[10:30:51.731]   - Field: ‘local’
[10:30:51.731]   - Field: ‘owner’
[10:30:51.731]   - Field: ‘envir’
[10:30:51.731]   - Field: ‘workers’
[10:30:51.731]   - Field: ‘packages’
[10:30:51.731]   - Field: ‘gc’
[10:30:51.731]   - Field: ‘job’
[10:30:51.732]   - Field: ‘conditions’
[10:30:51.732]   - Field: ‘expr’
[10:30:51.732]   - Field: ‘uuid’
[10:30:51.732]   - Field: ‘seed’
[10:30:51.732]   - Field: ‘version’
[10:30:51.732]   - Field: ‘result’
[10:30:51.732]   - Field: ‘asynchronous’
[10:30:51.732]   - Field: ‘calls’
[10:30:51.733]   - Field: ‘globals’
[10:30:51.733]   - Field: ‘stdout’
[10:30:51.733]   - Field: ‘earlySignal’
[10:30:51.733]   - Field: ‘lazy’
[10:30:51.733]   - Field: ‘state’
[10:30:51.733] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.733] - Launch lazy future ...
[10:30:51.734] Packages needed by the future expression (n = 0): <none>
[10:30:51.734] Packages needed by future strategies (n = 0): <none>
[10:30:51.735] {
[10:30:51.735]     {
[10:30:51.735]         {
[10:30:51.735]             ...future.startTime <- base::Sys.time()
[10:30:51.735]             {
[10:30:51.735]                 {
[10:30:51.735]                   {
[10:30:51.735]                     {
[10:30:51.735]                       base::local({
[10:30:51.735]                         has_future <- base::requireNamespace("future", 
[10:30:51.735]                           quietly = TRUE)
[10:30:51.735]                         if (has_future) {
[10:30:51.735]                           ns <- base::getNamespace("future")
[10:30:51.735]                           version <- ns[[".package"]][["version"]]
[10:30:51.735]                           if (is.null(version)) 
[10:30:51.735]                             version <- utils::packageVersion("future")
[10:30:51.735]                         }
[10:30:51.735]                         else {
[10:30:51.735]                           version <- NULL
[10:30:51.735]                         }
[10:30:51.735]                         if (!has_future || version < "1.8.0") {
[10:30:51.735]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.735]                             "", base::R.version$version.string), 
[10:30:51.735]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:51.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:51.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.735]                               "release", "version")], collapse = " "), 
[10:30:51.735]                             hostname = base::Sys.info()[["nodename"]])
[10:30:51.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.735]                             info)
[10:30:51.735]                           info <- base::paste(info, collapse = "; ")
[10:30:51.735]                           if (!has_future) {
[10:30:51.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.735]                               info)
[10:30:51.735]                           }
[10:30:51.735]                           else {
[10:30:51.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.735]                               info, version)
[10:30:51.735]                           }
[10:30:51.735]                           base::stop(msg)
[10:30:51.735]                         }
[10:30:51.735]                       })
[10:30:51.735]                     }
[10:30:51.735]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.735]                     base::options(mc.cores = 1L)
[10:30:51.735]                   }
[10:30:51.735]                   ...future.strategy.old <- future::plan("list")
[10:30:51.735]                   options(future.plan = NULL)
[10:30:51.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.735]                 }
[10:30:51.735]                 ...future.workdir <- getwd()
[10:30:51.735]             }
[10:30:51.735]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.735]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.735]         }
[10:30:51.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.735]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.735]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.735]             base::names(...future.oldOptions))
[10:30:51.735]     }
[10:30:51.735]     if (FALSE) {
[10:30:51.735]     }
[10:30:51.735]     else {
[10:30:51.735]         if (TRUE) {
[10:30:51.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.735]                 open = "w")
[10:30:51.735]         }
[10:30:51.735]         else {
[10:30:51.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.735]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.735]         }
[10:30:51.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.735]             base::sink(type = "output", split = FALSE)
[10:30:51.735]             base::close(...future.stdout)
[10:30:51.735]         }, add = TRUE)
[10:30:51.735]     }
[10:30:51.735]     ...future.frame <- base::sys.nframe()
[10:30:51.735]     ...future.conditions <- base::list()
[10:30:51.735]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.735]     if (FALSE) {
[10:30:51.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.735]     }
[10:30:51.735]     ...future.result <- base::tryCatch({
[10:30:51.735]         base::withCallingHandlers({
[10:30:51.735]             ...future.value <- base::withVisible(base::local({
[10:30:51.735]                 withCallingHandlers({
[10:30:51.735]                   {
[10:30:51.735]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.735]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.735]                       ...future.globals.maxSize)) {
[10:30:51.735]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.735]                       on.exit(options(oopts), add = TRUE)
[10:30:51.735]                     }
[10:30:51.735]                     {
[10:30:51.735]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.735]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.735]                         USE.NAMES = FALSE)
[10:30:51.735]                       do.call(mapply, args = args)
[10:30:51.735]                     }
[10:30:51.735]                   }
[10:30:51.735]                 }, immediateCondition = function(cond) {
[10:30:51.735]                   save_rds <- function (object, pathname, ...) 
[10:30:51.735]                   {
[10:30:51.735]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.735]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.735]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.735]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.735]                         fi_tmp[["mtime"]])
[10:30:51.735]                     }
[10:30:51.735]                     tryCatch({
[10:30:51.735]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.735]                     }, error = function(ex) {
[10:30:51.735]                       msg <- conditionMessage(ex)
[10:30:51.735]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.735]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.735]                         fi_tmp[["mtime"]], msg)
[10:30:51.735]                       ex$message <- msg
[10:30:51.735]                       stop(ex)
[10:30:51.735]                     })
[10:30:51.735]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.735]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.735]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.735]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.735]                       fi <- file.info(pathname)
[10:30:51.735]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.735]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.735]                         fi[["size"]], fi[["mtime"]])
[10:30:51.735]                       stop(msg)
[10:30:51.735]                     }
[10:30:51.735]                     invisible(pathname)
[10:30:51.735]                   }
[10:30:51.735]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.735]                     rootPath = tempdir()) 
[10:30:51.735]                   {
[10:30:51.735]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.735]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.735]                       tmpdir = path, fileext = ".rds")
[10:30:51.735]                     save_rds(obj, file)
[10:30:51.735]                   }
[10:30:51.735]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.735]                   {
[10:30:51.735]                     inherits <- base::inherits
[10:30:51.735]                     invokeRestart <- base::invokeRestart
[10:30:51.735]                     is.null <- base::is.null
[10:30:51.735]                     muffled <- FALSE
[10:30:51.735]                     if (inherits(cond, "message")) {
[10:30:51.735]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.735]                       if (muffled) 
[10:30:51.735]                         invokeRestart("muffleMessage")
[10:30:51.735]                     }
[10:30:51.735]                     else if (inherits(cond, "warning")) {
[10:30:51.735]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.735]                       if (muffled) 
[10:30:51.735]                         invokeRestart("muffleWarning")
[10:30:51.735]                     }
[10:30:51.735]                     else if (inherits(cond, "condition")) {
[10:30:51.735]                       if (!is.null(pattern)) {
[10:30:51.735]                         computeRestarts <- base::computeRestarts
[10:30:51.735]                         grepl <- base::grepl
[10:30:51.735]                         restarts <- computeRestarts(cond)
[10:30:51.735]                         for (restart in restarts) {
[10:30:51.735]                           name <- restart$name
[10:30:51.735]                           if (is.null(name)) 
[10:30:51.735]                             next
[10:30:51.735]                           if (!grepl(pattern, name)) 
[10:30:51.735]                             next
[10:30:51.735]                           invokeRestart(restart)
[10:30:51.735]                           muffled <- TRUE
[10:30:51.735]                           break
[10:30:51.735]                         }
[10:30:51.735]                       }
[10:30:51.735]                     }
[10:30:51.735]                     invisible(muffled)
[10:30:51.735]                   }
[10:30:51.735]                   muffleCondition(cond)
[10:30:51.735]                 })
[10:30:51.735]             }))
[10:30:51.735]             future::FutureResult(value = ...future.value$value, 
[10:30:51.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.735]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.735]                     ...future.globalenv.names))
[10:30:51.735]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.735]         }, condition = base::local({
[10:30:51.735]             c <- base::c
[10:30:51.735]             inherits <- base::inherits
[10:30:51.735]             invokeRestart <- base::invokeRestart
[10:30:51.735]             length <- base::length
[10:30:51.735]             list <- base::list
[10:30:51.735]             seq.int <- base::seq.int
[10:30:51.735]             signalCondition <- base::signalCondition
[10:30:51.735]             sys.calls <- base::sys.calls
[10:30:51.735]             `[[` <- base::`[[`
[10:30:51.735]             `+` <- base::`+`
[10:30:51.735]             `<<-` <- base::`<<-`
[10:30:51.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.735]                   3L)]
[10:30:51.735]             }
[10:30:51.735]             function(cond) {
[10:30:51.735]                 is_error <- inherits(cond, "error")
[10:30:51.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.735]                   NULL)
[10:30:51.735]                 if (is_error) {
[10:30:51.735]                   sessionInformation <- function() {
[10:30:51.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.735]                       search = base::search(), system = base::Sys.info())
[10:30:51.735]                   }
[10:30:51.735]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.735]                     cond$call), session = sessionInformation(), 
[10:30:51.735]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.735]                   signalCondition(cond)
[10:30:51.735]                 }
[10:30:51.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.735]                 "immediateCondition"))) {
[10:30:51.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.735]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.735]                   if (TRUE && !signal) {
[10:30:51.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.735]                     {
[10:30:51.735]                       inherits <- base::inherits
[10:30:51.735]                       invokeRestart <- base::invokeRestart
[10:30:51.735]                       is.null <- base::is.null
[10:30:51.735]                       muffled <- FALSE
[10:30:51.735]                       if (inherits(cond, "message")) {
[10:30:51.735]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.735]                         if (muffled) 
[10:30:51.735]                           invokeRestart("muffleMessage")
[10:30:51.735]                       }
[10:30:51.735]                       else if (inherits(cond, "warning")) {
[10:30:51.735]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.735]                         if (muffled) 
[10:30:51.735]                           invokeRestart("muffleWarning")
[10:30:51.735]                       }
[10:30:51.735]                       else if (inherits(cond, "condition")) {
[10:30:51.735]                         if (!is.null(pattern)) {
[10:30:51.735]                           computeRestarts <- base::computeRestarts
[10:30:51.735]                           grepl <- base::grepl
[10:30:51.735]                           restarts <- computeRestarts(cond)
[10:30:51.735]                           for (restart in restarts) {
[10:30:51.735]                             name <- restart$name
[10:30:51.735]                             if (is.null(name)) 
[10:30:51.735]                               next
[10:30:51.735]                             if (!grepl(pattern, name)) 
[10:30:51.735]                               next
[10:30:51.735]                             invokeRestart(restart)
[10:30:51.735]                             muffled <- TRUE
[10:30:51.735]                             break
[10:30:51.735]                           }
[10:30:51.735]                         }
[10:30:51.735]                       }
[10:30:51.735]                       invisible(muffled)
[10:30:51.735]                     }
[10:30:51.735]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.735]                   }
[10:30:51.735]                 }
[10:30:51.735]                 else {
[10:30:51.735]                   if (TRUE) {
[10:30:51.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.735]                     {
[10:30:51.735]                       inherits <- base::inherits
[10:30:51.735]                       invokeRestart <- base::invokeRestart
[10:30:51.735]                       is.null <- base::is.null
[10:30:51.735]                       muffled <- FALSE
[10:30:51.735]                       if (inherits(cond, "message")) {
[10:30:51.735]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.735]                         if (muffled) 
[10:30:51.735]                           invokeRestart("muffleMessage")
[10:30:51.735]                       }
[10:30:51.735]                       else if (inherits(cond, "warning")) {
[10:30:51.735]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.735]                         if (muffled) 
[10:30:51.735]                           invokeRestart("muffleWarning")
[10:30:51.735]                       }
[10:30:51.735]                       else if (inherits(cond, "condition")) {
[10:30:51.735]                         if (!is.null(pattern)) {
[10:30:51.735]                           computeRestarts <- base::computeRestarts
[10:30:51.735]                           grepl <- base::grepl
[10:30:51.735]                           restarts <- computeRestarts(cond)
[10:30:51.735]                           for (restart in restarts) {
[10:30:51.735]                             name <- restart$name
[10:30:51.735]                             if (is.null(name)) 
[10:30:51.735]                               next
[10:30:51.735]                             if (!grepl(pattern, name)) 
[10:30:51.735]                               next
[10:30:51.735]                             invokeRestart(restart)
[10:30:51.735]                             muffled <- TRUE
[10:30:51.735]                             break
[10:30:51.735]                           }
[10:30:51.735]                         }
[10:30:51.735]                       }
[10:30:51.735]                       invisible(muffled)
[10:30:51.735]                     }
[10:30:51.735]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.735]                   }
[10:30:51.735]                 }
[10:30:51.735]             }
[10:30:51.735]         }))
[10:30:51.735]     }, error = function(ex) {
[10:30:51.735]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.735]                 ...future.rng), started = ...future.startTime, 
[10:30:51.735]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.735]             version = "1.8"), class = "FutureResult")
[10:30:51.735]     }, finally = {
[10:30:51.735]         if (!identical(...future.workdir, getwd())) 
[10:30:51.735]             setwd(...future.workdir)
[10:30:51.735]         {
[10:30:51.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.735]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.735]             }
[10:30:51.735]             base::options(...future.oldOptions)
[10:30:51.735]             if (.Platform$OS.type == "windows") {
[10:30:51.735]                 old_names <- names(...future.oldEnvVars)
[10:30:51.735]                 envs <- base::Sys.getenv()
[10:30:51.735]                 names <- names(envs)
[10:30:51.735]                 common <- intersect(names, old_names)
[10:30:51.735]                 added <- setdiff(names, old_names)
[10:30:51.735]                 removed <- setdiff(old_names, names)
[10:30:51.735]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.735]                   envs[common]]
[10:30:51.735]                 NAMES <- toupper(changed)
[10:30:51.735]                 args <- list()
[10:30:51.735]                 for (kk in seq_along(NAMES)) {
[10:30:51.735]                   name <- changed[[kk]]
[10:30:51.735]                   NAME <- NAMES[[kk]]
[10:30:51.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.735]                     next
[10:30:51.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.735]                 }
[10:30:51.735]                 NAMES <- toupper(added)
[10:30:51.735]                 for (kk in seq_along(NAMES)) {
[10:30:51.735]                   name <- added[[kk]]
[10:30:51.735]                   NAME <- NAMES[[kk]]
[10:30:51.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.735]                     next
[10:30:51.735]                   args[[name]] <- ""
[10:30:51.735]                 }
[10:30:51.735]                 NAMES <- toupper(removed)
[10:30:51.735]                 for (kk in seq_along(NAMES)) {
[10:30:51.735]                   name <- removed[[kk]]
[10:30:51.735]                   NAME <- NAMES[[kk]]
[10:30:51.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.735]                     next
[10:30:51.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.735]                 }
[10:30:51.735]                 if (length(args) > 0) 
[10:30:51.735]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.735]             }
[10:30:51.735]             else {
[10:30:51.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.735]             }
[10:30:51.735]             {
[10:30:51.735]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.735]                   0L) {
[10:30:51.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.735]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.735]                   base::options(opts)
[10:30:51.735]                 }
[10:30:51.735]                 {
[10:30:51.735]                   {
[10:30:51.735]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.735]                     NULL
[10:30:51.735]                   }
[10:30:51.735]                   options(future.plan = NULL)
[10:30:51.735]                   if (is.na(NA_character_)) 
[10:30:51.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.735]                     .init = FALSE)
[10:30:51.735]                 }
[10:30:51.735]             }
[10:30:51.735]         }
[10:30:51.735]     })
[10:30:51.735]     if (TRUE) {
[10:30:51.735]         base::sink(type = "output", split = FALSE)
[10:30:51.735]         if (TRUE) {
[10:30:51.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.735]         }
[10:30:51.735]         else {
[10:30:51.735]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.735]         }
[10:30:51.735]         base::close(...future.stdout)
[10:30:51.735]         ...future.stdout <- NULL
[10:30:51.735]     }
[10:30:51.735]     ...future.result$conditions <- ...future.conditions
[10:30:51.735]     ...future.result$finished <- base::Sys.time()
[10:30:51.735]     ...future.result
[10:30:51.735] }
[10:30:51.738] assign_globals() ...
[10:30:51.738] List of 5
[10:30:51.738]  $ ...future.FUN            :function (e1, e2)  
[10:30:51.738]  $ MoreArgs                 : NULL
[10:30:51.738]  $ ...future.elements_ii    :List of 2
[10:30:51.738]   ..$ :List of 2
[10:30:51.738]   .. ..$ : num 1
[10:30:51.738]   .. ..$ : num 1
[10:30:51.738]   ..$ :List of 2
[10:30:51.738]   .. ..$ : int 2
[10:30:51.738]   .. ..$ : int 3
[10:30:51.738]  $ ...future.seeds_ii       : NULL
[10:30:51.738]  $ ...future.globals.maxSize: NULL
[10:30:51.738]  - attr(*, "where")=List of 5
[10:30:51.738]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.738]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.738]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.738]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.738]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.738]  - attr(*, "resolved")= logi FALSE
[10:30:51.738]  - attr(*, "total_size")= num 280
[10:30:51.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.738]  - attr(*, "already-done")= logi TRUE
[10:30:51.746] - copied ‘...future.FUN’ to environment
[10:30:51.747] - copied ‘MoreArgs’ to environment
[10:30:51.747] - copied ‘...future.elements_ii’ to environment
[10:30:51.747] - copied ‘...future.seeds_ii’ to environment
[10:30:51.747] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.747] assign_globals() ... done
[10:30:51.747] requestCore(): workers = 2
[10:30:51.750] MulticoreFuture started
[10:30:51.750] - Launch lazy future ... done
[10:30:51.750] run() for ‘MulticoreFuture’ ... done
[10:30:51.751] Created future:
[10:30:51.751] plan(): Setting new future strategy stack:
[10:30:51.751] List of future strategies:
[10:30:51.751] 1. sequential:
[10:30:51.751]    - args: function (..., envir = parent.frame())
[10:30:51.751]    - tweaked: FALSE
[10:30:51.751]    - call: NULL
[10:30:51.752] plan(): nbrOfWorkers() = 1
[10:30:51.755] plan(): Setting new future strategy stack:
[10:30:51.755] List of future strategies:
[10:30:51.755] 1. multicore:
[10:30:51.755]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.755]    - tweaked: FALSE
[10:30:51.755]    - call: plan(strategy)
[10:30:51.761] plan(): nbrOfWorkers() = 2
[10:30:51.751] MulticoreFuture:
[10:30:51.751] Label: ‘future_Map-2’
[10:30:51.751] Expression:
[10:30:51.751] {
[10:30:51.751]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.751]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.751]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.751]         on.exit(options(oopts), add = TRUE)
[10:30:51.751]     }
[10:30:51.751]     {
[10:30:51.751]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.751]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.751]         do.call(mapply, args = args)
[10:30:51.751]     }
[10:30:51.751] }
[10:30:51.751] Lazy evaluation: FALSE
[10:30:51.751] Asynchronous evaluation: TRUE
[10:30:51.751] Local evaluation: TRUE
[10:30:51.751] Environment: R_GlobalEnv
[10:30:51.751] Capture standard output: TRUE
[10:30:51.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.751] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.751] Packages: <none>
[10:30:51.751] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:51.751] Resolved: TRUE
[10:30:51.751] Value: <not collected>
[10:30:51.751] Conditions captured: <none>
[10:30:51.751] Early signaling: FALSE
[10:30:51.751] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.751] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.762] Chunk #2 of 2 ... DONE
[10:30:51.763] Launching 2 futures (chunks) ... DONE
[10:30:51.763] Resolving 2 futures (chunks) ...
[10:30:51.763] resolve() on list ...
[10:30:51.763]  recursive: 0
[10:30:51.763]  length: 2
[10:30:51.763] 
[10:30:51.764] Future #1
[10:30:51.764] result() for MulticoreFuture ...
[10:30:51.766] result() for MulticoreFuture ...
[10:30:51.766] result() for MulticoreFuture ... done
[10:30:51.766] result() for MulticoreFuture ... done
[10:30:51.767] result() for MulticoreFuture ...
[10:30:51.767] result() for MulticoreFuture ... done
[10:30:51.767] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:51.767] - nx: 2
[10:30:51.767] - relay: TRUE
[10:30:51.767] - stdout: TRUE
[10:30:51.767] - signal: TRUE
[10:30:51.768] - resignal: FALSE
[10:30:51.768] - force: TRUE
[10:30:51.768] - relayed: [n=2] FALSE, FALSE
[10:30:51.768] - queued futures: [n=2] FALSE, FALSE
[10:30:51.768]  - until=1
[10:30:51.768]  - relaying element #1
[10:30:51.768] result() for MulticoreFuture ...
[10:30:51.768] result() for MulticoreFuture ... done
[10:30:51.769] result() for MulticoreFuture ...
[10:30:51.769] result() for MulticoreFuture ... done
[10:30:51.769] result() for MulticoreFuture ...
[10:30:51.769] result() for MulticoreFuture ... done
[10:30:51.769] result() for MulticoreFuture ...
[10:30:51.769] result() for MulticoreFuture ... done
[10:30:51.769] - relayed: [n=2] TRUE, FALSE
[10:30:51.770] - queued futures: [n=2] TRUE, FALSE
[10:30:51.770] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:51.770]  length: 1 (resolved future 1)
[10:30:51.770] Future #2
[10:30:51.770] result() for MulticoreFuture ...
[10:30:51.771] result() for MulticoreFuture ...
[10:30:51.771] result() for MulticoreFuture ... done
[10:30:51.771] result() for MulticoreFuture ... done
[10:30:51.771] result() for MulticoreFuture ...
[10:30:51.771] result() for MulticoreFuture ... done
[10:30:51.772] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:51.772] - nx: 2
[10:30:51.772] - relay: TRUE
[10:30:51.772] - stdout: TRUE
[10:30:51.772] - signal: TRUE
[10:30:51.772] - resignal: FALSE
[10:30:51.772] - force: TRUE
[10:30:51.772] - relayed: [n=2] TRUE, FALSE
[10:30:51.772] - queued futures: [n=2] TRUE, FALSE
[10:30:51.773]  - until=2
[10:30:51.773]  - relaying element #2
[10:30:51.773] result() for MulticoreFuture ...
[10:30:51.773] result() for MulticoreFuture ... done
[10:30:51.773] result() for MulticoreFuture ...
[10:30:51.773] result() for MulticoreFuture ... done
[10:30:51.773] result() for MulticoreFuture ...
[10:30:51.774] result() for MulticoreFuture ... done
[10:30:51.774] result() for MulticoreFuture ...
[10:30:51.774] result() for MulticoreFuture ... done
[10:30:51.774] - relayed: [n=2] TRUE, TRUE
[10:30:51.774] - queued futures: [n=2] TRUE, TRUE
[10:30:51.774] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:51.774]  length: 0 (resolved future 2)
[10:30:51.774] Relaying remaining futures
[10:30:51.775] signalConditionsASAP(NULL, pos=0) ...
[10:30:51.775] - nx: 2
[10:30:51.775] - relay: TRUE
[10:30:51.775] - stdout: TRUE
[10:30:51.775] - signal: TRUE
[10:30:51.775] - resignal: FALSE
[10:30:51.775] - force: TRUE
[10:30:51.775] - relayed: [n=2] TRUE, TRUE
[10:30:51.775] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:51.776] - relayed: [n=2] TRUE, TRUE
[10:30:51.776] - queued futures: [n=2] TRUE, TRUE
[10:30:51.776] signalConditionsASAP(NULL, pos=0) ... done
[10:30:51.776] resolve() on list ... DONE
[10:30:51.776] result() for MulticoreFuture ...
[10:30:51.776] result() for MulticoreFuture ... done
[10:30:51.776] result() for MulticoreFuture ...
[10:30:51.776] result() for MulticoreFuture ... done
[10:30:51.777] result() for MulticoreFuture ...
[10:30:51.777] result() for MulticoreFuture ... done
[10:30:51.777] result() for MulticoreFuture ...
[10:30:51.777] result() for MulticoreFuture ... done
[10:30:51.777]  - Number of value chunks collected: 2
[10:30:51.777] Resolving 2 futures (chunks) ... DONE
[10:30:51.777] Reducing values from 2 chunks ...
[10:30:51.778]  - Number of values collected after concatenation: 3
[10:30:51.778]  - Number of values expected: 3
[10:30:51.778] Reducing values from 2 chunks ... DONE
[10:30:51.778] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[10:30:51.778] future_mapply() ...
[10:30:51.783] Number of chunks: 2
[10:30:51.783] getGlobalsAndPackagesXApply() ...
[10:30:51.783]  - future.globals: TRUE
[10:30:51.784] getGlobalsAndPackages() ...
[10:30:51.784] Searching for globals...
[10:30:51.785] - globals found: [1] ‘FUN’
[10:30:51.786] Searching for globals ... DONE
[10:30:51.786] Resolving globals: FALSE
[10:30:51.786] The total size of the 1 globals is 848 bytes (848 bytes)
[10:30:51.786] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:30:51.787] - globals: [1] ‘FUN’
[10:30:51.787] 
[10:30:51.787] getGlobalsAndPackages() ... DONE
[10:30:51.787]  - globals found/used: [n=1] ‘FUN’
[10:30:51.787]  - needed namespaces: [n=0] 
[10:30:51.787] Finding globals ... DONE
[10:30:51.788] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:51.788] List of 2
[10:30:51.788]  $ ...future.FUN:function (x)  
[10:30:51.788]  $ MoreArgs     : NULL
[10:30:51.788]  - attr(*, "where")=List of 2
[10:30:51.788]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:51.788]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:51.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.788]  - attr(*, "resolved")= logi FALSE
[10:30:51.788]  - attr(*, "total_size")= num NA
[10:30:51.791] Packages to be attached in all futures: [n=0] 
[10:30:51.791] getGlobalsAndPackagesXApply() ... DONE
[10:30:51.792] Number of futures (= number of chunks): 2
[10:30:51.792] Launching 2 futures (chunks) ...
[10:30:51.792] Chunk #1 of 2 ...
[10:30:51.792]  - Finding globals in '...' for chunk #1 ...
[10:30:51.792] getGlobalsAndPackages() ...
[10:30:51.792] Searching for globals...
[10:30:51.793] 
[10:30:51.793] Searching for globals ... DONE
[10:30:51.793] - globals: [0] <none>
[10:30:51.793] getGlobalsAndPackages() ... DONE
[10:30:51.793]    + additional globals found: [n=0] 
[10:30:51.793]    + additional namespaces needed: [n=0] 
[10:30:51.793]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:51.794]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.794]  - seeds: <none>
[10:30:51.794]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.794] getGlobalsAndPackages() ...
[10:30:51.794] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.794] Resolving globals: FALSE
[10:30:51.795] The total size of the 5 globals is 904 bytes (904 bytes)
[10:30:51.795] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:51.796] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.796] 
[10:30:51.796] getGlobalsAndPackages() ... DONE
[10:30:51.796] run() for ‘Future’ ...
[10:30:51.796] - state: ‘created’
[10:30:51.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.803] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.803] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.804]   - Field: ‘label’
[10:30:51.804]   - Field: ‘local’
[10:30:51.804]   - Field: ‘owner’
[10:30:51.804]   - Field: ‘envir’
[10:30:51.804]   - Field: ‘workers’
[10:30:51.804]   - Field: ‘packages’
[10:30:51.804]   - Field: ‘gc’
[10:30:51.804]   - Field: ‘job’
[10:30:51.804]   - Field: ‘conditions’
[10:30:51.805]   - Field: ‘expr’
[10:30:51.805]   - Field: ‘uuid’
[10:30:51.805]   - Field: ‘seed’
[10:30:51.805]   - Field: ‘version’
[10:30:51.805]   - Field: ‘result’
[10:30:51.805]   - Field: ‘asynchronous’
[10:30:51.805]   - Field: ‘calls’
[10:30:51.805]   - Field: ‘globals’
[10:30:51.805]   - Field: ‘stdout’
[10:30:51.806]   - Field: ‘earlySignal’
[10:30:51.806]   - Field: ‘lazy’
[10:30:51.806]   - Field: ‘state’
[10:30:51.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.806] - Launch lazy future ...
[10:30:51.806] Packages needed by the future expression (n = 0): <none>
[10:30:51.806] Packages needed by future strategies (n = 0): <none>
[10:30:51.807] {
[10:30:51.807]     {
[10:30:51.807]         {
[10:30:51.807]             ...future.startTime <- base::Sys.time()
[10:30:51.807]             {
[10:30:51.807]                 {
[10:30:51.807]                   {
[10:30:51.807]                     {
[10:30:51.807]                       base::local({
[10:30:51.807]                         has_future <- base::requireNamespace("future", 
[10:30:51.807]                           quietly = TRUE)
[10:30:51.807]                         if (has_future) {
[10:30:51.807]                           ns <- base::getNamespace("future")
[10:30:51.807]                           version <- ns[[".package"]][["version"]]
[10:30:51.807]                           if (is.null(version)) 
[10:30:51.807]                             version <- utils::packageVersion("future")
[10:30:51.807]                         }
[10:30:51.807]                         else {
[10:30:51.807]                           version <- NULL
[10:30:51.807]                         }
[10:30:51.807]                         if (!has_future || version < "1.8.0") {
[10:30:51.807]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.807]                             "", base::R.version$version.string), 
[10:30:51.807]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:51.807]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:51.807]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.807]                               "release", "version")], collapse = " "), 
[10:30:51.807]                             hostname = base::Sys.info()[["nodename"]])
[10:30:51.807]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.807]                             info)
[10:30:51.807]                           info <- base::paste(info, collapse = "; ")
[10:30:51.807]                           if (!has_future) {
[10:30:51.807]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.807]                               info)
[10:30:51.807]                           }
[10:30:51.807]                           else {
[10:30:51.807]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.807]                               info, version)
[10:30:51.807]                           }
[10:30:51.807]                           base::stop(msg)
[10:30:51.807]                         }
[10:30:51.807]                       })
[10:30:51.807]                     }
[10:30:51.807]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.807]                     base::options(mc.cores = 1L)
[10:30:51.807]                   }
[10:30:51.807]                   ...future.strategy.old <- future::plan("list")
[10:30:51.807]                   options(future.plan = NULL)
[10:30:51.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.807]                 }
[10:30:51.807]                 ...future.workdir <- getwd()
[10:30:51.807]             }
[10:30:51.807]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.807]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.807]         }
[10:30:51.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.807]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.807]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.807]             base::names(...future.oldOptions))
[10:30:51.807]     }
[10:30:51.807]     if (FALSE) {
[10:30:51.807]     }
[10:30:51.807]     else {
[10:30:51.807]         if (TRUE) {
[10:30:51.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.807]                 open = "w")
[10:30:51.807]         }
[10:30:51.807]         else {
[10:30:51.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.807]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.807]         }
[10:30:51.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.807]             base::sink(type = "output", split = FALSE)
[10:30:51.807]             base::close(...future.stdout)
[10:30:51.807]         }, add = TRUE)
[10:30:51.807]     }
[10:30:51.807]     ...future.frame <- base::sys.nframe()
[10:30:51.807]     ...future.conditions <- base::list()
[10:30:51.807]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.807]     if (FALSE) {
[10:30:51.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.807]     }
[10:30:51.807]     ...future.result <- base::tryCatch({
[10:30:51.807]         base::withCallingHandlers({
[10:30:51.807]             ...future.value <- base::withVisible(base::local({
[10:30:51.807]                 withCallingHandlers({
[10:30:51.807]                   {
[10:30:51.807]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.807]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.807]                       ...future.globals.maxSize)) {
[10:30:51.807]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.807]                       on.exit(options(oopts), add = TRUE)
[10:30:51.807]                     }
[10:30:51.807]                     {
[10:30:51.807]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.807]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.807]                         USE.NAMES = FALSE)
[10:30:51.807]                       do.call(mapply, args = args)
[10:30:51.807]                     }
[10:30:51.807]                   }
[10:30:51.807]                 }, immediateCondition = function(cond) {
[10:30:51.807]                   save_rds <- function (object, pathname, ...) 
[10:30:51.807]                   {
[10:30:51.807]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.807]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.807]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.807]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.807]                         fi_tmp[["mtime"]])
[10:30:51.807]                     }
[10:30:51.807]                     tryCatch({
[10:30:51.807]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.807]                     }, error = function(ex) {
[10:30:51.807]                       msg <- conditionMessage(ex)
[10:30:51.807]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.807]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.807]                         fi_tmp[["mtime"]], msg)
[10:30:51.807]                       ex$message <- msg
[10:30:51.807]                       stop(ex)
[10:30:51.807]                     })
[10:30:51.807]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.807]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.807]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.807]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.807]                       fi <- file.info(pathname)
[10:30:51.807]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.807]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.807]                         fi[["size"]], fi[["mtime"]])
[10:30:51.807]                       stop(msg)
[10:30:51.807]                     }
[10:30:51.807]                     invisible(pathname)
[10:30:51.807]                   }
[10:30:51.807]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.807]                     rootPath = tempdir()) 
[10:30:51.807]                   {
[10:30:51.807]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.807]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.807]                       tmpdir = path, fileext = ".rds")
[10:30:51.807]                     save_rds(obj, file)
[10:30:51.807]                   }
[10:30:51.807]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.807]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.807]                   {
[10:30:51.807]                     inherits <- base::inherits
[10:30:51.807]                     invokeRestart <- base::invokeRestart
[10:30:51.807]                     is.null <- base::is.null
[10:30:51.807]                     muffled <- FALSE
[10:30:51.807]                     if (inherits(cond, "message")) {
[10:30:51.807]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.807]                       if (muffled) 
[10:30:51.807]                         invokeRestart("muffleMessage")
[10:30:51.807]                     }
[10:30:51.807]                     else if (inherits(cond, "warning")) {
[10:30:51.807]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.807]                       if (muffled) 
[10:30:51.807]                         invokeRestart("muffleWarning")
[10:30:51.807]                     }
[10:30:51.807]                     else if (inherits(cond, "condition")) {
[10:30:51.807]                       if (!is.null(pattern)) {
[10:30:51.807]                         computeRestarts <- base::computeRestarts
[10:30:51.807]                         grepl <- base::grepl
[10:30:51.807]                         restarts <- computeRestarts(cond)
[10:30:51.807]                         for (restart in restarts) {
[10:30:51.807]                           name <- restart$name
[10:30:51.807]                           if (is.null(name)) 
[10:30:51.807]                             next
[10:30:51.807]                           if (!grepl(pattern, name)) 
[10:30:51.807]                             next
[10:30:51.807]                           invokeRestart(restart)
[10:30:51.807]                           muffled <- TRUE
[10:30:51.807]                           break
[10:30:51.807]                         }
[10:30:51.807]                       }
[10:30:51.807]                     }
[10:30:51.807]                     invisible(muffled)
[10:30:51.807]                   }
[10:30:51.807]                   muffleCondition(cond)
[10:30:51.807]                 })
[10:30:51.807]             }))
[10:30:51.807]             future::FutureResult(value = ...future.value$value, 
[10:30:51.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.807]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.807]                     ...future.globalenv.names))
[10:30:51.807]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.807]         }, condition = base::local({
[10:30:51.807]             c <- base::c
[10:30:51.807]             inherits <- base::inherits
[10:30:51.807]             invokeRestart <- base::invokeRestart
[10:30:51.807]             length <- base::length
[10:30:51.807]             list <- base::list
[10:30:51.807]             seq.int <- base::seq.int
[10:30:51.807]             signalCondition <- base::signalCondition
[10:30:51.807]             sys.calls <- base::sys.calls
[10:30:51.807]             `[[` <- base::`[[`
[10:30:51.807]             `+` <- base::`+`
[10:30:51.807]             `<<-` <- base::`<<-`
[10:30:51.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.807]                   3L)]
[10:30:51.807]             }
[10:30:51.807]             function(cond) {
[10:30:51.807]                 is_error <- inherits(cond, "error")
[10:30:51.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.807]                   NULL)
[10:30:51.807]                 if (is_error) {
[10:30:51.807]                   sessionInformation <- function() {
[10:30:51.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.807]                       search = base::search(), system = base::Sys.info())
[10:30:51.807]                   }
[10:30:51.807]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.807]                     cond$call), session = sessionInformation(), 
[10:30:51.807]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.807]                   signalCondition(cond)
[10:30:51.807]                 }
[10:30:51.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.807]                 "immediateCondition"))) {
[10:30:51.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.807]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.807]                   if (TRUE && !signal) {
[10:30:51.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.807]                     {
[10:30:51.807]                       inherits <- base::inherits
[10:30:51.807]                       invokeRestart <- base::invokeRestart
[10:30:51.807]                       is.null <- base::is.null
[10:30:51.807]                       muffled <- FALSE
[10:30:51.807]                       if (inherits(cond, "message")) {
[10:30:51.807]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.807]                         if (muffled) 
[10:30:51.807]                           invokeRestart("muffleMessage")
[10:30:51.807]                       }
[10:30:51.807]                       else if (inherits(cond, "warning")) {
[10:30:51.807]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.807]                         if (muffled) 
[10:30:51.807]                           invokeRestart("muffleWarning")
[10:30:51.807]                       }
[10:30:51.807]                       else if (inherits(cond, "condition")) {
[10:30:51.807]                         if (!is.null(pattern)) {
[10:30:51.807]                           computeRestarts <- base::computeRestarts
[10:30:51.807]                           grepl <- base::grepl
[10:30:51.807]                           restarts <- computeRestarts(cond)
[10:30:51.807]                           for (restart in restarts) {
[10:30:51.807]                             name <- restart$name
[10:30:51.807]                             if (is.null(name)) 
[10:30:51.807]                               next
[10:30:51.807]                             if (!grepl(pattern, name)) 
[10:30:51.807]                               next
[10:30:51.807]                             invokeRestart(restart)
[10:30:51.807]                             muffled <- TRUE
[10:30:51.807]                             break
[10:30:51.807]                           }
[10:30:51.807]                         }
[10:30:51.807]                       }
[10:30:51.807]                       invisible(muffled)
[10:30:51.807]                     }
[10:30:51.807]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.807]                   }
[10:30:51.807]                 }
[10:30:51.807]                 else {
[10:30:51.807]                   if (TRUE) {
[10:30:51.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.807]                     {
[10:30:51.807]                       inherits <- base::inherits
[10:30:51.807]                       invokeRestart <- base::invokeRestart
[10:30:51.807]                       is.null <- base::is.null
[10:30:51.807]                       muffled <- FALSE
[10:30:51.807]                       if (inherits(cond, "message")) {
[10:30:51.807]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.807]                         if (muffled) 
[10:30:51.807]                           invokeRestart("muffleMessage")
[10:30:51.807]                       }
[10:30:51.807]                       else if (inherits(cond, "warning")) {
[10:30:51.807]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.807]                         if (muffled) 
[10:30:51.807]                           invokeRestart("muffleWarning")
[10:30:51.807]                       }
[10:30:51.807]                       else if (inherits(cond, "condition")) {
[10:30:51.807]                         if (!is.null(pattern)) {
[10:30:51.807]                           computeRestarts <- base::computeRestarts
[10:30:51.807]                           grepl <- base::grepl
[10:30:51.807]                           restarts <- computeRestarts(cond)
[10:30:51.807]                           for (restart in restarts) {
[10:30:51.807]                             name <- restart$name
[10:30:51.807]                             if (is.null(name)) 
[10:30:51.807]                               next
[10:30:51.807]                             if (!grepl(pattern, name)) 
[10:30:51.807]                               next
[10:30:51.807]                             invokeRestart(restart)
[10:30:51.807]                             muffled <- TRUE
[10:30:51.807]                             break
[10:30:51.807]                           }
[10:30:51.807]                         }
[10:30:51.807]                       }
[10:30:51.807]                       invisible(muffled)
[10:30:51.807]                     }
[10:30:51.807]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.807]                   }
[10:30:51.807]                 }
[10:30:51.807]             }
[10:30:51.807]         }))
[10:30:51.807]     }, error = function(ex) {
[10:30:51.807]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.807]                 ...future.rng), started = ...future.startTime, 
[10:30:51.807]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.807]             version = "1.8"), class = "FutureResult")
[10:30:51.807]     }, finally = {
[10:30:51.807]         if (!identical(...future.workdir, getwd())) 
[10:30:51.807]             setwd(...future.workdir)
[10:30:51.807]         {
[10:30:51.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.807]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.807]             }
[10:30:51.807]             base::options(...future.oldOptions)
[10:30:51.807]             if (.Platform$OS.type == "windows") {
[10:30:51.807]                 old_names <- names(...future.oldEnvVars)
[10:30:51.807]                 envs <- base::Sys.getenv()
[10:30:51.807]                 names <- names(envs)
[10:30:51.807]                 common <- intersect(names, old_names)
[10:30:51.807]                 added <- setdiff(names, old_names)
[10:30:51.807]                 removed <- setdiff(old_names, names)
[10:30:51.807]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.807]                   envs[common]]
[10:30:51.807]                 NAMES <- toupper(changed)
[10:30:51.807]                 args <- list()
[10:30:51.807]                 for (kk in seq_along(NAMES)) {
[10:30:51.807]                   name <- changed[[kk]]
[10:30:51.807]                   NAME <- NAMES[[kk]]
[10:30:51.807]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.807]                     next
[10:30:51.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.807]                 }
[10:30:51.807]                 NAMES <- toupper(added)
[10:30:51.807]                 for (kk in seq_along(NAMES)) {
[10:30:51.807]                   name <- added[[kk]]
[10:30:51.807]                   NAME <- NAMES[[kk]]
[10:30:51.807]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.807]                     next
[10:30:51.807]                   args[[name]] <- ""
[10:30:51.807]                 }
[10:30:51.807]                 NAMES <- toupper(removed)
[10:30:51.807]                 for (kk in seq_along(NAMES)) {
[10:30:51.807]                   name <- removed[[kk]]
[10:30:51.807]                   NAME <- NAMES[[kk]]
[10:30:51.807]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.807]                     next
[10:30:51.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.807]                 }
[10:30:51.807]                 if (length(args) > 0) 
[10:30:51.807]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.807]             }
[10:30:51.807]             else {
[10:30:51.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.807]             }
[10:30:51.807]             {
[10:30:51.807]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.807]                   0L) {
[10:30:51.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.807]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.807]                   base::options(opts)
[10:30:51.807]                 }
[10:30:51.807]                 {
[10:30:51.807]                   {
[10:30:51.807]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.807]                     NULL
[10:30:51.807]                   }
[10:30:51.807]                   options(future.plan = NULL)
[10:30:51.807]                   if (is.na(NA_character_)) 
[10:30:51.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.807]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.807]                     .init = FALSE)
[10:30:51.807]                 }
[10:30:51.807]             }
[10:30:51.807]         }
[10:30:51.807]     })
[10:30:51.807]     if (TRUE) {
[10:30:51.807]         base::sink(type = "output", split = FALSE)
[10:30:51.807]         if (TRUE) {
[10:30:51.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.807]         }
[10:30:51.807]         else {
[10:30:51.807]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.807]         }
[10:30:51.807]         base::close(...future.stdout)
[10:30:51.807]         ...future.stdout <- NULL
[10:30:51.807]     }
[10:30:51.807]     ...future.result$conditions <- ...future.conditions
[10:30:51.807]     ...future.result$finished <- base::Sys.time()
[10:30:51.807]     ...future.result
[10:30:51.807] }
[10:30:51.809] assign_globals() ...
[10:30:51.809] List of 5
[10:30:51.809]  $ ...future.FUN            :function (x)  
[10:30:51.809]  $ MoreArgs                 : NULL
[10:30:51.809]  $ ...future.elements_ii    :List of 1
[10:30:51.809]   ..$ :List of 1
[10:30:51.809]   .. ..$ a: num 0
[10:30:51.809]  $ ...future.seeds_ii       : NULL
[10:30:51.809]  $ ...future.globals.maxSize: NULL
[10:30:51.809]  - attr(*, "where")=List of 5
[10:30:51.809]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.809]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.809]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.809]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.809]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.809]  - attr(*, "resolved")= logi FALSE
[10:30:51.809]  - attr(*, "total_size")= num 904
[10:30:51.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.809]  - attr(*, "already-done")= logi TRUE
[10:30:51.815] - copied ‘...future.FUN’ to environment
[10:30:51.815] - copied ‘MoreArgs’ to environment
[10:30:51.815] - copied ‘...future.elements_ii’ to environment
[10:30:51.815] - copied ‘...future.seeds_ii’ to environment
[10:30:51.815] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.815] assign_globals() ... done
[10:30:51.815] requestCore(): workers = 2
[10:30:51.818] MulticoreFuture started
[10:30:51.818] - Launch lazy future ... done
[10:30:51.819] run() for ‘MulticoreFuture’ ... done
[10:30:51.819] Created future:
[10:30:51.819] plan(): Setting new future strategy stack:
[10:30:51.820] List of future strategies:
[10:30:51.820] 1. sequential:
[10:30:51.820]    - args: function (..., envir = parent.frame())
[10:30:51.820]    - tweaked: FALSE
[10:30:51.820]    - call: NULL
[10:30:51.820] plan(): nbrOfWorkers() = 1
[10:30:51.822] plan(): Setting new future strategy stack:
[10:30:51.822] List of future strategies:
[10:30:51.822] 1. multicore:
[10:30:51.822]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.822]    - tweaked: FALSE
[10:30:51.822]    - call: plan(strategy)
[10:30:51.828] plan(): nbrOfWorkers() = 2
[10:30:51.819] MulticoreFuture:
[10:30:51.819] Label: ‘future_mapply-1’
[10:30:51.819] Expression:
[10:30:51.819] {
[10:30:51.819]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.819]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.819]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.819]         on.exit(options(oopts), add = TRUE)
[10:30:51.819]     }
[10:30:51.819]     {
[10:30:51.819]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.819]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.819]         do.call(mapply, args = args)
[10:30:51.819]     }
[10:30:51.819] }
[10:30:51.819] Lazy evaluation: FALSE
[10:30:51.819] Asynchronous evaluation: TRUE
[10:30:51.819] Local evaluation: TRUE
[10:30:51.819] Environment: R_GlobalEnv
[10:30:51.819] Capture standard output: TRUE
[10:30:51.819] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.819] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.819] Packages: <none>
[10:30:51.819] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:51.819] Resolved: TRUE
[10:30:51.819] Value: <not collected>
[10:30:51.819] Conditions captured: <none>
[10:30:51.819] Early signaling: FALSE
[10:30:51.819] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.819] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.829] Chunk #1 of 2 ... DONE
[10:30:51.829] Chunk #2 of 2 ...
[10:30:51.829]  - Finding globals in '...' for chunk #2 ...
[10:30:51.829] getGlobalsAndPackages() ...
[10:30:51.830] Searching for globals...
[10:30:51.830] 
[10:30:51.830] Searching for globals ... DONE
[10:30:51.830] - globals: [0] <none>
[10:30:51.831] getGlobalsAndPackages() ... DONE
[10:30:51.831]    + additional globals found: [n=0] 
[10:30:51.831]    + additional namespaces needed: [n=0] 
[10:30:51.831]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:51.831]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:51.831]  - seeds: <none>
[10:30:51.831]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.832] getGlobalsAndPackages() ...
[10:30:51.832] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.832] Resolving globals: FALSE
[10:30:51.833] The total size of the 5 globals is 904 bytes (904 bytes)
[10:30:51.833] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:51.834] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:51.834] 
[10:30:51.834] getGlobalsAndPackages() ... DONE
[10:30:51.834] run() for ‘Future’ ...
[10:30:51.835] - state: ‘created’
[10:30:51.835] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:30:51.839] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.840] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:30:51.840]   - Field: ‘label’
[10:30:51.840]   - Field: ‘local’
[10:30:51.840]   - Field: ‘owner’
[10:30:51.840]   - Field: ‘envir’
[10:30:51.840]   - Field: ‘workers’
[10:30:51.841]   - Field: ‘packages’
[10:30:51.841]   - Field: ‘gc’
[10:30:51.841]   - Field: ‘job’
[10:30:51.841]   - Field: ‘conditions’
[10:30:51.841]   - Field: ‘expr’
[10:30:51.841]   - Field: ‘uuid’
[10:30:51.841]   - Field: ‘seed’
[10:30:51.842]   - Field: ‘version’
[10:30:51.842]   - Field: ‘result’
[10:30:51.842]   - Field: ‘asynchronous’
[10:30:51.842]   - Field: ‘calls’
[10:30:51.842]   - Field: ‘globals’
[10:30:51.842]   - Field: ‘stdout’
[10:30:51.842]   - Field: ‘earlySignal’
[10:30:51.843]   - Field: ‘lazy’
[10:30:51.843]   - Field: ‘state’
[10:30:51.843] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:30:51.843] - Launch lazy future ...
[10:30:51.843] Packages needed by the future expression (n = 0): <none>
[10:30:51.844] Packages needed by future strategies (n = 0): <none>
[10:30:51.844] {
[10:30:51.844]     {
[10:30:51.844]         {
[10:30:51.844]             ...future.startTime <- base::Sys.time()
[10:30:51.844]             {
[10:30:51.844]                 {
[10:30:51.844]                   {
[10:30:51.844]                     {
[10:30:51.844]                       base::local({
[10:30:51.844]                         has_future <- base::requireNamespace("future", 
[10:30:51.844]                           quietly = TRUE)
[10:30:51.844]                         if (has_future) {
[10:30:51.844]                           ns <- base::getNamespace("future")
[10:30:51.844]                           version <- ns[[".package"]][["version"]]
[10:30:51.844]                           if (is.null(version)) 
[10:30:51.844]                             version <- utils::packageVersion("future")
[10:30:51.844]                         }
[10:30:51.844]                         else {
[10:30:51.844]                           version <- NULL
[10:30:51.844]                         }
[10:30:51.844]                         if (!has_future || version < "1.8.0") {
[10:30:51.844]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:51.844]                             "", base::R.version$version.string), 
[10:30:51.844]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:51.844]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:51.844]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:51.844]                               "release", "version")], collapse = " "), 
[10:30:51.844]                             hostname = base::Sys.info()[["nodename"]])
[10:30:51.844]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:51.844]                             info)
[10:30:51.844]                           info <- base::paste(info, collapse = "; ")
[10:30:51.844]                           if (!has_future) {
[10:30:51.844]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:51.844]                               info)
[10:30:51.844]                           }
[10:30:51.844]                           else {
[10:30:51.844]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:51.844]                               info, version)
[10:30:51.844]                           }
[10:30:51.844]                           base::stop(msg)
[10:30:51.844]                         }
[10:30:51.844]                       })
[10:30:51.844]                     }
[10:30:51.844]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:51.844]                     base::options(mc.cores = 1L)
[10:30:51.844]                   }
[10:30:51.844]                   ...future.strategy.old <- future::plan("list")
[10:30:51.844]                   options(future.plan = NULL)
[10:30:51.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:51.844]                 }
[10:30:51.844]                 ...future.workdir <- getwd()
[10:30:51.844]             }
[10:30:51.844]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:51.844]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:51.844]         }
[10:30:51.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:51.844]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:51.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:51.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:51.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:51.844]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:51.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:51.844]             base::names(...future.oldOptions))
[10:30:51.844]     }
[10:30:51.844]     if (FALSE) {
[10:30:51.844]     }
[10:30:51.844]     else {
[10:30:51.844]         if (TRUE) {
[10:30:51.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:51.844]                 open = "w")
[10:30:51.844]         }
[10:30:51.844]         else {
[10:30:51.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:51.844]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:51.844]         }
[10:30:51.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:51.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:51.844]             base::sink(type = "output", split = FALSE)
[10:30:51.844]             base::close(...future.stdout)
[10:30:51.844]         }, add = TRUE)
[10:30:51.844]     }
[10:30:51.844]     ...future.frame <- base::sys.nframe()
[10:30:51.844]     ...future.conditions <- base::list()
[10:30:51.844]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:51.844]     if (FALSE) {
[10:30:51.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:51.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:51.844]     }
[10:30:51.844]     ...future.result <- base::tryCatch({
[10:30:51.844]         base::withCallingHandlers({
[10:30:51.844]             ...future.value <- base::withVisible(base::local({
[10:30:51.844]                 withCallingHandlers({
[10:30:51.844]                   {
[10:30:51.844]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.844]                     if (!identical(...future.globals.maxSize.org, 
[10:30:51.844]                       ...future.globals.maxSize)) {
[10:30:51.844]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.844]                       on.exit(options(oopts), add = TRUE)
[10:30:51.844]                     }
[10:30:51.844]                     {
[10:30:51.844]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.844]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:51.844]                         USE.NAMES = FALSE)
[10:30:51.844]                       do.call(mapply, args = args)
[10:30:51.844]                     }
[10:30:51.844]                   }
[10:30:51.844]                 }, immediateCondition = function(cond) {
[10:30:51.844]                   save_rds <- function (object, pathname, ...) 
[10:30:51.844]                   {
[10:30:51.844]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:30:51.844]                     if (file_test("-f", pathname_tmp)) {
[10:30:51.844]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.844]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:30:51.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.844]                         fi_tmp[["mtime"]])
[10:30:51.844]                     }
[10:30:51.844]                     tryCatch({
[10:30:51.844]                       saveRDS(object, file = pathname_tmp, ...)
[10:30:51.844]                     }, error = function(ex) {
[10:30:51.844]                       msg <- conditionMessage(ex)
[10:30:51.844]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.844]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:30:51.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.844]                         fi_tmp[["mtime"]], msg)
[10:30:51.844]                       ex$message <- msg
[10:30:51.844]                       stop(ex)
[10:30:51.844]                     })
[10:30:51.844]                     stopifnot(file_test("-f", pathname_tmp))
[10:30:51.844]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:30:51.844]                     if (!res || file_test("-f", pathname_tmp)) {
[10:30:51.844]                       fi_tmp <- file.info(pathname_tmp)
[10:30:51.844]                       fi <- file.info(pathname)
[10:30:51.844]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:30:51.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:30:51.844]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:30:51.844]                         fi[["size"]], fi[["mtime"]])
[10:30:51.844]                       stop(msg)
[10:30:51.844]                     }
[10:30:51.844]                     invisible(pathname)
[10:30:51.844]                   }
[10:30:51.844]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:30:51.844]                     rootPath = tempdir()) 
[10:30:51.844]                   {
[10:30:51.844]                     obj <- list(time = Sys.time(), condition = cond)
[10:30:51.844]                     file <- tempfile(pattern = class(cond)[1], 
[10:30:51.844]                       tmpdir = path, fileext = ".rds")
[10:30:51.844]                     save_rds(obj, file)
[10:30:51.844]                   }
[10:30:51.844]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4zIALD/.future/immediateConditions")
[10:30:51.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.844]                   {
[10:30:51.844]                     inherits <- base::inherits
[10:30:51.844]                     invokeRestart <- base::invokeRestart
[10:30:51.844]                     is.null <- base::is.null
[10:30:51.844]                     muffled <- FALSE
[10:30:51.844]                     if (inherits(cond, "message")) {
[10:30:51.844]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:51.844]                       if (muffled) 
[10:30:51.844]                         invokeRestart("muffleMessage")
[10:30:51.844]                     }
[10:30:51.844]                     else if (inherits(cond, "warning")) {
[10:30:51.844]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:51.844]                       if (muffled) 
[10:30:51.844]                         invokeRestart("muffleWarning")
[10:30:51.844]                     }
[10:30:51.844]                     else if (inherits(cond, "condition")) {
[10:30:51.844]                       if (!is.null(pattern)) {
[10:30:51.844]                         computeRestarts <- base::computeRestarts
[10:30:51.844]                         grepl <- base::grepl
[10:30:51.844]                         restarts <- computeRestarts(cond)
[10:30:51.844]                         for (restart in restarts) {
[10:30:51.844]                           name <- restart$name
[10:30:51.844]                           if (is.null(name)) 
[10:30:51.844]                             next
[10:30:51.844]                           if (!grepl(pattern, name)) 
[10:30:51.844]                             next
[10:30:51.844]                           invokeRestart(restart)
[10:30:51.844]                           muffled <- TRUE
[10:30:51.844]                           break
[10:30:51.844]                         }
[10:30:51.844]                       }
[10:30:51.844]                     }
[10:30:51.844]                     invisible(muffled)
[10:30:51.844]                   }
[10:30:51.844]                   muffleCondition(cond)
[10:30:51.844]                 })
[10:30:51.844]             }))
[10:30:51.844]             future::FutureResult(value = ...future.value$value, 
[10:30:51.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.844]                   ...future.rng), globalenv = if (FALSE) 
[10:30:51.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:51.844]                     ...future.globalenv.names))
[10:30:51.844]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:51.844]         }, condition = base::local({
[10:30:51.844]             c <- base::c
[10:30:51.844]             inherits <- base::inherits
[10:30:51.844]             invokeRestart <- base::invokeRestart
[10:30:51.844]             length <- base::length
[10:30:51.844]             list <- base::list
[10:30:51.844]             seq.int <- base::seq.int
[10:30:51.844]             signalCondition <- base::signalCondition
[10:30:51.844]             sys.calls <- base::sys.calls
[10:30:51.844]             `[[` <- base::`[[`
[10:30:51.844]             `+` <- base::`+`
[10:30:51.844]             `<<-` <- base::`<<-`
[10:30:51.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:51.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:51.844]                   3L)]
[10:30:51.844]             }
[10:30:51.844]             function(cond) {
[10:30:51.844]                 is_error <- inherits(cond, "error")
[10:30:51.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:51.844]                   NULL)
[10:30:51.844]                 if (is_error) {
[10:30:51.844]                   sessionInformation <- function() {
[10:30:51.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:51.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:51.844]                       search = base::search(), system = base::Sys.info())
[10:30:51.844]                   }
[10:30:51.844]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:51.844]                     cond$call), session = sessionInformation(), 
[10:30:51.844]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:51.844]                   signalCondition(cond)
[10:30:51.844]                 }
[10:30:51.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:51.844]                 "immediateCondition"))) {
[10:30:51.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:51.844]                   ...future.conditions[[length(...future.conditions) + 
[10:30:51.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:51.844]                   if (TRUE && !signal) {
[10:30:51.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.844]                     {
[10:30:51.844]                       inherits <- base::inherits
[10:30:51.844]                       invokeRestart <- base::invokeRestart
[10:30:51.844]                       is.null <- base::is.null
[10:30:51.844]                       muffled <- FALSE
[10:30:51.844]                       if (inherits(cond, "message")) {
[10:30:51.844]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.844]                         if (muffled) 
[10:30:51.844]                           invokeRestart("muffleMessage")
[10:30:51.844]                       }
[10:30:51.844]                       else if (inherits(cond, "warning")) {
[10:30:51.844]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.844]                         if (muffled) 
[10:30:51.844]                           invokeRestart("muffleWarning")
[10:30:51.844]                       }
[10:30:51.844]                       else if (inherits(cond, "condition")) {
[10:30:51.844]                         if (!is.null(pattern)) {
[10:30:51.844]                           computeRestarts <- base::computeRestarts
[10:30:51.844]                           grepl <- base::grepl
[10:30:51.844]                           restarts <- computeRestarts(cond)
[10:30:51.844]                           for (restart in restarts) {
[10:30:51.844]                             name <- restart$name
[10:30:51.844]                             if (is.null(name)) 
[10:30:51.844]                               next
[10:30:51.844]                             if (!grepl(pattern, name)) 
[10:30:51.844]                               next
[10:30:51.844]                             invokeRestart(restart)
[10:30:51.844]                             muffled <- TRUE
[10:30:51.844]                             break
[10:30:51.844]                           }
[10:30:51.844]                         }
[10:30:51.844]                       }
[10:30:51.844]                       invisible(muffled)
[10:30:51.844]                     }
[10:30:51.844]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.844]                   }
[10:30:51.844]                 }
[10:30:51.844]                 else {
[10:30:51.844]                   if (TRUE) {
[10:30:51.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:51.844]                     {
[10:30:51.844]                       inherits <- base::inherits
[10:30:51.844]                       invokeRestart <- base::invokeRestart
[10:30:51.844]                       is.null <- base::is.null
[10:30:51.844]                       muffled <- FALSE
[10:30:51.844]                       if (inherits(cond, "message")) {
[10:30:51.844]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:51.844]                         if (muffled) 
[10:30:51.844]                           invokeRestart("muffleMessage")
[10:30:51.844]                       }
[10:30:51.844]                       else if (inherits(cond, "warning")) {
[10:30:51.844]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:51.844]                         if (muffled) 
[10:30:51.844]                           invokeRestart("muffleWarning")
[10:30:51.844]                       }
[10:30:51.844]                       else if (inherits(cond, "condition")) {
[10:30:51.844]                         if (!is.null(pattern)) {
[10:30:51.844]                           computeRestarts <- base::computeRestarts
[10:30:51.844]                           grepl <- base::grepl
[10:30:51.844]                           restarts <- computeRestarts(cond)
[10:30:51.844]                           for (restart in restarts) {
[10:30:51.844]                             name <- restart$name
[10:30:51.844]                             if (is.null(name)) 
[10:30:51.844]                               next
[10:30:51.844]                             if (!grepl(pattern, name)) 
[10:30:51.844]                               next
[10:30:51.844]                             invokeRestart(restart)
[10:30:51.844]                             muffled <- TRUE
[10:30:51.844]                             break
[10:30:51.844]                           }
[10:30:51.844]                         }
[10:30:51.844]                       }
[10:30:51.844]                       invisible(muffled)
[10:30:51.844]                     }
[10:30:51.844]                     muffleCondition(cond, pattern = "^muffle")
[10:30:51.844]                   }
[10:30:51.844]                 }
[10:30:51.844]             }
[10:30:51.844]         }))
[10:30:51.844]     }, error = function(ex) {
[10:30:51.844]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:51.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:51.844]                 ...future.rng), started = ...future.startTime, 
[10:30:51.844]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:51.844]             version = "1.8"), class = "FutureResult")
[10:30:51.844]     }, finally = {
[10:30:51.844]         if (!identical(...future.workdir, getwd())) 
[10:30:51.844]             setwd(...future.workdir)
[10:30:51.844]         {
[10:30:51.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:51.844]                 ...future.oldOptions$nwarnings <- NULL
[10:30:51.844]             }
[10:30:51.844]             base::options(...future.oldOptions)
[10:30:51.844]             if (.Platform$OS.type == "windows") {
[10:30:51.844]                 old_names <- names(...future.oldEnvVars)
[10:30:51.844]                 envs <- base::Sys.getenv()
[10:30:51.844]                 names <- names(envs)
[10:30:51.844]                 common <- intersect(names, old_names)
[10:30:51.844]                 added <- setdiff(names, old_names)
[10:30:51.844]                 removed <- setdiff(old_names, names)
[10:30:51.844]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:51.844]                   envs[common]]
[10:30:51.844]                 NAMES <- toupper(changed)
[10:30:51.844]                 args <- list()
[10:30:51.844]                 for (kk in seq_along(NAMES)) {
[10:30:51.844]                   name <- changed[[kk]]
[10:30:51.844]                   NAME <- NAMES[[kk]]
[10:30:51.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.844]                     next
[10:30:51.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.844]                 }
[10:30:51.844]                 NAMES <- toupper(added)
[10:30:51.844]                 for (kk in seq_along(NAMES)) {
[10:30:51.844]                   name <- added[[kk]]
[10:30:51.844]                   NAME <- NAMES[[kk]]
[10:30:51.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.844]                     next
[10:30:51.844]                   args[[name]] <- ""
[10:30:51.844]                 }
[10:30:51.844]                 NAMES <- toupper(removed)
[10:30:51.844]                 for (kk in seq_along(NAMES)) {
[10:30:51.844]                   name <- removed[[kk]]
[10:30:51.844]                   NAME <- NAMES[[kk]]
[10:30:51.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:51.844]                     next
[10:30:51.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:51.844]                 }
[10:30:51.844]                 if (length(args) > 0) 
[10:30:51.844]                   base::do.call(base::Sys.setenv, args = args)
[10:30:51.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:51.844]             }
[10:30:51.844]             else {
[10:30:51.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:51.844]             }
[10:30:51.844]             {
[10:30:51.844]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:51.844]                   0L) {
[10:30:51.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:51.844]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:51.844]                   base::options(opts)
[10:30:51.844]                 }
[10:30:51.844]                 {
[10:30:51.844]                   {
[10:30:51.844]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:51.844]                     NULL
[10:30:51.844]                   }
[10:30:51.844]                   options(future.plan = NULL)
[10:30:51.844]                   if (is.na(NA_character_)) 
[10:30:51.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:51.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:51.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:51.844]                     .init = FALSE)
[10:30:51.844]                 }
[10:30:51.844]             }
[10:30:51.844]         }
[10:30:51.844]     })
[10:30:51.844]     if (TRUE) {
[10:30:51.844]         base::sink(type = "output", split = FALSE)
[10:30:51.844]         if (TRUE) {
[10:30:51.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:51.844]         }
[10:30:51.844]         else {
[10:30:51.844]             ...future.result["stdout"] <- base::list(NULL)
[10:30:51.844]         }
[10:30:51.844]         base::close(...future.stdout)
[10:30:51.844]         ...future.stdout <- NULL
[10:30:51.844]     }
[10:30:51.844]     ...future.result$conditions <- ...future.conditions
[10:30:51.844]     ...future.result$finished <- base::Sys.time()
[10:30:51.844]     ...future.result
[10:30:51.844] }
[10:30:51.848] assign_globals() ...
[10:30:51.848] List of 5
[10:30:51.848]  $ ...future.FUN            :function (x)  
[10:30:51.848]  $ MoreArgs                 : NULL
[10:30:51.848]  $ ...future.elements_ii    :List of 1
[10:30:51.848]   ..$ :List of 1
[10:30:51.848]   .. ..$ b: num 0
[10:30:51.848]  $ ...future.seeds_ii       : NULL
[10:30:51.848]  $ ...future.globals.maxSize: NULL
[10:30:51.848]  - attr(*, "where")=List of 5
[10:30:51.848]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:30:51.848]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:30:51.848]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:30:51.848]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:30:51.848]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:30:51.848]  - attr(*, "resolved")= logi FALSE
[10:30:51.848]  - attr(*, "total_size")= num 904
[10:30:51.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:51.848]  - attr(*, "already-done")= logi TRUE
[10:30:51.856] - copied ‘...future.FUN’ to environment
[10:30:51.856] - copied ‘MoreArgs’ to environment
[10:30:51.856] - copied ‘...future.elements_ii’ to environment
[10:30:51.856] - copied ‘...future.seeds_ii’ to environment
[10:30:51.857] - copied ‘...future.globals.maxSize’ to environment
[10:30:51.857] assign_globals() ... done
[10:30:51.857] requestCore(): workers = 2
[10:30:51.860] MulticoreFuture started
[10:30:51.860] - Launch lazy future ... done
[10:30:51.860] run() for ‘MulticoreFuture’ ... done
[10:30:51.861] Created future:
[10:30:51.861] plan(): Setting new future strategy stack:
[10:30:51.861] List of future strategies:
[10:30:51.861] 1. sequential:
[10:30:51.861]    - args: function (..., envir = parent.frame())
[10:30:51.861]    - tweaked: FALSE
[10:30:51.861]    - call: NULL
[10:30:51.862] plan(): nbrOfWorkers() = 1
[10:30:51.864] plan(): Setting new future strategy stack:
[10:30:51.865] List of future strategies:
[10:30:51.865] 1. multicore:
[10:30:51.865]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:30:51.865]    - tweaked: FALSE
[10:30:51.865]    - call: plan(strategy)
[10:30:51.871] plan(): nbrOfWorkers() = 2
[10:30:51.861] MulticoreFuture:
[10:30:51.861] Label: ‘future_mapply-2’
[10:30:51.861] Expression:
[10:30:51.861] {
[10:30:51.861]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:51.861]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:51.861]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:51.861]         on.exit(options(oopts), add = TRUE)
[10:30:51.861]     }
[10:30:51.861]     {
[10:30:51.861]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:51.861]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:51.861]         do.call(mapply, args = args)
[10:30:51.861]     }
[10:30:51.861] }
[10:30:51.861] Lazy evaluation: FALSE
[10:30:51.861] Asynchronous evaluation: TRUE
[10:30:51.861] Local evaluation: TRUE
[10:30:51.861] Environment: R_GlobalEnv
[10:30:51.861] Capture standard output: TRUE
[10:30:51.861] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:51.861] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:51.861] Packages: <none>
[10:30:51.861] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:51.861] Resolved: TRUE
[10:30:51.861] Value: <not collected>
[10:30:51.861] Conditions captured: <none>
[10:30:51.861] Early signaling: FALSE
[10:30:51.861] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:51.861] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:51.872] Chunk #2 of 2 ... DONE
[10:30:51.872] Launching 2 futures (chunks) ... DONE
[10:30:51.872] Resolving 2 futures (chunks) ...
[10:30:51.873] resolve() on list ...
[10:30:51.873]  recursive: 0
[10:30:51.873]  length: 2
[10:30:51.874] 
[10:30:51.874] Future #1
[10:30:51.874] result() for MulticoreFuture ...
[10:30:51.875] result() for MulticoreFuture ...
[10:30:51.875] result() for MulticoreFuture ... done
[10:30:51.875] result() for MulticoreFuture ... done
[10:30:51.876] result() for MulticoreFuture ...
[10:30:51.876] result() for MulticoreFuture ... done
[10:30:51.876] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:30:51.876] - nx: 2
[10:30:51.876] - relay: TRUE
[10:30:51.876] - stdout: TRUE
[10:30:51.877] - signal: TRUE
[10:30:51.877] - resignal: FALSE
[10:30:51.877] - force: TRUE
[10:30:51.877] - relayed: [n=2] FALSE, FALSE
[10:30:51.877] - queued futures: [n=2] FALSE, FALSE
[10:30:51.877]  - until=1
[10:30:51.878]  - relaying element #1
[10:30:51.878] result() for MulticoreFuture ...
[10:30:51.878] result() for MulticoreFuture ... done
[10:30:51.878] result() for MulticoreFuture ...
[10:30:51.878] result() for MulticoreFuture ... done
[10:30:51.878] result() for MulticoreFuture ...
[10:30:51.878] result() for MulticoreFuture ... done
[10:30:51.879] result() for MulticoreFuture ...
[10:30:51.879] result() for MulticoreFuture ... done
[10:30:51.879] - relayed: [n=2] TRUE, FALSE
[10:30:51.879] - queued futures: [n=2] TRUE, FALSE
[10:30:51.879] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:30:51.879]  length: 1 (resolved future 1)
[10:30:51.880] Future #2
[10:30:51.880] result() for MulticoreFuture ...
[10:30:51.880] result() for MulticoreFuture ...
[10:30:51.881] result() for MulticoreFuture ... done
[10:30:51.881] result() for MulticoreFuture ... done
[10:30:51.881] result() for MulticoreFuture ...
[10:30:51.881] result() for MulticoreFuture ... done
[10:30:51.881] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:30:51.881] - nx: 2
[10:30:51.882] - relay: TRUE
[10:30:51.882] - stdout: TRUE
[10:30:51.882] - signal: TRUE
[10:30:51.882] - resignal: FALSE
[10:30:51.882] - force: TRUE
[10:30:51.882] - relayed: [n=2] TRUE, FALSE
[10:30:51.882] - queued futures: [n=2] TRUE, FALSE
[10:30:51.882]  - until=2
[10:30:51.882]  - relaying element #2
[10:30:51.883] result() for MulticoreFuture ...
[10:30:51.883] result() for MulticoreFuture ... done
[10:30:51.883] result() for MulticoreFuture ...
[10:30:51.883] result() for MulticoreFuture ... done
[10:30:51.883] result() for MulticoreFuture ...
[10:30:51.883] result() for MulticoreFuture ... done
[10:30:51.883] result() for MulticoreFuture ...
[10:30:51.883] result() for MulticoreFuture ... done
[10:30:51.883] - relayed: [n=2] TRUE, TRUE
[10:30:51.884] - queued futures: [n=2] TRUE, TRUE
[10:30:51.884] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:30:51.884]  length: 0 (resolved future 2)
[10:30:51.884] Relaying remaining futures
[10:30:51.884] signalConditionsASAP(NULL, pos=0) ...
[10:30:51.884] - nx: 2
[10:30:51.884] - relay: TRUE
[10:30:51.884] - stdout: TRUE
[10:30:51.884] - signal: TRUE
[10:30:51.884] - resignal: FALSE
[10:30:51.885] - force: TRUE
[10:30:51.885] - relayed: [n=2] TRUE, TRUE
[10:30:51.885] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:51.885] - relayed: [n=2] TRUE, TRUE
[10:30:51.885] - queued futures: [n=2] TRUE, TRUE
[10:30:51.885] signalConditionsASAP(NULL, pos=0) ... done
[10:30:51.885] resolve() on list ... DONE
[10:30:51.885] result() for MulticoreFuture ...
[10:30:51.886] result() for MulticoreFuture ... done
[10:30:51.886] result() for MulticoreFuture ...
[10:30:51.886] result() for MulticoreFuture ... done
[10:30:51.886] result() for MulticoreFuture ...
[10:30:51.886] result() for MulticoreFuture ... done
[10:30:51.886] result() for MulticoreFuture ...
[10:30:51.886] result() for MulticoreFuture ... done
[10:30:51.886]  - Number of value chunks collected: 2
[10:30:51.886] Resolving 2 futures (chunks) ... DONE
[10:30:51.887] Reducing values from 2 chunks ...
[10:30:51.887]  - Number of values collected after concatenation: 2
[10:30:51.887]  - Number of values expected: 2
[10:30:51.887] Reducing values from 2 chunks ... DONE
[10:30:51.887] future_mapply() ... DONE
[10:30:51.887] plan(): Setting new future strategy stack:
[10:30:51.887] List of future strategies:
[10:30:51.887] 1. sequential:
[10:30:51.887]    - args: function (..., envir = parent.frame())
[10:30:51.887]    - tweaked: FALSE
[10:30:51.887]    - call: plan(sequential)
[10:30:51.888] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:30:51.888] plan(): Setting new future strategy stack:
[10:30:51.889] List of future strategies:
[10:30:51.889] 1. multisession:
[10:30:51.889]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:30:51.889]    - tweaked: FALSE
[10:30:51.889]    - call: plan(strategy)
[10:30:51.889] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:30:51.889] multisession:
[10:30:51.889] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:30:51.889] - tweaked: FALSE
[10:30:51.889] - call: plan(strategy)
[10:30:51.896] getGlobalsAndPackages() ...
[10:30:51.896] Not searching for globals
[10:30:51.896] - globals: [0] <none>
[10:30:51.897] getGlobalsAndPackages() ... DONE
[10:30:51.897] [local output] makeClusterPSOCK() ...
[10:30:51.950] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:30:51.951] [local output] Base port: 11429
[10:30:51.951] [local output] Getting setup options for 2 cluster nodes ...
[10:30:51.951] [local output]  - Node 1 of 2 ...
[10:30:51.952] [local output] localMachine=TRUE => revtunnel=FALSE

[10:30:51.953] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4zIALD/worker.rank=1.parallelly.parent=74094.1216e7728e0b0.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp4zIALD/worker.rank=1.parallelly.parent=74094.1216e7728e0b0.pid")'’
[10:30:52.146] - Possible to infer worker's PID: TRUE
[10:30:52.147] [local output] Rscript port: 11429

[10:30:52.147] [local output]  - Node 2 of 2 ...
[10:30:52.147] [local output] localMachine=TRUE => revtunnel=FALSE

[10:30:52.148] [local output] Rscript port: 11429

[10:30:52.148] [local output] Getting setup options for 2 cluster nodes ... done
[10:30:52.148] [local output]  - Parallel setup requested for some PSOCK nodes
[10:30:52.149] [local output] Setting up PSOCK nodes in parallel
[10:30:52.149] List of 36
[10:30:52.149]  $ worker          : chr "localhost"
[10:30:52.149]   ..- attr(*, "localhost")= logi TRUE
[10:30:52.149]  $ master          : chr "localhost"
[10:30:52.149]  $ port            : int 11429
[10:30:52.149]  $ connectTimeout  : num 120
[10:30:52.149]  $ timeout         : num 2592000
[10:30:52.149]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:30:52.149]  $ homogeneous     : logi TRUE
[10:30:52.149]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:30:52.149]  $ rscript_envs    : NULL
[10:30:52.149]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:30:52.149]  $ rscript_startup : NULL
[10:30:52.149]  $ rscript_sh      : chr "sh"
[10:30:52.149]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:30:52.149]  $ methods         : logi TRUE
[10:30:52.149]  $ socketOptions   : chr "no-delay"
[10:30:52.149]  $ useXDR          : logi FALSE
[10:30:52.149]  $ outfile         : chr "/dev/null"
[10:30:52.149]  $ renice          : int NA
[10:30:52.149]  $ rshcmd          : NULL
[10:30:52.149]  $ user            : chr(0) 
[10:30:52.149]  $ revtunnel       : logi FALSE
[10:30:52.149]  $ rshlogfile      : NULL
[10:30:52.149]  $ rshopts         : chr(0) 
[10:30:52.149]  $ rank            : int 1
[10:30:52.149]  $ manual          : logi FALSE
[10:30:52.149]  $ dryrun          : logi FALSE
[10:30:52.149]  $ quiet           : logi FALSE
[10:30:52.149]  $ setup_strategy  : chr "parallel"
[10:30:52.149]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:30:52.149]  $ pidfile         : chr "/tmp/Rtmp4zIALD/worker.rank=1.parallelly.parent=74094.1216e7728e0b0.pid"
[10:30:52.149]  $ rshcmd_label    : NULL
[10:30:52.149]  $ rsh_call        : NULL
[10:30:52.149]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:30:52.149]  $ localMachine    : logi TRUE
[10:30:52.149]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:30:52.149]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:30:52.149]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:30:52.149]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:30:52.149]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:30:52.149]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:30:52.149]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:30:52.149]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:30:52.149]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:30:52.149]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:30:52.149]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:30:52.149]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:30:52.149]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:30:52.149]  $ arguments       :List of 28
[10:30:52.149]   ..$ worker          : chr "localhost"
[10:30:52.149]   ..$ master          : NULL
[10:30:52.149]   ..$ port            : int 11429
[10:30:52.149]   ..$ connectTimeout  : num 120
[10:30:52.149]   ..$ timeout         : num 2592000
[10:30:52.149]   ..$ rscript         : NULL
[10:30:52.149]   ..$ homogeneous     : NULL
[10:30:52.149]   ..$ rscript_args    : NULL
[10:30:52.149]   ..$ rscript_envs    : NULL
[10:30:52.149]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:30:52.149]   ..$ rscript_startup : NULL
[10:30:52.149]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:30:52.149]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:30:52.149]   ..$ methods         : logi TRUE
[10:30:52.149]   ..$ socketOptions   : chr "no-delay"
[10:30:52.149]   ..$ useXDR          : logi FALSE
[10:30:52.149]   ..$ outfile         : chr "/dev/null"
[10:30:52.149]   ..$ renice          : int NA
[10:30:52.149]   ..$ rshcmd          : NULL
[10:30:52.149]   ..$ user            : NULL
[10:30:52.149]   ..$ revtunnel       : logi NA
[10:30:52.149]   ..$ rshlogfile      : NULL
[10:30:52.149]   ..$ rshopts         : NULL
[10:30:52.149]   ..$ rank            : int 1
[10:30:52.149]   ..$ manual          : logi FALSE
[10:30:52.149]   ..$ dryrun          : logi FALSE
[10:30:52.149]   ..$ quiet           : logi FALSE
[10:30:52.149]   ..$ setup_strategy  : chr "parallel"
[10:30:52.149]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:30:52.165] [local output] System call to launch all workers:
[10:30:52.166] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4zIALD/worker.rank=1.parallelly.parent=74094.1216e7728e0b0.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11429 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:30:52.166] [local output] Starting PSOCK main server
[10:30:52.171] [local output] Workers launched
[10:30:52.171] [local output] Waiting for workers to connect back
[10:30:52.172]  - [local output] 0 workers out of 2 ready
[10:30:52.418]  - [local output] 0 workers out of 2 ready
[10:30:52.419]  - [local output] 1 workers out of 2 ready
[10:30:52.420]  - [local output] 1 workers out of 2 ready
[10:30:52.420]  - [local output] 2 workers out of 2 ready
[10:30:52.420] [local output] Launching of workers completed
[10:30:52.420] [local output] Collecting session information from workers
[10:30:52.421] [local output]  - Worker #1 of 2
[10:30:52.422] [local output]  - Worker #2 of 2
[10:30:52.422] [local output] makeClusterPSOCK() ... done
[10:30:52.433] Packages needed by the future expression (n = 0): <none>
[10:30:52.433] Packages needed by future strategies (n = 0): <none>
[10:30:52.434] {
[10:30:52.434]     {
[10:30:52.434]         {
[10:30:52.434]             ...future.startTime <- base::Sys.time()
[10:30:52.434]             {
[10:30:52.434]                 {
[10:30:52.434]                   {
[10:30:52.434]                     {
[10:30:52.434]                       base::local({
[10:30:52.434]                         has_future <- base::requireNamespace("future", 
[10:30:52.434]                           quietly = TRUE)
[10:30:52.434]                         if (has_future) {
[10:30:52.434]                           ns <- base::getNamespace("future")
[10:30:52.434]                           version <- ns[[".package"]][["version"]]
[10:30:52.434]                           if (is.null(version)) 
[10:30:52.434]                             version <- utils::packageVersion("future")
[10:30:52.434]                         }
[10:30:52.434]                         else {
[10:30:52.434]                           version <- NULL
[10:30:52.434]                         }
[10:30:52.434]                         if (!has_future || version < "1.8.0") {
[10:30:52.434]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:52.434]                             "", base::R.version$version.string), 
[10:30:52.434]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:52.434]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:52.434]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:52.434]                               "release", "version")], collapse = " "), 
[10:30:52.434]                             hostname = base::Sys.info()[["nodename"]])
[10:30:52.434]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:52.434]                             info)
[10:30:52.434]                           info <- base::paste(info, collapse = "; ")
[10:30:52.434]                           if (!has_future) {
[10:30:52.434]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:52.434]                               info)
[10:30:52.434]                           }
[10:30:52.434]                           else {
[10:30:52.434]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:52.434]                               info, version)
[10:30:52.434]                           }
[10:30:52.434]                           base::stop(msg)
[10:30:52.434]                         }
[10:30:52.434]                       })
[10:30:52.434]                     }
[10:30:52.434]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:52.434]                     base::options(mc.cores = 1L)
[10:30:52.434]                   }
[10:30:52.434]                   ...future.strategy.old <- future::plan("list")
[10:30:52.434]                   options(future.plan = NULL)
[10:30:52.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:52.434]                 }
[10:30:52.434]                 ...future.workdir <- getwd()
[10:30:52.434]             }
[10:30:52.434]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:52.434]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:52.434]         }
[10:30:52.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:52.434]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:52.434]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:52.434]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:52.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:52.434]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:52.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:52.434]             base::names(...future.oldOptions))
[10:30:52.434]     }
[10:30:52.434]     if (FALSE) {
[10:30:52.434]     }
[10:30:52.434]     else {
[10:30:52.434]         if (TRUE) {
[10:30:52.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:52.434]                 open = "w")
[10:30:52.434]         }
[10:30:52.434]         else {
[10:30:52.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:52.434]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:52.434]         }
[10:30:52.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:52.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:52.434]             base::sink(type = "output", split = FALSE)
[10:30:52.434]             base::close(...future.stdout)
[10:30:52.434]         }, add = TRUE)
[10:30:52.434]     }
[10:30:52.434]     ...future.frame <- base::sys.nframe()
[10:30:52.434]     ...future.conditions <- base::list()
[10:30:52.434]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:52.434]     if (FALSE) {
[10:30:52.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:52.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:52.434]     }
[10:30:52.434]     ...future.result <- base::tryCatch({
[10:30:52.434]         base::withCallingHandlers({
[10:30:52.434]             ...future.value <- base::withVisible(base::local({
[10:30:52.434]                 ...future.makeSendCondition <- base::local({
[10:30:52.434]                   sendCondition <- NULL
[10:30:52.434]                   function(frame = 1L) {
[10:30:52.434]                     if (is.function(sendCondition)) 
[10:30:52.434]                       return(sendCondition)
[10:30:52.434]                     ns <- getNamespace("parallel")
[10:30:52.434]                     if (exists("sendData", mode = "function", 
[10:30:52.434]                       envir = ns)) {
[10:30:52.434]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:52.434]                         envir = ns)
[10:30:52.434]                       envir <- sys.frame(frame)
[10:30:52.434]                       master <- NULL
[10:30:52.434]                       while (!identical(envir, .GlobalEnv) && 
[10:30:52.434]                         !identical(envir, emptyenv())) {
[10:30:52.434]                         if (exists("master", mode = "list", envir = envir, 
[10:30:52.434]                           inherits = FALSE)) {
[10:30:52.434]                           master <- get("master", mode = "list", 
[10:30:52.434]                             envir = envir, inherits = FALSE)
[10:30:52.434]                           if (inherits(master, c("SOCKnode", 
[10:30:52.434]                             "SOCK0node"))) {
[10:30:52.434]                             sendCondition <<- function(cond) {
[10:30:52.434]                               data <- list(type = "VALUE", value = cond, 
[10:30:52.434]                                 success = TRUE)
[10:30:52.434]                               parallel_sendData(master, data)
[10:30:52.434]                             }
[10:30:52.434]                             return(sendCondition)
[10:30:52.434]                           }
[10:30:52.434]                         }
[10:30:52.434]                         frame <- frame + 1L
[10:30:52.434]                         envir <- sys.frame(frame)
[10:30:52.434]                       }
[10:30:52.434]                     }
[10:30:52.434]                     sendCondition <<- function(cond) NULL
[10:30:52.434]                   }
[10:30:52.434]                 })
[10:30:52.434]                 withCallingHandlers({
[10:30:52.434]                   NA
[10:30:52.434]                 }, immediateCondition = function(cond) {
[10:30:52.434]                   sendCondition <- ...future.makeSendCondition()
[10:30:52.434]                   sendCondition(cond)
[10:30:52.434]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.434]                   {
[10:30:52.434]                     inherits <- base::inherits
[10:30:52.434]                     invokeRestart <- base::invokeRestart
[10:30:52.434]                     is.null <- base::is.null
[10:30:52.434]                     muffled <- FALSE
[10:30:52.434]                     if (inherits(cond, "message")) {
[10:30:52.434]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:52.434]                       if (muffled) 
[10:30:52.434]                         invokeRestart("muffleMessage")
[10:30:52.434]                     }
[10:30:52.434]                     else if (inherits(cond, "warning")) {
[10:30:52.434]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:52.434]                       if (muffled) 
[10:30:52.434]                         invokeRestart("muffleWarning")
[10:30:52.434]                     }
[10:30:52.434]                     else if (inherits(cond, "condition")) {
[10:30:52.434]                       if (!is.null(pattern)) {
[10:30:52.434]                         computeRestarts <- base::computeRestarts
[10:30:52.434]                         grepl <- base::grepl
[10:30:52.434]                         restarts <- computeRestarts(cond)
[10:30:52.434]                         for (restart in restarts) {
[10:30:52.434]                           name <- restart$name
[10:30:52.434]                           if (is.null(name)) 
[10:30:52.434]                             next
[10:30:52.434]                           if (!grepl(pattern, name)) 
[10:30:52.434]                             next
[10:30:52.434]                           invokeRestart(restart)
[10:30:52.434]                           muffled <- TRUE
[10:30:52.434]                           break
[10:30:52.434]                         }
[10:30:52.434]                       }
[10:30:52.434]                     }
[10:30:52.434]                     invisible(muffled)
[10:30:52.434]                   }
[10:30:52.434]                   muffleCondition(cond)
[10:30:52.434]                 })
[10:30:52.434]             }))
[10:30:52.434]             future::FutureResult(value = ...future.value$value, 
[10:30:52.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.434]                   ...future.rng), globalenv = if (FALSE) 
[10:30:52.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:52.434]                     ...future.globalenv.names))
[10:30:52.434]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:52.434]         }, condition = base::local({
[10:30:52.434]             c <- base::c
[10:30:52.434]             inherits <- base::inherits
[10:30:52.434]             invokeRestart <- base::invokeRestart
[10:30:52.434]             length <- base::length
[10:30:52.434]             list <- base::list
[10:30:52.434]             seq.int <- base::seq.int
[10:30:52.434]             signalCondition <- base::signalCondition
[10:30:52.434]             sys.calls <- base::sys.calls
[10:30:52.434]             `[[` <- base::`[[`
[10:30:52.434]             `+` <- base::`+`
[10:30:52.434]             `<<-` <- base::`<<-`
[10:30:52.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:52.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:52.434]                   3L)]
[10:30:52.434]             }
[10:30:52.434]             function(cond) {
[10:30:52.434]                 is_error <- inherits(cond, "error")
[10:30:52.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:52.434]                   NULL)
[10:30:52.434]                 if (is_error) {
[10:30:52.434]                   sessionInformation <- function() {
[10:30:52.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:52.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:52.434]                       search = base::search(), system = base::Sys.info())
[10:30:52.434]                   }
[10:30:52.434]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:52.434]                     cond$call), session = sessionInformation(), 
[10:30:52.434]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:52.434]                   signalCondition(cond)
[10:30:52.434]                 }
[10:30:52.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:52.434]                 "immediateCondition"))) {
[10:30:52.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:52.434]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:52.434]                   if (TRUE && !signal) {
[10:30:52.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.434]                     {
[10:30:52.434]                       inherits <- base::inherits
[10:30:52.434]                       invokeRestart <- base::invokeRestart
[10:30:52.434]                       is.null <- base::is.null
[10:30:52.434]                       muffled <- FALSE
[10:30:52.434]                       if (inherits(cond, "message")) {
[10:30:52.434]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.434]                         if (muffled) 
[10:30:52.434]                           invokeRestart("muffleMessage")
[10:30:52.434]                       }
[10:30:52.434]                       else if (inherits(cond, "warning")) {
[10:30:52.434]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.434]                         if (muffled) 
[10:30:52.434]                           invokeRestart("muffleWarning")
[10:30:52.434]                       }
[10:30:52.434]                       else if (inherits(cond, "condition")) {
[10:30:52.434]                         if (!is.null(pattern)) {
[10:30:52.434]                           computeRestarts <- base::computeRestarts
[10:30:52.434]                           grepl <- base::grepl
[10:30:52.434]                           restarts <- computeRestarts(cond)
[10:30:52.434]                           for (restart in restarts) {
[10:30:52.434]                             name <- restart$name
[10:30:52.434]                             if (is.null(name)) 
[10:30:52.434]                               next
[10:30:52.434]                             if (!grepl(pattern, name)) 
[10:30:52.434]                               next
[10:30:52.434]                             invokeRestart(restart)
[10:30:52.434]                             muffled <- TRUE
[10:30:52.434]                             break
[10:30:52.434]                           }
[10:30:52.434]                         }
[10:30:52.434]                       }
[10:30:52.434]                       invisible(muffled)
[10:30:52.434]                     }
[10:30:52.434]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.434]                   }
[10:30:52.434]                 }
[10:30:52.434]                 else {
[10:30:52.434]                   if (TRUE) {
[10:30:52.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.434]                     {
[10:30:52.434]                       inherits <- base::inherits
[10:30:52.434]                       invokeRestart <- base::invokeRestart
[10:30:52.434]                       is.null <- base::is.null
[10:30:52.434]                       muffled <- FALSE
[10:30:52.434]                       if (inherits(cond, "message")) {
[10:30:52.434]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.434]                         if (muffled) 
[10:30:52.434]                           invokeRestart("muffleMessage")
[10:30:52.434]                       }
[10:30:52.434]                       else if (inherits(cond, "warning")) {
[10:30:52.434]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.434]                         if (muffled) 
[10:30:52.434]                           invokeRestart("muffleWarning")
[10:30:52.434]                       }
[10:30:52.434]                       else if (inherits(cond, "condition")) {
[10:30:52.434]                         if (!is.null(pattern)) {
[10:30:52.434]                           computeRestarts <- base::computeRestarts
[10:30:52.434]                           grepl <- base::grepl
[10:30:52.434]                           restarts <- computeRestarts(cond)
[10:30:52.434]                           for (restart in restarts) {
[10:30:52.434]                             name <- restart$name
[10:30:52.434]                             if (is.null(name)) 
[10:30:52.434]                               next
[10:30:52.434]                             if (!grepl(pattern, name)) 
[10:30:52.434]                               next
[10:30:52.434]                             invokeRestart(restart)
[10:30:52.434]                             muffled <- TRUE
[10:30:52.434]                             break
[10:30:52.434]                           }
[10:30:52.434]                         }
[10:30:52.434]                       }
[10:30:52.434]                       invisible(muffled)
[10:30:52.434]                     }
[10:30:52.434]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.434]                   }
[10:30:52.434]                 }
[10:30:52.434]             }
[10:30:52.434]         }))
[10:30:52.434]     }, error = function(ex) {
[10:30:52.434]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:52.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.434]                 ...future.rng), started = ...future.startTime, 
[10:30:52.434]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:52.434]             version = "1.8"), class = "FutureResult")
[10:30:52.434]     }, finally = {
[10:30:52.434]         if (!identical(...future.workdir, getwd())) 
[10:30:52.434]             setwd(...future.workdir)
[10:30:52.434]         {
[10:30:52.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:52.434]                 ...future.oldOptions$nwarnings <- NULL
[10:30:52.434]             }
[10:30:52.434]             base::options(...future.oldOptions)
[10:30:52.434]             if (.Platform$OS.type == "windows") {
[10:30:52.434]                 old_names <- names(...future.oldEnvVars)
[10:30:52.434]                 envs <- base::Sys.getenv()
[10:30:52.434]                 names <- names(envs)
[10:30:52.434]                 common <- intersect(names, old_names)
[10:30:52.434]                 added <- setdiff(names, old_names)
[10:30:52.434]                 removed <- setdiff(old_names, names)
[10:30:52.434]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:52.434]                   envs[common]]
[10:30:52.434]                 NAMES <- toupper(changed)
[10:30:52.434]                 args <- list()
[10:30:52.434]                 for (kk in seq_along(NAMES)) {
[10:30:52.434]                   name <- changed[[kk]]
[10:30:52.434]                   NAME <- NAMES[[kk]]
[10:30:52.434]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.434]                     next
[10:30:52.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.434]                 }
[10:30:52.434]                 NAMES <- toupper(added)
[10:30:52.434]                 for (kk in seq_along(NAMES)) {
[10:30:52.434]                   name <- added[[kk]]
[10:30:52.434]                   NAME <- NAMES[[kk]]
[10:30:52.434]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.434]                     next
[10:30:52.434]                   args[[name]] <- ""
[10:30:52.434]                 }
[10:30:52.434]                 NAMES <- toupper(removed)
[10:30:52.434]                 for (kk in seq_along(NAMES)) {
[10:30:52.434]                   name <- removed[[kk]]
[10:30:52.434]                   NAME <- NAMES[[kk]]
[10:30:52.434]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.434]                     next
[10:30:52.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.434]                 }
[10:30:52.434]                 if (length(args) > 0) 
[10:30:52.434]                   base::do.call(base::Sys.setenv, args = args)
[10:30:52.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:52.434]             }
[10:30:52.434]             else {
[10:30:52.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:52.434]             }
[10:30:52.434]             {
[10:30:52.434]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:52.434]                   0L) {
[10:30:52.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:52.434]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:52.434]                   base::options(opts)
[10:30:52.434]                 }
[10:30:52.434]                 {
[10:30:52.434]                   {
[10:30:52.434]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:52.434]                     NULL
[10:30:52.434]                   }
[10:30:52.434]                   options(future.plan = NULL)
[10:30:52.434]                   if (is.na(NA_character_)) 
[10:30:52.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:52.434]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:52.434]                     .init = FALSE)
[10:30:52.434]                 }
[10:30:52.434]             }
[10:30:52.434]         }
[10:30:52.434]     })
[10:30:52.434]     if (TRUE) {
[10:30:52.434]         base::sink(type = "output", split = FALSE)
[10:30:52.434]         if (TRUE) {
[10:30:52.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:52.434]         }
[10:30:52.434]         else {
[10:30:52.434]             ...future.result["stdout"] <- base::list(NULL)
[10:30:52.434]         }
[10:30:52.434]         base::close(...future.stdout)
[10:30:52.434]         ...future.stdout <- NULL
[10:30:52.434]     }
[10:30:52.434]     ...future.result$conditions <- ...future.conditions
[10:30:52.434]     ...future.result$finished <- base::Sys.time()
[10:30:52.434]     ...future.result
[10:30:52.434] }
[10:30:52.488] MultisessionFuture started
[10:30:52.488] result() for ClusterFuture ...
[10:30:52.489] receiveMessageFromWorker() for ClusterFuture ...
[10:30:52.489] - Validating connection of MultisessionFuture
[10:30:52.522] - received message: FutureResult
[10:30:52.523] - Received FutureResult
[10:30:52.523] - Erased future from FutureRegistry
[10:30:52.523] result() for ClusterFuture ...
[10:30:52.523] - result already collected: FutureResult
[10:30:52.523] result() for ClusterFuture ... done
[10:30:52.523] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:52.523] result() for ClusterFuture ... done
[10:30:52.523] result() for ClusterFuture ...
[10:30:52.523] - result already collected: FutureResult
[10:30:52.523] result() for ClusterFuture ... done
[10:30:52.524] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:30:52.528] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[10:30:52.528] future_mapply() ...
[10:30:52.531] Number of chunks: 2
[10:30:52.532] getGlobalsAndPackagesXApply() ...
[10:30:52.532]  - future.globals: TRUE
[10:30:52.532] getGlobalsAndPackages() ...
[10:30:52.532] Searching for globals...
[10:30:52.533] - globals found: [1] ‘FUN’
[10:30:52.533] Searching for globals ... DONE
[10:30:52.533] Resolving globals: FALSE
[10:30:52.533] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:52.533] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:52.534] - globals: [1] ‘FUN’
[10:30:52.534] 
[10:30:52.534] getGlobalsAndPackages() ... DONE
[10:30:52.534]  - globals found/used: [n=1] ‘FUN’
[10:30:52.534]  - needed namespaces: [n=0] 
[10:30:52.534] Finding globals ... DONE
[10:30:52.534] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:52.534] List of 2
[10:30:52.534]  $ ...future.FUN:function (x, ...)  
[10:30:52.534]  $ MoreArgs     : NULL
[10:30:52.534]  - attr(*, "where")=List of 2
[10:30:52.534]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:52.534]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:52.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:52.534]  - attr(*, "resolved")= logi FALSE
[10:30:52.534]  - attr(*, "total_size")= num NA
[10:30:52.537] Packages to be attached in all futures: [n=0] 
[10:30:52.537] getGlobalsAndPackagesXApply() ... DONE
[10:30:52.537] Number of futures (= number of chunks): 2
[10:30:52.537] Launching 2 futures (chunks) ...
[10:30:52.537] Chunk #1 of 2 ...
[10:30:52.537]  - Finding globals in '...' for chunk #1 ...
[10:30:52.537] getGlobalsAndPackages() ...
[10:30:52.538] Searching for globals...
[10:30:52.538] 
[10:30:52.538] Searching for globals ... DONE
[10:30:52.538] - globals: [0] <none>
[10:30:52.538] getGlobalsAndPackages() ... DONE
[10:30:52.538]    + additional globals found: [n=0] 
[10:30:52.538]    + additional namespaces needed: [n=0] 
[10:30:52.538]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:52.538]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:52.539]  - seeds: <none>
[10:30:52.539]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.539] getGlobalsAndPackages() ...
[10:30:52.539] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.539] Resolving globals: FALSE
[10:30:52.539] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:52.540] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:52.540] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.540] 
[10:30:52.540] getGlobalsAndPackages() ... DONE
[10:30:52.540] run() for ‘Future’ ...
[10:30:52.541] - state: ‘created’
[10:30:52.541] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:52.555] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:52.555]   - Field: ‘node’
[10:30:52.555]   - Field: ‘label’
[10:30:52.555]   - Field: ‘local’
[10:30:52.555]   - Field: ‘owner’
[10:30:52.555]   - Field: ‘envir’
[10:30:52.555]   - Field: ‘workers’
[10:30:52.555]   - Field: ‘packages’
[10:30:52.556]   - Field: ‘gc’
[10:30:52.556]   - Field: ‘conditions’
[10:30:52.556]   - Field: ‘persistent’
[10:30:52.556]   - Field: ‘expr’
[10:30:52.556]   - Field: ‘uuid’
[10:30:52.556]   - Field: ‘seed’
[10:30:52.556]   - Field: ‘version’
[10:30:52.556]   - Field: ‘result’
[10:30:52.556]   - Field: ‘asynchronous’
[10:30:52.556]   - Field: ‘calls’
[10:30:52.556]   - Field: ‘globals’
[10:30:52.557]   - Field: ‘stdout’
[10:30:52.557]   - Field: ‘earlySignal’
[10:30:52.557]   - Field: ‘lazy’
[10:30:52.557]   - Field: ‘state’
[10:30:52.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:52.557] - Launch lazy future ...
[10:30:52.557] Packages needed by the future expression (n = 0): <none>
[10:30:52.557] Packages needed by future strategies (n = 0): <none>
[10:30:52.558] {
[10:30:52.558]     {
[10:30:52.558]         {
[10:30:52.558]             ...future.startTime <- base::Sys.time()
[10:30:52.558]             {
[10:30:52.558]                 {
[10:30:52.558]                   {
[10:30:52.558]                     {
[10:30:52.558]                       base::local({
[10:30:52.558]                         has_future <- base::requireNamespace("future", 
[10:30:52.558]                           quietly = TRUE)
[10:30:52.558]                         if (has_future) {
[10:30:52.558]                           ns <- base::getNamespace("future")
[10:30:52.558]                           version <- ns[[".package"]][["version"]]
[10:30:52.558]                           if (is.null(version)) 
[10:30:52.558]                             version <- utils::packageVersion("future")
[10:30:52.558]                         }
[10:30:52.558]                         else {
[10:30:52.558]                           version <- NULL
[10:30:52.558]                         }
[10:30:52.558]                         if (!has_future || version < "1.8.0") {
[10:30:52.558]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:52.558]                             "", base::R.version$version.string), 
[10:30:52.558]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:52.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:52.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:52.558]                               "release", "version")], collapse = " "), 
[10:30:52.558]                             hostname = base::Sys.info()[["nodename"]])
[10:30:52.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:52.558]                             info)
[10:30:52.558]                           info <- base::paste(info, collapse = "; ")
[10:30:52.558]                           if (!has_future) {
[10:30:52.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:52.558]                               info)
[10:30:52.558]                           }
[10:30:52.558]                           else {
[10:30:52.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:52.558]                               info, version)
[10:30:52.558]                           }
[10:30:52.558]                           base::stop(msg)
[10:30:52.558]                         }
[10:30:52.558]                       })
[10:30:52.558]                     }
[10:30:52.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:52.558]                     base::options(mc.cores = 1L)
[10:30:52.558]                   }
[10:30:52.558]                   ...future.strategy.old <- future::plan("list")
[10:30:52.558]                   options(future.plan = NULL)
[10:30:52.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:52.558]                 }
[10:30:52.558]                 ...future.workdir <- getwd()
[10:30:52.558]             }
[10:30:52.558]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:52.558]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:52.558]         }
[10:30:52.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:52.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:52.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:52.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:52.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:52.558]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:52.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:52.558]             base::names(...future.oldOptions))
[10:30:52.558]     }
[10:30:52.558]     if (FALSE) {
[10:30:52.558]     }
[10:30:52.558]     else {
[10:30:52.558]         if (TRUE) {
[10:30:52.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:52.558]                 open = "w")
[10:30:52.558]         }
[10:30:52.558]         else {
[10:30:52.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:52.558]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:52.558]         }
[10:30:52.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:52.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:52.558]             base::sink(type = "output", split = FALSE)
[10:30:52.558]             base::close(...future.stdout)
[10:30:52.558]         }, add = TRUE)
[10:30:52.558]     }
[10:30:52.558]     ...future.frame <- base::sys.nframe()
[10:30:52.558]     ...future.conditions <- base::list()
[10:30:52.558]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:52.558]     if (FALSE) {
[10:30:52.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:52.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:52.558]     }
[10:30:52.558]     ...future.result <- base::tryCatch({
[10:30:52.558]         base::withCallingHandlers({
[10:30:52.558]             ...future.value <- base::withVisible(base::local({
[10:30:52.558]                 ...future.makeSendCondition <- base::local({
[10:30:52.558]                   sendCondition <- NULL
[10:30:52.558]                   function(frame = 1L) {
[10:30:52.558]                     if (is.function(sendCondition)) 
[10:30:52.558]                       return(sendCondition)
[10:30:52.558]                     ns <- getNamespace("parallel")
[10:30:52.558]                     if (exists("sendData", mode = "function", 
[10:30:52.558]                       envir = ns)) {
[10:30:52.558]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:52.558]                         envir = ns)
[10:30:52.558]                       envir <- sys.frame(frame)
[10:30:52.558]                       master <- NULL
[10:30:52.558]                       while (!identical(envir, .GlobalEnv) && 
[10:30:52.558]                         !identical(envir, emptyenv())) {
[10:30:52.558]                         if (exists("master", mode = "list", envir = envir, 
[10:30:52.558]                           inherits = FALSE)) {
[10:30:52.558]                           master <- get("master", mode = "list", 
[10:30:52.558]                             envir = envir, inherits = FALSE)
[10:30:52.558]                           if (inherits(master, c("SOCKnode", 
[10:30:52.558]                             "SOCK0node"))) {
[10:30:52.558]                             sendCondition <<- function(cond) {
[10:30:52.558]                               data <- list(type = "VALUE", value = cond, 
[10:30:52.558]                                 success = TRUE)
[10:30:52.558]                               parallel_sendData(master, data)
[10:30:52.558]                             }
[10:30:52.558]                             return(sendCondition)
[10:30:52.558]                           }
[10:30:52.558]                         }
[10:30:52.558]                         frame <- frame + 1L
[10:30:52.558]                         envir <- sys.frame(frame)
[10:30:52.558]                       }
[10:30:52.558]                     }
[10:30:52.558]                     sendCondition <<- function(cond) NULL
[10:30:52.558]                   }
[10:30:52.558]                 })
[10:30:52.558]                 withCallingHandlers({
[10:30:52.558]                   {
[10:30:52.558]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.558]                     if (!identical(...future.globals.maxSize.org, 
[10:30:52.558]                       ...future.globals.maxSize)) {
[10:30:52.558]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.558]                       on.exit(options(oopts), add = TRUE)
[10:30:52.558]                     }
[10:30:52.558]                     {
[10:30:52.558]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.558]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:52.558]                         USE.NAMES = FALSE)
[10:30:52.558]                       do.call(mapply, args = args)
[10:30:52.558]                     }
[10:30:52.558]                   }
[10:30:52.558]                 }, immediateCondition = function(cond) {
[10:30:52.558]                   sendCondition <- ...future.makeSendCondition()
[10:30:52.558]                   sendCondition(cond)
[10:30:52.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.558]                   {
[10:30:52.558]                     inherits <- base::inherits
[10:30:52.558]                     invokeRestart <- base::invokeRestart
[10:30:52.558]                     is.null <- base::is.null
[10:30:52.558]                     muffled <- FALSE
[10:30:52.558]                     if (inherits(cond, "message")) {
[10:30:52.558]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:52.558]                       if (muffled) 
[10:30:52.558]                         invokeRestart("muffleMessage")
[10:30:52.558]                     }
[10:30:52.558]                     else if (inherits(cond, "warning")) {
[10:30:52.558]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:52.558]                       if (muffled) 
[10:30:52.558]                         invokeRestart("muffleWarning")
[10:30:52.558]                     }
[10:30:52.558]                     else if (inherits(cond, "condition")) {
[10:30:52.558]                       if (!is.null(pattern)) {
[10:30:52.558]                         computeRestarts <- base::computeRestarts
[10:30:52.558]                         grepl <- base::grepl
[10:30:52.558]                         restarts <- computeRestarts(cond)
[10:30:52.558]                         for (restart in restarts) {
[10:30:52.558]                           name <- restart$name
[10:30:52.558]                           if (is.null(name)) 
[10:30:52.558]                             next
[10:30:52.558]                           if (!grepl(pattern, name)) 
[10:30:52.558]                             next
[10:30:52.558]                           invokeRestart(restart)
[10:30:52.558]                           muffled <- TRUE
[10:30:52.558]                           break
[10:30:52.558]                         }
[10:30:52.558]                       }
[10:30:52.558]                     }
[10:30:52.558]                     invisible(muffled)
[10:30:52.558]                   }
[10:30:52.558]                   muffleCondition(cond)
[10:30:52.558]                 })
[10:30:52.558]             }))
[10:30:52.558]             future::FutureResult(value = ...future.value$value, 
[10:30:52.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.558]                   ...future.rng), globalenv = if (FALSE) 
[10:30:52.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:52.558]                     ...future.globalenv.names))
[10:30:52.558]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:52.558]         }, condition = base::local({
[10:30:52.558]             c <- base::c
[10:30:52.558]             inherits <- base::inherits
[10:30:52.558]             invokeRestart <- base::invokeRestart
[10:30:52.558]             length <- base::length
[10:30:52.558]             list <- base::list
[10:30:52.558]             seq.int <- base::seq.int
[10:30:52.558]             signalCondition <- base::signalCondition
[10:30:52.558]             sys.calls <- base::sys.calls
[10:30:52.558]             `[[` <- base::`[[`
[10:30:52.558]             `+` <- base::`+`
[10:30:52.558]             `<<-` <- base::`<<-`
[10:30:52.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:52.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:52.558]                   3L)]
[10:30:52.558]             }
[10:30:52.558]             function(cond) {
[10:30:52.558]                 is_error <- inherits(cond, "error")
[10:30:52.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:52.558]                   NULL)
[10:30:52.558]                 if (is_error) {
[10:30:52.558]                   sessionInformation <- function() {
[10:30:52.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:52.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:52.558]                       search = base::search(), system = base::Sys.info())
[10:30:52.558]                   }
[10:30:52.558]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:52.558]                     cond$call), session = sessionInformation(), 
[10:30:52.558]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:52.558]                   signalCondition(cond)
[10:30:52.558]                 }
[10:30:52.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:52.558]                 "immediateCondition"))) {
[10:30:52.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:52.558]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:52.558]                   if (TRUE && !signal) {
[10:30:52.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.558]                     {
[10:30:52.558]                       inherits <- base::inherits
[10:30:52.558]                       invokeRestart <- base::invokeRestart
[10:30:52.558]                       is.null <- base::is.null
[10:30:52.558]                       muffled <- FALSE
[10:30:52.558]                       if (inherits(cond, "message")) {
[10:30:52.558]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.558]                         if (muffled) 
[10:30:52.558]                           invokeRestart("muffleMessage")
[10:30:52.558]                       }
[10:30:52.558]                       else if (inherits(cond, "warning")) {
[10:30:52.558]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.558]                         if (muffled) 
[10:30:52.558]                           invokeRestart("muffleWarning")
[10:30:52.558]                       }
[10:30:52.558]                       else if (inherits(cond, "condition")) {
[10:30:52.558]                         if (!is.null(pattern)) {
[10:30:52.558]                           computeRestarts <- base::computeRestarts
[10:30:52.558]                           grepl <- base::grepl
[10:30:52.558]                           restarts <- computeRestarts(cond)
[10:30:52.558]                           for (restart in restarts) {
[10:30:52.558]                             name <- restart$name
[10:30:52.558]                             if (is.null(name)) 
[10:30:52.558]                               next
[10:30:52.558]                             if (!grepl(pattern, name)) 
[10:30:52.558]                               next
[10:30:52.558]                             invokeRestart(restart)
[10:30:52.558]                             muffled <- TRUE
[10:30:52.558]                             break
[10:30:52.558]                           }
[10:30:52.558]                         }
[10:30:52.558]                       }
[10:30:52.558]                       invisible(muffled)
[10:30:52.558]                     }
[10:30:52.558]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.558]                   }
[10:30:52.558]                 }
[10:30:52.558]                 else {
[10:30:52.558]                   if (TRUE) {
[10:30:52.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.558]                     {
[10:30:52.558]                       inherits <- base::inherits
[10:30:52.558]                       invokeRestart <- base::invokeRestart
[10:30:52.558]                       is.null <- base::is.null
[10:30:52.558]                       muffled <- FALSE
[10:30:52.558]                       if (inherits(cond, "message")) {
[10:30:52.558]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.558]                         if (muffled) 
[10:30:52.558]                           invokeRestart("muffleMessage")
[10:30:52.558]                       }
[10:30:52.558]                       else if (inherits(cond, "warning")) {
[10:30:52.558]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.558]                         if (muffled) 
[10:30:52.558]                           invokeRestart("muffleWarning")
[10:30:52.558]                       }
[10:30:52.558]                       else if (inherits(cond, "condition")) {
[10:30:52.558]                         if (!is.null(pattern)) {
[10:30:52.558]                           computeRestarts <- base::computeRestarts
[10:30:52.558]                           grepl <- base::grepl
[10:30:52.558]                           restarts <- computeRestarts(cond)
[10:30:52.558]                           for (restart in restarts) {
[10:30:52.558]                             name <- restart$name
[10:30:52.558]                             if (is.null(name)) 
[10:30:52.558]                               next
[10:30:52.558]                             if (!grepl(pattern, name)) 
[10:30:52.558]                               next
[10:30:52.558]                             invokeRestart(restart)
[10:30:52.558]                             muffled <- TRUE
[10:30:52.558]                             break
[10:30:52.558]                           }
[10:30:52.558]                         }
[10:30:52.558]                       }
[10:30:52.558]                       invisible(muffled)
[10:30:52.558]                     }
[10:30:52.558]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.558]                   }
[10:30:52.558]                 }
[10:30:52.558]             }
[10:30:52.558]         }))
[10:30:52.558]     }, error = function(ex) {
[10:30:52.558]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:52.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.558]                 ...future.rng), started = ...future.startTime, 
[10:30:52.558]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:52.558]             version = "1.8"), class = "FutureResult")
[10:30:52.558]     }, finally = {
[10:30:52.558]         if (!identical(...future.workdir, getwd())) 
[10:30:52.558]             setwd(...future.workdir)
[10:30:52.558]         {
[10:30:52.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:52.558]                 ...future.oldOptions$nwarnings <- NULL
[10:30:52.558]             }
[10:30:52.558]             base::options(...future.oldOptions)
[10:30:52.558]             if (.Platform$OS.type == "windows") {
[10:30:52.558]                 old_names <- names(...future.oldEnvVars)
[10:30:52.558]                 envs <- base::Sys.getenv()
[10:30:52.558]                 names <- names(envs)
[10:30:52.558]                 common <- intersect(names, old_names)
[10:30:52.558]                 added <- setdiff(names, old_names)
[10:30:52.558]                 removed <- setdiff(old_names, names)
[10:30:52.558]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:52.558]                   envs[common]]
[10:30:52.558]                 NAMES <- toupper(changed)
[10:30:52.558]                 args <- list()
[10:30:52.558]                 for (kk in seq_along(NAMES)) {
[10:30:52.558]                   name <- changed[[kk]]
[10:30:52.558]                   NAME <- NAMES[[kk]]
[10:30:52.558]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.558]                     next
[10:30:52.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.558]                 }
[10:30:52.558]                 NAMES <- toupper(added)
[10:30:52.558]                 for (kk in seq_along(NAMES)) {
[10:30:52.558]                   name <- added[[kk]]
[10:30:52.558]                   NAME <- NAMES[[kk]]
[10:30:52.558]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.558]                     next
[10:30:52.558]                   args[[name]] <- ""
[10:30:52.558]                 }
[10:30:52.558]                 NAMES <- toupper(removed)
[10:30:52.558]                 for (kk in seq_along(NAMES)) {
[10:30:52.558]                   name <- removed[[kk]]
[10:30:52.558]                   NAME <- NAMES[[kk]]
[10:30:52.558]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.558]                     next
[10:30:52.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.558]                 }
[10:30:52.558]                 if (length(args) > 0) 
[10:30:52.558]                   base::do.call(base::Sys.setenv, args = args)
[10:30:52.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:52.558]             }
[10:30:52.558]             else {
[10:30:52.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:52.558]             }
[10:30:52.558]             {
[10:30:52.558]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:52.558]                   0L) {
[10:30:52.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:52.558]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:52.558]                   base::options(opts)
[10:30:52.558]                 }
[10:30:52.558]                 {
[10:30:52.558]                   {
[10:30:52.558]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:52.558]                     NULL
[10:30:52.558]                   }
[10:30:52.558]                   options(future.plan = NULL)
[10:30:52.558]                   if (is.na(NA_character_)) 
[10:30:52.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:52.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:52.558]                     .init = FALSE)
[10:30:52.558]                 }
[10:30:52.558]             }
[10:30:52.558]         }
[10:30:52.558]     })
[10:30:52.558]     if (TRUE) {
[10:30:52.558]         base::sink(type = "output", split = FALSE)
[10:30:52.558]         if (TRUE) {
[10:30:52.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:52.558]         }
[10:30:52.558]         else {
[10:30:52.558]             ...future.result["stdout"] <- base::list(NULL)
[10:30:52.558]         }
[10:30:52.558]         base::close(...future.stdout)
[10:30:52.558]         ...future.stdout <- NULL
[10:30:52.558]     }
[10:30:52.558]     ...future.result$conditions <- ...future.conditions
[10:30:52.558]     ...future.result$finished <- base::Sys.time()
[10:30:52.558]     ...future.result
[10:30:52.558] }
[10:30:52.561] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[10:30:52.561] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[10:30:52.561] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[10:30:52.561] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:52.562] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:52.562] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[10:30:52.562] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[10:30:52.562] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:52.563] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:52.563] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:52.563] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:52.563] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[10:30:52.564] MultisessionFuture started
[10:30:52.564] - Launch lazy future ... done
[10:30:52.564] run() for ‘MultisessionFuture’ ... done
[10:30:52.564] Created future:
[10:30:52.564] MultisessionFuture:
[10:30:52.564] Label: ‘future_mapply-1’
[10:30:52.564] Expression:
[10:30:52.564] {
[10:30:52.564]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.564]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:52.564]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.564]         on.exit(options(oopts), add = TRUE)
[10:30:52.564]     }
[10:30:52.564]     {
[10:30:52.564]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.564]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:52.564]         do.call(mapply, args = args)
[10:30:52.564]     }
[10:30:52.564] }
[10:30:52.564] Lazy evaluation: FALSE
[10:30:52.564] Asynchronous evaluation: TRUE
[10:30:52.564] Local evaluation: TRUE
[10:30:52.564] Environment: R_GlobalEnv
[10:30:52.564] Capture standard output: TRUE
[10:30:52.564] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:52.564] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:52.564] Packages: <none>
[10:30:52.564] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:52.564] Resolved: FALSE
[10:30:52.564] Value: <not collected>
[10:30:52.564] Conditions captured: <none>
[10:30:52.564] Early signaling: FALSE
[10:30:52.564] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:52.564] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.576] Chunk #1 of 2 ... DONE
[10:30:52.576] Chunk #2 of 2 ...
[10:30:52.576]  - Finding globals in '...' for chunk #2 ...
[10:30:52.576] getGlobalsAndPackages() ...
[10:30:52.577] Searching for globals...
[10:30:52.577] 
[10:30:52.577] Searching for globals ... DONE
[10:30:52.577] - globals: [0] <none>
[10:30:52.577] getGlobalsAndPackages() ... DONE
[10:30:52.577]    + additional globals found: [n=0] 
[10:30:52.577]    + additional namespaces needed: [n=0] 
[10:30:52.577]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:52.578]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:52.578]  - seeds: <none>
[10:30:52.578]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.578] getGlobalsAndPackages() ...
[10:30:52.578] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.578] Resolving globals: FALSE
[10:30:52.579] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:52.579] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:52.579] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.579] 
[10:30:52.579] getGlobalsAndPackages() ... DONE
[10:30:52.580] run() for ‘Future’ ...
[10:30:52.580] - state: ‘created’
[10:30:52.580] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:52.595] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.595] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:52.595]   - Field: ‘node’
[10:30:52.595]   - Field: ‘label’
[10:30:52.595]   - Field: ‘local’
[10:30:52.595]   - Field: ‘owner’
[10:30:52.595]   - Field: ‘envir’
[10:30:52.595]   - Field: ‘workers’
[10:30:52.596]   - Field: ‘packages’
[10:30:52.596]   - Field: ‘gc’
[10:30:52.596]   - Field: ‘conditions’
[10:30:52.596]   - Field: ‘persistent’
[10:30:52.596]   - Field: ‘expr’
[10:30:52.596]   - Field: ‘uuid’
[10:30:52.596]   - Field: ‘seed’
[10:30:52.596]   - Field: ‘version’
[10:30:52.596]   - Field: ‘result’
[10:30:52.596]   - Field: ‘asynchronous’
[10:30:52.596]   - Field: ‘calls’
[10:30:52.597]   - Field: ‘globals’
[10:30:52.597]   - Field: ‘stdout’
[10:30:52.597]   - Field: ‘earlySignal’
[10:30:52.597]   - Field: ‘lazy’
[10:30:52.597]   - Field: ‘state’
[10:30:52.597] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:52.597] - Launch lazy future ...
[10:30:52.597] Packages needed by the future expression (n = 0): <none>
[10:30:52.598] Packages needed by future strategies (n = 0): <none>
[10:30:52.598] {
[10:30:52.598]     {
[10:30:52.598]         {
[10:30:52.598]             ...future.startTime <- base::Sys.time()
[10:30:52.598]             {
[10:30:52.598]                 {
[10:30:52.598]                   {
[10:30:52.598]                     {
[10:30:52.598]                       base::local({
[10:30:52.598]                         has_future <- base::requireNamespace("future", 
[10:30:52.598]                           quietly = TRUE)
[10:30:52.598]                         if (has_future) {
[10:30:52.598]                           ns <- base::getNamespace("future")
[10:30:52.598]                           version <- ns[[".package"]][["version"]]
[10:30:52.598]                           if (is.null(version)) 
[10:30:52.598]                             version <- utils::packageVersion("future")
[10:30:52.598]                         }
[10:30:52.598]                         else {
[10:30:52.598]                           version <- NULL
[10:30:52.598]                         }
[10:30:52.598]                         if (!has_future || version < "1.8.0") {
[10:30:52.598]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:52.598]                             "", base::R.version$version.string), 
[10:30:52.598]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:52.598]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:52.598]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:52.598]                               "release", "version")], collapse = " "), 
[10:30:52.598]                             hostname = base::Sys.info()[["nodename"]])
[10:30:52.598]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:52.598]                             info)
[10:30:52.598]                           info <- base::paste(info, collapse = "; ")
[10:30:52.598]                           if (!has_future) {
[10:30:52.598]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:52.598]                               info)
[10:30:52.598]                           }
[10:30:52.598]                           else {
[10:30:52.598]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:52.598]                               info, version)
[10:30:52.598]                           }
[10:30:52.598]                           base::stop(msg)
[10:30:52.598]                         }
[10:30:52.598]                       })
[10:30:52.598]                     }
[10:30:52.598]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:52.598]                     base::options(mc.cores = 1L)
[10:30:52.598]                   }
[10:30:52.598]                   ...future.strategy.old <- future::plan("list")
[10:30:52.598]                   options(future.plan = NULL)
[10:30:52.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:52.598]                 }
[10:30:52.598]                 ...future.workdir <- getwd()
[10:30:52.598]             }
[10:30:52.598]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:52.598]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:52.598]         }
[10:30:52.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:52.598]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:52.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:52.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:52.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:52.598]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:52.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:52.598]             base::names(...future.oldOptions))
[10:30:52.598]     }
[10:30:52.598]     if (FALSE) {
[10:30:52.598]     }
[10:30:52.598]     else {
[10:30:52.598]         if (TRUE) {
[10:30:52.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:52.598]                 open = "w")
[10:30:52.598]         }
[10:30:52.598]         else {
[10:30:52.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:52.598]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:52.598]         }
[10:30:52.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:52.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:52.598]             base::sink(type = "output", split = FALSE)
[10:30:52.598]             base::close(...future.stdout)
[10:30:52.598]         }, add = TRUE)
[10:30:52.598]     }
[10:30:52.598]     ...future.frame <- base::sys.nframe()
[10:30:52.598]     ...future.conditions <- base::list()
[10:30:52.598]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:52.598]     if (FALSE) {
[10:30:52.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:52.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:52.598]     }
[10:30:52.598]     ...future.result <- base::tryCatch({
[10:30:52.598]         base::withCallingHandlers({
[10:30:52.598]             ...future.value <- base::withVisible(base::local({
[10:30:52.598]                 ...future.makeSendCondition <- base::local({
[10:30:52.598]                   sendCondition <- NULL
[10:30:52.598]                   function(frame = 1L) {
[10:30:52.598]                     if (is.function(sendCondition)) 
[10:30:52.598]                       return(sendCondition)
[10:30:52.598]                     ns <- getNamespace("parallel")
[10:30:52.598]                     if (exists("sendData", mode = "function", 
[10:30:52.598]                       envir = ns)) {
[10:30:52.598]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:52.598]                         envir = ns)
[10:30:52.598]                       envir <- sys.frame(frame)
[10:30:52.598]                       master <- NULL
[10:30:52.598]                       while (!identical(envir, .GlobalEnv) && 
[10:30:52.598]                         !identical(envir, emptyenv())) {
[10:30:52.598]                         if (exists("master", mode = "list", envir = envir, 
[10:30:52.598]                           inherits = FALSE)) {
[10:30:52.598]                           master <- get("master", mode = "list", 
[10:30:52.598]                             envir = envir, inherits = FALSE)
[10:30:52.598]                           if (inherits(master, c("SOCKnode", 
[10:30:52.598]                             "SOCK0node"))) {
[10:30:52.598]                             sendCondition <<- function(cond) {
[10:30:52.598]                               data <- list(type = "VALUE", value = cond, 
[10:30:52.598]                                 success = TRUE)
[10:30:52.598]                               parallel_sendData(master, data)
[10:30:52.598]                             }
[10:30:52.598]                             return(sendCondition)
[10:30:52.598]                           }
[10:30:52.598]                         }
[10:30:52.598]                         frame <- frame + 1L
[10:30:52.598]                         envir <- sys.frame(frame)
[10:30:52.598]                       }
[10:30:52.598]                     }
[10:30:52.598]                     sendCondition <<- function(cond) NULL
[10:30:52.598]                   }
[10:30:52.598]                 })
[10:30:52.598]                 withCallingHandlers({
[10:30:52.598]                   {
[10:30:52.598]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.598]                     if (!identical(...future.globals.maxSize.org, 
[10:30:52.598]                       ...future.globals.maxSize)) {
[10:30:52.598]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.598]                       on.exit(options(oopts), add = TRUE)
[10:30:52.598]                     }
[10:30:52.598]                     {
[10:30:52.598]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.598]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:52.598]                         USE.NAMES = FALSE)
[10:30:52.598]                       do.call(mapply, args = args)
[10:30:52.598]                     }
[10:30:52.598]                   }
[10:30:52.598]                 }, immediateCondition = function(cond) {
[10:30:52.598]                   sendCondition <- ...future.makeSendCondition()
[10:30:52.598]                   sendCondition(cond)
[10:30:52.598]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.598]                   {
[10:30:52.598]                     inherits <- base::inherits
[10:30:52.598]                     invokeRestart <- base::invokeRestart
[10:30:52.598]                     is.null <- base::is.null
[10:30:52.598]                     muffled <- FALSE
[10:30:52.598]                     if (inherits(cond, "message")) {
[10:30:52.598]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:52.598]                       if (muffled) 
[10:30:52.598]                         invokeRestart("muffleMessage")
[10:30:52.598]                     }
[10:30:52.598]                     else if (inherits(cond, "warning")) {
[10:30:52.598]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:52.598]                       if (muffled) 
[10:30:52.598]                         invokeRestart("muffleWarning")
[10:30:52.598]                     }
[10:30:52.598]                     else if (inherits(cond, "condition")) {
[10:30:52.598]                       if (!is.null(pattern)) {
[10:30:52.598]                         computeRestarts <- base::computeRestarts
[10:30:52.598]                         grepl <- base::grepl
[10:30:52.598]                         restarts <- computeRestarts(cond)
[10:30:52.598]                         for (restart in restarts) {
[10:30:52.598]                           name <- restart$name
[10:30:52.598]                           if (is.null(name)) 
[10:30:52.598]                             next
[10:30:52.598]                           if (!grepl(pattern, name)) 
[10:30:52.598]                             next
[10:30:52.598]                           invokeRestart(restart)
[10:30:52.598]                           muffled <- TRUE
[10:30:52.598]                           break
[10:30:52.598]                         }
[10:30:52.598]                       }
[10:30:52.598]                     }
[10:30:52.598]                     invisible(muffled)
[10:30:52.598]                   }
[10:30:52.598]                   muffleCondition(cond)
[10:30:52.598]                 })
[10:30:52.598]             }))
[10:30:52.598]             future::FutureResult(value = ...future.value$value, 
[10:30:52.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.598]                   ...future.rng), globalenv = if (FALSE) 
[10:30:52.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:52.598]                     ...future.globalenv.names))
[10:30:52.598]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:52.598]         }, condition = base::local({
[10:30:52.598]             c <- base::c
[10:30:52.598]             inherits <- base::inherits
[10:30:52.598]             invokeRestart <- base::invokeRestart
[10:30:52.598]             length <- base::length
[10:30:52.598]             list <- base::list
[10:30:52.598]             seq.int <- base::seq.int
[10:30:52.598]             signalCondition <- base::signalCondition
[10:30:52.598]             sys.calls <- base::sys.calls
[10:30:52.598]             `[[` <- base::`[[`
[10:30:52.598]             `+` <- base::`+`
[10:30:52.598]             `<<-` <- base::`<<-`
[10:30:52.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:52.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:52.598]                   3L)]
[10:30:52.598]             }
[10:30:52.598]             function(cond) {
[10:30:52.598]                 is_error <- inherits(cond, "error")
[10:30:52.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:52.598]                   NULL)
[10:30:52.598]                 if (is_error) {
[10:30:52.598]                   sessionInformation <- function() {
[10:30:52.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:52.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:52.598]                       search = base::search(), system = base::Sys.info())
[10:30:52.598]                   }
[10:30:52.598]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:52.598]                     cond$call), session = sessionInformation(), 
[10:30:52.598]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:52.598]                   signalCondition(cond)
[10:30:52.598]                 }
[10:30:52.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:52.598]                 "immediateCondition"))) {
[10:30:52.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:52.598]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:52.598]                   if (TRUE && !signal) {
[10:30:52.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.598]                     {
[10:30:52.598]                       inherits <- base::inherits
[10:30:52.598]                       invokeRestart <- base::invokeRestart
[10:30:52.598]                       is.null <- base::is.null
[10:30:52.598]                       muffled <- FALSE
[10:30:52.598]                       if (inherits(cond, "message")) {
[10:30:52.598]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.598]                         if (muffled) 
[10:30:52.598]                           invokeRestart("muffleMessage")
[10:30:52.598]                       }
[10:30:52.598]                       else if (inherits(cond, "warning")) {
[10:30:52.598]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.598]                         if (muffled) 
[10:30:52.598]                           invokeRestart("muffleWarning")
[10:30:52.598]                       }
[10:30:52.598]                       else if (inherits(cond, "condition")) {
[10:30:52.598]                         if (!is.null(pattern)) {
[10:30:52.598]                           computeRestarts <- base::computeRestarts
[10:30:52.598]                           grepl <- base::grepl
[10:30:52.598]                           restarts <- computeRestarts(cond)
[10:30:52.598]                           for (restart in restarts) {
[10:30:52.598]                             name <- restart$name
[10:30:52.598]                             if (is.null(name)) 
[10:30:52.598]                               next
[10:30:52.598]                             if (!grepl(pattern, name)) 
[10:30:52.598]                               next
[10:30:52.598]                             invokeRestart(restart)
[10:30:52.598]                             muffled <- TRUE
[10:30:52.598]                             break
[10:30:52.598]                           }
[10:30:52.598]                         }
[10:30:52.598]                       }
[10:30:52.598]                       invisible(muffled)
[10:30:52.598]                     }
[10:30:52.598]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.598]                   }
[10:30:52.598]                 }
[10:30:52.598]                 else {
[10:30:52.598]                   if (TRUE) {
[10:30:52.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.598]                     {
[10:30:52.598]                       inherits <- base::inherits
[10:30:52.598]                       invokeRestart <- base::invokeRestart
[10:30:52.598]                       is.null <- base::is.null
[10:30:52.598]                       muffled <- FALSE
[10:30:52.598]                       if (inherits(cond, "message")) {
[10:30:52.598]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.598]                         if (muffled) 
[10:30:52.598]                           invokeRestart("muffleMessage")
[10:30:52.598]                       }
[10:30:52.598]                       else if (inherits(cond, "warning")) {
[10:30:52.598]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.598]                         if (muffled) 
[10:30:52.598]                           invokeRestart("muffleWarning")
[10:30:52.598]                       }
[10:30:52.598]                       else if (inherits(cond, "condition")) {
[10:30:52.598]                         if (!is.null(pattern)) {
[10:30:52.598]                           computeRestarts <- base::computeRestarts
[10:30:52.598]                           grepl <- base::grepl
[10:30:52.598]                           restarts <- computeRestarts(cond)
[10:30:52.598]                           for (restart in restarts) {
[10:30:52.598]                             name <- restart$name
[10:30:52.598]                             if (is.null(name)) 
[10:30:52.598]                               next
[10:30:52.598]                             if (!grepl(pattern, name)) 
[10:30:52.598]                               next
[10:30:52.598]                             invokeRestart(restart)
[10:30:52.598]                             muffled <- TRUE
[10:30:52.598]                             break
[10:30:52.598]                           }
[10:30:52.598]                         }
[10:30:52.598]                       }
[10:30:52.598]                       invisible(muffled)
[10:30:52.598]                     }
[10:30:52.598]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.598]                   }
[10:30:52.598]                 }
[10:30:52.598]             }
[10:30:52.598]         }))
[10:30:52.598]     }, error = function(ex) {
[10:30:52.598]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:52.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.598]                 ...future.rng), started = ...future.startTime, 
[10:30:52.598]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:52.598]             version = "1.8"), class = "FutureResult")
[10:30:52.598]     }, finally = {
[10:30:52.598]         if (!identical(...future.workdir, getwd())) 
[10:30:52.598]             setwd(...future.workdir)
[10:30:52.598]         {
[10:30:52.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:52.598]                 ...future.oldOptions$nwarnings <- NULL
[10:30:52.598]             }
[10:30:52.598]             base::options(...future.oldOptions)
[10:30:52.598]             if (.Platform$OS.type == "windows") {
[10:30:52.598]                 old_names <- names(...future.oldEnvVars)
[10:30:52.598]                 envs <- base::Sys.getenv()
[10:30:52.598]                 names <- names(envs)
[10:30:52.598]                 common <- intersect(names, old_names)
[10:30:52.598]                 added <- setdiff(names, old_names)
[10:30:52.598]                 removed <- setdiff(old_names, names)
[10:30:52.598]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:52.598]                   envs[common]]
[10:30:52.598]                 NAMES <- toupper(changed)
[10:30:52.598]                 args <- list()
[10:30:52.598]                 for (kk in seq_along(NAMES)) {
[10:30:52.598]                   name <- changed[[kk]]
[10:30:52.598]                   NAME <- NAMES[[kk]]
[10:30:52.598]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.598]                     next
[10:30:52.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.598]                 }
[10:30:52.598]                 NAMES <- toupper(added)
[10:30:52.598]                 for (kk in seq_along(NAMES)) {
[10:30:52.598]                   name <- added[[kk]]
[10:30:52.598]                   NAME <- NAMES[[kk]]
[10:30:52.598]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.598]                     next
[10:30:52.598]                   args[[name]] <- ""
[10:30:52.598]                 }
[10:30:52.598]                 NAMES <- toupper(removed)
[10:30:52.598]                 for (kk in seq_along(NAMES)) {
[10:30:52.598]                   name <- removed[[kk]]
[10:30:52.598]                   NAME <- NAMES[[kk]]
[10:30:52.598]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.598]                     next
[10:30:52.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.598]                 }
[10:30:52.598]                 if (length(args) > 0) 
[10:30:52.598]                   base::do.call(base::Sys.setenv, args = args)
[10:30:52.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:52.598]             }
[10:30:52.598]             else {
[10:30:52.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:52.598]             }
[10:30:52.598]             {
[10:30:52.598]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:52.598]                   0L) {
[10:30:52.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:52.598]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:52.598]                   base::options(opts)
[10:30:52.598]                 }
[10:30:52.598]                 {
[10:30:52.598]                   {
[10:30:52.598]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:52.598]                     NULL
[10:30:52.598]                   }
[10:30:52.598]                   options(future.plan = NULL)
[10:30:52.598]                   if (is.na(NA_character_)) 
[10:30:52.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:52.598]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:52.598]                     .init = FALSE)
[10:30:52.598]                 }
[10:30:52.598]             }
[10:30:52.598]         }
[10:30:52.598]     })
[10:30:52.598]     if (TRUE) {
[10:30:52.598]         base::sink(type = "output", split = FALSE)
[10:30:52.598]         if (TRUE) {
[10:30:52.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:52.598]         }
[10:30:52.598]         else {
[10:30:52.598]             ...future.result["stdout"] <- base::list(NULL)
[10:30:52.598]         }
[10:30:52.598]         base::close(...future.stdout)
[10:30:52.598]         ...future.stdout <- NULL
[10:30:52.598]     }
[10:30:52.598]     ...future.result$conditions <- ...future.conditions
[10:30:52.598]     ...future.result$finished <- base::Sys.time()
[10:30:52.598]     ...future.result
[10:30:52.598] }
[10:30:52.651] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[10:30:52.651] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[10:30:52.652] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[10:30:52.652] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:52.652] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:52.653] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[10:30:52.653] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[10:30:52.653] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:52.654] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:52.654] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:52.654] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:52.654] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[10:30:52.655] MultisessionFuture started
[10:30:52.655] - Launch lazy future ... done
[10:30:52.655] run() for ‘MultisessionFuture’ ... done
[10:30:52.655] Created future:
[10:30:52.655] MultisessionFuture:
[10:30:52.655] Label: ‘future_mapply-2’
[10:30:52.655] Expression:
[10:30:52.655] {
[10:30:52.655]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.655]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:52.655]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.655]         on.exit(options(oopts), add = TRUE)
[10:30:52.655]     }
[10:30:52.655]     {
[10:30:52.655]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.655]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:52.655]         do.call(mapply, args = args)
[10:30:52.655]     }
[10:30:52.655] }
[10:30:52.655] Lazy evaluation: FALSE
[10:30:52.655] Asynchronous evaluation: TRUE
[10:30:52.655] Local evaluation: TRUE
[10:30:52.655] Environment: R_GlobalEnv
[10:30:52.655] Capture standard output: TRUE
[10:30:52.655] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:52.655] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:52.655] Packages: <none>
[10:30:52.655] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:52.655] Resolved: FALSE
[10:30:52.655] Value: <not collected>
[10:30:52.655] Conditions captured: <none>
[10:30:52.655] Early signaling: FALSE
[10:30:52.655] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:52.655] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.667] Chunk #2 of 2 ... DONE
[10:30:52.667] Launching 2 futures (chunks) ... DONE
[10:30:52.667] Resolving 2 futures (chunks) ...
[10:30:52.667] resolve() on list ...
[10:30:52.667]  recursive: 0
[10:30:52.668]  length: 2
[10:30:52.668] 
[10:30:52.668] receiveMessageFromWorker() for ClusterFuture ...
[10:30:52.668] - Validating connection of MultisessionFuture
[10:30:52.669] - received message: FutureResult
[10:30:52.669] - Received FutureResult
[10:30:52.669] - Erased future from FutureRegistry
[10:30:52.669] result() for ClusterFuture ...
[10:30:52.669] - result already collected: FutureResult
[10:30:52.669] result() for ClusterFuture ... done
[10:30:52.669] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:52.669] Future #1
[10:30:52.669] result() for ClusterFuture ...
[10:30:52.670] - result already collected: FutureResult
[10:30:52.670] result() for ClusterFuture ... done
[10:30:52.670] result() for ClusterFuture ...
[10:30:52.670] - result already collected: FutureResult
[10:30:52.670] result() for ClusterFuture ... done
[10:30:52.670] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:52.670] - nx: 2
[10:30:52.670] - relay: TRUE
[10:30:52.670] - stdout: TRUE
[10:30:52.670] - signal: TRUE
[10:30:52.670] - resignal: FALSE
[10:30:52.671] - force: TRUE
[10:30:52.671] - relayed: [n=2] FALSE, FALSE
[10:30:52.671] - queued futures: [n=2] FALSE, FALSE
[10:30:52.671]  - until=1
[10:30:52.671]  - relaying element #1
[10:30:52.671] result() for ClusterFuture ...
[10:30:52.673] - result already collected: FutureResult
[10:30:52.673] result() for ClusterFuture ... done
[10:30:52.674] result() for ClusterFuture ...
[10:30:52.674] - result already collected: FutureResult
[10:30:52.674] result() for ClusterFuture ... done
[10:30:52.674] result() for ClusterFuture ...
[10:30:52.674] - result already collected: FutureResult
[10:30:52.674] result() for ClusterFuture ... done
[10:30:52.674] result() for ClusterFuture ...
[10:30:52.674] - result already collected: FutureResult
[10:30:52.674] result() for ClusterFuture ... done
[10:30:52.674] - relayed: [n=2] TRUE, FALSE
[10:30:52.674] - queued futures: [n=2] TRUE, FALSE
[10:30:52.675] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:52.675]  length: 1 (resolved future 1)
[10:30:52.738] receiveMessageFromWorker() for ClusterFuture ...
[10:30:52.738] - Validating connection of MultisessionFuture
[10:30:52.738] - received message: FutureResult
[10:30:52.738] - Received FutureResult
[10:30:52.738] - Erased future from FutureRegistry
[10:30:52.738] result() for ClusterFuture ...
[10:30:52.739] - result already collected: FutureResult
[10:30:52.739] result() for ClusterFuture ... done
[10:30:52.739] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:52.739] Future #2
[10:30:52.739] result() for ClusterFuture ...
[10:30:52.739] - result already collected: FutureResult
[10:30:52.739] result() for ClusterFuture ... done
[10:30:52.739] result() for ClusterFuture ...
[10:30:52.739] - result already collected: FutureResult
[10:30:52.739] result() for ClusterFuture ... done
[10:30:52.739] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:52.740] - nx: 2
[10:30:52.740] - relay: TRUE
[10:30:52.740] - stdout: TRUE
[10:30:52.740] - signal: TRUE
[10:30:52.740] - resignal: FALSE
[10:30:52.740] - force: TRUE
[10:30:52.740] - relayed: [n=2] TRUE, FALSE
[10:30:52.740] - queued futures: [n=2] TRUE, FALSE
[10:30:52.740]  - until=2
[10:30:52.740]  - relaying element #2
[10:30:52.740] result() for ClusterFuture ...
[10:30:52.740] - result already collected: FutureResult
[10:30:52.741] result() for ClusterFuture ... done
[10:30:52.741] result() for ClusterFuture ...
[10:30:52.741] - result already collected: FutureResult
[10:30:52.741] result() for ClusterFuture ... done
[10:30:52.741] result() for ClusterFuture ...
[10:30:52.741] - result already collected: FutureResult
[10:30:52.741] result() for ClusterFuture ... done
[10:30:52.741] result() for ClusterFuture ...
[10:30:52.741] - result already collected: FutureResult
[10:30:52.741] result() for ClusterFuture ... done
[10:30:52.742] - relayed: [n=2] TRUE, TRUE
[10:30:52.742] - queued futures: [n=2] TRUE, TRUE
[10:30:52.742] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:52.742]  length: 0 (resolved future 2)
[10:30:52.742] Relaying remaining futures
[10:30:52.742] signalConditionsASAP(NULL, pos=0) ...
[10:30:52.742] - nx: 2
[10:30:52.742] - relay: TRUE
[10:30:52.742] - stdout: TRUE
[10:30:52.742] - signal: TRUE
[10:30:52.742] - resignal: FALSE
[10:30:52.742] - force: TRUE
[10:30:52.742] - relayed: [n=2] TRUE, TRUE
[10:30:52.743] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:52.743] - relayed: [n=2] TRUE, TRUE
[10:30:52.743] - queued futures: [n=2] TRUE, TRUE
[10:30:52.743] signalConditionsASAP(NULL, pos=0) ... done
[10:30:52.743] resolve() on list ... DONE
[10:30:52.743] result() for ClusterFuture ...
[10:30:52.743] - result already collected: FutureResult
[10:30:52.743] result() for ClusterFuture ... done
[10:30:52.743] result() for ClusterFuture ...
[10:30:52.743] - result already collected: FutureResult
[10:30:52.743] result() for ClusterFuture ... done
[10:30:52.744] result() for ClusterFuture ...
[10:30:52.744] - result already collected: FutureResult
[10:30:52.744] result() for ClusterFuture ... done
[10:30:52.744] result() for ClusterFuture ...
[10:30:52.744] - result already collected: FutureResult
[10:30:52.744] result() for ClusterFuture ... done
[10:30:52.744]  - Number of value chunks collected: 2
[10:30:52.744] Resolving 2 futures (chunks) ... DONE
[10:30:52.744] Reducing values from 2 chunks ...
[10:30:52.744]  - Number of values collected after concatenation: 4
[10:30:52.744]  - Number of values expected: 4
[10:30:52.745] Reducing values from 2 chunks ... DONE
[10:30:52.745] future_mapply() ... DONE
[10:30:52.745] future_mapply() ...
[10:30:52.749] Number of chunks: 2
[10:30:52.749] getGlobalsAndPackagesXApply() ...
[10:30:52.749]  - future.globals: TRUE
[10:30:52.749] getGlobalsAndPackages() ...
[10:30:52.749] Searching for globals...
[10:30:52.750] - globals found: [1] ‘FUN’
[10:30:52.750] Searching for globals ... DONE
[10:30:52.750] Resolving globals: FALSE
[10:30:52.750] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:52.750] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:52.751] - globals: [1] ‘FUN’
[10:30:52.751] 
[10:30:52.751] getGlobalsAndPackages() ... DONE
[10:30:52.751]  - globals found/used: [n=1] ‘FUN’
[10:30:52.751]  - needed namespaces: [n=0] 
[10:30:52.751] Finding globals ... DONE
[10:30:52.751] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:52.751] List of 2
[10:30:52.751]  $ ...future.FUN:function (x, ...)  
[10:30:52.751]  $ MoreArgs     : NULL
[10:30:52.751]  - attr(*, "where")=List of 2
[10:30:52.751]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:52.751]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:52.751]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:52.751]  - attr(*, "resolved")= logi FALSE
[10:30:52.751]  - attr(*, "total_size")= num NA
[10:30:52.754] Packages to be attached in all futures: [n=0] 
[10:30:52.754] getGlobalsAndPackagesXApply() ... DONE
[10:30:52.754] Number of futures (= number of chunks): 2
[10:30:52.754] Launching 2 futures (chunks) ...
[10:30:52.754] Chunk #1 of 2 ...
[10:30:52.754]  - Finding globals in '...' for chunk #1 ...
[10:30:52.755] getGlobalsAndPackages() ...
[10:30:52.755] Searching for globals...
[10:30:52.755] 
[10:30:52.755] Searching for globals ... DONE
[10:30:52.755] - globals: [0] <none>
[10:30:52.755] getGlobalsAndPackages() ... DONE
[10:30:52.755]    + additional globals found: [n=0] 
[10:30:52.755]    + additional namespaces needed: [n=0] 
[10:30:52.755]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:52.756]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:52.756]  - seeds: <none>
[10:30:52.756]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.756] getGlobalsAndPackages() ...
[10:30:52.756] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.756] Resolving globals: FALSE
[10:30:52.756] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:52.757] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:52.757] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.757] 
[10:30:52.757] getGlobalsAndPackages() ... DONE
[10:30:52.758] run() for ‘Future’ ...
[10:30:52.758] - state: ‘created’
[10:30:52.758] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:52.771] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.772] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:52.772]   - Field: ‘node’
[10:30:52.772]   - Field: ‘label’
[10:30:52.772]   - Field: ‘local’
[10:30:52.772]   - Field: ‘owner’
[10:30:52.772]   - Field: ‘envir’
[10:30:52.772]   - Field: ‘workers’
[10:30:52.772]   - Field: ‘packages’
[10:30:52.772]   - Field: ‘gc’
[10:30:52.772]   - Field: ‘conditions’
[10:30:52.773]   - Field: ‘persistent’
[10:30:52.773]   - Field: ‘expr’
[10:30:52.773]   - Field: ‘uuid’
[10:30:52.773]   - Field: ‘seed’
[10:30:52.773]   - Field: ‘version’
[10:30:52.773]   - Field: ‘result’
[10:30:52.773]   - Field: ‘asynchronous’
[10:30:52.773]   - Field: ‘calls’
[10:30:52.773]   - Field: ‘globals’
[10:30:52.773]   - Field: ‘stdout’
[10:30:52.773]   - Field: ‘earlySignal’
[10:30:52.774]   - Field: ‘lazy’
[10:30:52.774]   - Field: ‘state’
[10:30:52.774] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:52.774] - Launch lazy future ...
[10:30:52.774] Packages needed by the future expression (n = 0): <none>
[10:30:52.774] Packages needed by future strategies (n = 0): <none>
[10:30:52.775] {
[10:30:52.775]     {
[10:30:52.775]         {
[10:30:52.775]             ...future.startTime <- base::Sys.time()
[10:30:52.775]             {
[10:30:52.775]                 {
[10:30:52.775]                   {
[10:30:52.775]                     {
[10:30:52.775]                       base::local({
[10:30:52.775]                         has_future <- base::requireNamespace("future", 
[10:30:52.775]                           quietly = TRUE)
[10:30:52.775]                         if (has_future) {
[10:30:52.775]                           ns <- base::getNamespace("future")
[10:30:52.775]                           version <- ns[[".package"]][["version"]]
[10:30:52.775]                           if (is.null(version)) 
[10:30:52.775]                             version <- utils::packageVersion("future")
[10:30:52.775]                         }
[10:30:52.775]                         else {
[10:30:52.775]                           version <- NULL
[10:30:52.775]                         }
[10:30:52.775]                         if (!has_future || version < "1.8.0") {
[10:30:52.775]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:52.775]                             "", base::R.version$version.string), 
[10:30:52.775]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:52.775]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:52.775]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:52.775]                               "release", "version")], collapse = " "), 
[10:30:52.775]                             hostname = base::Sys.info()[["nodename"]])
[10:30:52.775]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:52.775]                             info)
[10:30:52.775]                           info <- base::paste(info, collapse = "; ")
[10:30:52.775]                           if (!has_future) {
[10:30:52.775]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:52.775]                               info)
[10:30:52.775]                           }
[10:30:52.775]                           else {
[10:30:52.775]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:52.775]                               info, version)
[10:30:52.775]                           }
[10:30:52.775]                           base::stop(msg)
[10:30:52.775]                         }
[10:30:52.775]                       })
[10:30:52.775]                     }
[10:30:52.775]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:52.775]                     base::options(mc.cores = 1L)
[10:30:52.775]                   }
[10:30:52.775]                   ...future.strategy.old <- future::plan("list")
[10:30:52.775]                   options(future.plan = NULL)
[10:30:52.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:52.775]                 }
[10:30:52.775]                 ...future.workdir <- getwd()
[10:30:52.775]             }
[10:30:52.775]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:52.775]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:52.775]         }
[10:30:52.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:52.775]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:52.775]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:52.775]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:52.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:52.775]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:52.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:52.775]             base::names(...future.oldOptions))
[10:30:52.775]     }
[10:30:52.775]     if (FALSE) {
[10:30:52.775]     }
[10:30:52.775]     else {
[10:30:52.775]         if (TRUE) {
[10:30:52.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:52.775]                 open = "w")
[10:30:52.775]         }
[10:30:52.775]         else {
[10:30:52.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:52.775]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:52.775]         }
[10:30:52.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:52.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:52.775]             base::sink(type = "output", split = FALSE)
[10:30:52.775]             base::close(...future.stdout)
[10:30:52.775]         }, add = TRUE)
[10:30:52.775]     }
[10:30:52.775]     ...future.frame <- base::sys.nframe()
[10:30:52.775]     ...future.conditions <- base::list()
[10:30:52.775]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:52.775]     if (FALSE) {
[10:30:52.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:52.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:52.775]     }
[10:30:52.775]     ...future.result <- base::tryCatch({
[10:30:52.775]         base::withCallingHandlers({
[10:30:52.775]             ...future.value <- base::withVisible(base::local({
[10:30:52.775]                 ...future.makeSendCondition <- base::local({
[10:30:52.775]                   sendCondition <- NULL
[10:30:52.775]                   function(frame = 1L) {
[10:30:52.775]                     if (is.function(sendCondition)) 
[10:30:52.775]                       return(sendCondition)
[10:30:52.775]                     ns <- getNamespace("parallel")
[10:30:52.775]                     if (exists("sendData", mode = "function", 
[10:30:52.775]                       envir = ns)) {
[10:30:52.775]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:52.775]                         envir = ns)
[10:30:52.775]                       envir <- sys.frame(frame)
[10:30:52.775]                       master <- NULL
[10:30:52.775]                       while (!identical(envir, .GlobalEnv) && 
[10:30:52.775]                         !identical(envir, emptyenv())) {
[10:30:52.775]                         if (exists("master", mode = "list", envir = envir, 
[10:30:52.775]                           inherits = FALSE)) {
[10:30:52.775]                           master <- get("master", mode = "list", 
[10:30:52.775]                             envir = envir, inherits = FALSE)
[10:30:52.775]                           if (inherits(master, c("SOCKnode", 
[10:30:52.775]                             "SOCK0node"))) {
[10:30:52.775]                             sendCondition <<- function(cond) {
[10:30:52.775]                               data <- list(type = "VALUE", value = cond, 
[10:30:52.775]                                 success = TRUE)
[10:30:52.775]                               parallel_sendData(master, data)
[10:30:52.775]                             }
[10:30:52.775]                             return(sendCondition)
[10:30:52.775]                           }
[10:30:52.775]                         }
[10:30:52.775]                         frame <- frame + 1L
[10:30:52.775]                         envir <- sys.frame(frame)
[10:30:52.775]                       }
[10:30:52.775]                     }
[10:30:52.775]                     sendCondition <<- function(cond) NULL
[10:30:52.775]                   }
[10:30:52.775]                 })
[10:30:52.775]                 withCallingHandlers({
[10:30:52.775]                   {
[10:30:52.775]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.775]                     if (!identical(...future.globals.maxSize.org, 
[10:30:52.775]                       ...future.globals.maxSize)) {
[10:30:52.775]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.775]                       on.exit(options(oopts), add = TRUE)
[10:30:52.775]                     }
[10:30:52.775]                     {
[10:30:52.775]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.775]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:52.775]                         USE.NAMES = FALSE)
[10:30:52.775]                       do.call(mapply, args = args)
[10:30:52.775]                     }
[10:30:52.775]                   }
[10:30:52.775]                 }, immediateCondition = function(cond) {
[10:30:52.775]                   sendCondition <- ...future.makeSendCondition()
[10:30:52.775]                   sendCondition(cond)
[10:30:52.775]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.775]                   {
[10:30:52.775]                     inherits <- base::inherits
[10:30:52.775]                     invokeRestart <- base::invokeRestart
[10:30:52.775]                     is.null <- base::is.null
[10:30:52.775]                     muffled <- FALSE
[10:30:52.775]                     if (inherits(cond, "message")) {
[10:30:52.775]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:52.775]                       if (muffled) 
[10:30:52.775]                         invokeRestart("muffleMessage")
[10:30:52.775]                     }
[10:30:52.775]                     else if (inherits(cond, "warning")) {
[10:30:52.775]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:52.775]                       if (muffled) 
[10:30:52.775]                         invokeRestart("muffleWarning")
[10:30:52.775]                     }
[10:30:52.775]                     else if (inherits(cond, "condition")) {
[10:30:52.775]                       if (!is.null(pattern)) {
[10:30:52.775]                         computeRestarts <- base::computeRestarts
[10:30:52.775]                         grepl <- base::grepl
[10:30:52.775]                         restarts <- computeRestarts(cond)
[10:30:52.775]                         for (restart in restarts) {
[10:30:52.775]                           name <- restart$name
[10:30:52.775]                           if (is.null(name)) 
[10:30:52.775]                             next
[10:30:52.775]                           if (!grepl(pattern, name)) 
[10:30:52.775]                             next
[10:30:52.775]                           invokeRestart(restart)
[10:30:52.775]                           muffled <- TRUE
[10:30:52.775]                           break
[10:30:52.775]                         }
[10:30:52.775]                       }
[10:30:52.775]                     }
[10:30:52.775]                     invisible(muffled)
[10:30:52.775]                   }
[10:30:52.775]                   muffleCondition(cond)
[10:30:52.775]                 })
[10:30:52.775]             }))
[10:30:52.775]             future::FutureResult(value = ...future.value$value, 
[10:30:52.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.775]                   ...future.rng), globalenv = if (FALSE) 
[10:30:52.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:52.775]                     ...future.globalenv.names))
[10:30:52.775]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:52.775]         }, condition = base::local({
[10:30:52.775]             c <- base::c
[10:30:52.775]             inherits <- base::inherits
[10:30:52.775]             invokeRestart <- base::invokeRestart
[10:30:52.775]             length <- base::length
[10:30:52.775]             list <- base::list
[10:30:52.775]             seq.int <- base::seq.int
[10:30:52.775]             signalCondition <- base::signalCondition
[10:30:52.775]             sys.calls <- base::sys.calls
[10:30:52.775]             `[[` <- base::`[[`
[10:30:52.775]             `+` <- base::`+`
[10:30:52.775]             `<<-` <- base::`<<-`
[10:30:52.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:52.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:52.775]                   3L)]
[10:30:52.775]             }
[10:30:52.775]             function(cond) {
[10:30:52.775]                 is_error <- inherits(cond, "error")
[10:30:52.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:52.775]                   NULL)
[10:30:52.775]                 if (is_error) {
[10:30:52.775]                   sessionInformation <- function() {
[10:30:52.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:52.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:52.775]                       search = base::search(), system = base::Sys.info())
[10:30:52.775]                   }
[10:30:52.775]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:52.775]                     cond$call), session = sessionInformation(), 
[10:30:52.775]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:52.775]                   signalCondition(cond)
[10:30:52.775]                 }
[10:30:52.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:52.775]                 "immediateCondition"))) {
[10:30:52.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:52.775]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:52.775]                   if (TRUE && !signal) {
[10:30:52.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.775]                     {
[10:30:52.775]                       inherits <- base::inherits
[10:30:52.775]                       invokeRestart <- base::invokeRestart
[10:30:52.775]                       is.null <- base::is.null
[10:30:52.775]                       muffled <- FALSE
[10:30:52.775]                       if (inherits(cond, "message")) {
[10:30:52.775]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.775]                         if (muffled) 
[10:30:52.775]                           invokeRestart("muffleMessage")
[10:30:52.775]                       }
[10:30:52.775]                       else if (inherits(cond, "warning")) {
[10:30:52.775]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.775]                         if (muffled) 
[10:30:52.775]                           invokeRestart("muffleWarning")
[10:30:52.775]                       }
[10:30:52.775]                       else if (inherits(cond, "condition")) {
[10:30:52.775]                         if (!is.null(pattern)) {
[10:30:52.775]                           computeRestarts <- base::computeRestarts
[10:30:52.775]                           grepl <- base::grepl
[10:30:52.775]                           restarts <- computeRestarts(cond)
[10:30:52.775]                           for (restart in restarts) {
[10:30:52.775]                             name <- restart$name
[10:30:52.775]                             if (is.null(name)) 
[10:30:52.775]                               next
[10:30:52.775]                             if (!grepl(pattern, name)) 
[10:30:52.775]                               next
[10:30:52.775]                             invokeRestart(restart)
[10:30:52.775]                             muffled <- TRUE
[10:30:52.775]                             break
[10:30:52.775]                           }
[10:30:52.775]                         }
[10:30:52.775]                       }
[10:30:52.775]                       invisible(muffled)
[10:30:52.775]                     }
[10:30:52.775]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.775]                   }
[10:30:52.775]                 }
[10:30:52.775]                 else {
[10:30:52.775]                   if (TRUE) {
[10:30:52.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.775]                     {
[10:30:52.775]                       inherits <- base::inherits
[10:30:52.775]                       invokeRestart <- base::invokeRestart
[10:30:52.775]                       is.null <- base::is.null
[10:30:52.775]                       muffled <- FALSE
[10:30:52.775]                       if (inherits(cond, "message")) {
[10:30:52.775]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.775]                         if (muffled) 
[10:30:52.775]                           invokeRestart("muffleMessage")
[10:30:52.775]                       }
[10:30:52.775]                       else if (inherits(cond, "warning")) {
[10:30:52.775]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.775]                         if (muffled) 
[10:30:52.775]                           invokeRestart("muffleWarning")
[10:30:52.775]                       }
[10:30:52.775]                       else if (inherits(cond, "condition")) {
[10:30:52.775]                         if (!is.null(pattern)) {
[10:30:52.775]                           computeRestarts <- base::computeRestarts
[10:30:52.775]                           grepl <- base::grepl
[10:30:52.775]                           restarts <- computeRestarts(cond)
[10:30:52.775]                           for (restart in restarts) {
[10:30:52.775]                             name <- restart$name
[10:30:52.775]                             if (is.null(name)) 
[10:30:52.775]                               next
[10:30:52.775]                             if (!grepl(pattern, name)) 
[10:30:52.775]                               next
[10:30:52.775]                             invokeRestart(restart)
[10:30:52.775]                             muffled <- TRUE
[10:30:52.775]                             break
[10:30:52.775]                           }
[10:30:52.775]                         }
[10:30:52.775]                       }
[10:30:52.775]                       invisible(muffled)
[10:30:52.775]                     }
[10:30:52.775]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.775]                   }
[10:30:52.775]                 }
[10:30:52.775]             }
[10:30:52.775]         }))
[10:30:52.775]     }, error = function(ex) {
[10:30:52.775]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:52.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.775]                 ...future.rng), started = ...future.startTime, 
[10:30:52.775]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:52.775]             version = "1.8"), class = "FutureResult")
[10:30:52.775]     }, finally = {
[10:30:52.775]         if (!identical(...future.workdir, getwd())) 
[10:30:52.775]             setwd(...future.workdir)
[10:30:52.775]         {
[10:30:52.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:52.775]                 ...future.oldOptions$nwarnings <- NULL
[10:30:52.775]             }
[10:30:52.775]             base::options(...future.oldOptions)
[10:30:52.775]             if (.Platform$OS.type == "windows") {
[10:30:52.775]                 old_names <- names(...future.oldEnvVars)
[10:30:52.775]                 envs <- base::Sys.getenv()
[10:30:52.775]                 names <- names(envs)
[10:30:52.775]                 common <- intersect(names, old_names)
[10:30:52.775]                 added <- setdiff(names, old_names)
[10:30:52.775]                 removed <- setdiff(old_names, names)
[10:30:52.775]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:52.775]                   envs[common]]
[10:30:52.775]                 NAMES <- toupper(changed)
[10:30:52.775]                 args <- list()
[10:30:52.775]                 for (kk in seq_along(NAMES)) {
[10:30:52.775]                   name <- changed[[kk]]
[10:30:52.775]                   NAME <- NAMES[[kk]]
[10:30:52.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.775]                     next
[10:30:52.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.775]                 }
[10:30:52.775]                 NAMES <- toupper(added)
[10:30:52.775]                 for (kk in seq_along(NAMES)) {
[10:30:52.775]                   name <- added[[kk]]
[10:30:52.775]                   NAME <- NAMES[[kk]]
[10:30:52.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.775]                     next
[10:30:52.775]                   args[[name]] <- ""
[10:30:52.775]                 }
[10:30:52.775]                 NAMES <- toupper(removed)
[10:30:52.775]                 for (kk in seq_along(NAMES)) {
[10:30:52.775]                   name <- removed[[kk]]
[10:30:52.775]                   NAME <- NAMES[[kk]]
[10:30:52.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.775]                     next
[10:30:52.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.775]                 }
[10:30:52.775]                 if (length(args) > 0) 
[10:30:52.775]                   base::do.call(base::Sys.setenv, args = args)
[10:30:52.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:52.775]             }
[10:30:52.775]             else {
[10:30:52.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:52.775]             }
[10:30:52.775]             {
[10:30:52.775]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:52.775]                   0L) {
[10:30:52.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:52.775]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:52.775]                   base::options(opts)
[10:30:52.775]                 }
[10:30:52.775]                 {
[10:30:52.775]                   {
[10:30:52.775]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:52.775]                     NULL
[10:30:52.775]                   }
[10:30:52.775]                   options(future.plan = NULL)
[10:30:52.775]                   if (is.na(NA_character_)) 
[10:30:52.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:52.775]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:52.775]                     .init = FALSE)
[10:30:52.775]                 }
[10:30:52.775]             }
[10:30:52.775]         }
[10:30:52.775]     })
[10:30:52.775]     if (TRUE) {
[10:30:52.775]         base::sink(type = "output", split = FALSE)
[10:30:52.775]         if (TRUE) {
[10:30:52.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:52.775]         }
[10:30:52.775]         else {
[10:30:52.775]             ...future.result["stdout"] <- base::list(NULL)
[10:30:52.775]         }
[10:30:52.775]         base::close(...future.stdout)
[10:30:52.775]         ...future.stdout <- NULL
[10:30:52.775]     }
[10:30:52.775]     ...future.result$conditions <- ...future.conditions
[10:30:52.775]     ...future.result$finished <- base::Sys.time()
[10:30:52.775]     ...future.result
[10:30:52.775] }
[10:30:52.777] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[10:30:52.778] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[10:30:52.778] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[10:30:52.778] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:52.779] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:52.779] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[10:30:52.779] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[10:30:52.779] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:52.779] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:52.780] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:52.780] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:52.780] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[10:30:52.780] MultisessionFuture started
[10:30:52.781] - Launch lazy future ... done
[10:30:52.781] run() for ‘MultisessionFuture’ ... done
[10:30:52.781] Created future:
[10:30:52.781] MultisessionFuture:
[10:30:52.781] Label: ‘future_mapply-1’
[10:30:52.781] Expression:
[10:30:52.781] {
[10:30:52.781]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.781]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:52.781]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.781]         on.exit(options(oopts), add = TRUE)
[10:30:52.781]     }
[10:30:52.781]     {
[10:30:52.781]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.781]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:52.781]         do.call(mapply, args = args)
[10:30:52.781]     }
[10:30:52.781] }
[10:30:52.781] Lazy evaluation: FALSE
[10:30:52.781] Asynchronous evaluation: TRUE
[10:30:52.781] Local evaluation: TRUE
[10:30:52.781] Environment: R_GlobalEnv
[10:30:52.781] Capture standard output: TRUE
[10:30:52.781] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:52.781] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:52.781] Packages: <none>
[10:30:52.781] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:52.781] Resolved: FALSE
[10:30:52.781] Value: <not collected>
[10:30:52.781] Conditions captured: <none>
[10:30:52.781] Early signaling: FALSE
[10:30:52.781] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:52.781] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.792] Chunk #1 of 2 ... DONE
[10:30:52.792] Chunk #2 of 2 ...
[10:30:52.793]  - Finding globals in '...' for chunk #2 ...
[10:30:52.793] getGlobalsAndPackages() ...
[10:30:52.793] Searching for globals...
[10:30:52.793] 
[10:30:52.793] Searching for globals ... DONE
[10:30:52.793] - globals: [0] <none>
[10:30:52.794] getGlobalsAndPackages() ... DONE
[10:30:52.794]    + additional globals found: [n=0] 
[10:30:52.794]    + additional namespaces needed: [n=0] 
[10:30:52.794]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:52.794]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:52.794]  - seeds: <none>
[10:30:52.794]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.794] getGlobalsAndPackages() ...
[10:30:52.794] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.794] Resolving globals: FALSE
[10:30:52.795] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:52.795] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:52.795] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.796] 
[10:30:52.796] getGlobalsAndPackages() ... DONE
[10:30:52.796] run() for ‘Future’ ...
[10:30:52.796] - state: ‘created’
[10:30:52.796] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:52.810] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:52.810]   - Field: ‘node’
[10:30:52.810]   - Field: ‘label’
[10:30:52.811]   - Field: ‘local’
[10:30:52.811]   - Field: ‘owner’
[10:30:52.811]   - Field: ‘envir’
[10:30:52.811]   - Field: ‘workers’
[10:30:52.811]   - Field: ‘packages’
[10:30:52.811]   - Field: ‘gc’
[10:30:52.811]   - Field: ‘conditions’
[10:30:52.811]   - Field: ‘persistent’
[10:30:52.811]   - Field: ‘expr’
[10:30:52.811]   - Field: ‘uuid’
[10:30:52.811]   - Field: ‘seed’
[10:30:52.812]   - Field: ‘version’
[10:30:52.812]   - Field: ‘result’
[10:30:52.812]   - Field: ‘asynchronous’
[10:30:52.812]   - Field: ‘calls’
[10:30:52.812]   - Field: ‘globals’
[10:30:52.812]   - Field: ‘stdout’
[10:30:52.812]   - Field: ‘earlySignal’
[10:30:52.812]   - Field: ‘lazy’
[10:30:52.812]   - Field: ‘state’
[10:30:52.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:52.812] - Launch lazy future ...
[10:30:52.813] Packages needed by the future expression (n = 0): <none>
[10:30:52.813] Packages needed by future strategies (n = 0): <none>
[10:30:52.813] {
[10:30:52.813]     {
[10:30:52.813]         {
[10:30:52.813]             ...future.startTime <- base::Sys.time()
[10:30:52.813]             {
[10:30:52.813]                 {
[10:30:52.813]                   {
[10:30:52.813]                     {
[10:30:52.813]                       base::local({
[10:30:52.813]                         has_future <- base::requireNamespace("future", 
[10:30:52.813]                           quietly = TRUE)
[10:30:52.813]                         if (has_future) {
[10:30:52.813]                           ns <- base::getNamespace("future")
[10:30:52.813]                           version <- ns[[".package"]][["version"]]
[10:30:52.813]                           if (is.null(version)) 
[10:30:52.813]                             version <- utils::packageVersion("future")
[10:30:52.813]                         }
[10:30:52.813]                         else {
[10:30:52.813]                           version <- NULL
[10:30:52.813]                         }
[10:30:52.813]                         if (!has_future || version < "1.8.0") {
[10:30:52.813]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:52.813]                             "", base::R.version$version.string), 
[10:30:52.813]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:52.813]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:52.813]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:52.813]                               "release", "version")], collapse = " "), 
[10:30:52.813]                             hostname = base::Sys.info()[["nodename"]])
[10:30:52.813]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:52.813]                             info)
[10:30:52.813]                           info <- base::paste(info, collapse = "; ")
[10:30:52.813]                           if (!has_future) {
[10:30:52.813]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:52.813]                               info)
[10:30:52.813]                           }
[10:30:52.813]                           else {
[10:30:52.813]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:52.813]                               info, version)
[10:30:52.813]                           }
[10:30:52.813]                           base::stop(msg)
[10:30:52.813]                         }
[10:30:52.813]                       })
[10:30:52.813]                     }
[10:30:52.813]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:52.813]                     base::options(mc.cores = 1L)
[10:30:52.813]                   }
[10:30:52.813]                   ...future.strategy.old <- future::plan("list")
[10:30:52.813]                   options(future.plan = NULL)
[10:30:52.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:52.813]                 }
[10:30:52.813]                 ...future.workdir <- getwd()
[10:30:52.813]             }
[10:30:52.813]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:52.813]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:52.813]         }
[10:30:52.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:52.813]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:52.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:52.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:52.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:52.813]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:52.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:52.813]             base::names(...future.oldOptions))
[10:30:52.813]     }
[10:30:52.813]     if (FALSE) {
[10:30:52.813]     }
[10:30:52.813]     else {
[10:30:52.813]         if (TRUE) {
[10:30:52.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:52.813]                 open = "w")
[10:30:52.813]         }
[10:30:52.813]         else {
[10:30:52.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:52.813]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:52.813]         }
[10:30:52.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:52.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:52.813]             base::sink(type = "output", split = FALSE)
[10:30:52.813]             base::close(...future.stdout)
[10:30:52.813]         }, add = TRUE)
[10:30:52.813]     }
[10:30:52.813]     ...future.frame <- base::sys.nframe()
[10:30:52.813]     ...future.conditions <- base::list()
[10:30:52.813]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:52.813]     if (FALSE) {
[10:30:52.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:52.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:52.813]     }
[10:30:52.813]     ...future.result <- base::tryCatch({
[10:30:52.813]         base::withCallingHandlers({
[10:30:52.813]             ...future.value <- base::withVisible(base::local({
[10:30:52.813]                 ...future.makeSendCondition <- base::local({
[10:30:52.813]                   sendCondition <- NULL
[10:30:52.813]                   function(frame = 1L) {
[10:30:52.813]                     if (is.function(sendCondition)) 
[10:30:52.813]                       return(sendCondition)
[10:30:52.813]                     ns <- getNamespace("parallel")
[10:30:52.813]                     if (exists("sendData", mode = "function", 
[10:30:52.813]                       envir = ns)) {
[10:30:52.813]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:52.813]                         envir = ns)
[10:30:52.813]                       envir <- sys.frame(frame)
[10:30:52.813]                       master <- NULL
[10:30:52.813]                       while (!identical(envir, .GlobalEnv) && 
[10:30:52.813]                         !identical(envir, emptyenv())) {
[10:30:52.813]                         if (exists("master", mode = "list", envir = envir, 
[10:30:52.813]                           inherits = FALSE)) {
[10:30:52.813]                           master <- get("master", mode = "list", 
[10:30:52.813]                             envir = envir, inherits = FALSE)
[10:30:52.813]                           if (inherits(master, c("SOCKnode", 
[10:30:52.813]                             "SOCK0node"))) {
[10:30:52.813]                             sendCondition <<- function(cond) {
[10:30:52.813]                               data <- list(type = "VALUE", value = cond, 
[10:30:52.813]                                 success = TRUE)
[10:30:52.813]                               parallel_sendData(master, data)
[10:30:52.813]                             }
[10:30:52.813]                             return(sendCondition)
[10:30:52.813]                           }
[10:30:52.813]                         }
[10:30:52.813]                         frame <- frame + 1L
[10:30:52.813]                         envir <- sys.frame(frame)
[10:30:52.813]                       }
[10:30:52.813]                     }
[10:30:52.813]                     sendCondition <<- function(cond) NULL
[10:30:52.813]                   }
[10:30:52.813]                 })
[10:30:52.813]                 withCallingHandlers({
[10:30:52.813]                   {
[10:30:52.813]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.813]                     if (!identical(...future.globals.maxSize.org, 
[10:30:52.813]                       ...future.globals.maxSize)) {
[10:30:52.813]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.813]                       on.exit(options(oopts), add = TRUE)
[10:30:52.813]                     }
[10:30:52.813]                     {
[10:30:52.813]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.813]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:52.813]                         USE.NAMES = FALSE)
[10:30:52.813]                       do.call(mapply, args = args)
[10:30:52.813]                     }
[10:30:52.813]                   }
[10:30:52.813]                 }, immediateCondition = function(cond) {
[10:30:52.813]                   sendCondition <- ...future.makeSendCondition()
[10:30:52.813]                   sendCondition(cond)
[10:30:52.813]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.813]                   {
[10:30:52.813]                     inherits <- base::inherits
[10:30:52.813]                     invokeRestart <- base::invokeRestart
[10:30:52.813]                     is.null <- base::is.null
[10:30:52.813]                     muffled <- FALSE
[10:30:52.813]                     if (inherits(cond, "message")) {
[10:30:52.813]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:52.813]                       if (muffled) 
[10:30:52.813]                         invokeRestart("muffleMessage")
[10:30:52.813]                     }
[10:30:52.813]                     else if (inherits(cond, "warning")) {
[10:30:52.813]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:52.813]                       if (muffled) 
[10:30:52.813]                         invokeRestart("muffleWarning")
[10:30:52.813]                     }
[10:30:52.813]                     else if (inherits(cond, "condition")) {
[10:30:52.813]                       if (!is.null(pattern)) {
[10:30:52.813]                         computeRestarts <- base::computeRestarts
[10:30:52.813]                         grepl <- base::grepl
[10:30:52.813]                         restarts <- computeRestarts(cond)
[10:30:52.813]                         for (restart in restarts) {
[10:30:52.813]                           name <- restart$name
[10:30:52.813]                           if (is.null(name)) 
[10:30:52.813]                             next
[10:30:52.813]                           if (!grepl(pattern, name)) 
[10:30:52.813]                             next
[10:30:52.813]                           invokeRestart(restart)
[10:30:52.813]                           muffled <- TRUE
[10:30:52.813]                           break
[10:30:52.813]                         }
[10:30:52.813]                       }
[10:30:52.813]                     }
[10:30:52.813]                     invisible(muffled)
[10:30:52.813]                   }
[10:30:52.813]                   muffleCondition(cond)
[10:30:52.813]                 })
[10:30:52.813]             }))
[10:30:52.813]             future::FutureResult(value = ...future.value$value, 
[10:30:52.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.813]                   ...future.rng), globalenv = if (FALSE) 
[10:30:52.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:52.813]                     ...future.globalenv.names))
[10:30:52.813]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:52.813]         }, condition = base::local({
[10:30:52.813]             c <- base::c
[10:30:52.813]             inherits <- base::inherits
[10:30:52.813]             invokeRestart <- base::invokeRestart
[10:30:52.813]             length <- base::length
[10:30:52.813]             list <- base::list
[10:30:52.813]             seq.int <- base::seq.int
[10:30:52.813]             signalCondition <- base::signalCondition
[10:30:52.813]             sys.calls <- base::sys.calls
[10:30:52.813]             `[[` <- base::`[[`
[10:30:52.813]             `+` <- base::`+`
[10:30:52.813]             `<<-` <- base::`<<-`
[10:30:52.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:52.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:52.813]                   3L)]
[10:30:52.813]             }
[10:30:52.813]             function(cond) {
[10:30:52.813]                 is_error <- inherits(cond, "error")
[10:30:52.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:52.813]                   NULL)
[10:30:52.813]                 if (is_error) {
[10:30:52.813]                   sessionInformation <- function() {
[10:30:52.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:52.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:52.813]                       search = base::search(), system = base::Sys.info())
[10:30:52.813]                   }
[10:30:52.813]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:52.813]                     cond$call), session = sessionInformation(), 
[10:30:52.813]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:52.813]                   signalCondition(cond)
[10:30:52.813]                 }
[10:30:52.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:52.813]                 "immediateCondition"))) {
[10:30:52.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:52.813]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:52.813]                   if (TRUE && !signal) {
[10:30:52.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.813]                     {
[10:30:52.813]                       inherits <- base::inherits
[10:30:52.813]                       invokeRestart <- base::invokeRestart
[10:30:52.813]                       is.null <- base::is.null
[10:30:52.813]                       muffled <- FALSE
[10:30:52.813]                       if (inherits(cond, "message")) {
[10:30:52.813]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.813]                         if (muffled) 
[10:30:52.813]                           invokeRestart("muffleMessage")
[10:30:52.813]                       }
[10:30:52.813]                       else if (inherits(cond, "warning")) {
[10:30:52.813]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.813]                         if (muffled) 
[10:30:52.813]                           invokeRestart("muffleWarning")
[10:30:52.813]                       }
[10:30:52.813]                       else if (inherits(cond, "condition")) {
[10:30:52.813]                         if (!is.null(pattern)) {
[10:30:52.813]                           computeRestarts <- base::computeRestarts
[10:30:52.813]                           grepl <- base::grepl
[10:30:52.813]                           restarts <- computeRestarts(cond)
[10:30:52.813]                           for (restart in restarts) {
[10:30:52.813]                             name <- restart$name
[10:30:52.813]                             if (is.null(name)) 
[10:30:52.813]                               next
[10:30:52.813]                             if (!grepl(pattern, name)) 
[10:30:52.813]                               next
[10:30:52.813]                             invokeRestart(restart)
[10:30:52.813]                             muffled <- TRUE
[10:30:52.813]                             break
[10:30:52.813]                           }
[10:30:52.813]                         }
[10:30:52.813]                       }
[10:30:52.813]                       invisible(muffled)
[10:30:52.813]                     }
[10:30:52.813]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.813]                   }
[10:30:52.813]                 }
[10:30:52.813]                 else {
[10:30:52.813]                   if (TRUE) {
[10:30:52.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.813]                     {
[10:30:52.813]                       inherits <- base::inherits
[10:30:52.813]                       invokeRestart <- base::invokeRestart
[10:30:52.813]                       is.null <- base::is.null
[10:30:52.813]                       muffled <- FALSE
[10:30:52.813]                       if (inherits(cond, "message")) {
[10:30:52.813]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.813]                         if (muffled) 
[10:30:52.813]                           invokeRestart("muffleMessage")
[10:30:52.813]                       }
[10:30:52.813]                       else if (inherits(cond, "warning")) {
[10:30:52.813]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.813]                         if (muffled) 
[10:30:52.813]                           invokeRestart("muffleWarning")
[10:30:52.813]                       }
[10:30:52.813]                       else if (inherits(cond, "condition")) {
[10:30:52.813]                         if (!is.null(pattern)) {
[10:30:52.813]                           computeRestarts <- base::computeRestarts
[10:30:52.813]                           grepl <- base::grepl
[10:30:52.813]                           restarts <- computeRestarts(cond)
[10:30:52.813]                           for (restart in restarts) {
[10:30:52.813]                             name <- restart$name
[10:30:52.813]                             if (is.null(name)) 
[10:30:52.813]                               next
[10:30:52.813]                             if (!grepl(pattern, name)) 
[10:30:52.813]                               next
[10:30:52.813]                             invokeRestart(restart)
[10:30:52.813]                             muffled <- TRUE
[10:30:52.813]                             break
[10:30:52.813]                           }
[10:30:52.813]                         }
[10:30:52.813]                       }
[10:30:52.813]                       invisible(muffled)
[10:30:52.813]                     }
[10:30:52.813]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.813]                   }
[10:30:52.813]                 }
[10:30:52.813]             }
[10:30:52.813]         }))
[10:30:52.813]     }, error = function(ex) {
[10:30:52.813]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:52.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.813]                 ...future.rng), started = ...future.startTime, 
[10:30:52.813]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:52.813]             version = "1.8"), class = "FutureResult")
[10:30:52.813]     }, finally = {
[10:30:52.813]         if (!identical(...future.workdir, getwd())) 
[10:30:52.813]             setwd(...future.workdir)
[10:30:52.813]         {
[10:30:52.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:52.813]                 ...future.oldOptions$nwarnings <- NULL
[10:30:52.813]             }
[10:30:52.813]             base::options(...future.oldOptions)
[10:30:52.813]             if (.Platform$OS.type == "windows") {
[10:30:52.813]                 old_names <- names(...future.oldEnvVars)
[10:30:52.813]                 envs <- base::Sys.getenv()
[10:30:52.813]                 names <- names(envs)
[10:30:52.813]                 common <- intersect(names, old_names)
[10:30:52.813]                 added <- setdiff(names, old_names)
[10:30:52.813]                 removed <- setdiff(old_names, names)
[10:30:52.813]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:52.813]                   envs[common]]
[10:30:52.813]                 NAMES <- toupper(changed)
[10:30:52.813]                 args <- list()
[10:30:52.813]                 for (kk in seq_along(NAMES)) {
[10:30:52.813]                   name <- changed[[kk]]
[10:30:52.813]                   NAME <- NAMES[[kk]]
[10:30:52.813]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.813]                     next
[10:30:52.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.813]                 }
[10:30:52.813]                 NAMES <- toupper(added)
[10:30:52.813]                 for (kk in seq_along(NAMES)) {
[10:30:52.813]                   name <- added[[kk]]
[10:30:52.813]                   NAME <- NAMES[[kk]]
[10:30:52.813]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.813]                     next
[10:30:52.813]                   args[[name]] <- ""
[10:30:52.813]                 }
[10:30:52.813]                 NAMES <- toupper(removed)
[10:30:52.813]                 for (kk in seq_along(NAMES)) {
[10:30:52.813]                   name <- removed[[kk]]
[10:30:52.813]                   NAME <- NAMES[[kk]]
[10:30:52.813]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.813]                     next
[10:30:52.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.813]                 }
[10:30:52.813]                 if (length(args) > 0) 
[10:30:52.813]                   base::do.call(base::Sys.setenv, args = args)
[10:30:52.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:52.813]             }
[10:30:52.813]             else {
[10:30:52.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:52.813]             }
[10:30:52.813]             {
[10:30:52.813]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:52.813]                   0L) {
[10:30:52.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:52.813]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:52.813]                   base::options(opts)
[10:30:52.813]                 }
[10:30:52.813]                 {
[10:30:52.813]                   {
[10:30:52.813]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:52.813]                     NULL
[10:30:52.813]                   }
[10:30:52.813]                   options(future.plan = NULL)
[10:30:52.813]                   if (is.na(NA_character_)) 
[10:30:52.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:52.813]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:52.813]                     .init = FALSE)
[10:30:52.813]                 }
[10:30:52.813]             }
[10:30:52.813]         }
[10:30:52.813]     })
[10:30:52.813]     if (TRUE) {
[10:30:52.813]         base::sink(type = "output", split = FALSE)
[10:30:52.813]         if (TRUE) {
[10:30:52.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:52.813]         }
[10:30:52.813]         else {
[10:30:52.813]             ...future.result["stdout"] <- base::list(NULL)
[10:30:52.813]         }
[10:30:52.813]         base::close(...future.stdout)
[10:30:52.813]         ...future.stdout <- NULL
[10:30:52.813]     }
[10:30:52.813]     ...future.result$conditions <- ...future.conditions
[10:30:52.813]     ...future.result$finished <- base::Sys.time()
[10:30:52.813]     ...future.result
[10:30:52.813] }
[10:30:52.816] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[10:30:52.816] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[10:30:52.817] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[10:30:52.817] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:52.817] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:52.817] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[10:30:52.818] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[10:30:52.818] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:52.818] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:52.818] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:52.822] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:52.822] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[10:30:52.823] MultisessionFuture started
[10:30:52.823] - Launch lazy future ... done
[10:30:52.823] run() for ‘MultisessionFuture’ ... done
[10:30:52.823] Created future:
[10:30:52.823] MultisessionFuture:
[10:30:52.823] Label: ‘future_mapply-2’
[10:30:52.823] Expression:
[10:30:52.823] {
[10:30:52.823]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.823]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:52.823]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.823]         on.exit(options(oopts), add = TRUE)
[10:30:52.823]     }
[10:30:52.823]     {
[10:30:52.823]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.823]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:52.823]         do.call(mapply, args = args)
[10:30:52.823]     }
[10:30:52.823] }
[10:30:52.823] Lazy evaluation: FALSE
[10:30:52.823] Asynchronous evaluation: TRUE
[10:30:52.823] Local evaluation: TRUE
[10:30:52.823] Environment: R_GlobalEnv
[10:30:52.823] Capture standard output: TRUE
[10:30:52.823] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:52.823] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:52.823] Packages: <none>
[10:30:52.823] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:52.823] Resolved: FALSE
[10:30:52.823] Value: <not collected>
[10:30:52.823] Conditions captured: <none>
[10:30:52.823] Early signaling: FALSE
[10:30:52.823] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:52.823] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.835] Chunk #2 of 2 ... DONE
[10:30:52.835] Launching 2 futures (chunks) ... DONE
[10:30:52.835] Resolving 2 futures (chunks) ...
[10:30:52.835] resolve() on list ...
[10:30:52.835]  recursive: 0
[10:30:52.835]  length: 2
[10:30:52.835] 
[10:30:52.836] receiveMessageFromWorker() for ClusterFuture ...
[10:30:52.836] - Validating connection of MultisessionFuture
[10:30:52.836] - received message: FutureResult
[10:30:52.836] - Received FutureResult
[10:30:52.837] - Erased future from FutureRegistry
[10:30:52.837] result() for ClusterFuture ...
[10:30:52.837] - result already collected: FutureResult
[10:30:52.837] result() for ClusterFuture ... done
[10:30:52.837] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:52.837] Future #1
[10:30:52.837] result() for ClusterFuture ...
[10:30:52.837] - result already collected: FutureResult
[10:30:52.837] result() for ClusterFuture ... done
[10:30:52.837] result() for ClusterFuture ...
[10:30:52.838] - result already collected: FutureResult
[10:30:52.838] result() for ClusterFuture ... done
[10:30:52.838] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:52.838] - nx: 2
[10:30:52.838] - relay: TRUE
[10:30:52.838] - stdout: TRUE
[10:30:52.838] - signal: TRUE
[10:30:52.838] - resignal: FALSE
[10:30:52.838] - force: TRUE
[10:30:52.838] - relayed: [n=2] FALSE, FALSE
[10:30:52.838] - queued futures: [n=2] FALSE, FALSE
[10:30:52.838]  - until=1
[10:30:52.839]  - relaying element #1
[10:30:52.839] result() for ClusterFuture ...
[10:30:52.839] - result already collected: FutureResult
[10:30:52.839] result() for ClusterFuture ... done
[10:30:52.839] result() for ClusterFuture ...
[10:30:52.839] - result already collected: FutureResult
[10:30:52.839] result() for ClusterFuture ... done
[10:30:52.839] result() for ClusterFuture ...
[10:30:52.839] - result already collected: FutureResult
[10:30:52.839] result() for ClusterFuture ... done
[10:30:52.840] result() for ClusterFuture ...
[10:30:52.840] - result already collected: FutureResult
[10:30:52.840] result() for ClusterFuture ... done
[10:30:52.840] - relayed: [n=2] TRUE, FALSE
[10:30:52.840] - queued futures: [n=2] TRUE, FALSE
[10:30:52.840] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:52.840]  length: 1 (resolved future 1)
[10:30:52.866] receiveMessageFromWorker() for ClusterFuture ...
[10:30:52.867] - Validating connection of MultisessionFuture
[10:30:52.867] - received message: FutureResult
[10:30:52.867] - Received FutureResult
[10:30:52.867] - Erased future from FutureRegistry
[10:30:52.867] result() for ClusterFuture ...
[10:30:52.867] - result already collected: FutureResult
[10:30:52.867] result() for ClusterFuture ... done
[10:30:52.867] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:52.867] Future #2
[10:30:52.868] result() for ClusterFuture ...
[10:30:52.868] - result already collected: FutureResult
[10:30:52.868] result() for ClusterFuture ... done
[10:30:52.868] result() for ClusterFuture ...
[10:30:52.868] - result already collected: FutureResult
[10:30:52.868] result() for ClusterFuture ... done
[10:30:52.868] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:52.868] - nx: 2
[10:30:52.868] - relay: TRUE
[10:30:52.868] - stdout: TRUE
[10:30:52.868] - signal: TRUE
[10:30:52.869] - resignal: FALSE
[10:30:52.869] - force: TRUE
[10:30:52.869] - relayed: [n=2] TRUE, FALSE
[10:30:52.869] - queued futures: [n=2] TRUE, FALSE
[10:30:52.869]  - until=2
[10:30:52.869]  - relaying element #2
[10:30:52.869] result() for ClusterFuture ...
[10:30:52.869] - result already collected: FutureResult
[10:30:52.869] result() for ClusterFuture ... done
[10:30:52.869] result() for ClusterFuture ...
[10:30:52.870] - result already collected: FutureResult
[10:30:52.870] result() for ClusterFuture ... done
[10:30:52.870] result() for ClusterFuture ...
[10:30:52.870] - result already collected: FutureResult
[10:30:52.870] result() for ClusterFuture ... done
[10:30:52.870] result() for ClusterFuture ...
[10:30:52.870] - result already collected: FutureResult
[10:30:52.870] result() for ClusterFuture ... done
[10:30:52.870] - relayed: [n=2] TRUE, TRUE
[10:30:52.870] - queued futures: [n=2] TRUE, TRUE
[10:30:52.870] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:52.871]  length: 0 (resolved future 2)
[10:30:52.871] Relaying remaining futures
[10:30:52.871] signalConditionsASAP(NULL, pos=0) ...
[10:30:52.871] - nx: 2
[10:30:52.871] - relay: TRUE
[10:30:52.871] - stdout: TRUE
[10:30:52.871] - signal: TRUE
[10:30:52.871] - resignal: FALSE
[10:30:52.871] - force: TRUE
[10:30:52.871] - relayed: [n=2] TRUE, TRUE
[10:30:52.871] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:52.872] - relayed: [n=2] TRUE, TRUE
[10:30:52.872] - queued futures: [n=2] TRUE, TRUE
[10:30:52.872] signalConditionsASAP(NULL, pos=0) ... done
[10:30:52.872] resolve() on list ... DONE
[10:30:52.872] result() for ClusterFuture ...
[10:30:52.872] - result already collected: FutureResult
[10:30:52.872] result() for ClusterFuture ... done
[10:30:52.872] result() for ClusterFuture ...
[10:30:52.872] - result already collected: FutureResult
[10:30:52.872] result() for ClusterFuture ... done
[10:30:52.872] result() for ClusterFuture ...
[10:30:52.872] - result already collected: FutureResult
[10:30:52.873] result() for ClusterFuture ... done
[10:30:52.873] result() for ClusterFuture ...
[10:30:52.873] - result already collected: FutureResult
[10:30:52.873] result() for ClusterFuture ... done
[10:30:52.873]  - Number of value chunks collected: 2
[10:30:52.873] Resolving 2 futures (chunks) ... DONE
[10:30:52.873] Reducing values from 2 chunks ...
[10:30:52.873]  - Number of values collected after concatenation: 4
[10:30:52.873]  - Number of values expected: 4
[10:30:52.873] Reducing values from 2 chunks ... DONE
[10:30:52.873] future_mapply() ... DONE
[10:30:52.874] future_mapply() ...
[10:30:52.877] Number of chunks: 2
[10:30:52.877] getGlobalsAndPackagesXApply() ...
[10:30:52.878]  - future.globals: TRUE
[10:30:52.878] getGlobalsAndPackages() ...
[10:30:52.878] Searching for globals...
[10:30:52.878] - globals found: [1] ‘FUN’
[10:30:52.879] Searching for globals ... DONE
[10:30:52.879] Resolving globals: FALSE
[10:30:52.879] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:52.879] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:52.879] - globals: [1] ‘FUN’
[10:30:52.880] 
[10:30:52.880] getGlobalsAndPackages() ... DONE
[10:30:52.880]  - globals found/used: [n=1] ‘FUN’
[10:30:52.880]  - needed namespaces: [n=0] 
[10:30:52.880] Finding globals ... DONE
[10:30:52.880] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:52.880] List of 2
[10:30:52.880]  $ ...future.FUN:function (x, ...)  
[10:30:52.880]  $ MoreArgs     : NULL
[10:30:52.880]  - attr(*, "where")=List of 2
[10:30:52.880]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:52.880]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:52.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:52.880]  - attr(*, "resolved")= logi FALSE
[10:30:52.880]  - attr(*, "total_size")= num NA
[10:30:52.883] Packages to be attached in all futures: [n=0] 
[10:30:52.883] getGlobalsAndPackagesXApply() ... DONE
[10:30:52.883] Number of futures (= number of chunks): 2
[10:30:52.883] Launching 2 futures (chunks) ...
[10:30:52.883] Chunk #1 of 2 ...
[10:30:52.883]  - Finding globals in '...' for chunk #1 ...
[10:30:52.883] getGlobalsAndPackages() ...
[10:30:52.884] Searching for globals...
[10:30:52.884] 
[10:30:52.884] Searching for globals ... DONE
[10:30:52.884] - globals: [0] <none>
[10:30:52.884] getGlobalsAndPackages() ... DONE
[10:30:52.884]    + additional globals found: [n=0] 
[10:30:52.884]    + additional namespaces needed: [n=0] 
[10:30:52.884]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:52.885]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:52.885]  - seeds: <none>
[10:30:52.885]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.885] getGlobalsAndPackages() ...
[10:30:52.885] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.885] Resolving globals: FALSE
[10:30:52.886] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:52.886] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:52.886] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.886] 
[10:30:52.886] getGlobalsAndPackages() ... DONE
[10:30:52.887] run() for ‘Future’ ...
[10:30:52.887] - state: ‘created’
[10:30:52.887] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:52.902] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:52.902]   - Field: ‘node’
[10:30:52.905]   - Field: ‘label’
[10:30:52.905]   - Field: ‘local’
[10:30:52.905]   - Field: ‘owner’
[10:30:52.905]   - Field: ‘envir’
[10:30:52.905]   - Field: ‘workers’
[10:30:52.905]   - Field: ‘packages’
[10:30:52.905]   - Field: ‘gc’
[10:30:52.905]   - Field: ‘conditions’
[10:30:52.905]   - Field: ‘persistent’
[10:30:52.905]   - Field: ‘expr’
[10:30:52.906]   - Field: ‘uuid’
[10:30:52.906]   - Field: ‘seed’
[10:30:52.906]   - Field: ‘version’
[10:30:52.906]   - Field: ‘result’
[10:30:52.906]   - Field: ‘asynchronous’
[10:30:52.906]   - Field: ‘calls’
[10:30:52.906]   - Field: ‘globals’
[10:30:52.906]   - Field: ‘stdout’
[10:30:52.906]   - Field: ‘earlySignal’
[10:30:52.906]   - Field: ‘lazy’
[10:30:52.906]   - Field: ‘state’
[10:30:52.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:52.907] - Launch lazy future ...
[10:30:52.907] Packages needed by the future expression (n = 0): <none>
[10:30:52.907] Packages needed by future strategies (n = 0): <none>
[10:30:52.907] {
[10:30:52.907]     {
[10:30:52.907]         {
[10:30:52.907]             ...future.startTime <- base::Sys.time()
[10:30:52.907]             {
[10:30:52.907]                 {
[10:30:52.907]                   {
[10:30:52.907]                     {
[10:30:52.907]                       base::local({
[10:30:52.907]                         has_future <- base::requireNamespace("future", 
[10:30:52.907]                           quietly = TRUE)
[10:30:52.907]                         if (has_future) {
[10:30:52.907]                           ns <- base::getNamespace("future")
[10:30:52.907]                           version <- ns[[".package"]][["version"]]
[10:30:52.907]                           if (is.null(version)) 
[10:30:52.907]                             version <- utils::packageVersion("future")
[10:30:52.907]                         }
[10:30:52.907]                         else {
[10:30:52.907]                           version <- NULL
[10:30:52.907]                         }
[10:30:52.907]                         if (!has_future || version < "1.8.0") {
[10:30:52.907]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:52.907]                             "", base::R.version$version.string), 
[10:30:52.907]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:52.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:52.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:52.907]                               "release", "version")], collapse = " "), 
[10:30:52.907]                             hostname = base::Sys.info()[["nodename"]])
[10:30:52.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:52.907]                             info)
[10:30:52.907]                           info <- base::paste(info, collapse = "; ")
[10:30:52.907]                           if (!has_future) {
[10:30:52.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:52.907]                               info)
[10:30:52.907]                           }
[10:30:52.907]                           else {
[10:30:52.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:52.907]                               info, version)
[10:30:52.907]                           }
[10:30:52.907]                           base::stop(msg)
[10:30:52.907]                         }
[10:30:52.907]                       })
[10:30:52.907]                     }
[10:30:52.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:52.907]                     base::options(mc.cores = 1L)
[10:30:52.907]                   }
[10:30:52.907]                   ...future.strategy.old <- future::plan("list")
[10:30:52.907]                   options(future.plan = NULL)
[10:30:52.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:52.907]                 }
[10:30:52.907]                 ...future.workdir <- getwd()
[10:30:52.907]             }
[10:30:52.907]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:52.907]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:52.907]         }
[10:30:52.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:52.907]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:52.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:52.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:52.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:52.907]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:52.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:52.907]             base::names(...future.oldOptions))
[10:30:52.907]     }
[10:30:52.907]     if (FALSE) {
[10:30:52.907]     }
[10:30:52.907]     else {
[10:30:52.907]         if (TRUE) {
[10:30:52.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:52.907]                 open = "w")
[10:30:52.907]         }
[10:30:52.907]         else {
[10:30:52.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:52.907]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:52.907]         }
[10:30:52.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:52.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:52.907]             base::sink(type = "output", split = FALSE)
[10:30:52.907]             base::close(...future.stdout)
[10:30:52.907]         }, add = TRUE)
[10:30:52.907]     }
[10:30:52.907]     ...future.frame <- base::sys.nframe()
[10:30:52.907]     ...future.conditions <- base::list()
[10:30:52.907]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:52.907]     if (FALSE) {
[10:30:52.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:52.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:52.907]     }
[10:30:52.907]     ...future.result <- base::tryCatch({
[10:30:52.907]         base::withCallingHandlers({
[10:30:52.907]             ...future.value <- base::withVisible(base::local({
[10:30:52.907]                 ...future.makeSendCondition <- base::local({
[10:30:52.907]                   sendCondition <- NULL
[10:30:52.907]                   function(frame = 1L) {
[10:30:52.907]                     if (is.function(sendCondition)) 
[10:30:52.907]                       return(sendCondition)
[10:30:52.907]                     ns <- getNamespace("parallel")
[10:30:52.907]                     if (exists("sendData", mode = "function", 
[10:30:52.907]                       envir = ns)) {
[10:30:52.907]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:52.907]                         envir = ns)
[10:30:52.907]                       envir <- sys.frame(frame)
[10:30:52.907]                       master <- NULL
[10:30:52.907]                       while (!identical(envir, .GlobalEnv) && 
[10:30:52.907]                         !identical(envir, emptyenv())) {
[10:30:52.907]                         if (exists("master", mode = "list", envir = envir, 
[10:30:52.907]                           inherits = FALSE)) {
[10:30:52.907]                           master <- get("master", mode = "list", 
[10:30:52.907]                             envir = envir, inherits = FALSE)
[10:30:52.907]                           if (inherits(master, c("SOCKnode", 
[10:30:52.907]                             "SOCK0node"))) {
[10:30:52.907]                             sendCondition <<- function(cond) {
[10:30:52.907]                               data <- list(type = "VALUE", value = cond, 
[10:30:52.907]                                 success = TRUE)
[10:30:52.907]                               parallel_sendData(master, data)
[10:30:52.907]                             }
[10:30:52.907]                             return(sendCondition)
[10:30:52.907]                           }
[10:30:52.907]                         }
[10:30:52.907]                         frame <- frame + 1L
[10:30:52.907]                         envir <- sys.frame(frame)
[10:30:52.907]                       }
[10:30:52.907]                     }
[10:30:52.907]                     sendCondition <<- function(cond) NULL
[10:30:52.907]                   }
[10:30:52.907]                 })
[10:30:52.907]                 withCallingHandlers({
[10:30:52.907]                   {
[10:30:52.907]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.907]                     if (!identical(...future.globals.maxSize.org, 
[10:30:52.907]                       ...future.globals.maxSize)) {
[10:30:52.907]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.907]                       on.exit(options(oopts), add = TRUE)
[10:30:52.907]                     }
[10:30:52.907]                     {
[10:30:52.907]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.907]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:52.907]                         USE.NAMES = FALSE)
[10:30:52.907]                       do.call(mapply, args = args)
[10:30:52.907]                     }
[10:30:52.907]                   }
[10:30:52.907]                 }, immediateCondition = function(cond) {
[10:30:52.907]                   sendCondition <- ...future.makeSendCondition()
[10:30:52.907]                   sendCondition(cond)
[10:30:52.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.907]                   {
[10:30:52.907]                     inherits <- base::inherits
[10:30:52.907]                     invokeRestart <- base::invokeRestart
[10:30:52.907]                     is.null <- base::is.null
[10:30:52.907]                     muffled <- FALSE
[10:30:52.907]                     if (inherits(cond, "message")) {
[10:30:52.907]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:52.907]                       if (muffled) 
[10:30:52.907]                         invokeRestart("muffleMessage")
[10:30:52.907]                     }
[10:30:52.907]                     else if (inherits(cond, "warning")) {
[10:30:52.907]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:52.907]                       if (muffled) 
[10:30:52.907]                         invokeRestart("muffleWarning")
[10:30:52.907]                     }
[10:30:52.907]                     else if (inherits(cond, "condition")) {
[10:30:52.907]                       if (!is.null(pattern)) {
[10:30:52.907]                         computeRestarts <- base::computeRestarts
[10:30:52.907]                         grepl <- base::grepl
[10:30:52.907]                         restarts <- computeRestarts(cond)
[10:30:52.907]                         for (restart in restarts) {
[10:30:52.907]                           name <- restart$name
[10:30:52.907]                           if (is.null(name)) 
[10:30:52.907]                             next
[10:30:52.907]                           if (!grepl(pattern, name)) 
[10:30:52.907]                             next
[10:30:52.907]                           invokeRestart(restart)
[10:30:52.907]                           muffled <- TRUE
[10:30:52.907]                           break
[10:30:52.907]                         }
[10:30:52.907]                       }
[10:30:52.907]                     }
[10:30:52.907]                     invisible(muffled)
[10:30:52.907]                   }
[10:30:52.907]                   muffleCondition(cond)
[10:30:52.907]                 })
[10:30:52.907]             }))
[10:30:52.907]             future::FutureResult(value = ...future.value$value, 
[10:30:52.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.907]                   ...future.rng), globalenv = if (FALSE) 
[10:30:52.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:52.907]                     ...future.globalenv.names))
[10:30:52.907]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:52.907]         }, condition = base::local({
[10:30:52.907]             c <- base::c
[10:30:52.907]             inherits <- base::inherits
[10:30:52.907]             invokeRestart <- base::invokeRestart
[10:30:52.907]             length <- base::length
[10:30:52.907]             list <- base::list
[10:30:52.907]             seq.int <- base::seq.int
[10:30:52.907]             signalCondition <- base::signalCondition
[10:30:52.907]             sys.calls <- base::sys.calls
[10:30:52.907]             `[[` <- base::`[[`
[10:30:52.907]             `+` <- base::`+`
[10:30:52.907]             `<<-` <- base::`<<-`
[10:30:52.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:52.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:52.907]                   3L)]
[10:30:52.907]             }
[10:30:52.907]             function(cond) {
[10:30:52.907]                 is_error <- inherits(cond, "error")
[10:30:52.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:52.907]                   NULL)
[10:30:52.907]                 if (is_error) {
[10:30:52.907]                   sessionInformation <- function() {
[10:30:52.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:52.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:52.907]                       search = base::search(), system = base::Sys.info())
[10:30:52.907]                   }
[10:30:52.907]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:52.907]                     cond$call), session = sessionInformation(), 
[10:30:52.907]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:52.907]                   signalCondition(cond)
[10:30:52.907]                 }
[10:30:52.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:52.907]                 "immediateCondition"))) {
[10:30:52.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:52.907]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:52.907]                   if (TRUE && !signal) {
[10:30:52.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.907]                     {
[10:30:52.907]                       inherits <- base::inherits
[10:30:52.907]                       invokeRestart <- base::invokeRestart
[10:30:52.907]                       is.null <- base::is.null
[10:30:52.907]                       muffled <- FALSE
[10:30:52.907]                       if (inherits(cond, "message")) {
[10:30:52.907]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.907]                         if (muffled) 
[10:30:52.907]                           invokeRestart("muffleMessage")
[10:30:52.907]                       }
[10:30:52.907]                       else if (inherits(cond, "warning")) {
[10:30:52.907]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.907]                         if (muffled) 
[10:30:52.907]                           invokeRestart("muffleWarning")
[10:30:52.907]                       }
[10:30:52.907]                       else if (inherits(cond, "condition")) {
[10:30:52.907]                         if (!is.null(pattern)) {
[10:30:52.907]                           computeRestarts <- base::computeRestarts
[10:30:52.907]                           grepl <- base::grepl
[10:30:52.907]                           restarts <- computeRestarts(cond)
[10:30:52.907]                           for (restart in restarts) {
[10:30:52.907]                             name <- restart$name
[10:30:52.907]                             if (is.null(name)) 
[10:30:52.907]                               next
[10:30:52.907]                             if (!grepl(pattern, name)) 
[10:30:52.907]                               next
[10:30:52.907]                             invokeRestart(restart)
[10:30:52.907]                             muffled <- TRUE
[10:30:52.907]                             break
[10:30:52.907]                           }
[10:30:52.907]                         }
[10:30:52.907]                       }
[10:30:52.907]                       invisible(muffled)
[10:30:52.907]                     }
[10:30:52.907]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.907]                   }
[10:30:52.907]                 }
[10:30:52.907]                 else {
[10:30:52.907]                   if (TRUE) {
[10:30:52.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.907]                     {
[10:30:52.907]                       inherits <- base::inherits
[10:30:52.907]                       invokeRestart <- base::invokeRestart
[10:30:52.907]                       is.null <- base::is.null
[10:30:52.907]                       muffled <- FALSE
[10:30:52.907]                       if (inherits(cond, "message")) {
[10:30:52.907]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.907]                         if (muffled) 
[10:30:52.907]                           invokeRestart("muffleMessage")
[10:30:52.907]                       }
[10:30:52.907]                       else if (inherits(cond, "warning")) {
[10:30:52.907]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.907]                         if (muffled) 
[10:30:52.907]                           invokeRestart("muffleWarning")
[10:30:52.907]                       }
[10:30:52.907]                       else if (inherits(cond, "condition")) {
[10:30:52.907]                         if (!is.null(pattern)) {
[10:30:52.907]                           computeRestarts <- base::computeRestarts
[10:30:52.907]                           grepl <- base::grepl
[10:30:52.907]                           restarts <- computeRestarts(cond)
[10:30:52.907]                           for (restart in restarts) {
[10:30:52.907]                             name <- restart$name
[10:30:52.907]                             if (is.null(name)) 
[10:30:52.907]                               next
[10:30:52.907]                             if (!grepl(pattern, name)) 
[10:30:52.907]                               next
[10:30:52.907]                             invokeRestart(restart)
[10:30:52.907]                             muffled <- TRUE
[10:30:52.907]                             break
[10:30:52.907]                           }
[10:30:52.907]                         }
[10:30:52.907]                       }
[10:30:52.907]                       invisible(muffled)
[10:30:52.907]                     }
[10:30:52.907]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.907]                   }
[10:30:52.907]                 }
[10:30:52.907]             }
[10:30:52.907]         }))
[10:30:52.907]     }, error = function(ex) {
[10:30:52.907]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:52.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.907]                 ...future.rng), started = ...future.startTime, 
[10:30:52.907]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:52.907]             version = "1.8"), class = "FutureResult")
[10:30:52.907]     }, finally = {
[10:30:52.907]         if (!identical(...future.workdir, getwd())) 
[10:30:52.907]             setwd(...future.workdir)
[10:30:52.907]         {
[10:30:52.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:52.907]                 ...future.oldOptions$nwarnings <- NULL
[10:30:52.907]             }
[10:30:52.907]             base::options(...future.oldOptions)
[10:30:52.907]             if (.Platform$OS.type == "windows") {
[10:30:52.907]                 old_names <- names(...future.oldEnvVars)
[10:30:52.907]                 envs <- base::Sys.getenv()
[10:30:52.907]                 names <- names(envs)
[10:30:52.907]                 common <- intersect(names, old_names)
[10:30:52.907]                 added <- setdiff(names, old_names)
[10:30:52.907]                 removed <- setdiff(old_names, names)
[10:30:52.907]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:52.907]                   envs[common]]
[10:30:52.907]                 NAMES <- toupper(changed)
[10:30:52.907]                 args <- list()
[10:30:52.907]                 for (kk in seq_along(NAMES)) {
[10:30:52.907]                   name <- changed[[kk]]
[10:30:52.907]                   NAME <- NAMES[[kk]]
[10:30:52.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.907]                     next
[10:30:52.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.907]                 }
[10:30:52.907]                 NAMES <- toupper(added)
[10:30:52.907]                 for (kk in seq_along(NAMES)) {
[10:30:52.907]                   name <- added[[kk]]
[10:30:52.907]                   NAME <- NAMES[[kk]]
[10:30:52.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.907]                     next
[10:30:52.907]                   args[[name]] <- ""
[10:30:52.907]                 }
[10:30:52.907]                 NAMES <- toupper(removed)
[10:30:52.907]                 for (kk in seq_along(NAMES)) {
[10:30:52.907]                   name <- removed[[kk]]
[10:30:52.907]                   NAME <- NAMES[[kk]]
[10:30:52.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.907]                     next
[10:30:52.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.907]                 }
[10:30:52.907]                 if (length(args) > 0) 
[10:30:52.907]                   base::do.call(base::Sys.setenv, args = args)
[10:30:52.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:52.907]             }
[10:30:52.907]             else {
[10:30:52.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:52.907]             }
[10:30:52.907]             {
[10:30:52.907]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:52.907]                   0L) {
[10:30:52.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:52.907]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:52.907]                   base::options(opts)
[10:30:52.907]                 }
[10:30:52.907]                 {
[10:30:52.907]                   {
[10:30:52.907]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:52.907]                     NULL
[10:30:52.907]                   }
[10:30:52.907]                   options(future.plan = NULL)
[10:30:52.907]                   if (is.na(NA_character_)) 
[10:30:52.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:52.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:52.907]                     .init = FALSE)
[10:30:52.907]                 }
[10:30:52.907]             }
[10:30:52.907]         }
[10:30:52.907]     })
[10:30:52.907]     if (TRUE) {
[10:30:52.907]         base::sink(type = "output", split = FALSE)
[10:30:52.907]         if (TRUE) {
[10:30:52.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:52.907]         }
[10:30:52.907]         else {
[10:30:52.907]             ...future.result["stdout"] <- base::list(NULL)
[10:30:52.907]         }
[10:30:52.907]         base::close(...future.stdout)
[10:30:52.907]         ...future.stdout <- NULL
[10:30:52.907]     }
[10:30:52.907]     ...future.result$conditions <- ...future.conditions
[10:30:52.907]     ...future.result$finished <- base::Sys.time()
[10:30:52.907]     ...future.result
[10:30:52.907] }
[10:30:52.910] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[10:30:52.910] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[10:30:52.911] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[10:30:52.911] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:52.911] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:52.911] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[10:30:52.912] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[10:30:52.912] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:52.912] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:52.912] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:52.913] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:52.913] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[10:30:52.914] MultisessionFuture started
[10:30:52.914] - Launch lazy future ... done
[10:30:52.914] run() for ‘MultisessionFuture’ ... done
[10:30:52.914] Created future:
[10:30:52.914] MultisessionFuture:
[10:30:52.914] Label: ‘future_mapply-1’
[10:30:52.914] Expression:
[10:30:52.914] {
[10:30:52.914]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.914]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:52.914]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.914]         on.exit(options(oopts), add = TRUE)
[10:30:52.914]     }
[10:30:52.914]     {
[10:30:52.914]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.914]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:52.914]         do.call(mapply, args = args)
[10:30:52.914]     }
[10:30:52.914] }
[10:30:52.914] Lazy evaluation: FALSE
[10:30:52.914] Asynchronous evaluation: TRUE
[10:30:52.914] Local evaluation: TRUE
[10:30:52.914] Environment: R_GlobalEnv
[10:30:52.914] Capture standard output: TRUE
[10:30:52.914] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:52.914] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:52.914] Packages: <none>
[10:30:52.914] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:52.914] Resolved: FALSE
[10:30:52.914] Value: <not collected>
[10:30:52.914] Conditions captured: <none>
[10:30:52.914] Early signaling: FALSE
[10:30:52.914] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:52.914] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.926] Chunk #1 of 2 ... DONE
[10:30:52.926] Chunk #2 of 2 ...
[10:30:52.926]  - Finding globals in '...' for chunk #2 ...
[10:30:52.926] getGlobalsAndPackages() ...
[10:30:52.926] Searching for globals...
[10:30:52.926] 
[10:30:52.927] Searching for globals ... DONE
[10:30:52.927] - globals: [0] <none>
[10:30:52.927] getGlobalsAndPackages() ... DONE
[10:30:52.927]    + additional globals found: [n=0] 
[10:30:52.927]    + additional namespaces needed: [n=0] 
[10:30:52.927]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:52.927]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:52.927]  - seeds: <none>
[10:30:52.927]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.927] getGlobalsAndPackages() ...
[10:30:52.927] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.928] Resolving globals: FALSE
[10:30:52.928] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:52.929] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:52.929] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:52.929] 
[10:30:52.929] getGlobalsAndPackages() ... DONE
[10:30:52.929] run() for ‘Future’ ...
[10:30:52.929] - state: ‘created’
[10:30:52.929] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:52.943] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.943] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:52.943]   - Field: ‘node’
[10:30:52.944]   - Field: ‘label’
[10:30:52.944]   - Field: ‘local’
[10:30:52.944]   - Field: ‘owner’
[10:30:52.944]   - Field: ‘envir’
[10:30:52.944]   - Field: ‘workers’
[10:30:52.944]   - Field: ‘packages’
[10:30:52.944]   - Field: ‘gc’
[10:30:52.944]   - Field: ‘conditions’
[10:30:52.944]   - Field: ‘persistent’
[10:30:52.944]   - Field: ‘expr’
[10:30:52.945]   - Field: ‘uuid’
[10:30:52.945]   - Field: ‘seed’
[10:30:52.945]   - Field: ‘version’
[10:30:52.945]   - Field: ‘result’
[10:30:52.945]   - Field: ‘asynchronous’
[10:30:52.945]   - Field: ‘calls’
[10:30:52.945]   - Field: ‘globals’
[10:30:52.945]   - Field: ‘stdout’
[10:30:52.945]   - Field: ‘earlySignal’
[10:30:52.945]   - Field: ‘lazy’
[10:30:52.945]   - Field: ‘state’
[10:30:52.946] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:52.946] - Launch lazy future ...
[10:30:52.946] Packages needed by the future expression (n = 0): <none>
[10:30:52.946] Packages needed by future strategies (n = 0): <none>
[10:30:52.946] {
[10:30:52.946]     {
[10:30:52.946]         {
[10:30:52.946]             ...future.startTime <- base::Sys.time()
[10:30:52.946]             {
[10:30:52.946]                 {
[10:30:52.946]                   {
[10:30:52.946]                     {
[10:30:52.946]                       base::local({
[10:30:52.946]                         has_future <- base::requireNamespace("future", 
[10:30:52.946]                           quietly = TRUE)
[10:30:52.946]                         if (has_future) {
[10:30:52.946]                           ns <- base::getNamespace("future")
[10:30:52.946]                           version <- ns[[".package"]][["version"]]
[10:30:52.946]                           if (is.null(version)) 
[10:30:52.946]                             version <- utils::packageVersion("future")
[10:30:52.946]                         }
[10:30:52.946]                         else {
[10:30:52.946]                           version <- NULL
[10:30:52.946]                         }
[10:30:52.946]                         if (!has_future || version < "1.8.0") {
[10:30:52.946]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:52.946]                             "", base::R.version$version.string), 
[10:30:52.946]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:52.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:52.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:52.946]                               "release", "version")], collapse = " "), 
[10:30:52.946]                             hostname = base::Sys.info()[["nodename"]])
[10:30:52.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:52.946]                             info)
[10:30:52.946]                           info <- base::paste(info, collapse = "; ")
[10:30:52.946]                           if (!has_future) {
[10:30:52.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:52.946]                               info)
[10:30:52.946]                           }
[10:30:52.946]                           else {
[10:30:52.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:52.946]                               info, version)
[10:30:52.946]                           }
[10:30:52.946]                           base::stop(msg)
[10:30:52.946]                         }
[10:30:52.946]                       })
[10:30:52.946]                     }
[10:30:52.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:52.946]                     base::options(mc.cores = 1L)
[10:30:52.946]                   }
[10:30:52.946]                   ...future.strategy.old <- future::plan("list")
[10:30:52.946]                   options(future.plan = NULL)
[10:30:52.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:52.946]                 }
[10:30:52.946]                 ...future.workdir <- getwd()
[10:30:52.946]             }
[10:30:52.946]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:52.946]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:52.946]         }
[10:30:52.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:52.946]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:52.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:52.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:52.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:52.946]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:52.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:52.946]             base::names(...future.oldOptions))
[10:30:52.946]     }
[10:30:52.946]     if (FALSE) {
[10:30:52.946]     }
[10:30:52.946]     else {
[10:30:52.946]         if (TRUE) {
[10:30:52.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:52.946]                 open = "w")
[10:30:52.946]         }
[10:30:52.946]         else {
[10:30:52.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:52.946]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:52.946]         }
[10:30:52.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:52.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:52.946]             base::sink(type = "output", split = FALSE)
[10:30:52.946]             base::close(...future.stdout)
[10:30:52.946]         }, add = TRUE)
[10:30:52.946]     }
[10:30:52.946]     ...future.frame <- base::sys.nframe()
[10:30:52.946]     ...future.conditions <- base::list()
[10:30:52.946]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:52.946]     if (FALSE) {
[10:30:52.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:52.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:52.946]     }
[10:30:52.946]     ...future.result <- base::tryCatch({
[10:30:52.946]         base::withCallingHandlers({
[10:30:52.946]             ...future.value <- base::withVisible(base::local({
[10:30:52.946]                 ...future.makeSendCondition <- base::local({
[10:30:52.946]                   sendCondition <- NULL
[10:30:52.946]                   function(frame = 1L) {
[10:30:52.946]                     if (is.function(sendCondition)) 
[10:30:52.946]                       return(sendCondition)
[10:30:52.946]                     ns <- getNamespace("parallel")
[10:30:52.946]                     if (exists("sendData", mode = "function", 
[10:30:52.946]                       envir = ns)) {
[10:30:52.946]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:52.946]                         envir = ns)
[10:30:52.946]                       envir <- sys.frame(frame)
[10:30:52.946]                       master <- NULL
[10:30:52.946]                       while (!identical(envir, .GlobalEnv) && 
[10:30:52.946]                         !identical(envir, emptyenv())) {
[10:30:52.946]                         if (exists("master", mode = "list", envir = envir, 
[10:30:52.946]                           inherits = FALSE)) {
[10:30:52.946]                           master <- get("master", mode = "list", 
[10:30:52.946]                             envir = envir, inherits = FALSE)
[10:30:52.946]                           if (inherits(master, c("SOCKnode", 
[10:30:52.946]                             "SOCK0node"))) {
[10:30:52.946]                             sendCondition <<- function(cond) {
[10:30:52.946]                               data <- list(type = "VALUE", value = cond, 
[10:30:52.946]                                 success = TRUE)
[10:30:52.946]                               parallel_sendData(master, data)
[10:30:52.946]                             }
[10:30:52.946]                             return(sendCondition)
[10:30:52.946]                           }
[10:30:52.946]                         }
[10:30:52.946]                         frame <- frame + 1L
[10:30:52.946]                         envir <- sys.frame(frame)
[10:30:52.946]                       }
[10:30:52.946]                     }
[10:30:52.946]                     sendCondition <<- function(cond) NULL
[10:30:52.946]                   }
[10:30:52.946]                 })
[10:30:52.946]                 withCallingHandlers({
[10:30:52.946]                   {
[10:30:52.946]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.946]                     if (!identical(...future.globals.maxSize.org, 
[10:30:52.946]                       ...future.globals.maxSize)) {
[10:30:52.946]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.946]                       on.exit(options(oopts), add = TRUE)
[10:30:52.946]                     }
[10:30:52.946]                     {
[10:30:52.946]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.946]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:52.946]                         USE.NAMES = FALSE)
[10:30:52.946]                       do.call(mapply, args = args)
[10:30:52.946]                     }
[10:30:52.946]                   }
[10:30:52.946]                 }, immediateCondition = function(cond) {
[10:30:52.946]                   sendCondition <- ...future.makeSendCondition()
[10:30:52.946]                   sendCondition(cond)
[10:30:52.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.946]                   {
[10:30:52.946]                     inherits <- base::inherits
[10:30:52.946]                     invokeRestart <- base::invokeRestart
[10:30:52.946]                     is.null <- base::is.null
[10:30:52.946]                     muffled <- FALSE
[10:30:52.946]                     if (inherits(cond, "message")) {
[10:30:52.946]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:52.946]                       if (muffled) 
[10:30:52.946]                         invokeRestart("muffleMessage")
[10:30:52.946]                     }
[10:30:52.946]                     else if (inherits(cond, "warning")) {
[10:30:52.946]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:52.946]                       if (muffled) 
[10:30:52.946]                         invokeRestart("muffleWarning")
[10:30:52.946]                     }
[10:30:52.946]                     else if (inherits(cond, "condition")) {
[10:30:52.946]                       if (!is.null(pattern)) {
[10:30:52.946]                         computeRestarts <- base::computeRestarts
[10:30:52.946]                         grepl <- base::grepl
[10:30:52.946]                         restarts <- computeRestarts(cond)
[10:30:52.946]                         for (restart in restarts) {
[10:30:52.946]                           name <- restart$name
[10:30:52.946]                           if (is.null(name)) 
[10:30:52.946]                             next
[10:30:52.946]                           if (!grepl(pattern, name)) 
[10:30:52.946]                             next
[10:30:52.946]                           invokeRestart(restart)
[10:30:52.946]                           muffled <- TRUE
[10:30:52.946]                           break
[10:30:52.946]                         }
[10:30:52.946]                       }
[10:30:52.946]                     }
[10:30:52.946]                     invisible(muffled)
[10:30:52.946]                   }
[10:30:52.946]                   muffleCondition(cond)
[10:30:52.946]                 })
[10:30:52.946]             }))
[10:30:52.946]             future::FutureResult(value = ...future.value$value, 
[10:30:52.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.946]                   ...future.rng), globalenv = if (FALSE) 
[10:30:52.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:52.946]                     ...future.globalenv.names))
[10:30:52.946]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:52.946]         }, condition = base::local({
[10:30:52.946]             c <- base::c
[10:30:52.946]             inherits <- base::inherits
[10:30:52.946]             invokeRestart <- base::invokeRestart
[10:30:52.946]             length <- base::length
[10:30:52.946]             list <- base::list
[10:30:52.946]             seq.int <- base::seq.int
[10:30:52.946]             signalCondition <- base::signalCondition
[10:30:52.946]             sys.calls <- base::sys.calls
[10:30:52.946]             `[[` <- base::`[[`
[10:30:52.946]             `+` <- base::`+`
[10:30:52.946]             `<<-` <- base::`<<-`
[10:30:52.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:52.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:52.946]                   3L)]
[10:30:52.946]             }
[10:30:52.946]             function(cond) {
[10:30:52.946]                 is_error <- inherits(cond, "error")
[10:30:52.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:52.946]                   NULL)
[10:30:52.946]                 if (is_error) {
[10:30:52.946]                   sessionInformation <- function() {
[10:30:52.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:52.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:52.946]                       search = base::search(), system = base::Sys.info())
[10:30:52.946]                   }
[10:30:52.946]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:52.946]                     cond$call), session = sessionInformation(), 
[10:30:52.946]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:52.946]                   signalCondition(cond)
[10:30:52.946]                 }
[10:30:52.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:52.946]                 "immediateCondition"))) {
[10:30:52.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:52.946]                   ...future.conditions[[length(...future.conditions) + 
[10:30:52.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:52.946]                   if (TRUE && !signal) {
[10:30:52.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.946]                     {
[10:30:52.946]                       inherits <- base::inherits
[10:30:52.946]                       invokeRestart <- base::invokeRestart
[10:30:52.946]                       is.null <- base::is.null
[10:30:52.946]                       muffled <- FALSE
[10:30:52.946]                       if (inherits(cond, "message")) {
[10:30:52.946]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.946]                         if (muffled) 
[10:30:52.946]                           invokeRestart("muffleMessage")
[10:30:52.946]                       }
[10:30:52.946]                       else if (inherits(cond, "warning")) {
[10:30:52.946]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.946]                         if (muffled) 
[10:30:52.946]                           invokeRestart("muffleWarning")
[10:30:52.946]                       }
[10:30:52.946]                       else if (inherits(cond, "condition")) {
[10:30:52.946]                         if (!is.null(pattern)) {
[10:30:52.946]                           computeRestarts <- base::computeRestarts
[10:30:52.946]                           grepl <- base::grepl
[10:30:52.946]                           restarts <- computeRestarts(cond)
[10:30:52.946]                           for (restart in restarts) {
[10:30:52.946]                             name <- restart$name
[10:30:52.946]                             if (is.null(name)) 
[10:30:52.946]                               next
[10:30:52.946]                             if (!grepl(pattern, name)) 
[10:30:52.946]                               next
[10:30:52.946]                             invokeRestart(restart)
[10:30:52.946]                             muffled <- TRUE
[10:30:52.946]                             break
[10:30:52.946]                           }
[10:30:52.946]                         }
[10:30:52.946]                       }
[10:30:52.946]                       invisible(muffled)
[10:30:52.946]                     }
[10:30:52.946]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.946]                   }
[10:30:52.946]                 }
[10:30:52.946]                 else {
[10:30:52.946]                   if (TRUE) {
[10:30:52.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:52.946]                     {
[10:30:52.946]                       inherits <- base::inherits
[10:30:52.946]                       invokeRestart <- base::invokeRestart
[10:30:52.946]                       is.null <- base::is.null
[10:30:52.946]                       muffled <- FALSE
[10:30:52.946]                       if (inherits(cond, "message")) {
[10:30:52.946]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:52.946]                         if (muffled) 
[10:30:52.946]                           invokeRestart("muffleMessage")
[10:30:52.946]                       }
[10:30:52.946]                       else if (inherits(cond, "warning")) {
[10:30:52.946]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:52.946]                         if (muffled) 
[10:30:52.946]                           invokeRestart("muffleWarning")
[10:30:52.946]                       }
[10:30:52.946]                       else if (inherits(cond, "condition")) {
[10:30:52.946]                         if (!is.null(pattern)) {
[10:30:52.946]                           computeRestarts <- base::computeRestarts
[10:30:52.946]                           grepl <- base::grepl
[10:30:52.946]                           restarts <- computeRestarts(cond)
[10:30:52.946]                           for (restart in restarts) {
[10:30:52.946]                             name <- restart$name
[10:30:52.946]                             if (is.null(name)) 
[10:30:52.946]                               next
[10:30:52.946]                             if (!grepl(pattern, name)) 
[10:30:52.946]                               next
[10:30:52.946]                             invokeRestart(restart)
[10:30:52.946]                             muffled <- TRUE
[10:30:52.946]                             break
[10:30:52.946]                           }
[10:30:52.946]                         }
[10:30:52.946]                       }
[10:30:52.946]                       invisible(muffled)
[10:30:52.946]                     }
[10:30:52.946]                     muffleCondition(cond, pattern = "^muffle")
[10:30:52.946]                   }
[10:30:52.946]                 }
[10:30:52.946]             }
[10:30:52.946]         }))
[10:30:52.946]     }, error = function(ex) {
[10:30:52.946]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:52.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:52.946]                 ...future.rng), started = ...future.startTime, 
[10:30:52.946]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:52.946]             version = "1.8"), class = "FutureResult")
[10:30:52.946]     }, finally = {
[10:30:52.946]         if (!identical(...future.workdir, getwd())) 
[10:30:52.946]             setwd(...future.workdir)
[10:30:52.946]         {
[10:30:52.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:52.946]                 ...future.oldOptions$nwarnings <- NULL
[10:30:52.946]             }
[10:30:52.946]             base::options(...future.oldOptions)
[10:30:52.946]             if (.Platform$OS.type == "windows") {
[10:30:52.946]                 old_names <- names(...future.oldEnvVars)
[10:30:52.946]                 envs <- base::Sys.getenv()
[10:30:52.946]                 names <- names(envs)
[10:30:52.946]                 common <- intersect(names, old_names)
[10:30:52.946]                 added <- setdiff(names, old_names)
[10:30:52.946]                 removed <- setdiff(old_names, names)
[10:30:52.946]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:52.946]                   envs[common]]
[10:30:52.946]                 NAMES <- toupper(changed)
[10:30:52.946]                 args <- list()
[10:30:52.946]                 for (kk in seq_along(NAMES)) {
[10:30:52.946]                   name <- changed[[kk]]
[10:30:52.946]                   NAME <- NAMES[[kk]]
[10:30:52.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.946]                     next
[10:30:52.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.946]                 }
[10:30:52.946]                 NAMES <- toupper(added)
[10:30:52.946]                 for (kk in seq_along(NAMES)) {
[10:30:52.946]                   name <- added[[kk]]
[10:30:52.946]                   NAME <- NAMES[[kk]]
[10:30:52.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.946]                     next
[10:30:52.946]                   args[[name]] <- ""
[10:30:52.946]                 }
[10:30:52.946]                 NAMES <- toupper(removed)
[10:30:52.946]                 for (kk in seq_along(NAMES)) {
[10:30:52.946]                   name <- removed[[kk]]
[10:30:52.946]                   NAME <- NAMES[[kk]]
[10:30:52.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:52.946]                     next
[10:30:52.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:52.946]                 }
[10:30:52.946]                 if (length(args) > 0) 
[10:30:52.946]                   base::do.call(base::Sys.setenv, args = args)
[10:30:52.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:52.946]             }
[10:30:52.946]             else {
[10:30:52.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:52.946]             }
[10:30:52.946]             {
[10:30:52.946]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:52.946]                   0L) {
[10:30:52.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:52.946]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:52.946]                   base::options(opts)
[10:30:52.946]                 }
[10:30:52.946]                 {
[10:30:52.946]                   {
[10:30:52.946]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:52.946]                     NULL
[10:30:52.946]                   }
[10:30:52.946]                   options(future.plan = NULL)
[10:30:52.946]                   if (is.na(NA_character_)) 
[10:30:52.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:52.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:52.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:52.946]                     .init = FALSE)
[10:30:52.946]                 }
[10:30:52.946]             }
[10:30:52.946]         }
[10:30:52.946]     })
[10:30:52.946]     if (TRUE) {
[10:30:52.946]         base::sink(type = "output", split = FALSE)
[10:30:52.946]         if (TRUE) {
[10:30:52.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:52.946]         }
[10:30:52.946]         else {
[10:30:52.946]             ...future.result["stdout"] <- base::list(NULL)
[10:30:52.946]         }
[10:30:52.946]         base::close(...future.stdout)
[10:30:52.946]         ...future.stdout <- NULL
[10:30:52.946]     }
[10:30:52.946]     ...future.result$conditions <- ...future.conditions
[10:30:52.946]     ...future.result$finished <- base::Sys.time()
[10:30:52.946]     ...future.result
[10:30:52.946] }
[10:30:52.949] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[10:30:52.949] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[10:30:52.950] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[10:30:52.950] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:52.950] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:52.950] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[10:30:52.951] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[10:30:52.951] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:52.951] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:52.951] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:52.952] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:52.952] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[10:30:52.952] MultisessionFuture started
[10:30:52.952] - Launch lazy future ... done
[10:30:52.952] run() for ‘MultisessionFuture’ ... done
[10:30:52.953] Created future:
[10:30:52.953] MultisessionFuture:
[10:30:52.953] Label: ‘future_mapply-2’
[10:30:52.953] Expression:
[10:30:52.953] {
[10:30:52.953]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:52.953]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:52.953]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:52.953]         on.exit(options(oopts), add = TRUE)
[10:30:52.953]     }
[10:30:52.953]     {
[10:30:52.953]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:52.953]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:52.953]         do.call(mapply, args = args)
[10:30:52.953]     }
[10:30:52.953] }
[10:30:52.953] Lazy evaluation: FALSE
[10:30:52.953] Asynchronous evaluation: TRUE
[10:30:52.953] Local evaluation: TRUE
[10:30:52.953] Environment: R_GlobalEnv
[10:30:52.953] Capture standard output: TRUE
[10:30:52.953] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:52.953] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:52.953] Packages: <none>
[10:30:52.953] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:52.953] Resolved: FALSE
[10:30:52.953] Value: <not collected>
[10:30:52.953] Conditions captured: <none>
[10:30:52.953] Early signaling: FALSE
[10:30:52.953] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:52.953] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:52.964] Chunk #2 of 2 ... DONE
[10:30:52.964] Launching 2 futures (chunks) ... DONE
[10:30:52.964] Resolving 2 futures (chunks) ...
[10:30:52.965] resolve() on list ...
[10:30:52.965]  recursive: 0
[10:30:52.965]  length: 2
[10:30:52.965] 
[10:30:52.965] receiveMessageFromWorker() for ClusterFuture ...
[10:30:52.966] - Validating connection of MultisessionFuture
[10:30:52.966] - received message: FutureResult
[10:30:52.966] - Received FutureResult
[10:30:52.966] - Erased future from FutureRegistry
[10:30:52.966] result() for ClusterFuture ...
[10:30:52.966] - result already collected: FutureResult
[10:30:52.966] result() for ClusterFuture ... done
[10:30:52.966] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:52.966] Future #1
[10:30:52.967] result() for ClusterFuture ...
[10:30:52.967] - result already collected: FutureResult
[10:30:52.967] result() for ClusterFuture ... done
[10:30:52.967] result() for ClusterFuture ...
[10:30:52.967] - result already collected: FutureResult
[10:30:52.967] result() for ClusterFuture ... done
[10:30:52.967] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:52.967] - nx: 2
[10:30:52.967] - relay: TRUE
[10:30:52.967] - stdout: TRUE
[10:30:52.967] - signal: TRUE
[10:30:52.967] - resignal: FALSE
[10:30:52.968] - force: TRUE
[10:30:52.968] - relayed: [n=2] FALSE, FALSE
[10:30:52.968] - queued futures: [n=2] FALSE, FALSE
[10:30:52.968]  - until=1
[10:30:52.968]  - relaying element #1
[10:30:52.968] result() for ClusterFuture ...
[10:30:52.968] - result already collected: FutureResult
[10:30:52.968] result() for ClusterFuture ... done
[10:30:52.968] result() for ClusterFuture ...
[10:30:52.968] - result already collected: FutureResult
[10:30:52.968] result() for ClusterFuture ... done
[10:30:52.969] result() for ClusterFuture ...
[10:30:52.969] - result already collected: FutureResult
[10:30:52.969] result() for ClusterFuture ... done
[10:30:52.969] result() for ClusterFuture ...
[10:30:52.969] - result already collected: FutureResult
[10:30:52.969] result() for ClusterFuture ... done
[10:30:52.969] - relayed: [n=2] TRUE, FALSE
[10:30:52.969] - queued futures: [n=2] TRUE, FALSE
[10:30:52.969] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:52.969]  length: 1 (resolved future 1)
[10:30:52.995] receiveMessageFromWorker() for ClusterFuture ...
[10:30:52.995] - Validating connection of MultisessionFuture
[10:30:52.995] - received message: FutureResult
[10:30:52.995] - Received FutureResult
[10:30:52.995] - Erased future from FutureRegistry
[10:30:52.995] result() for ClusterFuture ...
[10:30:52.995] - result already collected: FutureResult
[10:30:52.995] result() for ClusterFuture ... done
[10:30:52.996] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:52.996] Future #2
[10:30:52.996] result() for ClusterFuture ...
[10:30:52.996] - result already collected: FutureResult
[10:30:52.996] result() for ClusterFuture ... done
[10:30:52.996] result() for ClusterFuture ...
[10:30:52.996] - result already collected: FutureResult
[10:30:52.996] result() for ClusterFuture ... done
[10:30:52.996] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:52.996] - nx: 2
[10:30:52.996] - relay: TRUE
[10:30:52.997] - stdout: TRUE
[10:30:52.997] - signal: TRUE
[10:30:52.997] - resignal: FALSE
[10:30:52.997] - force: TRUE
[10:30:52.997] - relayed: [n=2] TRUE, FALSE
[10:30:52.997] - queued futures: [n=2] TRUE, FALSE
[10:30:52.997]  - until=2
[10:30:52.997]  - relaying element #2
[10:30:52.997] result() for ClusterFuture ...
[10:30:52.997] - result already collected: FutureResult
[10:30:52.997] result() for ClusterFuture ... done
[10:30:52.998] result() for ClusterFuture ...
[10:30:52.998] - result already collected: FutureResult
[10:30:52.998] result() for ClusterFuture ... done
[10:30:52.998] result() for ClusterFuture ...
[10:30:52.998] - result already collected: FutureResult
[10:30:52.998] result() for ClusterFuture ... done
[10:30:52.998] result() for ClusterFuture ...
[10:30:52.998] - result already collected: FutureResult
[10:30:52.998] result() for ClusterFuture ... done
[10:30:52.998] - relayed: [n=2] TRUE, TRUE
[10:30:52.998] - queued futures: [n=2] TRUE, TRUE
[10:30:52.999] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:52.999]  length: 0 (resolved future 2)
[10:30:52.999] Relaying remaining futures
[10:30:52.999] signalConditionsASAP(NULL, pos=0) ...
[10:30:52.999] - nx: 2
[10:30:52.999] - relay: TRUE
[10:30:52.999] - stdout: TRUE
[10:30:52.999] - signal: TRUE
[10:30:52.999] - resignal: FALSE
[10:30:52.999] - force: TRUE
[10:30:52.999] - relayed: [n=2] TRUE, TRUE
[10:30:52.999] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:53.000] - relayed: [n=2] TRUE, TRUE
[10:30:53.000] - queued futures: [n=2] TRUE, TRUE
[10:30:53.000] signalConditionsASAP(NULL, pos=0) ... done
[10:30:53.000] resolve() on list ... DONE
[10:30:53.000] result() for ClusterFuture ...
[10:30:53.000] - result already collected: FutureResult
[10:30:53.000] result() for ClusterFuture ... done
[10:30:53.000] result() for ClusterFuture ...
[10:30:53.000] - result already collected: FutureResult
[10:30:53.000] result() for ClusterFuture ... done
[10:30:53.001] result() for ClusterFuture ...
[10:30:53.001] - result already collected: FutureResult
[10:30:53.001] result() for ClusterFuture ... done
[10:30:53.001] result() for ClusterFuture ...
[10:30:53.001] - result already collected: FutureResult
[10:30:53.001] result() for ClusterFuture ... done
[10:30:53.001]  - Number of value chunks collected: 2
[10:30:53.001] Resolving 2 futures (chunks) ... DONE
[10:30:53.001] Reducing values from 2 chunks ...
[10:30:53.001]  - Number of values collected after concatenation: 4
[10:30:53.002]  - Number of values expected: 4
[10:30:53.002] Reducing values from 2 chunks ... DONE
[10:30:53.002] future_mapply() ... DONE
[10:30:53.002] future_mapply() ...
[10:30:53.006] Number of chunks: 2
[10:30:53.006] getGlobalsAndPackagesXApply() ...
[10:30:53.006]  - future.globals: TRUE
[10:30:53.006] getGlobalsAndPackages() ...
[10:30:53.006] Searching for globals...
[10:30:53.007] - globals found: [1] ‘FUN’
[10:30:53.007] Searching for globals ... DONE
[10:30:53.007] Resolving globals: FALSE
[10:30:53.008] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:53.008] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:53.008] - globals: [1] ‘FUN’
[10:30:53.008] 
[10:30:53.008] getGlobalsAndPackages() ... DONE
[10:30:53.008]  - globals found/used: [n=1] ‘FUN’
[10:30:53.008]  - needed namespaces: [n=0] 
[10:30:53.008] Finding globals ... DONE
[10:30:53.009] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:53.009] List of 2
[10:30:53.009]  $ ...future.FUN:function (x, ...)  
[10:30:53.009]  $ MoreArgs     :List of 1
[10:30:53.009]   ..$ x: num 42
[10:30:53.009]  - attr(*, "where")=List of 2
[10:30:53.009]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:53.009]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:53.009]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:53.009]  - attr(*, "resolved")= logi FALSE
[10:30:53.009]  - attr(*, "total_size")= num NA
[10:30:53.012] Packages to be attached in all futures: [n=0] 
[10:30:53.012] getGlobalsAndPackagesXApply() ... DONE
[10:30:53.012] Number of futures (= number of chunks): 2
[10:30:53.012] Launching 2 futures (chunks) ...
[10:30:53.012] Chunk #1 of 2 ...
[10:30:53.012]  - Finding globals in '...' for chunk #1 ...
[10:30:53.012] getGlobalsAndPackages() ...
[10:30:53.012] Searching for globals...
[10:30:53.013] 
[10:30:53.013] Searching for globals ... DONE
[10:30:53.013] - globals: [0] <none>
[10:30:53.013] getGlobalsAndPackages() ... DONE
[10:30:53.013]    + additional globals found: [n=0] 
[10:30:53.013]    + additional namespaces needed: [n=0] 
[10:30:53.013]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:53.013]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:53.014]  - seeds: <none>
[10:30:53.014]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.014] getGlobalsAndPackages() ...
[10:30:53.014] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.014] Resolving globals: FALSE
[10:30:53.014] The total size of the 5 globals is 224 bytes (224 bytes)
[10:30:53.015] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:53.015] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.015] 
[10:30:53.015] getGlobalsAndPackages() ... DONE
[10:30:53.015] run() for ‘Future’ ...
[10:30:53.016] - state: ‘created’
[10:30:53.016] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.030] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.030] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.030]   - Field: ‘node’
[10:30:53.030]   - Field: ‘label’
[10:30:53.030]   - Field: ‘local’
[10:30:53.031]   - Field: ‘owner’
[10:30:53.031]   - Field: ‘envir’
[10:30:53.031]   - Field: ‘workers’
[10:30:53.031]   - Field: ‘packages’
[10:30:53.031]   - Field: ‘gc’
[10:30:53.031]   - Field: ‘conditions’
[10:30:53.031]   - Field: ‘persistent’
[10:30:53.031]   - Field: ‘expr’
[10:30:53.031]   - Field: ‘uuid’
[10:30:53.031]   - Field: ‘seed’
[10:30:53.032]   - Field: ‘version’
[10:30:53.032]   - Field: ‘result’
[10:30:53.032]   - Field: ‘asynchronous’
[10:30:53.032]   - Field: ‘calls’
[10:30:53.032]   - Field: ‘globals’
[10:30:53.032]   - Field: ‘stdout’
[10:30:53.032]   - Field: ‘earlySignal’
[10:30:53.032]   - Field: ‘lazy’
[10:30:53.032]   - Field: ‘state’
[10:30:53.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.032] - Launch lazy future ...
[10:30:53.033] Packages needed by the future expression (n = 0): <none>
[10:30:53.033] Packages needed by future strategies (n = 0): <none>
[10:30:53.033] {
[10:30:53.033]     {
[10:30:53.033]         {
[10:30:53.033]             ...future.startTime <- base::Sys.time()
[10:30:53.033]             {
[10:30:53.033]                 {
[10:30:53.033]                   {
[10:30:53.033]                     {
[10:30:53.033]                       base::local({
[10:30:53.033]                         has_future <- base::requireNamespace("future", 
[10:30:53.033]                           quietly = TRUE)
[10:30:53.033]                         if (has_future) {
[10:30:53.033]                           ns <- base::getNamespace("future")
[10:30:53.033]                           version <- ns[[".package"]][["version"]]
[10:30:53.033]                           if (is.null(version)) 
[10:30:53.033]                             version <- utils::packageVersion("future")
[10:30:53.033]                         }
[10:30:53.033]                         else {
[10:30:53.033]                           version <- NULL
[10:30:53.033]                         }
[10:30:53.033]                         if (!has_future || version < "1.8.0") {
[10:30:53.033]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.033]                             "", base::R.version$version.string), 
[10:30:53.033]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.033]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.033]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.033]                               "release", "version")], collapse = " "), 
[10:30:53.033]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.033]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.033]                             info)
[10:30:53.033]                           info <- base::paste(info, collapse = "; ")
[10:30:53.033]                           if (!has_future) {
[10:30:53.033]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.033]                               info)
[10:30:53.033]                           }
[10:30:53.033]                           else {
[10:30:53.033]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.033]                               info, version)
[10:30:53.033]                           }
[10:30:53.033]                           base::stop(msg)
[10:30:53.033]                         }
[10:30:53.033]                       })
[10:30:53.033]                     }
[10:30:53.033]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.033]                     base::options(mc.cores = 1L)
[10:30:53.033]                   }
[10:30:53.033]                   ...future.strategy.old <- future::plan("list")
[10:30:53.033]                   options(future.plan = NULL)
[10:30:53.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.033]                 }
[10:30:53.033]                 ...future.workdir <- getwd()
[10:30:53.033]             }
[10:30:53.033]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.033]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.033]         }
[10:30:53.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.033]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:53.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.033]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.033]             base::names(...future.oldOptions))
[10:30:53.033]     }
[10:30:53.033]     if (FALSE) {
[10:30:53.033]     }
[10:30:53.033]     else {
[10:30:53.033]         if (TRUE) {
[10:30:53.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.033]                 open = "w")
[10:30:53.033]         }
[10:30:53.033]         else {
[10:30:53.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.033]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.033]         }
[10:30:53.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.033]             base::sink(type = "output", split = FALSE)
[10:30:53.033]             base::close(...future.stdout)
[10:30:53.033]         }, add = TRUE)
[10:30:53.033]     }
[10:30:53.033]     ...future.frame <- base::sys.nframe()
[10:30:53.033]     ...future.conditions <- base::list()
[10:30:53.033]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.033]     if (FALSE) {
[10:30:53.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.033]     }
[10:30:53.033]     ...future.result <- base::tryCatch({
[10:30:53.033]         base::withCallingHandlers({
[10:30:53.033]             ...future.value <- base::withVisible(base::local({
[10:30:53.033]                 ...future.makeSendCondition <- base::local({
[10:30:53.033]                   sendCondition <- NULL
[10:30:53.033]                   function(frame = 1L) {
[10:30:53.033]                     if (is.function(sendCondition)) 
[10:30:53.033]                       return(sendCondition)
[10:30:53.033]                     ns <- getNamespace("parallel")
[10:30:53.033]                     if (exists("sendData", mode = "function", 
[10:30:53.033]                       envir = ns)) {
[10:30:53.033]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.033]                         envir = ns)
[10:30:53.033]                       envir <- sys.frame(frame)
[10:30:53.033]                       master <- NULL
[10:30:53.033]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.033]                         !identical(envir, emptyenv())) {
[10:30:53.033]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.033]                           inherits = FALSE)) {
[10:30:53.033]                           master <- get("master", mode = "list", 
[10:30:53.033]                             envir = envir, inherits = FALSE)
[10:30:53.033]                           if (inherits(master, c("SOCKnode", 
[10:30:53.033]                             "SOCK0node"))) {
[10:30:53.033]                             sendCondition <<- function(cond) {
[10:30:53.033]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.033]                                 success = TRUE)
[10:30:53.033]                               parallel_sendData(master, data)
[10:30:53.033]                             }
[10:30:53.033]                             return(sendCondition)
[10:30:53.033]                           }
[10:30:53.033]                         }
[10:30:53.033]                         frame <- frame + 1L
[10:30:53.033]                         envir <- sys.frame(frame)
[10:30:53.033]                       }
[10:30:53.033]                     }
[10:30:53.033]                     sendCondition <<- function(cond) NULL
[10:30:53.033]                   }
[10:30:53.033]                 })
[10:30:53.033]                 withCallingHandlers({
[10:30:53.033]                   {
[10:30:53.033]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.033]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.033]                       ...future.globals.maxSize)) {
[10:30:53.033]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.033]                       on.exit(options(oopts), add = TRUE)
[10:30:53.033]                     }
[10:30:53.033]                     {
[10:30:53.033]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.033]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.033]                         USE.NAMES = FALSE)
[10:30:53.033]                       do.call(mapply, args = args)
[10:30:53.033]                     }
[10:30:53.033]                   }
[10:30:53.033]                 }, immediateCondition = function(cond) {
[10:30:53.033]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.033]                   sendCondition(cond)
[10:30:53.033]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.033]                   {
[10:30:53.033]                     inherits <- base::inherits
[10:30:53.033]                     invokeRestart <- base::invokeRestart
[10:30:53.033]                     is.null <- base::is.null
[10:30:53.033]                     muffled <- FALSE
[10:30:53.033]                     if (inherits(cond, "message")) {
[10:30:53.033]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.033]                       if (muffled) 
[10:30:53.033]                         invokeRestart("muffleMessage")
[10:30:53.033]                     }
[10:30:53.033]                     else if (inherits(cond, "warning")) {
[10:30:53.033]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.033]                       if (muffled) 
[10:30:53.033]                         invokeRestart("muffleWarning")
[10:30:53.033]                     }
[10:30:53.033]                     else if (inherits(cond, "condition")) {
[10:30:53.033]                       if (!is.null(pattern)) {
[10:30:53.033]                         computeRestarts <- base::computeRestarts
[10:30:53.033]                         grepl <- base::grepl
[10:30:53.033]                         restarts <- computeRestarts(cond)
[10:30:53.033]                         for (restart in restarts) {
[10:30:53.033]                           name <- restart$name
[10:30:53.033]                           if (is.null(name)) 
[10:30:53.033]                             next
[10:30:53.033]                           if (!grepl(pattern, name)) 
[10:30:53.033]                             next
[10:30:53.033]                           invokeRestart(restart)
[10:30:53.033]                           muffled <- TRUE
[10:30:53.033]                           break
[10:30:53.033]                         }
[10:30:53.033]                       }
[10:30:53.033]                     }
[10:30:53.033]                     invisible(muffled)
[10:30:53.033]                   }
[10:30:53.033]                   muffleCondition(cond)
[10:30:53.033]                 })
[10:30:53.033]             }))
[10:30:53.033]             future::FutureResult(value = ...future.value$value, 
[10:30:53.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.033]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.033]                     ...future.globalenv.names))
[10:30:53.033]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.033]         }, condition = base::local({
[10:30:53.033]             c <- base::c
[10:30:53.033]             inherits <- base::inherits
[10:30:53.033]             invokeRestart <- base::invokeRestart
[10:30:53.033]             length <- base::length
[10:30:53.033]             list <- base::list
[10:30:53.033]             seq.int <- base::seq.int
[10:30:53.033]             signalCondition <- base::signalCondition
[10:30:53.033]             sys.calls <- base::sys.calls
[10:30:53.033]             `[[` <- base::`[[`
[10:30:53.033]             `+` <- base::`+`
[10:30:53.033]             `<<-` <- base::`<<-`
[10:30:53.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.033]                   3L)]
[10:30:53.033]             }
[10:30:53.033]             function(cond) {
[10:30:53.033]                 is_error <- inherits(cond, "error")
[10:30:53.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.033]                   NULL)
[10:30:53.033]                 if (is_error) {
[10:30:53.033]                   sessionInformation <- function() {
[10:30:53.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.033]                       search = base::search(), system = base::Sys.info())
[10:30:53.033]                   }
[10:30:53.033]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.033]                     cond$call), session = sessionInformation(), 
[10:30:53.033]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.033]                   signalCondition(cond)
[10:30:53.033]                 }
[10:30:53.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.033]                 "immediateCondition"))) {
[10:30:53.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.033]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.033]                   if (TRUE && !signal) {
[10:30:53.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.033]                     {
[10:30:53.033]                       inherits <- base::inherits
[10:30:53.033]                       invokeRestart <- base::invokeRestart
[10:30:53.033]                       is.null <- base::is.null
[10:30:53.033]                       muffled <- FALSE
[10:30:53.033]                       if (inherits(cond, "message")) {
[10:30:53.033]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.033]                         if (muffled) 
[10:30:53.033]                           invokeRestart("muffleMessage")
[10:30:53.033]                       }
[10:30:53.033]                       else if (inherits(cond, "warning")) {
[10:30:53.033]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.033]                         if (muffled) 
[10:30:53.033]                           invokeRestart("muffleWarning")
[10:30:53.033]                       }
[10:30:53.033]                       else if (inherits(cond, "condition")) {
[10:30:53.033]                         if (!is.null(pattern)) {
[10:30:53.033]                           computeRestarts <- base::computeRestarts
[10:30:53.033]                           grepl <- base::grepl
[10:30:53.033]                           restarts <- computeRestarts(cond)
[10:30:53.033]                           for (restart in restarts) {
[10:30:53.033]                             name <- restart$name
[10:30:53.033]                             if (is.null(name)) 
[10:30:53.033]                               next
[10:30:53.033]                             if (!grepl(pattern, name)) 
[10:30:53.033]                               next
[10:30:53.033]                             invokeRestart(restart)
[10:30:53.033]                             muffled <- TRUE
[10:30:53.033]                             break
[10:30:53.033]                           }
[10:30:53.033]                         }
[10:30:53.033]                       }
[10:30:53.033]                       invisible(muffled)
[10:30:53.033]                     }
[10:30:53.033]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.033]                   }
[10:30:53.033]                 }
[10:30:53.033]                 else {
[10:30:53.033]                   if (TRUE) {
[10:30:53.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.033]                     {
[10:30:53.033]                       inherits <- base::inherits
[10:30:53.033]                       invokeRestart <- base::invokeRestart
[10:30:53.033]                       is.null <- base::is.null
[10:30:53.033]                       muffled <- FALSE
[10:30:53.033]                       if (inherits(cond, "message")) {
[10:30:53.033]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.033]                         if (muffled) 
[10:30:53.033]                           invokeRestart("muffleMessage")
[10:30:53.033]                       }
[10:30:53.033]                       else if (inherits(cond, "warning")) {
[10:30:53.033]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.033]                         if (muffled) 
[10:30:53.033]                           invokeRestart("muffleWarning")
[10:30:53.033]                       }
[10:30:53.033]                       else if (inherits(cond, "condition")) {
[10:30:53.033]                         if (!is.null(pattern)) {
[10:30:53.033]                           computeRestarts <- base::computeRestarts
[10:30:53.033]                           grepl <- base::grepl
[10:30:53.033]                           restarts <- computeRestarts(cond)
[10:30:53.033]                           for (restart in restarts) {
[10:30:53.033]                             name <- restart$name
[10:30:53.033]                             if (is.null(name)) 
[10:30:53.033]                               next
[10:30:53.033]                             if (!grepl(pattern, name)) 
[10:30:53.033]                               next
[10:30:53.033]                             invokeRestart(restart)
[10:30:53.033]                             muffled <- TRUE
[10:30:53.033]                             break
[10:30:53.033]                           }
[10:30:53.033]                         }
[10:30:53.033]                       }
[10:30:53.033]                       invisible(muffled)
[10:30:53.033]                     }
[10:30:53.033]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.033]                   }
[10:30:53.033]                 }
[10:30:53.033]             }
[10:30:53.033]         }))
[10:30:53.033]     }, error = function(ex) {
[10:30:53.033]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.033]                 ...future.rng), started = ...future.startTime, 
[10:30:53.033]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.033]             version = "1.8"), class = "FutureResult")
[10:30:53.033]     }, finally = {
[10:30:53.033]         if (!identical(...future.workdir, getwd())) 
[10:30:53.033]             setwd(...future.workdir)
[10:30:53.033]         {
[10:30:53.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.033]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.033]             }
[10:30:53.033]             base::options(...future.oldOptions)
[10:30:53.033]             if (.Platform$OS.type == "windows") {
[10:30:53.033]                 old_names <- names(...future.oldEnvVars)
[10:30:53.033]                 envs <- base::Sys.getenv()
[10:30:53.033]                 names <- names(envs)
[10:30:53.033]                 common <- intersect(names, old_names)
[10:30:53.033]                 added <- setdiff(names, old_names)
[10:30:53.033]                 removed <- setdiff(old_names, names)
[10:30:53.033]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.033]                   envs[common]]
[10:30:53.033]                 NAMES <- toupper(changed)
[10:30:53.033]                 args <- list()
[10:30:53.033]                 for (kk in seq_along(NAMES)) {
[10:30:53.033]                   name <- changed[[kk]]
[10:30:53.033]                   NAME <- NAMES[[kk]]
[10:30:53.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.033]                     next
[10:30:53.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.033]                 }
[10:30:53.033]                 NAMES <- toupper(added)
[10:30:53.033]                 for (kk in seq_along(NAMES)) {
[10:30:53.033]                   name <- added[[kk]]
[10:30:53.033]                   NAME <- NAMES[[kk]]
[10:30:53.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.033]                     next
[10:30:53.033]                   args[[name]] <- ""
[10:30:53.033]                 }
[10:30:53.033]                 NAMES <- toupper(removed)
[10:30:53.033]                 for (kk in seq_along(NAMES)) {
[10:30:53.033]                   name <- removed[[kk]]
[10:30:53.033]                   NAME <- NAMES[[kk]]
[10:30:53.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.033]                     next
[10:30:53.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.033]                 }
[10:30:53.033]                 if (length(args) > 0) 
[10:30:53.033]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.033]             }
[10:30:53.033]             else {
[10:30:53.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.033]             }
[10:30:53.033]             {
[10:30:53.033]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.033]                   0L) {
[10:30:53.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.033]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.033]                   base::options(opts)
[10:30:53.033]                 }
[10:30:53.033]                 {
[10:30:53.033]                   {
[10:30:53.033]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.033]                     NULL
[10:30:53.033]                   }
[10:30:53.033]                   options(future.plan = NULL)
[10:30:53.033]                   if (is.na(NA_character_)) 
[10:30:53.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.033]                     .init = FALSE)
[10:30:53.033]                 }
[10:30:53.033]             }
[10:30:53.033]         }
[10:30:53.033]     })
[10:30:53.033]     if (TRUE) {
[10:30:53.033]         base::sink(type = "output", split = FALSE)
[10:30:53.033]         if (TRUE) {
[10:30:53.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.033]         }
[10:30:53.033]         else {
[10:30:53.033]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.033]         }
[10:30:53.033]         base::close(...future.stdout)
[10:30:53.033]         ...future.stdout <- NULL
[10:30:53.033]     }
[10:30:53.033]     ...future.result$conditions <- ...future.conditions
[10:30:53.033]     ...future.result$finished <- base::Sys.time()
[10:30:53.033]     ...future.result
[10:30:53.033] }
[10:30:53.036] Exporting 5 global objects (224 bytes) to cluster node #1 ...
[10:30:53.036] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[10:30:53.037] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[10:30:53.037] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[10:30:53.037] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[10:30:53.037] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:30:53.038] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:30:53.038] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:53.038] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.038] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:53.039] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.039] Exporting 5 global objects (224 bytes) to cluster node #1 ... DONE
[10:30:53.040] MultisessionFuture started
[10:30:53.040] - Launch lazy future ... done
[10:30:53.040] run() for ‘MultisessionFuture’ ... done
[10:30:53.040] Created future:
[10:30:53.040] MultisessionFuture:
[10:30:53.040] Label: ‘future_mapply-1’
[10:30:53.040] Expression:
[10:30:53.040] {
[10:30:53.040]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.040]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.040]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.040]         on.exit(options(oopts), add = TRUE)
[10:30:53.040]     }
[10:30:53.040]     {
[10:30:53.040]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.040]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.040]         do.call(mapply, args = args)
[10:30:53.040]     }
[10:30:53.040] }
[10:30:53.040] Lazy evaluation: FALSE
[10:30:53.040] Asynchronous evaluation: TRUE
[10:30:53.040] Local evaluation: TRUE
[10:30:53.040] Environment: R_GlobalEnv
[10:30:53.040] Capture standard output: TRUE
[10:30:53.040] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.040] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.040] Packages: <none>
[10:30:53.040] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.040] Resolved: FALSE
[10:30:53.040] Value: <not collected>
[10:30:53.040] Conditions captured: <none>
[10:30:53.040] Early signaling: FALSE
[10:30:53.040] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.040] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.052] Chunk #1 of 2 ... DONE
[10:30:53.052] Chunk #2 of 2 ...
[10:30:53.052]  - Finding globals in '...' for chunk #2 ...
[10:30:53.052] getGlobalsAndPackages() ...
[10:30:53.052] Searching for globals...
[10:30:53.053] 
[10:30:53.053] Searching for globals ... DONE
[10:30:53.053] - globals: [0] <none>
[10:30:53.053] getGlobalsAndPackages() ... DONE
[10:30:53.053]    + additional globals found: [n=0] 
[10:30:53.053]    + additional namespaces needed: [n=0] 
[10:30:53.053]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:53.053]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:53.053]  - seeds: <none>
[10:30:53.053]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.054] getGlobalsAndPackages() ...
[10:30:53.054] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.054] Resolving globals: FALSE
[10:30:53.054] The total size of the 5 globals is 224 bytes (224 bytes)
[10:30:53.055] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:53.055] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.055] 
[10:30:53.055] getGlobalsAndPackages() ... DONE
[10:30:53.055] run() for ‘Future’ ...
[10:30:53.055] - state: ‘created’
[10:30:53.056] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.071] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.071]   - Field: ‘node’
[10:30:53.071]   - Field: ‘label’
[10:30:53.071]   - Field: ‘local’
[10:30:53.071]   - Field: ‘owner’
[10:30:53.072]   - Field: ‘envir’
[10:30:53.072]   - Field: ‘workers’
[10:30:53.072]   - Field: ‘packages’
[10:30:53.072]   - Field: ‘gc’
[10:30:53.072]   - Field: ‘conditions’
[10:30:53.072]   - Field: ‘persistent’
[10:30:53.072]   - Field: ‘expr’
[10:30:53.072]   - Field: ‘uuid’
[10:30:53.072]   - Field: ‘seed’
[10:30:53.072]   - Field: ‘version’
[10:30:53.073]   - Field: ‘result’
[10:30:53.073]   - Field: ‘asynchronous’
[10:30:53.073]   - Field: ‘calls’
[10:30:53.073]   - Field: ‘globals’
[10:30:53.073]   - Field: ‘stdout’
[10:30:53.073]   - Field: ‘earlySignal’
[10:30:53.073]   - Field: ‘lazy’
[10:30:53.073]   - Field: ‘state’
[10:30:53.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.073] - Launch lazy future ...
[10:30:53.074] Packages needed by the future expression (n = 0): <none>
[10:30:53.074] Packages needed by future strategies (n = 0): <none>
[10:30:53.074] {
[10:30:53.074]     {
[10:30:53.074]         {
[10:30:53.074]             ...future.startTime <- base::Sys.time()
[10:30:53.074]             {
[10:30:53.074]                 {
[10:30:53.074]                   {
[10:30:53.074]                     {
[10:30:53.074]                       base::local({
[10:30:53.074]                         has_future <- base::requireNamespace("future", 
[10:30:53.074]                           quietly = TRUE)
[10:30:53.074]                         if (has_future) {
[10:30:53.074]                           ns <- base::getNamespace("future")
[10:30:53.074]                           version <- ns[[".package"]][["version"]]
[10:30:53.074]                           if (is.null(version)) 
[10:30:53.074]                             version <- utils::packageVersion("future")
[10:30:53.074]                         }
[10:30:53.074]                         else {
[10:30:53.074]                           version <- NULL
[10:30:53.074]                         }
[10:30:53.074]                         if (!has_future || version < "1.8.0") {
[10:30:53.074]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.074]                             "", base::R.version$version.string), 
[10:30:53.074]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.074]                               "release", "version")], collapse = " "), 
[10:30:53.074]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.074]                             info)
[10:30:53.074]                           info <- base::paste(info, collapse = "; ")
[10:30:53.074]                           if (!has_future) {
[10:30:53.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.074]                               info)
[10:30:53.074]                           }
[10:30:53.074]                           else {
[10:30:53.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.074]                               info, version)
[10:30:53.074]                           }
[10:30:53.074]                           base::stop(msg)
[10:30:53.074]                         }
[10:30:53.074]                       })
[10:30:53.074]                     }
[10:30:53.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.074]                     base::options(mc.cores = 1L)
[10:30:53.074]                   }
[10:30:53.074]                   ...future.strategy.old <- future::plan("list")
[10:30:53.074]                   options(future.plan = NULL)
[10:30:53.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.074]                 }
[10:30:53.074]                 ...future.workdir <- getwd()
[10:30:53.074]             }
[10:30:53.074]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.074]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.074]         }
[10:30:53.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.074]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:53.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.074]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.074]             base::names(...future.oldOptions))
[10:30:53.074]     }
[10:30:53.074]     if (FALSE) {
[10:30:53.074]     }
[10:30:53.074]     else {
[10:30:53.074]         if (TRUE) {
[10:30:53.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.074]                 open = "w")
[10:30:53.074]         }
[10:30:53.074]         else {
[10:30:53.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.074]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.074]         }
[10:30:53.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.074]             base::sink(type = "output", split = FALSE)
[10:30:53.074]             base::close(...future.stdout)
[10:30:53.074]         }, add = TRUE)
[10:30:53.074]     }
[10:30:53.074]     ...future.frame <- base::sys.nframe()
[10:30:53.074]     ...future.conditions <- base::list()
[10:30:53.074]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.074]     if (FALSE) {
[10:30:53.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.074]     }
[10:30:53.074]     ...future.result <- base::tryCatch({
[10:30:53.074]         base::withCallingHandlers({
[10:30:53.074]             ...future.value <- base::withVisible(base::local({
[10:30:53.074]                 ...future.makeSendCondition <- base::local({
[10:30:53.074]                   sendCondition <- NULL
[10:30:53.074]                   function(frame = 1L) {
[10:30:53.074]                     if (is.function(sendCondition)) 
[10:30:53.074]                       return(sendCondition)
[10:30:53.074]                     ns <- getNamespace("parallel")
[10:30:53.074]                     if (exists("sendData", mode = "function", 
[10:30:53.074]                       envir = ns)) {
[10:30:53.074]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.074]                         envir = ns)
[10:30:53.074]                       envir <- sys.frame(frame)
[10:30:53.074]                       master <- NULL
[10:30:53.074]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.074]                         !identical(envir, emptyenv())) {
[10:30:53.074]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.074]                           inherits = FALSE)) {
[10:30:53.074]                           master <- get("master", mode = "list", 
[10:30:53.074]                             envir = envir, inherits = FALSE)
[10:30:53.074]                           if (inherits(master, c("SOCKnode", 
[10:30:53.074]                             "SOCK0node"))) {
[10:30:53.074]                             sendCondition <<- function(cond) {
[10:30:53.074]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.074]                                 success = TRUE)
[10:30:53.074]                               parallel_sendData(master, data)
[10:30:53.074]                             }
[10:30:53.074]                             return(sendCondition)
[10:30:53.074]                           }
[10:30:53.074]                         }
[10:30:53.074]                         frame <- frame + 1L
[10:30:53.074]                         envir <- sys.frame(frame)
[10:30:53.074]                       }
[10:30:53.074]                     }
[10:30:53.074]                     sendCondition <<- function(cond) NULL
[10:30:53.074]                   }
[10:30:53.074]                 })
[10:30:53.074]                 withCallingHandlers({
[10:30:53.074]                   {
[10:30:53.074]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.074]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.074]                       ...future.globals.maxSize)) {
[10:30:53.074]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.074]                       on.exit(options(oopts), add = TRUE)
[10:30:53.074]                     }
[10:30:53.074]                     {
[10:30:53.074]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.074]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.074]                         USE.NAMES = FALSE)
[10:30:53.074]                       do.call(mapply, args = args)
[10:30:53.074]                     }
[10:30:53.074]                   }
[10:30:53.074]                 }, immediateCondition = function(cond) {
[10:30:53.074]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.074]                   sendCondition(cond)
[10:30:53.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.074]                   {
[10:30:53.074]                     inherits <- base::inherits
[10:30:53.074]                     invokeRestart <- base::invokeRestart
[10:30:53.074]                     is.null <- base::is.null
[10:30:53.074]                     muffled <- FALSE
[10:30:53.074]                     if (inherits(cond, "message")) {
[10:30:53.074]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.074]                       if (muffled) 
[10:30:53.074]                         invokeRestart("muffleMessage")
[10:30:53.074]                     }
[10:30:53.074]                     else if (inherits(cond, "warning")) {
[10:30:53.074]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.074]                       if (muffled) 
[10:30:53.074]                         invokeRestart("muffleWarning")
[10:30:53.074]                     }
[10:30:53.074]                     else if (inherits(cond, "condition")) {
[10:30:53.074]                       if (!is.null(pattern)) {
[10:30:53.074]                         computeRestarts <- base::computeRestarts
[10:30:53.074]                         grepl <- base::grepl
[10:30:53.074]                         restarts <- computeRestarts(cond)
[10:30:53.074]                         for (restart in restarts) {
[10:30:53.074]                           name <- restart$name
[10:30:53.074]                           if (is.null(name)) 
[10:30:53.074]                             next
[10:30:53.074]                           if (!grepl(pattern, name)) 
[10:30:53.074]                             next
[10:30:53.074]                           invokeRestart(restart)
[10:30:53.074]                           muffled <- TRUE
[10:30:53.074]                           break
[10:30:53.074]                         }
[10:30:53.074]                       }
[10:30:53.074]                     }
[10:30:53.074]                     invisible(muffled)
[10:30:53.074]                   }
[10:30:53.074]                   muffleCondition(cond)
[10:30:53.074]                 })
[10:30:53.074]             }))
[10:30:53.074]             future::FutureResult(value = ...future.value$value, 
[10:30:53.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.074]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.074]                     ...future.globalenv.names))
[10:30:53.074]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.074]         }, condition = base::local({
[10:30:53.074]             c <- base::c
[10:30:53.074]             inherits <- base::inherits
[10:30:53.074]             invokeRestart <- base::invokeRestart
[10:30:53.074]             length <- base::length
[10:30:53.074]             list <- base::list
[10:30:53.074]             seq.int <- base::seq.int
[10:30:53.074]             signalCondition <- base::signalCondition
[10:30:53.074]             sys.calls <- base::sys.calls
[10:30:53.074]             `[[` <- base::`[[`
[10:30:53.074]             `+` <- base::`+`
[10:30:53.074]             `<<-` <- base::`<<-`
[10:30:53.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.074]                   3L)]
[10:30:53.074]             }
[10:30:53.074]             function(cond) {
[10:30:53.074]                 is_error <- inherits(cond, "error")
[10:30:53.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.074]                   NULL)
[10:30:53.074]                 if (is_error) {
[10:30:53.074]                   sessionInformation <- function() {
[10:30:53.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.074]                       search = base::search(), system = base::Sys.info())
[10:30:53.074]                   }
[10:30:53.074]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.074]                     cond$call), session = sessionInformation(), 
[10:30:53.074]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.074]                   signalCondition(cond)
[10:30:53.074]                 }
[10:30:53.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.074]                 "immediateCondition"))) {
[10:30:53.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.074]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.074]                   if (TRUE && !signal) {
[10:30:53.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.074]                     {
[10:30:53.074]                       inherits <- base::inherits
[10:30:53.074]                       invokeRestart <- base::invokeRestart
[10:30:53.074]                       is.null <- base::is.null
[10:30:53.074]                       muffled <- FALSE
[10:30:53.074]                       if (inherits(cond, "message")) {
[10:30:53.074]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.074]                         if (muffled) 
[10:30:53.074]                           invokeRestart("muffleMessage")
[10:30:53.074]                       }
[10:30:53.074]                       else if (inherits(cond, "warning")) {
[10:30:53.074]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.074]                         if (muffled) 
[10:30:53.074]                           invokeRestart("muffleWarning")
[10:30:53.074]                       }
[10:30:53.074]                       else if (inherits(cond, "condition")) {
[10:30:53.074]                         if (!is.null(pattern)) {
[10:30:53.074]                           computeRestarts <- base::computeRestarts
[10:30:53.074]                           grepl <- base::grepl
[10:30:53.074]                           restarts <- computeRestarts(cond)
[10:30:53.074]                           for (restart in restarts) {
[10:30:53.074]                             name <- restart$name
[10:30:53.074]                             if (is.null(name)) 
[10:30:53.074]                               next
[10:30:53.074]                             if (!grepl(pattern, name)) 
[10:30:53.074]                               next
[10:30:53.074]                             invokeRestart(restart)
[10:30:53.074]                             muffled <- TRUE
[10:30:53.074]                             break
[10:30:53.074]                           }
[10:30:53.074]                         }
[10:30:53.074]                       }
[10:30:53.074]                       invisible(muffled)
[10:30:53.074]                     }
[10:30:53.074]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.074]                   }
[10:30:53.074]                 }
[10:30:53.074]                 else {
[10:30:53.074]                   if (TRUE) {
[10:30:53.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.074]                     {
[10:30:53.074]                       inherits <- base::inherits
[10:30:53.074]                       invokeRestart <- base::invokeRestart
[10:30:53.074]                       is.null <- base::is.null
[10:30:53.074]                       muffled <- FALSE
[10:30:53.074]                       if (inherits(cond, "message")) {
[10:30:53.074]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.074]                         if (muffled) 
[10:30:53.074]                           invokeRestart("muffleMessage")
[10:30:53.074]                       }
[10:30:53.074]                       else if (inherits(cond, "warning")) {
[10:30:53.074]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.074]                         if (muffled) 
[10:30:53.074]                           invokeRestart("muffleWarning")
[10:30:53.074]                       }
[10:30:53.074]                       else if (inherits(cond, "condition")) {
[10:30:53.074]                         if (!is.null(pattern)) {
[10:30:53.074]                           computeRestarts <- base::computeRestarts
[10:30:53.074]                           grepl <- base::grepl
[10:30:53.074]                           restarts <- computeRestarts(cond)
[10:30:53.074]                           for (restart in restarts) {
[10:30:53.074]                             name <- restart$name
[10:30:53.074]                             if (is.null(name)) 
[10:30:53.074]                               next
[10:30:53.074]                             if (!grepl(pattern, name)) 
[10:30:53.074]                               next
[10:30:53.074]                             invokeRestart(restart)
[10:30:53.074]                             muffled <- TRUE
[10:30:53.074]                             break
[10:30:53.074]                           }
[10:30:53.074]                         }
[10:30:53.074]                       }
[10:30:53.074]                       invisible(muffled)
[10:30:53.074]                     }
[10:30:53.074]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.074]                   }
[10:30:53.074]                 }
[10:30:53.074]             }
[10:30:53.074]         }))
[10:30:53.074]     }, error = function(ex) {
[10:30:53.074]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.074]                 ...future.rng), started = ...future.startTime, 
[10:30:53.074]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.074]             version = "1.8"), class = "FutureResult")
[10:30:53.074]     }, finally = {
[10:30:53.074]         if (!identical(...future.workdir, getwd())) 
[10:30:53.074]             setwd(...future.workdir)
[10:30:53.074]         {
[10:30:53.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.074]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.074]             }
[10:30:53.074]             base::options(...future.oldOptions)
[10:30:53.074]             if (.Platform$OS.type == "windows") {
[10:30:53.074]                 old_names <- names(...future.oldEnvVars)
[10:30:53.074]                 envs <- base::Sys.getenv()
[10:30:53.074]                 names <- names(envs)
[10:30:53.074]                 common <- intersect(names, old_names)
[10:30:53.074]                 added <- setdiff(names, old_names)
[10:30:53.074]                 removed <- setdiff(old_names, names)
[10:30:53.074]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.074]                   envs[common]]
[10:30:53.074]                 NAMES <- toupper(changed)
[10:30:53.074]                 args <- list()
[10:30:53.074]                 for (kk in seq_along(NAMES)) {
[10:30:53.074]                   name <- changed[[kk]]
[10:30:53.074]                   NAME <- NAMES[[kk]]
[10:30:53.074]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.074]                     next
[10:30:53.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.074]                 }
[10:30:53.074]                 NAMES <- toupper(added)
[10:30:53.074]                 for (kk in seq_along(NAMES)) {
[10:30:53.074]                   name <- added[[kk]]
[10:30:53.074]                   NAME <- NAMES[[kk]]
[10:30:53.074]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.074]                     next
[10:30:53.074]                   args[[name]] <- ""
[10:30:53.074]                 }
[10:30:53.074]                 NAMES <- toupper(removed)
[10:30:53.074]                 for (kk in seq_along(NAMES)) {
[10:30:53.074]                   name <- removed[[kk]]
[10:30:53.074]                   NAME <- NAMES[[kk]]
[10:30:53.074]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.074]                     next
[10:30:53.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.074]                 }
[10:30:53.074]                 if (length(args) > 0) 
[10:30:53.074]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.074]             }
[10:30:53.074]             else {
[10:30:53.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.074]             }
[10:30:53.074]             {
[10:30:53.074]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.074]                   0L) {
[10:30:53.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.074]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.074]                   base::options(opts)
[10:30:53.074]                 }
[10:30:53.074]                 {
[10:30:53.074]                   {
[10:30:53.074]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.074]                     NULL
[10:30:53.074]                   }
[10:30:53.074]                   options(future.plan = NULL)
[10:30:53.074]                   if (is.na(NA_character_)) 
[10:30:53.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.074]                     .init = FALSE)
[10:30:53.074]                 }
[10:30:53.074]             }
[10:30:53.074]         }
[10:30:53.074]     })
[10:30:53.074]     if (TRUE) {
[10:30:53.074]         base::sink(type = "output", split = FALSE)
[10:30:53.074]         if (TRUE) {
[10:30:53.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.074]         }
[10:30:53.074]         else {
[10:30:53.074]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.074]         }
[10:30:53.074]         base::close(...future.stdout)
[10:30:53.074]         ...future.stdout <- NULL
[10:30:53.074]     }
[10:30:53.074]     ...future.result$conditions <- ...future.conditions
[10:30:53.074]     ...future.result$finished <- base::Sys.time()
[10:30:53.074]     ...future.result
[10:30:53.074] }
[10:30:53.077] Exporting 5 global objects (224 bytes) to cluster node #2 ...
[10:30:53.077] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[10:30:53.078] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[10:30:53.078] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[10:30:53.078] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[10:30:53.079] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:30:53.079] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:30:53.079] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:53.079] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.080] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:53.080] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.080] Exporting 5 global objects (224 bytes) to cluster node #2 ... DONE
[10:30:53.081] MultisessionFuture started
[10:30:53.081] - Launch lazy future ... done
[10:30:53.081] run() for ‘MultisessionFuture’ ... done
[10:30:53.081] Created future:
[10:30:53.081] MultisessionFuture:
[10:30:53.081] Label: ‘future_mapply-2’
[10:30:53.081] Expression:
[10:30:53.081] {
[10:30:53.081]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.081]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.081]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.081]         on.exit(options(oopts), add = TRUE)
[10:30:53.081]     }
[10:30:53.081]     {
[10:30:53.081]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.081]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.081]         do.call(mapply, args = args)
[10:30:53.081]     }
[10:30:53.081] }
[10:30:53.081] Lazy evaluation: FALSE
[10:30:53.081] Asynchronous evaluation: TRUE
[10:30:53.081] Local evaluation: TRUE
[10:30:53.081] Environment: R_GlobalEnv
[10:30:53.081] Capture standard output: TRUE
[10:30:53.081] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.081] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.081] Packages: <none>
[10:30:53.081] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.081] Resolved: FALSE
[10:30:53.081] Value: <not collected>
[10:30:53.081] Conditions captured: <none>
[10:30:53.081] Early signaling: FALSE
[10:30:53.081] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.081] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.093] Chunk #2 of 2 ... DONE
[10:30:53.093] Launching 2 futures (chunks) ... DONE
[10:30:53.093] Resolving 2 futures (chunks) ...
[10:30:53.093] resolve() on list ...
[10:30:53.093]  recursive: 0
[10:30:53.093]  length: 2
[10:30:53.094] 
[10:30:53.094] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.094] - Validating connection of MultisessionFuture
[10:30:53.094] - received message: FutureResult
[10:30:53.095] - Received FutureResult
[10:30:53.095] - Erased future from FutureRegistry
[10:30:53.095] result() for ClusterFuture ...
[10:30:53.095] - result already collected: FutureResult
[10:30:53.095] result() for ClusterFuture ... done
[10:30:53.095] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.095] Future #1
[10:30:53.095] result() for ClusterFuture ...
[10:30:53.095] - result already collected: FutureResult
[10:30:53.095] result() for ClusterFuture ... done
[10:30:53.095] result() for ClusterFuture ...
[10:30:53.096] - result already collected: FutureResult
[10:30:53.096] result() for ClusterFuture ... done
[10:30:53.098] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:53.098] - nx: 2
[10:30:53.098] - relay: TRUE
[10:30:53.098] - stdout: TRUE
[10:30:53.098] - signal: TRUE
[10:30:53.099] - resignal: FALSE
[10:30:53.099] - force: TRUE
[10:30:53.099] - relayed: [n=2] FALSE, FALSE
[10:30:53.099] - queued futures: [n=2] FALSE, FALSE
[10:30:53.099]  - until=1
[10:30:53.099]  - relaying element #1
[10:30:53.099] result() for ClusterFuture ...
[10:30:53.099] - result already collected: FutureResult
[10:30:53.099] result() for ClusterFuture ... done
[10:30:53.099] result() for ClusterFuture ...
[10:30:53.099] - result already collected: FutureResult
[10:30:53.099] result() for ClusterFuture ... done
[10:30:53.100] result() for ClusterFuture ...
[10:30:53.100] - result already collected: FutureResult
[10:30:53.100] result() for ClusterFuture ... done
[10:30:53.100] result() for ClusterFuture ...
[10:30:53.100] - result already collected: FutureResult
[10:30:53.100] result() for ClusterFuture ... done
[10:30:53.100] - relayed: [n=2] TRUE, FALSE
[10:30:53.100] - queued futures: [n=2] TRUE, FALSE
[10:30:53.100] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:53.100]  length: 1 (resolved future 1)
[10:30:53.123] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.123] - Validating connection of MultisessionFuture
[10:30:53.123] - received message: FutureResult
[10:30:53.123] - Received FutureResult
[10:30:53.123] - Erased future from FutureRegistry
[10:30:53.123] result() for ClusterFuture ...
[10:30:53.123] - result already collected: FutureResult
[10:30:53.124] result() for ClusterFuture ... done
[10:30:53.124] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.124] Future #2
[10:30:53.124] result() for ClusterFuture ...
[10:30:53.124] - result already collected: FutureResult
[10:30:53.124] result() for ClusterFuture ... done
[10:30:53.124] result() for ClusterFuture ...
[10:30:53.124] - result already collected: FutureResult
[10:30:53.124] result() for ClusterFuture ... done
[10:30:53.124] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:53.124] - nx: 2
[10:30:53.125] - relay: TRUE
[10:30:53.125] - stdout: TRUE
[10:30:53.125] - signal: TRUE
[10:30:53.125] - resignal: FALSE
[10:30:53.125] - force: TRUE
[10:30:53.125] - relayed: [n=2] TRUE, FALSE
[10:30:53.125] - queued futures: [n=2] TRUE, FALSE
[10:30:53.125]  - until=2
[10:30:53.125]  - relaying element #2
[10:30:53.125] result() for ClusterFuture ...
[10:30:53.125] - result already collected: FutureResult
[10:30:53.126] result() for ClusterFuture ... done
[10:30:53.126] result() for ClusterFuture ...
[10:30:53.126] - result already collected: FutureResult
[10:30:53.126] result() for ClusterFuture ... done
[10:30:53.126] result() for ClusterFuture ...
[10:30:53.126] - result already collected: FutureResult
[10:30:53.126] result() for ClusterFuture ... done
[10:30:53.126] result() for ClusterFuture ...
[10:30:53.126] - result already collected: FutureResult
[10:30:53.126] result() for ClusterFuture ... done
[10:30:53.126] - relayed: [n=2] TRUE, TRUE
[10:30:53.126] - queued futures: [n=2] TRUE, TRUE
[10:30:53.127] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:53.127]  length: 0 (resolved future 2)
[10:30:53.127] Relaying remaining futures
[10:30:53.127] signalConditionsASAP(NULL, pos=0) ...
[10:30:53.127] - nx: 2
[10:30:53.127] - relay: TRUE
[10:30:53.127] - stdout: TRUE
[10:30:53.127] - signal: TRUE
[10:30:53.127] - resignal: FALSE
[10:30:53.127] - force: TRUE
[10:30:53.127] - relayed: [n=2] TRUE, TRUE
[10:30:53.127] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:53.128] - relayed: [n=2] TRUE, TRUE
[10:30:53.128] - queued futures: [n=2] TRUE, TRUE
[10:30:53.128] signalConditionsASAP(NULL, pos=0) ... done
[10:30:53.128] resolve() on list ... DONE
[10:30:53.128] result() for ClusterFuture ...
[10:30:53.128] - result already collected: FutureResult
[10:30:53.128] result() for ClusterFuture ... done
[10:30:53.128] result() for ClusterFuture ...
[10:30:53.128] - result already collected: FutureResult
[10:30:53.128] result() for ClusterFuture ... done
[10:30:53.128] result() for ClusterFuture ...
[10:30:53.129] - result already collected: FutureResult
[10:30:53.129] result() for ClusterFuture ... done
[10:30:53.129] result() for ClusterFuture ...
[10:30:53.129] - result already collected: FutureResult
[10:30:53.129] result() for ClusterFuture ... done
[10:30:53.129]  - Number of value chunks collected: 2
[10:30:53.129] Resolving 2 futures (chunks) ... DONE
[10:30:53.129] Reducing values from 2 chunks ...
[10:30:53.129]  - Number of values collected after concatenation: 4
[10:30:53.129]  - Number of values expected: 4
[10:30:53.129] Reducing values from 2 chunks ... DONE
[10:30:53.130] future_mapply() ... DONE
[10:30:53.130] future_mapply() ...
[10:30:53.133] Number of chunks: 2
[10:30:53.134] getGlobalsAndPackagesXApply() ...
[10:30:53.134]  - future.globals: TRUE
[10:30:53.134] getGlobalsAndPackages() ...
[10:30:53.134] Searching for globals...
[10:30:53.135] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:30:53.135] Searching for globals ... DONE
[10:30:53.135] Resolving globals: FALSE
[10:30:53.136] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[10:30:53.136] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[10:30:53.136] - globals: [1] ‘FUN’
[10:30:53.136] 
[10:30:53.136] getGlobalsAndPackages() ... DONE
[10:30:53.137]  - globals found/used: [n=1] ‘FUN’
[10:30:53.137]  - needed namespaces: [n=0] 
[10:30:53.137] Finding globals ... DONE
[10:30:53.137] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:53.137] List of 2
[10:30:53.137]  $ ...future.FUN:function (x, y)  
[10:30:53.137]  $ MoreArgs     : NULL
[10:30:53.137]  - attr(*, "where")=List of 2
[10:30:53.137]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:53.137]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:53.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:53.137]  - attr(*, "resolved")= logi FALSE
[10:30:53.137]  - attr(*, "total_size")= num NA
[10:30:53.139] Packages to be attached in all futures: [n=0] 
[10:30:53.140] getGlobalsAndPackagesXApply() ... DONE
[10:30:53.140] Number of futures (= number of chunks): 2
[10:30:53.140] Launching 2 futures (chunks) ...
[10:30:53.140] Chunk #1 of 2 ...
[10:30:53.140]  - Finding globals in '...' for chunk #1 ...
[10:30:53.140] getGlobalsAndPackages() ...
[10:30:53.140] Searching for globals...
[10:30:53.141] 
[10:30:53.141] Searching for globals ... DONE
[10:30:53.141] - globals: [0] <none>
[10:30:53.141] getGlobalsAndPackages() ... DONE
[10:30:53.141]    + additional globals found: [n=0] 
[10:30:53.141]    + additional namespaces needed: [n=0] 
[10:30:53.141]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:53.141]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:53.141]  - seeds: <none>
[10:30:53.141]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.142] getGlobalsAndPackages() ...
[10:30:53.142] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.142] Resolving globals: FALSE
[10:30:53.142] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[10:30:53.143] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:53.143] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.143] 
[10:30:53.143] getGlobalsAndPackages() ... DONE
[10:30:53.143] run() for ‘Future’ ...
[10:30:53.143] - state: ‘created’
[10:30:53.143] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.157] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.157] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.158]   - Field: ‘node’
[10:30:53.158]   - Field: ‘label’
[10:30:53.158]   - Field: ‘local’
[10:30:53.158]   - Field: ‘owner’
[10:30:53.158]   - Field: ‘envir’
[10:30:53.158]   - Field: ‘workers’
[10:30:53.158]   - Field: ‘packages’
[10:30:53.158]   - Field: ‘gc’
[10:30:53.158]   - Field: ‘conditions’
[10:30:53.158]   - Field: ‘persistent’
[10:30:53.158]   - Field: ‘expr’
[10:30:53.159]   - Field: ‘uuid’
[10:30:53.159]   - Field: ‘seed’
[10:30:53.159]   - Field: ‘version’
[10:30:53.159]   - Field: ‘result’
[10:30:53.159]   - Field: ‘asynchronous’
[10:30:53.159]   - Field: ‘calls’
[10:30:53.159]   - Field: ‘globals’
[10:30:53.159]   - Field: ‘stdout’
[10:30:53.159]   - Field: ‘earlySignal’
[10:30:53.159]   - Field: ‘lazy’
[10:30:53.159]   - Field: ‘state’
[10:30:53.160] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.160] - Launch lazy future ...
[10:30:53.160] Packages needed by the future expression (n = 0): <none>
[10:30:53.160] Packages needed by future strategies (n = 0): <none>
[10:30:53.160] {
[10:30:53.160]     {
[10:30:53.160]         {
[10:30:53.160]             ...future.startTime <- base::Sys.time()
[10:30:53.160]             {
[10:30:53.160]                 {
[10:30:53.160]                   {
[10:30:53.160]                     {
[10:30:53.160]                       base::local({
[10:30:53.160]                         has_future <- base::requireNamespace("future", 
[10:30:53.160]                           quietly = TRUE)
[10:30:53.160]                         if (has_future) {
[10:30:53.160]                           ns <- base::getNamespace("future")
[10:30:53.160]                           version <- ns[[".package"]][["version"]]
[10:30:53.160]                           if (is.null(version)) 
[10:30:53.160]                             version <- utils::packageVersion("future")
[10:30:53.160]                         }
[10:30:53.160]                         else {
[10:30:53.160]                           version <- NULL
[10:30:53.160]                         }
[10:30:53.160]                         if (!has_future || version < "1.8.0") {
[10:30:53.160]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.160]                             "", base::R.version$version.string), 
[10:30:53.160]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.160]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.160]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.160]                               "release", "version")], collapse = " "), 
[10:30:53.160]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.160]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.160]                             info)
[10:30:53.160]                           info <- base::paste(info, collapse = "; ")
[10:30:53.160]                           if (!has_future) {
[10:30:53.160]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.160]                               info)
[10:30:53.160]                           }
[10:30:53.160]                           else {
[10:30:53.160]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.160]                               info, version)
[10:30:53.160]                           }
[10:30:53.160]                           base::stop(msg)
[10:30:53.160]                         }
[10:30:53.160]                       })
[10:30:53.160]                     }
[10:30:53.160]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.160]                     base::options(mc.cores = 1L)
[10:30:53.160]                   }
[10:30:53.160]                   ...future.strategy.old <- future::plan("list")
[10:30:53.160]                   options(future.plan = NULL)
[10:30:53.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.160]                 }
[10:30:53.160]                 ...future.workdir <- getwd()
[10:30:53.160]             }
[10:30:53.160]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.160]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.160]         }
[10:30:53.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.160]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:53.160]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.160]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.160]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.160]             base::names(...future.oldOptions))
[10:30:53.160]     }
[10:30:53.160]     if (FALSE) {
[10:30:53.160]     }
[10:30:53.160]     else {
[10:30:53.160]         if (TRUE) {
[10:30:53.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.160]                 open = "w")
[10:30:53.160]         }
[10:30:53.160]         else {
[10:30:53.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.160]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.160]         }
[10:30:53.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.160]             base::sink(type = "output", split = FALSE)
[10:30:53.160]             base::close(...future.stdout)
[10:30:53.160]         }, add = TRUE)
[10:30:53.160]     }
[10:30:53.160]     ...future.frame <- base::sys.nframe()
[10:30:53.160]     ...future.conditions <- base::list()
[10:30:53.160]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.160]     if (FALSE) {
[10:30:53.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.160]     }
[10:30:53.160]     ...future.result <- base::tryCatch({
[10:30:53.160]         base::withCallingHandlers({
[10:30:53.160]             ...future.value <- base::withVisible(base::local({
[10:30:53.160]                 ...future.makeSendCondition <- base::local({
[10:30:53.160]                   sendCondition <- NULL
[10:30:53.160]                   function(frame = 1L) {
[10:30:53.160]                     if (is.function(sendCondition)) 
[10:30:53.160]                       return(sendCondition)
[10:30:53.160]                     ns <- getNamespace("parallel")
[10:30:53.160]                     if (exists("sendData", mode = "function", 
[10:30:53.160]                       envir = ns)) {
[10:30:53.160]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.160]                         envir = ns)
[10:30:53.160]                       envir <- sys.frame(frame)
[10:30:53.160]                       master <- NULL
[10:30:53.160]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.160]                         !identical(envir, emptyenv())) {
[10:30:53.160]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.160]                           inherits = FALSE)) {
[10:30:53.160]                           master <- get("master", mode = "list", 
[10:30:53.160]                             envir = envir, inherits = FALSE)
[10:30:53.160]                           if (inherits(master, c("SOCKnode", 
[10:30:53.160]                             "SOCK0node"))) {
[10:30:53.160]                             sendCondition <<- function(cond) {
[10:30:53.160]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.160]                                 success = TRUE)
[10:30:53.160]                               parallel_sendData(master, data)
[10:30:53.160]                             }
[10:30:53.160]                             return(sendCondition)
[10:30:53.160]                           }
[10:30:53.160]                         }
[10:30:53.160]                         frame <- frame + 1L
[10:30:53.160]                         envir <- sys.frame(frame)
[10:30:53.160]                       }
[10:30:53.160]                     }
[10:30:53.160]                     sendCondition <<- function(cond) NULL
[10:30:53.160]                   }
[10:30:53.160]                 })
[10:30:53.160]                 withCallingHandlers({
[10:30:53.160]                   {
[10:30:53.160]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.160]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.160]                       ...future.globals.maxSize)) {
[10:30:53.160]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.160]                       on.exit(options(oopts), add = TRUE)
[10:30:53.160]                     }
[10:30:53.160]                     {
[10:30:53.160]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.160]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.160]                         USE.NAMES = FALSE)
[10:30:53.160]                       do.call(mapply, args = args)
[10:30:53.160]                     }
[10:30:53.160]                   }
[10:30:53.160]                 }, immediateCondition = function(cond) {
[10:30:53.160]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.160]                   sendCondition(cond)
[10:30:53.160]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.160]                   {
[10:30:53.160]                     inherits <- base::inherits
[10:30:53.160]                     invokeRestart <- base::invokeRestart
[10:30:53.160]                     is.null <- base::is.null
[10:30:53.160]                     muffled <- FALSE
[10:30:53.160]                     if (inherits(cond, "message")) {
[10:30:53.160]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.160]                       if (muffled) 
[10:30:53.160]                         invokeRestart("muffleMessage")
[10:30:53.160]                     }
[10:30:53.160]                     else if (inherits(cond, "warning")) {
[10:30:53.160]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.160]                       if (muffled) 
[10:30:53.160]                         invokeRestart("muffleWarning")
[10:30:53.160]                     }
[10:30:53.160]                     else if (inherits(cond, "condition")) {
[10:30:53.160]                       if (!is.null(pattern)) {
[10:30:53.160]                         computeRestarts <- base::computeRestarts
[10:30:53.160]                         grepl <- base::grepl
[10:30:53.160]                         restarts <- computeRestarts(cond)
[10:30:53.160]                         for (restart in restarts) {
[10:30:53.160]                           name <- restart$name
[10:30:53.160]                           if (is.null(name)) 
[10:30:53.160]                             next
[10:30:53.160]                           if (!grepl(pattern, name)) 
[10:30:53.160]                             next
[10:30:53.160]                           invokeRestart(restart)
[10:30:53.160]                           muffled <- TRUE
[10:30:53.160]                           break
[10:30:53.160]                         }
[10:30:53.160]                       }
[10:30:53.160]                     }
[10:30:53.160]                     invisible(muffled)
[10:30:53.160]                   }
[10:30:53.160]                   muffleCondition(cond)
[10:30:53.160]                 })
[10:30:53.160]             }))
[10:30:53.160]             future::FutureResult(value = ...future.value$value, 
[10:30:53.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.160]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.160]                     ...future.globalenv.names))
[10:30:53.160]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.160]         }, condition = base::local({
[10:30:53.160]             c <- base::c
[10:30:53.160]             inherits <- base::inherits
[10:30:53.160]             invokeRestart <- base::invokeRestart
[10:30:53.160]             length <- base::length
[10:30:53.160]             list <- base::list
[10:30:53.160]             seq.int <- base::seq.int
[10:30:53.160]             signalCondition <- base::signalCondition
[10:30:53.160]             sys.calls <- base::sys.calls
[10:30:53.160]             `[[` <- base::`[[`
[10:30:53.160]             `+` <- base::`+`
[10:30:53.160]             `<<-` <- base::`<<-`
[10:30:53.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.160]                   3L)]
[10:30:53.160]             }
[10:30:53.160]             function(cond) {
[10:30:53.160]                 is_error <- inherits(cond, "error")
[10:30:53.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.160]                   NULL)
[10:30:53.160]                 if (is_error) {
[10:30:53.160]                   sessionInformation <- function() {
[10:30:53.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.160]                       search = base::search(), system = base::Sys.info())
[10:30:53.160]                   }
[10:30:53.160]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.160]                     cond$call), session = sessionInformation(), 
[10:30:53.160]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.160]                   signalCondition(cond)
[10:30:53.160]                 }
[10:30:53.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.160]                 "immediateCondition"))) {
[10:30:53.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.160]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.160]                   if (TRUE && !signal) {
[10:30:53.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.160]                     {
[10:30:53.160]                       inherits <- base::inherits
[10:30:53.160]                       invokeRestart <- base::invokeRestart
[10:30:53.160]                       is.null <- base::is.null
[10:30:53.160]                       muffled <- FALSE
[10:30:53.160]                       if (inherits(cond, "message")) {
[10:30:53.160]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.160]                         if (muffled) 
[10:30:53.160]                           invokeRestart("muffleMessage")
[10:30:53.160]                       }
[10:30:53.160]                       else if (inherits(cond, "warning")) {
[10:30:53.160]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.160]                         if (muffled) 
[10:30:53.160]                           invokeRestart("muffleWarning")
[10:30:53.160]                       }
[10:30:53.160]                       else if (inherits(cond, "condition")) {
[10:30:53.160]                         if (!is.null(pattern)) {
[10:30:53.160]                           computeRestarts <- base::computeRestarts
[10:30:53.160]                           grepl <- base::grepl
[10:30:53.160]                           restarts <- computeRestarts(cond)
[10:30:53.160]                           for (restart in restarts) {
[10:30:53.160]                             name <- restart$name
[10:30:53.160]                             if (is.null(name)) 
[10:30:53.160]                               next
[10:30:53.160]                             if (!grepl(pattern, name)) 
[10:30:53.160]                               next
[10:30:53.160]                             invokeRestart(restart)
[10:30:53.160]                             muffled <- TRUE
[10:30:53.160]                             break
[10:30:53.160]                           }
[10:30:53.160]                         }
[10:30:53.160]                       }
[10:30:53.160]                       invisible(muffled)
[10:30:53.160]                     }
[10:30:53.160]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.160]                   }
[10:30:53.160]                 }
[10:30:53.160]                 else {
[10:30:53.160]                   if (TRUE) {
[10:30:53.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.160]                     {
[10:30:53.160]                       inherits <- base::inherits
[10:30:53.160]                       invokeRestart <- base::invokeRestart
[10:30:53.160]                       is.null <- base::is.null
[10:30:53.160]                       muffled <- FALSE
[10:30:53.160]                       if (inherits(cond, "message")) {
[10:30:53.160]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.160]                         if (muffled) 
[10:30:53.160]                           invokeRestart("muffleMessage")
[10:30:53.160]                       }
[10:30:53.160]                       else if (inherits(cond, "warning")) {
[10:30:53.160]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.160]                         if (muffled) 
[10:30:53.160]                           invokeRestart("muffleWarning")
[10:30:53.160]                       }
[10:30:53.160]                       else if (inherits(cond, "condition")) {
[10:30:53.160]                         if (!is.null(pattern)) {
[10:30:53.160]                           computeRestarts <- base::computeRestarts
[10:30:53.160]                           grepl <- base::grepl
[10:30:53.160]                           restarts <- computeRestarts(cond)
[10:30:53.160]                           for (restart in restarts) {
[10:30:53.160]                             name <- restart$name
[10:30:53.160]                             if (is.null(name)) 
[10:30:53.160]                               next
[10:30:53.160]                             if (!grepl(pattern, name)) 
[10:30:53.160]                               next
[10:30:53.160]                             invokeRestart(restart)
[10:30:53.160]                             muffled <- TRUE
[10:30:53.160]                             break
[10:30:53.160]                           }
[10:30:53.160]                         }
[10:30:53.160]                       }
[10:30:53.160]                       invisible(muffled)
[10:30:53.160]                     }
[10:30:53.160]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.160]                   }
[10:30:53.160]                 }
[10:30:53.160]             }
[10:30:53.160]         }))
[10:30:53.160]     }, error = function(ex) {
[10:30:53.160]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.160]                 ...future.rng), started = ...future.startTime, 
[10:30:53.160]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.160]             version = "1.8"), class = "FutureResult")
[10:30:53.160]     }, finally = {
[10:30:53.160]         if (!identical(...future.workdir, getwd())) 
[10:30:53.160]             setwd(...future.workdir)
[10:30:53.160]         {
[10:30:53.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.160]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.160]             }
[10:30:53.160]             base::options(...future.oldOptions)
[10:30:53.160]             if (.Platform$OS.type == "windows") {
[10:30:53.160]                 old_names <- names(...future.oldEnvVars)
[10:30:53.160]                 envs <- base::Sys.getenv()
[10:30:53.160]                 names <- names(envs)
[10:30:53.160]                 common <- intersect(names, old_names)
[10:30:53.160]                 added <- setdiff(names, old_names)
[10:30:53.160]                 removed <- setdiff(old_names, names)
[10:30:53.160]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.160]                   envs[common]]
[10:30:53.160]                 NAMES <- toupper(changed)
[10:30:53.160]                 args <- list()
[10:30:53.160]                 for (kk in seq_along(NAMES)) {
[10:30:53.160]                   name <- changed[[kk]]
[10:30:53.160]                   NAME <- NAMES[[kk]]
[10:30:53.160]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.160]                     next
[10:30:53.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.160]                 }
[10:30:53.160]                 NAMES <- toupper(added)
[10:30:53.160]                 for (kk in seq_along(NAMES)) {
[10:30:53.160]                   name <- added[[kk]]
[10:30:53.160]                   NAME <- NAMES[[kk]]
[10:30:53.160]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.160]                     next
[10:30:53.160]                   args[[name]] <- ""
[10:30:53.160]                 }
[10:30:53.160]                 NAMES <- toupper(removed)
[10:30:53.160]                 for (kk in seq_along(NAMES)) {
[10:30:53.160]                   name <- removed[[kk]]
[10:30:53.160]                   NAME <- NAMES[[kk]]
[10:30:53.160]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.160]                     next
[10:30:53.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.160]                 }
[10:30:53.160]                 if (length(args) > 0) 
[10:30:53.160]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.160]             }
[10:30:53.160]             else {
[10:30:53.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.160]             }
[10:30:53.160]             {
[10:30:53.160]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.160]                   0L) {
[10:30:53.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.160]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.160]                   base::options(opts)
[10:30:53.160]                 }
[10:30:53.160]                 {
[10:30:53.160]                   {
[10:30:53.160]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.160]                     NULL
[10:30:53.160]                   }
[10:30:53.160]                   options(future.plan = NULL)
[10:30:53.160]                   if (is.na(NA_character_)) 
[10:30:53.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.160]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.160]                     .init = FALSE)
[10:30:53.160]                 }
[10:30:53.160]             }
[10:30:53.160]         }
[10:30:53.160]     })
[10:30:53.160]     if (TRUE) {
[10:30:53.160]         base::sink(type = "output", split = FALSE)
[10:30:53.160]         if (TRUE) {
[10:30:53.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.160]         }
[10:30:53.160]         else {
[10:30:53.160]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.160]         }
[10:30:53.160]         base::close(...future.stdout)
[10:30:53.160]         ...future.stdout <- NULL
[10:30:53.160]     }
[10:30:53.160]     ...future.result$conditions <- ...future.conditions
[10:30:53.160]     ...future.result$finished <- base::Sys.time()
[10:30:53.160]     ...future.result
[10:30:53.160] }
[10:30:53.163] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[10:30:53.163] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[10:30:53.164] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[10:30:53.164] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:53.164] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.165] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:30:53.165] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:30:53.165] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:53.165] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.166] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:53.166] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.166] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[10:30:53.167] MultisessionFuture started
[10:30:53.167] - Launch lazy future ... done
[10:30:53.167] run() for ‘MultisessionFuture’ ... done
[10:30:53.167] Created future:
[10:30:53.167] MultisessionFuture:
[10:30:53.167] Label: ‘future_mapply-1’
[10:30:53.167] Expression:
[10:30:53.167] {
[10:30:53.167]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.167]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.167]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.167]         on.exit(options(oopts), add = TRUE)
[10:30:53.167]     }
[10:30:53.167]     {
[10:30:53.167]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.167]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.167]         do.call(mapply, args = args)
[10:30:53.167]     }
[10:30:53.167] }
[10:30:53.167] Lazy evaluation: FALSE
[10:30:53.167] Asynchronous evaluation: TRUE
[10:30:53.167] Local evaluation: TRUE
[10:30:53.167] Environment: R_GlobalEnv
[10:30:53.167] Capture standard output: TRUE
[10:30:53.167] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.167] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.167] Packages: <none>
[10:30:53.167] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.167] Resolved: FALSE
[10:30:53.167] Value: <not collected>
[10:30:53.167] Conditions captured: <none>
[10:30:53.167] Early signaling: FALSE
[10:30:53.167] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.167] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.179] Chunk #1 of 2 ... DONE
[10:30:53.179] Chunk #2 of 2 ...
[10:30:53.179]  - Finding globals in '...' for chunk #2 ...
[10:30:53.179] getGlobalsAndPackages() ...
[10:30:53.179] Searching for globals...
[10:30:53.180] 
[10:30:53.180] Searching for globals ... DONE
[10:30:53.180] - globals: [0] <none>
[10:30:53.180] getGlobalsAndPackages() ... DONE
[10:30:53.180]    + additional globals found: [n=0] 
[10:30:53.180]    + additional namespaces needed: [n=0] 
[10:30:53.180]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:53.180]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:53.180]  - seeds: <none>
[10:30:53.180]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.181] getGlobalsAndPackages() ...
[10:30:53.181] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.181] Resolving globals: FALSE
[10:30:53.181] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[10:30:53.182] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:53.182] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.182] 
[10:30:53.182] getGlobalsAndPackages() ... DONE
[10:30:53.182] run() for ‘Future’ ...
[10:30:53.183] - state: ‘created’
[10:30:53.183] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.197] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.197] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.197]   - Field: ‘node’
[10:30:53.197]   - Field: ‘label’
[10:30:53.197]   - Field: ‘local’
[10:30:53.198]   - Field: ‘owner’
[10:30:53.198]   - Field: ‘envir’
[10:30:53.198]   - Field: ‘workers’
[10:30:53.198]   - Field: ‘packages’
[10:30:53.198]   - Field: ‘gc’
[10:30:53.198]   - Field: ‘conditions’
[10:30:53.198]   - Field: ‘persistent’
[10:30:53.198]   - Field: ‘expr’
[10:30:53.198]   - Field: ‘uuid’
[10:30:53.198]   - Field: ‘seed’
[10:30:53.198]   - Field: ‘version’
[10:30:53.199]   - Field: ‘result’
[10:30:53.199]   - Field: ‘asynchronous’
[10:30:53.199]   - Field: ‘calls’
[10:30:53.199]   - Field: ‘globals’
[10:30:53.199]   - Field: ‘stdout’
[10:30:53.199]   - Field: ‘earlySignal’
[10:30:53.199]   - Field: ‘lazy’
[10:30:53.199]   - Field: ‘state’
[10:30:53.199] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.199] - Launch lazy future ...
[10:30:53.200] Packages needed by the future expression (n = 0): <none>
[10:30:53.200] Packages needed by future strategies (n = 0): <none>
[10:30:53.200] {
[10:30:53.200]     {
[10:30:53.200]         {
[10:30:53.200]             ...future.startTime <- base::Sys.time()
[10:30:53.200]             {
[10:30:53.200]                 {
[10:30:53.200]                   {
[10:30:53.200]                     {
[10:30:53.200]                       base::local({
[10:30:53.200]                         has_future <- base::requireNamespace("future", 
[10:30:53.200]                           quietly = TRUE)
[10:30:53.200]                         if (has_future) {
[10:30:53.200]                           ns <- base::getNamespace("future")
[10:30:53.200]                           version <- ns[[".package"]][["version"]]
[10:30:53.200]                           if (is.null(version)) 
[10:30:53.200]                             version <- utils::packageVersion("future")
[10:30:53.200]                         }
[10:30:53.200]                         else {
[10:30:53.200]                           version <- NULL
[10:30:53.200]                         }
[10:30:53.200]                         if (!has_future || version < "1.8.0") {
[10:30:53.200]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.200]                             "", base::R.version$version.string), 
[10:30:53.200]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.200]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.200]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.200]                               "release", "version")], collapse = " "), 
[10:30:53.200]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.200]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.200]                             info)
[10:30:53.200]                           info <- base::paste(info, collapse = "; ")
[10:30:53.200]                           if (!has_future) {
[10:30:53.200]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.200]                               info)
[10:30:53.200]                           }
[10:30:53.200]                           else {
[10:30:53.200]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.200]                               info, version)
[10:30:53.200]                           }
[10:30:53.200]                           base::stop(msg)
[10:30:53.200]                         }
[10:30:53.200]                       })
[10:30:53.200]                     }
[10:30:53.200]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.200]                     base::options(mc.cores = 1L)
[10:30:53.200]                   }
[10:30:53.200]                   ...future.strategy.old <- future::plan("list")
[10:30:53.200]                   options(future.plan = NULL)
[10:30:53.200]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.200]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.200]                 }
[10:30:53.200]                 ...future.workdir <- getwd()
[10:30:53.200]             }
[10:30:53.200]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.200]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.200]         }
[10:30:53.200]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.200]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:53.200]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.200]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.200]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.200]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.200]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.200]             base::names(...future.oldOptions))
[10:30:53.200]     }
[10:30:53.200]     if (FALSE) {
[10:30:53.200]     }
[10:30:53.200]     else {
[10:30:53.200]         if (TRUE) {
[10:30:53.200]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.200]                 open = "w")
[10:30:53.200]         }
[10:30:53.200]         else {
[10:30:53.200]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.200]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.200]         }
[10:30:53.200]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.200]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.200]             base::sink(type = "output", split = FALSE)
[10:30:53.200]             base::close(...future.stdout)
[10:30:53.200]         }, add = TRUE)
[10:30:53.200]     }
[10:30:53.200]     ...future.frame <- base::sys.nframe()
[10:30:53.200]     ...future.conditions <- base::list()
[10:30:53.200]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.200]     if (FALSE) {
[10:30:53.200]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.200]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.200]     }
[10:30:53.200]     ...future.result <- base::tryCatch({
[10:30:53.200]         base::withCallingHandlers({
[10:30:53.200]             ...future.value <- base::withVisible(base::local({
[10:30:53.200]                 ...future.makeSendCondition <- base::local({
[10:30:53.200]                   sendCondition <- NULL
[10:30:53.200]                   function(frame = 1L) {
[10:30:53.200]                     if (is.function(sendCondition)) 
[10:30:53.200]                       return(sendCondition)
[10:30:53.200]                     ns <- getNamespace("parallel")
[10:30:53.200]                     if (exists("sendData", mode = "function", 
[10:30:53.200]                       envir = ns)) {
[10:30:53.200]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.200]                         envir = ns)
[10:30:53.200]                       envir <- sys.frame(frame)
[10:30:53.200]                       master <- NULL
[10:30:53.200]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.200]                         !identical(envir, emptyenv())) {
[10:30:53.200]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.200]                           inherits = FALSE)) {
[10:30:53.200]                           master <- get("master", mode = "list", 
[10:30:53.200]                             envir = envir, inherits = FALSE)
[10:30:53.200]                           if (inherits(master, c("SOCKnode", 
[10:30:53.200]                             "SOCK0node"))) {
[10:30:53.200]                             sendCondition <<- function(cond) {
[10:30:53.200]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.200]                                 success = TRUE)
[10:30:53.200]                               parallel_sendData(master, data)
[10:30:53.200]                             }
[10:30:53.200]                             return(sendCondition)
[10:30:53.200]                           }
[10:30:53.200]                         }
[10:30:53.200]                         frame <- frame + 1L
[10:30:53.200]                         envir <- sys.frame(frame)
[10:30:53.200]                       }
[10:30:53.200]                     }
[10:30:53.200]                     sendCondition <<- function(cond) NULL
[10:30:53.200]                   }
[10:30:53.200]                 })
[10:30:53.200]                 withCallingHandlers({
[10:30:53.200]                   {
[10:30:53.200]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.200]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.200]                       ...future.globals.maxSize)) {
[10:30:53.200]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.200]                       on.exit(options(oopts), add = TRUE)
[10:30:53.200]                     }
[10:30:53.200]                     {
[10:30:53.200]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.200]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.200]                         USE.NAMES = FALSE)
[10:30:53.200]                       do.call(mapply, args = args)
[10:30:53.200]                     }
[10:30:53.200]                   }
[10:30:53.200]                 }, immediateCondition = function(cond) {
[10:30:53.200]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.200]                   sendCondition(cond)
[10:30:53.200]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.200]                   {
[10:30:53.200]                     inherits <- base::inherits
[10:30:53.200]                     invokeRestart <- base::invokeRestart
[10:30:53.200]                     is.null <- base::is.null
[10:30:53.200]                     muffled <- FALSE
[10:30:53.200]                     if (inherits(cond, "message")) {
[10:30:53.200]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.200]                       if (muffled) 
[10:30:53.200]                         invokeRestart("muffleMessage")
[10:30:53.200]                     }
[10:30:53.200]                     else if (inherits(cond, "warning")) {
[10:30:53.200]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.200]                       if (muffled) 
[10:30:53.200]                         invokeRestart("muffleWarning")
[10:30:53.200]                     }
[10:30:53.200]                     else if (inherits(cond, "condition")) {
[10:30:53.200]                       if (!is.null(pattern)) {
[10:30:53.200]                         computeRestarts <- base::computeRestarts
[10:30:53.200]                         grepl <- base::grepl
[10:30:53.200]                         restarts <- computeRestarts(cond)
[10:30:53.200]                         for (restart in restarts) {
[10:30:53.200]                           name <- restart$name
[10:30:53.200]                           if (is.null(name)) 
[10:30:53.200]                             next
[10:30:53.200]                           if (!grepl(pattern, name)) 
[10:30:53.200]                             next
[10:30:53.200]                           invokeRestart(restart)
[10:30:53.200]                           muffled <- TRUE
[10:30:53.200]                           break
[10:30:53.200]                         }
[10:30:53.200]                       }
[10:30:53.200]                     }
[10:30:53.200]                     invisible(muffled)
[10:30:53.200]                   }
[10:30:53.200]                   muffleCondition(cond)
[10:30:53.200]                 })
[10:30:53.200]             }))
[10:30:53.200]             future::FutureResult(value = ...future.value$value, 
[10:30:53.200]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.200]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.200]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.200]                     ...future.globalenv.names))
[10:30:53.200]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.200]         }, condition = base::local({
[10:30:53.200]             c <- base::c
[10:30:53.200]             inherits <- base::inherits
[10:30:53.200]             invokeRestart <- base::invokeRestart
[10:30:53.200]             length <- base::length
[10:30:53.200]             list <- base::list
[10:30:53.200]             seq.int <- base::seq.int
[10:30:53.200]             signalCondition <- base::signalCondition
[10:30:53.200]             sys.calls <- base::sys.calls
[10:30:53.200]             `[[` <- base::`[[`
[10:30:53.200]             `+` <- base::`+`
[10:30:53.200]             `<<-` <- base::`<<-`
[10:30:53.200]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.200]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.200]                   3L)]
[10:30:53.200]             }
[10:30:53.200]             function(cond) {
[10:30:53.200]                 is_error <- inherits(cond, "error")
[10:30:53.200]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.200]                   NULL)
[10:30:53.200]                 if (is_error) {
[10:30:53.200]                   sessionInformation <- function() {
[10:30:53.200]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.200]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.200]                       search = base::search(), system = base::Sys.info())
[10:30:53.200]                   }
[10:30:53.200]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.200]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.200]                     cond$call), session = sessionInformation(), 
[10:30:53.200]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.200]                   signalCondition(cond)
[10:30:53.200]                 }
[10:30:53.200]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.200]                 "immediateCondition"))) {
[10:30:53.200]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.200]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.200]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.200]                   if (TRUE && !signal) {
[10:30:53.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.200]                     {
[10:30:53.200]                       inherits <- base::inherits
[10:30:53.200]                       invokeRestart <- base::invokeRestart
[10:30:53.200]                       is.null <- base::is.null
[10:30:53.200]                       muffled <- FALSE
[10:30:53.200]                       if (inherits(cond, "message")) {
[10:30:53.200]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.200]                         if (muffled) 
[10:30:53.200]                           invokeRestart("muffleMessage")
[10:30:53.200]                       }
[10:30:53.200]                       else if (inherits(cond, "warning")) {
[10:30:53.200]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.200]                         if (muffled) 
[10:30:53.200]                           invokeRestart("muffleWarning")
[10:30:53.200]                       }
[10:30:53.200]                       else if (inherits(cond, "condition")) {
[10:30:53.200]                         if (!is.null(pattern)) {
[10:30:53.200]                           computeRestarts <- base::computeRestarts
[10:30:53.200]                           grepl <- base::grepl
[10:30:53.200]                           restarts <- computeRestarts(cond)
[10:30:53.200]                           for (restart in restarts) {
[10:30:53.200]                             name <- restart$name
[10:30:53.200]                             if (is.null(name)) 
[10:30:53.200]                               next
[10:30:53.200]                             if (!grepl(pattern, name)) 
[10:30:53.200]                               next
[10:30:53.200]                             invokeRestart(restart)
[10:30:53.200]                             muffled <- TRUE
[10:30:53.200]                             break
[10:30:53.200]                           }
[10:30:53.200]                         }
[10:30:53.200]                       }
[10:30:53.200]                       invisible(muffled)
[10:30:53.200]                     }
[10:30:53.200]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.200]                   }
[10:30:53.200]                 }
[10:30:53.200]                 else {
[10:30:53.200]                   if (TRUE) {
[10:30:53.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.200]                     {
[10:30:53.200]                       inherits <- base::inherits
[10:30:53.200]                       invokeRestart <- base::invokeRestart
[10:30:53.200]                       is.null <- base::is.null
[10:30:53.200]                       muffled <- FALSE
[10:30:53.200]                       if (inherits(cond, "message")) {
[10:30:53.200]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.200]                         if (muffled) 
[10:30:53.200]                           invokeRestart("muffleMessage")
[10:30:53.200]                       }
[10:30:53.200]                       else if (inherits(cond, "warning")) {
[10:30:53.200]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.200]                         if (muffled) 
[10:30:53.200]                           invokeRestart("muffleWarning")
[10:30:53.200]                       }
[10:30:53.200]                       else if (inherits(cond, "condition")) {
[10:30:53.200]                         if (!is.null(pattern)) {
[10:30:53.200]                           computeRestarts <- base::computeRestarts
[10:30:53.200]                           grepl <- base::grepl
[10:30:53.200]                           restarts <- computeRestarts(cond)
[10:30:53.200]                           for (restart in restarts) {
[10:30:53.200]                             name <- restart$name
[10:30:53.200]                             if (is.null(name)) 
[10:30:53.200]                               next
[10:30:53.200]                             if (!grepl(pattern, name)) 
[10:30:53.200]                               next
[10:30:53.200]                             invokeRestart(restart)
[10:30:53.200]                             muffled <- TRUE
[10:30:53.200]                             break
[10:30:53.200]                           }
[10:30:53.200]                         }
[10:30:53.200]                       }
[10:30:53.200]                       invisible(muffled)
[10:30:53.200]                     }
[10:30:53.200]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.200]                   }
[10:30:53.200]                 }
[10:30:53.200]             }
[10:30:53.200]         }))
[10:30:53.200]     }, error = function(ex) {
[10:30:53.200]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.200]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.200]                 ...future.rng), started = ...future.startTime, 
[10:30:53.200]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.200]             version = "1.8"), class = "FutureResult")
[10:30:53.200]     }, finally = {
[10:30:53.200]         if (!identical(...future.workdir, getwd())) 
[10:30:53.200]             setwd(...future.workdir)
[10:30:53.200]         {
[10:30:53.200]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.200]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.200]             }
[10:30:53.200]             base::options(...future.oldOptions)
[10:30:53.200]             if (.Platform$OS.type == "windows") {
[10:30:53.200]                 old_names <- names(...future.oldEnvVars)
[10:30:53.200]                 envs <- base::Sys.getenv()
[10:30:53.200]                 names <- names(envs)
[10:30:53.200]                 common <- intersect(names, old_names)
[10:30:53.200]                 added <- setdiff(names, old_names)
[10:30:53.200]                 removed <- setdiff(old_names, names)
[10:30:53.200]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.200]                   envs[common]]
[10:30:53.200]                 NAMES <- toupper(changed)
[10:30:53.200]                 args <- list()
[10:30:53.200]                 for (kk in seq_along(NAMES)) {
[10:30:53.200]                   name <- changed[[kk]]
[10:30:53.200]                   NAME <- NAMES[[kk]]
[10:30:53.200]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.200]                     next
[10:30:53.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.200]                 }
[10:30:53.200]                 NAMES <- toupper(added)
[10:30:53.200]                 for (kk in seq_along(NAMES)) {
[10:30:53.200]                   name <- added[[kk]]
[10:30:53.200]                   NAME <- NAMES[[kk]]
[10:30:53.200]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.200]                     next
[10:30:53.200]                   args[[name]] <- ""
[10:30:53.200]                 }
[10:30:53.200]                 NAMES <- toupper(removed)
[10:30:53.200]                 for (kk in seq_along(NAMES)) {
[10:30:53.200]                   name <- removed[[kk]]
[10:30:53.200]                   NAME <- NAMES[[kk]]
[10:30:53.200]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.200]                     next
[10:30:53.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.200]                 }
[10:30:53.200]                 if (length(args) > 0) 
[10:30:53.200]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.200]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.200]             }
[10:30:53.200]             else {
[10:30:53.200]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.200]             }
[10:30:53.200]             {
[10:30:53.200]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.200]                   0L) {
[10:30:53.200]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.200]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.200]                   base::options(opts)
[10:30:53.200]                 }
[10:30:53.200]                 {
[10:30:53.200]                   {
[10:30:53.200]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.200]                     NULL
[10:30:53.200]                   }
[10:30:53.200]                   options(future.plan = NULL)
[10:30:53.200]                   if (is.na(NA_character_)) 
[10:30:53.200]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.200]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.200]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.200]                     .init = FALSE)
[10:30:53.200]                 }
[10:30:53.200]             }
[10:30:53.200]         }
[10:30:53.200]     })
[10:30:53.200]     if (TRUE) {
[10:30:53.200]         base::sink(type = "output", split = FALSE)
[10:30:53.200]         if (TRUE) {
[10:30:53.200]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.200]         }
[10:30:53.200]         else {
[10:30:53.200]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.200]         }
[10:30:53.200]         base::close(...future.stdout)
[10:30:53.200]         ...future.stdout <- NULL
[10:30:53.200]     }
[10:30:53.200]     ...future.result$conditions <- ...future.conditions
[10:30:53.200]     ...future.result$finished <- base::Sys.time()
[10:30:53.200]     ...future.result
[10:30:53.200] }
[10:30:53.203] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[10:30:53.203] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[10:30:53.204] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[10:30:53.204] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:53.204] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.204] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[10:30:53.205] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[10:30:53.205] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:53.205] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.205] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:53.205] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.206] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[10:30:53.206] MultisessionFuture started
[10:30:53.206] - Launch lazy future ... done
[10:30:53.206] run() for ‘MultisessionFuture’ ... done
[10:30:53.206] Created future:
[10:30:53.206] MultisessionFuture:
[10:30:53.206] Label: ‘future_mapply-2’
[10:30:53.206] Expression:
[10:30:53.206] {
[10:30:53.206]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.206]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.206]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.206]         on.exit(options(oopts), add = TRUE)
[10:30:53.206]     }
[10:30:53.206]     {
[10:30:53.206]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.206]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.206]         do.call(mapply, args = args)
[10:30:53.206]     }
[10:30:53.206] }
[10:30:53.206] Lazy evaluation: FALSE
[10:30:53.206] Asynchronous evaluation: TRUE
[10:30:53.206] Local evaluation: TRUE
[10:30:53.206] Environment: R_GlobalEnv
[10:30:53.206] Capture standard output: TRUE
[10:30:53.206] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.206] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.206] Packages: <none>
[10:30:53.206] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.206] Resolved: FALSE
[10:30:53.206] Value: <not collected>
[10:30:53.206] Conditions captured: <none>
[10:30:53.206] Early signaling: FALSE
[10:30:53.206] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.206] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.218] Chunk #2 of 2 ... DONE
[10:30:53.218] Launching 2 futures (chunks) ... DONE
[10:30:53.218] Resolving 2 futures (chunks) ...
[10:30:53.218] resolve() on list ...
[10:30:53.218]  recursive: 0
[10:30:53.218]  length: 2
[10:30:53.219] 
[10:30:53.219] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.219] - Validating connection of MultisessionFuture
[10:30:53.219] - received message: FutureResult
[10:30:53.220] - Received FutureResult
[10:30:53.220] - Erased future from FutureRegistry
[10:30:53.220] result() for ClusterFuture ...
[10:30:53.220] - result already collected: FutureResult
[10:30:53.220] result() for ClusterFuture ... done
[10:30:53.220] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.220] Future #1
[10:30:53.220] result() for ClusterFuture ...
[10:30:53.220] - result already collected: FutureResult
[10:30:53.220] result() for ClusterFuture ... done
[10:30:53.220] result() for ClusterFuture ...
[10:30:53.221] - result already collected: FutureResult
[10:30:53.221] result() for ClusterFuture ... done
[10:30:53.221] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:53.221] - nx: 2
[10:30:53.221] - relay: TRUE
[10:30:53.221] - stdout: TRUE
[10:30:53.221] - signal: TRUE
[10:30:53.221] - resignal: FALSE
[10:30:53.221] - force: TRUE
[10:30:53.221] - relayed: [n=2] FALSE, FALSE
[10:30:53.221] - queued futures: [n=2] FALSE, FALSE
[10:30:53.222]  - until=1
[10:30:53.222]  - relaying element #1
[10:30:53.222] result() for ClusterFuture ...
[10:30:53.222] - result already collected: FutureResult
[10:30:53.222] result() for ClusterFuture ... done
[10:30:53.222] result() for ClusterFuture ...
[10:30:53.222] - result already collected: FutureResult
[10:30:53.222] result() for ClusterFuture ... done
[10:30:53.222] result() for ClusterFuture ...
[10:30:53.222] - result already collected: FutureResult
[10:30:53.222] result() for ClusterFuture ... done
[10:30:53.223] result() for ClusterFuture ...
[10:30:53.223] - result already collected: FutureResult
[10:30:53.223] result() for ClusterFuture ... done
[10:30:53.223] - relayed: [n=2] TRUE, FALSE
[10:30:53.223] - queued futures: [n=2] TRUE, FALSE
[10:30:53.223] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:53.223]  length: 1 (resolved future 1)
[10:30:53.250] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.251] - Validating connection of MultisessionFuture
[10:30:53.251] - received message: FutureResult
[10:30:53.251] - Received FutureResult
[10:30:53.251] - Erased future from FutureRegistry
[10:30:53.251] result() for ClusterFuture ...
[10:30:53.251] - result already collected: FutureResult
[10:30:53.252] result() for ClusterFuture ... done
[10:30:53.252] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.252] Future #2
[10:30:53.252] result() for ClusterFuture ...
[10:30:53.252] - result already collected: FutureResult
[10:30:53.252] result() for ClusterFuture ... done
[10:30:53.252] result() for ClusterFuture ...
[10:30:53.252] - result already collected: FutureResult
[10:30:53.252] result() for ClusterFuture ... done
[10:30:53.252] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:53.252] - nx: 2
[10:30:53.253] - relay: TRUE
[10:30:53.253] - stdout: TRUE
[10:30:53.253] - signal: TRUE
[10:30:53.253] - resignal: FALSE
[10:30:53.253] - force: TRUE
[10:30:53.253] - relayed: [n=2] TRUE, FALSE
[10:30:53.253] - queued futures: [n=2] TRUE, FALSE
[10:30:53.253]  - until=2
[10:30:53.253]  - relaying element #2
[10:30:53.253] result() for ClusterFuture ...
[10:30:53.253] - result already collected: FutureResult
[10:30:53.254] result() for ClusterFuture ... done
[10:30:53.254] result() for ClusterFuture ...
[10:30:53.254] - result already collected: FutureResult
[10:30:53.254] result() for ClusterFuture ... done
[10:30:53.254] result() for ClusterFuture ...
[10:30:53.254] - result already collected: FutureResult
[10:30:53.254] result() for ClusterFuture ... done
[10:30:53.254] result() for ClusterFuture ...
[10:30:53.254] - result already collected: FutureResult
[10:30:53.254] result() for ClusterFuture ... done
[10:30:53.254] - relayed: [n=2] TRUE, TRUE
[10:30:53.255] - queued futures: [n=2] TRUE, TRUE
[10:30:53.255] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:53.255]  length: 0 (resolved future 2)
[10:30:53.255] Relaying remaining futures
[10:30:53.255] signalConditionsASAP(NULL, pos=0) ...
[10:30:53.255] - nx: 2
[10:30:53.255] - relay: TRUE
[10:30:53.255] - stdout: TRUE
[10:30:53.255] - signal: TRUE
[10:30:53.255] - resignal: FALSE
[10:30:53.255] - force: TRUE
[10:30:53.255] - relayed: [n=2] TRUE, TRUE
[10:30:53.256] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:53.256] - relayed: [n=2] TRUE, TRUE
[10:30:53.256] - queued futures: [n=2] TRUE, TRUE
[10:30:53.256] signalConditionsASAP(NULL, pos=0) ... done
[10:30:53.256] resolve() on list ... DONE
[10:30:53.256] result() for ClusterFuture ...
[10:30:53.256] - result already collected: FutureResult
[10:30:53.256] result() for ClusterFuture ... done
[10:30:53.256] result() for ClusterFuture ...
[10:30:53.256] - result already collected: FutureResult
[10:30:53.256] result() for ClusterFuture ... done
[10:30:53.257] result() for ClusterFuture ...
[10:30:53.257] - result already collected: FutureResult
[10:30:53.257] result() for ClusterFuture ... done
[10:30:53.257] result() for ClusterFuture ...
[10:30:53.257] - result already collected: FutureResult
[10:30:53.257] result() for ClusterFuture ... done
[10:30:53.257]  - Number of value chunks collected: 2
[10:30:53.257] Resolving 2 futures (chunks) ... DONE
[10:30:53.257] Reducing values from 2 chunks ...
[10:30:53.257]  - Number of values collected after concatenation: 3
[10:30:53.258]  - Number of values expected: 3
[10:30:53.258] Reducing values from 2 chunks ... DONE
[10:30:53.258] future_mapply() ... DONE
- future_.mapply()
[10:30:53.258] future_mapply() ...
[10:30:53.262] Number of chunks: 2
[10:30:53.262] getGlobalsAndPackagesXApply() ...
[10:30:53.262]  - future.globals: TRUE
[10:30:53.262] getGlobalsAndPackages() ...
[10:30:53.262] Searching for globals...
[10:30:53.264] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:30:53.264] Searching for globals ... DONE
[10:30:53.264] Resolving globals: FALSE
[10:30:53.264] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[10:30:53.265] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[10:30:53.265] - globals: [1] ‘FUN’
[10:30:53.265] 
[10:30:53.265] getGlobalsAndPackages() ... DONE
[10:30:53.265]  - globals found/used: [n=1] ‘FUN’
[10:30:53.265]  - needed namespaces: [n=0] 
[10:30:53.265] Finding globals ... DONE
[10:30:53.266] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:53.266] List of 2
[10:30:53.266]  $ ...future.FUN:function (x, y)  
[10:30:53.266]  $ MoreArgs     : list()
[10:30:53.266]  - attr(*, "where")=List of 2
[10:30:53.266]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:53.266]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:53.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:53.266]  - attr(*, "resolved")= logi FALSE
[10:30:53.266]  - attr(*, "total_size")= num NA
[10:30:53.268] Packages to be attached in all futures: [n=0] 
[10:30:53.268] getGlobalsAndPackagesXApply() ... DONE
[10:30:53.268] Number of futures (= number of chunks): 2
[10:30:53.269] Launching 2 futures (chunks) ...
[10:30:53.269] Chunk #1 of 2 ...
[10:30:53.269]  - Finding globals in '...' for chunk #1 ...
[10:30:53.269] getGlobalsAndPackages() ...
[10:30:53.269] Searching for globals...
[10:30:53.269] 
[10:30:53.269] Searching for globals ... DONE
[10:30:53.270] - globals: [0] <none>
[10:30:53.270] getGlobalsAndPackages() ... DONE
[10:30:53.270]    + additional globals found: [n=0] 
[10:30:53.270]    + additional namespaces needed: [n=0] 
[10:30:53.270]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:53.270]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:53.270]  - seeds: <none>
[10:30:53.270]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.270] getGlobalsAndPackages() ...
[10:30:53.270] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.270] Resolving globals: FALSE
[10:30:53.271] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[10:30:53.271] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:53.272] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.272] 
[10:30:53.272] getGlobalsAndPackages() ... DONE
[10:30:53.274] run() for ‘Future’ ...
[10:30:53.274] - state: ‘created’
[10:30:53.275] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.288] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.289]   - Field: ‘node’
[10:30:53.289]   - Field: ‘label’
[10:30:53.289]   - Field: ‘local’
[10:30:53.289]   - Field: ‘owner’
[10:30:53.289]   - Field: ‘envir’
[10:30:53.289]   - Field: ‘workers’
[10:30:53.289]   - Field: ‘packages’
[10:30:53.289]   - Field: ‘gc’
[10:30:53.289]   - Field: ‘conditions’
[10:30:53.289]   - Field: ‘persistent’
[10:30:53.289]   - Field: ‘expr’
[10:30:53.290]   - Field: ‘uuid’
[10:30:53.290]   - Field: ‘seed’
[10:30:53.290]   - Field: ‘version’
[10:30:53.290]   - Field: ‘result’
[10:30:53.290]   - Field: ‘asynchronous’
[10:30:53.290]   - Field: ‘calls’
[10:30:53.290]   - Field: ‘globals’
[10:30:53.290]   - Field: ‘stdout’
[10:30:53.290]   - Field: ‘earlySignal’
[10:30:53.290]   - Field: ‘lazy’
[10:30:53.290]   - Field: ‘state’
[10:30:53.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.291] - Launch lazy future ...
[10:30:53.291] Packages needed by the future expression (n = 0): <none>
[10:30:53.291] Packages needed by future strategies (n = 0): <none>
[10:30:53.291] {
[10:30:53.291]     {
[10:30:53.291]         {
[10:30:53.291]             ...future.startTime <- base::Sys.time()
[10:30:53.291]             {
[10:30:53.291]                 {
[10:30:53.291]                   {
[10:30:53.291]                     {
[10:30:53.291]                       base::local({
[10:30:53.291]                         has_future <- base::requireNamespace("future", 
[10:30:53.291]                           quietly = TRUE)
[10:30:53.291]                         if (has_future) {
[10:30:53.291]                           ns <- base::getNamespace("future")
[10:30:53.291]                           version <- ns[[".package"]][["version"]]
[10:30:53.291]                           if (is.null(version)) 
[10:30:53.291]                             version <- utils::packageVersion("future")
[10:30:53.291]                         }
[10:30:53.291]                         else {
[10:30:53.291]                           version <- NULL
[10:30:53.291]                         }
[10:30:53.291]                         if (!has_future || version < "1.8.0") {
[10:30:53.291]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.291]                             "", base::R.version$version.string), 
[10:30:53.291]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.291]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.291]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.291]                               "release", "version")], collapse = " "), 
[10:30:53.291]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.291]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.291]                             info)
[10:30:53.291]                           info <- base::paste(info, collapse = "; ")
[10:30:53.291]                           if (!has_future) {
[10:30:53.291]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.291]                               info)
[10:30:53.291]                           }
[10:30:53.291]                           else {
[10:30:53.291]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.291]                               info, version)
[10:30:53.291]                           }
[10:30:53.291]                           base::stop(msg)
[10:30:53.291]                         }
[10:30:53.291]                       })
[10:30:53.291]                     }
[10:30:53.291]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.291]                     base::options(mc.cores = 1L)
[10:30:53.291]                   }
[10:30:53.291]                   ...future.strategy.old <- future::plan("list")
[10:30:53.291]                   options(future.plan = NULL)
[10:30:53.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.291]                 }
[10:30:53.291]                 ...future.workdir <- getwd()
[10:30:53.291]             }
[10:30:53.291]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.291]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.291]         }
[10:30:53.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.291]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:53.291]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.291]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.291]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.291]             base::names(...future.oldOptions))
[10:30:53.291]     }
[10:30:53.291]     if (FALSE) {
[10:30:53.291]     }
[10:30:53.291]     else {
[10:30:53.291]         if (TRUE) {
[10:30:53.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.291]                 open = "w")
[10:30:53.291]         }
[10:30:53.291]         else {
[10:30:53.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.291]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.291]         }
[10:30:53.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.291]             base::sink(type = "output", split = FALSE)
[10:30:53.291]             base::close(...future.stdout)
[10:30:53.291]         }, add = TRUE)
[10:30:53.291]     }
[10:30:53.291]     ...future.frame <- base::sys.nframe()
[10:30:53.291]     ...future.conditions <- base::list()
[10:30:53.291]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.291]     if (FALSE) {
[10:30:53.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.291]     }
[10:30:53.291]     ...future.result <- base::tryCatch({
[10:30:53.291]         base::withCallingHandlers({
[10:30:53.291]             ...future.value <- base::withVisible(base::local({
[10:30:53.291]                 ...future.makeSendCondition <- base::local({
[10:30:53.291]                   sendCondition <- NULL
[10:30:53.291]                   function(frame = 1L) {
[10:30:53.291]                     if (is.function(sendCondition)) 
[10:30:53.291]                       return(sendCondition)
[10:30:53.291]                     ns <- getNamespace("parallel")
[10:30:53.291]                     if (exists("sendData", mode = "function", 
[10:30:53.291]                       envir = ns)) {
[10:30:53.291]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.291]                         envir = ns)
[10:30:53.291]                       envir <- sys.frame(frame)
[10:30:53.291]                       master <- NULL
[10:30:53.291]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.291]                         !identical(envir, emptyenv())) {
[10:30:53.291]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.291]                           inherits = FALSE)) {
[10:30:53.291]                           master <- get("master", mode = "list", 
[10:30:53.291]                             envir = envir, inherits = FALSE)
[10:30:53.291]                           if (inherits(master, c("SOCKnode", 
[10:30:53.291]                             "SOCK0node"))) {
[10:30:53.291]                             sendCondition <<- function(cond) {
[10:30:53.291]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.291]                                 success = TRUE)
[10:30:53.291]                               parallel_sendData(master, data)
[10:30:53.291]                             }
[10:30:53.291]                             return(sendCondition)
[10:30:53.291]                           }
[10:30:53.291]                         }
[10:30:53.291]                         frame <- frame + 1L
[10:30:53.291]                         envir <- sys.frame(frame)
[10:30:53.291]                       }
[10:30:53.291]                     }
[10:30:53.291]                     sendCondition <<- function(cond) NULL
[10:30:53.291]                   }
[10:30:53.291]                 })
[10:30:53.291]                 withCallingHandlers({
[10:30:53.291]                   {
[10:30:53.291]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.291]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.291]                       ...future.globals.maxSize)) {
[10:30:53.291]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.291]                       on.exit(options(oopts), add = TRUE)
[10:30:53.291]                     }
[10:30:53.291]                     {
[10:30:53.291]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.291]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.291]                         USE.NAMES = FALSE)
[10:30:53.291]                       do.call(mapply, args = args)
[10:30:53.291]                     }
[10:30:53.291]                   }
[10:30:53.291]                 }, immediateCondition = function(cond) {
[10:30:53.291]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.291]                   sendCondition(cond)
[10:30:53.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.291]                   {
[10:30:53.291]                     inherits <- base::inherits
[10:30:53.291]                     invokeRestart <- base::invokeRestart
[10:30:53.291]                     is.null <- base::is.null
[10:30:53.291]                     muffled <- FALSE
[10:30:53.291]                     if (inherits(cond, "message")) {
[10:30:53.291]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.291]                       if (muffled) 
[10:30:53.291]                         invokeRestart("muffleMessage")
[10:30:53.291]                     }
[10:30:53.291]                     else if (inherits(cond, "warning")) {
[10:30:53.291]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.291]                       if (muffled) 
[10:30:53.291]                         invokeRestart("muffleWarning")
[10:30:53.291]                     }
[10:30:53.291]                     else if (inherits(cond, "condition")) {
[10:30:53.291]                       if (!is.null(pattern)) {
[10:30:53.291]                         computeRestarts <- base::computeRestarts
[10:30:53.291]                         grepl <- base::grepl
[10:30:53.291]                         restarts <- computeRestarts(cond)
[10:30:53.291]                         for (restart in restarts) {
[10:30:53.291]                           name <- restart$name
[10:30:53.291]                           if (is.null(name)) 
[10:30:53.291]                             next
[10:30:53.291]                           if (!grepl(pattern, name)) 
[10:30:53.291]                             next
[10:30:53.291]                           invokeRestart(restart)
[10:30:53.291]                           muffled <- TRUE
[10:30:53.291]                           break
[10:30:53.291]                         }
[10:30:53.291]                       }
[10:30:53.291]                     }
[10:30:53.291]                     invisible(muffled)
[10:30:53.291]                   }
[10:30:53.291]                   muffleCondition(cond)
[10:30:53.291]                 })
[10:30:53.291]             }))
[10:30:53.291]             future::FutureResult(value = ...future.value$value, 
[10:30:53.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.291]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.291]                     ...future.globalenv.names))
[10:30:53.291]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.291]         }, condition = base::local({
[10:30:53.291]             c <- base::c
[10:30:53.291]             inherits <- base::inherits
[10:30:53.291]             invokeRestart <- base::invokeRestart
[10:30:53.291]             length <- base::length
[10:30:53.291]             list <- base::list
[10:30:53.291]             seq.int <- base::seq.int
[10:30:53.291]             signalCondition <- base::signalCondition
[10:30:53.291]             sys.calls <- base::sys.calls
[10:30:53.291]             `[[` <- base::`[[`
[10:30:53.291]             `+` <- base::`+`
[10:30:53.291]             `<<-` <- base::`<<-`
[10:30:53.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.291]                   3L)]
[10:30:53.291]             }
[10:30:53.291]             function(cond) {
[10:30:53.291]                 is_error <- inherits(cond, "error")
[10:30:53.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.291]                   NULL)
[10:30:53.291]                 if (is_error) {
[10:30:53.291]                   sessionInformation <- function() {
[10:30:53.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.291]                       search = base::search(), system = base::Sys.info())
[10:30:53.291]                   }
[10:30:53.291]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.291]                     cond$call), session = sessionInformation(), 
[10:30:53.291]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.291]                   signalCondition(cond)
[10:30:53.291]                 }
[10:30:53.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.291]                 "immediateCondition"))) {
[10:30:53.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.291]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.291]                   if (TRUE && !signal) {
[10:30:53.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.291]                     {
[10:30:53.291]                       inherits <- base::inherits
[10:30:53.291]                       invokeRestart <- base::invokeRestart
[10:30:53.291]                       is.null <- base::is.null
[10:30:53.291]                       muffled <- FALSE
[10:30:53.291]                       if (inherits(cond, "message")) {
[10:30:53.291]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.291]                         if (muffled) 
[10:30:53.291]                           invokeRestart("muffleMessage")
[10:30:53.291]                       }
[10:30:53.291]                       else if (inherits(cond, "warning")) {
[10:30:53.291]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.291]                         if (muffled) 
[10:30:53.291]                           invokeRestart("muffleWarning")
[10:30:53.291]                       }
[10:30:53.291]                       else if (inherits(cond, "condition")) {
[10:30:53.291]                         if (!is.null(pattern)) {
[10:30:53.291]                           computeRestarts <- base::computeRestarts
[10:30:53.291]                           grepl <- base::grepl
[10:30:53.291]                           restarts <- computeRestarts(cond)
[10:30:53.291]                           for (restart in restarts) {
[10:30:53.291]                             name <- restart$name
[10:30:53.291]                             if (is.null(name)) 
[10:30:53.291]                               next
[10:30:53.291]                             if (!grepl(pattern, name)) 
[10:30:53.291]                               next
[10:30:53.291]                             invokeRestart(restart)
[10:30:53.291]                             muffled <- TRUE
[10:30:53.291]                             break
[10:30:53.291]                           }
[10:30:53.291]                         }
[10:30:53.291]                       }
[10:30:53.291]                       invisible(muffled)
[10:30:53.291]                     }
[10:30:53.291]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.291]                   }
[10:30:53.291]                 }
[10:30:53.291]                 else {
[10:30:53.291]                   if (TRUE) {
[10:30:53.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.291]                     {
[10:30:53.291]                       inherits <- base::inherits
[10:30:53.291]                       invokeRestart <- base::invokeRestart
[10:30:53.291]                       is.null <- base::is.null
[10:30:53.291]                       muffled <- FALSE
[10:30:53.291]                       if (inherits(cond, "message")) {
[10:30:53.291]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.291]                         if (muffled) 
[10:30:53.291]                           invokeRestart("muffleMessage")
[10:30:53.291]                       }
[10:30:53.291]                       else if (inherits(cond, "warning")) {
[10:30:53.291]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.291]                         if (muffled) 
[10:30:53.291]                           invokeRestart("muffleWarning")
[10:30:53.291]                       }
[10:30:53.291]                       else if (inherits(cond, "condition")) {
[10:30:53.291]                         if (!is.null(pattern)) {
[10:30:53.291]                           computeRestarts <- base::computeRestarts
[10:30:53.291]                           grepl <- base::grepl
[10:30:53.291]                           restarts <- computeRestarts(cond)
[10:30:53.291]                           for (restart in restarts) {
[10:30:53.291]                             name <- restart$name
[10:30:53.291]                             if (is.null(name)) 
[10:30:53.291]                               next
[10:30:53.291]                             if (!grepl(pattern, name)) 
[10:30:53.291]                               next
[10:30:53.291]                             invokeRestart(restart)
[10:30:53.291]                             muffled <- TRUE
[10:30:53.291]                             break
[10:30:53.291]                           }
[10:30:53.291]                         }
[10:30:53.291]                       }
[10:30:53.291]                       invisible(muffled)
[10:30:53.291]                     }
[10:30:53.291]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.291]                   }
[10:30:53.291]                 }
[10:30:53.291]             }
[10:30:53.291]         }))
[10:30:53.291]     }, error = function(ex) {
[10:30:53.291]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.291]                 ...future.rng), started = ...future.startTime, 
[10:30:53.291]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.291]             version = "1.8"), class = "FutureResult")
[10:30:53.291]     }, finally = {
[10:30:53.291]         if (!identical(...future.workdir, getwd())) 
[10:30:53.291]             setwd(...future.workdir)
[10:30:53.291]         {
[10:30:53.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.291]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.291]             }
[10:30:53.291]             base::options(...future.oldOptions)
[10:30:53.291]             if (.Platform$OS.type == "windows") {
[10:30:53.291]                 old_names <- names(...future.oldEnvVars)
[10:30:53.291]                 envs <- base::Sys.getenv()
[10:30:53.291]                 names <- names(envs)
[10:30:53.291]                 common <- intersect(names, old_names)
[10:30:53.291]                 added <- setdiff(names, old_names)
[10:30:53.291]                 removed <- setdiff(old_names, names)
[10:30:53.291]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.291]                   envs[common]]
[10:30:53.291]                 NAMES <- toupper(changed)
[10:30:53.291]                 args <- list()
[10:30:53.291]                 for (kk in seq_along(NAMES)) {
[10:30:53.291]                   name <- changed[[kk]]
[10:30:53.291]                   NAME <- NAMES[[kk]]
[10:30:53.291]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.291]                     next
[10:30:53.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.291]                 }
[10:30:53.291]                 NAMES <- toupper(added)
[10:30:53.291]                 for (kk in seq_along(NAMES)) {
[10:30:53.291]                   name <- added[[kk]]
[10:30:53.291]                   NAME <- NAMES[[kk]]
[10:30:53.291]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.291]                     next
[10:30:53.291]                   args[[name]] <- ""
[10:30:53.291]                 }
[10:30:53.291]                 NAMES <- toupper(removed)
[10:30:53.291]                 for (kk in seq_along(NAMES)) {
[10:30:53.291]                   name <- removed[[kk]]
[10:30:53.291]                   NAME <- NAMES[[kk]]
[10:30:53.291]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.291]                     next
[10:30:53.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.291]                 }
[10:30:53.291]                 if (length(args) > 0) 
[10:30:53.291]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.291]             }
[10:30:53.291]             else {
[10:30:53.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.291]             }
[10:30:53.291]             {
[10:30:53.291]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.291]                   0L) {
[10:30:53.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.291]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.291]                   base::options(opts)
[10:30:53.291]                 }
[10:30:53.291]                 {
[10:30:53.291]                   {
[10:30:53.291]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.291]                     NULL
[10:30:53.291]                   }
[10:30:53.291]                   options(future.plan = NULL)
[10:30:53.291]                   if (is.na(NA_character_)) 
[10:30:53.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.291]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.291]                     .init = FALSE)
[10:30:53.291]                 }
[10:30:53.291]             }
[10:30:53.291]         }
[10:30:53.291]     })
[10:30:53.291]     if (TRUE) {
[10:30:53.291]         base::sink(type = "output", split = FALSE)
[10:30:53.291]         if (TRUE) {
[10:30:53.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.291]         }
[10:30:53.291]         else {
[10:30:53.291]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.291]         }
[10:30:53.291]         base::close(...future.stdout)
[10:30:53.291]         ...future.stdout <- NULL
[10:30:53.291]     }
[10:30:53.291]     ...future.result$conditions <- ...future.conditions
[10:30:53.291]     ...future.result$finished <- base::Sys.time()
[10:30:53.291]     ...future.result
[10:30:53.291] }
[10:30:53.294] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[10:30:53.294] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[10:30:53.295] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[10:30:53.295] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:53.295] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.295] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:30:53.296] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:30:53.296] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:53.296] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.296] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:53.296] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.297] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[10:30:53.297] MultisessionFuture started
[10:30:53.297] - Launch lazy future ... done
[10:30:53.297] run() for ‘MultisessionFuture’ ... done
[10:30:53.297] Created future:
[10:30:53.297] MultisessionFuture:
[10:30:53.297] Label: ‘future_.mapply-1’
[10:30:53.297] Expression:
[10:30:53.297] {
[10:30:53.297]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.297]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.297]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.297]         on.exit(options(oopts), add = TRUE)
[10:30:53.297]     }
[10:30:53.297]     {
[10:30:53.297]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.297]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.297]         do.call(mapply, args = args)
[10:30:53.297]     }
[10:30:53.297] }
[10:30:53.297] Lazy evaluation: FALSE
[10:30:53.297] Asynchronous evaluation: TRUE
[10:30:53.297] Local evaluation: TRUE
[10:30:53.297] Environment: R_GlobalEnv
[10:30:53.297] Capture standard output: TRUE
[10:30:53.297] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.297] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.297] Packages: <none>
[10:30:53.297] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.297] Resolved: FALSE
[10:30:53.297] Value: <not collected>
[10:30:53.297] Conditions captured: <none>
[10:30:53.297] Early signaling: FALSE
[10:30:53.297] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.297] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.309] Chunk #1 of 2 ... DONE
[10:30:53.309] Chunk #2 of 2 ...
[10:30:53.309]  - Finding globals in '...' for chunk #2 ...
[10:30:53.309] getGlobalsAndPackages() ...
[10:30:53.310] Searching for globals...
[10:30:53.310] 
[10:30:53.310] Searching for globals ... DONE
[10:30:53.310] - globals: [0] <none>
[10:30:53.310] getGlobalsAndPackages() ... DONE
[10:30:53.310]    + additional globals found: [n=0] 
[10:30:53.310]    + additional namespaces needed: [n=0] 
[10:30:53.310]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:53.311]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:53.311]  - seeds: <none>
[10:30:53.311]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.311] getGlobalsAndPackages() ...
[10:30:53.311] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.311] Resolving globals: FALSE
[10:30:53.312] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[10:30:53.312] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:53.312] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.312] 
[10:30:53.312] getGlobalsAndPackages() ... DONE
[10:30:53.313] run() for ‘Future’ ...
[10:30:53.313] - state: ‘created’
[10:30:53.313] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.327]   - Field: ‘node’
[10:30:53.327]   - Field: ‘label’
[10:30:53.327]   - Field: ‘local’
[10:30:53.327]   - Field: ‘owner’
[10:30:53.327]   - Field: ‘envir’
[10:30:53.327]   - Field: ‘workers’
[10:30:53.327]   - Field: ‘packages’
[10:30:53.327]   - Field: ‘gc’
[10:30:53.328]   - Field: ‘conditions’
[10:30:53.328]   - Field: ‘persistent’
[10:30:53.328]   - Field: ‘expr’
[10:30:53.328]   - Field: ‘uuid’
[10:30:53.328]   - Field: ‘seed’
[10:30:53.328]   - Field: ‘version’
[10:30:53.328]   - Field: ‘result’
[10:30:53.328]   - Field: ‘asynchronous’
[10:30:53.328]   - Field: ‘calls’
[10:30:53.328]   - Field: ‘globals’
[10:30:53.328]   - Field: ‘stdout’
[10:30:53.328]   - Field: ‘earlySignal’
[10:30:53.329]   - Field: ‘lazy’
[10:30:53.329]   - Field: ‘state’
[10:30:53.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.329] - Launch lazy future ...
[10:30:53.329] Packages needed by the future expression (n = 0): <none>
[10:30:53.329] Packages needed by future strategies (n = 0): <none>
[10:30:53.330] {
[10:30:53.330]     {
[10:30:53.330]         {
[10:30:53.330]             ...future.startTime <- base::Sys.time()
[10:30:53.330]             {
[10:30:53.330]                 {
[10:30:53.330]                   {
[10:30:53.330]                     {
[10:30:53.330]                       base::local({
[10:30:53.330]                         has_future <- base::requireNamespace("future", 
[10:30:53.330]                           quietly = TRUE)
[10:30:53.330]                         if (has_future) {
[10:30:53.330]                           ns <- base::getNamespace("future")
[10:30:53.330]                           version <- ns[[".package"]][["version"]]
[10:30:53.330]                           if (is.null(version)) 
[10:30:53.330]                             version <- utils::packageVersion("future")
[10:30:53.330]                         }
[10:30:53.330]                         else {
[10:30:53.330]                           version <- NULL
[10:30:53.330]                         }
[10:30:53.330]                         if (!has_future || version < "1.8.0") {
[10:30:53.330]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.330]                             "", base::R.version$version.string), 
[10:30:53.330]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.330]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.330]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.330]                               "release", "version")], collapse = " "), 
[10:30:53.330]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.330]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.330]                             info)
[10:30:53.330]                           info <- base::paste(info, collapse = "; ")
[10:30:53.330]                           if (!has_future) {
[10:30:53.330]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.330]                               info)
[10:30:53.330]                           }
[10:30:53.330]                           else {
[10:30:53.330]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.330]                               info, version)
[10:30:53.330]                           }
[10:30:53.330]                           base::stop(msg)
[10:30:53.330]                         }
[10:30:53.330]                       })
[10:30:53.330]                     }
[10:30:53.330]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.330]                     base::options(mc.cores = 1L)
[10:30:53.330]                   }
[10:30:53.330]                   ...future.strategy.old <- future::plan("list")
[10:30:53.330]                   options(future.plan = NULL)
[10:30:53.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.330]                 }
[10:30:53.330]                 ...future.workdir <- getwd()
[10:30:53.330]             }
[10:30:53.330]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.330]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.330]         }
[10:30:53.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.330]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:53.330]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.330]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.330]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.330]             base::names(...future.oldOptions))
[10:30:53.330]     }
[10:30:53.330]     if (FALSE) {
[10:30:53.330]     }
[10:30:53.330]     else {
[10:30:53.330]         if (TRUE) {
[10:30:53.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.330]                 open = "w")
[10:30:53.330]         }
[10:30:53.330]         else {
[10:30:53.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.330]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.330]         }
[10:30:53.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.330]             base::sink(type = "output", split = FALSE)
[10:30:53.330]             base::close(...future.stdout)
[10:30:53.330]         }, add = TRUE)
[10:30:53.330]     }
[10:30:53.330]     ...future.frame <- base::sys.nframe()
[10:30:53.330]     ...future.conditions <- base::list()
[10:30:53.330]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.330]     if (FALSE) {
[10:30:53.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.330]     }
[10:30:53.330]     ...future.result <- base::tryCatch({
[10:30:53.330]         base::withCallingHandlers({
[10:30:53.330]             ...future.value <- base::withVisible(base::local({
[10:30:53.330]                 ...future.makeSendCondition <- base::local({
[10:30:53.330]                   sendCondition <- NULL
[10:30:53.330]                   function(frame = 1L) {
[10:30:53.330]                     if (is.function(sendCondition)) 
[10:30:53.330]                       return(sendCondition)
[10:30:53.330]                     ns <- getNamespace("parallel")
[10:30:53.330]                     if (exists("sendData", mode = "function", 
[10:30:53.330]                       envir = ns)) {
[10:30:53.330]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.330]                         envir = ns)
[10:30:53.330]                       envir <- sys.frame(frame)
[10:30:53.330]                       master <- NULL
[10:30:53.330]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.330]                         !identical(envir, emptyenv())) {
[10:30:53.330]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.330]                           inherits = FALSE)) {
[10:30:53.330]                           master <- get("master", mode = "list", 
[10:30:53.330]                             envir = envir, inherits = FALSE)
[10:30:53.330]                           if (inherits(master, c("SOCKnode", 
[10:30:53.330]                             "SOCK0node"))) {
[10:30:53.330]                             sendCondition <<- function(cond) {
[10:30:53.330]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.330]                                 success = TRUE)
[10:30:53.330]                               parallel_sendData(master, data)
[10:30:53.330]                             }
[10:30:53.330]                             return(sendCondition)
[10:30:53.330]                           }
[10:30:53.330]                         }
[10:30:53.330]                         frame <- frame + 1L
[10:30:53.330]                         envir <- sys.frame(frame)
[10:30:53.330]                       }
[10:30:53.330]                     }
[10:30:53.330]                     sendCondition <<- function(cond) NULL
[10:30:53.330]                   }
[10:30:53.330]                 })
[10:30:53.330]                 withCallingHandlers({
[10:30:53.330]                   {
[10:30:53.330]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.330]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.330]                       ...future.globals.maxSize)) {
[10:30:53.330]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.330]                       on.exit(options(oopts), add = TRUE)
[10:30:53.330]                     }
[10:30:53.330]                     {
[10:30:53.330]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.330]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.330]                         USE.NAMES = FALSE)
[10:30:53.330]                       do.call(mapply, args = args)
[10:30:53.330]                     }
[10:30:53.330]                   }
[10:30:53.330]                 }, immediateCondition = function(cond) {
[10:30:53.330]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.330]                   sendCondition(cond)
[10:30:53.330]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.330]                   {
[10:30:53.330]                     inherits <- base::inherits
[10:30:53.330]                     invokeRestart <- base::invokeRestart
[10:30:53.330]                     is.null <- base::is.null
[10:30:53.330]                     muffled <- FALSE
[10:30:53.330]                     if (inherits(cond, "message")) {
[10:30:53.330]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.330]                       if (muffled) 
[10:30:53.330]                         invokeRestart("muffleMessage")
[10:30:53.330]                     }
[10:30:53.330]                     else if (inherits(cond, "warning")) {
[10:30:53.330]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.330]                       if (muffled) 
[10:30:53.330]                         invokeRestart("muffleWarning")
[10:30:53.330]                     }
[10:30:53.330]                     else if (inherits(cond, "condition")) {
[10:30:53.330]                       if (!is.null(pattern)) {
[10:30:53.330]                         computeRestarts <- base::computeRestarts
[10:30:53.330]                         grepl <- base::grepl
[10:30:53.330]                         restarts <- computeRestarts(cond)
[10:30:53.330]                         for (restart in restarts) {
[10:30:53.330]                           name <- restart$name
[10:30:53.330]                           if (is.null(name)) 
[10:30:53.330]                             next
[10:30:53.330]                           if (!grepl(pattern, name)) 
[10:30:53.330]                             next
[10:30:53.330]                           invokeRestart(restart)
[10:30:53.330]                           muffled <- TRUE
[10:30:53.330]                           break
[10:30:53.330]                         }
[10:30:53.330]                       }
[10:30:53.330]                     }
[10:30:53.330]                     invisible(muffled)
[10:30:53.330]                   }
[10:30:53.330]                   muffleCondition(cond)
[10:30:53.330]                 })
[10:30:53.330]             }))
[10:30:53.330]             future::FutureResult(value = ...future.value$value, 
[10:30:53.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.330]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.330]                     ...future.globalenv.names))
[10:30:53.330]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.330]         }, condition = base::local({
[10:30:53.330]             c <- base::c
[10:30:53.330]             inherits <- base::inherits
[10:30:53.330]             invokeRestart <- base::invokeRestart
[10:30:53.330]             length <- base::length
[10:30:53.330]             list <- base::list
[10:30:53.330]             seq.int <- base::seq.int
[10:30:53.330]             signalCondition <- base::signalCondition
[10:30:53.330]             sys.calls <- base::sys.calls
[10:30:53.330]             `[[` <- base::`[[`
[10:30:53.330]             `+` <- base::`+`
[10:30:53.330]             `<<-` <- base::`<<-`
[10:30:53.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.330]                   3L)]
[10:30:53.330]             }
[10:30:53.330]             function(cond) {
[10:30:53.330]                 is_error <- inherits(cond, "error")
[10:30:53.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.330]                   NULL)
[10:30:53.330]                 if (is_error) {
[10:30:53.330]                   sessionInformation <- function() {
[10:30:53.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.330]                       search = base::search(), system = base::Sys.info())
[10:30:53.330]                   }
[10:30:53.330]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.330]                     cond$call), session = sessionInformation(), 
[10:30:53.330]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.330]                   signalCondition(cond)
[10:30:53.330]                 }
[10:30:53.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.330]                 "immediateCondition"))) {
[10:30:53.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.330]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.330]                   if (TRUE && !signal) {
[10:30:53.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.330]                     {
[10:30:53.330]                       inherits <- base::inherits
[10:30:53.330]                       invokeRestart <- base::invokeRestart
[10:30:53.330]                       is.null <- base::is.null
[10:30:53.330]                       muffled <- FALSE
[10:30:53.330]                       if (inherits(cond, "message")) {
[10:30:53.330]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.330]                         if (muffled) 
[10:30:53.330]                           invokeRestart("muffleMessage")
[10:30:53.330]                       }
[10:30:53.330]                       else if (inherits(cond, "warning")) {
[10:30:53.330]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.330]                         if (muffled) 
[10:30:53.330]                           invokeRestart("muffleWarning")
[10:30:53.330]                       }
[10:30:53.330]                       else if (inherits(cond, "condition")) {
[10:30:53.330]                         if (!is.null(pattern)) {
[10:30:53.330]                           computeRestarts <- base::computeRestarts
[10:30:53.330]                           grepl <- base::grepl
[10:30:53.330]                           restarts <- computeRestarts(cond)
[10:30:53.330]                           for (restart in restarts) {
[10:30:53.330]                             name <- restart$name
[10:30:53.330]                             if (is.null(name)) 
[10:30:53.330]                               next
[10:30:53.330]                             if (!grepl(pattern, name)) 
[10:30:53.330]                               next
[10:30:53.330]                             invokeRestart(restart)
[10:30:53.330]                             muffled <- TRUE
[10:30:53.330]                             break
[10:30:53.330]                           }
[10:30:53.330]                         }
[10:30:53.330]                       }
[10:30:53.330]                       invisible(muffled)
[10:30:53.330]                     }
[10:30:53.330]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.330]                   }
[10:30:53.330]                 }
[10:30:53.330]                 else {
[10:30:53.330]                   if (TRUE) {
[10:30:53.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.330]                     {
[10:30:53.330]                       inherits <- base::inherits
[10:30:53.330]                       invokeRestart <- base::invokeRestart
[10:30:53.330]                       is.null <- base::is.null
[10:30:53.330]                       muffled <- FALSE
[10:30:53.330]                       if (inherits(cond, "message")) {
[10:30:53.330]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.330]                         if (muffled) 
[10:30:53.330]                           invokeRestart("muffleMessage")
[10:30:53.330]                       }
[10:30:53.330]                       else if (inherits(cond, "warning")) {
[10:30:53.330]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.330]                         if (muffled) 
[10:30:53.330]                           invokeRestart("muffleWarning")
[10:30:53.330]                       }
[10:30:53.330]                       else if (inherits(cond, "condition")) {
[10:30:53.330]                         if (!is.null(pattern)) {
[10:30:53.330]                           computeRestarts <- base::computeRestarts
[10:30:53.330]                           grepl <- base::grepl
[10:30:53.330]                           restarts <- computeRestarts(cond)
[10:30:53.330]                           for (restart in restarts) {
[10:30:53.330]                             name <- restart$name
[10:30:53.330]                             if (is.null(name)) 
[10:30:53.330]                               next
[10:30:53.330]                             if (!grepl(pattern, name)) 
[10:30:53.330]                               next
[10:30:53.330]                             invokeRestart(restart)
[10:30:53.330]                             muffled <- TRUE
[10:30:53.330]                             break
[10:30:53.330]                           }
[10:30:53.330]                         }
[10:30:53.330]                       }
[10:30:53.330]                       invisible(muffled)
[10:30:53.330]                     }
[10:30:53.330]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.330]                   }
[10:30:53.330]                 }
[10:30:53.330]             }
[10:30:53.330]         }))
[10:30:53.330]     }, error = function(ex) {
[10:30:53.330]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.330]                 ...future.rng), started = ...future.startTime, 
[10:30:53.330]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.330]             version = "1.8"), class = "FutureResult")
[10:30:53.330]     }, finally = {
[10:30:53.330]         if (!identical(...future.workdir, getwd())) 
[10:30:53.330]             setwd(...future.workdir)
[10:30:53.330]         {
[10:30:53.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.330]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.330]             }
[10:30:53.330]             base::options(...future.oldOptions)
[10:30:53.330]             if (.Platform$OS.type == "windows") {
[10:30:53.330]                 old_names <- names(...future.oldEnvVars)
[10:30:53.330]                 envs <- base::Sys.getenv()
[10:30:53.330]                 names <- names(envs)
[10:30:53.330]                 common <- intersect(names, old_names)
[10:30:53.330]                 added <- setdiff(names, old_names)
[10:30:53.330]                 removed <- setdiff(old_names, names)
[10:30:53.330]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.330]                   envs[common]]
[10:30:53.330]                 NAMES <- toupper(changed)
[10:30:53.330]                 args <- list()
[10:30:53.330]                 for (kk in seq_along(NAMES)) {
[10:30:53.330]                   name <- changed[[kk]]
[10:30:53.330]                   NAME <- NAMES[[kk]]
[10:30:53.330]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.330]                     next
[10:30:53.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.330]                 }
[10:30:53.330]                 NAMES <- toupper(added)
[10:30:53.330]                 for (kk in seq_along(NAMES)) {
[10:30:53.330]                   name <- added[[kk]]
[10:30:53.330]                   NAME <- NAMES[[kk]]
[10:30:53.330]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.330]                     next
[10:30:53.330]                   args[[name]] <- ""
[10:30:53.330]                 }
[10:30:53.330]                 NAMES <- toupper(removed)
[10:30:53.330]                 for (kk in seq_along(NAMES)) {
[10:30:53.330]                   name <- removed[[kk]]
[10:30:53.330]                   NAME <- NAMES[[kk]]
[10:30:53.330]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.330]                     next
[10:30:53.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.330]                 }
[10:30:53.330]                 if (length(args) > 0) 
[10:30:53.330]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.330]             }
[10:30:53.330]             else {
[10:30:53.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.330]             }
[10:30:53.330]             {
[10:30:53.330]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.330]                   0L) {
[10:30:53.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.330]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.330]                   base::options(opts)
[10:30:53.330]                 }
[10:30:53.330]                 {
[10:30:53.330]                   {
[10:30:53.330]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.330]                     NULL
[10:30:53.330]                   }
[10:30:53.330]                   options(future.plan = NULL)
[10:30:53.330]                   if (is.na(NA_character_)) 
[10:30:53.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.330]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.330]                     .init = FALSE)
[10:30:53.330]                 }
[10:30:53.330]             }
[10:30:53.330]         }
[10:30:53.330]     })
[10:30:53.330]     if (TRUE) {
[10:30:53.330]         base::sink(type = "output", split = FALSE)
[10:30:53.330]         if (TRUE) {
[10:30:53.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.330]         }
[10:30:53.330]         else {
[10:30:53.330]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.330]         }
[10:30:53.330]         base::close(...future.stdout)
[10:30:53.330]         ...future.stdout <- NULL
[10:30:53.330]     }
[10:30:53.330]     ...future.result$conditions <- ...future.conditions
[10:30:53.330]     ...future.result$finished <- base::Sys.time()
[10:30:53.330]     ...future.result
[10:30:53.330] }
[10:30:53.332] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[10:30:53.333] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[10:30:53.333] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[10:30:53.333] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:53.334] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.334] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[10:30:53.334] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[10:30:53.334] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:53.335] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.335] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:53.335] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.335] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[10:30:53.336] MultisessionFuture started
[10:30:53.336] - Launch lazy future ... done
[10:30:53.336] run() for ‘MultisessionFuture’ ... done
[10:30:53.336] Created future:
[10:30:53.336] MultisessionFuture:
[10:30:53.336] Label: ‘future_.mapply-2’
[10:30:53.336] Expression:
[10:30:53.336] {
[10:30:53.336]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.336]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.336]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.336]         on.exit(options(oopts), add = TRUE)
[10:30:53.336]     }
[10:30:53.336]     {
[10:30:53.336]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.336]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.336]         do.call(mapply, args = args)
[10:30:53.336]     }
[10:30:53.336] }
[10:30:53.336] Lazy evaluation: FALSE
[10:30:53.336] Asynchronous evaluation: TRUE
[10:30:53.336] Local evaluation: TRUE
[10:30:53.336] Environment: R_GlobalEnv
[10:30:53.336] Capture standard output: TRUE
[10:30:53.336] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.336] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.336] Packages: <none>
[10:30:53.336] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.336] Resolved: FALSE
[10:30:53.336] Value: <not collected>
[10:30:53.336] Conditions captured: <none>
[10:30:53.336] Early signaling: FALSE
[10:30:53.336] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.336] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.348] Chunk #2 of 2 ... DONE
[10:30:53.348] Launching 2 futures (chunks) ... DONE
[10:30:53.348] Resolving 2 futures (chunks) ...
[10:30:53.348] resolve() on list ...
[10:30:53.348]  recursive: 0
[10:30:53.348]  length: 2
[10:30:53.349] 
[10:30:53.349] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.349] - Validating connection of MultisessionFuture
[10:30:53.349] - received message: FutureResult
[10:30:53.350] - Received FutureResult
[10:30:53.350] - Erased future from FutureRegistry
[10:30:53.350] result() for ClusterFuture ...
[10:30:53.350] - result already collected: FutureResult
[10:30:53.350] result() for ClusterFuture ... done
[10:30:53.350] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.350] Future #1
[10:30:53.350] result() for ClusterFuture ...
[10:30:53.350] - result already collected: FutureResult
[10:30:53.350] result() for ClusterFuture ... done
[10:30:53.350] result() for ClusterFuture ...
[10:30:53.350] - result already collected: FutureResult
[10:30:53.351] result() for ClusterFuture ... done
[10:30:53.351] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:53.351] - nx: 2
[10:30:53.351] - relay: TRUE
[10:30:53.351] - stdout: TRUE
[10:30:53.351] - signal: TRUE
[10:30:53.351] - resignal: FALSE
[10:30:53.351] - force: TRUE
[10:30:53.351] - relayed: [n=2] FALSE, FALSE
[10:30:53.351] - queued futures: [n=2] FALSE, FALSE
[10:30:53.351]  - until=1
[10:30:53.352]  - relaying element #1
[10:30:53.352] result() for ClusterFuture ...
[10:30:53.352] - result already collected: FutureResult
[10:30:53.352] result() for ClusterFuture ... done
[10:30:53.352] result() for ClusterFuture ...
[10:30:53.352] - result already collected: FutureResult
[10:30:53.352] result() for ClusterFuture ... done
[10:30:53.352] result() for ClusterFuture ...
[10:30:53.352] - result already collected: FutureResult
[10:30:53.352] result() for ClusterFuture ... done
[10:30:53.352] result() for ClusterFuture ...
[10:30:53.352] - result already collected: FutureResult
[10:30:53.353] result() for ClusterFuture ... done
[10:30:53.353] - relayed: [n=2] TRUE, FALSE
[10:30:53.353] - queued futures: [n=2] TRUE, FALSE
[10:30:53.353] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:53.353]  length: 1 (resolved future 1)
[10:30:53.378] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.379] - Validating connection of MultisessionFuture
[10:30:53.379] - received message: FutureResult
[10:30:53.379] - Received FutureResult
[10:30:53.379] - Erased future from FutureRegistry
[10:30:53.379] result() for ClusterFuture ...
[10:30:53.379] - result already collected: FutureResult
[10:30:53.379] result() for ClusterFuture ... done
[10:30:53.380] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.380] Future #2
[10:30:53.380] result() for ClusterFuture ...
[10:30:53.380] - result already collected: FutureResult
[10:30:53.380] result() for ClusterFuture ... done
[10:30:53.380] result() for ClusterFuture ...
[10:30:53.380] - result already collected: FutureResult
[10:30:53.380] result() for ClusterFuture ... done
[10:30:53.380] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:53.380] - nx: 2
[10:30:53.380] - relay: TRUE
[10:30:53.381] - stdout: TRUE
[10:30:53.381] - signal: TRUE
[10:30:53.381] - resignal: FALSE
[10:30:53.381] - force: TRUE
[10:30:53.381] - relayed: [n=2] TRUE, FALSE
[10:30:53.381] - queued futures: [n=2] TRUE, FALSE
[10:30:53.381]  - until=2
[10:30:53.381]  - relaying element #2
[10:30:53.381] result() for ClusterFuture ...
[10:30:53.381] - result already collected: FutureResult
[10:30:53.381] result() for ClusterFuture ... done
[10:30:53.381] result() for ClusterFuture ...
[10:30:53.382] - result already collected: FutureResult
[10:30:53.382] result() for ClusterFuture ... done
[10:30:53.382] result() for ClusterFuture ...
[10:30:53.382] - result already collected: FutureResult
[10:30:53.382] result() for ClusterFuture ... done
[10:30:53.382] result() for ClusterFuture ...
[10:30:53.382] - result already collected: FutureResult
[10:30:53.382] result() for ClusterFuture ... done
[10:30:53.382] - relayed: [n=2] TRUE, TRUE
[10:30:53.382] - queued futures: [n=2] TRUE, TRUE
[10:30:53.382] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:53.383]  length: 0 (resolved future 2)
[10:30:53.383] Relaying remaining futures
[10:30:53.383] signalConditionsASAP(NULL, pos=0) ...
[10:30:53.383] - nx: 2
[10:30:53.383] - relay: TRUE
[10:30:53.383] - stdout: TRUE
[10:30:53.383] - signal: TRUE
[10:30:53.383] - resignal: FALSE
[10:30:53.383] - force: TRUE
[10:30:53.383] - relayed: [n=2] TRUE, TRUE
[10:30:53.383] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:53.383] - relayed: [n=2] TRUE, TRUE
[10:30:53.384] - queued futures: [n=2] TRUE, TRUE
[10:30:53.384] signalConditionsASAP(NULL, pos=0) ... done
[10:30:53.384] resolve() on list ... DONE
[10:30:53.384] result() for ClusterFuture ...
[10:30:53.384] - result already collected: FutureResult
[10:30:53.384] result() for ClusterFuture ... done
[10:30:53.384] result() for ClusterFuture ...
[10:30:53.384] - result already collected: FutureResult
[10:30:53.384] result() for ClusterFuture ... done
[10:30:53.384] result() for ClusterFuture ...
[10:30:53.384] - result already collected: FutureResult
[10:30:53.385] result() for ClusterFuture ... done
[10:30:53.385] result() for ClusterFuture ...
[10:30:53.385] - result already collected: FutureResult
[10:30:53.385] result() for ClusterFuture ... done
[10:30:53.385]  - Number of value chunks collected: 2
[10:30:53.385] Resolving 2 futures (chunks) ... DONE
[10:30:53.385] Reducing values from 2 chunks ...
[10:30:53.385]  - Number of values collected after concatenation: 3
[10:30:53.385]  - Number of values expected: 3
[10:30:53.385] Reducing values from 2 chunks ... DONE
[10:30:53.385] future_mapply() ... DONE
[10:30:53.386] future_mapply() ...
[10:30:53.390] Number of chunks: 5
[10:30:53.390] getGlobalsAndPackagesXApply() ...
[10:30:53.390]  - future.globals: TRUE
[10:30:53.390] getGlobalsAndPackages() ...
[10:30:53.390] Searching for globals...
[10:30:53.391] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:53.391] Searching for globals ... DONE
[10:30:53.392] Resolving globals: FALSE
[10:30:53.392] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:53.392] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:53.392] - globals: [1] ‘FUN’
[10:30:53.392] 
[10:30:53.393] getGlobalsAndPackages() ... DONE
[10:30:53.393]  - globals found/used: [n=1] ‘FUN’
[10:30:53.393]  - needed namespaces: [n=0] 
[10:30:53.393] Finding globals ... DONE
[10:30:53.393] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:53.393] List of 2
[10:30:53.393]  $ ...future.FUN:function (C, k)  
[10:30:53.393]  $ MoreArgs     : NULL
[10:30:53.393]  - attr(*, "where")=List of 2
[10:30:53.393]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:53.393]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:53.393]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:53.393]  - attr(*, "resolved")= logi FALSE
[10:30:53.393]  - attr(*, "total_size")= num NA
[10:30:53.396] Packages to be attached in all futures: [n=0] 
[10:30:53.396] getGlobalsAndPackagesXApply() ... DONE
[10:30:53.396] Number of futures (= number of chunks): 5
[10:30:53.396] Launching 5 futures (chunks) ...
[10:30:53.396] Chunk #1 of 5 ...
[10:30:53.396]  - Finding globals in '...' for chunk #1 ...
[10:30:53.397] getGlobalsAndPackages() ...
[10:30:53.397] Searching for globals...
[10:30:53.397] 
[10:30:53.397] Searching for globals ... DONE
[10:30:53.397] - globals: [0] <none>
[10:30:53.397] getGlobalsAndPackages() ... DONE
[10:30:53.397]    + additional globals found: [n=0] 
[10:30:53.397]    + additional namespaces needed: [n=0] 
[10:30:53.398]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:53.398]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:53.398]  - seeds: <none>
[10:30:53.398]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.398] getGlobalsAndPackages() ...
[10:30:53.398] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.398] Resolving globals: FALSE
[10:30:53.399] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:53.399] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:53.399] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.399] 
[10:30:53.399] getGlobalsAndPackages() ... DONE
[10:30:53.400] run() for ‘Future’ ...
[10:30:53.400] - state: ‘created’
[10:30:53.400] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.414] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.414]   - Field: ‘node’
[10:30:53.415]   - Field: ‘label’
[10:30:53.415]   - Field: ‘local’
[10:30:53.415]   - Field: ‘owner’
[10:30:53.415]   - Field: ‘envir’
[10:30:53.415]   - Field: ‘workers’
[10:30:53.415]   - Field: ‘packages’
[10:30:53.415]   - Field: ‘gc’
[10:30:53.415]   - Field: ‘conditions’
[10:30:53.415]   - Field: ‘persistent’
[10:30:53.415]   - Field: ‘expr’
[10:30:53.415]   - Field: ‘uuid’
[10:30:53.416]   - Field: ‘seed’
[10:30:53.416]   - Field: ‘version’
[10:30:53.416]   - Field: ‘result’
[10:30:53.416]   - Field: ‘asynchronous’
[10:30:53.416]   - Field: ‘calls’
[10:30:53.416]   - Field: ‘globals’
[10:30:53.416]   - Field: ‘stdout’
[10:30:53.416]   - Field: ‘earlySignal’
[10:30:53.416]   - Field: ‘lazy’
[10:30:53.416]   - Field: ‘state’
[10:30:53.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.417] - Launch lazy future ...
[10:30:53.417] Packages needed by the future expression (n = 0): <none>
[10:30:53.417] Packages needed by future strategies (n = 0): <none>
[10:30:53.417] {
[10:30:53.417]     {
[10:30:53.417]         {
[10:30:53.417]             ...future.startTime <- base::Sys.time()
[10:30:53.417]             {
[10:30:53.417]                 {
[10:30:53.417]                   {
[10:30:53.417]                     {
[10:30:53.417]                       base::local({
[10:30:53.417]                         has_future <- base::requireNamespace("future", 
[10:30:53.417]                           quietly = TRUE)
[10:30:53.417]                         if (has_future) {
[10:30:53.417]                           ns <- base::getNamespace("future")
[10:30:53.417]                           version <- ns[[".package"]][["version"]]
[10:30:53.417]                           if (is.null(version)) 
[10:30:53.417]                             version <- utils::packageVersion("future")
[10:30:53.417]                         }
[10:30:53.417]                         else {
[10:30:53.417]                           version <- NULL
[10:30:53.417]                         }
[10:30:53.417]                         if (!has_future || version < "1.8.0") {
[10:30:53.417]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.417]                             "", base::R.version$version.string), 
[10:30:53.417]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.417]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.417]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.417]                               "release", "version")], collapse = " "), 
[10:30:53.417]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.417]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.417]                             info)
[10:30:53.417]                           info <- base::paste(info, collapse = "; ")
[10:30:53.417]                           if (!has_future) {
[10:30:53.417]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.417]                               info)
[10:30:53.417]                           }
[10:30:53.417]                           else {
[10:30:53.417]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.417]                               info, version)
[10:30:53.417]                           }
[10:30:53.417]                           base::stop(msg)
[10:30:53.417]                         }
[10:30:53.417]                       })
[10:30:53.417]                     }
[10:30:53.417]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.417]                     base::options(mc.cores = 1L)
[10:30:53.417]                   }
[10:30:53.417]                   ...future.strategy.old <- future::plan("list")
[10:30:53.417]                   options(future.plan = NULL)
[10:30:53.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.417]                 }
[10:30:53.417]                 ...future.workdir <- getwd()
[10:30:53.417]             }
[10:30:53.417]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.417]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.417]         }
[10:30:53.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.417]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:53.417]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.417]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.417]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.417]             base::names(...future.oldOptions))
[10:30:53.417]     }
[10:30:53.417]     if (FALSE) {
[10:30:53.417]     }
[10:30:53.417]     else {
[10:30:53.417]         if (TRUE) {
[10:30:53.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.417]                 open = "w")
[10:30:53.417]         }
[10:30:53.417]         else {
[10:30:53.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.417]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.417]         }
[10:30:53.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.417]             base::sink(type = "output", split = FALSE)
[10:30:53.417]             base::close(...future.stdout)
[10:30:53.417]         }, add = TRUE)
[10:30:53.417]     }
[10:30:53.417]     ...future.frame <- base::sys.nframe()
[10:30:53.417]     ...future.conditions <- base::list()
[10:30:53.417]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.417]     if (FALSE) {
[10:30:53.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.417]     }
[10:30:53.417]     ...future.result <- base::tryCatch({
[10:30:53.417]         base::withCallingHandlers({
[10:30:53.417]             ...future.value <- base::withVisible(base::local({
[10:30:53.417]                 ...future.makeSendCondition <- base::local({
[10:30:53.417]                   sendCondition <- NULL
[10:30:53.417]                   function(frame = 1L) {
[10:30:53.417]                     if (is.function(sendCondition)) 
[10:30:53.417]                       return(sendCondition)
[10:30:53.417]                     ns <- getNamespace("parallel")
[10:30:53.417]                     if (exists("sendData", mode = "function", 
[10:30:53.417]                       envir = ns)) {
[10:30:53.417]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.417]                         envir = ns)
[10:30:53.417]                       envir <- sys.frame(frame)
[10:30:53.417]                       master <- NULL
[10:30:53.417]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.417]                         !identical(envir, emptyenv())) {
[10:30:53.417]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.417]                           inherits = FALSE)) {
[10:30:53.417]                           master <- get("master", mode = "list", 
[10:30:53.417]                             envir = envir, inherits = FALSE)
[10:30:53.417]                           if (inherits(master, c("SOCKnode", 
[10:30:53.417]                             "SOCK0node"))) {
[10:30:53.417]                             sendCondition <<- function(cond) {
[10:30:53.417]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.417]                                 success = TRUE)
[10:30:53.417]                               parallel_sendData(master, data)
[10:30:53.417]                             }
[10:30:53.417]                             return(sendCondition)
[10:30:53.417]                           }
[10:30:53.417]                         }
[10:30:53.417]                         frame <- frame + 1L
[10:30:53.417]                         envir <- sys.frame(frame)
[10:30:53.417]                       }
[10:30:53.417]                     }
[10:30:53.417]                     sendCondition <<- function(cond) NULL
[10:30:53.417]                   }
[10:30:53.417]                 })
[10:30:53.417]                 withCallingHandlers({
[10:30:53.417]                   {
[10:30:53.417]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.417]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.417]                       ...future.globals.maxSize)) {
[10:30:53.417]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.417]                       on.exit(options(oopts), add = TRUE)
[10:30:53.417]                     }
[10:30:53.417]                     {
[10:30:53.417]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.417]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.417]                         USE.NAMES = FALSE)
[10:30:53.417]                       do.call(mapply, args = args)
[10:30:53.417]                     }
[10:30:53.417]                   }
[10:30:53.417]                 }, immediateCondition = function(cond) {
[10:30:53.417]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.417]                   sendCondition(cond)
[10:30:53.417]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.417]                   {
[10:30:53.417]                     inherits <- base::inherits
[10:30:53.417]                     invokeRestart <- base::invokeRestart
[10:30:53.417]                     is.null <- base::is.null
[10:30:53.417]                     muffled <- FALSE
[10:30:53.417]                     if (inherits(cond, "message")) {
[10:30:53.417]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.417]                       if (muffled) 
[10:30:53.417]                         invokeRestart("muffleMessage")
[10:30:53.417]                     }
[10:30:53.417]                     else if (inherits(cond, "warning")) {
[10:30:53.417]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.417]                       if (muffled) 
[10:30:53.417]                         invokeRestart("muffleWarning")
[10:30:53.417]                     }
[10:30:53.417]                     else if (inherits(cond, "condition")) {
[10:30:53.417]                       if (!is.null(pattern)) {
[10:30:53.417]                         computeRestarts <- base::computeRestarts
[10:30:53.417]                         grepl <- base::grepl
[10:30:53.417]                         restarts <- computeRestarts(cond)
[10:30:53.417]                         for (restart in restarts) {
[10:30:53.417]                           name <- restart$name
[10:30:53.417]                           if (is.null(name)) 
[10:30:53.417]                             next
[10:30:53.417]                           if (!grepl(pattern, name)) 
[10:30:53.417]                             next
[10:30:53.417]                           invokeRestart(restart)
[10:30:53.417]                           muffled <- TRUE
[10:30:53.417]                           break
[10:30:53.417]                         }
[10:30:53.417]                       }
[10:30:53.417]                     }
[10:30:53.417]                     invisible(muffled)
[10:30:53.417]                   }
[10:30:53.417]                   muffleCondition(cond)
[10:30:53.417]                 })
[10:30:53.417]             }))
[10:30:53.417]             future::FutureResult(value = ...future.value$value, 
[10:30:53.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.417]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.417]                     ...future.globalenv.names))
[10:30:53.417]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.417]         }, condition = base::local({
[10:30:53.417]             c <- base::c
[10:30:53.417]             inherits <- base::inherits
[10:30:53.417]             invokeRestart <- base::invokeRestart
[10:30:53.417]             length <- base::length
[10:30:53.417]             list <- base::list
[10:30:53.417]             seq.int <- base::seq.int
[10:30:53.417]             signalCondition <- base::signalCondition
[10:30:53.417]             sys.calls <- base::sys.calls
[10:30:53.417]             `[[` <- base::`[[`
[10:30:53.417]             `+` <- base::`+`
[10:30:53.417]             `<<-` <- base::`<<-`
[10:30:53.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.417]                   3L)]
[10:30:53.417]             }
[10:30:53.417]             function(cond) {
[10:30:53.417]                 is_error <- inherits(cond, "error")
[10:30:53.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.417]                   NULL)
[10:30:53.417]                 if (is_error) {
[10:30:53.417]                   sessionInformation <- function() {
[10:30:53.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.417]                       search = base::search(), system = base::Sys.info())
[10:30:53.417]                   }
[10:30:53.417]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.417]                     cond$call), session = sessionInformation(), 
[10:30:53.417]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.417]                   signalCondition(cond)
[10:30:53.417]                 }
[10:30:53.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.417]                 "immediateCondition"))) {
[10:30:53.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.417]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.417]                   if (TRUE && !signal) {
[10:30:53.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.417]                     {
[10:30:53.417]                       inherits <- base::inherits
[10:30:53.417]                       invokeRestart <- base::invokeRestart
[10:30:53.417]                       is.null <- base::is.null
[10:30:53.417]                       muffled <- FALSE
[10:30:53.417]                       if (inherits(cond, "message")) {
[10:30:53.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.417]                         if (muffled) 
[10:30:53.417]                           invokeRestart("muffleMessage")
[10:30:53.417]                       }
[10:30:53.417]                       else if (inherits(cond, "warning")) {
[10:30:53.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.417]                         if (muffled) 
[10:30:53.417]                           invokeRestart("muffleWarning")
[10:30:53.417]                       }
[10:30:53.417]                       else if (inherits(cond, "condition")) {
[10:30:53.417]                         if (!is.null(pattern)) {
[10:30:53.417]                           computeRestarts <- base::computeRestarts
[10:30:53.417]                           grepl <- base::grepl
[10:30:53.417]                           restarts <- computeRestarts(cond)
[10:30:53.417]                           for (restart in restarts) {
[10:30:53.417]                             name <- restart$name
[10:30:53.417]                             if (is.null(name)) 
[10:30:53.417]                               next
[10:30:53.417]                             if (!grepl(pattern, name)) 
[10:30:53.417]                               next
[10:30:53.417]                             invokeRestart(restart)
[10:30:53.417]                             muffled <- TRUE
[10:30:53.417]                             break
[10:30:53.417]                           }
[10:30:53.417]                         }
[10:30:53.417]                       }
[10:30:53.417]                       invisible(muffled)
[10:30:53.417]                     }
[10:30:53.417]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.417]                   }
[10:30:53.417]                 }
[10:30:53.417]                 else {
[10:30:53.417]                   if (TRUE) {
[10:30:53.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.417]                     {
[10:30:53.417]                       inherits <- base::inherits
[10:30:53.417]                       invokeRestart <- base::invokeRestart
[10:30:53.417]                       is.null <- base::is.null
[10:30:53.417]                       muffled <- FALSE
[10:30:53.417]                       if (inherits(cond, "message")) {
[10:30:53.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.417]                         if (muffled) 
[10:30:53.417]                           invokeRestart("muffleMessage")
[10:30:53.417]                       }
[10:30:53.417]                       else if (inherits(cond, "warning")) {
[10:30:53.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.417]                         if (muffled) 
[10:30:53.417]                           invokeRestart("muffleWarning")
[10:30:53.417]                       }
[10:30:53.417]                       else if (inherits(cond, "condition")) {
[10:30:53.417]                         if (!is.null(pattern)) {
[10:30:53.417]                           computeRestarts <- base::computeRestarts
[10:30:53.417]                           grepl <- base::grepl
[10:30:53.417]                           restarts <- computeRestarts(cond)
[10:30:53.417]                           for (restart in restarts) {
[10:30:53.417]                             name <- restart$name
[10:30:53.417]                             if (is.null(name)) 
[10:30:53.417]                               next
[10:30:53.417]                             if (!grepl(pattern, name)) 
[10:30:53.417]                               next
[10:30:53.417]                             invokeRestart(restart)
[10:30:53.417]                             muffled <- TRUE
[10:30:53.417]                             break
[10:30:53.417]                           }
[10:30:53.417]                         }
[10:30:53.417]                       }
[10:30:53.417]                       invisible(muffled)
[10:30:53.417]                     }
[10:30:53.417]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.417]                   }
[10:30:53.417]                 }
[10:30:53.417]             }
[10:30:53.417]         }))
[10:30:53.417]     }, error = function(ex) {
[10:30:53.417]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.417]                 ...future.rng), started = ...future.startTime, 
[10:30:53.417]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.417]             version = "1.8"), class = "FutureResult")
[10:30:53.417]     }, finally = {
[10:30:53.417]         if (!identical(...future.workdir, getwd())) 
[10:30:53.417]             setwd(...future.workdir)
[10:30:53.417]         {
[10:30:53.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.417]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.417]             }
[10:30:53.417]             base::options(...future.oldOptions)
[10:30:53.417]             if (.Platform$OS.type == "windows") {
[10:30:53.417]                 old_names <- names(...future.oldEnvVars)
[10:30:53.417]                 envs <- base::Sys.getenv()
[10:30:53.417]                 names <- names(envs)
[10:30:53.417]                 common <- intersect(names, old_names)
[10:30:53.417]                 added <- setdiff(names, old_names)
[10:30:53.417]                 removed <- setdiff(old_names, names)
[10:30:53.417]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.417]                   envs[common]]
[10:30:53.417]                 NAMES <- toupper(changed)
[10:30:53.417]                 args <- list()
[10:30:53.417]                 for (kk in seq_along(NAMES)) {
[10:30:53.417]                   name <- changed[[kk]]
[10:30:53.417]                   NAME <- NAMES[[kk]]
[10:30:53.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.417]                     next
[10:30:53.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.417]                 }
[10:30:53.417]                 NAMES <- toupper(added)
[10:30:53.417]                 for (kk in seq_along(NAMES)) {
[10:30:53.417]                   name <- added[[kk]]
[10:30:53.417]                   NAME <- NAMES[[kk]]
[10:30:53.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.417]                     next
[10:30:53.417]                   args[[name]] <- ""
[10:30:53.417]                 }
[10:30:53.417]                 NAMES <- toupper(removed)
[10:30:53.417]                 for (kk in seq_along(NAMES)) {
[10:30:53.417]                   name <- removed[[kk]]
[10:30:53.417]                   NAME <- NAMES[[kk]]
[10:30:53.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.417]                     next
[10:30:53.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.417]                 }
[10:30:53.417]                 if (length(args) > 0) 
[10:30:53.417]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.417]             }
[10:30:53.417]             else {
[10:30:53.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.417]             }
[10:30:53.417]             {
[10:30:53.417]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.417]                   0L) {
[10:30:53.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.417]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.417]                   base::options(opts)
[10:30:53.417]                 }
[10:30:53.417]                 {
[10:30:53.417]                   {
[10:30:53.417]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.417]                     NULL
[10:30:53.417]                   }
[10:30:53.417]                   options(future.plan = NULL)
[10:30:53.417]                   if (is.na(NA_character_)) 
[10:30:53.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.417]                     .init = FALSE)
[10:30:53.417]                 }
[10:30:53.417]             }
[10:30:53.417]         }
[10:30:53.417]     })
[10:30:53.417]     if (TRUE) {
[10:30:53.417]         base::sink(type = "output", split = FALSE)
[10:30:53.417]         if (TRUE) {
[10:30:53.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.417]         }
[10:30:53.417]         else {
[10:30:53.417]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.417]         }
[10:30:53.417]         base::close(...future.stdout)
[10:30:53.417]         ...future.stdout <- NULL
[10:30:53.417]     }
[10:30:53.417]     ...future.result$conditions <- ...future.conditions
[10:30:53.417]     ...future.result$finished <- base::Sys.time()
[10:30:53.417]     ...future.result
[10:30:53.417] }
[10:30:53.420] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[10:30:53.420] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[10:30:53.421] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[10:30:53.421] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:53.421] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.422] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[10:30:53.422] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[10:30:53.422] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:53.422] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.423] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:53.423] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.423] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[10:30:53.424] MultisessionFuture started
[10:30:53.424] - Launch lazy future ... done
[10:30:53.424] run() for ‘MultisessionFuture’ ... done
[10:30:53.424] Created future:
[10:30:53.424] MultisessionFuture:
[10:30:53.424] Label: ‘future_mapply-1’
[10:30:53.424] Expression:
[10:30:53.424] {
[10:30:53.424]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.424]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.424]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.424]         on.exit(options(oopts), add = TRUE)
[10:30:53.424]     }
[10:30:53.424]     {
[10:30:53.424]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.424]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.424]         do.call(mapply, args = args)
[10:30:53.424]     }
[10:30:53.424] }
[10:30:53.424] Lazy evaluation: FALSE
[10:30:53.424] Asynchronous evaluation: TRUE
[10:30:53.424] Local evaluation: TRUE
[10:30:53.424] Environment: R_GlobalEnv
[10:30:53.424] Capture standard output: TRUE
[10:30:53.424] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.424] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.424] Packages: <none>
[10:30:53.424] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.424] Resolved: FALSE
[10:30:53.424] Value: <not collected>
[10:30:53.424] Conditions captured: <none>
[10:30:53.424] Early signaling: FALSE
[10:30:53.424] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.424] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.436] Chunk #1 of 5 ... DONE
[10:30:53.436] Chunk #2 of 5 ...
[10:30:53.436]  - Finding globals in '...' for chunk #2 ...
[10:30:53.436] getGlobalsAndPackages() ...
[10:30:53.436] Searching for globals...
[10:30:53.436] 
[10:30:53.437] Searching for globals ... DONE
[10:30:53.437] - globals: [0] <none>
[10:30:53.437] getGlobalsAndPackages() ... DONE
[10:30:53.437]    + additional globals found: [n=0] 
[10:30:53.437]    + additional namespaces needed: [n=0] 
[10:30:53.437]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:53.437]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:53.437]  - seeds: <none>
[10:30:53.437]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.437] getGlobalsAndPackages() ...
[10:30:53.438] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.438] Resolving globals: FALSE
[10:30:53.438] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:53.439] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:53.439] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.439] 
[10:30:53.439] getGlobalsAndPackages() ... DONE
[10:30:53.439] run() for ‘Future’ ...
[10:30:53.439] - state: ‘created’
[10:30:53.440] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.454] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.455]   - Field: ‘node’
[10:30:53.455]   - Field: ‘label’
[10:30:53.455]   - Field: ‘local’
[10:30:53.455]   - Field: ‘owner’
[10:30:53.455]   - Field: ‘envir’
[10:30:53.455]   - Field: ‘workers’
[10:30:53.455]   - Field: ‘packages’
[10:30:53.455]   - Field: ‘gc’
[10:30:53.455]   - Field: ‘conditions’
[10:30:53.455]   - Field: ‘persistent’
[10:30:53.455]   - Field: ‘expr’
[10:30:53.456]   - Field: ‘uuid’
[10:30:53.456]   - Field: ‘seed’
[10:30:53.456]   - Field: ‘version’
[10:30:53.456]   - Field: ‘result’
[10:30:53.456]   - Field: ‘asynchronous’
[10:30:53.456]   - Field: ‘calls’
[10:30:53.456]   - Field: ‘globals’
[10:30:53.456]   - Field: ‘stdout’
[10:30:53.456]   - Field: ‘earlySignal’
[10:30:53.456]   - Field: ‘lazy’
[10:30:53.456]   - Field: ‘state’
[10:30:53.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.457] - Launch lazy future ...
[10:30:53.457] Packages needed by the future expression (n = 0): <none>
[10:30:53.457] Packages needed by future strategies (n = 0): <none>
[10:30:53.458] {
[10:30:53.458]     {
[10:30:53.458]         {
[10:30:53.458]             ...future.startTime <- base::Sys.time()
[10:30:53.458]             {
[10:30:53.458]                 {
[10:30:53.458]                   {
[10:30:53.458]                     {
[10:30:53.458]                       base::local({
[10:30:53.458]                         has_future <- base::requireNamespace("future", 
[10:30:53.458]                           quietly = TRUE)
[10:30:53.458]                         if (has_future) {
[10:30:53.458]                           ns <- base::getNamespace("future")
[10:30:53.458]                           version <- ns[[".package"]][["version"]]
[10:30:53.458]                           if (is.null(version)) 
[10:30:53.458]                             version <- utils::packageVersion("future")
[10:30:53.458]                         }
[10:30:53.458]                         else {
[10:30:53.458]                           version <- NULL
[10:30:53.458]                         }
[10:30:53.458]                         if (!has_future || version < "1.8.0") {
[10:30:53.458]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.458]                             "", base::R.version$version.string), 
[10:30:53.458]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.458]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.458]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.458]                               "release", "version")], collapse = " "), 
[10:30:53.458]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.458]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.458]                             info)
[10:30:53.458]                           info <- base::paste(info, collapse = "; ")
[10:30:53.458]                           if (!has_future) {
[10:30:53.458]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.458]                               info)
[10:30:53.458]                           }
[10:30:53.458]                           else {
[10:30:53.458]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.458]                               info, version)
[10:30:53.458]                           }
[10:30:53.458]                           base::stop(msg)
[10:30:53.458]                         }
[10:30:53.458]                       })
[10:30:53.458]                     }
[10:30:53.458]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.458]                     base::options(mc.cores = 1L)
[10:30:53.458]                   }
[10:30:53.458]                   ...future.strategy.old <- future::plan("list")
[10:30:53.458]                   options(future.plan = NULL)
[10:30:53.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.458]                 }
[10:30:53.458]                 ...future.workdir <- getwd()
[10:30:53.458]             }
[10:30:53.458]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.458]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.458]         }
[10:30:53.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.458]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:53.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.458]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.458]             base::names(...future.oldOptions))
[10:30:53.458]     }
[10:30:53.458]     if (FALSE) {
[10:30:53.458]     }
[10:30:53.458]     else {
[10:30:53.458]         if (TRUE) {
[10:30:53.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.458]                 open = "w")
[10:30:53.458]         }
[10:30:53.458]         else {
[10:30:53.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.458]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.458]         }
[10:30:53.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.458]             base::sink(type = "output", split = FALSE)
[10:30:53.458]             base::close(...future.stdout)
[10:30:53.458]         }, add = TRUE)
[10:30:53.458]     }
[10:30:53.458]     ...future.frame <- base::sys.nframe()
[10:30:53.458]     ...future.conditions <- base::list()
[10:30:53.458]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.458]     if (FALSE) {
[10:30:53.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.458]     }
[10:30:53.458]     ...future.result <- base::tryCatch({
[10:30:53.458]         base::withCallingHandlers({
[10:30:53.458]             ...future.value <- base::withVisible(base::local({
[10:30:53.458]                 ...future.makeSendCondition <- base::local({
[10:30:53.458]                   sendCondition <- NULL
[10:30:53.458]                   function(frame = 1L) {
[10:30:53.458]                     if (is.function(sendCondition)) 
[10:30:53.458]                       return(sendCondition)
[10:30:53.458]                     ns <- getNamespace("parallel")
[10:30:53.458]                     if (exists("sendData", mode = "function", 
[10:30:53.458]                       envir = ns)) {
[10:30:53.458]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.458]                         envir = ns)
[10:30:53.458]                       envir <- sys.frame(frame)
[10:30:53.458]                       master <- NULL
[10:30:53.458]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.458]                         !identical(envir, emptyenv())) {
[10:30:53.458]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.458]                           inherits = FALSE)) {
[10:30:53.458]                           master <- get("master", mode = "list", 
[10:30:53.458]                             envir = envir, inherits = FALSE)
[10:30:53.458]                           if (inherits(master, c("SOCKnode", 
[10:30:53.458]                             "SOCK0node"))) {
[10:30:53.458]                             sendCondition <<- function(cond) {
[10:30:53.458]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.458]                                 success = TRUE)
[10:30:53.458]                               parallel_sendData(master, data)
[10:30:53.458]                             }
[10:30:53.458]                             return(sendCondition)
[10:30:53.458]                           }
[10:30:53.458]                         }
[10:30:53.458]                         frame <- frame + 1L
[10:30:53.458]                         envir <- sys.frame(frame)
[10:30:53.458]                       }
[10:30:53.458]                     }
[10:30:53.458]                     sendCondition <<- function(cond) NULL
[10:30:53.458]                   }
[10:30:53.458]                 })
[10:30:53.458]                 withCallingHandlers({
[10:30:53.458]                   {
[10:30:53.458]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.458]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.458]                       ...future.globals.maxSize)) {
[10:30:53.458]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.458]                       on.exit(options(oopts), add = TRUE)
[10:30:53.458]                     }
[10:30:53.458]                     {
[10:30:53.458]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.458]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.458]                         USE.NAMES = FALSE)
[10:30:53.458]                       do.call(mapply, args = args)
[10:30:53.458]                     }
[10:30:53.458]                   }
[10:30:53.458]                 }, immediateCondition = function(cond) {
[10:30:53.458]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.458]                   sendCondition(cond)
[10:30:53.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.458]                   {
[10:30:53.458]                     inherits <- base::inherits
[10:30:53.458]                     invokeRestart <- base::invokeRestart
[10:30:53.458]                     is.null <- base::is.null
[10:30:53.458]                     muffled <- FALSE
[10:30:53.458]                     if (inherits(cond, "message")) {
[10:30:53.458]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.458]                       if (muffled) 
[10:30:53.458]                         invokeRestart("muffleMessage")
[10:30:53.458]                     }
[10:30:53.458]                     else if (inherits(cond, "warning")) {
[10:30:53.458]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.458]                       if (muffled) 
[10:30:53.458]                         invokeRestart("muffleWarning")
[10:30:53.458]                     }
[10:30:53.458]                     else if (inherits(cond, "condition")) {
[10:30:53.458]                       if (!is.null(pattern)) {
[10:30:53.458]                         computeRestarts <- base::computeRestarts
[10:30:53.458]                         grepl <- base::grepl
[10:30:53.458]                         restarts <- computeRestarts(cond)
[10:30:53.458]                         for (restart in restarts) {
[10:30:53.458]                           name <- restart$name
[10:30:53.458]                           if (is.null(name)) 
[10:30:53.458]                             next
[10:30:53.458]                           if (!grepl(pattern, name)) 
[10:30:53.458]                             next
[10:30:53.458]                           invokeRestart(restart)
[10:30:53.458]                           muffled <- TRUE
[10:30:53.458]                           break
[10:30:53.458]                         }
[10:30:53.458]                       }
[10:30:53.458]                     }
[10:30:53.458]                     invisible(muffled)
[10:30:53.458]                   }
[10:30:53.458]                   muffleCondition(cond)
[10:30:53.458]                 })
[10:30:53.458]             }))
[10:30:53.458]             future::FutureResult(value = ...future.value$value, 
[10:30:53.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.458]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.458]                     ...future.globalenv.names))
[10:30:53.458]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.458]         }, condition = base::local({
[10:30:53.458]             c <- base::c
[10:30:53.458]             inherits <- base::inherits
[10:30:53.458]             invokeRestart <- base::invokeRestart
[10:30:53.458]             length <- base::length
[10:30:53.458]             list <- base::list
[10:30:53.458]             seq.int <- base::seq.int
[10:30:53.458]             signalCondition <- base::signalCondition
[10:30:53.458]             sys.calls <- base::sys.calls
[10:30:53.458]             `[[` <- base::`[[`
[10:30:53.458]             `+` <- base::`+`
[10:30:53.458]             `<<-` <- base::`<<-`
[10:30:53.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.458]                   3L)]
[10:30:53.458]             }
[10:30:53.458]             function(cond) {
[10:30:53.458]                 is_error <- inherits(cond, "error")
[10:30:53.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.458]                   NULL)
[10:30:53.458]                 if (is_error) {
[10:30:53.458]                   sessionInformation <- function() {
[10:30:53.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.458]                       search = base::search(), system = base::Sys.info())
[10:30:53.458]                   }
[10:30:53.458]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.458]                     cond$call), session = sessionInformation(), 
[10:30:53.458]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.458]                   signalCondition(cond)
[10:30:53.458]                 }
[10:30:53.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.458]                 "immediateCondition"))) {
[10:30:53.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.458]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.458]                   if (TRUE && !signal) {
[10:30:53.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.458]                     {
[10:30:53.458]                       inherits <- base::inherits
[10:30:53.458]                       invokeRestart <- base::invokeRestart
[10:30:53.458]                       is.null <- base::is.null
[10:30:53.458]                       muffled <- FALSE
[10:30:53.458]                       if (inherits(cond, "message")) {
[10:30:53.458]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.458]                         if (muffled) 
[10:30:53.458]                           invokeRestart("muffleMessage")
[10:30:53.458]                       }
[10:30:53.458]                       else if (inherits(cond, "warning")) {
[10:30:53.458]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.458]                         if (muffled) 
[10:30:53.458]                           invokeRestart("muffleWarning")
[10:30:53.458]                       }
[10:30:53.458]                       else if (inherits(cond, "condition")) {
[10:30:53.458]                         if (!is.null(pattern)) {
[10:30:53.458]                           computeRestarts <- base::computeRestarts
[10:30:53.458]                           grepl <- base::grepl
[10:30:53.458]                           restarts <- computeRestarts(cond)
[10:30:53.458]                           for (restart in restarts) {
[10:30:53.458]                             name <- restart$name
[10:30:53.458]                             if (is.null(name)) 
[10:30:53.458]                               next
[10:30:53.458]                             if (!grepl(pattern, name)) 
[10:30:53.458]                               next
[10:30:53.458]                             invokeRestart(restart)
[10:30:53.458]                             muffled <- TRUE
[10:30:53.458]                             break
[10:30:53.458]                           }
[10:30:53.458]                         }
[10:30:53.458]                       }
[10:30:53.458]                       invisible(muffled)
[10:30:53.458]                     }
[10:30:53.458]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.458]                   }
[10:30:53.458]                 }
[10:30:53.458]                 else {
[10:30:53.458]                   if (TRUE) {
[10:30:53.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.458]                     {
[10:30:53.458]                       inherits <- base::inherits
[10:30:53.458]                       invokeRestart <- base::invokeRestart
[10:30:53.458]                       is.null <- base::is.null
[10:30:53.458]                       muffled <- FALSE
[10:30:53.458]                       if (inherits(cond, "message")) {
[10:30:53.458]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.458]                         if (muffled) 
[10:30:53.458]                           invokeRestart("muffleMessage")
[10:30:53.458]                       }
[10:30:53.458]                       else if (inherits(cond, "warning")) {
[10:30:53.458]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.458]                         if (muffled) 
[10:30:53.458]                           invokeRestart("muffleWarning")
[10:30:53.458]                       }
[10:30:53.458]                       else if (inherits(cond, "condition")) {
[10:30:53.458]                         if (!is.null(pattern)) {
[10:30:53.458]                           computeRestarts <- base::computeRestarts
[10:30:53.458]                           grepl <- base::grepl
[10:30:53.458]                           restarts <- computeRestarts(cond)
[10:30:53.458]                           for (restart in restarts) {
[10:30:53.458]                             name <- restart$name
[10:30:53.458]                             if (is.null(name)) 
[10:30:53.458]                               next
[10:30:53.458]                             if (!grepl(pattern, name)) 
[10:30:53.458]                               next
[10:30:53.458]                             invokeRestart(restart)
[10:30:53.458]                             muffled <- TRUE
[10:30:53.458]                             break
[10:30:53.458]                           }
[10:30:53.458]                         }
[10:30:53.458]                       }
[10:30:53.458]                       invisible(muffled)
[10:30:53.458]                     }
[10:30:53.458]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.458]                   }
[10:30:53.458]                 }
[10:30:53.458]             }
[10:30:53.458]         }))
[10:30:53.458]     }, error = function(ex) {
[10:30:53.458]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.458]                 ...future.rng), started = ...future.startTime, 
[10:30:53.458]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.458]             version = "1.8"), class = "FutureResult")
[10:30:53.458]     }, finally = {
[10:30:53.458]         if (!identical(...future.workdir, getwd())) 
[10:30:53.458]             setwd(...future.workdir)
[10:30:53.458]         {
[10:30:53.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.458]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.458]             }
[10:30:53.458]             base::options(...future.oldOptions)
[10:30:53.458]             if (.Platform$OS.type == "windows") {
[10:30:53.458]                 old_names <- names(...future.oldEnvVars)
[10:30:53.458]                 envs <- base::Sys.getenv()
[10:30:53.458]                 names <- names(envs)
[10:30:53.458]                 common <- intersect(names, old_names)
[10:30:53.458]                 added <- setdiff(names, old_names)
[10:30:53.458]                 removed <- setdiff(old_names, names)
[10:30:53.458]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.458]                   envs[common]]
[10:30:53.458]                 NAMES <- toupper(changed)
[10:30:53.458]                 args <- list()
[10:30:53.458]                 for (kk in seq_along(NAMES)) {
[10:30:53.458]                   name <- changed[[kk]]
[10:30:53.458]                   NAME <- NAMES[[kk]]
[10:30:53.458]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.458]                     next
[10:30:53.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.458]                 }
[10:30:53.458]                 NAMES <- toupper(added)
[10:30:53.458]                 for (kk in seq_along(NAMES)) {
[10:30:53.458]                   name <- added[[kk]]
[10:30:53.458]                   NAME <- NAMES[[kk]]
[10:30:53.458]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.458]                     next
[10:30:53.458]                   args[[name]] <- ""
[10:30:53.458]                 }
[10:30:53.458]                 NAMES <- toupper(removed)
[10:30:53.458]                 for (kk in seq_along(NAMES)) {
[10:30:53.458]                   name <- removed[[kk]]
[10:30:53.458]                   NAME <- NAMES[[kk]]
[10:30:53.458]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.458]                     next
[10:30:53.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.458]                 }
[10:30:53.458]                 if (length(args) > 0) 
[10:30:53.458]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.458]             }
[10:30:53.458]             else {
[10:30:53.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.458]             }
[10:30:53.458]             {
[10:30:53.458]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.458]                   0L) {
[10:30:53.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.458]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.458]                   base::options(opts)
[10:30:53.458]                 }
[10:30:53.458]                 {
[10:30:53.458]                   {
[10:30:53.458]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.458]                     NULL
[10:30:53.458]                   }
[10:30:53.458]                   options(future.plan = NULL)
[10:30:53.458]                   if (is.na(NA_character_)) 
[10:30:53.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.458]                     .init = FALSE)
[10:30:53.458]                 }
[10:30:53.458]             }
[10:30:53.458]         }
[10:30:53.458]     })
[10:30:53.458]     if (TRUE) {
[10:30:53.458]         base::sink(type = "output", split = FALSE)
[10:30:53.458]         if (TRUE) {
[10:30:53.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.458]         }
[10:30:53.458]         else {
[10:30:53.458]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.458]         }
[10:30:53.458]         base::close(...future.stdout)
[10:30:53.458]         ...future.stdout <- NULL
[10:30:53.458]     }
[10:30:53.458]     ...future.result$conditions <- ...future.conditions
[10:30:53.458]     ...future.result$finished <- base::Sys.time()
[10:30:53.458]     ...future.result
[10:30:53.458] }
[10:30:53.461] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[10:30:53.461] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[10:30:53.461] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[10:30:53.461] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:53.462] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.462] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[10:30:53.462] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[10:30:53.462] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:53.463] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.465] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:53.466] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.466] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[10:30:53.467] MultisessionFuture started
[10:30:53.467] - Launch lazy future ... done
[10:30:53.467] run() for ‘MultisessionFuture’ ... done
[10:30:53.467] Created future:
[10:30:53.468] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.468] - Validating connection of MultisessionFuture
[10:30:53.469] - received message: FutureResult
[10:30:53.469] - Received FutureResult
[10:30:53.469] - Erased future from FutureRegistry
[10:30:53.469] result() for ClusterFuture ...
[10:30:53.469] - result already collected: FutureResult
[10:30:53.469] result() for ClusterFuture ... done
[10:30:53.469] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.467] MultisessionFuture:
[10:30:53.467] Label: ‘future_mapply-2’
[10:30:53.467] Expression:
[10:30:53.467] {
[10:30:53.467]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.467]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.467]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.467]         on.exit(options(oopts), add = TRUE)
[10:30:53.467]     }
[10:30:53.467]     {
[10:30:53.467]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.467]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.467]         do.call(mapply, args = args)
[10:30:53.467]     }
[10:30:53.467] }
[10:30:53.467] Lazy evaluation: FALSE
[10:30:53.467] Asynchronous evaluation: TRUE
[10:30:53.467] Local evaluation: TRUE
[10:30:53.467] Environment: R_GlobalEnv
[10:30:53.467] Capture standard output: TRUE
[10:30:53.467] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.467] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.467] Packages: <none>
[10:30:53.467] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.467] Resolved: TRUE
[10:30:53.467] Value: <not collected>
[10:30:53.467] Conditions captured: <none>
[10:30:53.467] Early signaling: FALSE
[10:30:53.467] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.467] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.470] Chunk #2 of 5 ... DONE
[10:30:53.470] Chunk #3 of 5 ...
[10:30:53.470]  - Finding globals in '...' for chunk #3 ...
[10:30:53.470] getGlobalsAndPackages() ...
[10:30:53.470] Searching for globals...
[10:30:53.470] 
[10:30:53.470] Searching for globals ... DONE
[10:30:53.470] - globals: [0] <none>
[10:30:53.471] getGlobalsAndPackages() ... DONE
[10:30:53.471]    + additional globals found: [n=0] 
[10:30:53.471]    + additional namespaces needed: [n=0] 
[10:30:53.471]  - Finding globals in '...' for chunk #3 ... DONE
[10:30:53.471]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:53.471]  - seeds: <none>
[10:30:53.471]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.471] getGlobalsAndPackages() ...
[10:30:53.471] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.471] Resolving globals: FALSE
[10:30:53.472] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:53.472] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:53.472] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.473] 
[10:30:53.473] getGlobalsAndPackages() ... DONE
[10:30:53.473] run() for ‘Future’ ...
[10:30:53.473] - state: ‘created’
[10:30:53.473] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.487] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.487] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.487]   - Field: ‘node’
[10:30:53.487]   - Field: ‘label’
[10:30:53.487]   - Field: ‘local’
[10:30:53.487]   - Field: ‘owner’
[10:30:53.488]   - Field: ‘envir’
[10:30:53.488]   - Field: ‘workers’
[10:30:53.488]   - Field: ‘packages’
[10:30:53.488]   - Field: ‘gc’
[10:30:53.488]   - Field: ‘conditions’
[10:30:53.488]   - Field: ‘persistent’
[10:30:53.488]   - Field: ‘expr’
[10:30:53.488]   - Field: ‘uuid’
[10:30:53.488]   - Field: ‘seed’
[10:30:53.488]   - Field: ‘version’
[10:30:53.488]   - Field: ‘result’
[10:30:53.488]   - Field: ‘asynchronous’
[10:30:53.489]   - Field: ‘calls’
[10:30:53.489]   - Field: ‘globals’
[10:30:53.489]   - Field: ‘stdout’
[10:30:53.489]   - Field: ‘earlySignal’
[10:30:53.489]   - Field: ‘lazy’
[10:30:53.489]   - Field: ‘state’
[10:30:53.489] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.489] - Launch lazy future ...
[10:30:53.490] Packages needed by the future expression (n = 0): <none>
[10:30:53.490] Packages needed by future strategies (n = 0): <none>
[10:30:53.490] {
[10:30:53.490]     {
[10:30:53.490]         {
[10:30:53.490]             ...future.startTime <- base::Sys.time()
[10:30:53.490]             {
[10:30:53.490]                 {
[10:30:53.490]                   {
[10:30:53.490]                     {
[10:30:53.490]                       base::local({
[10:30:53.490]                         has_future <- base::requireNamespace("future", 
[10:30:53.490]                           quietly = TRUE)
[10:30:53.490]                         if (has_future) {
[10:30:53.490]                           ns <- base::getNamespace("future")
[10:30:53.490]                           version <- ns[[".package"]][["version"]]
[10:30:53.490]                           if (is.null(version)) 
[10:30:53.490]                             version <- utils::packageVersion("future")
[10:30:53.490]                         }
[10:30:53.490]                         else {
[10:30:53.490]                           version <- NULL
[10:30:53.490]                         }
[10:30:53.490]                         if (!has_future || version < "1.8.0") {
[10:30:53.490]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.490]                             "", base::R.version$version.string), 
[10:30:53.490]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.490]                               "release", "version")], collapse = " "), 
[10:30:53.490]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.490]                             info)
[10:30:53.490]                           info <- base::paste(info, collapse = "; ")
[10:30:53.490]                           if (!has_future) {
[10:30:53.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.490]                               info)
[10:30:53.490]                           }
[10:30:53.490]                           else {
[10:30:53.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.490]                               info, version)
[10:30:53.490]                           }
[10:30:53.490]                           base::stop(msg)
[10:30:53.490]                         }
[10:30:53.490]                       })
[10:30:53.490]                     }
[10:30:53.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.490]                     base::options(mc.cores = 1L)
[10:30:53.490]                   }
[10:30:53.490]                   ...future.strategy.old <- future::plan("list")
[10:30:53.490]                   options(future.plan = NULL)
[10:30:53.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.490]                 }
[10:30:53.490]                 ...future.workdir <- getwd()
[10:30:53.490]             }
[10:30:53.490]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.490]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.490]         }
[10:30:53.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.490]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:53.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.490]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.490]             base::names(...future.oldOptions))
[10:30:53.490]     }
[10:30:53.490]     if (FALSE) {
[10:30:53.490]     }
[10:30:53.490]     else {
[10:30:53.490]         if (TRUE) {
[10:30:53.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.490]                 open = "w")
[10:30:53.490]         }
[10:30:53.490]         else {
[10:30:53.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.490]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.490]         }
[10:30:53.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.490]             base::sink(type = "output", split = FALSE)
[10:30:53.490]             base::close(...future.stdout)
[10:30:53.490]         }, add = TRUE)
[10:30:53.490]     }
[10:30:53.490]     ...future.frame <- base::sys.nframe()
[10:30:53.490]     ...future.conditions <- base::list()
[10:30:53.490]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.490]     if (FALSE) {
[10:30:53.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.490]     }
[10:30:53.490]     ...future.result <- base::tryCatch({
[10:30:53.490]         base::withCallingHandlers({
[10:30:53.490]             ...future.value <- base::withVisible(base::local({
[10:30:53.490]                 ...future.makeSendCondition <- base::local({
[10:30:53.490]                   sendCondition <- NULL
[10:30:53.490]                   function(frame = 1L) {
[10:30:53.490]                     if (is.function(sendCondition)) 
[10:30:53.490]                       return(sendCondition)
[10:30:53.490]                     ns <- getNamespace("parallel")
[10:30:53.490]                     if (exists("sendData", mode = "function", 
[10:30:53.490]                       envir = ns)) {
[10:30:53.490]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.490]                         envir = ns)
[10:30:53.490]                       envir <- sys.frame(frame)
[10:30:53.490]                       master <- NULL
[10:30:53.490]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.490]                         !identical(envir, emptyenv())) {
[10:30:53.490]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.490]                           inherits = FALSE)) {
[10:30:53.490]                           master <- get("master", mode = "list", 
[10:30:53.490]                             envir = envir, inherits = FALSE)
[10:30:53.490]                           if (inherits(master, c("SOCKnode", 
[10:30:53.490]                             "SOCK0node"))) {
[10:30:53.490]                             sendCondition <<- function(cond) {
[10:30:53.490]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.490]                                 success = TRUE)
[10:30:53.490]                               parallel_sendData(master, data)
[10:30:53.490]                             }
[10:30:53.490]                             return(sendCondition)
[10:30:53.490]                           }
[10:30:53.490]                         }
[10:30:53.490]                         frame <- frame + 1L
[10:30:53.490]                         envir <- sys.frame(frame)
[10:30:53.490]                       }
[10:30:53.490]                     }
[10:30:53.490]                     sendCondition <<- function(cond) NULL
[10:30:53.490]                   }
[10:30:53.490]                 })
[10:30:53.490]                 withCallingHandlers({
[10:30:53.490]                   {
[10:30:53.490]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.490]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.490]                       ...future.globals.maxSize)) {
[10:30:53.490]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.490]                       on.exit(options(oopts), add = TRUE)
[10:30:53.490]                     }
[10:30:53.490]                     {
[10:30:53.490]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.490]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.490]                         USE.NAMES = FALSE)
[10:30:53.490]                       do.call(mapply, args = args)
[10:30:53.490]                     }
[10:30:53.490]                   }
[10:30:53.490]                 }, immediateCondition = function(cond) {
[10:30:53.490]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.490]                   sendCondition(cond)
[10:30:53.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.490]                   {
[10:30:53.490]                     inherits <- base::inherits
[10:30:53.490]                     invokeRestart <- base::invokeRestart
[10:30:53.490]                     is.null <- base::is.null
[10:30:53.490]                     muffled <- FALSE
[10:30:53.490]                     if (inherits(cond, "message")) {
[10:30:53.490]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.490]                       if (muffled) 
[10:30:53.490]                         invokeRestart("muffleMessage")
[10:30:53.490]                     }
[10:30:53.490]                     else if (inherits(cond, "warning")) {
[10:30:53.490]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.490]                       if (muffled) 
[10:30:53.490]                         invokeRestart("muffleWarning")
[10:30:53.490]                     }
[10:30:53.490]                     else if (inherits(cond, "condition")) {
[10:30:53.490]                       if (!is.null(pattern)) {
[10:30:53.490]                         computeRestarts <- base::computeRestarts
[10:30:53.490]                         grepl <- base::grepl
[10:30:53.490]                         restarts <- computeRestarts(cond)
[10:30:53.490]                         for (restart in restarts) {
[10:30:53.490]                           name <- restart$name
[10:30:53.490]                           if (is.null(name)) 
[10:30:53.490]                             next
[10:30:53.490]                           if (!grepl(pattern, name)) 
[10:30:53.490]                             next
[10:30:53.490]                           invokeRestart(restart)
[10:30:53.490]                           muffled <- TRUE
[10:30:53.490]                           break
[10:30:53.490]                         }
[10:30:53.490]                       }
[10:30:53.490]                     }
[10:30:53.490]                     invisible(muffled)
[10:30:53.490]                   }
[10:30:53.490]                   muffleCondition(cond)
[10:30:53.490]                 })
[10:30:53.490]             }))
[10:30:53.490]             future::FutureResult(value = ...future.value$value, 
[10:30:53.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.490]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.490]                     ...future.globalenv.names))
[10:30:53.490]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.490]         }, condition = base::local({
[10:30:53.490]             c <- base::c
[10:30:53.490]             inherits <- base::inherits
[10:30:53.490]             invokeRestart <- base::invokeRestart
[10:30:53.490]             length <- base::length
[10:30:53.490]             list <- base::list
[10:30:53.490]             seq.int <- base::seq.int
[10:30:53.490]             signalCondition <- base::signalCondition
[10:30:53.490]             sys.calls <- base::sys.calls
[10:30:53.490]             `[[` <- base::`[[`
[10:30:53.490]             `+` <- base::`+`
[10:30:53.490]             `<<-` <- base::`<<-`
[10:30:53.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.490]                   3L)]
[10:30:53.490]             }
[10:30:53.490]             function(cond) {
[10:30:53.490]                 is_error <- inherits(cond, "error")
[10:30:53.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.490]                   NULL)
[10:30:53.490]                 if (is_error) {
[10:30:53.490]                   sessionInformation <- function() {
[10:30:53.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.490]                       search = base::search(), system = base::Sys.info())
[10:30:53.490]                   }
[10:30:53.490]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.490]                     cond$call), session = sessionInformation(), 
[10:30:53.490]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.490]                   signalCondition(cond)
[10:30:53.490]                 }
[10:30:53.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.490]                 "immediateCondition"))) {
[10:30:53.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.490]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.490]                   if (TRUE && !signal) {
[10:30:53.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.490]                     {
[10:30:53.490]                       inherits <- base::inherits
[10:30:53.490]                       invokeRestart <- base::invokeRestart
[10:30:53.490]                       is.null <- base::is.null
[10:30:53.490]                       muffled <- FALSE
[10:30:53.490]                       if (inherits(cond, "message")) {
[10:30:53.490]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.490]                         if (muffled) 
[10:30:53.490]                           invokeRestart("muffleMessage")
[10:30:53.490]                       }
[10:30:53.490]                       else if (inherits(cond, "warning")) {
[10:30:53.490]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.490]                         if (muffled) 
[10:30:53.490]                           invokeRestart("muffleWarning")
[10:30:53.490]                       }
[10:30:53.490]                       else if (inherits(cond, "condition")) {
[10:30:53.490]                         if (!is.null(pattern)) {
[10:30:53.490]                           computeRestarts <- base::computeRestarts
[10:30:53.490]                           grepl <- base::grepl
[10:30:53.490]                           restarts <- computeRestarts(cond)
[10:30:53.490]                           for (restart in restarts) {
[10:30:53.490]                             name <- restart$name
[10:30:53.490]                             if (is.null(name)) 
[10:30:53.490]                               next
[10:30:53.490]                             if (!grepl(pattern, name)) 
[10:30:53.490]                               next
[10:30:53.490]                             invokeRestart(restart)
[10:30:53.490]                             muffled <- TRUE
[10:30:53.490]                             break
[10:30:53.490]                           }
[10:30:53.490]                         }
[10:30:53.490]                       }
[10:30:53.490]                       invisible(muffled)
[10:30:53.490]                     }
[10:30:53.490]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.490]                   }
[10:30:53.490]                 }
[10:30:53.490]                 else {
[10:30:53.490]                   if (TRUE) {
[10:30:53.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.490]                     {
[10:30:53.490]                       inherits <- base::inherits
[10:30:53.490]                       invokeRestart <- base::invokeRestart
[10:30:53.490]                       is.null <- base::is.null
[10:30:53.490]                       muffled <- FALSE
[10:30:53.490]                       if (inherits(cond, "message")) {
[10:30:53.490]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.490]                         if (muffled) 
[10:30:53.490]                           invokeRestart("muffleMessage")
[10:30:53.490]                       }
[10:30:53.490]                       else if (inherits(cond, "warning")) {
[10:30:53.490]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.490]                         if (muffled) 
[10:30:53.490]                           invokeRestart("muffleWarning")
[10:30:53.490]                       }
[10:30:53.490]                       else if (inherits(cond, "condition")) {
[10:30:53.490]                         if (!is.null(pattern)) {
[10:30:53.490]                           computeRestarts <- base::computeRestarts
[10:30:53.490]                           grepl <- base::grepl
[10:30:53.490]                           restarts <- computeRestarts(cond)
[10:30:53.490]                           for (restart in restarts) {
[10:30:53.490]                             name <- restart$name
[10:30:53.490]                             if (is.null(name)) 
[10:30:53.490]                               next
[10:30:53.490]                             if (!grepl(pattern, name)) 
[10:30:53.490]                               next
[10:30:53.490]                             invokeRestart(restart)
[10:30:53.490]                             muffled <- TRUE
[10:30:53.490]                             break
[10:30:53.490]                           }
[10:30:53.490]                         }
[10:30:53.490]                       }
[10:30:53.490]                       invisible(muffled)
[10:30:53.490]                     }
[10:30:53.490]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.490]                   }
[10:30:53.490]                 }
[10:30:53.490]             }
[10:30:53.490]         }))
[10:30:53.490]     }, error = function(ex) {
[10:30:53.490]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.490]                 ...future.rng), started = ...future.startTime, 
[10:30:53.490]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.490]             version = "1.8"), class = "FutureResult")
[10:30:53.490]     }, finally = {
[10:30:53.490]         if (!identical(...future.workdir, getwd())) 
[10:30:53.490]             setwd(...future.workdir)
[10:30:53.490]         {
[10:30:53.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.490]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.490]             }
[10:30:53.490]             base::options(...future.oldOptions)
[10:30:53.490]             if (.Platform$OS.type == "windows") {
[10:30:53.490]                 old_names <- names(...future.oldEnvVars)
[10:30:53.490]                 envs <- base::Sys.getenv()
[10:30:53.490]                 names <- names(envs)
[10:30:53.490]                 common <- intersect(names, old_names)
[10:30:53.490]                 added <- setdiff(names, old_names)
[10:30:53.490]                 removed <- setdiff(old_names, names)
[10:30:53.490]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.490]                   envs[common]]
[10:30:53.490]                 NAMES <- toupper(changed)
[10:30:53.490]                 args <- list()
[10:30:53.490]                 for (kk in seq_along(NAMES)) {
[10:30:53.490]                   name <- changed[[kk]]
[10:30:53.490]                   NAME <- NAMES[[kk]]
[10:30:53.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.490]                     next
[10:30:53.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.490]                 }
[10:30:53.490]                 NAMES <- toupper(added)
[10:30:53.490]                 for (kk in seq_along(NAMES)) {
[10:30:53.490]                   name <- added[[kk]]
[10:30:53.490]                   NAME <- NAMES[[kk]]
[10:30:53.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.490]                     next
[10:30:53.490]                   args[[name]] <- ""
[10:30:53.490]                 }
[10:30:53.490]                 NAMES <- toupper(removed)
[10:30:53.490]                 for (kk in seq_along(NAMES)) {
[10:30:53.490]                   name <- removed[[kk]]
[10:30:53.490]                   NAME <- NAMES[[kk]]
[10:30:53.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.490]                     next
[10:30:53.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.490]                 }
[10:30:53.490]                 if (length(args) > 0) 
[10:30:53.490]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.490]             }
[10:30:53.490]             else {
[10:30:53.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.490]             }
[10:30:53.490]             {
[10:30:53.490]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.490]                   0L) {
[10:30:53.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.490]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.490]                   base::options(opts)
[10:30:53.490]                 }
[10:30:53.490]                 {
[10:30:53.490]                   {
[10:30:53.490]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.490]                     NULL
[10:30:53.490]                   }
[10:30:53.490]                   options(future.plan = NULL)
[10:30:53.490]                   if (is.na(NA_character_)) 
[10:30:53.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.490]                     .init = FALSE)
[10:30:53.490]                 }
[10:30:53.490]             }
[10:30:53.490]         }
[10:30:53.490]     })
[10:30:53.490]     if (TRUE) {
[10:30:53.490]         base::sink(type = "output", split = FALSE)
[10:30:53.490]         if (TRUE) {
[10:30:53.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.490]         }
[10:30:53.490]         else {
[10:30:53.490]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.490]         }
[10:30:53.490]         base::close(...future.stdout)
[10:30:53.490]         ...future.stdout <- NULL
[10:30:53.490]     }
[10:30:53.490]     ...future.result$conditions <- ...future.conditions
[10:30:53.490]     ...future.result$finished <- base::Sys.time()
[10:30:53.490]     ...future.result
[10:30:53.490] }
[10:30:53.493] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[10:30:53.493] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[10:30:53.493] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[10:30:53.494] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:53.494] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.494] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[10:30:53.494] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[10:30:53.495] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:53.495] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.495] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:53.495] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.496] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[10:30:53.496] MultisessionFuture started
[10:30:53.496] - Launch lazy future ... done
[10:30:53.496] run() for ‘MultisessionFuture’ ... done
[10:30:53.497] Created future:
[10:30:53.497] MultisessionFuture:
[10:30:53.497] Label: ‘future_mapply-3’
[10:30:53.497] Expression:
[10:30:53.497] {
[10:30:53.497]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.497]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.497]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.497]         on.exit(options(oopts), add = TRUE)
[10:30:53.497]     }
[10:30:53.497]     {
[10:30:53.497]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.497]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.497]         do.call(mapply, args = args)
[10:30:53.497]     }
[10:30:53.497] }
[10:30:53.497] Lazy evaluation: FALSE
[10:30:53.497] Asynchronous evaluation: TRUE
[10:30:53.497] Local evaluation: TRUE
[10:30:53.497] Environment: R_GlobalEnv
[10:30:53.497] Capture standard output: TRUE
[10:30:53.497] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.497] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.497] Packages: <none>
[10:30:53.497] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.497] Resolved: FALSE
[10:30:53.497] Value: <not collected>
[10:30:53.497] Conditions captured: <none>
[10:30:53.497] Early signaling: FALSE
[10:30:53.497] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.497] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.508] Chunk #3 of 5 ... DONE
[10:30:53.508] Chunk #4 of 5 ...
[10:30:53.508]  - Finding globals in '...' for chunk #4 ...
[10:30:53.509] getGlobalsAndPackages() ...
[10:30:53.509] Searching for globals...
[10:30:53.509] 
[10:30:53.509] Searching for globals ... DONE
[10:30:53.509] - globals: [0] <none>
[10:30:53.509] getGlobalsAndPackages() ... DONE
[10:30:53.509]    + additional globals found: [n=0] 
[10:30:53.510]    + additional namespaces needed: [n=0] 
[10:30:53.510]  - Finding globals in '...' for chunk #4 ... DONE
[10:30:53.510]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:53.510]  - seeds: <none>
[10:30:53.510]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.510] getGlobalsAndPackages() ...
[10:30:53.510] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.510] Resolving globals: FALSE
[10:30:53.511] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:53.511] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:53.511] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.511] 
[10:30:53.511] getGlobalsAndPackages() ... DONE
[10:30:53.512] run() for ‘Future’ ...
[10:30:53.512] - state: ‘created’
[10:30:53.512] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.526]   - Field: ‘node’
[10:30:53.526]   - Field: ‘label’
[10:30:53.526]   - Field: ‘local’
[10:30:53.527]   - Field: ‘owner’
[10:30:53.527]   - Field: ‘envir’
[10:30:53.527]   - Field: ‘workers’
[10:30:53.527]   - Field: ‘packages’
[10:30:53.527]   - Field: ‘gc’
[10:30:53.527]   - Field: ‘conditions’
[10:30:53.527]   - Field: ‘persistent’
[10:30:53.527]   - Field: ‘expr’
[10:30:53.527]   - Field: ‘uuid’
[10:30:53.527]   - Field: ‘seed’
[10:30:53.527]   - Field: ‘version’
[10:30:53.528]   - Field: ‘result’
[10:30:53.528]   - Field: ‘asynchronous’
[10:30:53.528]   - Field: ‘calls’
[10:30:53.528]   - Field: ‘globals’
[10:30:53.528]   - Field: ‘stdout’
[10:30:53.528]   - Field: ‘earlySignal’
[10:30:53.528]   - Field: ‘lazy’
[10:30:53.528]   - Field: ‘state’
[10:30:53.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.528] - Launch lazy future ...
[10:30:53.529] Packages needed by the future expression (n = 0): <none>
[10:30:53.529] Packages needed by future strategies (n = 0): <none>
[10:30:53.529] {
[10:30:53.529]     {
[10:30:53.529]         {
[10:30:53.529]             ...future.startTime <- base::Sys.time()
[10:30:53.529]             {
[10:30:53.529]                 {
[10:30:53.529]                   {
[10:30:53.529]                     {
[10:30:53.529]                       base::local({
[10:30:53.529]                         has_future <- base::requireNamespace("future", 
[10:30:53.529]                           quietly = TRUE)
[10:30:53.529]                         if (has_future) {
[10:30:53.529]                           ns <- base::getNamespace("future")
[10:30:53.529]                           version <- ns[[".package"]][["version"]]
[10:30:53.529]                           if (is.null(version)) 
[10:30:53.529]                             version <- utils::packageVersion("future")
[10:30:53.529]                         }
[10:30:53.529]                         else {
[10:30:53.529]                           version <- NULL
[10:30:53.529]                         }
[10:30:53.529]                         if (!has_future || version < "1.8.0") {
[10:30:53.529]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.529]                             "", base::R.version$version.string), 
[10:30:53.529]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.529]                               "release", "version")], collapse = " "), 
[10:30:53.529]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.529]                             info)
[10:30:53.529]                           info <- base::paste(info, collapse = "; ")
[10:30:53.529]                           if (!has_future) {
[10:30:53.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.529]                               info)
[10:30:53.529]                           }
[10:30:53.529]                           else {
[10:30:53.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.529]                               info, version)
[10:30:53.529]                           }
[10:30:53.529]                           base::stop(msg)
[10:30:53.529]                         }
[10:30:53.529]                       })
[10:30:53.529]                     }
[10:30:53.529]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.529]                     base::options(mc.cores = 1L)
[10:30:53.529]                   }
[10:30:53.529]                   ...future.strategy.old <- future::plan("list")
[10:30:53.529]                   options(future.plan = NULL)
[10:30:53.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.529]                 }
[10:30:53.529]                 ...future.workdir <- getwd()
[10:30:53.529]             }
[10:30:53.529]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.529]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.529]         }
[10:30:53.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.529]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:53.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.529]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.529]             base::names(...future.oldOptions))
[10:30:53.529]     }
[10:30:53.529]     if (FALSE) {
[10:30:53.529]     }
[10:30:53.529]     else {
[10:30:53.529]         if (TRUE) {
[10:30:53.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.529]                 open = "w")
[10:30:53.529]         }
[10:30:53.529]         else {
[10:30:53.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.529]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.529]         }
[10:30:53.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.529]             base::sink(type = "output", split = FALSE)
[10:30:53.529]             base::close(...future.stdout)
[10:30:53.529]         }, add = TRUE)
[10:30:53.529]     }
[10:30:53.529]     ...future.frame <- base::sys.nframe()
[10:30:53.529]     ...future.conditions <- base::list()
[10:30:53.529]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.529]     if (FALSE) {
[10:30:53.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.529]     }
[10:30:53.529]     ...future.result <- base::tryCatch({
[10:30:53.529]         base::withCallingHandlers({
[10:30:53.529]             ...future.value <- base::withVisible(base::local({
[10:30:53.529]                 ...future.makeSendCondition <- base::local({
[10:30:53.529]                   sendCondition <- NULL
[10:30:53.529]                   function(frame = 1L) {
[10:30:53.529]                     if (is.function(sendCondition)) 
[10:30:53.529]                       return(sendCondition)
[10:30:53.529]                     ns <- getNamespace("parallel")
[10:30:53.529]                     if (exists("sendData", mode = "function", 
[10:30:53.529]                       envir = ns)) {
[10:30:53.529]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.529]                         envir = ns)
[10:30:53.529]                       envir <- sys.frame(frame)
[10:30:53.529]                       master <- NULL
[10:30:53.529]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.529]                         !identical(envir, emptyenv())) {
[10:30:53.529]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.529]                           inherits = FALSE)) {
[10:30:53.529]                           master <- get("master", mode = "list", 
[10:30:53.529]                             envir = envir, inherits = FALSE)
[10:30:53.529]                           if (inherits(master, c("SOCKnode", 
[10:30:53.529]                             "SOCK0node"))) {
[10:30:53.529]                             sendCondition <<- function(cond) {
[10:30:53.529]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.529]                                 success = TRUE)
[10:30:53.529]                               parallel_sendData(master, data)
[10:30:53.529]                             }
[10:30:53.529]                             return(sendCondition)
[10:30:53.529]                           }
[10:30:53.529]                         }
[10:30:53.529]                         frame <- frame + 1L
[10:30:53.529]                         envir <- sys.frame(frame)
[10:30:53.529]                       }
[10:30:53.529]                     }
[10:30:53.529]                     sendCondition <<- function(cond) NULL
[10:30:53.529]                   }
[10:30:53.529]                 })
[10:30:53.529]                 withCallingHandlers({
[10:30:53.529]                   {
[10:30:53.529]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.529]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.529]                       ...future.globals.maxSize)) {
[10:30:53.529]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.529]                       on.exit(options(oopts), add = TRUE)
[10:30:53.529]                     }
[10:30:53.529]                     {
[10:30:53.529]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.529]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.529]                         USE.NAMES = FALSE)
[10:30:53.529]                       do.call(mapply, args = args)
[10:30:53.529]                     }
[10:30:53.529]                   }
[10:30:53.529]                 }, immediateCondition = function(cond) {
[10:30:53.529]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.529]                   sendCondition(cond)
[10:30:53.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.529]                   {
[10:30:53.529]                     inherits <- base::inherits
[10:30:53.529]                     invokeRestart <- base::invokeRestart
[10:30:53.529]                     is.null <- base::is.null
[10:30:53.529]                     muffled <- FALSE
[10:30:53.529]                     if (inherits(cond, "message")) {
[10:30:53.529]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.529]                       if (muffled) 
[10:30:53.529]                         invokeRestart("muffleMessage")
[10:30:53.529]                     }
[10:30:53.529]                     else if (inherits(cond, "warning")) {
[10:30:53.529]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.529]                       if (muffled) 
[10:30:53.529]                         invokeRestart("muffleWarning")
[10:30:53.529]                     }
[10:30:53.529]                     else if (inherits(cond, "condition")) {
[10:30:53.529]                       if (!is.null(pattern)) {
[10:30:53.529]                         computeRestarts <- base::computeRestarts
[10:30:53.529]                         grepl <- base::grepl
[10:30:53.529]                         restarts <- computeRestarts(cond)
[10:30:53.529]                         for (restart in restarts) {
[10:30:53.529]                           name <- restart$name
[10:30:53.529]                           if (is.null(name)) 
[10:30:53.529]                             next
[10:30:53.529]                           if (!grepl(pattern, name)) 
[10:30:53.529]                             next
[10:30:53.529]                           invokeRestart(restart)
[10:30:53.529]                           muffled <- TRUE
[10:30:53.529]                           break
[10:30:53.529]                         }
[10:30:53.529]                       }
[10:30:53.529]                     }
[10:30:53.529]                     invisible(muffled)
[10:30:53.529]                   }
[10:30:53.529]                   muffleCondition(cond)
[10:30:53.529]                 })
[10:30:53.529]             }))
[10:30:53.529]             future::FutureResult(value = ...future.value$value, 
[10:30:53.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.529]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.529]                     ...future.globalenv.names))
[10:30:53.529]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.529]         }, condition = base::local({
[10:30:53.529]             c <- base::c
[10:30:53.529]             inherits <- base::inherits
[10:30:53.529]             invokeRestart <- base::invokeRestart
[10:30:53.529]             length <- base::length
[10:30:53.529]             list <- base::list
[10:30:53.529]             seq.int <- base::seq.int
[10:30:53.529]             signalCondition <- base::signalCondition
[10:30:53.529]             sys.calls <- base::sys.calls
[10:30:53.529]             `[[` <- base::`[[`
[10:30:53.529]             `+` <- base::`+`
[10:30:53.529]             `<<-` <- base::`<<-`
[10:30:53.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.529]                   3L)]
[10:30:53.529]             }
[10:30:53.529]             function(cond) {
[10:30:53.529]                 is_error <- inherits(cond, "error")
[10:30:53.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.529]                   NULL)
[10:30:53.529]                 if (is_error) {
[10:30:53.529]                   sessionInformation <- function() {
[10:30:53.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.529]                       search = base::search(), system = base::Sys.info())
[10:30:53.529]                   }
[10:30:53.529]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.529]                     cond$call), session = sessionInformation(), 
[10:30:53.529]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.529]                   signalCondition(cond)
[10:30:53.529]                 }
[10:30:53.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.529]                 "immediateCondition"))) {
[10:30:53.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.529]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.529]                   if (TRUE && !signal) {
[10:30:53.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.529]                     {
[10:30:53.529]                       inherits <- base::inherits
[10:30:53.529]                       invokeRestart <- base::invokeRestart
[10:30:53.529]                       is.null <- base::is.null
[10:30:53.529]                       muffled <- FALSE
[10:30:53.529]                       if (inherits(cond, "message")) {
[10:30:53.529]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.529]                         if (muffled) 
[10:30:53.529]                           invokeRestart("muffleMessage")
[10:30:53.529]                       }
[10:30:53.529]                       else if (inherits(cond, "warning")) {
[10:30:53.529]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.529]                         if (muffled) 
[10:30:53.529]                           invokeRestart("muffleWarning")
[10:30:53.529]                       }
[10:30:53.529]                       else if (inherits(cond, "condition")) {
[10:30:53.529]                         if (!is.null(pattern)) {
[10:30:53.529]                           computeRestarts <- base::computeRestarts
[10:30:53.529]                           grepl <- base::grepl
[10:30:53.529]                           restarts <- computeRestarts(cond)
[10:30:53.529]                           for (restart in restarts) {
[10:30:53.529]                             name <- restart$name
[10:30:53.529]                             if (is.null(name)) 
[10:30:53.529]                               next
[10:30:53.529]                             if (!grepl(pattern, name)) 
[10:30:53.529]                               next
[10:30:53.529]                             invokeRestart(restart)
[10:30:53.529]                             muffled <- TRUE
[10:30:53.529]                             break
[10:30:53.529]                           }
[10:30:53.529]                         }
[10:30:53.529]                       }
[10:30:53.529]                       invisible(muffled)
[10:30:53.529]                     }
[10:30:53.529]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.529]                   }
[10:30:53.529]                 }
[10:30:53.529]                 else {
[10:30:53.529]                   if (TRUE) {
[10:30:53.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.529]                     {
[10:30:53.529]                       inherits <- base::inherits
[10:30:53.529]                       invokeRestart <- base::invokeRestart
[10:30:53.529]                       is.null <- base::is.null
[10:30:53.529]                       muffled <- FALSE
[10:30:53.529]                       if (inherits(cond, "message")) {
[10:30:53.529]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.529]                         if (muffled) 
[10:30:53.529]                           invokeRestart("muffleMessage")
[10:30:53.529]                       }
[10:30:53.529]                       else if (inherits(cond, "warning")) {
[10:30:53.529]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.529]                         if (muffled) 
[10:30:53.529]                           invokeRestart("muffleWarning")
[10:30:53.529]                       }
[10:30:53.529]                       else if (inherits(cond, "condition")) {
[10:30:53.529]                         if (!is.null(pattern)) {
[10:30:53.529]                           computeRestarts <- base::computeRestarts
[10:30:53.529]                           grepl <- base::grepl
[10:30:53.529]                           restarts <- computeRestarts(cond)
[10:30:53.529]                           for (restart in restarts) {
[10:30:53.529]                             name <- restart$name
[10:30:53.529]                             if (is.null(name)) 
[10:30:53.529]                               next
[10:30:53.529]                             if (!grepl(pattern, name)) 
[10:30:53.529]                               next
[10:30:53.529]                             invokeRestart(restart)
[10:30:53.529]                             muffled <- TRUE
[10:30:53.529]                             break
[10:30:53.529]                           }
[10:30:53.529]                         }
[10:30:53.529]                       }
[10:30:53.529]                       invisible(muffled)
[10:30:53.529]                     }
[10:30:53.529]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.529]                   }
[10:30:53.529]                 }
[10:30:53.529]             }
[10:30:53.529]         }))
[10:30:53.529]     }, error = function(ex) {
[10:30:53.529]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.529]                 ...future.rng), started = ...future.startTime, 
[10:30:53.529]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.529]             version = "1.8"), class = "FutureResult")
[10:30:53.529]     }, finally = {
[10:30:53.529]         if (!identical(...future.workdir, getwd())) 
[10:30:53.529]             setwd(...future.workdir)
[10:30:53.529]         {
[10:30:53.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.529]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.529]             }
[10:30:53.529]             base::options(...future.oldOptions)
[10:30:53.529]             if (.Platform$OS.type == "windows") {
[10:30:53.529]                 old_names <- names(...future.oldEnvVars)
[10:30:53.529]                 envs <- base::Sys.getenv()
[10:30:53.529]                 names <- names(envs)
[10:30:53.529]                 common <- intersect(names, old_names)
[10:30:53.529]                 added <- setdiff(names, old_names)
[10:30:53.529]                 removed <- setdiff(old_names, names)
[10:30:53.529]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.529]                   envs[common]]
[10:30:53.529]                 NAMES <- toupper(changed)
[10:30:53.529]                 args <- list()
[10:30:53.529]                 for (kk in seq_along(NAMES)) {
[10:30:53.529]                   name <- changed[[kk]]
[10:30:53.529]                   NAME <- NAMES[[kk]]
[10:30:53.529]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.529]                     next
[10:30:53.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.529]                 }
[10:30:53.529]                 NAMES <- toupper(added)
[10:30:53.529]                 for (kk in seq_along(NAMES)) {
[10:30:53.529]                   name <- added[[kk]]
[10:30:53.529]                   NAME <- NAMES[[kk]]
[10:30:53.529]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.529]                     next
[10:30:53.529]                   args[[name]] <- ""
[10:30:53.529]                 }
[10:30:53.529]                 NAMES <- toupper(removed)
[10:30:53.529]                 for (kk in seq_along(NAMES)) {
[10:30:53.529]                   name <- removed[[kk]]
[10:30:53.529]                   NAME <- NAMES[[kk]]
[10:30:53.529]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.529]                     next
[10:30:53.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.529]                 }
[10:30:53.529]                 if (length(args) > 0) 
[10:30:53.529]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.529]             }
[10:30:53.529]             else {
[10:30:53.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.529]             }
[10:30:53.529]             {
[10:30:53.529]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.529]                   0L) {
[10:30:53.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.529]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.529]                   base::options(opts)
[10:30:53.529]                 }
[10:30:53.529]                 {
[10:30:53.529]                   {
[10:30:53.529]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.529]                     NULL
[10:30:53.529]                   }
[10:30:53.529]                   options(future.plan = NULL)
[10:30:53.529]                   if (is.na(NA_character_)) 
[10:30:53.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.529]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.529]                     .init = FALSE)
[10:30:53.529]                 }
[10:30:53.529]             }
[10:30:53.529]         }
[10:30:53.529]     })
[10:30:53.529]     if (TRUE) {
[10:30:53.529]         base::sink(type = "output", split = FALSE)
[10:30:53.529]         if (TRUE) {
[10:30:53.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.529]         }
[10:30:53.529]         else {
[10:30:53.529]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.529]         }
[10:30:53.529]         base::close(...future.stdout)
[10:30:53.529]         ...future.stdout <- NULL
[10:30:53.529]     }
[10:30:53.529]     ...future.result$conditions <- ...future.conditions
[10:30:53.529]     ...future.result$finished <- base::Sys.time()
[10:30:53.529]     ...future.result
[10:30:53.529] }
[10:30:53.531] Poll #1 (0): usedNodes() = 2, workers = 2
[10:30:53.542] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.542] - Validating connection of MultisessionFuture
[10:30:53.543] - received message: FutureResult
[10:30:53.543] - Received FutureResult
[10:30:53.543] - Erased future from FutureRegistry
[10:30:53.543] result() for ClusterFuture ...
[10:30:53.543] - result already collected: FutureResult
[10:30:53.543] result() for ClusterFuture ... done
[10:30:53.543] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.543] result() for ClusterFuture ...
[10:30:53.543] - result already collected: FutureResult
[10:30:53.543] result() for ClusterFuture ... done
[10:30:53.544] result() for ClusterFuture ...
[10:30:53.544] - result already collected: FutureResult
[10:30:53.544] result() for ClusterFuture ... done
[10:30:53.544] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[10:30:53.545] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[10:30:53.545] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[10:30:53.545] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:53.546] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.546] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[10:30:53.546] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[10:30:53.546] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:53.547] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.547] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:53.547] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.547] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[10:30:53.548] MultisessionFuture started
[10:30:53.548] - Launch lazy future ... done
[10:30:53.548] run() for ‘MultisessionFuture’ ... done
[10:30:53.548] Created future:
[10:30:53.548] MultisessionFuture:
[10:30:53.548] Label: ‘future_mapply-4’
[10:30:53.548] Expression:
[10:30:53.548] {
[10:30:53.548]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.548]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.548]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.548]         on.exit(options(oopts), add = TRUE)
[10:30:53.548]     }
[10:30:53.548]     {
[10:30:53.548]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.548]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.548]         do.call(mapply, args = args)
[10:30:53.548]     }
[10:30:53.548] }
[10:30:53.548] Lazy evaluation: FALSE
[10:30:53.548] Asynchronous evaluation: TRUE
[10:30:53.548] Local evaluation: TRUE
[10:30:53.548] Environment: R_GlobalEnv
[10:30:53.548] Capture standard output: TRUE
[10:30:53.548] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.548] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.548] Packages: <none>
[10:30:53.548] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.548] Resolved: FALSE
[10:30:53.548] Value: <not collected>
[10:30:53.548] Conditions captured: <none>
[10:30:53.548] Early signaling: FALSE
[10:30:53.548] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.548] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.560] Chunk #4 of 5 ... DONE
[10:30:53.560] Chunk #5 of 5 ...
[10:30:53.560]  - Finding globals in '...' for chunk #5 ...
[10:30:53.560] getGlobalsAndPackages() ...
[10:30:53.560] Searching for globals...
[10:30:53.561] 
[10:30:53.561] Searching for globals ... DONE
[10:30:53.561] - globals: [0] <none>
[10:30:53.561] getGlobalsAndPackages() ... DONE
[10:30:53.561]    + additional globals found: [n=0] 
[10:30:53.561]    + additional namespaces needed: [n=0] 
[10:30:53.561]  - Finding globals in '...' for chunk #5 ... DONE
[10:30:53.561]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:30:53.561]  - seeds: <none>
[10:30:53.562]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.562] getGlobalsAndPackages() ...
[10:30:53.562] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.562] Resolving globals: FALSE
[10:30:53.562] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:53.563] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:53.563] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.563] 
[10:30:53.563] getGlobalsAndPackages() ... DONE
[10:30:53.563] run() for ‘Future’ ...
[10:30:53.564] - state: ‘created’
[10:30:53.564] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.578] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.578]   - Field: ‘node’
[10:30:53.578]   - Field: ‘label’
[10:30:53.578]   - Field: ‘local’
[10:30:53.578]   - Field: ‘owner’
[10:30:53.578]   - Field: ‘envir’
[10:30:53.579]   - Field: ‘workers’
[10:30:53.579]   - Field: ‘packages’
[10:30:53.579]   - Field: ‘gc’
[10:30:53.579]   - Field: ‘conditions’
[10:30:53.579]   - Field: ‘persistent’
[10:30:53.579]   - Field: ‘expr’
[10:30:53.579]   - Field: ‘uuid’
[10:30:53.579]   - Field: ‘seed’
[10:30:53.579]   - Field: ‘version’
[10:30:53.579]   - Field: ‘result’
[10:30:53.579]   - Field: ‘asynchronous’
[10:30:53.579]   - Field: ‘calls’
[10:30:53.580]   - Field: ‘globals’
[10:30:53.580]   - Field: ‘stdout’
[10:30:53.580]   - Field: ‘earlySignal’
[10:30:53.580]   - Field: ‘lazy’
[10:30:53.580]   - Field: ‘state’
[10:30:53.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.580] - Launch lazy future ...
[10:30:53.580] Packages needed by the future expression (n = 0): <none>
[10:30:53.581] Packages needed by future strategies (n = 0): <none>
[10:30:53.581] {
[10:30:53.581]     {
[10:30:53.581]         {
[10:30:53.581]             ...future.startTime <- base::Sys.time()
[10:30:53.581]             {
[10:30:53.581]                 {
[10:30:53.581]                   {
[10:30:53.581]                     {
[10:30:53.581]                       base::local({
[10:30:53.581]                         has_future <- base::requireNamespace("future", 
[10:30:53.581]                           quietly = TRUE)
[10:30:53.581]                         if (has_future) {
[10:30:53.581]                           ns <- base::getNamespace("future")
[10:30:53.581]                           version <- ns[[".package"]][["version"]]
[10:30:53.581]                           if (is.null(version)) 
[10:30:53.581]                             version <- utils::packageVersion("future")
[10:30:53.581]                         }
[10:30:53.581]                         else {
[10:30:53.581]                           version <- NULL
[10:30:53.581]                         }
[10:30:53.581]                         if (!has_future || version < "1.8.0") {
[10:30:53.581]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.581]                             "", base::R.version$version.string), 
[10:30:53.581]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.581]                               "release", "version")], collapse = " "), 
[10:30:53.581]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.581]                             info)
[10:30:53.581]                           info <- base::paste(info, collapse = "; ")
[10:30:53.581]                           if (!has_future) {
[10:30:53.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.581]                               info)
[10:30:53.581]                           }
[10:30:53.581]                           else {
[10:30:53.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.581]                               info, version)
[10:30:53.581]                           }
[10:30:53.581]                           base::stop(msg)
[10:30:53.581]                         }
[10:30:53.581]                       })
[10:30:53.581]                     }
[10:30:53.581]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.581]                     base::options(mc.cores = 1L)
[10:30:53.581]                   }
[10:30:53.581]                   ...future.strategy.old <- future::plan("list")
[10:30:53.581]                   options(future.plan = NULL)
[10:30:53.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.581]                 }
[10:30:53.581]                 ...future.workdir <- getwd()
[10:30:53.581]             }
[10:30:53.581]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.581]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.581]         }
[10:30:53.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.581]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:30:53.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.581]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.581]             base::names(...future.oldOptions))
[10:30:53.581]     }
[10:30:53.581]     if (FALSE) {
[10:30:53.581]     }
[10:30:53.581]     else {
[10:30:53.581]         if (TRUE) {
[10:30:53.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.581]                 open = "w")
[10:30:53.581]         }
[10:30:53.581]         else {
[10:30:53.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.581]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.581]         }
[10:30:53.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.581]             base::sink(type = "output", split = FALSE)
[10:30:53.581]             base::close(...future.stdout)
[10:30:53.581]         }, add = TRUE)
[10:30:53.581]     }
[10:30:53.581]     ...future.frame <- base::sys.nframe()
[10:30:53.581]     ...future.conditions <- base::list()
[10:30:53.581]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.581]     if (FALSE) {
[10:30:53.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.581]     }
[10:30:53.581]     ...future.result <- base::tryCatch({
[10:30:53.581]         base::withCallingHandlers({
[10:30:53.581]             ...future.value <- base::withVisible(base::local({
[10:30:53.581]                 ...future.makeSendCondition <- base::local({
[10:30:53.581]                   sendCondition <- NULL
[10:30:53.581]                   function(frame = 1L) {
[10:30:53.581]                     if (is.function(sendCondition)) 
[10:30:53.581]                       return(sendCondition)
[10:30:53.581]                     ns <- getNamespace("parallel")
[10:30:53.581]                     if (exists("sendData", mode = "function", 
[10:30:53.581]                       envir = ns)) {
[10:30:53.581]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.581]                         envir = ns)
[10:30:53.581]                       envir <- sys.frame(frame)
[10:30:53.581]                       master <- NULL
[10:30:53.581]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.581]                         !identical(envir, emptyenv())) {
[10:30:53.581]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.581]                           inherits = FALSE)) {
[10:30:53.581]                           master <- get("master", mode = "list", 
[10:30:53.581]                             envir = envir, inherits = FALSE)
[10:30:53.581]                           if (inherits(master, c("SOCKnode", 
[10:30:53.581]                             "SOCK0node"))) {
[10:30:53.581]                             sendCondition <<- function(cond) {
[10:30:53.581]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.581]                                 success = TRUE)
[10:30:53.581]                               parallel_sendData(master, data)
[10:30:53.581]                             }
[10:30:53.581]                             return(sendCondition)
[10:30:53.581]                           }
[10:30:53.581]                         }
[10:30:53.581]                         frame <- frame + 1L
[10:30:53.581]                         envir <- sys.frame(frame)
[10:30:53.581]                       }
[10:30:53.581]                     }
[10:30:53.581]                     sendCondition <<- function(cond) NULL
[10:30:53.581]                   }
[10:30:53.581]                 })
[10:30:53.581]                 withCallingHandlers({
[10:30:53.581]                   {
[10:30:53.581]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.581]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.581]                       ...future.globals.maxSize)) {
[10:30:53.581]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.581]                       on.exit(options(oopts), add = TRUE)
[10:30:53.581]                     }
[10:30:53.581]                     {
[10:30:53.581]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.581]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.581]                         USE.NAMES = FALSE)
[10:30:53.581]                       do.call(mapply, args = args)
[10:30:53.581]                     }
[10:30:53.581]                   }
[10:30:53.581]                 }, immediateCondition = function(cond) {
[10:30:53.581]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.581]                   sendCondition(cond)
[10:30:53.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.581]                   {
[10:30:53.581]                     inherits <- base::inherits
[10:30:53.581]                     invokeRestart <- base::invokeRestart
[10:30:53.581]                     is.null <- base::is.null
[10:30:53.581]                     muffled <- FALSE
[10:30:53.581]                     if (inherits(cond, "message")) {
[10:30:53.581]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.581]                       if (muffled) 
[10:30:53.581]                         invokeRestart("muffleMessage")
[10:30:53.581]                     }
[10:30:53.581]                     else if (inherits(cond, "warning")) {
[10:30:53.581]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.581]                       if (muffled) 
[10:30:53.581]                         invokeRestart("muffleWarning")
[10:30:53.581]                     }
[10:30:53.581]                     else if (inherits(cond, "condition")) {
[10:30:53.581]                       if (!is.null(pattern)) {
[10:30:53.581]                         computeRestarts <- base::computeRestarts
[10:30:53.581]                         grepl <- base::grepl
[10:30:53.581]                         restarts <- computeRestarts(cond)
[10:30:53.581]                         for (restart in restarts) {
[10:30:53.581]                           name <- restart$name
[10:30:53.581]                           if (is.null(name)) 
[10:30:53.581]                             next
[10:30:53.581]                           if (!grepl(pattern, name)) 
[10:30:53.581]                             next
[10:30:53.581]                           invokeRestart(restart)
[10:30:53.581]                           muffled <- TRUE
[10:30:53.581]                           break
[10:30:53.581]                         }
[10:30:53.581]                       }
[10:30:53.581]                     }
[10:30:53.581]                     invisible(muffled)
[10:30:53.581]                   }
[10:30:53.581]                   muffleCondition(cond)
[10:30:53.581]                 })
[10:30:53.581]             }))
[10:30:53.581]             future::FutureResult(value = ...future.value$value, 
[10:30:53.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.581]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.581]                     ...future.globalenv.names))
[10:30:53.581]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.581]         }, condition = base::local({
[10:30:53.581]             c <- base::c
[10:30:53.581]             inherits <- base::inherits
[10:30:53.581]             invokeRestart <- base::invokeRestart
[10:30:53.581]             length <- base::length
[10:30:53.581]             list <- base::list
[10:30:53.581]             seq.int <- base::seq.int
[10:30:53.581]             signalCondition <- base::signalCondition
[10:30:53.581]             sys.calls <- base::sys.calls
[10:30:53.581]             `[[` <- base::`[[`
[10:30:53.581]             `+` <- base::`+`
[10:30:53.581]             `<<-` <- base::`<<-`
[10:30:53.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.581]                   3L)]
[10:30:53.581]             }
[10:30:53.581]             function(cond) {
[10:30:53.581]                 is_error <- inherits(cond, "error")
[10:30:53.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.581]                   NULL)
[10:30:53.581]                 if (is_error) {
[10:30:53.581]                   sessionInformation <- function() {
[10:30:53.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.581]                       search = base::search(), system = base::Sys.info())
[10:30:53.581]                   }
[10:30:53.581]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.581]                     cond$call), session = sessionInformation(), 
[10:30:53.581]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.581]                   signalCondition(cond)
[10:30:53.581]                 }
[10:30:53.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.581]                 "immediateCondition"))) {
[10:30:53.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.581]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.581]                   if (TRUE && !signal) {
[10:30:53.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.581]                     {
[10:30:53.581]                       inherits <- base::inherits
[10:30:53.581]                       invokeRestart <- base::invokeRestart
[10:30:53.581]                       is.null <- base::is.null
[10:30:53.581]                       muffled <- FALSE
[10:30:53.581]                       if (inherits(cond, "message")) {
[10:30:53.581]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.581]                         if (muffled) 
[10:30:53.581]                           invokeRestart("muffleMessage")
[10:30:53.581]                       }
[10:30:53.581]                       else if (inherits(cond, "warning")) {
[10:30:53.581]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.581]                         if (muffled) 
[10:30:53.581]                           invokeRestart("muffleWarning")
[10:30:53.581]                       }
[10:30:53.581]                       else if (inherits(cond, "condition")) {
[10:30:53.581]                         if (!is.null(pattern)) {
[10:30:53.581]                           computeRestarts <- base::computeRestarts
[10:30:53.581]                           grepl <- base::grepl
[10:30:53.581]                           restarts <- computeRestarts(cond)
[10:30:53.581]                           for (restart in restarts) {
[10:30:53.581]                             name <- restart$name
[10:30:53.581]                             if (is.null(name)) 
[10:30:53.581]                               next
[10:30:53.581]                             if (!grepl(pattern, name)) 
[10:30:53.581]                               next
[10:30:53.581]                             invokeRestart(restart)
[10:30:53.581]                             muffled <- TRUE
[10:30:53.581]                             break
[10:30:53.581]                           }
[10:30:53.581]                         }
[10:30:53.581]                       }
[10:30:53.581]                       invisible(muffled)
[10:30:53.581]                     }
[10:30:53.581]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.581]                   }
[10:30:53.581]                 }
[10:30:53.581]                 else {
[10:30:53.581]                   if (TRUE) {
[10:30:53.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.581]                     {
[10:30:53.581]                       inherits <- base::inherits
[10:30:53.581]                       invokeRestart <- base::invokeRestart
[10:30:53.581]                       is.null <- base::is.null
[10:30:53.581]                       muffled <- FALSE
[10:30:53.581]                       if (inherits(cond, "message")) {
[10:30:53.581]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.581]                         if (muffled) 
[10:30:53.581]                           invokeRestart("muffleMessage")
[10:30:53.581]                       }
[10:30:53.581]                       else if (inherits(cond, "warning")) {
[10:30:53.581]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.581]                         if (muffled) 
[10:30:53.581]                           invokeRestart("muffleWarning")
[10:30:53.581]                       }
[10:30:53.581]                       else if (inherits(cond, "condition")) {
[10:30:53.581]                         if (!is.null(pattern)) {
[10:30:53.581]                           computeRestarts <- base::computeRestarts
[10:30:53.581]                           grepl <- base::grepl
[10:30:53.581]                           restarts <- computeRestarts(cond)
[10:30:53.581]                           for (restart in restarts) {
[10:30:53.581]                             name <- restart$name
[10:30:53.581]                             if (is.null(name)) 
[10:30:53.581]                               next
[10:30:53.581]                             if (!grepl(pattern, name)) 
[10:30:53.581]                               next
[10:30:53.581]                             invokeRestart(restart)
[10:30:53.581]                             muffled <- TRUE
[10:30:53.581]                             break
[10:30:53.581]                           }
[10:30:53.581]                         }
[10:30:53.581]                       }
[10:30:53.581]                       invisible(muffled)
[10:30:53.581]                     }
[10:30:53.581]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.581]                   }
[10:30:53.581]                 }
[10:30:53.581]             }
[10:30:53.581]         }))
[10:30:53.581]     }, error = function(ex) {
[10:30:53.581]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.581]                 ...future.rng), started = ...future.startTime, 
[10:30:53.581]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.581]             version = "1.8"), class = "FutureResult")
[10:30:53.581]     }, finally = {
[10:30:53.581]         if (!identical(...future.workdir, getwd())) 
[10:30:53.581]             setwd(...future.workdir)
[10:30:53.581]         {
[10:30:53.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.581]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.581]             }
[10:30:53.581]             base::options(...future.oldOptions)
[10:30:53.581]             if (.Platform$OS.type == "windows") {
[10:30:53.581]                 old_names <- names(...future.oldEnvVars)
[10:30:53.581]                 envs <- base::Sys.getenv()
[10:30:53.581]                 names <- names(envs)
[10:30:53.581]                 common <- intersect(names, old_names)
[10:30:53.581]                 added <- setdiff(names, old_names)
[10:30:53.581]                 removed <- setdiff(old_names, names)
[10:30:53.581]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.581]                   envs[common]]
[10:30:53.581]                 NAMES <- toupper(changed)
[10:30:53.581]                 args <- list()
[10:30:53.581]                 for (kk in seq_along(NAMES)) {
[10:30:53.581]                   name <- changed[[kk]]
[10:30:53.581]                   NAME <- NAMES[[kk]]
[10:30:53.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.581]                     next
[10:30:53.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.581]                 }
[10:30:53.581]                 NAMES <- toupper(added)
[10:30:53.581]                 for (kk in seq_along(NAMES)) {
[10:30:53.581]                   name <- added[[kk]]
[10:30:53.581]                   NAME <- NAMES[[kk]]
[10:30:53.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.581]                     next
[10:30:53.581]                   args[[name]] <- ""
[10:30:53.581]                 }
[10:30:53.581]                 NAMES <- toupper(removed)
[10:30:53.581]                 for (kk in seq_along(NAMES)) {
[10:30:53.581]                   name <- removed[[kk]]
[10:30:53.581]                   NAME <- NAMES[[kk]]
[10:30:53.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.581]                     next
[10:30:53.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.581]                 }
[10:30:53.581]                 if (length(args) > 0) 
[10:30:53.581]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.581]             }
[10:30:53.581]             else {
[10:30:53.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.581]             }
[10:30:53.581]             {
[10:30:53.581]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.581]                   0L) {
[10:30:53.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.581]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.581]                   base::options(opts)
[10:30:53.581]                 }
[10:30:53.581]                 {
[10:30:53.581]                   {
[10:30:53.581]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.581]                     NULL
[10:30:53.581]                   }
[10:30:53.581]                   options(future.plan = NULL)
[10:30:53.581]                   if (is.na(NA_character_)) 
[10:30:53.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.581]                     .init = FALSE)
[10:30:53.581]                 }
[10:30:53.581]             }
[10:30:53.581]         }
[10:30:53.581]     })
[10:30:53.581]     if (TRUE) {
[10:30:53.581]         base::sink(type = "output", split = FALSE)
[10:30:53.581]         if (TRUE) {
[10:30:53.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.581]         }
[10:30:53.581]         else {
[10:30:53.581]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.581]         }
[10:30:53.581]         base::close(...future.stdout)
[10:30:53.581]         ...future.stdout <- NULL
[10:30:53.581]     }
[10:30:53.581]     ...future.result$conditions <- ...future.conditions
[10:30:53.581]     ...future.result$finished <- base::Sys.time()
[10:30:53.581]     ...future.result
[10:30:53.581] }
[10:30:53.583] Poll #1 (0): usedNodes() = 2, workers = 2
[10:30:53.594] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.594] - Validating connection of MultisessionFuture
[10:30:53.594] - received message: FutureResult
[10:30:53.594] - Received FutureResult
[10:30:53.594] - Erased future from FutureRegistry
[10:30:53.595] result() for ClusterFuture ...
[10:30:53.595] - result already collected: FutureResult
[10:30:53.595] result() for ClusterFuture ... done
[10:30:53.595] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.595] result() for ClusterFuture ...
[10:30:53.595] - result already collected: FutureResult
[10:30:53.595] result() for ClusterFuture ... done
[10:30:53.595] result() for ClusterFuture ...
[10:30:53.595] - result already collected: FutureResult
[10:30:53.595] result() for ClusterFuture ... done
[10:30:53.596] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[10:30:53.596] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[10:30:53.597] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[10:30:53.597] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:53.597] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.597] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[10:30:53.598] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[10:30:53.598] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:53.598] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.598] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:53.599] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.599] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[10:30:53.599] MultisessionFuture started
[10:30:53.600] - Launch lazy future ... done
[10:30:53.600] run() for ‘MultisessionFuture’ ... done
[10:30:53.600] Created future:
[10:30:53.600] MultisessionFuture:
[10:30:53.600] Label: ‘future_mapply-5’
[10:30:53.600] Expression:
[10:30:53.600] {
[10:30:53.600]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.600]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.600]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.600]         on.exit(options(oopts), add = TRUE)
[10:30:53.600]     }
[10:30:53.600]     {
[10:30:53.600]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.600]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.600]         do.call(mapply, args = args)
[10:30:53.600]     }
[10:30:53.600] }
[10:30:53.600] Lazy evaluation: FALSE
[10:30:53.600] Asynchronous evaluation: TRUE
[10:30:53.600] Local evaluation: TRUE
[10:30:53.600] Environment: R_GlobalEnv
[10:30:53.600] Capture standard output: TRUE
[10:30:53.600] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.600] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.600] Packages: <none>
[10:30:53.600] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.600] Resolved: FALSE
[10:30:53.600] Value: <not collected>
[10:30:53.600] Conditions captured: <none>
[10:30:53.600] Early signaling: FALSE
[10:30:53.600] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.600] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.612] Chunk #5 of 5 ... DONE
[10:30:53.612] Launching 5 futures (chunks) ... DONE
[10:30:53.612] Resolving 5 futures (chunks) ...
[10:30:53.612] resolve() on list ...
[10:30:53.612]  recursive: 0
[10:30:53.612]  length: 5
[10:30:53.612] 
[10:30:53.612] Future #1
[10:30:53.613] result() for ClusterFuture ...
[10:30:53.613] - result already collected: FutureResult
[10:30:53.613] result() for ClusterFuture ... done
[10:30:53.613] result() for ClusterFuture ...
[10:30:53.613] - result already collected: FutureResult
[10:30:53.613] result() for ClusterFuture ... done
[10:30:53.613] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:53.613] - nx: 5
[10:30:53.613] - relay: TRUE
[10:30:53.613] - stdout: TRUE
[10:30:53.613] - signal: TRUE
[10:30:53.614] - resignal: FALSE
[10:30:53.614] - force: TRUE
[10:30:53.614] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:30:53.614] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:30:53.614]  - until=1
[10:30:53.614]  - relaying element #1
[10:30:53.614] result() for ClusterFuture ...
[10:30:53.614] - result already collected: FutureResult
[10:30:53.614] result() for ClusterFuture ... done
[10:30:53.614] result() for ClusterFuture ...
[10:30:53.614] - result already collected: FutureResult
[10:30:53.615] result() for ClusterFuture ... done
[10:30:53.615] result() for ClusterFuture ...
[10:30:53.615] - result already collected: FutureResult
[10:30:53.615] result() for ClusterFuture ... done
[10:30:53.615] result() for ClusterFuture ...
[10:30:53.615] - result already collected: FutureResult
[10:30:53.615] result() for ClusterFuture ... done
[10:30:53.615] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:53.615] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:53.615] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:53.615]  length: 4 (resolved future 1)
[10:30:53.616] Future #2
[10:30:53.616] result() for ClusterFuture ...
[10:30:53.616] - result already collected: FutureResult
[10:30:53.616] result() for ClusterFuture ... done
[10:30:53.616] result() for ClusterFuture ...
[10:30:53.616] - result already collected: FutureResult
[10:30:53.616] result() for ClusterFuture ... done
[10:30:53.616] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:53.616] - nx: 5
[10:30:53.616] - relay: TRUE
[10:30:53.616] - stdout: TRUE
[10:30:53.617] - signal: TRUE
[10:30:53.617] - resignal: FALSE
[10:30:53.617] - force: TRUE
[10:30:53.617] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:53.617] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:30:53.617]  - until=2
[10:30:53.617]  - relaying element #2
[10:30:53.617] result() for ClusterFuture ...
[10:30:53.617] - result already collected: FutureResult
[10:30:53.617] result() for ClusterFuture ... done
[10:30:53.617] result() for ClusterFuture ...
[10:30:53.618] - result already collected: FutureResult
[10:30:53.618] result() for ClusterFuture ... done
[10:30:53.618] result() for ClusterFuture ...
[10:30:53.618] - result already collected: FutureResult
[10:30:53.618] result() for ClusterFuture ... done
[10:30:53.618] result() for ClusterFuture ...
[10:30:53.618] - result already collected: FutureResult
[10:30:53.618] result() for ClusterFuture ... done
[10:30:53.618] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:53.618] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:53.618] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:53.619]  length: 3 (resolved future 2)
[10:30:53.619] Future #3
[10:30:53.619] result() for ClusterFuture ...
[10:30:53.619] - result already collected: FutureResult
[10:30:53.619] result() for ClusterFuture ... done
[10:30:53.619] result() for ClusterFuture ...
[10:30:53.619] - result already collected: FutureResult
[10:30:53.619] result() for ClusterFuture ... done
[10:30:53.619] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:30:53.619] - nx: 5
[10:30:53.619] - relay: TRUE
[10:30:53.620] - stdout: TRUE
[10:30:53.620] - signal: TRUE
[10:30:53.620] - resignal: FALSE
[10:30:53.620] - force: TRUE
[10:30:53.620] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:53.620] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:30:53.620]  - until=3
[10:30:53.620]  - relaying element #3
[10:30:53.620] result() for ClusterFuture ...
[10:30:53.620] - result already collected: FutureResult
[10:30:53.620] result() for ClusterFuture ... done
[10:30:53.620] result() for ClusterFuture ...
[10:30:53.621] - result already collected: FutureResult
[10:30:53.621] result() for ClusterFuture ... done
[10:30:53.621] result() for ClusterFuture ...
[10:30:53.621] - result already collected: FutureResult
[10:30:53.621] result() for ClusterFuture ... done
[10:30:53.621] result() for ClusterFuture ...
[10:30:53.621] - result already collected: FutureResult
[10:30:53.621] result() for ClusterFuture ... done
[10:30:53.621] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:53.621] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:53.621] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:30:53.622]  length: 2 (resolved future 3)
[10:30:53.622] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.622] - Validating connection of MultisessionFuture
[10:30:53.622] - received message: FutureResult
[10:30:53.623] - Received FutureResult
[10:30:53.623] - Erased future from FutureRegistry
[10:30:53.623] result() for ClusterFuture ...
[10:30:53.623] - result already collected: FutureResult
[10:30:53.623] result() for ClusterFuture ... done
[10:30:53.623] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.623] Future #4
[10:30:53.623] result() for ClusterFuture ...
[10:30:53.623] - result already collected: FutureResult
[10:30:53.623] result() for ClusterFuture ... done
[10:30:53.623] result() for ClusterFuture ...
[10:30:53.624] - result already collected: FutureResult
[10:30:53.624] result() for ClusterFuture ... done
[10:30:53.624] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:30:53.624] - nx: 5
[10:30:53.624] - relay: TRUE
[10:30:53.624] - stdout: TRUE
[10:30:53.624] - signal: TRUE
[10:30:53.624] - resignal: FALSE
[10:30:53.624] - force: TRUE
[10:30:53.624] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:53.624] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:30:53.624]  - until=4
[10:30:53.625]  - relaying element #4
[10:30:53.625] result() for ClusterFuture ...
[10:30:53.625] - result already collected: FutureResult
[10:30:53.625] result() for ClusterFuture ... done
[10:30:53.625] result() for ClusterFuture ...
[10:30:53.625] - result already collected: FutureResult
[10:30:53.625] result() for ClusterFuture ... done
[10:30:53.625] result() for ClusterFuture ...
[10:30:53.625] - result already collected: FutureResult
[10:30:53.625] result() for ClusterFuture ... done
[10:30:53.626] result() for ClusterFuture ...
[10:30:53.626] - result already collected: FutureResult
[10:30:53.626] result() for ClusterFuture ... done
[10:30:53.626] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:53.626] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:53.626] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:30:53.626]  length: 1 (resolved future 4)
[10:30:53.647] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.647] - Validating connection of MultisessionFuture
[10:30:53.648] - received message: FutureResult
[10:30:53.648] - Received FutureResult
[10:30:53.648] - Erased future from FutureRegistry
[10:30:53.648] result() for ClusterFuture ...
[10:30:53.648] - result already collected: FutureResult
[10:30:53.648] result() for ClusterFuture ... done
[10:30:53.648] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.648] Future #5
[10:30:53.648] result() for ClusterFuture ...
[10:30:53.649] - result already collected: FutureResult
[10:30:53.649] result() for ClusterFuture ... done
[10:30:53.649] result() for ClusterFuture ...
[10:30:53.649] - result already collected: FutureResult
[10:30:53.649] result() for ClusterFuture ... done
[10:30:53.649] signalConditionsASAP(MultisessionFuture, pos=5) ...
[10:30:53.649] - nx: 5
[10:30:53.649] - relay: TRUE
[10:30:53.649] - stdout: TRUE
[10:30:53.649] - signal: TRUE
[10:30:53.649] - resignal: FALSE
[10:30:53.649] - force: TRUE
[10:30:53.650] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:53.650] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:30:53.650]  - until=5
[10:30:53.650]  - relaying element #5
[10:30:53.650] result() for ClusterFuture ...
[10:30:53.650] - result already collected: FutureResult
[10:30:53.650] result() for ClusterFuture ... done
[10:30:53.650] result() for ClusterFuture ...
[10:30:53.650] - result already collected: FutureResult
[10:30:53.650] result() for ClusterFuture ... done
[10:30:53.650] result() for ClusterFuture ...
[10:30:53.651] - result already collected: FutureResult
[10:30:53.651] result() for ClusterFuture ... done
[10:30:53.651] result() for ClusterFuture ...
[10:30:53.651] - result already collected: FutureResult
[10:30:53.651] result() for ClusterFuture ... done
[10:30:53.651] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:53.651] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:53.651] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[10:30:53.651]  length: 0 (resolved future 5)
[10:30:53.651] Relaying remaining futures
[10:30:53.651] signalConditionsASAP(NULL, pos=0) ...
[10:30:53.652] - nx: 5
[10:30:53.652] - relay: TRUE
[10:30:53.652] - stdout: TRUE
[10:30:53.652] - signal: TRUE
[10:30:53.652] - resignal: FALSE
[10:30:53.652] - force: TRUE
[10:30:53.652] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:53.652] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[10:30:53.652] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:53.652] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:30:53.652] signalConditionsASAP(NULL, pos=0) ... done
[10:30:53.653] resolve() on list ... DONE
[10:30:53.653] result() for ClusterFuture ...
[10:30:53.653] - result already collected: FutureResult
[10:30:53.653] result() for ClusterFuture ... done
[10:30:53.653] result() for ClusterFuture ...
[10:30:53.656] - result already collected: FutureResult
[10:30:53.656] result() for ClusterFuture ... done
[10:30:53.656] result() for ClusterFuture ...
[10:30:53.656] - result already collected: FutureResult
[10:30:53.656] result() for ClusterFuture ... done
[10:30:53.656] result() for ClusterFuture ...
[10:30:53.656] - result already collected: FutureResult
[10:30:53.656] result() for ClusterFuture ... done
[10:30:53.656] result() for ClusterFuture ...
[10:30:53.656] - result already collected: FutureResult
[10:30:53.656] result() for ClusterFuture ... done
[10:30:53.657] result() for ClusterFuture ...
[10:30:53.657] - result already collected: FutureResult
[10:30:53.657] result() for ClusterFuture ... done
[10:30:53.657] result() for ClusterFuture ...
[10:30:53.657] - result already collected: FutureResult
[10:30:53.657] result() for ClusterFuture ... done
[10:30:53.657] result() for ClusterFuture ...
[10:30:53.657] - result already collected: FutureResult
[10:30:53.657] result() for ClusterFuture ... done
[10:30:53.657] result() for ClusterFuture ...
[10:30:53.657] - result already collected: FutureResult
[10:30:53.657] result() for ClusterFuture ... done
[10:30:53.658] result() for ClusterFuture ...
[10:30:53.658] - result already collected: FutureResult
[10:30:53.658] result() for ClusterFuture ... done
[10:30:53.658]  - Number of value chunks collected: 5
[10:30:53.658] Resolving 5 futures (chunks) ... DONE
[10:30:53.658] Reducing values from 5 chunks ...
[10:30:53.658]  - Number of values collected after concatenation: 5
[10:30:53.658]  - Number of values expected: 5
[10:30:53.658] Reducing values from 5 chunks ... DONE
[10:30:53.658] future_mapply() ... DONE
[10:30:53.659] future_mapply() ...
[10:30:53.663] Number of chunks: 2
[10:30:53.663] getGlobalsAndPackagesXApply() ...
[10:30:53.663]  - future.globals: TRUE
[10:30:53.663] getGlobalsAndPackages() ...
[10:30:53.663] Searching for globals...
[10:30:53.664] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:53.664] Searching for globals ... DONE
[10:30:53.665] Resolving globals: FALSE
[10:30:53.665] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:53.665] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:53.665] - globals: [1] ‘FUN’
[10:30:53.665] 
[10:30:53.666] getGlobalsAndPackages() ... DONE
[10:30:53.666]  - globals found/used: [n=1] ‘FUN’
[10:30:53.666]  - needed namespaces: [n=0] 
[10:30:53.666] Finding globals ... DONE
[10:30:53.666] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:53.666] List of 2
[10:30:53.666]  $ ...future.FUN:function (C, k)  
[10:30:53.666]  $ MoreArgs     : list()
[10:30:53.666]  - attr(*, "where")=List of 2
[10:30:53.666]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:53.666]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:53.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:53.666]  - attr(*, "resolved")= logi FALSE
[10:30:53.666]  - attr(*, "total_size")= num NA
[10:30:53.669] Packages to be attached in all futures: [n=0] 
[10:30:53.669] getGlobalsAndPackagesXApply() ... DONE
[10:30:53.669] Number of futures (= number of chunks): 2
[10:30:53.669] Launching 2 futures (chunks) ...
[10:30:53.669] Chunk #1 of 2 ...
[10:30:53.669]  - Finding globals in '...' for chunk #1 ...
[10:30:53.669] getGlobalsAndPackages() ...
[10:30:53.669] Searching for globals...
[10:30:53.670] 
[10:30:53.670] Searching for globals ... DONE
[10:30:53.670] - globals: [0] <none>
[10:30:53.670] getGlobalsAndPackages() ... DONE
[10:30:53.670]    + additional globals found: [n=0] 
[10:30:53.670]    + additional namespaces needed: [n=0] 
[10:30:53.670]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:53.670]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:53.670]  - seeds: <none>
[10:30:53.671]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.671] getGlobalsAndPackages() ...
[10:30:53.671] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.671] Resolving globals: FALSE
[10:30:53.671] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:53.672] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:53.672] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.672] 
[10:30:53.672] getGlobalsAndPackages() ... DONE
[10:30:53.672] run() for ‘Future’ ...
[10:30:53.672] - state: ‘created’
[10:30:53.673] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.686] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.686]   - Field: ‘node’
[10:30:53.686]   - Field: ‘label’
[10:30:53.687]   - Field: ‘local’
[10:30:53.687]   - Field: ‘owner’
[10:30:53.687]   - Field: ‘envir’
[10:30:53.687]   - Field: ‘workers’
[10:30:53.687]   - Field: ‘packages’
[10:30:53.687]   - Field: ‘gc’
[10:30:53.687]   - Field: ‘conditions’
[10:30:53.687]   - Field: ‘persistent’
[10:30:53.687]   - Field: ‘expr’
[10:30:53.687]   - Field: ‘uuid’
[10:30:53.687]   - Field: ‘seed’
[10:30:53.688]   - Field: ‘version’
[10:30:53.688]   - Field: ‘result’
[10:30:53.688]   - Field: ‘asynchronous’
[10:30:53.688]   - Field: ‘calls’
[10:30:53.688]   - Field: ‘globals’
[10:30:53.688]   - Field: ‘stdout’
[10:30:53.688]   - Field: ‘earlySignal’
[10:30:53.688]   - Field: ‘lazy’
[10:30:53.688]   - Field: ‘state’
[10:30:53.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.688] - Launch lazy future ...
[10:30:53.689] Packages needed by the future expression (n = 0): <none>
[10:30:53.689] Packages needed by future strategies (n = 0): <none>
[10:30:53.689] {
[10:30:53.689]     {
[10:30:53.689]         {
[10:30:53.689]             ...future.startTime <- base::Sys.time()
[10:30:53.689]             {
[10:30:53.689]                 {
[10:30:53.689]                   {
[10:30:53.689]                     {
[10:30:53.689]                       base::local({
[10:30:53.689]                         has_future <- base::requireNamespace("future", 
[10:30:53.689]                           quietly = TRUE)
[10:30:53.689]                         if (has_future) {
[10:30:53.689]                           ns <- base::getNamespace("future")
[10:30:53.689]                           version <- ns[[".package"]][["version"]]
[10:30:53.689]                           if (is.null(version)) 
[10:30:53.689]                             version <- utils::packageVersion("future")
[10:30:53.689]                         }
[10:30:53.689]                         else {
[10:30:53.689]                           version <- NULL
[10:30:53.689]                         }
[10:30:53.689]                         if (!has_future || version < "1.8.0") {
[10:30:53.689]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.689]                             "", base::R.version$version.string), 
[10:30:53.689]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.689]                               "release", "version")], collapse = " "), 
[10:30:53.689]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.689]                             info)
[10:30:53.689]                           info <- base::paste(info, collapse = "; ")
[10:30:53.689]                           if (!has_future) {
[10:30:53.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.689]                               info)
[10:30:53.689]                           }
[10:30:53.689]                           else {
[10:30:53.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.689]                               info, version)
[10:30:53.689]                           }
[10:30:53.689]                           base::stop(msg)
[10:30:53.689]                         }
[10:30:53.689]                       })
[10:30:53.689]                     }
[10:30:53.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.689]                     base::options(mc.cores = 1L)
[10:30:53.689]                   }
[10:30:53.689]                   ...future.strategy.old <- future::plan("list")
[10:30:53.689]                   options(future.plan = NULL)
[10:30:53.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.689]                 }
[10:30:53.689]                 ...future.workdir <- getwd()
[10:30:53.689]             }
[10:30:53.689]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.689]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.689]         }
[10:30:53.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.689]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:53.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.689]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.689]             base::names(...future.oldOptions))
[10:30:53.689]     }
[10:30:53.689]     if (FALSE) {
[10:30:53.689]     }
[10:30:53.689]     else {
[10:30:53.689]         if (TRUE) {
[10:30:53.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.689]                 open = "w")
[10:30:53.689]         }
[10:30:53.689]         else {
[10:30:53.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.689]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.689]         }
[10:30:53.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.689]             base::sink(type = "output", split = FALSE)
[10:30:53.689]             base::close(...future.stdout)
[10:30:53.689]         }, add = TRUE)
[10:30:53.689]     }
[10:30:53.689]     ...future.frame <- base::sys.nframe()
[10:30:53.689]     ...future.conditions <- base::list()
[10:30:53.689]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.689]     if (FALSE) {
[10:30:53.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.689]     }
[10:30:53.689]     ...future.result <- base::tryCatch({
[10:30:53.689]         base::withCallingHandlers({
[10:30:53.689]             ...future.value <- base::withVisible(base::local({
[10:30:53.689]                 ...future.makeSendCondition <- base::local({
[10:30:53.689]                   sendCondition <- NULL
[10:30:53.689]                   function(frame = 1L) {
[10:30:53.689]                     if (is.function(sendCondition)) 
[10:30:53.689]                       return(sendCondition)
[10:30:53.689]                     ns <- getNamespace("parallel")
[10:30:53.689]                     if (exists("sendData", mode = "function", 
[10:30:53.689]                       envir = ns)) {
[10:30:53.689]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.689]                         envir = ns)
[10:30:53.689]                       envir <- sys.frame(frame)
[10:30:53.689]                       master <- NULL
[10:30:53.689]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.689]                         !identical(envir, emptyenv())) {
[10:30:53.689]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.689]                           inherits = FALSE)) {
[10:30:53.689]                           master <- get("master", mode = "list", 
[10:30:53.689]                             envir = envir, inherits = FALSE)
[10:30:53.689]                           if (inherits(master, c("SOCKnode", 
[10:30:53.689]                             "SOCK0node"))) {
[10:30:53.689]                             sendCondition <<- function(cond) {
[10:30:53.689]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.689]                                 success = TRUE)
[10:30:53.689]                               parallel_sendData(master, data)
[10:30:53.689]                             }
[10:30:53.689]                             return(sendCondition)
[10:30:53.689]                           }
[10:30:53.689]                         }
[10:30:53.689]                         frame <- frame + 1L
[10:30:53.689]                         envir <- sys.frame(frame)
[10:30:53.689]                       }
[10:30:53.689]                     }
[10:30:53.689]                     sendCondition <<- function(cond) NULL
[10:30:53.689]                   }
[10:30:53.689]                 })
[10:30:53.689]                 withCallingHandlers({
[10:30:53.689]                   {
[10:30:53.689]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.689]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.689]                       ...future.globals.maxSize)) {
[10:30:53.689]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.689]                       on.exit(options(oopts), add = TRUE)
[10:30:53.689]                     }
[10:30:53.689]                     {
[10:30:53.689]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.689]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.689]                         USE.NAMES = FALSE)
[10:30:53.689]                       do.call(mapply, args = args)
[10:30:53.689]                     }
[10:30:53.689]                   }
[10:30:53.689]                 }, immediateCondition = function(cond) {
[10:30:53.689]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.689]                   sendCondition(cond)
[10:30:53.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.689]                   {
[10:30:53.689]                     inherits <- base::inherits
[10:30:53.689]                     invokeRestart <- base::invokeRestart
[10:30:53.689]                     is.null <- base::is.null
[10:30:53.689]                     muffled <- FALSE
[10:30:53.689]                     if (inherits(cond, "message")) {
[10:30:53.689]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.689]                       if (muffled) 
[10:30:53.689]                         invokeRestart("muffleMessage")
[10:30:53.689]                     }
[10:30:53.689]                     else if (inherits(cond, "warning")) {
[10:30:53.689]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.689]                       if (muffled) 
[10:30:53.689]                         invokeRestart("muffleWarning")
[10:30:53.689]                     }
[10:30:53.689]                     else if (inherits(cond, "condition")) {
[10:30:53.689]                       if (!is.null(pattern)) {
[10:30:53.689]                         computeRestarts <- base::computeRestarts
[10:30:53.689]                         grepl <- base::grepl
[10:30:53.689]                         restarts <- computeRestarts(cond)
[10:30:53.689]                         for (restart in restarts) {
[10:30:53.689]                           name <- restart$name
[10:30:53.689]                           if (is.null(name)) 
[10:30:53.689]                             next
[10:30:53.689]                           if (!grepl(pattern, name)) 
[10:30:53.689]                             next
[10:30:53.689]                           invokeRestart(restart)
[10:30:53.689]                           muffled <- TRUE
[10:30:53.689]                           break
[10:30:53.689]                         }
[10:30:53.689]                       }
[10:30:53.689]                     }
[10:30:53.689]                     invisible(muffled)
[10:30:53.689]                   }
[10:30:53.689]                   muffleCondition(cond)
[10:30:53.689]                 })
[10:30:53.689]             }))
[10:30:53.689]             future::FutureResult(value = ...future.value$value, 
[10:30:53.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.689]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.689]                     ...future.globalenv.names))
[10:30:53.689]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.689]         }, condition = base::local({
[10:30:53.689]             c <- base::c
[10:30:53.689]             inherits <- base::inherits
[10:30:53.689]             invokeRestart <- base::invokeRestart
[10:30:53.689]             length <- base::length
[10:30:53.689]             list <- base::list
[10:30:53.689]             seq.int <- base::seq.int
[10:30:53.689]             signalCondition <- base::signalCondition
[10:30:53.689]             sys.calls <- base::sys.calls
[10:30:53.689]             `[[` <- base::`[[`
[10:30:53.689]             `+` <- base::`+`
[10:30:53.689]             `<<-` <- base::`<<-`
[10:30:53.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.689]                   3L)]
[10:30:53.689]             }
[10:30:53.689]             function(cond) {
[10:30:53.689]                 is_error <- inherits(cond, "error")
[10:30:53.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.689]                   NULL)
[10:30:53.689]                 if (is_error) {
[10:30:53.689]                   sessionInformation <- function() {
[10:30:53.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.689]                       search = base::search(), system = base::Sys.info())
[10:30:53.689]                   }
[10:30:53.689]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.689]                     cond$call), session = sessionInformation(), 
[10:30:53.689]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.689]                   signalCondition(cond)
[10:30:53.689]                 }
[10:30:53.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.689]                 "immediateCondition"))) {
[10:30:53.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.689]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.689]                   if (TRUE && !signal) {
[10:30:53.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.689]                     {
[10:30:53.689]                       inherits <- base::inherits
[10:30:53.689]                       invokeRestart <- base::invokeRestart
[10:30:53.689]                       is.null <- base::is.null
[10:30:53.689]                       muffled <- FALSE
[10:30:53.689]                       if (inherits(cond, "message")) {
[10:30:53.689]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.689]                         if (muffled) 
[10:30:53.689]                           invokeRestart("muffleMessage")
[10:30:53.689]                       }
[10:30:53.689]                       else if (inherits(cond, "warning")) {
[10:30:53.689]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.689]                         if (muffled) 
[10:30:53.689]                           invokeRestart("muffleWarning")
[10:30:53.689]                       }
[10:30:53.689]                       else if (inherits(cond, "condition")) {
[10:30:53.689]                         if (!is.null(pattern)) {
[10:30:53.689]                           computeRestarts <- base::computeRestarts
[10:30:53.689]                           grepl <- base::grepl
[10:30:53.689]                           restarts <- computeRestarts(cond)
[10:30:53.689]                           for (restart in restarts) {
[10:30:53.689]                             name <- restart$name
[10:30:53.689]                             if (is.null(name)) 
[10:30:53.689]                               next
[10:30:53.689]                             if (!grepl(pattern, name)) 
[10:30:53.689]                               next
[10:30:53.689]                             invokeRestart(restart)
[10:30:53.689]                             muffled <- TRUE
[10:30:53.689]                             break
[10:30:53.689]                           }
[10:30:53.689]                         }
[10:30:53.689]                       }
[10:30:53.689]                       invisible(muffled)
[10:30:53.689]                     }
[10:30:53.689]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.689]                   }
[10:30:53.689]                 }
[10:30:53.689]                 else {
[10:30:53.689]                   if (TRUE) {
[10:30:53.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.689]                     {
[10:30:53.689]                       inherits <- base::inherits
[10:30:53.689]                       invokeRestart <- base::invokeRestart
[10:30:53.689]                       is.null <- base::is.null
[10:30:53.689]                       muffled <- FALSE
[10:30:53.689]                       if (inherits(cond, "message")) {
[10:30:53.689]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.689]                         if (muffled) 
[10:30:53.689]                           invokeRestart("muffleMessage")
[10:30:53.689]                       }
[10:30:53.689]                       else if (inherits(cond, "warning")) {
[10:30:53.689]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.689]                         if (muffled) 
[10:30:53.689]                           invokeRestart("muffleWarning")
[10:30:53.689]                       }
[10:30:53.689]                       else if (inherits(cond, "condition")) {
[10:30:53.689]                         if (!is.null(pattern)) {
[10:30:53.689]                           computeRestarts <- base::computeRestarts
[10:30:53.689]                           grepl <- base::grepl
[10:30:53.689]                           restarts <- computeRestarts(cond)
[10:30:53.689]                           for (restart in restarts) {
[10:30:53.689]                             name <- restart$name
[10:30:53.689]                             if (is.null(name)) 
[10:30:53.689]                               next
[10:30:53.689]                             if (!grepl(pattern, name)) 
[10:30:53.689]                               next
[10:30:53.689]                             invokeRestart(restart)
[10:30:53.689]                             muffled <- TRUE
[10:30:53.689]                             break
[10:30:53.689]                           }
[10:30:53.689]                         }
[10:30:53.689]                       }
[10:30:53.689]                       invisible(muffled)
[10:30:53.689]                     }
[10:30:53.689]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.689]                   }
[10:30:53.689]                 }
[10:30:53.689]             }
[10:30:53.689]         }))
[10:30:53.689]     }, error = function(ex) {
[10:30:53.689]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.689]                 ...future.rng), started = ...future.startTime, 
[10:30:53.689]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.689]             version = "1.8"), class = "FutureResult")
[10:30:53.689]     }, finally = {
[10:30:53.689]         if (!identical(...future.workdir, getwd())) 
[10:30:53.689]             setwd(...future.workdir)
[10:30:53.689]         {
[10:30:53.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.689]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.689]             }
[10:30:53.689]             base::options(...future.oldOptions)
[10:30:53.689]             if (.Platform$OS.type == "windows") {
[10:30:53.689]                 old_names <- names(...future.oldEnvVars)
[10:30:53.689]                 envs <- base::Sys.getenv()
[10:30:53.689]                 names <- names(envs)
[10:30:53.689]                 common <- intersect(names, old_names)
[10:30:53.689]                 added <- setdiff(names, old_names)
[10:30:53.689]                 removed <- setdiff(old_names, names)
[10:30:53.689]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.689]                   envs[common]]
[10:30:53.689]                 NAMES <- toupper(changed)
[10:30:53.689]                 args <- list()
[10:30:53.689]                 for (kk in seq_along(NAMES)) {
[10:30:53.689]                   name <- changed[[kk]]
[10:30:53.689]                   NAME <- NAMES[[kk]]
[10:30:53.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.689]                     next
[10:30:53.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.689]                 }
[10:30:53.689]                 NAMES <- toupper(added)
[10:30:53.689]                 for (kk in seq_along(NAMES)) {
[10:30:53.689]                   name <- added[[kk]]
[10:30:53.689]                   NAME <- NAMES[[kk]]
[10:30:53.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.689]                     next
[10:30:53.689]                   args[[name]] <- ""
[10:30:53.689]                 }
[10:30:53.689]                 NAMES <- toupper(removed)
[10:30:53.689]                 for (kk in seq_along(NAMES)) {
[10:30:53.689]                   name <- removed[[kk]]
[10:30:53.689]                   NAME <- NAMES[[kk]]
[10:30:53.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.689]                     next
[10:30:53.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.689]                 }
[10:30:53.689]                 if (length(args) > 0) 
[10:30:53.689]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.689]             }
[10:30:53.689]             else {
[10:30:53.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.689]             }
[10:30:53.689]             {
[10:30:53.689]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.689]                   0L) {
[10:30:53.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.689]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.689]                   base::options(opts)
[10:30:53.689]                 }
[10:30:53.689]                 {
[10:30:53.689]                   {
[10:30:53.689]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.689]                     NULL
[10:30:53.689]                   }
[10:30:53.689]                   options(future.plan = NULL)
[10:30:53.689]                   if (is.na(NA_character_)) 
[10:30:53.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.689]                     .init = FALSE)
[10:30:53.689]                 }
[10:30:53.689]             }
[10:30:53.689]         }
[10:30:53.689]     })
[10:30:53.689]     if (TRUE) {
[10:30:53.689]         base::sink(type = "output", split = FALSE)
[10:30:53.689]         if (TRUE) {
[10:30:53.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.689]         }
[10:30:53.689]         else {
[10:30:53.689]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.689]         }
[10:30:53.689]         base::close(...future.stdout)
[10:30:53.689]         ...future.stdout <- NULL
[10:30:53.689]     }
[10:30:53.689]     ...future.result$conditions <- ...future.conditions
[10:30:53.689]     ...future.result$finished <- base::Sys.time()
[10:30:53.689]     ...future.result
[10:30:53.689] }
[10:30:53.692] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[10:30:53.692] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[10:30:53.693] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[10:30:53.693] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:53.693] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.693] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[10:30:53.694] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[10:30:53.694] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:53.694] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.694] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:53.695] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.695] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[10:30:53.695] MultisessionFuture started
[10:30:53.696] - Launch lazy future ... done
[10:30:53.696] run() for ‘MultisessionFuture’ ... done
[10:30:53.696] Created future:
[10:30:53.696] MultisessionFuture:
[10:30:53.696] Label: ‘future_.mapply-1’
[10:30:53.696] Expression:
[10:30:53.696] {
[10:30:53.696]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.696]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.696]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.696]         on.exit(options(oopts), add = TRUE)
[10:30:53.696]     }
[10:30:53.696]     {
[10:30:53.696]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.696]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.696]         do.call(mapply, args = args)
[10:30:53.696]     }
[10:30:53.696] }
[10:30:53.696] Lazy evaluation: FALSE
[10:30:53.696] Asynchronous evaluation: TRUE
[10:30:53.696] Local evaluation: TRUE
[10:30:53.696] Environment: R_GlobalEnv
[10:30:53.696] Capture standard output: TRUE
[10:30:53.696] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.696] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.696] Packages: <none>
[10:30:53.696] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.696] Resolved: FALSE
[10:30:53.696] Value: <not collected>
[10:30:53.696] Conditions captured: <none>
[10:30:53.696] Early signaling: FALSE
[10:30:53.696] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.696] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.707] Chunk #1 of 2 ... DONE
[10:30:53.708] Chunk #2 of 2 ...
[10:30:53.708]  - Finding globals in '...' for chunk #2 ...
[10:30:53.708] getGlobalsAndPackages() ...
[10:30:53.708] Searching for globals...
[10:30:53.708] 
[10:30:53.708] Searching for globals ... DONE
[10:30:53.709] - globals: [0] <none>
[10:30:53.709] getGlobalsAndPackages() ... DONE
[10:30:53.709]    + additional globals found: [n=0] 
[10:30:53.709]    + additional namespaces needed: [n=0] 
[10:30:53.709]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:53.709]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:53.709]  - seeds: <none>
[10:30:53.709]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.709] getGlobalsAndPackages() ...
[10:30:53.709] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.710] Resolving globals: FALSE
[10:30:53.710] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[10:30:53.711] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:53.711] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.711] 
[10:30:53.711] getGlobalsAndPackages() ... DONE
[10:30:53.711] run() for ‘Future’ ...
[10:30:53.711] - state: ‘created’
[10:30:53.711] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.725] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.726]   - Field: ‘node’
[10:30:53.726]   - Field: ‘label’
[10:30:53.726]   - Field: ‘local’
[10:30:53.726]   - Field: ‘owner’
[10:30:53.726]   - Field: ‘envir’
[10:30:53.726]   - Field: ‘workers’
[10:30:53.726]   - Field: ‘packages’
[10:30:53.726]   - Field: ‘gc’
[10:30:53.726]   - Field: ‘conditions’
[10:30:53.727]   - Field: ‘persistent’
[10:30:53.727]   - Field: ‘expr’
[10:30:53.727]   - Field: ‘uuid’
[10:30:53.727]   - Field: ‘seed’
[10:30:53.727]   - Field: ‘version’
[10:30:53.727]   - Field: ‘result’
[10:30:53.727]   - Field: ‘asynchronous’
[10:30:53.727]   - Field: ‘calls’
[10:30:53.727]   - Field: ‘globals’
[10:30:53.727]   - Field: ‘stdout’
[10:30:53.727]   - Field: ‘earlySignal’
[10:30:53.728]   - Field: ‘lazy’
[10:30:53.728]   - Field: ‘state’
[10:30:53.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.728] - Launch lazy future ...
[10:30:53.728] Packages needed by the future expression (n = 0): <none>
[10:30:53.728] Packages needed by future strategies (n = 0): <none>
[10:30:53.729] {
[10:30:53.729]     {
[10:30:53.729]         {
[10:30:53.729]             ...future.startTime <- base::Sys.time()
[10:30:53.729]             {
[10:30:53.729]                 {
[10:30:53.729]                   {
[10:30:53.729]                     {
[10:30:53.729]                       base::local({
[10:30:53.729]                         has_future <- base::requireNamespace("future", 
[10:30:53.729]                           quietly = TRUE)
[10:30:53.729]                         if (has_future) {
[10:30:53.729]                           ns <- base::getNamespace("future")
[10:30:53.729]                           version <- ns[[".package"]][["version"]]
[10:30:53.729]                           if (is.null(version)) 
[10:30:53.729]                             version <- utils::packageVersion("future")
[10:30:53.729]                         }
[10:30:53.729]                         else {
[10:30:53.729]                           version <- NULL
[10:30:53.729]                         }
[10:30:53.729]                         if (!has_future || version < "1.8.0") {
[10:30:53.729]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.729]                             "", base::R.version$version.string), 
[10:30:53.729]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.729]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.729]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.729]                               "release", "version")], collapse = " "), 
[10:30:53.729]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.729]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.729]                             info)
[10:30:53.729]                           info <- base::paste(info, collapse = "; ")
[10:30:53.729]                           if (!has_future) {
[10:30:53.729]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.729]                               info)
[10:30:53.729]                           }
[10:30:53.729]                           else {
[10:30:53.729]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.729]                               info, version)
[10:30:53.729]                           }
[10:30:53.729]                           base::stop(msg)
[10:30:53.729]                         }
[10:30:53.729]                       })
[10:30:53.729]                     }
[10:30:53.729]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.729]                     base::options(mc.cores = 1L)
[10:30:53.729]                   }
[10:30:53.729]                   ...future.strategy.old <- future::plan("list")
[10:30:53.729]                   options(future.plan = NULL)
[10:30:53.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.729]                 }
[10:30:53.729]                 ...future.workdir <- getwd()
[10:30:53.729]             }
[10:30:53.729]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.729]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.729]         }
[10:30:53.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.729]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:53.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.729]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.729]             base::names(...future.oldOptions))
[10:30:53.729]     }
[10:30:53.729]     if (FALSE) {
[10:30:53.729]     }
[10:30:53.729]     else {
[10:30:53.729]         if (TRUE) {
[10:30:53.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.729]                 open = "w")
[10:30:53.729]         }
[10:30:53.729]         else {
[10:30:53.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.729]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.729]         }
[10:30:53.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.729]             base::sink(type = "output", split = FALSE)
[10:30:53.729]             base::close(...future.stdout)
[10:30:53.729]         }, add = TRUE)
[10:30:53.729]     }
[10:30:53.729]     ...future.frame <- base::sys.nframe()
[10:30:53.729]     ...future.conditions <- base::list()
[10:30:53.729]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.729]     if (FALSE) {
[10:30:53.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.729]     }
[10:30:53.729]     ...future.result <- base::tryCatch({
[10:30:53.729]         base::withCallingHandlers({
[10:30:53.729]             ...future.value <- base::withVisible(base::local({
[10:30:53.729]                 ...future.makeSendCondition <- base::local({
[10:30:53.729]                   sendCondition <- NULL
[10:30:53.729]                   function(frame = 1L) {
[10:30:53.729]                     if (is.function(sendCondition)) 
[10:30:53.729]                       return(sendCondition)
[10:30:53.729]                     ns <- getNamespace("parallel")
[10:30:53.729]                     if (exists("sendData", mode = "function", 
[10:30:53.729]                       envir = ns)) {
[10:30:53.729]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.729]                         envir = ns)
[10:30:53.729]                       envir <- sys.frame(frame)
[10:30:53.729]                       master <- NULL
[10:30:53.729]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.729]                         !identical(envir, emptyenv())) {
[10:30:53.729]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.729]                           inherits = FALSE)) {
[10:30:53.729]                           master <- get("master", mode = "list", 
[10:30:53.729]                             envir = envir, inherits = FALSE)
[10:30:53.729]                           if (inherits(master, c("SOCKnode", 
[10:30:53.729]                             "SOCK0node"))) {
[10:30:53.729]                             sendCondition <<- function(cond) {
[10:30:53.729]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.729]                                 success = TRUE)
[10:30:53.729]                               parallel_sendData(master, data)
[10:30:53.729]                             }
[10:30:53.729]                             return(sendCondition)
[10:30:53.729]                           }
[10:30:53.729]                         }
[10:30:53.729]                         frame <- frame + 1L
[10:30:53.729]                         envir <- sys.frame(frame)
[10:30:53.729]                       }
[10:30:53.729]                     }
[10:30:53.729]                     sendCondition <<- function(cond) NULL
[10:30:53.729]                   }
[10:30:53.729]                 })
[10:30:53.729]                 withCallingHandlers({
[10:30:53.729]                   {
[10:30:53.729]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.729]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.729]                       ...future.globals.maxSize)) {
[10:30:53.729]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.729]                       on.exit(options(oopts), add = TRUE)
[10:30:53.729]                     }
[10:30:53.729]                     {
[10:30:53.729]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.729]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.729]                         USE.NAMES = FALSE)
[10:30:53.729]                       do.call(mapply, args = args)
[10:30:53.729]                     }
[10:30:53.729]                   }
[10:30:53.729]                 }, immediateCondition = function(cond) {
[10:30:53.729]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.729]                   sendCondition(cond)
[10:30:53.729]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.729]                   {
[10:30:53.729]                     inherits <- base::inherits
[10:30:53.729]                     invokeRestart <- base::invokeRestart
[10:30:53.729]                     is.null <- base::is.null
[10:30:53.729]                     muffled <- FALSE
[10:30:53.729]                     if (inherits(cond, "message")) {
[10:30:53.729]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.729]                       if (muffled) 
[10:30:53.729]                         invokeRestart("muffleMessage")
[10:30:53.729]                     }
[10:30:53.729]                     else if (inherits(cond, "warning")) {
[10:30:53.729]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.729]                       if (muffled) 
[10:30:53.729]                         invokeRestart("muffleWarning")
[10:30:53.729]                     }
[10:30:53.729]                     else if (inherits(cond, "condition")) {
[10:30:53.729]                       if (!is.null(pattern)) {
[10:30:53.729]                         computeRestarts <- base::computeRestarts
[10:30:53.729]                         grepl <- base::grepl
[10:30:53.729]                         restarts <- computeRestarts(cond)
[10:30:53.729]                         for (restart in restarts) {
[10:30:53.729]                           name <- restart$name
[10:30:53.729]                           if (is.null(name)) 
[10:30:53.729]                             next
[10:30:53.729]                           if (!grepl(pattern, name)) 
[10:30:53.729]                             next
[10:30:53.729]                           invokeRestart(restart)
[10:30:53.729]                           muffled <- TRUE
[10:30:53.729]                           break
[10:30:53.729]                         }
[10:30:53.729]                       }
[10:30:53.729]                     }
[10:30:53.729]                     invisible(muffled)
[10:30:53.729]                   }
[10:30:53.729]                   muffleCondition(cond)
[10:30:53.729]                 })
[10:30:53.729]             }))
[10:30:53.729]             future::FutureResult(value = ...future.value$value, 
[10:30:53.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.729]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.729]                     ...future.globalenv.names))
[10:30:53.729]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.729]         }, condition = base::local({
[10:30:53.729]             c <- base::c
[10:30:53.729]             inherits <- base::inherits
[10:30:53.729]             invokeRestart <- base::invokeRestart
[10:30:53.729]             length <- base::length
[10:30:53.729]             list <- base::list
[10:30:53.729]             seq.int <- base::seq.int
[10:30:53.729]             signalCondition <- base::signalCondition
[10:30:53.729]             sys.calls <- base::sys.calls
[10:30:53.729]             `[[` <- base::`[[`
[10:30:53.729]             `+` <- base::`+`
[10:30:53.729]             `<<-` <- base::`<<-`
[10:30:53.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.729]                   3L)]
[10:30:53.729]             }
[10:30:53.729]             function(cond) {
[10:30:53.729]                 is_error <- inherits(cond, "error")
[10:30:53.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.729]                   NULL)
[10:30:53.729]                 if (is_error) {
[10:30:53.729]                   sessionInformation <- function() {
[10:30:53.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.729]                       search = base::search(), system = base::Sys.info())
[10:30:53.729]                   }
[10:30:53.729]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.729]                     cond$call), session = sessionInformation(), 
[10:30:53.729]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.729]                   signalCondition(cond)
[10:30:53.729]                 }
[10:30:53.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.729]                 "immediateCondition"))) {
[10:30:53.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.729]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.729]                   if (TRUE && !signal) {
[10:30:53.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.729]                     {
[10:30:53.729]                       inherits <- base::inherits
[10:30:53.729]                       invokeRestart <- base::invokeRestart
[10:30:53.729]                       is.null <- base::is.null
[10:30:53.729]                       muffled <- FALSE
[10:30:53.729]                       if (inherits(cond, "message")) {
[10:30:53.729]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.729]                         if (muffled) 
[10:30:53.729]                           invokeRestart("muffleMessage")
[10:30:53.729]                       }
[10:30:53.729]                       else if (inherits(cond, "warning")) {
[10:30:53.729]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.729]                         if (muffled) 
[10:30:53.729]                           invokeRestart("muffleWarning")
[10:30:53.729]                       }
[10:30:53.729]                       else if (inherits(cond, "condition")) {
[10:30:53.729]                         if (!is.null(pattern)) {
[10:30:53.729]                           computeRestarts <- base::computeRestarts
[10:30:53.729]                           grepl <- base::grepl
[10:30:53.729]                           restarts <- computeRestarts(cond)
[10:30:53.729]                           for (restart in restarts) {
[10:30:53.729]                             name <- restart$name
[10:30:53.729]                             if (is.null(name)) 
[10:30:53.729]                               next
[10:30:53.729]                             if (!grepl(pattern, name)) 
[10:30:53.729]                               next
[10:30:53.729]                             invokeRestart(restart)
[10:30:53.729]                             muffled <- TRUE
[10:30:53.729]                             break
[10:30:53.729]                           }
[10:30:53.729]                         }
[10:30:53.729]                       }
[10:30:53.729]                       invisible(muffled)
[10:30:53.729]                     }
[10:30:53.729]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.729]                   }
[10:30:53.729]                 }
[10:30:53.729]                 else {
[10:30:53.729]                   if (TRUE) {
[10:30:53.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.729]                     {
[10:30:53.729]                       inherits <- base::inherits
[10:30:53.729]                       invokeRestart <- base::invokeRestart
[10:30:53.729]                       is.null <- base::is.null
[10:30:53.729]                       muffled <- FALSE
[10:30:53.729]                       if (inherits(cond, "message")) {
[10:30:53.729]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.729]                         if (muffled) 
[10:30:53.729]                           invokeRestart("muffleMessage")
[10:30:53.729]                       }
[10:30:53.729]                       else if (inherits(cond, "warning")) {
[10:30:53.729]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.729]                         if (muffled) 
[10:30:53.729]                           invokeRestart("muffleWarning")
[10:30:53.729]                       }
[10:30:53.729]                       else if (inherits(cond, "condition")) {
[10:30:53.729]                         if (!is.null(pattern)) {
[10:30:53.729]                           computeRestarts <- base::computeRestarts
[10:30:53.729]                           grepl <- base::grepl
[10:30:53.729]                           restarts <- computeRestarts(cond)
[10:30:53.729]                           for (restart in restarts) {
[10:30:53.729]                             name <- restart$name
[10:30:53.729]                             if (is.null(name)) 
[10:30:53.729]                               next
[10:30:53.729]                             if (!grepl(pattern, name)) 
[10:30:53.729]                               next
[10:30:53.729]                             invokeRestart(restart)
[10:30:53.729]                             muffled <- TRUE
[10:30:53.729]                             break
[10:30:53.729]                           }
[10:30:53.729]                         }
[10:30:53.729]                       }
[10:30:53.729]                       invisible(muffled)
[10:30:53.729]                     }
[10:30:53.729]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.729]                   }
[10:30:53.729]                 }
[10:30:53.729]             }
[10:30:53.729]         }))
[10:30:53.729]     }, error = function(ex) {
[10:30:53.729]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.729]                 ...future.rng), started = ...future.startTime, 
[10:30:53.729]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.729]             version = "1.8"), class = "FutureResult")
[10:30:53.729]     }, finally = {
[10:30:53.729]         if (!identical(...future.workdir, getwd())) 
[10:30:53.729]             setwd(...future.workdir)
[10:30:53.729]         {
[10:30:53.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.729]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.729]             }
[10:30:53.729]             base::options(...future.oldOptions)
[10:30:53.729]             if (.Platform$OS.type == "windows") {
[10:30:53.729]                 old_names <- names(...future.oldEnvVars)
[10:30:53.729]                 envs <- base::Sys.getenv()
[10:30:53.729]                 names <- names(envs)
[10:30:53.729]                 common <- intersect(names, old_names)
[10:30:53.729]                 added <- setdiff(names, old_names)
[10:30:53.729]                 removed <- setdiff(old_names, names)
[10:30:53.729]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.729]                   envs[common]]
[10:30:53.729]                 NAMES <- toupper(changed)
[10:30:53.729]                 args <- list()
[10:30:53.729]                 for (kk in seq_along(NAMES)) {
[10:30:53.729]                   name <- changed[[kk]]
[10:30:53.729]                   NAME <- NAMES[[kk]]
[10:30:53.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.729]                     next
[10:30:53.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.729]                 }
[10:30:53.729]                 NAMES <- toupper(added)
[10:30:53.729]                 for (kk in seq_along(NAMES)) {
[10:30:53.729]                   name <- added[[kk]]
[10:30:53.729]                   NAME <- NAMES[[kk]]
[10:30:53.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.729]                     next
[10:30:53.729]                   args[[name]] <- ""
[10:30:53.729]                 }
[10:30:53.729]                 NAMES <- toupper(removed)
[10:30:53.729]                 for (kk in seq_along(NAMES)) {
[10:30:53.729]                   name <- removed[[kk]]
[10:30:53.729]                   NAME <- NAMES[[kk]]
[10:30:53.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.729]                     next
[10:30:53.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.729]                 }
[10:30:53.729]                 if (length(args) > 0) 
[10:30:53.729]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.729]             }
[10:30:53.729]             else {
[10:30:53.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.729]             }
[10:30:53.729]             {
[10:30:53.729]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.729]                   0L) {
[10:30:53.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.729]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.729]                   base::options(opts)
[10:30:53.729]                 }
[10:30:53.729]                 {
[10:30:53.729]                   {
[10:30:53.729]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.729]                     NULL
[10:30:53.729]                   }
[10:30:53.729]                   options(future.plan = NULL)
[10:30:53.729]                   if (is.na(NA_character_)) 
[10:30:53.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.729]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.729]                     .init = FALSE)
[10:30:53.729]                 }
[10:30:53.729]             }
[10:30:53.729]         }
[10:30:53.729]     })
[10:30:53.729]     if (TRUE) {
[10:30:53.729]         base::sink(type = "output", split = FALSE)
[10:30:53.729]         if (TRUE) {
[10:30:53.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.729]         }
[10:30:53.729]         else {
[10:30:53.729]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.729]         }
[10:30:53.729]         base::close(...future.stdout)
[10:30:53.729]         ...future.stdout <- NULL
[10:30:53.729]     }
[10:30:53.729]     ...future.result$conditions <- ...future.conditions
[10:30:53.729]     ...future.result$finished <- base::Sys.time()
[10:30:53.729]     ...future.result
[10:30:53.729] }
[10:30:53.732] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[10:30:53.732] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[10:30:53.732] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[10:30:53.732] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:53.733] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.733] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[10:30:53.733] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[10:30:53.733] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:53.734] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.734] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:53.734] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.734] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[10:30:53.735] MultisessionFuture started
[10:30:53.735] - Launch lazy future ... done
[10:30:53.735] run() for ‘MultisessionFuture’ ... done
[10:30:53.735] Created future:
[10:30:53.736] MultisessionFuture:
[10:30:53.736] Label: ‘future_.mapply-2’
[10:30:53.736] Expression:
[10:30:53.736] {
[10:30:53.736]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.736]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.736]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.736]         on.exit(options(oopts), add = TRUE)
[10:30:53.736]     }
[10:30:53.736]     {
[10:30:53.736]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.736]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.736]         do.call(mapply, args = args)
[10:30:53.736]     }
[10:30:53.736] }
[10:30:53.736] Lazy evaluation: FALSE
[10:30:53.736] Asynchronous evaluation: TRUE
[10:30:53.736] Local evaluation: TRUE
[10:30:53.736] Environment: R_GlobalEnv
[10:30:53.736] Capture standard output: TRUE
[10:30:53.736] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.736] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.736] Packages: <none>
[10:30:53.736] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.736] Resolved: FALSE
[10:30:53.736] Value: <not collected>
[10:30:53.736] Conditions captured: <none>
[10:30:53.736] Early signaling: FALSE
[10:30:53.736] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.736] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.747] Chunk #2 of 2 ... DONE
[10:30:53.747] Launching 2 futures (chunks) ... DONE
[10:30:53.747] Resolving 2 futures (chunks) ...
[10:30:53.747] resolve() on list ...
[10:30:53.747]  recursive: 0
[10:30:53.748]  length: 2
[10:30:53.748] 
[10:30:53.748] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.748] - Validating connection of MultisessionFuture
[10:30:53.748] - received message: FutureResult
[10:30:53.749] - Received FutureResult
[10:30:53.749] - Erased future from FutureRegistry
[10:30:53.749] result() for ClusterFuture ...
[10:30:53.749] - result already collected: FutureResult
[10:30:53.749] result() for ClusterFuture ... done
[10:30:53.749] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.749] Future #1
[10:30:53.749] result() for ClusterFuture ...
[10:30:53.749] - result already collected: FutureResult
[10:30:53.749] result() for ClusterFuture ... done
[10:30:53.750] result() for ClusterFuture ...
[10:30:53.750] - result already collected: FutureResult
[10:30:53.750] result() for ClusterFuture ... done
[10:30:53.750] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:53.750] - nx: 2
[10:30:53.750] - relay: TRUE
[10:30:53.750] - stdout: TRUE
[10:30:53.750] - signal: TRUE
[10:30:53.750] - resignal: FALSE
[10:30:53.750] - force: TRUE
[10:30:53.750] - relayed: [n=2] FALSE, FALSE
[10:30:53.750] - queued futures: [n=2] FALSE, FALSE
[10:30:53.751]  - until=1
[10:30:53.751]  - relaying element #1
[10:30:53.751] result() for ClusterFuture ...
[10:30:53.751] - result already collected: FutureResult
[10:30:53.751] result() for ClusterFuture ... done
[10:30:53.751] result() for ClusterFuture ...
[10:30:53.751] - result already collected: FutureResult
[10:30:53.751] result() for ClusterFuture ... done
[10:30:53.751] result() for ClusterFuture ...
[10:30:53.751] - result already collected: FutureResult
[10:30:53.751] result() for ClusterFuture ... done
[10:30:53.752] result() for ClusterFuture ...
[10:30:53.752] - result already collected: FutureResult
[10:30:53.752] result() for ClusterFuture ... done
[10:30:53.752] - relayed: [n=2] TRUE, FALSE
[10:30:53.752] - queued futures: [n=2] TRUE, FALSE
[10:30:53.752] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:53.752]  length: 1 (resolved future 1)
[10:30:53.779] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.779] - Validating connection of MultisessionFuture
[10:30:53.779] - received message: FutureResult
[10:30:53.779] - Received FutureResult
[10:30:53.779] - Erased future from FutureRegistry
[10:30:53.779] result() for ClusterFuture ...
[10:30:53.780] - result already collected: FutureResult
[10:30:53.780] result() for ClusterFuture ... done
[10:30:53.780] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.780] Future #2
[10:30:53.780] result() for ClusterFuture ...
[10:30:53.780] - result already collected: FutureResult
[10:30:53.780] result() for ClusterFuture ... done
[10:30:53.781] result() for ClusterFuture ...
[10:30:53.781] - result already collected: FutureResult
[10:30:53.781] result() for ClusterFuture ... done
[10:30:53.781] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:53.781] - nx: 2
[10:30:53.781] - relay: TRUE
[10:30:53.781] - stdout: TRUE
[10:30:53.781] - signal: TRUE
[10:30:53.782] - resignal: FALSE
[10:30:53.782] - force: TRUE
[10:30:53.782] - relayed: [n=2] TRUE, FALSE
[10:30:53.782] - queued futures: [n=2] TRUE, FALSE
[10:30:53.782]  - until=2
[10:30:53.782]  - relaying element #2
[10:30:53.782] result() for ClusterFuture ...
[10:30:53.782] - result already collected: FutureResult
[10:30:53.783] result() for ClusterFuture ... done
[10:30:53.783] result() for ClusterFuture ...
[10:30:53.783] - result already collected: FutureResult
[10:30:53.783] result() for ClusterFuture ... done
[10:30:53.783] result() for ClusterFuture ...
[10:30:53.783] - result already collected: FutureResult
[10:30:53.783] result() for ClusterFuture ... done
[10:30:53.784] result() for ClusterFuture ...
[10:30:53.784] - result already collected: FutureResult
[10:30:53.784] result() for ClusterFuture ... done
[10:30:53.784] - relayed: [n=2] TRUE, TRUE
[10:30:53.784] - queued futures: [n=2] TRUE, TRUE
[10:30:53.784] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:53.784]  length: 0 (resolved future 2)
[10:30:53.784] Relaying remaining futures
[10:30:53.785] signalConditionsASAP(NULL, pos=0) ...
[10:30:53.785] - nx: 2
[10:30:53.785] - relay: TRUE
[10:30:53.785] - stdout: TRUE
[10:30:53.785] - signal: TRUE
[10:30:53.785] - resignal: FALSE
[10:30:53.785] - force: TRUE
[10:30:53.785] - relayed: [n=2] TRUE, TRUE
[10:30:53.786] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:53.786] - relayed: [n=2] TRUE, TRUE
[10:30:53.786] - queued futures: [n=2] TRUE, TRUE
[10:30:53.786] signalConditionsASAP(NULL, pos=0) ... done
[10:30:53.786] resolve() on list ... DONE
[10:30:53.786] result() for ClusterFuture ...
[10:30:53.786] - result already collected: FutureResult
[10:30:53.787] result() for ClusterFuture ... done
[10:30:53.787] result() for ClusterFuture ...
[10:30:53.787] - result already collected: FutureResult
[10:30:53.787] result() for ClusterFuture ... done
[10:30:53.787] result() for ClusterFuture ...
[10:30:53.787] - result already collected: FutureResult
[10:30:53.787] result() for ClusterFuture ... done
[10:30:53.787] result() for ClusterFuture ...
[10:30:53.788] - result already collected: FutureResult
[10:30:53.788] result() for ClusterFuture ... done
[10:30:53.788]  - Number of value chunks collected: 2
[10:30:53.788] Resolving 2 futures (chunks) ... DONE
[10:30:53.788] Reducing values from 2 chunks ...
[10:30:53.788]  - Number of values collected after concatenation: 5
[10:30:53.788]  - Number of values expected: 5
[10:30:53.788] Reducing values from 2 chunks ... DONE
[10:30:53.789] future_mapply() ... DONE
[10:30:53.789] future_mapply() ...
[10:30:53.794] Number of chunks: 3
[10:30:53.794] Index remapping (attribute 'ordering'): [n = 5] 5, 3, 2, 1, 4
[10:30:53.794] getGlobalsAndPackagesXApply() ...
[10:30:53.794]  - future.globals: TRUE
[10:30:53.794] getGlobalsAndPackages() ...
[10:30:53.795] Searching for globals...
[10:30:53.796] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:53.796] Searching for globals ... DONE
[10:30:53.796] Resolving globals: FALSE
[10:30:53.797] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:53.797] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:53.797] - globals: [1] ‘FUN’
[10:30:53.797] 
[10:30:53.798] getGlobalsAndPackages() ... DONE
[10:30:53.798]  - globals found/used: [n=1] ‘FUN’
[10:30:53.798]  - needed namespaces: [n=0] 
[10:30:53.798] Finding globals ... DONE
[10:30:53.798] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:53.798] List of 2
[10:30:53.798]  $ ...future.FUN:function (C, k)  
[10:30:53.798]  $ MoreArgs     : NULL
[10:30:53.798]  - attr(*, "where")=List of 2
[10:30:53.798]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:53.798]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:53.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:53.798]  - attr(*, "resolved")= logi FALSE
[10:30:53.798]  - attr(*, "total_size")= num NA
[10:30:53.801] Packages to be attached in all futures: [n=0] 
[10:30:53.801] getGlobalsAndPackagesXApply() ... DONE
[10:30:53.801] Number of futures (= number of chunks): 3
[10:30:53.801] Launching 3 futures (chunks) ...
[10:30:53.801] Chunk #1 of 3 ...
[10:30:53.801]  - Finding globals in '...' for chunk #1 ...
[10:30:53.801] getGlobalsAndPackages() ...
[10:30:53.801] Searching for globals...
[10:30:53.802] 
[10:30:53.802] Searching for globals ... DONE
[10:30:53.802] - globals: [0] <none>
[10:30:53.802] getGlobalsAndPackages() ... DONE
[10:30:53.802]    + additional globals found: [n=0] 
[10:30:53.802]    + additional namespaces needed: [n=0] 
[10:30:53.802]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:53.802]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:30:53.803]  - seeds: <none>
[10:30:53.803]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.803] getGlobalsAndPackages() ...
[10:30:53.803] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.803] Resolving globals: FALSE
[10:30:53.803] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:53.804] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:53.804] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.804] 
[10:30:53.804] getGlobalsAndPackages() ... DONE
[10:30:53.804] run() for ‘Future’ ...
[10:30:53.805] - state: ‘created’
[10:30:53.805] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.819] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.819] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.819]   - Field: ‘node’
[10:30:53.819]   - Field: ‘label’
[10:30:53.819]   - Field: ‘local’
[10:30:53.819]   - Field: ‘owner’
[10:30:53.819]   - Field: ‘envir’
[10:30:53.819]   - Field: ‘workers’
[10:30:53.819]   - Field: ‘packages’
[10:30:53.819]   - Field: ‘gc’
[10:30:53.820]   - Field: ‘conditions’
[10:30:53.820]   - Field: ‘persistent’
[10:30:53.820]   - Field: ‘expr’
[10:30:53.820]   - Field: ‘uuid’
[10:30:53.820]   - Field: ‘seed’
[10:30:53.820]   - Field: ‘version’
[10:30:53.820]   - Field: ‘result’
[10:30:53.820]   - Field: ‘asynchronous’
[10:30:53.820]   - Field: ‘calls’
[10:30:53.820]   - Field: ‘globals’
[10:30:53.820]   - Field: ‘stdout’
[10:30:53.821]   - Field: ‘earlySignal’
[10:30:53.821]   - Field: ‘lazy’
[10:30:53.821]   - Field: ‘state’
[10:30:53.821] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.821] - Launch lazy future ...
[10:30:53.821] Packages needed by the future expression (n = 0): <none>
[10:30:53.821] Packages needed by future strategies (n = 0): <none>
[10:30:53.824] {
[10:30:53.824]     {
[10:30:53.824]         {
[10:30:53.824]             ...future.startTime <- base::Sys.time()
[10:30:53.824]             {
[10:30:53.824]                 {
[10:30:53.824]                   {
[10:30:53.824]                     {
[10:30:53.824]                       base::local({
[10:30:53.824]                         has_future <- base::requireNamespace("future", 
[10:30:53.824]                           quietly = TRUE)
[10:30:53.824]                         if (has_future) {
[10:30:53.824]                           ns <- base::getNamespace("future")
[10:30:53.824]                           version <- ns[[".package"]][["version"]]
[10:30:53.824]                           if (is.null(version)) 
[10:30:53.824]                             version <- utils::packageVersion("future")
[10:30:53.824]                         }
[10:30:53.824]                         else {
[10:30:53.824]                           version <- NULL
[10:30:53.824]                         }
[10:30:53.824]                         if (!has_future || version < "1.8.0") {
[10:30:53.824]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.824]                             "", base::R.version$version.string), 
[10:30:53.824]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.824]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.824]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.824]                               "release", "version")], collapse = " "), 
[10:30:53.824]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.824]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.824]                             info)
[10:30:53.824]                           info <- base::paste(info, collapse = "; ")
[10:30:53.824]                           if (!has_future) {
[10:30:53.824]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.824]                               info)
[10:30:53.824]                           }
[10:30:53.824]                           else {
[10:30:53.824]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.824]                               info, version)
[10:30:53.824]                           }
[10:30:53.824]                           base::stop(msg)
[10:30:53.824]                         }
[10:30:53.824]                       })
[10:30:53.824]                     }
[10:30:53.824]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.824]                     base::options(mc.cores = 1L)
[10:30:53.824]                   }
[10:30:53.824]                   ...future.strategy.old <- future::plan("list")
[10:30:53.824]                   options(future.plan = NULL)
[10:30:53.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.824]                 }
[10:30:53.824]                 ...future.workdir <- getwd()
[10:30:53.824]             }
[10:30:53.824]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.824]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.824]         }
[10:30:53.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.824]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:30:53.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.824]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.824]             base::names(...future.oldOptions))
[10:30:53.824]     }
[10:30:53.824]     if (FALSE) {
[10:30:53.824]     }
[10:30:53.824]     else {
[10:30:53.824]         if (TRUE) {
[10:30:53.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.824]                 open = "w")
[10:30:53.824]         }
[10:30:53.824]         else {
[10:30:53.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.824]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.824]         }
[10:30:53.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.824]             base::sink(type = "output", split = FALSE)
[10:30:53.824]             base::close(...future.stdout)
[10:30:53.824]         }, add = TRUE)
[10:30:53.824]     }
[10:30:53.824]     ...future.frame <- base::sys.nframe()
[10:30:53.824]     ...future.conditions <- base::list()
[10:30:53.824]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.824]     if (FALSE) {
[10:30:53.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.824]     }
[10:30:53.824]     ...future.result <- base::tryCatch({
[10:30:53.824]         base::withCallingHandlers({
[10:30:53.824]             ...future.value <- base::withVisible(base::local({
[10:30:53.824]                 ...future.makeSendCondition <- base::local({
[10:30:53.824]                   sendCondition <- NULL
[10:30:53.824]                   function(frame = 1L) {
[10:30:53.824]                     if (is.function(sendCondition)) 
[10:30:53.824]                       return(sendCondition)
[10:30:53.824]                     ns <- getNamespace("parallel")
[10:30:53.824]                     if (exists("sendData", mode = "function", 
[10:30:53.824]                       envir = ns)) {
[10:30:53.824]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.824]                         envir = ns)
[10:30:53.824]                       envir <- sys.frame(frame)
[10:30:53.824]                       master <- NULL
[10:30:53.824]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.824]                         !identical(envir, emptyenv())) {
[10:30:53.824]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.824]                           inherits = FALSE)) {
[10:30:53.824]                           master <- get("master", mode = "list", 
[10:30:53.824]                             envir = envir, inherits = FALSE)
[10:30:53.824]                           if (inherits(master, c("SOCKnode", 
[10:30:53.824]                             "SOCK0node"))) {
[10:30:53.824]                             sendCondition <<- function(cond) {
[10:30:53.824]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.824]                                 success = TRUE)
[10:30:53.824]                               parallel_sendData(master, data)
[10:30:53.824]                             }
[10:30:53.824]                             return(sendCondition)
[10:30:53.824]                           }
[10:30:53.824]                         }
[10:30:53.824]                         frame <- frame + 1L
[10:30:53.824]                         envir <- sys.frame(frame)
[10:30:53.824]                       }
[10:30:53.824]                     }
[10:30:53.824]                     sendCondition <<- function(cond) NULL
[10:30:53.824]                   }
[10:30:53.824]                 })
[10:30:53.824]                 withCallingHandlers({
[10:30:53.824]                   {
[10:30:53.824]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.824]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.824]                       ...future.globals.maxSize)) {
[10:30:53.824]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.824]                       on.exit(options(oopts), add = TRUE)
[10:30:53.824]                     }
[10:30:53.824]                     {
[10:30:53.824]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.824]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.824]                         USE.NAMES = FALSE)
[10:30:53.824]                       do.call(mapply, args = args)
[10:30:53.824]                     }
[10:30:53.824]                   }
[10:30:53.824]                 }, immediateCondition = function(cond) {
[10:30:53.824]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.824]                   sendCondition(cond)
[10:30:53.824]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.824]                   {
[10:30:53.824]                     inherits <- base::inherits
[10:30:53.824]                     invokeRestart <- base::invokeRestart
[10:30:53.824]                     is.null <- base::is.null
[10:30:53.824]                     muffled <- FALSE
[10:30:53.824]                     if (inherits(cond, "message")) {
[10:30:53.824]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.824]                       if (muffled) 
[10:30:53.824]                         invokeRestart("muffleMessage")
[10:30:53.824]                     }
[10:30:53.824]                     else if (inherits(cond, "warning")) {
[10:30:53.824]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.824]                       if (muffled) 
[10:30:53.824]                         invokeRestart("muffleWarning")
[10:30:53.824]                     }
[10:30:53.824]                     else if (inherits(cond, "condition")) {
[10:30:53.824]                       if (!is.null(pattern)) {
[10:30:53.824]                         computeRestarts <- base::computeRestarts
[10:30:53.824]                         grepl <- base::grepl
[10:30:53.824]                         restarts <- computeRestarts(cond)
[10:30:53.824]                         for (restart in restarts) {
[10:30:53.824]                           name <- restart$name
[10:30:53.824]                           if (is.null(name)) 
[10:30:53.824]                             next
[10:30:53.824]                           if (!grepl(pattern, name)) 
[10:30:53.824]                             next
[10:30:53.824]                           invokeRestart(restart)
[10:30:53.824]                           muffled <- TRUE
[10:30:53.824]                           break
[10:30:53.824]                         }
[10:30:53.824]                       }
[10:30:53.824]                     }
[10:30:53.824]                     invisible(muffled)
[10:30:53.824]                   }
[10:30:53.824]                   muffleCondition(cond)
[10:30:53.824]                 })
[10:30:53.824]             }))
[10:30:53.824]             future::FutureResult(value = ...future.value$value, 
[10:30:53.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.824]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.824]                     ...future.globalenv.names))
[10:30:53.824]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.824]         }, condition = base::local({
[10:30:53.824]             c <- base::c
[10:30:53.824]             inherits <- base::inherits
[10:30:53.824]             invokeRestart <- base::invokeRestart
[10:30:53.824]             length <- base::length
[10:30:53.824]             list <- base::list
[10:30:53.824]             seq.int <- base::seq.int
[10:30:53.824]             signalCondition <- base::signalCondition
[10:30:53.824]             sys.calls <- base::sys.calls
[10:30:53.824]             `[[` <- base::`[[`
[10:30:53.824]             `+` <- base::`+`
[10:30:53.824]             `<<-` <- base::`<<-`
[10:30:53.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.824]                   3L)]
[10:30:53.824]             }
[10:30:53.824]             function(cond) {
[10:30:53.824]                 is_error <- inherits(cond, "error")
[10:30:53.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.824]                   NULL)
[10:30:53.824]                 if (is_error) {
[10:30:53.824]                   sessionInformation <- function() {
[10:30:53.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.824]                       search = base::search(), system = base::Sys.info())
[10:30:53.824]                   }
[10:30:53.824]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.824]                     cond$call), session = sessionInformation(), 
[10:30:53.824]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.824]                   signalCondition(cond)
[10:30:53.824]                 }
[10:30:53.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.824]                 "immediateCondition"))) {
[10:30:53.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.824]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.824]                   if (TRUE && !signal) {
[10:30:53.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.824]                     {
[10:30:53.824]                       inherits <- base::inherits
[10:30:53.824]                       invokeRestart <- base::invokeRestart
[10:30:53.824]                       is.null <- base::is.null
[10:30:53.824]                       muffled <- FALSE
[10:30:53.824]                       if (inherits(cond, "message")) {
[10:30:53.824]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.824]                         if (muffled) 
[10:30:53.824]                           invokeRestart("muffleMessage")
[10:30:53.824]                       }
[10:30:53.824]                       else if (inherits(cond, "warning")) {
[10:30:53.824]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.824]                         if (muffled) 
[10:30:53.824]                           invokeRestart("muffleWarning")
[10:30:53.824]                       }
[10:30:53.824]                       else if (inherits(cond, "condition")) {
[10:30:53.824]                         if (!is.null(pattern)) {
[10:30:53.824]                           computeRestarts <- base::computeRestarts
[10:30:53.824]                           grepl <- base::grepl
[10:30:53.824]                           restarts <- computeRestarts(cond)
[10:30:53.824]                           for (restart in restarts) {
[10:30:53.824]                             name <- restart$name
[10:30:53.824]                             if (is.null(name)) 
[10:30:53.824]                               next
[10:30:53.824]                             if (!grepl(pattern, name)) 
[10:30:53.824]                               next
[10:30:53.824]                             invokeRestart(restart)
[10:30:53.824]                             muffled <- TRUE
[10:30:53.824]                             break
[10:30:53.824]                           }
[10:30:53.824]                         }
[10:30:53.824]                       }
[10:30:53.824]                       invisible(muffled)
[10:30:53.824]                     }
[10:30:53.824]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.824]                   }
[10:30:53.824]                 }
[10:30:53.824]                 else {
[10:30:53.824]                   if (TRUE) {
[10:30:53.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.824]                     {
[10:30:53.824]                       inherits <- base::inherits
[10:30:53.824]                       invokeRestart <- base::invokeRestart
[10:30:53.824]                       is.null <- base::is.null
[10:30:53.824]                       muffled <- FALSE
[10:30:53.824]                       if (inherits(cond, "message")) {
[10:30:53.824]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.824]                         if (muffled) 
[10:30:53.824]                           invokeRestart("muffleMessage")
[10:30:53.824]                       }
[10:30:53.824]                       else if (inherits(cond, "warning")) {
[10:30:53.824]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.824]                         if (muffled) 
[10:30:53.824]                           invokeRestart("muffleWarning")
[10:30:53.824]                       }
[10:30:53.824]                       else if (inherits(cond, "condition")) {
[10:30:53.824]                         if (!is.null(pattern)) {
[10:30:53.824]                           computeRestarts <- base::computeRestarts
[10:30:53.824]                           grepl <- base::grepl
[10:30:53.824]                           restarts <- computeRestarts(cond)
[10:30:53.824]                           for (restart in restarts) {
[10:30:53.824]                             name <- restart$name
[10:30:53.824]                             if (is.null(name)) 
[10:30:53.824]                               next
[10:30:53.824]                             if (!grepl(pattern, name)) 
[10:30:53.824]                               next
[10:30:53.824]                             invokeRestart(restart)
[10:30:53.824]                             muffled <- TRUE
[10:30:53.824]                             break
[10:30:53.824]                           }
[10:30:53.824]                         }
[10:30:53.824]                       }
[10:30:53.824]                       invisible(muffled)
[10:30:53.824]                     }
[10:30:53.824]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.824]                   }
[10:30:53.824]                 }
[10:30:53.824]             }
[10:30:53.824]         }))
[10:30:53.824]     }, error = function(ex) {
[10:30:53.824]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.824]                 ...future.rng), started = ...future.startTime, 
[10:30:53.824]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.824]             version = "1.8"), class = "FutureResult")
[10:30:53.824]     }, finally = {
[10:30:53.824]         if (!identical(...future.workdir, getwd())) 
[10:30:53.824]             setwd(...future.workdir)
[10:30:53.824]         {
[10:30:53.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.824]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.824]             }
[10:30:53.824]             base::options(...future.oldOptions)
[10:30:53.824]             if (.Platform$OS.type == "windows") {
[10:30:53.824]                 old_names <- names(...future.oldEnvVars)
[10:30:53.824]                 envs <- base::Sys.getenv()
[10:30:53.824]                 names <- names(envs)
[10:30:53.824]                 common <- intersect(names, old_names)
[10:30:53.824]                 added <- setdiff(names, old_names)
[10:30:53.824]                 removed <- setdiff(old_names, names)
[10:30:53.824]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.824]                   envs[common]]
[10:30:53.824]                 NAMES <- toupper(changed)
[10:30:53.824]                 args <- list()
[10:30:53.824]                 for (kk in seq_along(NAMES)) {
[10:30:53.824]                   name <- changed[[kk]]
[10:30:53.824]                   NAME <- NAMES[[kk]]
[10:30:53.824]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.824]                     next
[10:30:53.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.824]                 }
[10:30:53.824]                 NAMES <- toupper(added)
[10:30:53.824]                 for (kk in seq_along(NAMES)) {
[10:30:53.824]                   name <- added[[kk]]
[10:30:53.824]                   NAME <- NAMES[[kk]]
[10:30:53.824]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.824]                     next
[10:30:53.824]                   args[[name]] <- ""
[10:30:53.824]                 }
[10:30:53.824]                 NAMES <- toupper(removed)
[10:30:53.824]                 for (kk in seq_along(NAMES)) {
[10:30:53.824]                   name <- removed[[kk]]
[10:30:53.824]                   NAME <- NAMES[[kk]]
[10:30:53.824]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.824]                     next
[10:30:53.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.824]                 }
[10:30:53.824]                 if (length(args) > 0) 
[10:30:53.824]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.824]             }
[10:30:53.824]             else {
[10:30:53.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.824]             }
[10:30:53.824]             {
[10:30:53.824]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.824]                   0L) {
[10:30:53.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.824]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.824]                   base::options(opts)
[10:30:53.824]                 }
[10:30:53.824]                 {
[10:30:53.824]                   {
[10:30:53.824]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.824]                     NULL
[10:30:53.824]                   }
[10:30:53.824]                   options(future.plan = NULL)
[10:30:53.824]                   if (is.na(NA_character_)) 
[10:30:53.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.824]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.824]                     .init = FALSE)
[10:30:53.824]                 }
[10:30:53.824]             }
[10:30:53.824]         }
[10:30:53.824]     })
[10:30:53.824]     if (TRUE) {
[10:30:53.824]         base::sink(type = "output", split = FALSE)
[10:30:53.824]         if (TRUE) {
[10:30:53.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.824]         }
[10:30:53.824]         else {
[10:30:53.824]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.824]         }
[10:30:53.824]         base::close(...future.stdout)
[10:30:53.824]         ...future.stdout <- NULL
[10:30:53.824]     }
[10:30:53.824]     ...future.result$conditions <- ...future.conditions
[10:30:53.824]     ...future.result$finished <- base::Sys.time()
[10:30:53.824]     ...future.result
[10:30:53.824] }
[10:30:53.827] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[10:30:53.827] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[10:30:53.827] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[10:30:53.827] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:53.828] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.828] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[10:30:53.828] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[10:30:53.828] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:53.828] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.829] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:53.829] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.829] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[10:30:53.829] MultisessionFuture started
[10:30:53.830] - Launch lazy future ... done
[10:30:53.830] run() for ‘MultisessionFuture’ ... done
[10:30:53.830] Created future:
[10:30:53.830] MultisessionFuture:
[10:30:53.830] Label: ‘future_mapply-1’
[10:30:53.830] Expression:
[10:30:53.830] {
[10:30:53.830]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.830]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.830]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.830]         on.exit(options(oopts), add = TRUE)
[10:30:53.830]     }
[10:30:53.830]     {
[10:30:53.830]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.830]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.830]         do.call(mapply, args = args)
[10:30:53.830]     }
[10:30:53.830] }
[10:30:53.830] Lazy evaluation: FALSE
[10:30:53.830] Asynchronous evaluation: TRUE
[10:30:53.830] Local evaluation: TRUE
[10:30:53.830] Environment: R_GlobalEnv
[10:30:53.830] Capture standard output: TRUE
[10:30:53.830] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.830] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.830] Packages: <none>
[10:30:53.830] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.830] Resolved: FALSE
[10:30:53.830] Value: <not collected>
[10:30:53.830] Conditions captured: <none>
[10:30:53.830] Early signaling: FALSE
[10:30:53.830] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.830] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.841] Chunk #1 of 3 ... DONE
[10:30:53.841] Chunk #2 of 3 ...
[10:30:53.842]  - Finding globals in '...' for chunk #2 ...
[10:30:53.842] getGlobalsAndPackages() ...
[10:30:53.842] Searching for globals...
[10:30:53.842] 
[10:30:53.842] Searching for globals ... DONE
[10:30:53.842] - globals: [0] <none>
[10:30:53.842] getGlobalsAndPackages() ... DONE
[10:30:53.842]    + additional globals found: [n=0] 
[10:30:53.842]    + additional namespaces needed: [n=0] 
[10:30:53.843]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:53.843]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:30:53.843]  - seeds: <none>
[10:30:53.843]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.843] getGlobalsAndPackages() ...
[10:30:53.843] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.843] Resolving globals: FALSE
[10:30:53.844] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[10:30:53.844] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:53.844] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.844] 
[10:30:53.844] getGlobalsAndPackages() ... DONE
[10:30:53.845] run() for ‘Future’ ...
[10:30:53.845] - state: ‘created’
[10:30:53.845] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.859] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.859] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.859]   - Field: ‘node’
[10:30:53.859]   - Field: ‘label’
[10:30:53.859]   - Field: ‘local’
[10:30:53.859]   - Field: ‘owner’
[10:30:53.859]   - Field: ‘envir’
[10:30:53.860]   - Field: ‘workers’
[10:30:53.860]   - Field: ‘packages’
[10:30:53.860]   - Field: ‘gc’
[10:30:53.860]   - Field: ‘conditions’
[10:30:53.860]   - Field: ‘persistent’
[10:30:53.860]   - Field: ‘expr’
[10:30:53.860]   - Field: ‘uuid’
[10:30:53.860]   - Field: ‘seed’
[10:30:53.860]   - Field: ‘version’
[10:30:53.860]   - Field: ‘result’
[10:30:53.860]   - Field: ‘asynchronous’
[10:30:53.861]   - Field: ‘calls’
[10:30:53.861]   - Field: ‘globals’
[10:30:53.861]   - Field: ‘stdout’
[10:30:53.861]   - Field: ‘earlySignal’
[10:30:53.861]   - Field: ‘lazy’
[10:30:53.861]   - Field: ‘state’
[10:30:53.861] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.861] - Launch lazy future ...
[10:30:53.861] Packages needed by the future expression (n = 0): <none>
[10:30:53.862] Packages needed by future strategies (n = 0): <none>
[10:30:53.862] {
[10:30:53.862]     {
[10:30:53.862]         {
[10:30:53.862]             ...future.startTime <- base::Sys.time()
[10:30:53.862]             {
[10:30:53.862]                 {
[10:30:53.862]                   {
[10:30:53.862]                     {
[10:30:53.862]                       base::local({
[10:30:53.862]                         has_future <- base::requireNamespace("future", 
[10:30:53.862]                           quietly = TRUE)
[10:30:53.862]                         if (has_future) {
[10:30:53.862]                           ns <- base::getNamespace("future")
[10:30:53.862]                           version <- ns[[".package"]][["version"]]
[10:30:53.862]                           if (is.null(version)) 
[10:30:53.862]                             version <- utils::packageVersion("future")
[10:30:53.862]                         }
[10:30:53.862]                         else {
[10:30:53.862]                           version <- NULL
[10:30:53.862]                         }
[10:30:53.862]                         if (!has_future || version < "1.8.0") {
[10:30:53.862]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.862]                             "", base::R.version$version.string), 
[10:30:53.862]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.862]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.862]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.862]                               "release", "version")], collapse = " "), 
[10:30:53.862]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.862]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.862]                             info)
[10:30:53.862]                           info <- base::paste(info, collapse = "; ")
[10:30:53.862]                           if (!has_future) {
[10:30:53.862]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.862]                               info)
[10:30:53.862]                           }
[10:30:53.862]                           else {
[10:30:53.862]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.862]                               info, version)
[10:30:53.862]                           }
[10:30:53.862]                           base::stop(msg)
[10:30:53.862]                         }
[10:30:53.862]                       })
[10:30:53.862]                     }
[10:30:53.862]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.862]                     base::options(mc.cores = 1L)
[10:30:53.862]                   }
[10:30:53.862]                   ...future.strategy.old <- future::plan("list")
[10:30:53.862]                   options(future.plan = NULL)
[10:30:53.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.862]                 }
[10:30:53.862]                 ...future.workdir <- getwd()
[10:30:53.862]             }
[10:30:53.862]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.862]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.862]         }
[10:30:53.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.862]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:30:53.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.862]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.862]             base::names(...future.oldOptions))
[10:30:53.862]     }
[10:30:53.862]     if (FALSE) {
[10:30:53.862]     }
[10:30:53.862]     else {
[10:30:53.862]         if (TRUE) {
[10:30:53.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.862]                 open = "w")
[10:30:53.862]         }
[10:30:53.862]         else {
[10:30:53.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.862]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.862]         }
[10:30:53.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.862]             base::sink(type = "output", split = FALSE)
[10:30:53.862]             base::close(...future.stdout)
[10:30:53.862]         }, add = TRUE)
[10:30:53.862]     }
[10:30:53.862]     ...future.frame <- base::sys.nframe()
[10:30:53.862]     ...future.conditions <- base::list()
[10:30:53.862]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.862]     if (FALSE) {
[10:30:53.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.862]     }
[10:30:53.862]     ...future.result <- base::tryCatch({
[10:30:53.862]         base::withCallingHandlers({
[10:30:53.862]             ...future.value <- base::withVisible(base::local({
[10:30:53.862]                 ...future.makeSendCondition <- base::local({
[10:30:53.862]                   sendCondition <- NULL
[10:30:53.862]                   function(frame = 1L) {
[10:30:53.862]                     if (is.function(sendCondition)) 
[10:30:53.862]                       return(sendCondition)
[10:30:53.862]                     ns <- getNamespace("parallel")
[10:30:53.862]                     if (exists("sendData", mode = "function", 
[10:30:53.862]                       envir = ns)) {
[10:30:53.862]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.862]                         envir = ns)
[10:30:53.862]                       envir <- sys.frame(frame)
[10:30:53.862]                       master <- NULL
[10:30:53.862]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.862]                         !identical(envir, emptyenv())) {
[10:30:53.862]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.862]                           inherits = FALSE)) {
[10:30:53.862]                           master <- get("master", mode = "list", 
[10:30:53.862]                             envir = envir, inherits = FALSE)
[10:30:53.862]                           if (inherits(master, c("SOCKnode", 
[10:30:53.862]                             "SOCK0node"))) {
[10:30:53.862]                             sendCondition <<- function(cond) {
[10:30:53.862]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.862]                                 success = TRUE)
[10:30:53.862]                               parallel_sendData(master, data)
[10:30:53.862]                             }
[10:30:53.862]                             return(sendCondition)
[10:30:53.862]                           }
[10:30:53.862]                         }
[10:30:53.862]                         frame <- frame + 1L
[10:30:53.862]                         envir <- sys.frame(frame)
[10:30:53.862]                       }
[10:30:53.862]                     }
[10:30:53.862]                     sendCondition <<- function(cond) NULL
[10:30:53.862]                   }
[10:30:53.862]                 })
[10:30:53.862]                 withCallingHandlers({
[10:30:53.862]                   {
[10:30:53.862]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.862]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.862]                       ...future.globals.maxSize)) {
[10:30:53.862]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.862]                       on.exit(options(oopts), add = TRUE)
[10:30:53.862]                     }
[10:30:53.862]                     {
[10:30:53.862]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.862]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.862]                         USE.NAMES = FALSE)
[10:30:53.862]                       do.call(mapply, args = args)
[10:30:53.862]                     }
[10:30:53.862]                   }
[10:30:53.862]                 }, immediateCondition = function(cond) {
[10:30:53.862]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.862]                   sendCondition(cond)
[10:30:53.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.862]                   {
[10:30:53.862]                     inherits <- base::inherits
[10:30:53.862]                     invokeRestart <- base::invokeRestart
[10:30:53.862]                     is.null <- base::is.null
[10:30:53.862]                     muffled <- FALSE
[10:30:53.862]                     if (inherits(cond, "message")) {
[10:30:53.862]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.862]                       if (muffled) 
[10:30:53.862]                         invokeRestart("muffleMessage")
[10:30:53.862]                     }
[10:30:53.862]                     else if (inherits(cond, "warning")) {
[10:30:53.862]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.862]                       if (muffled) 
[10:30:53.862]                         invokeRestart("muffleWarning")
[10:30:53.862]                     }
[10:30:53.862]                     else if (inherits(cond, "condition")) {
[10:30:53.862]                       if (!is.null(pattern)) {
[10:30:53.862]                         computeRestarts <- base::computeRestarts
[10:30:53.862]                         grepl <- base::grepl
[10:30:53.862]                         restarts <- computeRestarts(cond)
[10:30:53.862]                         for (restart in restarts) {
[10:30:53.862]                           name <- restart$name
[10:30:53.862]                           if (is.null(name)) 
[10:30:53.862]                             next
[10:30:53.862]                           if (!grepl(pattern, name)) 
[10:30:53.862]                             next
[10:30:53.862]                           invokeRestart(restart)
[10:30:53.862]                           muffled <- TRUE
[10:30:53.862]                           break
[10:30:53.862]                         }
[10:30:53.862]                       }
[10:30:53.862]                     }
[10:30:53.862]                     invisible(muffled)
[10:30:53.862]                   }
[10:30:53.862]                   muffleCondition(cond)
[10:30:53.862]                 })
[10:30:53.862]             }))
[10:30:53.862]             future::FutureResult(value = ...future.value$value, 
[10:30:53.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.862]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.862]                     ...future.globalenv.names))
[10:30:53.862]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.862]         }, condition = base::local({
[10:30:53.862]             c <- base::c
[10:30:53.862]             inherits <- base::inherits
[10:30:53.862]             invokeRestart <- base::invokeRestart
[10:30:53.862]             length <- base::length
[10:30:53.862]             list <- base::list
[10:30:53.862]             seq.int <- base::seq.int
[10:30:53.862]             signalCondition <- base::signalCondition
[10:30:53.862]             sys.calls <- base::sys.calls
[10:30:53.862]             `[[` <- base::`[[`
[10:30:53.862]             `+` <- base::`+`
[10:30:53.862]             `<<-` <- base::`<<-`
[10:30:53.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.862]                   3L)]
[10:30:53.862]             }
[10:30:53.862]             function(cond) {
[10:30:53.862]                 is_error <- inherits(cond, "error")
[10:30:53.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.862]                   NULL)
[10:30:53.862]                 if (is_error) {
[10:30:53.862]                   sessionInformation <- function() {
[10:30:53.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.862]                       search = base::search(), system = base::Sys.info())
[10:30:53.862]                   }
[10:30:53.862]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.862]                     cond$call), session = sessionInformation(), 
[10:30:53.862]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.862]                   signalCondition(cond)
[10:30:53.862]                 }
[10:30:53.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.862]                 "immediateCondition"))) {
[10:30:53.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.862]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.862]                   if (TRUE && !signal) {
[10:30:53.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.862]                     {
[10:30:53.862]                       inherits <- base::inherits
[10:30:53.862]                       invokeRestart <- base::invokeRestart
[10:30:53.862]                       is.null <- base::is.null
[10:30:53.862]                       muffled <- FALSE
[10:30:53.862]                       if (inherits(cond, "message")) {
[10:30:53.862]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.862]                         if (muffled) 
[10:30:53.862]                           invokeRestart("muffleMessage")
[10:30:53.862]                       }
[10:30:53.862]                       else if (inherits(cond, "warning")) {
[10:30:53.862]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.862]                         if (muffled) 
[10:30:53.862]                           invokeRestart("muffleWarning")
[10:30:53.862]                       }
[10:30:53.862]                       else if (inherits(cond, "condition")) {
[10:30:53.862]                         if (!is.null(pattern)) {
[10:30:53.862]                           computeRestarts <- base::computeRestarts
[10:30:53.862]                           grepl <- base::grepl
[10:30:53.862]                           restarts <- computeRestarts(cond)
[10:30:53.862]                           for (restart in restarts) {
[10:30:53.862]                             name <- restart$name
[10:30:53.862]                             if (is.null(name)) 
[10:30:53.862]                               next
[10:30:53.862]                             if (!grepl(pattern, name)) 
[10:30:53.862]                               next
[10:30:53.862]                             invokeRestart(restart)
[10:30:53.862]                             muffled <- TRUE
[10:30:53.862]                             break
[10:30:53.862]                           }
[10:30:53.862]                         }
[10:30:53.862]                       }
[10:30:53.862]                       invisible(muffled)
[10:30:53.862]                     }
[10:30:53.862]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.862]                   }
[10:30:53.862]                 }
[10:30:53.862]                 else {
[10:30:53.862]                   if (TRUE) {
[10:30:53.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.862]                     {
[10:30:53.862]                       inherits <- base::inherits
[10:30:53.862]                       invokeRestart <- base::invokeRestart
[10:30:53.862]                       is.null <- base::is.null
[10:30:53.862]                       muffled <- FALSE
[10:30:53.862]                       if (inherits(cond, "message")) {
[10:30:53.862]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.862]                         if (muffled) 
[10:30:53.862]                           invokeRestart("muffleMessage")
[10:30:53.862]                       }
[10:30:53.862]                       else if (inherits(cond, "warning")) {
[10:30:53.862]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.862]                         if (muffled) 
[10:30:53.862]                           invokeRestart("muffleWarning")
[10:30:53.862]                       }
[10:30:53.862]                       else if (inherits(cond, "condition")) {
[10:30:53.862]                         if (!is.null(pattern)) {
[10:30:53.862]                           computeRestarts <- base::computeRestarts
[10:30:53.862]                           grepl <- base::grepl
[10:30:53.862]                           restarts <- computeRestarts(cond)
[10:30:53.862]                           for (restart in restarts) {
[10:30:53.862]                             name <- restart$name
[10:30:53.862]                             if (is.null(name)) 
[10:30:53.862]                               next
[10:30:53.862]                             if (!grepl(pattern, name)) 
[10:30:53.862]                               next
[10:30:53.862]                             invokeRestart(restart)
[10:30:53.862]                             muffled <- TRUE
[10:30:53.862]                             break
[10:30:53.862]                           }
[10:30:53.862]                         }
[10:30:53.862]                       }
[10:30:53.862]                       invisible(muffled)
[10:30:53.862]                     }
[10:30:53.862]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.862]                   }
[10:30:53.862]                 }
[10:30:53.862]             }
[10:30:53.862]         }))
[10:30:53.862]     }, error = function(ex) {
[10:30:53.862]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.862]                 ...future.rng), started = ...future.startTime, 
[10:30:53.862]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.862]             version = "1.8"), class = "FutureResult")
[10:30:53.862]     }, finally = {
[10:30:53.862]         if (!identical(...future.workdir, getwd())) 
[10:30:53.862]             setwd(...future.workdir)
[10:30:53.862]         {
[10:30:53.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.862]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.862]             }
[10:30:53.862]             base::options(...future.oldOptions)
[10:30:53.862]             if (.Platform$OS.type == "windows") {
[10:30:53.862]                 old_names <- names(...future.oldEnvVars)
[10:30:53.862]                 envs <- base::Sys.getenv()
[10:30:53.862]                 names <- names(envs)
[10:30:53.862]                 common <- intersect(names, old_names)
[10:30:53.862]                 added <- setdiff(names, old_names)
[10:30:53.862]                 removed <- setdiff(old_names, names)
[10:30:53.862]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.862]                   envs[common]]
[10:30:53.862]                 NAMES <- toupper(changed)
[10:30:53.862]                 args <- list()
[10:30:53.862]                 for (kk in seq_along(NAMES)) {
[10:30:53.862]                   name <- changed[[kk]]
[10:30:53.862]                   NAME <- NAMES[[kk]]
[10:30:53.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.862]                     next
[10:30:53.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.862]                 }
[10:30:53.862]                 NAMES <- toupper(added)
[10:30:53.862]                 for (kk in seq_along(NAMES)) {
[10:30:53.862]                   name <- added[[kk]]
[10:30:53.862]                   NAME <- NAMES[[kk]]
[10:30:53.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.862]                     next
[10:30:53.862]                   args[[name]] <- ""
[10:30:53.862]                 }
[10:30:53.862]                 NAMES <- toupper(removed)
[10:30:53.862]                 for (kk in seq_along(NAMES)) {
[10:30:53.862]                   name <- removed[[kk]]
[10:30:53.862]                   NAME <- NAMES[[kk]]
[10:30:53.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.862]                     next
[10:30:53.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.862]                 }
[10:30:53.862]                 if (length(args) > 0) 
[10:30:53.862]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.862]             }
[10:30:53.862]             else {
[10:30:53.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.862]             }
[10:30:53.862]             {
[10:30:53.862]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.862]                   0L) {
[10:30:53.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.862]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.862]                   base::options(opts)
[10:30:53.862]                 }
[10:30:53.862]                 {
[10:30:53.862]                   {
[10:30:53.862]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.862]                     NULL
[10:30:53.862]                   }
[10:30:53.862]                   options(future.plan = NULL)
[10:30:53.862]                   if (is.na(NA_character_)) 
[10:30:53.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.862]                     .init = FALSE)
[10:30:53.862]                 }
[10:30:53.862]             }
[10:30:53.862]         }
[10:30:53.862]     })
[10:30:53.862]     if (TRUE) {
[10:30:53.862]         base::sink(type = "output", split = FALSE)
[10:30:53.862]         if (TRUE) {
[10:30:53.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.862]         }
[10:30:53.862]         else {
[10:30:53.862]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.862]         }
[10:30:53.862]         base::close(...future.stdout)
[10:30:53.862]         ...future.stdout <- NULL
[10:30:53.862]     }
[10:30:53.862]     ...future.result$conditions <- ...future.conditions
[10:30:53.862]     ...future.result$finished <- base::Sys.time()
[10:30:53.862]     ...future.result
[10:30:53.862] }
[10:30:53.865] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[10:30:53.865] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[10:30:53.865] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[10:30:53.866] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:53.866] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.866] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[10:30:53.866] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[10:30:53.866] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:53.867] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.867] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:53.867] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:53.867] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[10:30:53.868] MultisessionFuture started
[10:30:53.868] - Launch lazy future ... done
[10:30:53.868] run() for ‘MultisessionFuture’ ... done
[10:30:53.868] Created future:
[10:30:53.868] MultisessionFuture:
[10:30:53.868] Label: ‘future_mapply-2’
[10:30:53.868] Expression:
[10:30:53.868] {
[10:30:53.868]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.868]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.868]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.868]         on.exit(options(oopts), add = TRUE)
[10:30:53.868]     }
[10:30:53.868]     {
[10:30:53.868]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.868]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.868]         do.call(mapply, args = args)
[10:30:53.868]     }
[10:30:53.868] }
[10:30:53.868] Lazy evaluation: FALSE
[10:30:53.868] Asynchronous evaluation: TRUE
[10:30:53.868] Local evaluation: TRUE
[10:30:53.868] Environment: R_GlobalEnv
[10:30:53.868] Capture standard output: TRUE
[10:30:53.868] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.868] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.868] Packages: <none>
[10:30:53.868] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.868] Resolved: FALSE
[10:30:53.868] Value: <not collected>
[10:30:53.868] Conditions captured: <none>
[10:30:53.868] Early signaling: FALSE
[10:30:53.868] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.868] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.880] Chunk #2 of 3 ... DONE
[10:30:53.880] Chunk #3 of 3 ...
[10:30:53.880]  - Finding globals in '...' for chunk #3 ...
[10:30:53.880] getGlobalsAndPackages() ...
[10:30:53.880] Searching for globals...
[10:30:53.881] 
[10:30:53.881] Searching for globals ... DONE
[10:30:53.881] - globals: [0] <none>
[10:30:53.881] getGlobalsAndPackages() ... DONE
[10:30:53.881]    + additional globals found: [n=0] 
[10:30:53.881]    + additional namespaces needed: [n=0] 
[10:30:53.881]  - Finding globals in '...' for chunk #3 ... DONE
[10:30:53.881]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:30:53.881]  - seeds: <none>
[10:30:53.881]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.881] getGlobalsAndPackages() ...
[10:30:53.882] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.882] Resolving globals: FALSE
[10:30:53.882] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:53.883] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:53.883] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.883] 
[10:30:53.883] getGlobalsAndPackages() ... DONE
[10:30:53.883] run() for ‘Future’ ...
[10:30:53.883] - state: ‘created’
[10:30:53.884] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.898] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.898]   - Field: ‘node’
[10:30:53.898]   - Field: ‘label’
[10:30:53.898]   - Field: ‘local’
[10:30:53.898]   - Field: ‘owner’
[10:30:53.898]   - Field: ‘envir’
[10:30:53.899]   - Field: ‘workers’
[10:30:53.899]   - Field: ‘packages’
[10:30:53.899]   - Field: ‘gc’
[10:30:53.899]   - Field: ‘conditions’
[10:30:53.899]   - Field: ‘persistent’
[10:30:53.899]   - Field: ‘expr’
[10:30:53.899]   - Field: ‘uuid’
[10:30:53.899]   - Field: ‘seed’
[10:30:53.899]   - Field: ‘version’
[10:30:53.899]   - Field: ‘result’
[10:30:53.899]   - Field: ‘asynchronous’
[10:30:53.900]   - Field: ‘calls’
[10:30:53.900]   - Field: ‘globals’
[10:30:53.900]   - Field: ‘stdout’
[10:30:53.900]   - Field: ‘earlySignal’
[10:30:53.900]   - Field: ‘lazy’
[10:30:53.900]   - Field: ‘state’
[10:30:53.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:53.900] - Launch lazy future ...
[10:30:53.900] Packages needed by the future expression (n = 0): <none>
[10:30:53.901] Packages needed by future strategies (n = 0): <none>
[10:30:53.901] {
[10:30:53.901]     {
[10:30:53.901]         {
[10:30:53.901]             ...future.startTime <- base::Sys.time()
[10:30:53.901]             {
[10:30:53.901]                 {
[10:30:53.901]                   {
[10:30:53.901]                     {
[10:30:53.901]                       base::local({
[10:30:53.901]                         has_future <- base::requireNamespace("future", 
[10:30:53.901]                           quietly = TRUE)
[10:30:53.901]                         if (has_future) {
[10:30:53.901]                           ns <- base::getNamespace("future")
[10:30:53.901]                           version <- ns[[".package"]][["version"]]
[10:30:53.901]                           if (is.null(version)) 
[10:30:53.901]                             version <- utils::packageVersion("future")
[10:30:53.901]                         }
[10:30:53.901]                         else {
[10:30:53.901]                           version <- NULL
[10:30:53.901]                         }
[10:30:53.901]                         if (!has_future || version < "1.8.0") {
[10:30:53.901]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:53.901]                             "", base::R.version$version.string), 
[10:30:53.901]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:53.901]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:53.901]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:53.901]                               "release", "version")], collapse = " "), 
[10:30:53.901]                             hostname = base::Sys.info()[["nodename"]])
[10:30:53.901]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:53.901]                             info)
[10:30:53.901]                           info <- base::paste(info, collapse = "; ")
[10:30:53.901]                           if (!has_future) {
[10:30:53.901]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:53.901]                               info)
[10:30:53.901]                           }
[10:30:53.901]                           else {
[10:30:53.901]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:53.901]                               info, version)
[10:30:53.901]                           }
[10:30:53.901]                           base::stop(msg)
[10:30:53.901]                         }
[10:30:53.901]                       })
[10:30:53.901]                     }
[10:30:53.901]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:53.901]                     base::options(mc.cores = 1L)
[10:30:53.901]                   }
[10:30:53.901]                   ...future.strategy.old <- future::plan("list")
[10:30:53.901]                   options(future.plan = NULL)
[10:30:53.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:53.901]                 }
[10:30:53.901]                 ...future.workdir <- getwd()
[10:30:53.901]             }
[10:30:53.901]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:53.901]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:53.901]         }
[10:30:53.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:53.901]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:30:53.901]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:53.901]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:53.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:53.901]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:53.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:53.901]             base::names(...future.oldOptions))
[10:30:53.901]     }
[10:30:53.901]     if (FALSE) {
[10:30:53.901]     }
[10:30:53.901]     else {
[10:30:53.901]         if (TRUE) {
[10:30:53.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:53.901]                 open = "w")
[10:30:53.901]         }
[10:30:53.901]         else {
[10:30:53.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:53.901]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:53.901]         }
[10:30:53.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:53.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:53.901]             base::sink(type = "output", split = FALSE)
[10:30:53.901]             base::close(...future.stdout)
[10:30:53.901]         }, add = TRUE)
[10:30:53.901]     }
[10:30:53.901]     ...future.frame <- base::sys.nframe()
[10:30:53.901]     ...future.conditions <- base::list()
[10:30:53.901]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:53.901]     if (FALSE) {
[10:30:53.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:53.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:53.901]     }
[10:30:53.901]     ...future.result <- base::tryCatch({
[10:30:53.901]         base::withCallingHandlers({
[10:30:53.901]             ...future.value <- base::withVisible(base::local({
[10:30:53.901]                 ...future.makeSendCondition <- base::local({
[10:30:53.901]                   sendCondition <- NULL
[10:30:53.901]                   function(frame = 1L) {
[10:30:53.901]                     if (is.function(sendCondition)) 
[10:30:53.901]                       return(sendCondition)
[10:30:53.901]                     ns <- getNamespace("parallel")
[10:30:53.901]                     if (exists("sendData", mode = "function", 
[10:30:53.901]                       envir = ns)) {
[10:30:53.901]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:53.901]                         envir = ns)
[10:30:53.901]                       envir <- sys.frame(frame)
[10:30:53.901]                       master <- NULL
[10:30:53.901]                       while (!identical(envir, .GlobalEnv) && 
[10:30:53.901]                         !identical(envir, emptyenv())) {
[10:30:53.901]                         if (exists("master", mode = "list", envir = envir, 
[10:30:53.901]                           inherits = FALSE)) {
[10:30:53.901]                           master <- get("master", mode = "list", 
[10:30:53.901]                             envir = envir, inherits = FALSE)
[10:30:53.901]                           if (inherits(master, c("SOCKnode", 
[10:30:53.901]                             "SOCK0node"))) {
[10:30:53.901]                             sendCondition <<- function(cond) {
[10:30:53.901]                               data <- list(type = "VALUE", value = cond, 
[10:30:53.901]                                 success = TRUE)
[10:30:53.901]                               parallel_sendData(master, data)
[10:30:53.901]                             }
[10:30:53.901]                             return(sendCondition)
[10:30:53.901]                           }
[10:30:53.901]                         }
[10:30:53.901]                         frame <- frame + 1L
[10:30:53.901]                         envir <- sys.frame(frame)
[10:30:53.901]                       }
[10:30:53.901]                     }
[10:30:53.901]                     sendCondition <<- function(cond) NULL
[10:30:53.901]                   }
[10:30:53.901]                 })
[10:30:53.901]                 withCallingHandlers({
[10:30:53.901]                   {
[10:30:53.901]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.901]                     if (!identical(...future.globals.maxSize.org, 
[10:30:53.901]                       ...future.globals.maxSize)) {
[10:30:53.901]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.901]                       on.exit(options(oopts), add = TRUE)
[10:30:53.901]                     }
[10:30:53.901]                     {
[10:30:53.901]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.901]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:53.901]                         USE.NAMES = FALSE)
[10:30:53.901]                       do.call(mapply, args = args)
[10:30:53.901]                     }
[10:30:53.901]                   }
[10:30:53.901]                 }, immediateCondition = function(cond) {
[10:30:53.901]                   sendCondition <- ...future.makeSendCondition()
[10:30:53.901]                   sendCondition(cond)
[10:30:53.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.901]                   {
[10:30:53.901]                     inherits <- base::inherits
[10:30:53.901]                     invokeRestart <- base::invokeRestart
[10:30:53.901]                     is.null <- base::is.null
[10:30:53.901]                     muffled <- FALSE
[10:30:53.901]                     if (inherits(cond, "message")) {
[10:30:53.901]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:53.901]                       if (muffled) 
[10:30:53.901]                         invokeRestart("muffleMessage")
[10:30:53.901]                     }
[10:30:53.901]                     else if (inherits(cond, "warning")) {
[10:30:53.901]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:53.901]                       if (muffled) 
[10:30:53.901]                         invokeRestart("muffleWarning")
[10:30:53.901]                     }
[10:30:53.901]                     else if (inherits(cond, "condition")) {
[10:30:53.901]                       if (!is.null(pattern)) {
[10:30:53.901]                         computeRestarts <- base::computeRestarts
[10:30:53.901]                         grepl <- base::grepl
[10:30:53.901]                         restarts <- computeRestarts(cond)
[10:30:53.901]                         for (restart in restarts) {
[10:30:53.901]                           name <- restart$name
[10:30:53.901]                           if (is.null(name)) 
[10:30:53.901]                             next
[10:30:53.901]                           if (!grepl(pattern, name)) 
[10:30:53.901]                             next
[10:30:53.901]                           invokeRestart(restart)
[10:30:53.901]                           muffled <- TRUE
[10:30:53.901]                           break
[10:30:53.901]                         }
[10:30:53.901]                       }
[10:30:53.901]                     }
[10:30:53.901]                     invisible(muffled)
[10:30:53.901]                   }
[10:30:53.901]                   muffleCondition(cond)
[10:30:53.901]                 })
[10:30:53.901]             }))
[10:30:53.901]             future::FutureResult(value = ...future.value$value, 
[10:30:53.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.901]                   ...future.rng), globalenv = if (FALSE) 
[10:30:53.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:53.901]                     ...future.globalenv.names))
[10:30:53.901]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:53.901]         }, condition = base::local({
[10:30:53.901]             c <- base::c
[10:30:53.901]             inherits <- base::inherits
[10:30:53.901]             invokeRestart <- base::invokeRestart
[10:30:53.901]             length <- base::length
[10:30:53.901]             list <- base::list
[10:30:53.901]             seq.int <- base::seq.int
[10:30:53.901]             signalCondition <- base::signalCondition
[10:30:53.901]             sys.calls <- base::sys.calls
[10:30:53.901]             `[[` <- base::`[[`
[10:30:53.901]             `+` <- base::`+`
[10:30:53.901]             `<<-` <- base::`<<-`
[10:30:53.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:53.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:53.901]                   3L)]
[10:30:53.901]             }
[10:30:53.901]             function(cond) {
[10:30:53.901]                 is_error <- inherits(cond, "error")
[10:30:53.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:53.901]                   NULL)
[10:30:53.901]                 if (is_error) {
[10:30:53.901]                   sessionInformation <- function() {
[10:30:53.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:53.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:53.901]                       search = base::search(), system = base::Sys.info())
[10:30:53.901]                   }
[10:30:53.901]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:53.901]                     cond$call), session = sessionInformation(), 
[10:30:53.901]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:53.901]                   signalCondition(cond)
[10:30:53.901]                 }
[10:30:53.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:53.901]                 "immediateCondition"))) {
[10:30:53.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:53.901]                   ...future.conditions[[length(...future.conditions) + 
[10:30:53.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:53.901]                   if (TRUE && !signal) {
[10:30:53.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.901]                     {
[10:30:53.901]                       inherits <- base::inherits
[10:30:53.901]                       invokeRestart <- base::invokeRestart
[10:30:53.901]                       is.null <- base::is.null
[10:30:53.901]                       muffled <- FALSE
[10:30:53.901]                       if (inherits(cond, "message")) {
[10:30:53.901]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.901]                         if (muffled) 
[10:30:53.901]                           invokeRestart("muffleMessage")
[10:30:53.901]                       }
[10:30:53.901]                       else if (inherits(cond, "warning")) {
[10:30:53.901]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.901]                         if (muffled) 
[10:30:53.901]                           invokeRestart("muffleWarning")
[10:30:53.901]                       }
[10:30:53.901]                       else if (inherits(cond, "condition")) {
[10:30:53.901]                         if (!is.null(pattern)) {
[10:30:53.901]                           computeRestarts <- base::computeRestarts
[10:30:53.901]                           grepl <- base::grepl
[10:30:53.901]                           restarts <- computeRestarts(cond)
[10:30:53.901]                           for (restart in restarts) {
[10:30:53.901]                             name <- restart$name
[10:30:53.901]                             if (is.null(name)) 
[10:30:53.901]                               next
[10:30:53.901]                             if (!grepl(pattern, name)) 
[10:30:53.901]                               next
[10:30:53.901]                             invokeRestart(restart)
[10:30:53.901]                             muffled <- TRUE
[10:30:53.901]                             break
[10:30:53.901]                           }
[10:30:53.901]                         }
[10:30:53.901]                       }
[10:30:53.901]                       invisible(muffled)
[10:30:53.901]                     }
[10:30:53.901]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.901]                   }
[10:30:53.901]                 }
[10:30:53.901]                 else {
[10:30:53.901]                   if (TRUE) {
[10:30:53.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:53.901]                     {
[10:30:53.901]                       inherits <- base::inherits
[10:30:53.901]                       invokeRestart <- base::invokeRestart
[10:30:53.901]                       is.null <- base::is.null
[10:30:53.901]                       muffled <- FALSE
[10:30:53.901]                       if (inherits(cond, "message")) {
[10:30:53.901]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:53.901]                         if (muffled) 
[10:30:53.901]                           invokeRestart("muffleMessage")
[10:30:53.901]                       }
[10:30:53.901]                       else if (inherits(cond, "warning")) {
[10:30:53.901]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:53.901]                         if (muffled) 
[10:30:53.901]                           invokeRestart("muffleWarning")
[10:30:53.901]                       }
[10:30:53.901]                       else if (inherits(cond, "condition")) {
[10:30:53.901]                         if (!is.null(pattern)) {
[10:30:53.901]                           computeRestarts <- base::computeRestarts
[10:30:53.901]                           grepl <- base::grepl
[10:30:53.901]                           restarts <- computeRestarts(cond)
[10:30:53.901]                           for (restart in restarts) {
[10:30:53.901]                             name <- restart$name
[10:30:53.901]                             if (is.null(name)) 
[10:30:53.901]                               next
[10:30:53.901]                             if (!grepl(pattern, name)) 
[10:30:53.901]                               next
[10:30:53.901]                             invokeRestart(restart)
[10:30:53.901]                             muffled <- TRUE
[10:30:53.901]                             break
[10:30:53.901]                           }
[10:30:53.901]                         }
[10:30:53.901]                       }
[10:30:53.901]                       invisible(muffled)
[10:30:53.901]                     }
[10:30:53.901]                     muffleCondition(cond, pattern = "^muffle")
[10:30:53.901]                   }
[10:30:53.901]                 }
[10:30:53.901]             }
[10:30:53.901]         }))
[10:30:53.901]     }, error = function(ex) {
[10:30:53.901]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:53.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:53.901]                 ...future.rng), started = ...future.startTime, 
[10:30:53.901]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:53.901]             version = "1.8"), class = "FutureResult")
[10:30:53.901]     }, finally = {
[10:30:53.901]         if (!identical(...future.workdir, getwd())) 
[10:30:53.901]             setwd(...future.workdir)
[10:30:53.901]         {
[10:30:53.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:53.901]                 ...future.oldOptions$nwarnings <- NULL
[10:30:53.901]             }
[10:30:53.901]             base::options(...future.oldOptions)
[10:30:53.901]             if (.Platform$OS.type == "windows") {
[10:30:53.901]                 old_names <- names(...future.oldEnvVars)
[10:30:53.901]                 envs <- base::Sys.getenv()
[10:30:53.901]                 names <- names(envs)
[10:30:53.901]                 common <- intersect(names, old_names)
[10:30:53.901]                 added <- setdiff(names, old_names)
[10:30:53.901]                 removed <- setdiff(old_names, names)
[10:30:53.901]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:53.901]                   envs[common]]
[10:30:53.901]                 NAMES <- toupper(changed)
[10:30:53.901]                 args <- list()
[10:30:53.901]                 for (kk in seq_along(NAMES)) {
[10:30:53.901]                   name <- changed[[kk]]
[10:30:53.901]                   NAME <- NAMES[[kk]]
[10:30:53.901]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.901]                     next
[10:30:53.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.901]                 }
[10:30:53.901]                 NAMES <- toupper(added)
[10:30:53.901]                 for (kk in seq_along(NAMES)) {
[10:30:53.901]                   name <- added[[kk]]
[10:30:53.901]                   NAME <- NAMES[[kk]]
[10:30:53.901]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.901]                     next
[10:30:53.901]                   args[[name]] <- ""
[10:30:53.901]                 }
[10:30:53.901]                 NAMES <- toupper(removed)
[10:30:53.901]                 for (kk in seq_along(NAMES)) {
[10:30:53.901]                   name <- removed[[kk]]
[10:30:53.901]                   NAME <- NAMES[[kk]]
[10:30:53.901]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:53.901]                     next
[10:30:53.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:53.901]                 }
[10:30:53.901]                 if (length(args) > 0) 
[10:30:53.901]                   base::do.call(base::Sys.setenv, args = args)
[10:30:53.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:53.901]             }
[10:30:53.901]             else {
[10:30:53.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:53.901]             }
[10:30:53.901]             {
[10:30:53.901]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:53.901]                   0L) {
[10:30:53.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:53.901]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:53.901]                   base::options(opts)
[10:30:53.901]                 }
[10:30:53.901]                 {
[10:30:53.901]                   {
[10:30:53.901]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:53.901]                     NULL
[10:30:53.901]                   }
[10:30:53.901]                   options(future.plan = NULL)
[10:30:53.901]                   if (is.na(NA_character_)) 
[10:30:53.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:53.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:53.901]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:53.901]                     .init = FALSE)
[10:30:53.901]                 }
[10:30:53.901]             }
[10:30:53.901]         }
[10:30:53.901]     })
[10:30:53.901]     if (TRUE) {
[10:30:53.901]         base::sink(type = "output", split = FALSE)
[10:30:53.901]         if (TRUE) {
[10:30:53.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:53.901]         }
[10:30:53.901]         else {
[10:30:53.901]             ...future.result["stdout"] <- base::list(NULL)
[10:30:53.901]         }
[10:30:53.901]         base::close(...future.stdout)
[10:30:53.901]         ...future.stdout <- NULL
[10:30:53.901]     }
[10:30:53.901]     ...future.result$conditions <- ...future.conditions
[10:30:53.901]     ...future.result$finished <- base::Sys.time()
[10:30:53.901]     ...future.result
[10:30:53.901] }
[10:30:53.903] Poll #1 (0): usedNodes() = 2, workers = 2
[10:30:53.914] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.914] - Validating connection of MultisessionFuture
[10:30:53.915] - received message: FutureResult
[10:30:53.915] - Received FutureResult
[10:30:53.915] - Erased future from FutureRegistry
[10:30:53.915] result() for ClusterFuture ...
[10:30:53.915] - result already collected: FutureResult
[10:30:53.915] result() for ClusterFuture ... done
[10:30:53.915] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.916] result() for ClusterFuture ...
[10:30:53.916] - result already collected: FutureResult
[10:30:53.916] result() for ClusterFuture ... done
[10:30:53.916] result() for ClusterFuture ...
[10:30:53.916] - result already collected: FutureResult
[10:30:53.916] result() for ClusterFuture ... done
[10:30:53.917] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[10:30:53.917] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[10:30:53.917] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[10:30:53.917] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:53.918] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.918] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[10:30:53.918] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[10:30:53.919] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:53.919] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.919] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:53.919] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:53.920] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[10:30:53.920] MultisessionFuture started
[10:30:53.920] - Launch lazy future ... done
[10:30:53.920] run() for ‘MultisessionFuture’ ... done
[10:30:53.921] Created future:
[10:30:53.921] MultisessionFuture:
[10:30:53.921] Label: ‘future_mapply-3’
[10:30:53.921] Expression:
[10:30:53.921] {
[10:30:53.921]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:53.921]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:53.921]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:53.921]         on.exit(options(oopts), add = TRUE)
[10:30:53.921]     }
[10:30:53.921]     {
[10:30:53.921]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:53.921]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:53.921]         do.call(mapply, args = args)
[10:30:53.921]     }
[10:30:53.921] }
[10:30:53.921] Lazy evaluation: FALSE
[10:30:53.921] Asynchronous evaluation: TRUE
[10:30:53.921] Local evaluation: TRUE
[10:30:53.921] Environment: R_GlobalEnv
[10:30:53.921] Capture standard output: TRUE
[10:30:53.921] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:53.921] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:53.921] Packages: <none>
[10:30:53.921] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:53.921] Resolved: FALSE
[10:30:53.921] Value: <not collected>
[10:30:53.921] Conditions captured: <none>
[10:30:53.921] Early signaling: FALSE
[10:30:53.921] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:53.921] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.932] Chunk #3 of 3 ... DONE
[10:30:53.932] Launching 3 futures (chunks) ... DONE
[10:30:53.932] Resolving 3 futures (chunks) ...
[10:30:53.933] resolve() on list ...
[10:30:53.933]  recursive: 0
[10:30:53.933]  length: 3
[10:30:53.933] 
[10:30:53.933] Future #1
[10:30:53.933] result() for ClusterFuture ...
[10:30:53.933] - result already collected: FutureResult
[10:30:53.933] result() for ClusterFuture ... done
[10:30:53.933] result() for ClusterFuture ...
[10:30:53.934] - result already collected: FutureResult
[10:30:53.934] result() for ClusterFuture ... done
[10:30:53.934] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:53.934] - nx: 3
[10:30:53.934] - relay: TRUE
[10:30:53.934] - stdout: TRUE
[10:30:53.934] - signal: TRUE
[10:30:53.934] - resignal: FALSE
[10:30:53.934] - force: TRUE
[10:30:53.934] - relayed: [n=3] FALSE, FALSE, FALSE
[10:30:53.934] - queued futures: [n=3] FALSE, FALSE, FALSE
[10:30:53.934]  - until=1
[10:30:53.935]  - relaying element #1
[10:30:53.935] result() for ClusterFuture ...
[10:30:53.935] - result already collected: FutureResult
[10:30:53.935] result() for ClusterFuture ... done
[10:30:53.935] result() for ClusterFuture ...
[10:30:53.935] - result already collected: FutureResult
[10:30:53.935] result() for ClusterFuture ... done
[10:30:53.935] result() for ClusterFuture ...
[10:30:53.935] - result already collected: FutureResult
[10:30:53.935] result() for ClusterFuture ... done
[10:30:53.935] result() for ClusterFuture ...
[10:30:53.936] - result already collected: FutureResult
[10:30:53.936] result() for ClusterFuture ... done
[10:30:53.936] - relayed: [n=3] TRUE, FALSE, FALSE
[10:30:53.936] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:30:53.936] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:53.936]  length: 2 (resolved future 1)
[10:30:53.936] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.937] - Validating connection of MultisessionFuture
[10:30:53.937] - received message: FutureResult
[10:30:53.937] - Received FutureResult
[10:30:53.937] - Erased future from FutureRegistry
[10:30:53.937] result() for ClusterFuture ...
[10:30:53.937] - result already collected: FutureResult
[10:30:53.937] result() for ClusterFuture ... done
[10:30:53.937] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.937] Future #2
[10:30:53.937] result() for ClusterFuture ...
[10:30:53.938] - result already collected: FutureResult
[10:30:53.938] result() for ClusterFuture ... done
[10:30:53.938] result() for ClusterFuture ...
[10:30:53.938] - result already collected: FutureResult
[10:30:53.938] result() for ClusterFuture ... done
[10:30:53.938] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:53.938] - nx: 3
[10:30:53.938] - relay: TRUE
[10:30:53.938] - stdout: TRUE
[10:30:53.938] - signal: TRUE
[10:30:53.938] - resignal: FALSE
[10:30:53.938] - force: TRUE
[10:30:53.939] - relayed: [n=3] TRUE, FALSE, FALSE
[10:30:53.939] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:30:53.939]  - until=2
[10:30:53.939]  - relaying element #2
[10:30:53.939] result() for ClusterFuture ...
[10:30:53.939] - result already collected: FutureResult
[10:30:53.939] result() for ClusterFuture ... done
[10:30:53.939] result() for ClusterFuture ...
[10:30:53.939] - result already collected: FutureResult
[10:30:53.939] result() for ClusterFuture ... done
[10:30:53.939] result() for ClusterFuture ...
[10:30:53.940] - result already collected: FutureResult
[10:30:53.940] result() for ClusterFuture ... done
[10:30:53.940] result() for ClusterFuture ...
[10:30:53.940] - result already collected: FutureResult
[10:30:53.940] result() for ClusterFuture ... done
[10:30:53.940] - relayed: [n=3] TRUE, TRUE, FALSE
[10:30:53.940] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:30:53.940] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:53.940]  length: 1 (resolved future 2)
[10:30:53.963] receiveMessageFromWorker() for ClusterFuture ...
[10:30:53.963] - Validating connection of MultisessionFuture
[10:30:53.963] - received message: FutureResult
[10:30:53.963] - Received FutureResult
[10:30:53.963] - Erased future from FutureRegistry
[10:30:53.963] result() for ClusterFuture ...
[10:30:53.963] - result already collected: FutureResult
[10:30:53.964] result() for ClusterFuture ... done
[10:30:53.964] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:53.964] Future #3
[10:30:53.964] result() for ClusterFuture ...
[10:30:53.964] - result already collected: FutureResult
[10:30:53.964] result() for ClusterFuture ... done
[10:30:53.964] result() for ClusterFuture ...
[10:30:53.964] - result already collected: FutureResult
[10:30:53.964] result() for ClusterFuture ... done
[10:30:53.964] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:30:53.964] - nx: 3
[10:30:53.965] - relay: TRUE
[10:30:53.965] - stdout: TRUE
[10:30:53.965] - signal: TRUE
[10:30:53.965] - resignal: FALSE
[10:30:53.965] - force: TRUE
[10:30:53.965] - relayed: [n=3] TRUE, TRUE, FALSE
[10:30:53.965] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:30:53.965]  - until=3
[10:30:53.965]  - relaying element #3
[10:30:53.965] result() for ClusterFuture ...
[10:30:53.965] - result already collected: FutureResult
[10:30:53.966] result() for ClusterFuture ... done
[10:30:53.966] result() for ClusterFuture ...
[10:30:53.966] - result already collected: FutureResult
[10:30:53.966] result() for ClusterFuture ... done
[10:30:53.966] result() for ClusterFuture ...
[10:30:53.966] - result already collected: FutureResult
[10:30:53.966] result() for ClusterFuture ... done
[10:30:53.966] result() for ClusterFuture ...
[10:30:53.966] - result already collected: FutureResult
[10:30:53.966] result() for ClusterFuture ... done
[10:30:53.966] - relayed: [n=3] TRUE, TRUE, TRUE
[10:30:53.966] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:30:53.967] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:30:53.967]  length: 0 (resolved future 3)
[10:30:53.967] Relaying remaining futures
[10:30:53.967] signalConditionsASAP(NULL, pos=0) ...
[10:30:53.967] - nx: 3
[10:30:53.967] - relay: TRUE
[10:30:53.967] - stdout: TRUE
[10:30:53.967] - signal: TRUE
[10:30:53.967] - resignal: FALSE
[10:30:53.967] - force: TRUE
[10:30:53.967] - relayed: [n=3] TRUE, TRUE, TRUE
[10:30:53.967] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[10:30:53.968] - relayed: [n=3] TRUE, TRUE, TRUE
[10:30:53.968] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:30:53.968] signalConditionsASAP(NULL, pos=0) ... done
[10:30:53.968] resolve() on list ... DONE
[10:30:53.968] result() for ClusterFuture ...
[10:30:53.968] - result already collected: FutureResult
[10:30:53.968] result() for ClusterFuture ... done
[10:30:53.968] result() for ClusterFuture ...
[10:30:53.968] - result already collected: FutureResult
[10:30:53.968] result() for ClusterFuture ... done
[10:30:53.969] result() for ClusterFuture ...
[10:30:53.969] - result already collected: FutureResult
[10:30:53.969] result() for ClusterFuture ... done
[10:30:53.969] result() for ClusterFuture ...
[10:30:53.969] - result already collected: FutureResult
[10:30:53.969] result() for ClusterFuture ... done
[10:30:53.969] result() for ClusterFuture ...
[10:30:53.969] - result already collected: FutureResult
[10:30:53.969] result() for ClusterFuture ... done
[10:30:53.969] result() for ClusterFuture ...
[10:30:53.969] - result already collected: FutureResult
[10:30:53.969] result() for ClusterFuture ... done
[10:30:53.970]  - Number of value chunks collected: 3
[10:30:53.970] Resolving 3 futures (chunks) ... DONE
[10:30:53.970] Reducing values from 3 chunks ...
[10:30:53.970]  - Number of values collected after concatenation: 5
[10:30:53.970]  - Number of values expected: 5
[10:30:53.970] Reverse index remapping (attribute 'ordering'): [n = 5] 4, 3, 2, 5, 1
[10:30:53.970] Reducing values from 3 chunks ... DONE
[10:30:53.970] future_mapply() ... DONE
[10:30:53.971] future_mapply() ...
[10:30:53.974] Number of chunks: 2
[10:30:53.974] getGlobalsAndPackagesXApply() ...
[10:30:53.975]  - future.globals: TRUE
[10:30:53.975] getGlobalsAndPackages() ...
[10:30:53.975] Searching for globals...
[10:30:53.976] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:53.976] Searching for globals ... DONE
[10:30:53.976] Resolving globals: FALSE
[10:30:53.977] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:53.977] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:53.977] - globals: [1] ‘FUN’
[10:30:53.977] 
[10:30:53.977] getGlobalsAndPackages() ... DONE
[10:30:53.977]  - globals found/used: [n=1] ‘FUN’
[10:30:53.977]  - needed namespaces: [n=0] 
[10:30:53.978] Finding globals ... DONE
[10:30:53.978] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:53.978] List of 2
[10:30:53.978]  $ ...future.FUN:function (C, k)  
[10:30:53.978]  $ MoreArgs     : list()
[10:30:53.978]  - attr(*, "where")=List of 2
[10:30:53.978]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:53.978]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:53.978]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:53.978]  - attr(*, "resolved")= logi FALSE
[10:30:53.978]  - attr(*, "total_size")= num NA
[10:30:53.980] Packages to be attached in all futures: [n=0] 
[10:30:53.980] getGlobalsAndPackagesXApply() ... DONE
[10:30:53.981] Number of futures (= number of chunks): 2
[10:30:53.981] Launching 2 futures (chunks) ...
[10:30:53.981] Chunk #1 of 2 ...
[10:30:53.981]  - Finding globals in '...' for chunk #1 ...
[10:30:53.981] getGlobalsAndPackages() ...
[10:30:53.981] Searching for globals...
[10:30:53.982] 
[10:30:53.982] Searching for globals ... DONE
[10:30:53.982] - globals: [0] <none>
[10:30:53.982] getGlobalsAndPackages() ... DONE
[10:30:53.982]    + additional globals found: [n=0] 
[10:30:53.982]    + additional namespaces needed: [n=0] 
[10:30:53.982]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:53.982]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:53.982]  - seeds: <none>
[10:30:53.982]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.982] getGlobalsAndPackages() ...
[10:30:53.983] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.983] Resolving globals: FALSE
[10:30:53.983] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:53.984] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:53.984] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:53.984] 
[10:30:53.984] getGlobalsAndPackages() ... DONE
[10:30:53.984] run() for ‘Future’ ...
[10:30:53.984] - state: ‘created’
[10:30:53.984] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:53.999] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:53.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:53.999]   - Field: ‘node’
[10:30:53.999]   - Field: ‘label’
[10:30:53.999]   - Field: ‘local’
[10:30:53.999]   - Field: ‘owner’
[10:30:53.999]   - Field: ‘envir’
[10:30:54.000]   - Field: ‘workers’
[10:30:54.000]   - Field: ‘packages’
[10:30:54.000]   - Field: ‘gc’
[10:30:54.000]   - Field: ‘conditions’
[10:30:54.000]   - Field: ‘persistent’
[10:30:54.000]   - Field: ‘expr’
[10:30:54.000]   - Field: ‘uuid’
[10:30:54.000]   - Field: ‘seed’
[10:30:54.000]   - Field: ‘version’
[10:30:54.000]   - Field: ‘result’
[10:30:54.000]   - Field: ‘asynchronous’
[10:30:54.001]   - Field: ‘calls’
[10:30:54.001]   - Field: ‘globals’
[10:30:54.001]   - Field: ‘stdout’
[10:30:54.001]   - Field: ‘earlySignal’
[10:30:54.001]   - Field: ‘lazy’
[10:30:54.001]   - Field: ‘state’
[10:30:54.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.001] - Launch lazy future ...
[10:30:54.002] Packages needed by the future expression (n = 0): <none>
[10:30:54.002] Packages needed by future strategies (n = 0): <none>
[10:30:54.002] {
[10:30:54.002]     {
[10:30:54.002]         {
[10:30:54.002]             ...future.startTime <- base::Sys.time()
[10:30:54.002]             {
[10:30:54.002]                 {
[10:30:54.002]                   {
[10:30:54.002]                     {
[10:30:54.002]                       base::local({
[10:30:54.002]                         has_future <- base::requireNamespace("future", 
[10:30:54.002]                           quietly = TRUE)
[10:30:54.002]                         if (has_future) {
[10:30:54.002]                           ns <- base::getNamespace("future")
[10:30:54.002]                           version <- ns[[".package"]][["version"]]
[10:30:54.002]                           if (is.null(version)) 
[10:30:54.002]                             version <- utils::packageVersion("future")
[10:30:54.002]                         }
[10:30:54.002]                         else {
[10:30:54.002]                           version <- NULL
[10:30:54.002]                         }
[10:30:54.002]                         if (!has_future || version < "1.8.0") {
[10:30:54.002]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.002]                             "", base::R.version$version.string), 
[10:30:54.002]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.002]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.002]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.002]                               "release", "version")], collapse = " "), 
[10:30:54.002]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.002]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.002]                             info)
[10:30:54.002]                           info <- base::paste(info, collapse = "; ")
[10:30:54.002]                           if (!has_future) {
[10:30:54.002]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.002]                               info)
[10:30:54.002]                           }
[10:30:54.002]                           else {
[10:30:54.002]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.002]                               info, version)
[10:30:54.002]                           }
[10:30:54.002]                           base::stop(msg)
[10:30:54.002]                         }
[10:30:54.002]                       })
[10:30:54.002]                     }
[10:30:54.002]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.002]                     base::options(mc.cores = 1L)
[10:30:54.002]                   }
[10:30:54.002]                   ...future.strategy.old <- future::plan("list")
[10:30:54.002]                   options(future.plan = NULL)
[10:30:54.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.002]                 }
[10:30:54.002]                 ...future.workdir <- getwd()
[10:30:54.002]             }
[10:30:54.002]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.002]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.002]         }
[10:30:54.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.002]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.002]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.002]             base::names(...future.oldOptions))
[10:30:54.002]     }
[10:30:54.002]     if (FALSE) {
[10:30:54.002]     }
[10:30:54.002]     else {
[10:30:54.002]         if (TRUE) {
[10:30:54.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.002]                 open = "w")
[10:30:54.002]         }
[10:30:54.002]         else {
[10:30:54.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.002]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.002]         }
[10:30:54.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.002]             base::sink(type = "output", split = FALSE)
[10:30:54.002]             base::close(...future.stdout)
[10:30:54.002]         }, add = TRUE)
[10:30:54.002]     }
[10:30:54.002]     ...future.frame <- base::sys.nframe()
[10:30:54.002]     ...future.conditions <- base::list()
[10:30:54.002]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.002]     if (FALSE) {
[10:30:54.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.002]     }
[10:30:54.002]     ...future.result <- base::tryCatch({
[10:30:54.002]         base::withCallingHandlers({
[10:30:54.002]             ...future.value <- base::withVisible(base::local({
[10:30:54.002]                 ...future.makeSendCondition <- base::local({
[10:30:54.002]                   sendCondition <- NULL
[10:30:54.002]                   function(frame = 1L) {
[10:30:54.002]                     if (is.function(sendCondition)) 
[10:30:54.002]                       return(sendCondition)
[10:30:54.002]                     ns <- getNamespace("parallel")
[10:30:54.002]                     if (exists("sendData", mode = "function", 
[10:30:54.002]                       envir = ns)) {
[10:30:54.002]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.002]                         envir = ns)
[10:30:54.002]                       envir <- sys.frame(frame)
[10:30:54.002]                       master <- NULL
[10:30:54.002]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.002]                         !identical(envir, emptyenv())) {
[10:30:54.002]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.002]                           inherits = FALSE)) {
[10:30:54.002]                           master <- get("master", mode = "list", 
[10:30:54.002]                             envir = envir, inherits = FALSE)
[10:30:54.002]                           if (inherits(master, c("SOCKnode", 
[10:30:54.002]                             "SOCK0node"))) {
[10:30:54.002]                             sendCondition <<- function(cond) {
[10:30:54.002]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.002]                                 success = TRUE)
[10:30:54.002]                               parallel_sendData(master, data)
[10:30:54.002]                             }
[10:30:54.002]                             return(sendCondition)
[10:30:54.002]                           }
[10:30:54.002]                         }
[10:30:54.002]                         frame <- frame + 1L
[10:30:54.002]                         envir <- sys.frame(frame)
[10:30:54.002]                       }
[10:30:54.002]                     }
[10:30:54.002]                     sendCondition <<- function(cond) NULL
[10:30:54.002]                   }
[10:30:54.002]                 })
[10:30:54.002]                 withCallingHandlers({
[10:30:54.002]                   {
[10:30:54.002]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.002]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.002]                       ...future.globals.maxSize)) {
[10:30:54.002]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.002]                       on.exit(options(oopts), add = TRUE)
[10:30:54.002]                     }
[10:30:54.002]                     {
[10:30:54.002]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.002]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.002]                         USE.NAMES = FALSE)
[10:30:54.002]                       do.call(mapply, args = args)
[10:30:54.002]                     }
[10:30:54.002]                   }
[10:30:54.002]                 }, immediateCondition = function(cond) {
[10:30:54.002]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.002]                   sendCondition(cond)
[10:30:54.002]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.002]                   {
[10:30:54.002]                     inherits <- base::inherits
[10:30:54.002]                     invokeRestart <- base::invokeRestart
[10:30:54.002]                     is.null <- base::is.null
[10:30:54.002]                     muffled <- FALSE
[10:30:54.002]                     if (inherits(cond, "message")) {
[10:30:54.002]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.002]                       if (muffled) 
[10:30:54.002]                         invokeRestart("muffleMessage")
[10:30:54.002]                     }
[10:30:54.002]                     else if (inherits(cond, "warning")) {
[10:30:54.002]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.002]                       if (muffled) 
[10:30:54.002]                         invokeRestart("muffleWarning")
[10:30:54.002]                     }
[10:30:54.002]                     else if (inherits(cond, "condition")) {
[10:30:54.002]                       if (!is.null(pattern)) {
[10:30:54.002]                         computeRestarts <- base::computeRestarts
[10:30:54.002]                         grepl <- base::grepl
[10:30:54.002]                         restarts <- computeRestarts(cond)
[10:30:54.002]                         for (restart in restarts) {
[10:30:54.002]                           name <- restart$name
[10:30:54.002]                           if (is.null(name)) 
[10:30:54.002]                             next
[10:30:54.002]                           if (!grepl(pattern, name)) 
[10:30:54.002]                             next
[10:30:54.002]                           invokeRestart(restart)
[10:30:54.002]                           muffled <- TRUE
[10:30:54.002]                           break
[10:30:54.002]                         }
[10:30:54.002]                       }
[10:30:54.002]                     }
[10:30:54.002]                     invisible(muffled)
[10:30:54.002]                   }
[10:30:54.002]                   muffleCondition(cond)
[10:30:54.002]                 })
[10:30:54.002]             }))
[10:30:54.002]             future::FutureResult(value = ...future.value$value, 
[10:30:54.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.002]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.002]                     ...future.globalenv.names))
[10:30:54.002]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.002]         }, condition = base::local({
[10:30:54.002]             c <- base::c
[10:30:54.002]             inherits <- base::inherits
[10:30:54.002]             invokeRestart <- base::invokeRestart
[10:30:54.002]             length <- base::length
[10:30:54.002]             list <- base::list
[10:30:54.002]             seq.int <- base::seq.int
[10:30:54.002]             signalCondition <- base::signalCondition
[10:30:54.002]             sys.calls <- base::sys.calls
[10:30:54.002]             `[[` <- base::`[[`
[10:30:54.002]             `+` <- base::`+`
[10:30:54.002]             `<<-` <- base::`<<-`
[10:30:54.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.002]                   3L)]
[10:30:54.002]             }
[10:30:54.002]             function(cond) {
[10:30:54.002]                 is_error <- inherits(cond, "error")
[10:30:54.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.002]                   NULL)
[10:30:54.002]                 if (is_error) {
[10:30:54.002]                   sessionInformation <- function() {
[10:30:54.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.002]                       search = base::search(), system = base::Sys.info())
[10:30:54.002]                   }
[10:30:54.002]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.002]                     cond$call), session = sessionInformation(), 
[10:30:54.002]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.002]                   signalCondition(cond)
[10:30:54.002]                 }
[10:30:54.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.002]                 "immediateCondition"))) {
[10:30:54.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.002]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.002]                   if (TRUE && !signal) {
[10:30:54.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.002]                     {
[10:30:54.002]                       inherits <- base::inherits
[10:30:54.002]                       invokeRestart <- base::invokeRestart
[10:30:54.002]                       is.null <- base::is.null
[10:30:54.002]                       muffled <- FALSE
[10:30:54.002]                       if (inherits(cond, "message")) {
[10:30:54.002]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.002]                         if (muffled) 
[10:30:54.002]                           invokeRestart("muffleMessage")
[10:30:54.002]                       }
[10:30:54.002]                       else if (inherits(cond, "warning")) {
[10:30:54.002]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.002]                         if (muffled) 
[10:30:54.002]                           invokeRestart("muffleWarning")
[10:30:54.002]                       }
[10:30:54.002]                       else if (inherits(cond, "condition")) {
[10:30:54.002]                         if (!is.null(pattern)) {
[10:30:54.002]                           computeRestarts <- base::computeRestarts
[10:30:54.002]                           grepl <- base::grepl
[10:30:54.002]                           restarts <- computeRestarts(cond)
[10:30:54.002]                           for (restart in restarts) {
[10:30:54.002]                             name <- restart$name
[10:30:54.002]                             if (is.null(name)) 
[10:30:54.002]                               next
[10:30:54.002]                             if (!grepl(pattern, name)) 
[10:30:54.002]                               next
[10:30:54.002]                             invokeRestart(restart)
[10:30:54.002]                             muffled <- TRUE
[10:30:54.002]                             break
[10:30:54.002]                           }
[10:30:54.002]                         }
[10:30:54.002]                       }
[10:30:54.002]                       invisible(muffled)
[10:30:54.002]                     }
[10:30:54.002]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.002]                   }
[10:30:54.002]                 }
[10:30:54.002]                 else {
[10:30:54.002]                   if (TRUE) {
[10:30:54.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.002]                     {
[10:30:54.002]                       inherits <- base::inherits
[10:30:54.002]                       invokeRestart <- base::invokeRestart
[10:30:54.002]                       is.null <- base::is.null
[10:30:54.002]                       muffled <- FALSE
[10:30:54.002]                       if (inherits(cond, "message")) {
[10:30:54.002]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.002]                         if (muffled) 
[10:30:54.002]                           invokeRestart("muffleMessage")
[10:30:54.002]                       }
[10:30:54.002]                       else if (inherits(cond, "warning")) {
[10:30:54.002]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.002]                         if (muffled) 
[10:30:54.002]                           invokeRestart("muffleWarning")
[10:30:54.002]                       }
[10:30:54.002]                       else if (inherits(cond, "condition")) {
[10:30:54.002]                         if (!is.null(pattern)) {
[10:30:54.002]                           computeRestarts <- base::computeRestarts
[10:30:54.002]                           grepl <- base::grepl
[10:30:54.002]                           restarts <- computeRestarts(cond)
[10:30:54.002]                           for (restart in restarts) {
[10:30:54.002]                             name <- restart$name
[10:30:54.002]                             if (is.null(name)) 
[10:30:54.002]                               next
[10:30:54.002]                             if (!grepl(pattern, name)) 
[10:30:54.002]                               next
[10:30:54.002]                             invokeRestart(restart)
[10:30:54.002]                             muffled <- TRUE
[10:30:54.002]                             break
[10:30:54.002]                           }
[10:30:54.002]                         }
[10:30:54.002]                       }
[10:30:54.002]                       invisible(muffled)
[10:30:54.002]                     }
[10:30:54.002]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.002]                   }
[10:30:54.002]                 }
[10:30:54.002]             }
[10:30:54.002]         }))
[10:30:54.002]     }, error = function(ex) {
[10:30:54.002]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.002]                 ...future.rng), started = ...future.startTime, 
[10:30:54.002]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.002]             version = "1.8"), class = "FutureResult")
[10:30:54.002]     }, finally = {
[10:30:54.002]         if (!identical(...future.workdir, getwd())) 
[10:30:54.002]             setwd(...future.workdir)
[10:30:54.002]         {
[10:30:54.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.002]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.002]             }
[10:30:54.002]             base::options(...future.oldOptions)
[10:30:54.002]             if (.Platform$OS.type == "windows") {
[10:30:54.002]                 old_names <- names(...future.oldEnvVars)
[10:30:54.002]                 envs <- base::Sys.getenv()
[10:30:54.002]                 names <- names(envs)
[10:30:54.002]                 common <- intersect(names, old_names)
[10:30:54.002]                 added <- setdiff(names, old_names)
[10:30:54.002]                 removed <- setdiff(old_names, names)
[10:30:54.002]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.002]                   envs[common]]
[10:30:54.002]                 NAMES <- toupper(changed)
[10:30:54.002]                 args <- list()
[10:30:54.002]                 for (kk in seq_along(NAMES)) {
[10:30:54.002]                   name <- changed[[kk]]
[10:30:54.002]                   NAME <- NAMES[[kk]]
[10:30:54.002]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.002]                     next
[10:30:54.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.002]                 }
[10:30:54.002]                 NAMES <- toupper(added)
[10:30:54.002]                 for (kk in seq_along(NAMES)) {
[10:30:54.002]                   name <- added[[kk]]
[10:30:54.002]                   NAME <- NAMES[[kk]]
[10:30:54.002]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.002]                     next
[10:30:54.002]                   args[[name]] <- ""
[10:30:54.002]                 }
[10:30:54.002]                 NAMES <- toupper(removed)
[10:30:54.002]                 for (kk in seq_along(NAMES)) {
[10:30:54.002]                   name <- removed[[kk]]
[10:30:54.002]                   NAME <- NAMES[[kk]]
[10:30:54.002]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.002]                     next
[10:30:54.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.002]                 }
[10:30:54.002]                 if (length(args) > 0) 
[10:30:54.002]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.002]             }
[10:30:54.002]             else {
[10:30:54.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.002]             }
[10:30:54.002]             {
[10:30:54.002]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.002]                   0L) {
[10:30:54.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.002]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.002]                   base::options(opts)
[10:30:54.002]                 }
[10:30:54.002]                 {
[10:30:54.002]                   {
[10:30:54.002]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.002]                     NULL
[10:30:54.002]                   }
[10:30:54.002]                   options(future.plan = NULL)
[10:30:54.002]                   if (is.na(NA_character_)) 
[10:30:54.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.002]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.002]                     .init = FALSE)
[10:30:54.002]                 }
[10:30:54.002]             }
[10:30:54.002]         }
[10:30:54.002]     })
[10:30:54.002]     if (TRUE) {
[10:30:54.002]         base::sink(type = "output", split = FALSE)
[10:30:54.002]         if (TRUE) {
[10:30:54.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.002]         }
[10:30:54.002]         else {
[10:30:54.002]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.002]         }
[10:30:54.002]         base::close(...future.stdout)
[10:30:54.002]         ...future.stdout <- NULL
[10:30:54.002]     }
[10:30:54.002]     ...future.result$conditions <- ...future.conditions
[10:30:54.002]     ...future.result$finished <- base::Sys.time()
[10:30:54.002]     ...future.result
[10:30:54.002] }
[10:30:54.005] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[10:30:54.008] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[10:30:54.008] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[10:30:54.008] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:54.008] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.009] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[10:30:54.009] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[10:30:54.009] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:54.009] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.010] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:54.010] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.010] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[10:30:54.010] MultisessionFuture started
[10:30:54.010] - Launch lazy future ... done
[10:30:54.011] run() for ‘MultisessionFuture’ ... done
[10:30:54.011] Created future:
[10:30:54.011] MultisessionFuture:
[10:30:54.011] Label: ‘future_.mapply-1’
[10:30:54.011] Expression:
[10:30:54.011] {
[10:30:54.011]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.011]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.011]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.011]         on.exit(options(oopts), add = TRUE)
[10:30:54.011]     }
[10:30:54.011]     {
[10:30:54.011]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.011]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.011]         do.call(mapply, args = args)
[10:30:54.011]     }
[10:30:54.011] }
[10:30:54.011] Lazy evaluation: FALSE
[10:30:54.011] Asynchronous evaluation: TRUE
[10:30:54.011] Local evaluation: TRUE
[10:30:54.011] Environment: R_GlobalEnv
[10:30:54.011] Capture standard output: TRUE
[10:30:54.011] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.011] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.011] Packages: <none>
[10:30:54.011] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.011] Resolved: FALSE
[10:30:54.011] Value: <not collected>
[10:30:54.011] Conditions captured: <none>
[10:30:54.011] Early signaling: FALSE
[10:30:54.011] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.011] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.022] Chunk #1 of 2 ... DONE
[10:30:54.022] Chunk #2 of 2 ...
[10:30:54.022]  - Finding globals in '...' for chunk #2 ...
[10:30:54.022] getGlobalsAndPackages() ...
[10:30:54.023] Searching for globals...
[10:30:54.023] 
[10:30:54.023] Searching for globals ... DONE
[10:30:54.023] - globals: [0] <none>
[10:30:54.023] getGlobalsAndPackages() ... DONE
[10:30:54.023]    + additional globals found: [n=0] 
[10:30:54.023]    + additional namespaces needed: [n=0] 
[10:30:54.023]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:54.024]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.024]  - seeds: <none>
[10:30:54.024]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.024] getGlobalsAndPackages() ...
[10:30:54.024] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.024] Resolving globals: FALSE
[10:30:54.024] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[10:30:54.025] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:54.025] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.025] 
[10:30:54.025] getGlobalsAndPackages() ... DONE
[10:30:54.026] run() for ‘Future’ ...
[10:30:54.026] - state: ‘created’
[10:30:54.026] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.039] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.040] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.040]   - Field: ‘node’
[10:30:54.040]   - Field: ‘label’
[10:30:54.040]   - Field: ‘local’
[10:30:54.040]   - Field: ‘owner’
[10:30:54.040]   - Field: ‘envir’
[10:30:54.040]   - Field: ‘workers’
[10:30:54.040]   - Field: ‘packages’
[10:30:54.040]   - Field: ‘gc’
[10:30:54.040]   - Field: ‘conditions’
[10:30:54.041]   - Field: ‘persistent’
[10:30:54.041]   - Field: ‘expr’
[10:30:54.041]   - Field: ‘uuid’
[10:30:54.041]   - Field: ‘seed’
[10:30:54.041]   - Field: ‘version’
[10:30:54.041]   - Field: ‘result’
[10:30:54.041]   - Field: ‘asynchronous’
[10:30:54.041]   - Field: ‘calls’
[10:30:54.041]   - Field: ‘globals’
[10:30:54.041]   - Field: ‘stdout’
[10:30:54.041]   - Field: ‘earlySignal’
[10:30:54.042]   - Field: ‘lazy’
[10:30:54.042]   - Field: ‘state’
[10:30:54.042] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.042] - Launch lazy future ...
[10:30:54.042] Packages needed by the future expression (n = 0): <none>
[10:30:54.042] Packages needed by future strategies (n = 0): <none>
[10:30:54.043] {
[10:30:54.043]     {
[10:30:54.043]         {
[10:30:54.043]             ...future.startTime <- base::Sys.time()
[10:30:54.043]             {
[10:30:54.043]                 {
[10:30:54.043]                   {
[10:30:54.043]                     {
[10:30:54.043]                       base::local({
[10:30:54.043]                         has_future <- base::requireNamespace("future", 
[10:30:54.043]                           quietly = TRUE)
[10:30:54.043]                         if (has_future) {
[10:30:54.043]                           ns <- base::getNamespace("future")
[10:30:54.043]                           version <- ns[[".package"]][["version"]]
[10:30:54.043]                           if (is.null(version)) 
[10:30:54.043]                             version <- utils::packageVersion("future")
[10:30:54.043]                         }
[10:30:54.043]                         else {
[10:30:54.043]                           version <- NULL
[10:30:54.043]                         }
[10:30:54.043]                         if (!has_future || version < "1.8.0") {
[10:30:54.043]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.043]                             "", base::R.version$version.string), 
[10:30:54.043]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.043]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.043]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.043]                               "release", "version")], collapse = " "), 
[10:30:54.043]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.043]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.043]                             info)
[10:30:54.043]                           info <- base::paste(info, collapse = "; ")
[10:30:54.043]                           if (!has_future) {
[10:30:54.043]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.043]                               info)
[10:30:54.043]                           }
[10:30:54.043]                           else {
[10:30:54.043]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.043]                               info, version)
[10:30:54.043]                           }
[10:30:54.043]                           base::stop(msg)
[10:30:54.043]                         }
[10:30:54.043]                       })
[10:30:54.043]                     }
[10:30:54.043]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.043]                     base::options(mc.cores = 1L)
[10:30:54.043]                   }
[10:30:54.043]                   ...future.strategy.old <- future::plan("list")
[10:30:54.043]                   options(future.plan = NULL)
[10:30:54.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.043]                 }
[10:30:54.043]                 ...future.workdir <- getwd()
[10:30:54.043]             }
[10:30:54.043]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.043]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.043]         }
[10:30:54.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.043]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.043]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.043]             base::names(...future.oldOptions))
[10:30:54.043]     }
[10:30:54.043]     if (FALSE) {
[10:30:54.043]     }
[10:30:54.043]     else {
[10:30:54.043]         if (TRUE) {
[10:30:54.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.043]                 open = "w")
[10:30:54.043]         }
[10:30:54.043]         else {
[10:30:54.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.043]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.043]         }
[10:30:54.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.043]             base::sink(type = "output", split = FALSE)
[10:30:54.043]             base::close(...future.stdout)
[10:30:54.043]         }, add = TRUE)
[10:30:54.043]     }
[10:30:54.043]     ...future.frame <- base::sys.nframe()
[10:30:54.043]     ...future.conditions <- base::list()
[10:30:54.043]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.043]     if (FALSE) {
[10:30:54.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.043]     }
[10:30:54.043]     ...future.result <- base::tryCatch({
[10:30:54.043]         base::withCallingHandlers({
[10:30:54.043]             ...future.value <- base::withVisible(base::local({
[10:30:54.043]                 ...future.makeSendCondition <- base::local({
[10:30:54.043]                   sendCondition <- NULL
[10:30:54.043]                   function(frame = 1L) {
[10:30:54.043]                     if (is.function(sendCondition)) 
[10:30:54.043]                       return(sendCondition)
[10:30:54.043]                     ns <- getNamespace("parallel")
[10:30:54.043]                     if (exists("sendData", mode = "function", 
[10:30:54.043]                       envir = ns)) {
[10:30:54.043]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.043]                         envir = ns)
[10:30:54.043]                       envir <- sys.frame(frame)
[10:30:54.043]                       master <- NULL
[10:30:54.043]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.043]                         !identical(envir, emptyenv())) {
[10:30:54.043]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.043]                           inherits = FALSE)) {
[10:30:54.043]                           master <- get("master", mode = "list", 
[10:30:54.043]                             envir = envir, inherits = FALSE)
[10:30:54.043]                           if (inherits(master, c("SOCKnode", 
[10:30:54.043]                             "SOCK0node"))) {
[10:30:54.043]                             sendCondition <<- function(cond) {
[10:30:54.043]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.043]                                 success = TRUE)
[10:30:54.043]                               parallel_sendData(master, data)
[10:30:54.043]                             }
[10:30:54.043]                             return(sendCondition)
[10:30:54.043]                           }
[10:30:54.043]                         }
[10:30:54.043]                         frame <- frame + 1L
[10:30:54.043]                         envir <- sys.frame(frame)
[10:30:54.043]                       }
[10:30:54.043]                     }
[10:30:54.043]                     sendCondition <<- function(cond) NULL
[10:30:54.043]                   }
[10:30:54.043]                 })
[10:30:54.043]                 withCallingHandlers({
[10:30:54.043]                   {
[10:30:54.043]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.043]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.043]                       ...future.globals.maxSize)) {
[10:30:54.043]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.043]                       on.exit(options(oopts), add = TRUE)
[10:30:54.043]                     }
[10:30:54.043]                     {
[10:30:54.043]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.043]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.043]                         USE.NAMES = FALSE)
[10:30:54.043]                       do.call(mapply, args = args)
[10:30:54.043]                     }
[10:30:54.043]                   }
[10:30:54.043]                 }, immediateCondition = function(cond) {
[10:30:54.043]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.043]                   sendCondition(cond)
[10:30:54.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.043]                   {
[10:30:54.043]                     inherits <- base::inherits
[10:30:54.043]                     invokeRestart <- base::invokeRestart
[10:30:54.043]                     is.null <- base::is.null
[10:30:54.043]                     muffled <- FALSE
[10:30:54.043]                     if (inherits(cond, "message")) {
[10:30:54.043]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.043]                       if (muffled) 
[10:30:54.043]                         invokeRestart("muffleMessage")
[10:30:54.043]                     }
[10:30:54.043]                     else if (inherits(cond, "warning")) {
[10:30:54.043]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.043]                       if (muffled) 
[10:30:54.043]                         invokeRestart("muffleWarning")
[10:30:54.043]                     }
[10:30:54.043]                     else if (inherits(cond, "condition")) {
[10:30:54.043]                       if (!is.null(pattern)) {
[10:30:54.043]                         computeRestarts <- base::computeRestarts
[10:30:54.043]                         grepl <- base::grepl
[10:30:54.043]                         restarts <- computeRestarts(cond)
[10:30:54.043]                         for (restart in restarts) {
[10:30:54.043]                           name <- restart$name
[10:30:54.043]                           if (is.null(name)) 
[10:30:54.043]                             next
[10:30:54.043]                           if (!grepl(pattern, name)) 
[10:30:54.043]                             next
[10:30:54.043]                           invokeRestart(restart)
[10:30:54.043]                           muffled <- TRUE
[10:30:54.043]                           break
[10:30:54.043]                         }
[10:30:54.043]                       }
[10:30:54.043]                     }
[10:30:54.043]                     invisible(muffled)
[10:30:54.043]                   }
[10:30:54.043]                   muffleCondition(cond)
[10:30:54.043]                 })
[10:30:54.043]             }))
[10:30:54.043]             future::FutureResult(value = ...future.value$value, 
[10:30:54.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.043]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.043]                     ...future.globalenv.names))
[10:30:54.043]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.043]         }, condition = base::local({
[10:30:54.043]             c <- base::c
[10:30:54.043]             inherits <- base::inherits
[10:30:54.043]             invokeRestart <- base::invokeRestart
[10:30:54.043]             length <- base::length
[10:30:54.043]             list <- base::list
[10:30:54.043]             seq.int <- base::seq.int
[10:30:54.043]             signalCondition <- base::signalCondition
[10:30:54.043]             sys.calls <- base::sys.calls
[10:30:54.043]             `[[` <- base::`[[`
[10:30:54.043]             `+` <- base::`+`
[10:30:54.043]             `<<-` <- base::`<<-`
[10:30:54.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.043]                   3L)]
[10:30:54.043]             }
[10:30:54.043]             function(cond) {
[10:30:54.043]                 is_error <- inherits(cond, "error")
[10:30:54.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.043]                   NULL)
[10:30:54.043]                 if (is_error) {
[10:30:54.043]                   sessionInformation <- function() {
[10:30:54.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.043]                       search = base::search(), system = base::Sys.info())
[10:30:54.043]                   }
[10:30:54.043]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.043]                     cond$call), session = sessionInformation(), 
[10:30:54.043]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.043]                   signalCondition(cond)
[10:30:54.043]                 }
[10:30:54.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.043]                 "immediateCondition"))) {
[10:30:54.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.043]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.043]                   if (TRUE && !signal) {
[10:30:54.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.043]                     {
[10:30:54.043]                       inherits <- base::inherits
[10:30:54.043]                       invokeRestart <- base::invokeRestart
[10:30:54.043]                       is.null <- base::is.null
[10:30:54.043]                       muffled <- FALSE
[10:30:54.043]                       if (inherits(cond, "message")) {
[10:30:54.043]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.043]                         if (muffled) 
[10:30:54.043]                           invokeRestart("muffleMessage")
[10:30:54.043]                       }
[10:30:54.043]                       else if (inherits(cond, "warning")) {
[10:30:54.043]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.043]                         if (muffled) 
[10:30:54.043]                           invokeRestart("muffleWarning")
[10:30:54.043]                       }
[10:30:54.043]                       else if (inherits(cond, "condition")) {
[10:30:54.043]                         if (!is.null(pattern)) {
[10:30:54.043]                           computeRestarts <- base::computeRestarts
[10:30:54.043]                           grepl <- base::grepl
[10:30:54.043]                           restarts <- computeRestarts(cond)
[10:30:54.043]                           for (restart in restarts) {
[10:30:54.043]                             name <- restart$name
[10:30:54.043]                             if (is.null(name)) 
[10:30:54.043]                               next
[10:30:54.043]                             if (!grepl(pattern, name)) 
[10:30:54.043]                               next
[10:30:54.043]                             invokeRestart(restart)
[10:30:54.043]                             muffled <- TRUE
[10:30:54.043]                             break
[10:30:54.043]                           }
[10:30:54.043]                         }
[10:30:54.043]                       }
[10:30:54.043]                       invisible(muffled)
[10:30:54.043]                     }
[10:30:54.043]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.043]                   }
[10:30:54.043]                 }
[10:30:54.043]                 else {
[10:30:54.043]                   if (TRUE) {
[10:30:54.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.043]                     {
[10:30:54.043]                       inherits <- base::inherits
[10:30:54.043]                       invokeRestart <- base::invokeRestart
[10:30:54.043]                       is.null <- base::is.null
[10:30:54.043]                       muffled <- FALSE
[10:30:54.043]                       if (inherits(cond, "message")) {
[10:30:54.043]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.043]                         if (muffled) 
[10:30:54.043]                           invokeRestart("muffleMessage")
[10:30:54.043]                       }
[10:30:54.043]                       else if (inherits(cond, "warning")) {
[10:30:54.043]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.043]                         if (muffled) 
[10:30:54.043]                           invokeRestart("muffleWarning")
[10:30:54.043]                       }
[10:30:54.043]                       else if (inherits(cond, "condition")) {
[10:30:54.043]                         if (!is.null(pattern)) {
[10:30:54.043]                           computeRestarts <- base::computeRestarts
[10:30:54.043]                           grepl <- base::grepl
[10:30:54.043]                           restarts <- computeRestarts(cond)
[10:30:54.043]                           for (restart in restarts) {
[10:30:54.043]                             name <- restart$name
[10:30:54.043]                             if (is.null(name)) 
[10:30:54.043]                               next
[10:30:54.043]                             if (!grepl(pattern, name)) 
[10:30:54.043]                               next
[10:30:54.043]                             invokeRestart(restart)
[10:30:54.043]                             muffled <- TRUE
[10:30:54.043]                             break
[10:30:54.043]                           }
[10:30:54.043]                         }
[10:30:54.043]                       }
[10:30:54.043]                       invisible(muffled)
[10:30:54.043]                     }
[10:30:54.043]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.043]                   }
[10:30:54.043]                 }
[10:30:54.043]             }
[10:30:54.043]         }))
[10:30:54.043]     }, error = function(ex) {
[10:30:54.043]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.043]                 ...future.rng), started = ...future.startTime, 
[10:30:54.043]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.043]             version = "1.8"), class = "FutureResult")
[10:30:54.043]     }, finally = {
[10:30:54.043]         if (!identical(...future.workdir, getwd())) 
[10:30:54.043]             setwd(...future.workdir)
[10:30:54.043]         {
[10:30:54.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.043]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.043]             }
[10:30:54.043]             base::options(...future.oldOptions)
[10:30:54.043]             if (.Platform$OS.type == "windows") {
[10:30:54.043]                 old_names <- names(...future.oldEnvVars)
[10:30:54.043]                 envs <- base::Sys.getenv()
[10:30:54.043]                 names <- names(envs)
[10:30:54.043]                 common <- intersect(names, old_names)
[10:30:54.043]                 added <- setdiff(names, old_names)
[10:30:54.043]                 removed <- setdiff(old_names, names)
[10:30:54.043]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.043]                   envs[common]]
[10:30:54.043]                 NAMES <- toupper(changed)
[10:30:54.043]                 args <- list()
[10:30:54.043]                 for (kk in seq_along(NAMES)) {
[10:30:54.043]                   name <- changed[[kk]]
[10:30:54.043]                   NAME <- NAMES[[kk]]
[10:30:54.043]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.043]                     next
[10:30:54.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.043]                 }
[10:30:54.043]                 NAMES <- toupper(added)
[10:30:54.043]                 for (kk in seq_along(NAMES)) {
[10:30:54.043]                   name <- added[[kk]]
[10:30:54.043]                   NAME <- NAMES[[kk]]
[10:30:54.043]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.043]                     next
[10:30:54.043]                   args[[name]] <- ""
[10:30:54.043]                 }
[10:30:54.043]                 NAMES <- toupper(removed)
[10:30:54.043]                 for (kk in seq_along(NAMES)) {
[10:30:54.043]                   name <- removed[[kk]]
[10:30:54.043]                   NAME <- NAMES[[kk]]
[10:30:54.043]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.043]                     next
[10:30:54.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.043]                 }
[10:30:54.043]                 if (length(args) > 0) 
[10:30:54.043]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.043]             }
[10:30:54.043]             else {
[10:30:54.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.043]             }
[10:30:54.043]             {
[10:30:54.043]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.043]                   0L) {
[10:30:54.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.043]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.043]                   base::options(opts)
[10:30:54.043]                 }
[10:30:54.043]                 {
[10:30:54.043]                   {
[10:30:54.043]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.043]                     NULL
[10:30:54.043]                   }
[10:30:54.043]                   options(future.plan = NULL)
[10:30:54.043]                   if (is.na(NA_character_)) 
[10:30:54.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.043]                     .init = FALSE)
[10:30:54.043]                 }
[10:30:54.043]             }
[10:30:54.043]         }
[10:30:54.043]     })
[10:30:54.043]     if (TRUE) {
[10:30:54.043]         base::sink(type = "output", split = FALSE)
[10:30:54.043]         if (TRUE) {
[10:30:54.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.043]         }
[10:30:54.043]         else {
[10:30:54.043]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.043]         }
[10:30:54.043]         base::close(...future.stdout)
[10:30:54.043]         ...future.stdout <- NULL
[10:30:54.043]     }
[10:30:54.043]     ...future.result$conditions <- ...future.conditions
[10:30:54.043]     ...future.result$finished <- base::Sys.time()
[10:30:54.043]     ...future.result
[10:30:54.043] }
[10:30:54.045] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[10:30:54.046] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[10:30:54.046] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[10:30:54.046] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:54.046] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.047] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[10:30:54.047] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[10:30:54.047] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:54.048] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.048] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:54.048] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.048] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[10:30:54.049] MultisessionFuture started
[10:30:54.049] - Launch lazy future ... done
[10:30:54.049] run() for ‘MultisessionFuture’ ... done
[10:30:54.049] Created future:
[10:30:54.049] MultisessionFuture:
[10:30:54.049] Label: ‘future_.mapply-2’
[10:30:54.049] Expression:
[10:30:54.049] {
[10:30:54.049]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.049]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.049]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.049]         on.exit(options(oopts), add = TRUE)
[10:30:54.049]     }
[10:30:54.049]     {
[10:30:54.049]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.049]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.049]         do.call(mapply, args = args)
[10:30:54.049]     }
[10:30:54.049] }
[10:30:54.049] Lazy evaluation: FALSE
[10:30:54.049] Asynchronous evaluation: TRUE
[10:30:54.049] Local evaluation: TRUE
[10:30:54.049] Environment: R_GlobalEnv
[10:30:54.049] Capture standard output: TRUE
[10:30:54.049] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.049] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.049] Packages: <none>
[10:30:54.049] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.049] Resolved: FALSE
[10:30:54.049] Value: <not collected>
[10:30:54.049] Conditions captured: <none>
[10:30:54.049] Early signaling: FALSE
[10:30:54.049] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.049] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.061] Chunk #2 of 2 ... DONE
[10:30:54.061] Launching 2 futures (chunks) ... DONE
[10:30:54.061] Resolving 2 futures (chunks) ...
[10:30:54.061] resolve() on list ...
[10:30:54.061]  recursive: 0
[10:30:54.061]  length: 2
[10:30:54.061] 
[10:30:54.062] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.062] - Validating connection of MultisessionFuture
[10:30:54.062] - received message: FutureResult
[10:30:54.062] - Received FutureResult
[10:30:54.062] - Erased future from FutureRegistry
[10:30:54.063] result() for ClusterFuture ...
[10:30:54.063] - result already collected: FutureResult
[10:30:54.063] result() for ClusterFuture ... done
[10:30:54.063] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.063] Future #1
[10:30:54.063] result() for ClusterFuture ...
[10:30:54.063] - result already collected: FutureResult
[10:30:54.063] result() for ClusterFuture ... done
[10:30:54.063] result() for ClusterFuture ...
[10:30:54.063] - result already collected: FutureResult
[10:30:54.063] result() for ClusterFuture ... done
[10:30:54.063] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:54.064] - nx: 2
[10:30:54.064] - relay: TRUE
[10:30:54.064] - stdout: TRUE
[10:30:54.064] - signal: TRUE
[10:30:54.064] - resignal: FALSE
[10:30:54.064] - force: TRUE
[10:30:54.064] - relayed: [n=2] FALSE, FALSE
[10:30:54.064] - queued futures: [n=2] FALSE, FALSE
[10:30:54.064]  - until=1
[10:30:54.064]  - relaying element #1
[10:30:54.064] result() for ClusterFuture ...
[10:30:54.064] - result already collected: FutureResult
[10:30:54.065] result() for ClusterFuture ... done
[10:30:54.065] result() for ClusterFuture ...
[10:30:54.065] - result already collected: FutureResult
[10:30:54.065] result() for ClusterFuture ... done
[10:30:54.065] result() for ClusterFuture ...
[10:30:54.065] - result already collected: FutureResult
[10:30:54.065] result() for ClusterFuture ... done
[10:30:54.065] result() for ClusterFuture ...
[10:30:54.065] - result already collected: FutureResult
[10:30:54.065] result() for ClusterFuture ... done
[10:30:54.065] - relayed: [n=2] TRUE, FALSE
[10:30:54.066] - queued futures: [n=2] TRUE, FALSE
[10:30:54.066] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:54.066]  length: 1 (resolved future 1)
[10:30:54.090] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.091] - Validating connection of MultisessionFuture
[10:30:54.091] - received message: FutureResult
[10:30:54.091] - Received FutureResult
[10:30:54.091] - Erased future from FutureRegistry
[10:30:54.091] result() for ClusterFuture ...
[10:30:54.091] - result already collected: FutureResult
[10:30:54.091] result() for ClusterFuture ... done
[10:30:54.091] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.092] Future #2
[10:30:54.092] result() for ClusterFuture ...
[10:30:54.092] - result already collected: FutureResult
[10:30:54.092] result() for ClusterFuture ... done
[10:30:54.092] result() for ClusterFuture ...
[10:30:54.092] - result already collected: FutureResult
[10:30:54.092] result() for ClusterFuture ... done
[10:30:54.092] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:54.092] - nx: 2
[10:30:54.092] - relay: TRUE
[10:30:54.092] - stdout: TRUE
[10:30:54.093] - signal: TRUE
[10:30:54.093] - resignal: FALSE
[10:30:54.093] - force: TRUE
[10:30:54.093] - relayed: [n=2] TRUE, FALSE
[10:30:54.093] - queued futures: [n=2] TRUE, FALSE
[10:30:54.093]  - until=2
[10:30:54.093]  - relaying element #2
[10:30:54.093] result() for ClusterFuture ...
[10:30:54.093] - result already collected: FutureResult
[10:30:54.093] result() for ClusterFuture ... done
[10:30:54.093] result() for ClusterFuture ...
[10:30:54.094] - result already collected: FutureResult
[10:30:54.094] result() for ClusterFuture ... done
[10:30:54.094] result() for ClusterFuture ...
[10:30:54.094] - result already collected: FutureResult
[10:30:54.094] result() for ClusterFuture ... done
[10:30:54.094] result() for ClusterFuture ...
[10:30:54.094] - result already collected: FutureResult
[10:30:54.094] result() for ClusterFuture ... done
[10:30:54.094] - relayed: [n=2] TRUE, TRUE
[10:30:54.094] - queued futures: [n=2] TRUE, TRUE
[10:30:54.094] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:54.095]  length: 0 (resolved future 2)
[10:30:54.095] Relaying remaining futures
[10:30:54.095] signalConditionsASAP(NULL, pos=0) ...
[10:30:54.095] - nx: 2
[10:30:54.095] - relay: TRUE
[10:30:54.095] - stdout: TRUE
[10:30:54.095] - signal: TRUE
[10:30:54.095] - resignal: FALSE
[10:30:54.095] - force: TRUE
[10:30:54.095] - relayed: [n=2] TRUE, TRUE
[10:30:54.095] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:54.096] - relayed: [n=2] TRUE, TRUE
[10:30:54.096] - queued futures: [n=2] TRUE, TRUE
[10:30:54.096] signalConditionsASAP(NULL, pos=0) ... done
[10:30:54.096] resolve() on list ... DONE
[10:30:54.096] result() for ClusterFuture ...
[10:30:54.096] - result already collected: FutureResult
[10:30:54.096] result() for ClusterFuture ... done
[10:30:54.096] result() for ClusterFuture ...
[10:30:54.096] - result already collected: FutureResult
[10:30:54.096] result() for ClusterFuture ... done
[10:30:54.096] result() for ClusterFuture ...
[10:30:54.096] - result already collected: FutureResult
[10:30:54.097] result() for ClusterFuture ... done
[10:30:54.097] result() for ClusterFuture ...
[10:30:54.097] - result already collected: FutureResult
[10:30:54.097] result() for ClusterFuture ... done
[10:30:54.097]  - Number of value chunks collected: 2
[10:30:54.097] Resolving 2 futures (chunks) ... DONE
[10:30:54.097] Reducing values from 2 chunks ...
[10:30:54.097]  - Number of values collected after concatenation: 5
[10:30:54.097]  - Number of values expected: 5
[10:30:54.097] Reducing values from 2 chunks ... DONE
[10:30:54.098] future_mapply() ... DONE
[10:30:54.098] future_mapply() ...
[10:30:54.102] Number of chunks: 2
[10:30:54.102] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:30:54.102] getGlobalsAndPackagesXApply() ...
[10:30:54.102]  - future.globals: TRUE
[10:30:54.102] getGlobalsAndPackages() ...
[10:30:54.102] Searching for globals...
[10:30:54.104] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:54.104] Searching for globals ... DONE
[10:30:54.104] Resolving globals: FALSE
[10:30:54.104] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:54.105] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:54.105] - globals: [1] ‘FUN’
[10:30:54.105] 
[10:30:54.105] getGlobalsAndPackages() ... DONE
[10:30:54.105]  - globals found/used: [n=1] ‘FUN’
[10:30:54.105]  - needed namespaces: [n=0] 
[10:30:54.105] Finding globals ... DONE
[10:30:54.105] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:54.106] List of 2
[10:30:54.106]  $ ...future.FUN:function (C, k)  
[10:30:54.106]  $ MoreArgs     : NULL
[10:30:54.106]  - attr(*, "where")=List of 2
[10:30:54.106]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:54.106]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:54.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:54.106]  - attr(*, "resolved")= logi FALSE
[10:30:54.106]  - attr(*, "total_size")= num NA
[10:30:54.108] Packages to be attached in all futures: [n=0] 
[10:30:54.108] getGlobalsAndPackagesXApply() ... DONE
[10:30:54.108] Number of futures (= number of chunks): 2
[10:30:54.108] Launching 2 futures (chunks) ...
[10:30:54.109] Chunk #1 of 2 ...
[10:30:54.109]  - Finding globals in '...' for chunk #1 ...
[10:30:54.109] getGlobalsAndPackages() ...
[10:30:54.109] Searching for globals...
[10:30:54.109] 
[10:30:54.109] Searching for globals ... DONE
[10:30:54.109] - globals: [0] <none>
[10:30:54.110] getGlobalsAndPackages() ... DONE
[10:30:54.110]    + additional globals found: [n=0] 
[10:30:54.110]    + additional namespaces needed: [n=0] 
[10:30:54.110]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:54.110]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.110]  - seeds: <none>
[10:30:54.110]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.110] getGlobalsAndPackages() ...
[10:30:54.110] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.110] Resolving globals: FALSE
[10:30:54.111] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:54.111] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:54.111] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.112] 
[10:30:54.112] getGlobalsAndPackages() ... DONE
[10:30:54.112] run() for ‘Future’ ...
[10:30:54.112] - state: ‘created’
[10:30:54.112] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.126] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.126]   - Field: ‘node’
[10:30:54.126]   - Field: ‘label’
[10:30:54.126]   - Field: ‘local’
[10:30:54.127]   - Field: ‘owner’
[10:30:54.127]   - Field: ‘envir’
[10:30:54.127]   - Field: ‘workers’
[10:30:54.127]   - Field: ‘packages’
[10:30:54.127]   - Field: ‘gc’
[10:30:54.127]   - Field: ‘conditions’
[10:30:54.127]   - Field: ‘persistent’
[10:30:54.127]   - Field: ‘expr’
[10:30:54.127]   - Field: ‘uuid’
[10:30:54.127]   - Field: ‘seed’
[10:30:54.127]   - Field: ‘version’
[10:30:54.128]   - Field: ‘result’
[10:30:54.128]   - Field: ‘asynchronous’
[10:30:54.128]   - Field: ‘calls’
[10:30:54.128]   - Field: ‘globals’
[10:30:54.128]   - Field: ‘stdout’
[10:30:54.128]   - Field: ‘earlySignal’
[10:30:54.128]   - Field: ‘lazy’
[10:30:54.128]   - Field: ‘state’
[10:30:54.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.128] - Launch lazy future ...
[10:30:54.129] Packages needed by the future expression (n = 0): <none>
[10:30:54.129] Packages needed by future strategies (n = 0): <none>
[10:30:54.129] {
[10:30:54.129]     {
[10:30:54.129]         {
[10:30:54.129]             ...future.startTime <- base::Sys.time()
[10:30:54.129]             {
[10:30:54.129]                 {
[10:30:54.129]                   {
[10:30:54.129]                     {
[10:30:54.129]                       base::local({
[10:30:54.129]                         has_future <- base::requireNamespace("future", 
[10:30:54.129]                           quietly = TRUE)
[10:30:54.129]                         if (has_future) {
[10:30:54.129]                           ns <- base::getNamespace("future")
[10:30:54.129]                           version <- ns[[".package"]][["version"]]
[10:30:54.129]                           if (is.null(version)) 
[10:30:54.129]                             version <- utils::packageVersion("future")
[10:30:54.129]                         }
[10:30:54.129]                         else {
[10:30:54.129]                           version <- NULL
[10:30:54.129]                         }
[10:30:54.129]                         if (!has_future || version < "1.8.0") {
[10:30:54.129]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.129]                             "", base::R.version$version.string), 
[10:30:54.129]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.129]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.129]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.129]                               "release", "version")], collapse = " "), 
[10:30:54.129]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.129]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.129]                             info)
[10:30:54.129]                           info <- base::paste(info, collapse = "; ")
[10:30:54.129]                           if (!has_future) {
[10:30:54.129]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.129]                               info)
[10:30:54.129]                           }
[10:30:54.129]                           else {
[10:30:54.129]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.129]                               info, version)
[10:30:54.129]                           }
[10:30:54.129]                           base::stop(msg)
[10:30:54.129]                         }
[10:30:54.129]                       })
[10:30:54.129]                     }
[10:30:54.129]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.129]                     base::options(mc.cores = 1L)
[10:30:54.129]                   }
[10:30:54.129]                   ...future.strategy.old <- future::plan("list")
[10:30:54.129]                   options(future.plan = NULL)
[10:30:54.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.129]                 }
[10:30:54.129]                 ...future.workdir <- getwd()
[10:30:54.129]             }
[10:30:54.129]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.129]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.129]         }
[10:30:54.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.129]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.129]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.129]             base::names(...future.oldOptions))
[10:30:54.129]     }
[10:30:54.129]     if (FALSE) {
[10:30:54.129]     }
[10:30:54.129]     else {
[10:30:54.129]         if (TRUE) {
[10:30:54.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.129]                 open = "w")
[10:30:54.129]         }
[10:30:54.129]         else {
[10:30:54.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.129]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.129]         }
[10:30:54.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.129]             base::sink(type = "output", split = FALSE)
[10:30:54.129]             base::close(...future.stdout)
[10:30:54.129]         }, add = TRUE)
[10:30:54.129]     }
[10:30:54.129]     ...future.frame <- base::sys.nframe()
[10:30:54.129]     ...future.conditions <- base::list()
[10:30:54.129]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.129]     if (FALSE) {
[10:30:54.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.129]     }
[10:30:54.129]     ...future.result <- base::tryCatch({
[10:30:54.129]         base::withCallingHandlers({
[10:30:54.129]             ...future.value <- base::withVisible(base::local({
[10:30:54.129]                 ...future.makeSendCondition <- base::local({
[10:30:54.129]                   sendCondition <- NULL
[10:30:54.129]                   function(frame = 1L) {
[10:30:54.129]                     if (is.function(sendCondition)) 
[10:30:54.129]                       return(sendCondition)
[10:30:54.129]                     ns <- getNamespace("parallel")
[10:30:54.129]                     if (exists("sendData", mode = "function", 
[10:30:54.129]                       envir = ns)) {
[10:30:54.129]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.129]                         envir = ns)
[10:30:54.129]                       envir <- sys.frame(frame)
[10:30:54.129]                       master <- NULL
[10:30:54.129]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.129]                         !identical(envir, emptyenv())) {
[10:30:54.129]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.129]                           inherits = FALSE)) {
[10:30:54.129]                           master <- get("master", mode = "list", 
[10:30:54.129]                             envir = envir, inherits = FALSE)
[10:30:54.129]                           if (inherits(master, c("SOCKnode", 
[10:30:54.129]                             "SOCK0node"))) {
[10:30:54.129]                             sendCondition <<- function(cond) {
[10:30:54.129]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.129]                                 success = TRUE)
[10:30:54.129]                               parallel_sendData(master, data)
[10:30:54.129]                             }
[10:30:54.129]                             return(sendCondition)
[10:30:54.129]                           }
[10:30:54.129]                         }
[10:30:54.129]                         frame <- frame + 1L
[10:30:54.129]                         envir <- sys.frame(frame)
[10:30:54.129]                       }
[10:30:54.129]                     }
[10:30:54.129]                     sendCondition <<- function(cond) NULL
[10:30:54.129]                   }
[10:30:54.129]                 })
[10:30:54.129]                 withCallingHandlers({
[10:30:54.129]                   {
[10:30:54.129]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.129]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.129]                       ...future.globals.maxSize)) {
[10:30:54.129]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.129]                       on.exit(options(oopts), add = TRUE)
[10:30:54.129]                     }
[10:30:54.129]                     {
[10:30:54.129]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.129]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.129]                         USE.NAMES = FALSE)
[10:30:54.129]                       do.call(mapply, args = args)
[10:30:54.129]                     }
[10:30:54.129]                   }
[10:30:54.129]                 }, immediateCondition = function(cond) {
[10:30:54.129]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.129]                   sendCondition(cond)
[10:30:54.129]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.129]                   {
[10:30:54.129]                     inherits <- base::inherits
[10:30:54.129]                     invokeRestart <- base::invokeRestart
[10:30:54.129]                     is.null <- base::is.null
[10:30:54.129]                     muffled <- FALSE
[10:30:54.129]                     if (inherits(cond, "message")) {
[10:30:54.129]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.129]                       if (muffled) 
[10:30:54.129]                         invokeRestart("muffleMessage")
[10:30:54.129]                     }
[10:30:54.129]                     else if (inherits(cond, "warning")) {
[10:30:54.129]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.129]                       if (muffled) 
[10:30:54.129]                         invokeRestart("muffleWarning")
[10:30:54.129]                     }
[10:30:54.129]                     else if (inherits(cond, "condition")) {
[10:30:54.129]                       if (!is.null(pattern)) {
[10:30:54.129]                         computeRestarts <- base::computeRestarts
[10:30:54.129]                         grepl <- base::grepl
[10:30:54.129]                         restarts <- computeRestarts(cond)
[10:30:54.129]                         for (restart in restarts) {
[10:30:54.129]                           name <- restart$name
[10:30:54.129]                           if (is.null(name)) 
[10:30:54.129]                             next
[10:30:54.129]                           if (!grepl(pattern, name)) 
[10:30:54.129]                             next
[10:30:54.129]                           invokeRestart(restart)
[10:30:54.129]                           muffled <- TRUE
[10:30:54.129]                           break
[10:30:54.129]                         }
[10:30:54.129]                       }
[10:30:54.129]                     }
[10:30:54.129]                     invisible(muffled)
[10:30:54.129]                   }
[10:30:54.129]                   muffleCondition(cond)
[10:30:54.129]                 })
[10:30:54.129]             }))
[10:30:54.129]             future::FutureResult(value = ...future.value$value, 
[10:30:54.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.129]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.129]                     ...future.globalenv.names))
[10:30:54.129]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.129]         }, condition = base::local({
[10:30:54.129]             c <- base::c
[10:30:54.129]             inherits <- base::inherits
[10:30:54.129]             invokeRestart <- base::invokeRestart
[10:30:54.129]             length <- base::length
[10:30:54.129]             list <- base::list
[10:30:54.129]             seq.int <- base::seq.int
[10:30:54.129]             signalCondition <- base::signalCondition
[10:30:54.129]             sys.calls <- base::sys.calls
[10:30:54.129]             `[[` <- base::`[[`
[10:30:54.129]             `+` <- base::`+`
[10:30:54.129]             `<<-` <- base::`<<-`
[10:30:54.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.129]                   3L)]
[10:30:54.129]             }
[10:30:54.129]             function(cond) {
[10:30:54.129]                 is_error <- inherits(cond, "error")
[10:30:54.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.129]                   NULL)
[10:30:54.129]                 if (is_error) {
[10:30:54.129]                   sessionInformation <- function() {
[10:30:54.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.129]                       search = base::search(), system = base::Sys.info())
[10:30:54.129]                   }
[10:30:54.129]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.129]                     cond$call), session = sessionInformation(), 
[10:30:54.129]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.129]                   signalCondition(cond)
[10:30:54.129]                 }
[10:30:54.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.129]                 "immediateCondition"))) {
[10:30:54.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.129]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.129]                   if (TRUE && !signal) {
[10:30:54.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.129]                     {
[10:30:54.129]                       inherits <- base::inherits
[10:30:54.129]                       invokeRestart <- base::invokeRestart
[10:30:54.129]                       is.null <- base::is.null
[10:30:54.129]                       muffled <- FALSE
[10:30:54.129]                       if (inherits(cond, "message")) {
[10:30:54.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.129]                         if (muffled) 
[10:30:54.129]                           invokeRestart("muffleMessage")
[10:30:54.129]                       }
[10:30:54.129]                       else if (inherits(cond, "warning")) {
[10:30:54.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.129]                         if (muffled) 
[10:30:54.129]                           invokeRestart("muffleWarning")
[10:30:54.129]                       }
[10:30:54.129]                       else if (inherits(cond, "condition")) {
[10:30:54.129]                         if (!is.null(pattern)) {
[10:30:54.129]                           computeRestarts <- base::computeRestarts
[10:30:54.129]                           grepl <- base::grepl
[10:30:54.129]                           restarts <- computeRestarts(cond)
[10:30:54.129]                           for (restart in restarts) {
[10:30:54.129]                             name <- restart$name
[10:30:54.129]                             if (is.null(name)) 
[10:30:54.129]                               next
[10:30:54.129]                             if (!grepl(pattern, name)) 
[10:30:54.129]                               next
[10:30:54.129]                             invokeRestart(restart)
[10:30:54.129]                             muffled <- TRUE
[10:30:54.129]                             break
[10:30:54.129]                           }
[10:30:54.129]                         }
[10:30:54.129]                       }
[10:30:54.129]                       invisible(muffled)
[10:30:54.129]                     }
[10:30:54.129]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.129]                   }
[10:30:54.129]                 }
[10:30:54.129]                 else {
[10:30:54.129]                   if (TRUE) {
[10:30:54.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.129]                     {
[10:30:54.129]                       inherits <- base::inherits
[10:30:54.129]                       invokeRestart <- base::invokeRestart
[10:30:54.129]                       is.null <- base::is.null
[10:30:54.129]                       muffled <- FALSE
[10:30:54.129]                       if (inherits(cond, "message")) {
[10:30:54.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.129]                         if (muffled) 
[10:30:54.129]                           invokeRestart("muffleMessage")
[10:30:54.129]                       }
[10:30:54.129]                       else if (inherits(cond, "warning")) {
[10:30:54.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.129]                         if (muffled) 
[10:30:54.129]                           invokeRestart("muffleWarning")
[10:30:54.129]                       }
[10:30:54.129]                       else if (inherits(cond, "condition")) {
[10:30:54.129]                         if (!is.null(pattern)) {
[10:30:54.129]                           computeRestarts <- base::computeRestarts
[10:30:54.129]                           grepl <- base::grepl
[10:30:54.129]                           restarts <- computeRestarts(cond)
[10:30:54.129]                           for (restart in restarts) {
[10:30:54.129]                             name <- restart$name
[10:30:54.129]                             if (is.null(name)) 
[10:30:54.129]                               next
[10:30:54.129]                             if (!grepl(pattern, name)) 
[10:30:54.129]                               next
[10:30:54.129]                             invokeRestart(restart)
[10:30:54.129]                             muffled <- TRUE
[10:30:54.129]                             break
[10:30:54.129]                           }
[10:30:54.129]                         }
[10:30:54.129]                       }
[10:30:54.129]                       invisible(muffled)
[10:30:54.129]                     }
[10:30:54.129]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.129]                   }
[10:30:54.129]                 }
[10:30:54.129]             }
[10:30:54.129]         }))
[10:30:54.129]     }, error = function(ex) {
[10:30:54.129]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.129]                 ...future.rng), started = ...future.startTime, 
[10:30:54.129]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.129]             version = "1.8"), class = "FutureResult")
[10:30:54.129]     }, finally = {
[10:30:54.129]         if (!identical(...future.workdir, getwd())) 
[10:30:54.129]             setwd(...future.workdir)
[10:30:54.129]         {
[10:30:54.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.129]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.129]             }
[10:30:54.129]             base::options(...future.oldOptions)
[10:30:54.129]             if (.Platform$OS.type == "windows") {
[10:30:54.129]                 old_names <- names(...future.oldEnvVars)
[10:30:54.129]                 envs <- base::Sys.getenv()
[10:30:54.129]                 names <- names(envs)
[10:30:54.129]                 common <- intersect(names, old_names)
[10:30:54.129]                 added <- setdiff(names, old_names)
[10:30:54.129]                 removed <- setdiff(old_names, names)
[10:30:54.129]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.129]                   envs[common]]
[10:30:54.129]                 NAMES <- toupper(changed)
[10:30:54.129]                 args <- list()
[10:30:54.129]                 for (kk in seq_along(NAMES)) {
[10:30:54.129]                   name <- changed[[kk]]
[10:30:54.129]                   NAME <- NAMES[[kk]]
[10:30:54.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.129]                     next
[10:30:54.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.129]                 }
[10:30:54.129]                 NAMES <- toupper(added)
[10:30:54.129]                 for (kk in seq_along(NAMES)) {
[10:30:54.129]                   name <- added[[kk]]
[10:30:54.129]                   NAME <- NAMES[[kk]]
[10:30:54.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.129]                     next
[10:30:54.129]                   args[[name]] <- ""
[10:30:54.129]                 }
[10:30:54.129]                 NAMES <- toupper(removed)
[10:30:54.129]                 for (kk in seq_along(NAMES)) {
[10:30:54.129]                   name <- removed[[kk]]
[10:30:54.129]                   NAME <- NAMES[[kk]]
[10:30:54.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.129]                     next
[10:30:54.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.129]                 }
[10:30:54.129]                 if (length(args) > 0) 
[10:30:54.129]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.129]             }
[10:30:54.129]             else {
[10:30:54.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.129]             }
[10:30:54.129]             {
[10:30:54.129]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.129]                   0L) {
[10:30:54.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.129]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.129]                   base::options(opts)
[10:30:54.129]                 }
[10:30:54.129]                 {
[10:30:54.129]                   {
[10:30:54.129]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.129]                     NULL
[10:30:54.129]                   }
[10:30:54.129]                   options(future.plan = NULL)
[10:30:54.129]                   if (is.na(NA_character_)) 
[10:30:54.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.129]                     .init = FALSE)
[10:30:54.129]                 }
[10:30:54.129]             }
[10:30:54.129]         }
[10:30:54.129]     })
[10:30:54.129]     if (TRUE) {
[10:30:54.129]         base::sink(type = "output", split = FALSE)
[10:30:54.129]         if (TRUE) {
[10:30:54.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.129]         }
[10:30:54.129]         else {
[10:30:54.129]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.129]         }
[10:30:54.129]         base::close(...future.stdout)
[10:30:54.129]         ...future.stdout <- NULL
[10:30:54.129]     }
[10:30:54.129]     ...future.result$conditions <- ...future.conditions
[10:30:54.129]     ...future.result$finished <- base::Sys.time()
[10:30:54.129]     ...future.result
[10:30:54.129] }
[10:30:54.132] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[10:30:54.132] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[10:30:54.132] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[10:30:54.133] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:54.133] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.133] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[10:30:54.133] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[10:30:54.134] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:54.134] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.134] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:54.134] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.134] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[10:30:54.135] MultisessionFuture started
[10:30:54.135] - Launch lazy future ... done
[10:30:54.135] run() for ‘MultisessionFuture’ ... done
[10:30:54.135] Created future:
[10:30:54.135] MultisessionFuture:
[10:30:54.135] Label: ‘future_mapply-1’
[10:30:54.135] Expression:
[10:30:54.135] {
[10:30:54.135]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.135]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.135]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.135]         on.exit(options(oopts), add = TRUE)
[10:30:54.135]     }
[10:30:54.135]     {
[10:30:54.135]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.135]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.135]         do.call(mapply, args = args)
[10:30:54.135]     }
[10:30:54.135] }
[10:30:54.135] Lazy evaluation: FALSE
[10:30:54.135] Asynchronous evaluation: TRUE
[10:30:54.135] Local evaluation: TRUE
[10:30:54.135] Environment: R_GlobalEnv
[10:30:54.135] Capture standard output: TRUE
[10:30:54.135] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.135] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.135] Packages: <none>
[10:30:54.135] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.135] Resolved: FALSE
[10:30:54.135] Value: <not collected>
[10:30:54.135] Conditions captured: <none>
[10:30:54.135] Early signaling: FALSE
[10:30:54.135] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.135] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.147] Chunk #1 of 2 ... DONE
[10:30:54.147] Chunk #2 of 2 ...
[10:30:54.147]  - Finding globals in '...' for chunk #2 ...
[10:30:54.147] getGlobalsAndPackages() ...
[10:30:54.147] Searching for globals...
[10:30:54.148] 
[10:30:54.148] Searching for globals ... DONE
[10:30:54.148] - globals: [0] <none>
[10:30:54.148] getGlobalsAndPackages() ... DONE
[10:30:54.148]    + additional globals found: [n=0] 
[10:30:54.148]    + additional namespaces needed: [n=0] 
[10:30:54.148]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:54.148]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.148]  - seeds: <none>
[10:30:54.149]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.149] getGlobalsAndPackages() ...
[10:30:54.149] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.149] Resolving globals: FALSE
[10:30:54.149] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[10:30:54.150] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:54.150] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.150] 
[10:30:54.150] getGlobalsAndPackages() ... DONE
[10:30:54.150] run() for ‘Future’ ...
[10:30:54.151] - state: ‘created’
[10:30:54.151] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.165] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.166] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.166]   - Field: ‘node’
[10:30:54.166]   - Field: ‘label’
[10:30:54.166]   - Field: ‘local’
[10:30:54.166]   - Field: ‘owner’
[10:30:54.166]   - Field: ‘envir’
[10:30:54.166]   - Field: ‘workers’
[10:30:54.166]   - Field: ‘packages’
[10:30:54.166]   - Field: ‘gc’
[10:30:54.167]   - Field: ‘conditions’
[10:30:54.167]   - Field: ‘persistent’
[10:30:54.167]   - Field: ‘expr’
[10:30:54.167]   - Field: ‘uuid’
[10:30:54.167]   - Field: ‘seed’
[10:30:54.167]   - Field: ‘version’
[10:30:54.167]   - Field: ‘result’
[10:30:54.167]   - Field: ‘asynchronous’
[10:30:54.167]   - Field: ‘calls’
[10:30:54.167]   - Field: ‘globals’
[10:30:54.167]   - Field: ‘stdout’
[10:30:54.168]   - Field: ‘earlySignal’
[10:30:54.168]   - Field: ‘lazy’
[10:30:54.168]   - Field: ‘state’
[10:30:54.168] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.168] - Launch lazy future ...
[10:30:54.168] Packages needed by the future expression (n = 0): <none>
[10:30:54.168] Packages needed by future strategies (n = 0): <none>
[10:30:54.169] {
[10:30:54.169]     {
[10:30:54.169]         {
[10:30:54.169]             ...future.startTime <- base::Sys.time()
[10:30:54.169]             {
[10:30:54.169]                 {
[10:30:54.169]                   {
[10:30:54.169]                     {
[10:30:54.169]                       base::local({
[10:30:54.169]                         has_future <- base::requireNamespace("future", 
[10:30:54.169]                           quietly = TRUE)
[10:30:54.169]                         if (has_future) {
[10:30:54.169]                           ns <- base::getNamespace("future")
[10:30:54.169]                           version <- ns[[".package"]][["version"]]
[10:30:54.169]                           if (is.null(version)) 
[10:30:54.169]                             version <- utils::packageVersion("future")
[10:30:54.169]                         }
[10:30:54.169]                         else {
[10:30:54.169]                           version <- NULL
[10:30:54.169]                         }
[10:30:54.169]                         if (!has_future || version < "1.8.0") {
[10:30:54.169]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.169]                             "", base::R.version$version.string), 
[10:30:54.169]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.169]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.169]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.169]                               "release", "version")], collapse = " "), 
[10:30:54.169]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.169]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.169]                             info)
[10:30:54.169]                           info <- base::paste(info, collapse = "; ")
[10:30:54.169]                           if (!has_future) {
[10:30:54.169]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.169]                               info)
[10:30:54.169]                           }
[10:30:54.169]                           else {
[10:30:54.169]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.169]                               info, version)
[10:30:54.169]                           }
[10:30:54.169]                           base::stop(msg)
[10:30:54.169]                         }
[10:30:54.169]                       })
[10:30:54.169]                     }
[10:30:54.169]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.169]                     base::options(mc.cores = 1L)
[10:30:54.169]                   }
[10:30:54.169]                   ...future.strategy.old <- future::plan("list")
[10:30:54.169]                   options(future.plan = NULL)
[10:30:54.169]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.169]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.169]                 }
[10:30:54.169]                 ...future.workdir <- getwd()
[10:30:54.169]             }
[10:30:54.169]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.169]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.169]         }
[10:30:54.169]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.169]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.169]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.169]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.169]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.169]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.169]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.169]             base::names(...future.oldOptions))
[10:30:54.169]     }
[10:30:54.169]     if (FALSE) {
[10:30:54.169]     }
[10:30:54.169]     else {
[10:30:54.169]         if (TRUE) {
[10:30:54.169]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.169]                 open = "w")
[10:30:54.169]         }
[10:30:54.169]         else {
[10:30:54.169]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.169]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.169]         }
[10:30:54.169]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.169]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.169]             base::sink(type = "output", split = FALSE)
[10:30:54.169]             base::close(...future.stdout)
[10:30:54.169]         }, add = TRUE)
[10:30:54.169]     }
[10:30:54.169]     ...future.frame <- base::sys.nframe()
[10:30:54.169]     ...future.conditions <- base::list()
[10:30:54.169]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.169]     if (FALSE) {
[10:30:54.169]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.169]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.169]     }
[10:30:54.169]     ...future.result <- base::tryCatch({
[10:30:54.169]         base::withCallingHandlers({
[10:30:54.169]             ...future.value <- base::withVisible(base::local({
[10:30:54.169]                 ...future.makeSendCondition <- base::local({
[10:30:54.169]                   sendCondition <- NULL
[10:30:54.169]                   function(frame = 1L) {
[10:30:54.169]                     if (is.function(sendCondition)) 
[10:30:54.169]                       return(sendCondition)
[10:30:54.169]                     ns <- getNamespace("parallel")
[10:30:54.169]                     if (exists("sendData", mode = "function", 
[10:30:54.169]                       envir = ns)) {
[10:30:54.169]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.169]                         envir = ns)
[10:30:54.169]                       envir <- sys.frame(frame)
[10:30:54.169]                       master <- NULL
[10:30:54.169]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.169]                         !identical(envir, emptyenv())) {
[10:30:54.169]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.169]                           inherits = FALSE)) {
[10:30:54.169]                           master <- get("master", mode = "list", 
[10:30:54.169]                             envir = envir, inherits = FALSE)
[10:30:54.169]                           if (inherits(master, c("SOCKnode", 
[10:30:54.169]                             "SOCK0node"))) {
[10:30:54.169]                             sendCondition <<- function(cond) {
[10:30:54.169]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.169]                                 success = TRUE)
[10:30:54.169]                               parallel_sendData(master, data)
[10:30:54.169]                             }
[10:30:54.169]                             return(sendCondition)
[10:30:54.169]                           }
[10:30:54.169]                         }
[10:30:54.169]                         frame <- frame + 1L
[10:30:54.169]                         envir <- sys.frame(frame)
[10:30:54.169]                       }
[10:30:54.169]                     }
[10:30:54.169]                     sendCondition <<- function(cond) NULL
[10:30:54.169]                   }
[10:30:54.169]                 })
[10:30:54.169]                 withCallingHandlers({
[10:30:54.169]                   {
[10:30:54.169]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.169]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.169]                       ...future.globals.maxSize)) {
[10:30:54.169]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.169]                       on.exit(options(oopts), add = TRUE)
[10:30:54.169]                     }
[10:30:54.169]                     {
[10:30:54.169]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.169]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.169]                         USE.NAMES = FALSE)
[10:30:54.169]                       do.call(mapply, args = args)
[10:30:54.169]                     }
[10:30:54.169]                   }
[10:30:54.169]                 }, immediateCondition = function(cond) {
[10:30:54.169]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.169]                   sendCondition(cond)
[10:30:54.169]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.169]                   {
[10:30:54.169]                     inherits <- base::inherits
[10:30:54.169]                     invokeRestart <- base::invokeRestart
[10:30:54.169]                     is.null <- base::is.null
[10:30:54.169]                     muffled <- FALSE
[10:30:54.169]                     if (inherits(cond, "message")) {
[10:30:54.169]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.169]                       if (muffled) 
[10:30:54.169]                         invokeRestart("muffleMessage")
[10:30:54.169]                     }
[10:30:54.169]                     else if (inherits(cond, "warning")) {
[10:30:54.169]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.169]                       if (muffled) 
[10:30:54.169]                         invokeRestart("muffleWarning")
[10:30:54.169]                     }
[10:30:54.169]                     else if (inherits(cond, "condition")) {
[10:30:54.169]                       if (!is.null(pattern)) {
[10:30:54.169]                         computeRestarts <- base::computeRestarts
[10:30:54.169]                         grepl <- base::grepl
[10:30:54.169]                         restarts <- computeRestarts(cond)
[10:30:54.169]                         for (restart in restarts) {
[10:30:54.169]                           name <- restart$name
[10:30:54.169]                           if (is.null(name)) 
[10:30:54.169]                             next
[10:30:54.169]                           if (!grepl(pattern, name)) 
[10:30:54.169]                             next
[10:30:54.169]                           invokeRestart(restart)
[10:30:54.169]                           muffled <- TRUE
[10:30:54.169]                           break
[10:30:54.169]                         }
[10:30:54.169]                       }
[10:30:54.169]                     }
[10:30:54.169]                     invisible(muffled)
[10:30:54.169]                   }
[10:30:54.169]                   muffleCondition(cond)
[10:30:54.169]                 })
[10:30:54.169]             }))
[10:30:54.169]             future::FutureResult(value = ...future.value$value, 
[10:30:54.169]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.169]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.169]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.169]                     ...future.globalenv.names))
[10:30:54.169]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.169]         }, condition = base::local({
[10:30:54.169]             c <- base::c
[10:30:54.169]             inherits <- base::inherits
[10:30:54.169]             invokeRestart <- base::invokeRestart
[10:30:54.169]             length <- base::length
[10:30:54.169]             list <- base::list
[10:30:54.169]             seq.int <- base::seq.int
[10:30:54.169]             signalCondition <- base::signalCondition
[10:30:54.169]             sys.calls <- base::sys.calls
[10:30:54.169]             `[[` <- base::`[[`
[10:30:54.169]             `+` <- base::`+`
[10:30:54.169]             `<<-` <- base::`<<-`
[10:30:54.169]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.169]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.169]                   3L)]
[10:30:54.169]             }
[10:30:54.169]             function(cond) {
[10:30:54.169]                 is_error <- inherits(cond, "error")
[10:30:54.169]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.169]                   NULL)
[10:30:54.169]                 if (is_error) {
[10:30:54.169]                   sessionInformation <- function() {
[10:30:54.169]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.169]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.169]                       search = base::search(), system = base::Sys.info())
[10:30:54.169]                   }
[10:30:54.169]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.169]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.169]                     cond$call), session = sessionInformation(), 
[10:30:54.169]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.169]                   signalCondition(cond)
[10:30:54.169]                 }
[10:30:54.169]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.169]                 "immediateCondition"))) {
[10:30:54.169]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.169]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.169]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.169]                   if (TRUE && !signal) {
[10:30:54.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.169]                     {
[10:30:54.169]                       inherits <- base::inherits
[10:30:54.169]                       invokeRestart <- base::invokeRestart
[10:30:54.169]                       is.null <- base::is.null
[10:30:54.169]                       muffled <- FALSE
[10:30:54.169]                       if (inherits(cond, "message")) {
[10:30:54.169]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.169]                         if (muffled) 
[10:30:54.169]                           invokeRestart("muffleMessage")
[10:30:54.169]                       }
[10:30:54.169]                       else if (inherits(cond, "warning")) {
[10:30:54.169]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.169]                         if (muffled) 
[10:30:54.169]                           invokeRestart("muffleWarning")
[10:30:54.169]                       }
[10:30:54.169]                       else if (inherits(cond, "condition")) {
[10:30:54.169]                         if (!is.null(pattern)) {
[10:30:54.169]                           computeRestarts <- base::computeRestarts
[10:30:54.169]                           grepl <- base::grepl
[10:30:54.169]                           restarts <- computeRestarts(cond)
[10:30:54.169]                           for (restart in restarts) {
[10:30:54.169]                             name <- restart$name
[10:30:54.169]                             if (is.null(name)) 
[10:30:54.169]                               next
[10:30:54.169]                             if (!grepl(pattern, name)) 
[10:30:54.169]                               next
[10:30:54.169]                             invokeRestart(restart)
[10:30:54.169]                             muffled <- TRUE
[10:30:54.169]                             break
[10:30:54.169]                           }
[10:30:54.169]                         }
[10:30:54.169]                       }
[10:30:54.169]                       invisible(muffled)
[10:30:54.169]                     }
[10:30:54.169]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.169]                   }
[10:30:54.169]                 }
[10:30:54.169]                 else {
[10:30:54.169]                   if (TRUE) {
[10:30:54.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.169]                     {
[10:30:54.169]                       inherits <- base::inherits
[10:30:54.169]                       invokeRestart <- base::invokeRestart
[10:30:54.169]                       is.null <- base::is.null
[10:30:54.169]                       muffled <- FALSE
[10:30:54.169]                       if (inherits(cond, "message")) {
[10:30:54.169]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.169]                         if (muffled) 
[10:30:54.169]                           invokeRestart("muffleMessage")
[10:30:54.169]                       }
[10:30:54.169]                       else if (inherits(cond, "warning")) {
[10:30:54.169]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.169]                         if (muffled) 
[10:30:54.169]                           invokeRestart("muffleWarning")
[10:30:54.169]                       }
[10:30:54.169]                       else if (inherits(cond, "condition")) {
[10:30:54.169]                         if (!is.null(pattern)) {
[10:30:54.169]                           computeRestarts <- base::computeRestarts
[10:30:54.169]                           grepl <- base::grepl
[10:30:54.169]                           restarts <- computeRestarts(cond)
[10:30:54.169]                           for (restart in restarts) {
[10:30:54.169]                             name <- restart$name
[10:30:54.169]                             if (is.null(name)) 
[10:30:54.169]                               next
[10:30:54.169]                             if (!grepl(pattern, name)) 
[10:30:54.169]                               next
[10:30:54.169]                             invokeRestart(restart)
[10:30:54.169]                             muffled <- TRUE
[10:30:54.169]                             break
[10:30:54.169]                           }
[10:30:54.169]                         }
[10:30:54.169]                       }
[10:30:54.169]                       invisible(muffled)
[10:30:54.169]                     }
[10:30:54.169]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.169]                   }
[10:30:54.169]                 }
[10:30:54.169]             }
[10:30:54.169]         }))
[10:30:54.169]     }, error = function(ex) {
[10:30:54.169]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.169]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.169]                 ...future.rng), started = ...future.startTime, 
[10:30:54.169]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.169]             version = "1.8"), class = "FutureResult")
[10:30:54.169]     }, finally = {
[10:30:54.169]         if (!identical(...future.workdir, getwd())) 
[10:30:54.169]             setwd(...future.workdir)
[10:30:54.169]         {
[10:30:54.169]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.169]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.169]             }
[10:30:54.169]             base::options(...future.oldOptions)
[10:30:54.169]             if (.Platform$OS.type == "windows") {
[10:30:54.169]                 old_names <- names(...future.oldEnvVars)
[10:30:54.169]                 envs <- base::Sys.getenv()
[10:30:54.169]                 names <- names(envs)
[10:30:54.169]                 common <- intersect(names, old_names)
[10:30:54.169]                 added <- setdiff(names, old_names)
[10:30:54.169]                 removed <- setdiff(old_names, names)
[10:30:54.169]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.169]                   envs[common]]
[10:30:54.169]                 NAMES <- toupper(changed)
[10:30:54.169]                 args <- list()
[10:30:54.169]                 for (kk in seq_along(NAMES)) {
[10:30:54.169]                   name <- changed[[kk]]
[10:30:54.169]                   NAME <- NAMES[[kk]]
[10:30:54.169]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.169]                     next
[10:30:54.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.169]                 }
[10:30:54.169]                 NAMES <- toupper(added)
[10:30:54.169]                 for (kk in seq_along(NAMES)) {
[10:30:54.169]                   name <- added[[kk]]
[10:30:54.169]                   NAME <- NAMES[[kk]]
[10:30:54.169]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.169]                     next
[10:30:54.169]                   args[[name]] <- ""
[10:30:54.169]                 }
[10:30:54.169]                 NAMES <- toupper(removed)
[10:30:54.169]                 for (kk in seq_along(NAMES)) {
[10:30:54.169]                   name <- removed[[kk]]
[10:30:54.169]                   NAME <- NAMES[[kk]]
[10:30:54.169]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.169]                     next
[10:30:54.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.169]                 }
[10:30:54.169]                 if (length(args) > 0) 
[10:30:54.169]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.169]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.169]             }
[10:30:54.169]             else {
[10:30:54.169]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.169]             }
[10:30:54.169]             {
[10:30:54.169]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.169]                   0L) {
[10:30:54.169]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.169]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.169]                   base::options(opts)
[10:30:54.169]                 }
[10:30:54.169]                 {
[10:30:54.169]                   {
[10:30:54.169]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.169]                     NULL
[10:30:54.169]                   }
[10:30:54.169]                   options(future.plan = NULL)
[10:30:54.169]                   if (is.na(NA_character_)) 
[10:30:54.169]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.169]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.169]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.169]                     .init = FALSE)
[10:30:54.169]                 }
[10:30:54.169]             }
[10:30:54.169]         }
[10:30:54.169]     })
[10:30:54.169]     if (TRUE) {
[10:30:54.169]         base::sink(type = "output", split = FALSE)
[10:30:54.169]         if (TRUE) {
[10:30:54.169]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.169]         }
[10:30:54.169]         else {
[10:30:54.169]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.169]         }
[10:30:54.169]         base::close(...future.stdout)
[10:30:54.169]         ...future.stdout <- NULL
[10:30:54.169]     }
[10:30:54.169]     ...future.result$conditions <- ...future.conditions
[10:30:54.169]     ...future.result$finished <- base::Sys.time()
[10:30:54.169]     ...future.result
[10:30:54.169] }
[10:30:54.172] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[10:30:54.172] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[10:30:54.172] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[10:30:54.172] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:54.173] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.173] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[10:30:54.173] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[10:30:54.173] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:54.174] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.174] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:54.174] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.174] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[10:30:54.175] MultisessionFuture started
[10:30:54.175] - Launch lazy future ... done
[10:30:54.175] run() for ‘MultisessionFuture’ ... done
[10:30:54.175] Created future:
[10:30:54.175] MultisessionFuture:
[10:30:54.175] Label: ‘future_mapply-2’
[10:30:54.175] Expression:
[10:30:54.175] {
[10:30:54.175]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.175]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.175]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.175]         on.exit(options(oopts), add = TRUE)
[10:30:54.175]     }
[10:30:54.175]     {
[10:30:54.175]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.175]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.175]         do.call(mapply, args = args)
[10:30:54.175]     }
[10:30:54.175] }
[10:30:54.175] Lazy evaluation: FALSE
[10:30:54.175] Asynchronous evaluation: TRUE
[10:30:54.175] Local evaluation: TRUE
[10:30:54.175] Environment: R_GlobalEnv
[10:30:54.175] Capture standard output: TRUE
[10:30:54.175] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.175] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.175] Packages: <none>
[10:30:54.175] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.175] Resolved: FALSE
[10:30:54.175] Value: <not collected>
[10:30:54.175] Conditions captured: <none>
[10:30:54.175] Early signaling: FALSE
[10:30:54.175] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.175] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.187] Chunk #2 of 2 ... DONE
[10:30:54.187] Launching 2 futures (chunks) ... DONE
[10:30:54.187] Resolving 2 futures (chunks) ...
[10:30:54.187] resolve() on list ...
[10:30:54.187]  recursive: 0
[10:30:54.187]  length: 2
[10:30:54.187] 
[10:30:54.188] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.188] - Validating connection of MultisessionFuture
[10:30:54.188] - received message: FutureResult
[10:30:54.188] - Received FutureResult
[10:30:54.188] - Erased future from FutureRegistry
[10:30:54.188] result() for ClusterFuture ...
[10:30:54.189] - result already collected: FutureResult
[10:30:54.189] result() for ClusterFuture ... done
[10:30:54.189] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.189] Future #1
[10:30:54.189] result() for ClusterFuture ...
[10:30:54.189] - result already collected: FutureResult
[10:30:54.189] result() for ClusterFuture ... done
[10:30:54.189] result() for ClusterFuture ...
[10:30:54.189] - result already collected: FutureResult
[10:30:54.189] result() for ClusterFuture ... done
[10:30:54.190] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:54.190] - nx: 2
[10:30:54.190] - relay: TRUE
[10:30:54.190] - stdout: TRUE
[10:30:54.192] - signal: TRUE
[10:30:54.193] - resignal: FALSE
[10:30:54.193] - force: TRUE
[10:30:54.193] - relayed: [n=2] FALSE, FALSE
[10:30:54.193] - queued futures: [n=2] FALSE, FALSE
[10:30:54.193]  - until=1
[10:30:54.193]  - relaying element #1
[10:30:54.193] result() for ClusterFuture ...
[10:30:54.193] - result already collected: FutureResult
[10:30:54.193] result() for ClusterFuture ... done
[10:30:54.193] result() for ClusterFuture ...
[10:30:54.194] - result already collected: FutureResult
[10:30:54.194] result() for ClusterFuture ... done
[10:30:54.194] result() for ClusterFuture ...
[10:30:54.194] - result already collected: FutureResult
[10:30:54.194] result() for ClusterFuture ... done
[10:30:54.194] result() for ClusterFuture ...
[10:30:54.194] - result already collected: FutureResult
[10:30:54.194] result() for ClusterFuture ... done
[10:30:54.194] - relayed: [n=2] TRUE, FALSE
[10:30:54.194] - queued futures: [n=2] TRUE, FALSE
[10:30:54.194] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:54.194]  length: 1 (resolved future 1)
[10:30:54.218] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.219] - Validating connection of MultisessionFuture
[10:30:54.219] - received message: FutureResult
[10:30:54.219] - Received FutureResult
[10:30:54.219] - Erased future from FutureRegistry
[10:30:54.219] result() for ClusterFuture ...
[10:30:54.219] - result already collected: FutureResult
[10:30:54.219] result() for ClusterFuture ... done
[10:30:54.220] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.220] Future #2
[10:30:54.220] result() for ClusterFuture ...
[10:30:54.220] - result already collected: FutureResult
[10:30:54.220] result() for ClusterFuture ... done
[10:30:54.220] result() for ClusterFuture ...
[10:30:54.220] - result already collected: FutureResult
[10:30:54.220] result() for ClusterFuture ... done
[10:30:54.220] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:54.220] - nx: 2
[10:30:54.220] - relay: TRUE
[10:30:54.221] - stdout: TRUE
[10:30:54.221] - signal: TRUE
[10:30:54.221] - resignal: FALSE
[10:30:54.221] - force: TRUE
[10:30:54.221] - relayed: [n=2] TRUE, FALSE
[10:30:54.221] - queued futures: [n=2] TRUE, FALSE
[10:30:54.221]  - until=2
[10:30:54.221]  - relaying element #2
[10:30:54.221] result() for ClusterFuture ...
[10:30:54.221] - result already collected: FutureResult
[10:30:54.221] result() for ClusterFuture ... done
[10:30:54.222] result() for ClusterFuture ...
[10:30:54.222] - result already collected: FutureResult
[10:30:54.222] result() for ClusterFuture ... done
[10:30:54.222] result() for ClusterFuture ...
[10:30:54.222] - result already collected: FutureResult
[10:30:54.222] result() for ClusterFuture ... done
[10:30:54.222] result() for ClusterFuture ...
[10:30:54.222] - result already collected: FutureResult
[10:30:54.222] result() for ClusterFuture ... done
[10:30:54.222] - relayed: [n=2] TRUE, TRUE
[10:30:54.222] - queued futures: [n=2] TRUE, TRUE
[10:30:54.222] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:54.223]  length: 0 (resolved future 2)
[10:30:54.223] Relaying remaining futures
[10:30:54.223] signalConditionsASAP(NULL, pos=0) ...
[10:30:54.223] - nx: 2
[10:30:54.223] - relay: TRUE
[10:30:54.223] - stdout: TRUE
[10:30:54.223] - signal: TRUE
[10:30:54.223] - resignal: FALSE
[10:30:54.223] - force: TRUE
[10:30:54.223] - relayed: [n=2] TRUE, TRUE
[10:30:54.223] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:54.224] - relayed: [n=2] TRUE, TRUE
[10:30:54.224] - queued futures: [n=2] TRUE, TRUE
[10:30:54.224] signalConditionsASAP(NULL, pos=0) ... done
[10:30:54.224] resolve() on list ... DONE
[10:30:54.224] result() for ClusterFuture ...
[10:30:54.224] - result already collected: FutureResult
[10:30:54.224] result() for ClusterFuture ... done
[10:30:54.224] result() for ClusterFuture ...
[10:30:54.224] - result already collected: FutureResult
[10:30:54.224] result() for ClusterFuture ... done
[10:30:54.224] result() for ClusterFuture ...
[10:30:54.224] - result already collected: FutureResult
[10:30:54.225] result() for ClusterFuture ... done
[10:30:54.225] result() for ClusterFuture ...
[10:30:54.225] - result already collected: FutureResult
[10:30:54.225] result() for ClusterFuture ... done
[10:30:54.225]  - Number of value chunks collected: 2
[10:30:54.225] Resolving 2 futures (chunks) ... DONE
[10:30:54.225] Reducing values from 2 chunks ...
[10:30:54.225]  - Number of values collected after concatenation: 5
[10:30:54.225]  - Number of values expected: 5
[10:30:54.225] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:30:54.226] Reducing values from 2 chunks ... DONE
[10:30:54.226] future_mapply() ... DONE
[10:30:54.226] future_mapply() ...
[10:30:54.230] Number of chunks: 2
[10:30:54.230] getGlobalsAndPackagesXApply() ...
[10:30:54.230]  - future.globals: TRUE
[10:30:54.230] getGlobalsAndPackages() ...
[10:30:54.230] Searching for globals...
[10:30:54.232] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:30:54.232] Searching for globals ... DONE
[10:30:54.232] Resolving globals: FALSE
[10:30:54.232] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[10:30:54.232] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[10:30:54.233] - globals: [1] ‘FUN’
[10:30:54.233] 
[10:30:54.233] getGlobalsAndPackages() ... DONE
[10:30:54.233]  - globals found/used: [n=1] ‘FUN’
[10:30:54.233]  - needed namespaces: [n=0] 
[10:30:54.233] Finding globals ... DONE
[10:30:54.233] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:54.233] List of 2
[10:30:54.233]  $ ...future.FUN:function (C, k)  
[10:30:54.233]  $ MoreArgs     : list()
[10:30:54.233]  - attr(*, "where")=List of 2
[10:30:54.233]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:54.233]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:54.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:54.233]  - attr(*, "resolved")= logi FALSE
[10:30:54.233]  - attr(*, "total_size")= num NA
[10:30:54.236] Packages to be attached in all futures: [n=0] 
[10:30:54.236] getGlobalsAndPackagesXApply() ... DONE
[10:30:54.236] Number of futures (= number of chunks): 2
[10:30:54.236] Launching 2 futures (chunks) ...
[10:30:54.236] Chunk #1 of 2 ...
[10:30:54.237]  - Finding globals in '...' for chunk #1 ...
[10:30:54.237] getGlobalsAndPackages() ...
[10:30:54.237] Searching for globals...
[10:30:54.237] 
[10:30:54.237] Searching for globals ... DONE
[10:30:54.237] - globals: [0] <none>
[10:30:54.237] getGlobalsAndPackages() ... DONE
[10:30:54.237]    + additional globals found: [n=0] 
[10:30:54.237]    + additional namespaces needed: [n=0] 
[10:30:54.238]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:54.238]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.238]  - seeds: <none>
[10:30:54.238]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.238] getGlobalsAndPackages() ...
[10:30:54.238] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.238] Resolving globals: FALSE
[10:30:54.239] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[10:30:54.239] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:54.239] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.239] 
[10:30:54.239] getGlobalsAndPackages() ... DONE
[10:30:54.240] run() for ‘Future’ ...
[10:30:54.240] - state: ‘created’
[10:30:54.240] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.254] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.254] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.254]   - Field: ‘node’
[10:30:54.254]   - Field: ‘label’
[10:30:54.254]   - Field: ‘local’
[10:30:54.254]   - Field: ‘owner’
[10:30:54.254]   - Field: ‘envir’
[10:30:54.254]   - Field: ‘workers’
[10:30:54.255]   - Field: ‘packages’
[10:30:54.255]   - Field: ‘gc’
[10:30:54.255]   - Field: ‘conditions’
[10:30:54.255]   - Field: ‘persistent’
[10:30:54.255]   - Field: ‘expr’
[10:30:54.255]   - Field: ‘uuid’
[10:30:54.255]   - Field: ‘seed’
[10:30:54.255]   - Field: ‘version’
[10:30:54.255]   - Field: ‘result’
[10:30:54.255]   - Field: ‘asynchronous’
[10:30:54.255]   - Field: ‘calls’
[10:30:54.256]   - Field: ‘globals’
[10:30:54.256]   - Field: ‘stdout’
[10:30:54.256]   - Field: ‘earlySignal’
[10:30:54.256]   - Field: ‘lazy’
[10:30:54.256]   - Field: ‘state’
[10:30:54.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.256] - Launch lazy future ...
[10:30:54.256] Packages needed by the future expression (n = 0): <none>
[10:30:54.256] Packages needed by future strategies (n = 0): <none>
[10:30:54.257] {
[10:30:54.257]     {
[10:30:54.257]         {
[10:30:54.257]             ...future.startTime <- base::Sys.time()
[10:30:54.257]             {
[10:30:54.257]                 {
[10:30:54.257]                   {
[10:30:54.257]                     {
[10:30:54.257]                       base::local({
[10:30:54.257]                         has_future <- base::requireNamespace("future", 
[10:30:54.257]                           quietly = TRUE)
[10:30:54.257]                         if (has_future) {
[10:30:54.257]                           ns <- base::getNamespace("future")
[10:30:54.257]                           version <- ns[[".package"]][["version"]]
[10:30:54.257]                           if (is.null(version)) 
[10:30:54.257]                             version <- utils::packageVersion("future")
[10:30:54.257]                         }
[10:30:54.257]                         else {
[10:30:54.257]                           version <- NULL
[10:30:54.257]                         }
[10:30:54.257]                         if (!has_future || version < "1.8.0") {
[10:30:54.257]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.257]                             "", base::R.version$version.string), 
[10:30:54.257]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.257]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.257]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.257]                               "release", "version")], collapse = " "), 
[10:30:54.257]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.257]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.257]                             info)
[10:30:54.257]                           info <- base::paste(info, collapse = "; ")
[10:30:54.257]                           if (!has_future) {
[10:30:54.257]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.257]                               info)
[10:30:54.257]                           }
[10:30:54.257]                           else {
[10:30:54.257]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.257]                               info, version)
[10:30:54.257]                           }
[10:30:54.257]                           base::stop(msg)
[10:30:54.257]                         }
[10:30:54.257]                       })
[10:30:54.257]                     }
[10:30:54.257]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.257]                     base::options(mc.cores = 1L)
[10:30:54.257]                   }
[10:30:54.257]                   ...future.strategy.old <- future::plan("list")
[10:30:54.257]                   options(future.plan = NULL)
[10:30:54.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.257]                 }
[10:30:54.257]                 ...future.workdir <- getwd()
[10:30:54.257]             }
[10:30:54.257]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.257]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.257]         }
[10:30:54.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.257]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.257]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.257]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.257]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.257]             base::names(...future.oldOptions))
[10:30:54.257]     }
[10:30:54.257]     if (FALSE) {
[10:30:54.257]     }
[10:30:54.257]     else {
[10:30:54.257]         if (TRUE) {
[10:30:54.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.257]                 open = "w")
[10:30:54.257]         }
[10:30:54.257]         else {
[10:30:54.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.257]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.257]         }
[10:30:54.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.257]             base::sink(type = "output", split = FALSE)
[10:30:54.257]             base::close(...future.stdout)
[10:30:54.257]         }, add = TRUE)
[10:30:54.257]     }
[10:30:54.257]     ...future.frame <- base::sys.nframe()
[10:30:54.257]     ...future.conditions <- base::list()
[10:30:54.257]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.257]     if (FALSE) {
[10:30:54.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.257]     }
[10:30:54.257]     ...future.result <- base::tryCatch({
[10:30:54.257]         base::withCallingHandlers({
[10:30:54.257]             ...future.value <- base::withVisible(base::local({
[10:30:54.257]                 ...future.makeSendCondition <- base::local({
[10:30:54.257]                   sendCondition <- NULL
[10:30:54.257]                   function(frame = 1L) {
[10:30:54.257]                     if (is.function(sendCondition)) 
[10:30:54.257]                       return(sendCondition)
[10:30:54.257]                     ns <- getNamespace("parallel")
[10:30:54.257]                     if (exists("sendData", mode = "function", 
[10:30:54.257]                       envir = ns)) {
[10:30:54.257]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.257]                         envir = ns)
[10:30:54.257]                       envir <- sys.frame(frame)
[10:30:54.257]                       master <- NULL
[10:30:54.257]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.257]                         !identical(envir, emptyenv())) {
[10:30:54.257]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.257]                           inherits = FALSE)) {
[10:30:54.257]                           master <- get("master", mode = "list", 
[10:30:54.257]                             envir = envir, inherits = FALSE)
[10:30:54.257]                           if (inherits(master, c("SOCKnode", 
[10:30:54.257]                             "SOCK0node"))) {
[10:30:54.257]                             sendCondition <<- function(cond) {
[10:30:54.257]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.257]                                 success = TRUE)
[10:30:54.257]                               parallel_sendData(master, data)
[10:30:54.257]                             }
[10:30:54.257]                             return(sendCondition)
[10:30:54.257]                           }
[10:30:54.257]                         }
[10:30:54.257]                         frame <- frame + 1L
[10:30:54.257]                         envir <- sys.frame(frame)
[10:30:54.257]                       }
[10:30:54.257]                     }
[10:30:54.257]                     sendCondition <<- function(cond) NULL
[10:30:54.257]                   }
[10:30:54.257]                 })
[10:30:54.257]                 withCallingHandlers({
[10:30:54.257]                   {
[10:30:54.257]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.257]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.257]                       ...future.globals.maxSize)) {
[10:30:54.257]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.257]                       on.exit(options(oopts), add = TRUE)
[10:30:54.257]                     }
[10:30:54.257]                     {
[10:30:54.257]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.257]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.257]                         USE.NAMES = FALSE)
[10:30:54.257]                       do.call(mapply, args = args)
[10:30:54.257]                     }
[10:30:54.257]                   }
[10:30:54.257]                 }, immediateCondition = function(cond) {
[10:30:54.257]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.257]                   sendCondition(cond)
[10:30:54.257]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.257]                   {
[10:30:54.257]                     inherits <- base::inherits
[10:30:54.257]                     invokeRestart <- base::invokeRestart
[10:30:54.257]                     is.null <- base::is.null
[10:30:54.257]                     muffled <- FALSE
[10:30:54.257]                     if (inherits(cond, "message")) {
[10:30:54.257]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.257]                       if (muffled) 
[10:30:54.257]                         invokeRestart("muffleMessage")
[10:30:54.257]                     }
[10:30:54.257]                     else if (inherits(cond, "warning")) {
[10:30:54.257]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.257]                       if (muffled) 
[10:30:54.257]                         invokeRestart("muffleWarning")
[10:30:54.257]                     }
[10:30:54.257]                     else if (inherits(cond, "condition")) {
[10:30:54.257]                       if (!is.null(pattern)) {
[10:30:54.257]                         computeRestarts <- base::computeRestarts
[10:30:54.257]                         grepl <- base::grepl
[10:30:54.257]                         restarts <- computeRestarts(cond)
[10:30:54.257]                         for (restart in restarts) {
[10:30:54.257]                           name <- restart$name
[10:30:54.257]                           if (is.null(name)) 
[10:30:54.257]                             next
[10:30:54.257]                           if (!grepl(pattern, name)) 
[10:30:54.257]                             next
[10:30:54.257]                           invokeRestart(restart)
[10:30:54.257]                           muffled <- TRUE
[10:30:54.257]                           break
[10:30:54.257]                         }
[10:30:54.257]                       }
[10:30:54.257]                     }
[10:30:54.257]                     invisible(muffled)
[10:30:54.257]                   }
[10:30:54.257]                   muffleCondition(cond)
[10:30:54.257]                 })
[10:30:54.257]             }))
[10:30:54.257]             future::FutureResult(value = ...future.value$value, 
[10:30:54.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.257]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.257]                     ...future.globalenv.names))
[10:30:54.257]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.257]         }, condition = base::local({
[10:30:54.257]             c <- base::c
[10:30:54.257]             inherits <- base::inherits
[10:30:54.257]             invokeRestart <- base::invokeRestart
[10:30:54.257]             length <- base::length
[10:30:54.257]             list <- base::list
[10:30:54.257]             seq.int <- base::seq.int
[10:30:54.257]             signalCondition <- base::signalCondition
[10:30:54.257]             sys.calls <- base::sys.calls
[10:30:54.257]             `[[` <- base::`[[`
[10:30:54.257]             `+` <- base::`+`
[10:30:54.257]             `<<-` <- base::`<<-`
[10:30:54.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.257]                   3L)]
[10:30:54.257]             }
[10:30:54.257]             function(cond) {
[10:30:54.257]                 is_error <- inherits(cond, "error")
[10:30:54.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.257]                   NULL)
[10:30:54.257]                 if (is_error) {
[10:30:54.257]                   sessionInformation <- function() {
[10:30:54.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.257]                       search = base::search(), system = base::Sys.info())
[10:30:54.257]                   }
[10:30:54.257]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.257]                     cond$call), session = sessionInformation(), 
[10:30:54.257]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.257]                   signalCondition(cond)
[10:30:54.257]                 }
[10:30:54.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.257]                 "immediateCondition"))) {
[10:30:54.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.257]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.257]                   if (TRUE && !signal) {
[10:30:54.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.257]                     {
[10:30:54.257]                       inherits <- base::inherits
[10:30:54.257]                       invokeRestart <- base::invokeRestart
[10:30:54.257]                       is.null <- base::is.null
[10:30:54.257]                       muffled <- FALSE
[10:30:54.257]                       if (inherits(cond, "message")) {
[10:30:54.257]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.257]                         if (muffled) 
[10:30:54.257]                           invokeRestart("muffleMessage")
[10:30:54.257]                       }
[10:30:54.257]                       else if (inherits(cond, "warning")) {
[10:30:54.257]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.257]                         if (muffled) 
[10:30:54.257]                           invokeRestart("muffleWarning")
[10:30:54.257]                       }
[10:30:54.257]                       else if (inherits(cond, "condition")) {
[10:30:54.257]                         if (!is.null(pattern)) {
[10:30:54.257]                           computeRestarts <- base::computeRestarts
[10:30:54.257]                           grepl <- base::grepl
[10:30:54.257]                           restarts <- computeRestarts(cond)
[10:30:54.257]                           for (restart in restarts) {
[10:30:54.257]                             name <- restart$name
[10:30:54.257]                             if (is.null(name)) 
[10:30:54.257]                               next
[10:30:54.257]                             if (!grepl(pattern, name)) 
[10:30:54.257]                               next
[10:30:54.257]                             invokeRestart(restart)
[10:30:54.257]                             muffled <- TRUE
[10:30:54.257]                             break
[10:30:54.257]                           }
[10:30:54.257]                         }
[10:30:54.257]                       }
[10:30:54.257]                       invisible(muffled)
[10:30:54.257]                     }
[10:30:54.257]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.257]                   }
[10:30:54.257]                 }
[10:30:54.257]                 else {
[10:30:54.257]                   if (TRUE) {
[10:30:54.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.257]                     {
[10:30:54.257]                       inherits <- base::inherits
[10:30:54.257]                       invokeRestart <- base::invokeRestart
[10:30:54.257]                       is.null <- base::is.null
[10:30:54.257]                       muffled <- FALSE
[10:30:54.257]                       if (inherits(cond, "message")) {
[10:30:54.257]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.257]                         if (muffled) 
[10:30:54.257]                           invokeRestart("muffleMessage")
[10:30:54.257]                       }
[10:30:54.257]                       else if (inherits(cond, "warning")) {
[10:30:54.257]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.257]                         if (muffled) 
[10:30:54.257]                           invokeRestart("muffleWarning")
[10:30:54.257]                       }
[10:30:54.257]                       else if (inherits(cond, "condition")) {
[10:30:54.257]                         if (!is.null(pattern)) {
[10:30:54.257]                           computeRestarts <- base::computeRestarts
[10:30:54.257]                           grepl <- base::grepl
[10:30:54.257]                           restarts <- computeRestarts(cond)
[10:30:54.257]                           for (restart in restarts) {
[10:30:54.257]                             name <- restart$name
[10:30:54.257]                             if (is.null(name)) 
[10:30:54.257]                               next
[10:30:54.257]                             if (!grepl(pattern, name)) 
[10:30:54.257]                               next
[10:30:54.257]                             invokeRestart(restart)
[10:30:54.257]                             muffled <- TRUE
[10:30:54.257]                             break
[10:30:54.257]                           }
[10:30:54.257]                         }
[10:30:54.257]                       }
[10:30:54.257]                       invisible(muffled)
[10:30:54.257]                     }
[10:30:54.257]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.257]                   }
[10:30:54.257]                 }
[10:30:54.257]             }
[10:30:54.257]         }))
[10:30:54.257]     }, error = function(ex) {
[10:30:54.257]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.257]                 ...future.rng), started = ...future.startTime, 
[10:30:54.257]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.257]             version = "1.8"), class = "FutureResult")
[10:30:54.257]     }, finally = {
[10:30:54.257]         if (!identical(...future.workdir, getwd())) 
[10:30:54.257]             setwd(...future.workdir)
[10:30:54.257]         {
[10:30:54.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.257]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.257]             }
[10:30:54.257]             base::options(...future.oldOptions)
[10:30:54.257]             if (.Platform$OS.type == "windows") {
[10:30:54.257]                 old_names <- names(...future.oldEnvVars)
[10:30:54.257]                 envs <- base::Sys.getenv()
[10:30:54.257]                 names <- names(envs)
[10:30:54.257]                 common <- intersect(names, old_names)
[10:30:54.257]                 added <- setdiff(names, old_names)
[10:30:54.257]                 removed <- setdiff(old_names, names)
[10:30:54.257]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.257]                   envs[common]]
[10:30:54.257]                 NAMES <- toupper(changed)
[10:30:54.257]                 args <- list()
[10:30:54.257]                 for (kk in seq_along(NAMES)) {
[10:30:54.257]                   name <- changed[[kk]]
[10:30:54.257]                   NAME <- NAMES[[kk]]
[10:30:54.257]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.257]                     next
[10:30:54.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.257]                 }
[10:30:54.257]                 NAMES <- toupper(added)
[10:30:54.257]                 for (kk in seq_along(NAMES)) {
[10:30:54.257]                   name <- added[[kk]]
[10:30:54.257]                   NAME <- NAMES[[kk]]
[10:30:54.257]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.257]                     next
[10:30:54.257]                   args[[name]] <- ""
[10:30:54.257]                 }
[10:30:54.257]                 NAMES <- toupper(removed)
[10:30:54.257]                 for (kk in seq_along(NAMES)) {
[10:30:54.257]                   name <- removed[[kk]]
[10:30:54.257]                   NAME <- NAMES[[kk]]
[10:30:54.257]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.257]                     next
[10:30:54.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.257]                 }
[10:30:54.257]                 if (length(args) > 0) 
[10:30:54.257]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.257]             }
[10:30:54.257]             else {
[10:30:54.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.257]             }
[10:30:54.257]             {
[10:30:54.257]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.257]                   0L) {
[10:30:54.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.257]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.257]                   base::options(opts)
[10:30:54.257]                 }
[10:30:54.257]                 {
[10:30:54.257]                   {
[10:30:54.257]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.257]                     NULL
[10:30:54.257]                   }
[10:30:54.257]                   options(future.plan = NULL)
[10:30:54.257]                   if (is.na(NA_character_)) 
[10:30:54.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.257]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.257]                     .init = FALSE)
[10:30:54.257]                 }
[10:30:54.257]             }
[10:30:54.257]         }
[10:30:54.257]     })
[10:30:54.257]     if (TRUE) {
[10:30:54.257]         base::sink(type = "output", split = FALSE)
[10:30:54.257]         if (TRUE) {
[10:30:54.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.257]         }
[10:30:54.257]         else {
[10:30:54.257]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.257]         }
[10:30:54.257]         base::close(...future.stdout)
[10:30:54.257]         ...future.stdout <- NULL
[10:30:54.257]     }
[10:30:54.257]     ...future.result$conditions <- ...future.conditions
[10:30:54.257]     ...future.result$finished <- base::Sys.time()
[10:30:54.257]     ...future.result
[10:30:54.257] }
[10:30:54.260] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[10:30:54.260] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[10:30:54.260] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[10:30:54.260] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:54.261] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.261] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[10:30:54.261] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[10:30:54.262] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:54.262] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.262] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:54.262] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.263] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[10:30:54.263] MultisessionFuture started
[10:30:54.263] - Launch lazy future ... done
[10:30:54.263] run() for ‘MultisessionFuture’ ... done
[10:30:54.264] Created future:
[10:30:54.264] MultisessionFuture:
[10:30:54.264] Label: ‘future_.mapply-1’
[10:30:54.264] Expression:
[10:30:54.264] {
[10:30:54.264]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.264]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.264]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.264]         on.exit(options(oopts), add = TRUE)
[10:30:54.264]     }
[10:30:54.264]     {
[10:30:54.264]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.264]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.264]         do.call(mapply, args = args)
[10:30:54.264]     }
[10:30:54.264] }
[10:30:54.264] Lazy evaluation: FALSE
[10:30:54.264] Asynchronous evaluation: TRUE
[10:30:54.264] Local evaluation: TRUE
[10:30:54.264] Environment: R_GlobalEnv
[10:30:54.264] Capture standard output: TRUE
[10:30:54.264] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.264] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.264] Packages: <none>
[10:30:54.264] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.264] Resolved: FALSE
[10:30:54.264] Value: <not collected>
[10:30:54.264] Conditions captured: <none>
[10:30:54.264] Early signaling: FALSE
[10:30:54.264] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.264] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.275] Chunk #1 of 2 ... DONE
[10:30:54.275] Chunk #2 of 2 ...
[10:30:54.275]  - Finding globals in '...' for chunk #2 ...
[10:30:54.276] getGlobalsAndPackages() ...
[10:30:54.276] Searching for globals...
[10:30:54.276] 
[10:30:54.276] Searching for globals ... DONE
[10:30:54.276] - globals: [0] <none>
[10:30:54.276] getGlobalsAndPackages() ... DONE
[10:30:54.276]    + additional globals found: [n=0] 
[10:30:54.276]    + additional namespaces needed: [n=0] 
[10:30:54.277]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:54.277]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.277]  - seeds: <none>
[10:30:54.277]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.277] getGlobalsAndPackages() ...
[10:30:54.277] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.277] Resolving globals: FALSE
[10:30:54.278] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[10:30:54.278] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:54.278] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.278] 
[10:30:54.279] getGlobalsAndPackages() ... DONE
[10:30:54.279] run() for ‘Future’ ...
[10:30:54.279] - state: ‘created’
[10:30:54.279] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.293] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.293]   - Field: ‘node’
[10:30:54.294]   - Field: ‘label’
[10:30:54.294]   - Field: ‘local’
[10:30:54.294]   - Field: ‘owner’
[10:30:54.294]   - Field: ‘envir’
[10:30:54.294]   - Field: ‘workers’
[10:30:54.294]   - Field: ‘packages’
[10:30:54.294]   - Field: ‘gc’
[10:30:54.294]   - Field: ‘conditions’
[10:30:54.294]   - Field: ‘persistent’
[10:30:54.294]   - Field: ‘expr’
[10:30:54.294]   - Field: ‘uuid’
[10:30:54.295]   - Field: ‘seed’
[10:30:54.295]   - Field: ‘version’
[10:30:54.295]   - Field: ‘result’
[10:30:54.295]   - Field: ‘asynchronous’
[10:30:54.295]   - Field: ‘calls’
[10:30:54.295]   - Field: ‘globals’
[10:30:54.295]   - Field: ‘stdout’
[10:30:54.295]   - Field: ‘earlySignal’
[10:30:54.295]   - Field: ‘lazy’
[10:30:54.295]   - Field: ‘state’
[10:30:54.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.296] - Launch lazy future ...
[10:30:54.296] Packages needed by the future expression (n = 0): <none>
[10:30:54.296] Packages needed by future strategies (n = 0): <none>
[10:30:54.296] {
[10:30:54.296]     {
[10:30:54.296]         {
[10:30:54.296]             ...future.startTime <- base::Sys.time()
[10:30:54.296]             {
[10:30:54.296]                 {
[10:30:54.296]                   {
[10:30:54.296]                     {
[10:30:54.296]                       base::local({
[10:30:54.296]                         has_future <- base::requireNamespace("future", 
[10:30:54.296]                           quietly = TRUE)
[10:30:54.296]                         if (has_future) {
[10:30:54.296]                           ns <- base::getNamespace("future")
[10:30:54.296]                           version <- ns[[".package"]][["version"]]
[10:30:54.296]                           if (is.null(version)) 
[10:30:54.296]                             version <- utils::packageVersion("future")
[10:30:54.296]                         }
[10:30:54.296]                         else {
[10:30:54.296]                           version <- NULL
[10:30:54.296]                         }
[10:30:54.296]                         if (!has_future || version < "1.8.0") {
[10:30:54.296]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.296]                             "", base::R.version$version.string), 
[10:30:54.296]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.296]                               "release", "version")], collapse = " "), 
[10:30:54.296]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.296]                             info)
[10:30:54.296]                           info <- base::paste(info, collapse = "; ")
[10:30:54.296]                           if (!has_future) {
[10:30:54.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.296]                               info)
[10:30:54.296]                           }
[10:30:54.296]                           else {
[10:30:54.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.296]                               info, version)
[10:30:54.296]                           }
[10:30:54.296]                           base::stop(msg)
[10:30:54.296]                         }
[10:30:54.296]                       })
[10:30:54.296]                     }
[10:30:54.296]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.296]                     base::options(mc.cores = 1L)
[10:30:54.296]                   }
[10:30:54.296]                   ...future.strategy.old <- future::plan("list")
[10:30:54.296]                   options(future.plan = NULL)
[10:30:54.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.296]                 }
[10:30:54.296]                 ...future.workdir <- getwd()
[10:30:54.296]             }
[10:30:54.296]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.296]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.296]         }
[10:30:54.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.296]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.296]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.296]             base::names(...future.oldOptions))
[10:30:54.296]     }
[10:30:54.296]     if (FALSE) {
[10:30:54.296]     }
[10:30:54.296]     else {
[10:30:54.296]         if (TRUE) {
[10:30:54.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.296]                 open = "w")
[10:30:54.296]         }
[10:30:54.296]         else {
[10:30:54.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.296]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.296]         }
[10:30:54.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.296]             base::sink(type = "output", split = FALSE)
[10:30:54.296]             base::close(...future.stdout)
[10:30:54.296]         }, add = TRUE)
[10:30:54.296]     }
[10:30:54.296]     ...future.frame <- base::sys.nframe()
[10:30:54.296]     ...future.conditions <- base::list()
[10:30:54.296]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.296]     if (FALSE) {
[10:30:54.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.296]     }
[10:30:54.296]     ...future.result <- base::tryCatch({
[10:30:54.296]         base::withCallingHandlers({
[10:30:54.296]             ...future.value <- base::withVisible(base::local({
[10:30:54.296]                 ...future.makeSendCondition <- base::local({
[10:30:54.296]                   sendCondition <- NULL
[10:30:54.296]                   function(frame = 1L) {
[10:30:54.296]                     if (is.function(sendCondition)) 
[10:30:54.296]                       return(sendCondition)
[10:30:54.296]                     ns <- getNamespace("parallel")
[10:30:54.296]                     if (exists("sendData", mode = "function", 
[10:30:54.296]                       envir = ns)) {
[10:30:54.296]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.296]                         envir = ns)
[10:30:54.296]                       envir <- sys.frame(frame)
[10:30:54.296]                       master <- NULL
[10:30:54.296]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.296]                         !identical(envir, emptyenv())) {
[10:30:54.296]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.296]                           inherits = FALSE)) {
[10:30:54.296]                           master <- get("master", mode = "list", 
[10:30:54.296]                             envir = envir, inherits = FALSE)
[10:30:54.296]                           if (inherits(master, c("SOCKnode", 
[10:30:54.296]                             "SOCK0node"))) {
[10:30:54.296]                             sendCondition <<- function(cond) {
[10:30:54.296]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.296]                                 success = TRUE)
[10:30:54.296]                               parallel_sendData(master, data)
[10:30:54.296]                             }
[10:30:54.296]                             return(sendCondition)
[10:30:54.296]                           }
[10:30:54.296]                         }
[10:30:54.296]                         frame <- frame + 1L
[10:30:54.296]                         envir <- sys.frame(frame)
[10:30:54.296]                       }
[10:30:54.296]                     }
[10:30:54.296]                     sendCondition <<- function(cond) NULL
[10:30:54.296]                   }
[10:30:54.296]                 })
[10:30:54.296]                 withCallingHandlers({
[10:30:54.296]                   {
[10:30:54.296]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.296]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.296]                       ...future.globals.maxSize)) {
[10:30:54.296]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.296]                       on.exit(options(oopts), add = TRUE)
[10:30:54.296]                     }
[10:30:54.296]                     {
[10:30:54.296]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.296]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.296]                         USE.NAMES = FALSE)
[10:30:54.296]                       do.call(mapply, args = args)
[10:30:54.296]                     }
[10:30:54.296]                   }
[10:30:54.296]                 }, immediateCondition = function(cond) {
[10:30:54.296]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.296]                   sendCondition(cond)
[10:30:54.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.296]                   {
[10:30:54.296]                     inherits <- base::inherits
[10:30:54.296]                     invokeRestart <- base::invokeRestart
[10:30:54.296]                     is.null <- base::is.null
[10:30:54.296]                     muffled <- FALSE
[10:30:54.296]                     if (inherits(cond, "message")) {
[10:30:54.296]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.296]                       if (muffled) 
[10:30:54.296]                         invokeRestart("muffleMessage")
[10:30:54.296]                     }
[10:30:54.296]                     else if (inherits(cond, "warning")) {
[10:30:54.296]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.296]                       if (muffled) 
[10:30:54.296]                         invokeRestart("muffleWarning")
[10:30:54.296]                     }
[10:30:54.296]                     else if (inherits(cond, "condition")) {
[10:30:54.296]                       if (!is.null(pattern)) {
[10:30:54.296]                         computeRestarts <- base::computeRestarts
[10:30:54.296]                         grepl <- base::grepl
[10:30:54.296]                         restarts <- computeRestarts(cond)
[10:30:54.296]                         for (restart in restarts) {
[10:30:54.296]                           name <- restart$name
[10:30:54.296]                           if (is.null(name)) 
[10:30:54.296]                             next
[10:30:54.296]                           if (!grepl(pattern, name)) 
[10:30:54.296]                             next
[10:30:54.296]                           invokeRestart(restart)
[10:30:54.296]                           muffled <- TRUE
[10:30:54.296]                           break
[10:30:54.296]                         }
[10:30:54.296]                       }
[10:30:54.296]                     }
[10:30:54.296]                     invisible(muffled)
[10:30:54.296]                   }
[10:30:54.296]                   muffleCondition(cond)
[10:30:54.296]                 })
[10:30:54.296]             }))
[10:30:54.296]             future::FutureResult(value = ...future.value$value, 
[10:30:54.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.296]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.296]                     ...future.globalenv.names))
[10:30:54.296]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.296]         }, condition = base::local({
[10:30:54.296]             c <- base::c
[10:30:54.296]             inherits <- base::inherits
[10:30:54.296]             invokeRestart <- base::invokeRestart
[10:30:54.296]             length <- base::length
[10:30:54.296]             list <- base::list
[10:30:54.296]             seq.int <- base::seq.int
[10:30:54.296]             signalCondition <- base::signalCondition
[10:30:54.296]             sys.calls <- base::sys.calls
[10:30:54.296]             `[[` <- base::`[[`
[10:30:54.296]             `+` <- base::`+`
[10:30:54.296]             `<<-` <- base::`<<-`
[10:30:54.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.296]                   3L)]
[10:30:54.296]             }
[10:30:54.296]             function(cond) {
[10:30:54.296]                 is_error <- inherits(cond, "error")
[10:30:54.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.296]                   NULL)
[10:30:54.296]                 if (is_error) {
[10:30:54.296]                   sessionInformation <- function() {
[10:30:54.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.296]                       search = base::search(), system = base::Sys.info())
[10:30:54.296]                   }
[10:30:54.296]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.296]                     cond$call), session = sessionInformation(), 
[10:30:54.296]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.296]                   signalCondition(cond)
[10:30:54.296]                 }
[10:30:54.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.296]                 "immediateCondition"))) {
[10:30:54.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.296]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.296]                   if (TRUE && !signal) {
[10:30:54.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.296]                     {
[10:30:54.296]                       inherits <- base::inherits
[10:30:54.296]                       invokeRestart <- base::invokeRestart
[10:30:54.296]                       is.null <- base::is.null
[10:30:54.296]                       muffled <- FALSE
[10:30:54.296]                       if (inherits(cond, "message")) {
[10:30:54.296]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.296]                         if (muffled) 
[10:30:54.296]                           invokeRestart("muffleMessage")
[10:30:54.296]                       }
[10:30:54.296]                       else if (inherits(cond, "warning")) {
[10:30:54.296]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.296]                         if (muffled) 
[10:30:54.296]                           invokeRestart("muffleWarning")
[10:30:54.296]                       }
[10:30:54.296]                       else if (inherits(cond, "condition")) {
[10:30:54.296]                         if (!is.null(pattern)) {
[10:30:54.296]                           computeRestarts <- base::computeRestarts
[10:30:54.296]                           grepl <- base::grepl
[10:30:54.296]                           restarts <- computeRestarts(cond)
[10:30:54.296]                           for (restart in restarts) {
[10:30:54.296]                             name <- restart$name
[10:30:54.296]                             if (is.null(name)) 
[10:30:54.296]                               next
[10:30:54.296]                             if (!grepl(pattern, name)) 
[10:30:54.296]                               next
[10:30:54.296]                             invokeRestart(restart)
[10:30:54.296]                             muffled <- TRUE
[10:30:54.296]                             break
[10:30:54.296]                           }
[10:30:54.296]                         }
[10:30:54.296]                       }
[10:30:54.296]                       invisible(muffled)
[10:30:54.296]                     }
[10:30:54.296]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.296]                   }
[10:30:54.296]                 }
[10:30:54.296]                 else {
[10:30:54.296]                   if (TRUE) {
[10:30:54.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.296]                     {
[10:30:54.296]                       inherits <- base::inherits
[10:30:54.296]                       invokeRestart <- base::invokeRestart
[10:30:54.296]                       is.null <- base::is.null
[10:30:54.296]                       muffled <- FALSE
[10:30:54.296]                       if (inherits(cond, "message")) {
[10:30:54.296]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.296]                         if (muffled) 
[10:30:54.296]                           invokeRestart("muffleMessage")
[10:30:54.296]                       }
[10:30:54.296]                       else if (inherits(cond, "warning")) {
[10:30:54.296]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.296]                         if (muffled) 
[10:30:54.296]                           invokeRestart("muffleWarning")
[10:30:54.296]                       }
[10:30:54.296]                       else if (inherits(cond, "condition")) {
[10:30:54.296]                         if (!is.null(pattern)) {
[10:30:54.296]                           computeRestarts <- base::computeRestarts
[10:30:54.296]                           grepl <- base::grepl
[10:30:54.296]                           restarts <- computeRestarts(cond)
[10:30:54.296]                           for (restart in restarts) {
[10:30:54.296]                             name <- restart$name
[10:30:54.296]                             if (is.null(name)) 
[10:30:54.296]                               next
[10:30:54.296]                             if (!grepl(pattern, name)) 
[10:30:54.296]                               next
[10:30:54.296]                             invokeRestart(restart)
[10:30:54.296]                             muffled <- TRUE
[10:30:54.296]                             break
[10:30:54.296]                           }
[10:30:54.296]                         }
[10:30:54.296]                       }
[10:30:54.296]                       invisible(muffled)
[10:30:54.296]                     }
[10:30:54.296]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.296]                   }
[10:30:54.296]                 }
[10:30:54.296]             }
[10:30:54.296]         }))
[10:30:54.296]     }, error = function(ex) {
[10:30:54.296]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.296]                 ...future.rng), started = ...future.startTime, 
[10:30:54.296]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.296]             version = "1.8"), class = "FutureResult")
[10:30:54.296]     }, finally = {
[10:30:54.296]         if (!identical(...future.workdir, getwd())) 
[10:30:54.296]             setwd(...future.workdir)
[10:30:54.296]         {
[10:30:54.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.296]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.296]             }
[10:30:54.296]             base::options(...future.oldOptions)
[10:30:54.296]             if (.Platform$OS.type == "windows") {
[10:30:54.296]                 old_names <- names(...future.oldEnvVars)
[10:30:54.296]                 envs <- base::Sys.getenv()
[10:30:54.296]                 names <- names(envs)
[10:30:54.296]                 common <- intersect(names, old_names)
[10:30:54.296]                 added <- setdiff(names, old_names)
[10:30:54.296]                 removed <- setdiff(old_names, names)
[10:30:54.296]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.296]                   envs[common]]
[10:30:54.296]                 NAMES <- toupper(changed)
[10:30:54.296]                 args <- list()
[10:30:54.296]                 for (kk in seq_along(NAMES)) {
[10:30:54.296]                   name <- changed[[kk]]
[10:30:54.296]                   NAME <- NAMES[[kk]]
[10:30:54.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.296]                     next
[10:30:54.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.296]                 }
[10:30:54.296]                 NAMES <- toupper(added)
[10:30:54.296]                 for (kk in seq_along(NAMES)) {
[10:30:54.296]                   name <- added[[kk]]
[10:30:54.296]                   NAME <- NAMES[[kk]]
[10:30:54.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.296]                     next
[10:30:54.296]                   args[[name]] <- ""
[10:30:54.296]                 }
[10:30:54.296]                 NAMES <- toupper(removed)
[10:30:54.296]                 for (kk in seq_along(NAMES)) {
[10:30:54.296]                   name <- removed[[kk]]
[10:30:54.296]                   NAME <- NAMES[[kk]]
[10:30:54.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.296]                     next
[10:30:54.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.296]                 }
[10:30:54.296]                 if (length(args) > 0) 
[10:30:54.296]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.296]             }
[10:30:54.296]             else {
[10:30:54.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.296]             }
[10:30:54.296]             {
[10:30:54.296]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.296]                   0L) {
[10:30:54.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.296]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.296]                   base::options(opts)
[10:30:54.296]                 }
[10:30:54.296]                 {
[10:30:54.296]                   {
[10:30:54.296]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.296]                     NULL
[10:30:54.296]                   }
[10:30:54.296]                   options(future.plan = NULL)
[10:30:54.296]                   if (is.na(NA_character_)) 
[10:30:54.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.296]                     .init = FALSE)
[10:30:54.296]                 }
[10:30:54.296]             }
[10:30:54.296]         }
[10:30:54.296]     })
[10:30:54.296]     if (TRUE) {
[10:30:54.296]         base::sink(type = "output", split = FALSE)
[10:30:54.296]         if (TRUE) {
[10:30:54.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.296]         }
[10:30:54.296]         else {
[10:30:54.296]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.296]         }
[10:30:54.296]         base::close(...future.stdout)
[10:30:54.296]         ...future.stdout <- NULL
[10:30:54.296]     }
[10:30:54.296]     ...future.result$conditions <- ...future.conditions
[10:30:54.296]     ...future.result$finished <- base::Sys.time()
[10:30:54.296]     ...future.result
[10:30:54.296] }
[10:30:54.299] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[10:30:54.299] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[10:30:54.300] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[10:30:54.300] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:54.300] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.301] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[10:30:54.301] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[10:30:54.301] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:54.301] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.302] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:54.302] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.302] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[10:30:54.303] MultisessionFuture started
[10:30:54.303] - Launch lazy future ... done
[10:30:54.303] run() for ‘MultisessionFuture’ ... done
[10:30:54.303] Created future:
[10:30:54.303] MultisessionFuture:
[10:30:54.303] Label: ‘future_.mapply-2’
[10:30:54.303] Expression:
[10:30:54.303] {
[10:30:54.303]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.303]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.303]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.303]         on.exit(options(oopts), add = TRUE)
[10:30:54.303]     }
[10:30:54.303]     {
[10:30:54.303]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.303]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.303]         do.call(mapply, args = args)
[10:30:54.303]     }
[10:30:54.303] }
[10:30:54.303] Lazy evaluation: FALSE
[10:30:54.303] Asynchronous evaluation: TRUE
[10:30:54.303] Local evaluation: TRUE
[10:30:54.303] Environment: R_GlobalEnv
[10:30:54.303] Capture standard output: TRUE
[10:30:54.303] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.303] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.303] Packages: <none>
[10:30:54.303] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.303] Resolved: FALSE
[10:30:54.303] Value: <not collected>
[10:30:54.303] Conditions captured: <none>
[10:30:54.303] Early signaling: FALSE
[10:30:54.303] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.303] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.315] Chunk #2 of 2 ... DONE
[10:30:54.315] Launching 2 futures (chunks) ... DONE
[10:30:54.315] Resolving 2 futures (chunks) ...
[10:30:54.315] resolve() on list ...
[10:30:54.315]  recursive: 0
[10:30:54.315]  length: 2
[10:30:54.315] 
[10:30:54.316] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.316] - Validating connection of MultisessionFuture
[10:30:54.316] - received message: FutureResult
[10:30:54.316] - Received FutureResult
[10:30:54.317] - Erased future from FutureRegistry
[10:30:54.317] result() for ClusterFuture ...
[10:30:54.317] - result already collected: FutureResult
[10:30:54.317] result() for ClusterFuture ... done
[10:30:54.317] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.317] Future #1
[10:30:54.317] result() for ClusterFuture ...
[10:30:54.317] - result already collected: FutureResult
[10:30:54.317] result() for ClusterFuture ... done
[10:30:54.318] result() for ClusterFuture ...
[10:30:54.318] - result already collected: FutureResult
[10:30:54.318] result() for ClusterFuture ... done
[10:30:54.318] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:54.318] - nx: 2
[10:30:54.318] - relay: TRUE
[10:30:54.318] - stdout: TRUE
[10:30:54.318] - signal: TRUE
[10:30:54.318] - resignal: FALSE
[10:30:54.318] - force: TRUE
[10:30:54.318] - relayed: [n=2] FALSE, FALSE
[10:30:54.318] - queued futures: [n=2] FALSE, FALSE
[10:30:54.319]  - until=1
[10:30:54.319]  - relaying element #1
[10:30:54.319] result() for ClusterFuture ...
[10:30:54.319] - result already collected: FutureResult
[10:30:54.319] result() for ClusterFuture ... done
[10:30:54.319] result() for ClusterFuture ...
[10:30:54.319] - result already collected: FutureResult
[10:30:54.319] result() for ClusterFuture ... done
[10:30:54.319] result() for ClusterFuture ...
[10:30:54.319] - result already collected: FutureResult
[10:30:54.319] result() for ClusterFuture ... done
[10:30:54.320] result() for ClusterFuture ...
[10:30:54.320] - result already collected: FutureResult
[10:30:54.320] result() for ClusterFuture ... done
[10:30:54.320] - relayed: [n=2] TRUE, FALSE
[10:30:54.320] - queued futures: [n=2] TRUE, FALSE
[10:30:54.320] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:54.320]  length: 1 (resolved future 1)
[10:30:54.347] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.347] - Validating connection of MultisessionFuture
[10:30:54.347] - received message: FutureResult
[10:30:54.347] - Received FutureResult
[10:30:54.347] - Erased future from FutureRegistry
[10:30:54.347] result() for ClusterFuture ...
[10:30:54.348] - result already collected: FutureResult
[10:30:54.348] result() for ClusterFuture ... done
[10:30:54.348] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.348] Future #2
[10:30:54.348] result() for ClusterFuture ...
[10:30:54.348] - result already collected: FutureResult
[10:30:54.348] result() for ClusterFuture ... done
[10:30:54.348] result() for ClusterFuture ...
[10:30:54.348] - result already collected: FutureResult
[10:30:54.348] result() for ClusterFuture ... done
[10:30:54.348] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:54.349] - nx: 2
[10:30:54.349] - relay: TRUE
[10:30:54.349] - stdout: TRUE
[10:30:54.349] - signal: TRUE
[10:30:54.349] - resignal: FALSE
[10:30:54.349] - force: TRUE
[10:30:54.349] - relayed: [n=2] TRUE, FALSE
[10:30:54.349] - queued futures: [n=2] TRUE, FALSE
[10:30:54.349]  - until=2
[10:30:54.349]  - relaying element #2
[10:30:54.349] result() for ClusterFuture ...
[10:30:54.350] - result already collected: FutureResult
[10:30:54.350] result() for ClusterFuture ... done
[10:30:54.350] result() for ClusterFuture ...
[10:30:54.350] - result already collected: FutureResult
[10:30:54.350] result() for ClusterFuture ... done
[10:30:54.350] result() for ClusterFuture ...
[10:30:54.350] - result already collected: FutureResult
[10:30:54.350] result() for ClusterFuture ... done
[10:30:54.350] result() for ClusterFuture ...
[10:30:54.350] - result already collected: FutureResult
[10:30:54.351] result() for ClusterFuture ... done
[10:30:54.351] - relayed: [n=2] TRUE, TRUE
[10:30:54.351] - queued futures: [n=2] TRUE, TRUE
[10:30:54.351] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:54.351]  length: 0 (resolved future 2)
[10:30:54.351] Relaying remaining futures
[10:30:54.351] signalConditionsASAP(NULL, pos=0) ...
[10:30:54.351] - nx: 2
[10:30:54.351] - relay: TRUE
[10:30:54.351] - stdout: TRUE
[10:30:54.351] - signal: TRUE
[10:30:54.351] - resignal: FALSE
[10:30:54.352] - force: TRUE
[10:30:54.352] - relayed: [n=2] TRUE, TRUE
[10:30:54.352] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:54.352] - relayed: [n=2] TRUE, TRUE
[10:30:54.352] - queued futures: [n=2] TRUE, TRUE
[10:30:54.352] signalConditionsASAP(NULL, pos=0) ... done
[10:30:54.352] resolve() on list ... DONE
[10:30:54.352] result() for ClusterFuture ...
[10:30:54.352] - result already collected: FutureResult
[10:30:54.352] result() for ClusterFuture ... done
[10:30:54.352] result() for ClusterFuture ...
[10:30:54.353] - result already collected: FutureResult
[10:30:54.353] result() for ClusterFuture ... done
[10:30:54.353] result() for ClusterFuture ...
[10:30:54.353] - result already collected: FutureResult
[10:30:54.353] result() for ClusterFuture ... done
[10:30:54.353] result() for ClusterFuture ...
[10:30:54.353] - result already collected: FutureResult
[10:30:54.353] result() for ClusterFuture ... done
[10:30:54.353]  - Number of value chunks collected: 2
[10:30:54.353] Resolving 2 futures (chunks) ... DONE
[10:30:54.353] Reducing values from 2 chunks ...
[10:30:54.354]  - Number of values collected after concatenation: 5
[10:30:54.354]  - Number of values expected: 5
[10:30:54.354] Reducing values from 2 chunks ... DONE
[10:30:54.354] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[10:30:54.354] future_mapply() ...
[10:30:54.358] Number of chunks: 1
[10:30:54.358] getGlobalsAndPackagesXApply() ...
[10:30:54.358]  - future.globals: TRUE
[10:30:54.358] getGlobalsAndPackages() ...
[10:30:54.358] Searching for globals...
[10:30:54.359] - globals found: [1] ‘FUN’
[10:30:54.360] Searching for globals ... DONE
[10:30:54.360] Resolving globals: FALSE
[10:30:54.360] The total size of the 1 globals is 848 bytes (848 bytes)
[10:30:54.360] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:30:54.360] - globals: [1] ‘FUN’
[10:30:54.361] 
[10:30:54.361] getGlobalsAndPackages() ... DONE
[10:30:54.361]  - globals found/used: [n=1] ‘FUN’
[10:30:54.361]  - needed namespaces: [n=0] 
[10:30:54.361] Finding globals ... DONE
[10:30:54.361] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:54.361] List of 2
[10:30:54.361]  $ ...future.FUN:function (x)  
[10:30:54.361]  $ MoreArgs     : NULL
[10:30:54.361]  - attr(*, "where")=List of 2
[10:30:54.361]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:54.361]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:54.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:54.361]  - attr(*, "resolved")= logi FALSE
[10:30:54.361]  - attr(*, "total_size")= num NA
[10:30:54.364] Packages to be attached in all futures: [n=0] 
[10:30:54.364] getGlobalsAndPackagesXApply() ... DONE
[10:30:54.364] Number of futures (= number of chunks): 1
[10:30:54.364] Launching 1 futures (chunks) ...
[10:30:54.364] Chunk #1 of 1 ...
[10:30:54.364]  - Finding globals in '...' for chunk #1 ...
[10:30:54.365] getGlobalsAndPackages() ...
[10:30:54.365] Searching for globals...
[10:30:54.365] 
[10:30:54.365] Searching for globals ... DONE
[10:30:54.365] - globals: [0] <none>
[10:30:54.365] getGlobalsAndPackages() ... DONE
[10:30:54.365]    + additional globals found: [n=0] 
[10:30:54.366]    + additional namespaces needed: [n=0] 
[10:30:54.366]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:54.366]  - seeds: <none>
[10:30:54.366]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.368] getGlobalsAndPackages() ...
[10:30:54.369] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.369] Resolving globals: FALSE
[10:30:54.369] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[10:30:54.370] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:54.370] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.370] 
[10:30:54.370] getGlobalsAndPackages() ... DONE
[10:30:54.370] run() for ‘Future’ ...
[10:30:54.370] - state: ‘created’
[10:30:54.371] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.384] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.384]   - Field: ‘node’
[10:30:54.385]   - Field: ‘label’
[10:30:54.385]   - Field: ‘local’
[10:30:54.385]   - Field: ‘owner’
[10:30:54.385]   - Field: ‘envir’
[10:30:54.385]   - Field: ‘workers’
[10:30:54.385]   - Field: ‘packages’
[10:30:54.385]   - Field: ‘gc’
[10:30:54.385]   - Field: ‘conditions’
[10:30:54.385]   - Field: ‘persistent’
[10:30:54.385]   - Field: ‘expr’
[10:30:54.385]   - Field: ‘uuid’
[10:30:54.386]   - Field: ‘seed’
[10:30:54.386]   - Field: ‘version’
[10:30:54.386]   - Field: ‘result’
[10:30:54.386]   - Field: ‘asynchronous’
[10:30:54.386]   - Field: ‘calls’
[10:30:54.386]   - Field: ‘globals’
[10:30:54.386]   - Field: ‘stdout’
[10:30:54.386]   - Field: ‘earlySignal’
[10:30:54.386]   - Field: ‘lazy’
[10:30:54.386]   - Field: ‘state’
[10:30:54.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.387] - Launch lazy future ...
[10:30:54.387] Packages needed by the future expression (n = 0): <none>
[10:30:54.387] Packages needed by future strategies (n = 0): <none>
[10:30:54.387] {
[10:30:54.387]     {
[10:30:54.387]         {
[10:30:54.387]             ...future.startTime <- base::Sys.time()
[10:30:54.387]             {
[10:30:54.387]                 {
[10:30:54.387]                   {
[10:30:54.387]                     {
[10:30:54.387]                       base::local({
[10:30:54.387]                         has_future <- base::requireNamespace("future", 
[10:30:54.387]                           quietly = TRUE)
[10:30:54.387]                         if (has_future) {
[10:30:54.387]                           ns <- base::getNamespace("future")
[10:30:54.387]                           version <- ns[[".package"]][["version"]]
[10:30:54.387]                           if (is.null(version)) 
[10:30:54.387]                             version <- utils::packageVersion("future")
[10:30:54.387]                         }
[10:30:54.387]                         else {
[10:30:54.387]                           version <- NULL
[10:30:54.387]                         }
[10:30:54.387]                         if (!has_future || version < "1.8.0") {
[10:30:54.387]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.387]                             "", base::R.version$version.string), 
[10:30:54.387]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.387]                               "release", "version")], collapse = " "), 
[10:30:54.387]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.387]                             info)
[10:30:54.387]                           info <- base::paste(info, collapse = "; ")
[10:30:54.387]                           if (!has_future) {
[10:30:54.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.387]                               info)
[10:30:54.387]                           }
[10:30:54.387]                           else {
[10:30:54.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.387]                               info, version)
[10:30:54.387]                           }
[10:30:54.387]                           base::stop(msg)
[10:30:54.387]                         }
[10:30:54.387]                       })
[10:30:54.387]                     }
[10:30:54.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.387]                     base::options(mc.cores = 1L)
[10:30:54.387]                   }
[10:30:54.387]                   ...future.strategy.old <- future::plan("list")
[10:30:54.387]                   options(future.plan = NULL)
[10:30:54.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.387]                 }
[10:30:54.387]                 ...future.workdir <- getwd()
[10:30:54.387]             }
[10:30:54.387]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.387]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.387]         }
[10:30:54.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:54.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.387]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.387]             base::names(...future.oldOptions))
[10:30:54.387]     }
[10:30:54.387]     if (FALSE) {
[10:30:54.387]     }
[10:30:54.387]     else {
[10:30:54.387]         if (TRUE) {
[10:30:54.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.387]                 open = "w")
[10:30:54.387]         }
[10:30:54.387]         else {
[10:30:54.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.387]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.387]         }
[10:30:54.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.387]             base::sink(type = "output", split = FALSE)
[10:30:54.387]             base::close(...future.stdout)
[10:30:54.387]         }, add = TRUE)
[10:30:54.387]     }
[10:30:54.387]     ...future.frame <- base::sys.nframe()
[10:30:54.387]     ...future.conditions <- base::list()
[10:30:54.387]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.387]     if (FALSE) {
[10:30:54.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.387]     }
[10:30:54.387]     ...future.result <- base::tryCatch({
[10:30:54.387]         base::withCallingHandlers({
[10:30:54.387]             ...future.value <- base::withVisible(base::local({
[10:30:54.387]                 ...future.makeSendCondition <- base::local({
[10:30:54.387]                   sendCondition <- NULL
[10:30:54.387]                   function(frame = 1L) {
[10:30:54.387]                     if (is.function(sendCondition)) 
[10:30:54.387]                       return(sendCondition)
[10:30:54.387]                     ns <- getNamespace("parallel")
[10:30:54.387]                     if (exists("sendData", mode = "function", 
[10:30:54.387]                       envir = ns)) {
[10:30:54.387]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.387]                         envir = ns)
[10:30:54.387]                       envir <- sys.frame(frame)
[10:30:54.387]                       master <- NULL
[10:30:54.387]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.387]                         !identical(envir, emptyenv())) {
[10:30:54.387]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.387]                           inherits = FALSE)) {
[10:30:54.387]                           master <- get("master", mode = "list", 
[10:30:54.387]                             envir = envir, inherits = FALSE)
[10:30:54.387]                           if (inherits(master, c("SOCKnode", 
[10:30:54.387]                             "SOCK0node"))) {
[10:30:54.387]                             sendCondition <<- function(cond) {
[10:30:54.387]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.387]                                 success = TRUE)
[10:30:54.387]                               parallel_sendData(master, data)
[10:30:54.387]                             }
[10:30:54.387]                             return(sendCondition)
[10:30:54.387]                           }
[10:30:54.387]                         }
[10:30:54.387]                         frame <- frame + 1L
[10:30:54.387]                         envir <- sys.frame(frame)
[10:30:54.387]                       }
[10:30:54.387]                     }
[10:30:54.387]                     sendCondition <<- function(cond) NULL
[10:30:54.387]                   }
[10:30:54.387]                 })
[10:30:54.387]                 withCallingHandlers({
[10:30:54.387]                   {
[10:30:54.387]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.387]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.387]                       ...future.globals.maxSize)) {
[10:30:54.387]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.387]                       on.exit(options(oopts), add = TRUE)
[10:30:54.387]                     }
[10:30:54.387]                     {
[10:30:54.387]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.387]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.387]                         USE.NAMES = FALSE)
[10:30:54.387]                       do.call(mapply, args = args)
[10:30:54.387]                     }
[10:30:54.387]                   }
[10:30:54.387]                 }, immediateCondition = function(cond) {
[10:30:54.387]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.387]                   sendCondition(cond)
[10:30:54.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.387]                   {
[10:30:54.387]                     inherits <- base::inherits
[10:30:54.387]                     invokeRestart <- base::invokeRestart
[10:30:54.387]                     is.null <- base::is.null
[10:30:54.387]                     muffled <- FALSE
[10:30:54.387]                     if (inherits(cond, "message")) {
[10:30:54.387]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.387]                       if (muffled) 
[10:30:54.387]                         invokeRestart("muffleMessage")
[10:30:54.387]                     }
[10:30:54.387]                     else if (inherits(cond, "warning")) {
[10:30:54.387]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.387]                       if (muffled) 
[10:30:54.387]                         invokeRestart("muffleWarning")
[10:30:54.387]                     }
[10:30:54.387]                     else if (inherits(cond, "condition")) {
[10:30:54.387]                       if (!is.null(pattern)) {
[10:30:54.387]                         computeRestarts <- base::computeRestarts
[10:30:54.387]                         grepl <- base::grepl
[10:30:54.387]                         restarts <- computeRestarts(cond)
[10:30:54.387]                         for (restart in restarts) {
[10:30:54.387]                           name <- restart$name
[10:30:54.387]                           if (is.null(name)) 
[10:30:54.387]                             next
[10:30:54.387]                           if (!grepl(pattern, name)) 
[10:30:54.387]                             next
[10:30:54.387]                           invokeRestart(restart)
[10:30:54.387]                           muffled <- TRUE
[10:30:54.387]                           break
[10:30:54.387]                         }
[10:30:54.387]                       }
[10:30:54.387]                     }
[10:30:54.387]                     invisible(muffled)
[10:30:54.387]                   }
[10:30:54.387]                   muffleCondition(cond)
[10:30:54.387]                 })
[10:30:54.387]             }))
[10:30:54.387]             future::FutureResult(value = ...future.value$value, 
[10:30:54.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.387]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.387]                     ...future.globalenv.names))
[10:30:54.387]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.387]         }, condition = base::local({
[10:30:54.387]             c <- base::c
[10:30:54.387]             inherits <- base::inherits
[10:30:54.387]             invokeRestart <- base::invokeRestart
[10:30:54.387]             length <- base::length
[10:30:54.387]             list <- base::list
[10:30:54.387]             seq.int <- base::seq.int
[10:30:54.387]             signalCondition <- base::signalCondition
[10:30:54.387]             sys.calls <- base::sys.calls
[10:30:54.387]             `[[` <- base::`[[`
[10:30:54.387]             `+` <- base::`+`
[10:30:54.387]             `<<-` <- base::`<<-`
[10:30:54.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.387]                   3L)]
[10:30:54.387]             }
[10:30:54.387]             function(cond) {
[10:30:54.387]                 is_error <- inherits(cond, "error")
[10:30:54.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.387]                   NULL)
[10:30:54.387]                 if (is_error) {
[10:30:54.387]                   sessionInformation <- function() {
[10:30:54.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.387]                       search = base::search(), system = base::Sys.info())
[10:30:54.387]                   }
[10:30:54.387]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.387]                     cond$call), session = sessionInformation(), 
[10:30:54.387]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.387]                   signalCondition(cond)
[10:30:54.387]                 }
[10:30:54.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.387]                 "immediateCondition"))) {
[10:30:54.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.387]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.387]                   if (TRUE && !signal) {
[10:30:54.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.387]                     {
[10:30:54.387]                       inherits <- base::inherits
[10:30:54.387]                       invokeRestart <- base::invokeRestart
[10:30:54.387]                       is.null <- base::is.null
[10:30:54.387]                       muffled <- FALSE
[10:30:54.387]                       if (inherits(cond, "message")) {
[10:30:54.387]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.387]                         if (muffled) 
[10:30:54.387]                           invokeRestart("muffleMessage")
[10:30:54.387]                       }
[10:30:54.387]                       else if (inherits(cond, "warning")) {
[10:30:54.387]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.387]                         if (muffled) 
[10:30:54.387]                           invokeRestart("muffleWarning")
[10:30:54.387]                       }
[10:30:54.387]                       else if (inherits(cond, "condition")) {
[10:30:54.387]                         if (!is.null(pattern)) {
[10:30:54.387]                           computeRestarts <- base::computeRestarts
[10:30:54.387]                           grepl <- base::grepl
[10:30:54.387]                           restarts <- computeRestarts(cond)
[10:30:54.387]                           for (restart in restarts) {
[10:30:54.387]                             name <- restart$name
[10:30:54.387]                             if (is.null(name)) 
[10:30:54.387]                               next
[10:30:54.387]                             if (!grepl(pattern, name)) 
[10:30:54.387]                               next
[10:30:54.387]                             invokeRestart(restart)
[10:30:54.387]                             muffled <- TRUE
[10:30:54.387]                             break
[10:30:54.387]                           }
[10:30:54.387]                         }
[10:30:54.387]                       }
[10:30:54.387]                       invisible(muffled)
[10:30:54.387]                     }
[10:30:54.387]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.387]                   }
[10:30:54.387]                 }
[10:30:54.387]                 else {
[10:30:54.387]                   if (TRUE) {
[10:30:54.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.387]                     {
[10:30:54.387]                       inherits <- base::inherits
[10:30:54.387]                       invokeRestart <- base::invokeRestart
[10:30:54.387]                       is.null <- base::is.null
[10:30:54.387]                       muffled <- FALSE
[10:30:54.387]                       if (inherits(cond, "message")) {
[10:30:54.387]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.387]                         if (muffled) 
[10:30:54.387]                           invokeRestart("muffleMessage")
[10:30:54.387]                       }
[10:30:54.387]                       else if (inherits(cond, "warning")) {
[10:30:54.387]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.387]                         if (muffled) 
[10:30:54.387]                           invokeRestart("muffleWarning")
[10:30:54.387]                       }
[10:30:54.387]                       else if (inherits(cond, "condition")) {
[10:30:54.387]                         if (!is.null(pattern)) {
[10:30:54.387]                           computeRestarts <- base::computeRestarts
[10:30:54.387]                           grepl <- base::grepl
[10:30:54.387]                           restarts <- computeRestarts(cond)
[10:30:54.387]                           for (restart in restarts) {
[10:30:54.387]                             name <- restart$name
[10:30:54.387]                             if (is.null(name)) 
[10:30:54.387]                               next
[10:30:54.387]                             if (!grepl(pattern, name)) 
[10:30:54.387]                               next
[10:30:54.387]                             invokeRestart(restart)
[10:30:54.387]                             muffled <- TRUE
[10:30:54.387]                             break
[10:30:54.387]                           }
[10:30:54.387]                         }
[10:30:54.387]                       }
[10:30:54.387]                       invisible(muffled)
[10:30:54.387]                     }
[10:30:54.387]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.387]                   }
[10:30:54.387]                 }
[10:30:54.387]             }
[10:30:54.387]         }))
[10:30:54.387]     }, error = function(ex) {
[10:30:54.387]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.387]                 ...future.rng), started = ...future.startTime, 
[10:30:54.387]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.387]             version = "1.8"), class = "FutureResult")
[10:30:54.387]     }, finally = {
[10:30:54.387]         if (!identical(...future.workdir, getwd())) 
[10:30:54.387]             setwd(...future.workdir)
[10:30:54.387]         {
[10:30:54.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.387]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.387]             }
[10:30:54.387]             base::options(...future.oldOptions)
[10:30:54.387]             if (.Platform$OS.type == "windows") {
[10:30:54.387]                 old_names <- names(...future.oldEnvVars)
[10:30:54.387]                 envs <- base::Sys.getenv()
[10:30:54.387]                 names <- names(envs)
[10:30:54.387]                 common <- intersect(names, old_names)
[10:30:54.387]                 added <- setdiff(names, old_names)
[10:30:54.387]                 removed <- setdiff(old_names, names)
[10:30:54.387]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.387]                   envs[common]]
[10:30:54.387]                 NAMES <- toupper(changed)
[10:30:54.387]                 args <- list()
[10:30:54.387]                 for (kk in seq_along(NAMES)) {
[10:30:54.387]                   name <- changed[[kk]]
[10:30:54.387]                   NAME <- NAMES[[kk]]
[10:30:54.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.387]                     next
[10:30:54.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.387]                 }
[10:30:54.387]                 NAMES <- toupper(added)
[10:30:54.387]                 for (kk in seq_along(NAMES)) {
[10:30:54.387]                   name <- added[[kk]]
[10:30:54.387]                   NAME <- NAMES[[kk]]
[10:30:54.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.387]                     next
[10:30:54.387]                   args[[name]] <- ""
[10:30:54.387]                 }
[10:30:54.387]                 NAMES <- toupper(removed)
[10:30:54.387]                 for (kk in seq_along(NAMES)) {
[10:30:54.387]                   name <- removed[[kk]]
[10:30:54.387]                   NAME <- NAMES[[kk]]
[10:30:54.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.387]                     next
[10:30:54.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.387]                 }
[10:30:54.387]                 if (length(args) > 0) 
[10:30:54.387]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.387]             }
[10:30:54.387]             else {
[10:30:54.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.387]             }
[10:30:54.387]             {
[10:30:54.387]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.387]                   0L) {
[10:30:54.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.387]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.387]                   base::options(opts)
[10:30:54.387]                 }
[10:30:54.387]                 {
[10:30:54.387]                   {
[10:30:54.387]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.387]                     NULL
[10:30:54.387]                   }
[10:30:54.387]                   options(future.plan = NULL)
[10:30:54.387]                   if (is.na(NA_character_)) 
[10:30:54.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.387]                     .init = FALSE)
[10:30:54.387]                 }
[10:30:54.387]             }
[10:30:54.387]         }
[10:30:54.387]     })
[10:30:54.387]     if (TRUE) {
[10:30:54.387]         base::sink(type = "output", split = FALSE)
[10:30:54.387]         if (TRUE) {
[10:30:54.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.387]         }
[10:30:54.387]         else {
[10:30:54.387]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.387]         }
[10:30:54.387]         base::close(...future.stdout)
[10:30:54.387]         ...future.stdout <- NULL
[10:30:54.387]     }
[10:30:54.387]     ...future.result$conditions <- ...future.conditions
[10:30:54.387]     ...future.result$finished <- base::Sys.time()
[10:30:54.387]     ...future.result
[10:30:54.387] }
[10:30:54.390] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[10:30:54.390] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:30:54.391] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:30:54.391] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:54.391] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.392] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:30:54.392] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:30:54.392] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:54.392] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.392] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:54.393] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.393] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[10:30:54.394] MultisessionFuture started
[10:30:54.394] - Launch lazy future ... done
[10:30:54.394] run() for ‘MultisessionFuture’ ... done
[10:30:54.394] Created future:
[10:30:54.394] MultisessionFuture:
[10:30:54.394] Label: ‘future_mapply-1’
[10:30:54.394] Expression:
[10:30:54.394] {
[10:30:54.394]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.394]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.394]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.394]         on.exit(options(oopts), add = TRUE)
[10:30:54.394]     }
[10:30:54.394]     {
[10:30:54.394]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.394]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.394]         do.call(mapply, args = args)
[10:30:54.394]     }
[10:30:54.394] }
[10:30:54.394] Lazy evaluation: FALSE
[10:30:54.394] Asynchronous evaluation: TRUE
[10:30:54.394] Local evaluation: TRUE
[10:30:54.394] Environment: R_GlobalEnv
[10:30:54.394] Capture standard output: TRUE
[10:30:54.394] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.394] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.394] Packages: <none>
[10:30:54.394] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.394] Resolved: FALSE
[10:30:54.394] Value: <not collected>
[10:30:54.394] Conditions captured: <none>
[10:30:54.394] Early signaling: FALSE
[10:30:54.394] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.394] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.406] Chunk #1 of 1 ... DONE
[10:30:54.406] Launching 1 futures (chunks) ... DONE
[10:30:54.406] Resolving 1 futures (chunks) ...
[10:30:54.406] resolve() on list ...
[10:30:54.406]  recursive: 0
[10:30:54.406]  length: 1
[10:30:54.406] 
[10:30:54.448] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.448] - Validating connection of MultisessionFuture
[10:30:54.448] - received message: FutureResult
[10:30:54.449] - Received FutureResult
[10:30:54.449] - Erased future from FutureRegistry
[10:30:54.449] result() for ClusterFuture ...
[10:30:54.449] - result already collected: FutureResult
[10:30:54.449] result() for ClusterFuture ... done
[10:30:54.449] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.449] Future #1
[10:30:54.449] result() for ClusterFuture ...
[10:30:54.449] - result already collected: FutureResult
[10:30:54.449] result() for ClusterFuture ... done
[10:30:54.450] result() for ClusterFuture ...
[10:30:54.450] - result already collected: FutureResult
[10:30:54.450] result() for ClusterFuture ... done
[10:30:54.450] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:54.450] - nx: 1
[10:30:54.450] - relay: TRUE
[10:30:54.450] - stdout: TRUE
[10:30:54.450] - signal: TRUE
[10:30:54.450] - resignal: FALSE
[10:30:54.450] - force: TRUE
[10:30:54.450] - relayed: [n=1] FALSE
[10:30:54.450] - queued futures: [n=1] FALSE
[10:30:54.451]  - until=1
[10:30:54.451]  - relaying element #1
[10:30:54.451] result() for ClusterFuture ...
[10:30:54.451] - result already collected: FutureResult
[10:30:54.451] result() for ClusterFuture ... done
[10:30:54.451] result() for ClusterFuture ...
[10:30:54.451] - result already collected: FutureResult
[10:30:54.451] result() for ClusterFuture ... done
[10:30:54.451] result() for ClusterFuture ...
[10:30:54.451] - result already collected: FutureResult
[10:30:54.451] result() for ClusterFuture ... done
[10:30:54.452] result() for ClusterFuture ...
[10:30:54.452] - result already collected: FutureResult
[10:30:54.452] result() for ClusterFuture ... done
[10:30:54.452] - relayed: [n=1] TRUE
[10:30:54.452] - queued futures: [n=1] TRUE
[10:30:54.452] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:54.452]  length: 0 (resolved future 1)
[10:30:54.452] Relaying remaining futures
[10:30:54.452] signalConditionsASAP(NULL, pos=0) ...
[10:30:54.452] - nx: 1
[10:30:54.452] - relay: TRUE
[10:30:54.452] - stdout: TRUE
[10:30:54.453] - signal: TRUE
[10:30:54.453] - resignal: FALSE
[10:30:54.453] - force: TRUE
[10:30:54.453] - relayed: [n=1] TRUE
[10:30:54.453] - queued futures: [n=1] TRUE
 - flush all
[10:30:54.453] - relayed: [n=1] TRUE
[10:30:54.453] - queued futures: [n=1] TRUE
[10:30:54.453] signalConditionsASAP(NULL, pos=0) ... done
[10:30:54.453] resolve() on list ... DONE
[10:30:54.453] result() for ClusterFuture ...
[10:30:54.453] - result already collected: FutureResult
[10:30:54.454] result() for ClusterFuture ... done
[10:30:54.454] result() for ClusterFuture ...
[10:30:54.454] - result already collected: FutureResult
[10:30:54.454] result() for ClusterFuture ... done
[10:30:54.454]  - Number of value chunks collected: 1
[10:30:54.454] Resolving 1 futures (chunks) ... DONE
[10:30:54.454] Reducing values from 1 chunks ...
[10:30:54.454]  - Number of values collected after concatenation: 1
[10:30:54.454]  - Number of values expected: 1
[10:30:54.454] Reducing values from 1 chunks ... DONE
[10:30:54.454] future_mapply() ... DONE
[10:30:54.455] future_mapply() ...
[10:30:54.458] Number of chunks: 1
[10:30:54.458] getGlobalsAndPackagesXApply() ...
[10:30:54.458]  - future.globals: TRUE
[10:30:54.458] getGlobalsAndPackages() ...
[10:30:54.459] Searching for globals...
[10:30:54.460] - globals found: [1] ‘FUN’
[10:30:54.460] Searching for globals ... DONE
[10:30:54.460] Resolving globals: FALSE
[10:30:54.460] The total size of the 1 globals is 848 bytes (848 bytes)
[10:30:54.460] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:30:54.461] - globals: [1] ‘FUN’
[10:30:54.461] 
[10:30:54.461] getGlobalsAndPackages() ... DONE
[10:30:54.461]  - globals found/used: [n=1] ‘FUN’
[10:30:54.461]  - needed namespaces: [n=0] 
[10:30:54.461] Finding globals ... DONE
[10:30:54.461] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:54.461] List of 2
[10:30:54.461]  $ ...future.FUN:function (x)  
[10:30:54.461]  $ MoreArgs     : list()
[10:30:54.461]  - attr(*, "where")=List of 2
[10:30:54.461]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:54.461]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:54.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:54.461]  - attr(*, "resolved")= logi FALSE
[10:30:54.461]  - attr(*, "total_size")= num NA
[10:30:54.464] Packages to be attached in all futures: [n=0] 
[10:30:54.464] getGlobalsAndPackagesXApply() ... DONE
[10:30:54.464] Number of futures (= number of chunks): 1
[10:30:54.464] Launching 1 futures (chunks) ...
[10:30:54.464] Chunk #1 of 1 ...
[10:30:54.464]  - Finding globals in '...' for chunk #1 ...
[10:30:54.465] getGlobalsAndPackages() ...
[10:30:54.465] Searching for globals...
[10:30:54.465] 
[10:30:54.465] Searching for globals ... DONE
[10:30:54.465] - globals: [0] <none>
[10:30:54.465] getGlobalsAndPackages() ... DONE
[10:30:54.465]    + additional globals found: [n=0] 
[10:30:54.465]    + additional namespaces needed: [n=0] 
[10:30:54.466]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:54.466]  - seeds: <none>
[10:30:54.466]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.466] getGlobalsAndPackages() ...
[10:30:54.466] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.466] Resolving globals: FALSE
[10:30:54.466] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[10:30:54.467] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[10:30:54.467] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.467] 
[10:30:54.467] getGlobalsAndPackages() ... DONE
[10:30:54.468] run() for ‘Future’ ...
[10:30:54.468] - state: ‘created’
[10:30:54.468] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.481] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.482]   - Field: ‘node’
[10:30:54.482]   - Field: ‘label’
[10:30:54.482]   - Field: ‘local’
[10:30:54.482]   - Field: ‘owner’
[10:30:54.482]   - Field: ‘envir’
[10:30:54.482]   - Field: ‘workers’
[10:30:54.482]   - Field: ‘packages’
[10:30:54.482]   - Field: ‘gc’
[10:30:54.482]   - Field: ‘conditions’
[10:30:54.483]   - Field: ‘persistent’
[10:30:54.483]   - Field: ‘expr’
[10:30:54.483]   - Field: ‘uuid’
[10:30:54.483]   - Field: ‘seed’
[10:30:54.483]   - Field: ‘version’
[10:30:54.483]   - Field: ‘result’
[10:30:54.483]   - Field: ‘asynchronous’
[10:30:54.483]   - Field: ‘calls’
[10:30:54.483]   - Field: ‘globals’
[10:30:54.483]   - Field: ‘stdout’
[10:30:54.483]   - Field: ‘earlySignal’
[10:30:54.483]   - Field: ‘lazy’
[10:30:54.484]   - Field: ‘state’
[10:30:54.484] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.484] - Launch lazy future ...
[10:30:54.484] Packages needed by the future expression (n = 0): <none>
[10:30:54.484] Packages needed by future strategies (n = 0): <none>
[10:30:54.485] {
[10:30:54.485]     {
[10:30:54.485]         {
[10:30:54.485]             ...future.startTime <- base::Sys.time()
[10:30:54.485]             {
[10:30:54.485]                 {
[10:30:54.485]                   {
[10:30:54.485]                     {
[10:30:54.485]                       base::local({
[10:30:54.485]                         has_future <- base::requireNamespace("future", 
[10:30:54.485]                           quietly = TRUE)
[10:30:54.485]                         if (has_future) {
[10:30:54.485]                           ns <- base::getNamespace("future")
[10:30:54.485]                           version <- ns[[".package"]][["version"]]
[10:30:54.485]                           if (is.null(version)) 
[10:30:54.485]                             version <- utils::packageVersion("future")
[10:30:54.485]                         }
[10:30:54.485]                         else {
[10:30:54.485]                           version <- NULL
[10:30:54.485]                         }
[10:30:54.485]                         if (!has_future || version < "1.8.0") {
[10:30:54.485]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.485]                             "", base::R.version$version.string), 
[10:30:54.485]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.485]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.485]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.485]                               "release", "version")], collapse = " "), 
[10:30:54.485]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.485]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.485]                             info)
[10:30:54.485]                           info <- base::paste(info, collapse = "; ")
[10:30:54.485]                           if (!has_future) {
[10:30:54.485]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.485]                               info)
[10:30:54.485]                           }
[10:30:54.485]                           else {
[10:30:54.485]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.485]                               info, version)
[10:30:54.485]                           }
[10:30:54.485]                           base::stop(msg)
[10:30:54.485]                         }
[10:30:54.485]                       })
[10:30:54.485]                     }
[10:30:54.485]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.485]                     base::options(mc.cores = 1L)
[10:30:54.485]                   }
[10:30:54.485]                   ...future.strategy.old <- future::plan("list")
[10:30:54.485]                   options(future.plan = NULL)
[10:30:54.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.485]                 }
[10:30:54.485]                 ...future.workdir <- getwd()
[10:30:54.485]             }
[10:30:54.485]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.485]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.485]         }
[10:30:54.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:30:54.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.485]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.485]             base::names(...future.oldOptions))
[10:30:54.485]     }
[10:30:54.485]     if (FALSE) {
[10:30:54.485]     }
[10:30:54.485]     else {
[10:30:54.485]         if (TRUE) {
[10:30:54.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.485]                 open = "w")
[10:30:54.485]         }
[10:30:54.485]         else {
[10:30:54.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.485]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.485]         }
[10:30:54.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.485]             base::sink(type = "output", split = FALSE)
[10:30:54.485]             base::close(...future.stdout)
[10:30:54.485]         }, add = TRUE)
[10:30:54.485]     }
[10:30:54.485]     ...future.frame <- base::sys.nframe()
[10:30:54.485]     ...future.conditions <- base::list()
[10:30:54.485]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.485]     if (FALSE) {
[10:30:54.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.485]     }
[10:30:54.485]     ...future.result <- base::tryCatch({
[10:30:54.485]         base::withCallingHandlers({
[10:30:54.485]             ...future.value <- base::withVisible(base::local({
[10:30:54.485]                 ...future.makeSendCondition <- base::local({
[10:30:54.485]                   sendCondition <- NULL
[10:30:54.485]                   function(frame = 1L) {
[10:30:54.485]                     if (is.function(sendCondition)) 
[10:30:54.485]                       return(sendCondition)
[10:30:54.485]                     ns <- getNamespace("parallel")
[10:30:54.485]                     if (exists("sendData", mode = "function", 
[10:30:54.485]                       envir = ns)) {
[10:30:54.485]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.485]                         envir = ns)
[10:30:54.485]                       envir <- sys.frame(frame)
[10:30:54.485]                       master <- NULL
[10:30:54.485]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.485]                         !identical(envir, emptyenv())) {
[10:30:54.485]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.485]                           inherits = FALSE)) {
[10:30:54.485]                           master <- get("master", mode = "list", 
[10:30:54.485]                             envir = envir, inherits = FALSE)
[10:30:54.485]                           if (inherits(master, c("SOCKnode", 
[10:30:54.485]                             "SOCK0node"))) {
[10:30:54.485]                             sendCondition <<- function(cond) {
[10:30:54.485]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.485]                                 success = TRUE)
[10:30:54.485]                               parallel_sendData(master, data)
[10:30:54.485]                             }
[10:30:54.485]                             return(sendCondition)
[10:30:54.485]                           }
[10:30:54.485]                         }
[10:30:54.485]                         frame <- frame + 1L
[10:30:54.485]                         envir <- sys.frame(frame)
[10:30:54.485]                       }
[10:30:54.485]                     }
[10:30:54.485]                     sendCondition <<- function(cond) NULL
[10:30:54.485]                   }
[10:30:54.485]                 })
[10:30:54.485]                 withCallingHandlers({
[10:30:54.485]                   {
[10:30:54.485]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.485]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.485]                       ...future.globals.maxSize)) {
[10:30:54.485]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.485]                       on.exit(options(oopts), add = TRUE)
[10:30:54.485]                     }
[10:30:54.485]                     {
[10:30:54.485]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.485]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.485]                         USE.NAMES = FALSE)
[10:30:54.485]                       do.call(mapply, args = args)
[10:30:54.485]                     }
[10:30:54.485]                   }
[10:30:54.485]                 }, immediateCondition = function(cond) {
[10:30:54.485]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.485]                   sendCondition(cond)
[10:30:54.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.485]                   {
[10:30:54.485]                     inherits <- base::inherits
[10:30:54.485]                     invokeRestart <- base::invokeRestart
[10:30:54.485]                     is.null <- base::is.null
[10:30:54.485]                     muffled <- FALSE
[10:30:54.485]                     if (inherits(cond, "message")) {
[10:30:54.485]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.485]                       if (muffled) 
[10:30:54.485]                         invokeRestart("muffleMessage")
[10:30:54.485]                     }
[10:30:54.485]                     else if (inherits(cond, "warning")) {
[10:30:54.485]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.485]                       if (muffled) 
[10:30:54.485]                         invokeRestart("muffleWarning")
[10:30:54.485]                     }
[10:30:54.485]                     else if (inherits(cond, "condition")) {
[10:30:54.485]                       if (!is.null(pattern)) {
[10:30:54.485]                         computeRestarts <- base::computeRestarts
[10:30:54.485]                         grepl <- base::grepl
[10:30:54.485]                         restarts <- computeRestarts(cond)
[10:30:54.485]                         for (restart in restarts) {
[10:30:54.485]                           name <- restart$name
[10:30:54.485]                           if (is.null(name)) 
[10:30:54.485]                             next
[10:30:54.485]                           if (!grepl(pattern, name)) 
[10:30:54.485]                             next
[10:30:54.485]                           invokeRestart(restart)
[10:30:54.485]                           muffled <- TRUE
[10:30:54.485]                           break
[10:30:54.485]                         }
[10:30:54.485]                       }
[10:30:54.485]                     }
[10:30:54.485]                     invisible(muffled)
[10:30:54.485]                   }
[10:30:54.485]                   muffleCondition(cond)
[10:30:54.485]                 })
[10:30:54.485]             }))
[10:30:54.485]             future::FutureResult(value = ...future.value$value, 
[10:30:54.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.485]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.485]                     ...future.globalenv.names))
[10:30:54.485]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.485]         }, condition = base::local({
[10:30:54.485]             c <- base::c
[10:30:54.485]             inherits <- base::inherits
[10:30:54.485]             invokeRestart <- base::invokeRestart
[10:30:54.485]             length <- base::length
[10:30:54.485]             list <- base::list
[10:30:54.485]             seq.int <- base::seq.int
[10:30:54.485]             signalCondition <- base::signalCondition
[10:30:54.485]             sys.calls <- base::sys.calls
[10:30:54.485]             `[[` <- base::`[[`
[10:30:54.485]             `+` <- base::`+`
[10:30:54.485]             `<<-` <- base::`<<-`
[10:30:54.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.485]                   3L)]
[10:30:54.485]             }
[10:30:54.485]             function(cond) {
[10:30:54.485]                 is_error <- inherits(cond, "error")
[10:30:54.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.485]                   NULL)
[10:30:54.485]                 if (is_error) {
[10:30:54.485]                   sessionInformation <- function() {
[10:30:54.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.485]                       search = base::search(), system = base::Sys.info())
[10:30:54.485]                   }
[10:30:54.485]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.485]                     cond$call), session = sessionInformation(), 
[10:30:54.485]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.485]                   signalCondition(cond)
[10:30:54.485]                 }
[10:30:54.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.485]                 "immediateCondition"))) {
[10:30:54.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.485]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.485]                   if (TRUE && !signal) {
[10:30:54.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.485]                     {
[10:30:54.485]                       inherits <- base::inherits
[10:30:54.485]                       invokeRestart <- base::invokeRestart
[10:30:54.485]                       is.null <- base::is.null
[10:30:54.485]                       muffled <- FALSE
[10:30:54.485]                       if (inherits(cond, "message")) {
[10:30:54.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.485]                         if (muffled) 
[10:30:54.485]                           invokeRestart("muffleMessage")
[10:30:54.485]                       }
[10:30:54.485]                       else if (inherits(cond, "warning")) {
[10:30:54.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.485]                         if (muffled) 
[10:30:54.485]                           invokeRestart("muffleWarning")
[10:30:54.485]                       }
[10:30:54.485]                       else if (inherits(cond, "condition")) {
[10:30:54.485]                         if (!is.null(pattern)) {
[10:30:54.485]                           computeRestarts <- base::computeRestarts
[10:30:54.485]                           grepl <- base::grepl
[10:30:54.485]                           restarts <- computeRestarts(cond)
[10:30:54.485]                           for (restart in restarts) {
[10:30:54.485]                             name <- restart$name
[10:30:54.485]                             if (is.null(name)) 
[10:30:54.485]                               next
[10:30:54.485]                             if (!grepl(pattern, name)) 
[10:30:54.485]                               next
[10:30:54.485]                             invokeRestart(restart)
[10:30:54.485]                             muffled <- TRUE
[10:30:54.485]                             break
[10:30:54.485]                           }
[10:30:54.485]                         }
[10:30:54.485]                       }
[10:30:54.485]                       invisible(muffled)
[10:30:54.485]                     }
[10:30:54.485]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.485]                   }
[10:30:54.485]                 }
[10:30:54.485]                 else {
[10:30:54.485]                   if (TRUE) {
[10:30:54.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.485]                     {
[10:30:54.485]                       inherits <- base::inherits
[10:30:54.485]                       invokeRestart <- base::invokeRestart
[10:30:54.485]                       is.null <- base::is.null
[10:30:54.485]                       muffled <- FALSE
[10:30:54.485]                       if (inherits(cond, "message")) {
[10:30:54.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.485]                         if (muffled) 
[10:30:54.485]                           invokeRestart("muffleMessage")
[10:30:54.485]                       }
[10:30:54.485]                       else if (inherits(cond, "warning")) {
[10:30:54.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.485]                         if (muffled) 
[10:30:54.485]                           invokeRestart("muffleWarning")
[10:30:54.485]                       }
[10:30:54.485]                       else if (inherits(cond, "condition")) {
[10:30:54.485]                         if (!is.null(pattern)) {
[10:30:54.485]                           computeRestarts <- base::computeRestarts
[10:30:54.485]                           grepl <- base::grepl
[10:30:54.485]                           restarts <- computeRestarts(cond)
[10:30:54.485]                           for (restart in restarts) {
[10:30:54.485]                             name <- restart$name
[10:30:54.485]                             if (is.null(name)) 
[10:30:54.485]                               next
[10:30:54.485]                             if (!grepl(pattern, name)) 
[10:30:54.485]                               next
[10:30:54.485]                             invokeRestart(restart)
[10:30:54.485]                             muffled <- TRUE
[10:30:54.485]                             break
[10:30:54.485]                           }
[10:30:54.485]                         }
[10:30:54.485]                       }
[10:30:54.485]                       invisible(muffled)
[10:30:54.485]                     }
[10:30:54.485]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.485]                   }
[10:30:54.485]                 }
[10:30:54.485]             }
[10:30:54.485]         }))
[10:30:54.485]     }, error = function(ex) {
[10:30:54.485]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.485]                 ...future.rng), started = ...future.startTime, 
[10:30:54.485]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.485]             version = "1.8"), class = "FutureResult")
[10:30:54.485]     }, finally = {
[10:30:54.485]         if (!identical(...future.workdir, getwd())) 
[10:30:54.485]             setwd(...future.workdir)
[10:30:54.485]         {
[10:30:54.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.485]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.485]             }
[10:30:54.485]             base::options(...future.oldOptions)
[10:30:54.485]             if (.Platform$OS.type == "windows") {
[10:30:54.485]                 old_names <- names(...future.oldEnvVars)
[10:30:54.485]                 envs <- base::Sys.getenv()
[10:30:54.485]                 names <- names(envs)
[10:30:54.485]                 common <- intersect(names, old_names)
[10:30:54.485]                 added <- setdiff(names, old_names)
[10:30:54.485]                 removed <- setdiff(old_names, names)
[10:30:54.485]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.485]                   envs[common]]
[10:30:54.485]                 NAMES <- toupper(changed)
[10:30:54.485]                 args <- list()
[10:30:54.485]                 for (kk in seq_along(NAMES)) {
[10:30:54.485]                   name <- changed[[kk]]
[10:30:54.485]                   NAME <- NAMES[[kk]]
[10:30:54.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.485]                     next
[10:30:54.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.485]                 }
[10:30:54.485]                 NAMES <- toupper(added)
[10:30:54.485]                 for (kk in seq_along(NAMES)) {
[10:30:54.485]                   name <- added[[kk]]
[10:30:54.485]                   NAME <- NAMES[[kk]]
[10:30:54.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.485]                     next
[10:30:54.485]                   args[[name]] <- ""
[10:30:54.485]                 }
[10:30:54.485]                 NAMES <- toupper(removed)
[10:30:54.485]                 for (kk in seq_along(NAMES)) {
[10:30:54.485]                   name <- removed[[kk]]
[10:30:54.485]                   NAME <- NAMES[[kk]]
[10:30:54.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.485]                     next
[10:30:54.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.485]                 }
[10:30:54.485]                 if (length(args) > 0) 
[10:30:54.485]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.485]             }
[10:30:54.485]             else {
[10:30:54.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.485]             }
[10:30:54.485]             {
[10:30:54.485]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.485]                   0L) {
[10:30:54.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.485]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.485]                   base::options(opts)
[10:30:54.485]                 }
[10:30:54.485]                 {
[10:30:54.485]                   {
[10:30:54.485]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.485]                     NULL
[10:30:54.485]                   }
[10:30:54.485]                   options(future.plan = NULL)
[10:30:54.485]                   if (is.na(NA_character_)) 
[10:30:54.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.485]                     .init = FALSE)
[10:30:54.485]                 }
[10:30:54.485]             }
[10:30:54.485]         }
[10:30:54.485]     })
[10:30:54.485]     if (TRUE) {
[10:30:54.485]         base::sink(type = "output", split = FALSE)
[10:30:54.485]         if (TRUE) {
[10:30:54.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.485]         }
[10:30:54.485]         else {
[10:30:54.485]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.485]         }
[10:30:54.485]         base::close(...future.stdout)
[10:30:54.485]         ...future.stdout <- NULL
[10:30:54.485]     }
[10:30:54.485]     ...future.result$conditions <- ...future.conditions
[10:30:54.485]     ...future.result$finished <- base::Sys.time()
[10:30:54.485]     ...future.result
[10:30:54.485] }
[10:30:54.487] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[10:30:54.488] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:30:54.488] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:30:54.488] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:54.488] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.488] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:30:54.489] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:30:54.489] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:54.489] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.489] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:54.490] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.490] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[10:30:54.490] MultisessionFuture started
[10:30:54.490] - Launch lazy future ... done
[10:30:54.490] run() for ‘MultisessionFuture’ ... done
[10:30:54.490] Created future:
[10:30:54.491] MultisessionFuture:
[10:30:54.491] Label: ‘future_.mapply-1’
[10:30:54.491] Expression:
[10:30:54.491] {
[10:30:54.491]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.491]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.491]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.491]         on.exit(options(oopts), add = TRUE)
[10:30:54.491]     }
[10:30:54.491]     {
[10:30:54.491]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.491]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.491]         do.call(mapply, args = args)
[10:30:54.491]     }
[10:30:54.491] }
[10:30:54.491] Lazy evaluation: FALSE
[10:30:54.491] Asynchronous evaluation: TRUE
[10:30:54.491] Local evaluation: TRUE
[10:30:54.491] Environment: R_GlobalEnv
[10:30:54.491] Capture standard output: TRUE
[10:30:54.491] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.491] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.491] Packages: <none>
[10:30:54.491] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.491] Resolved: FALSE
[10:30:54.491] Value: <not collected>
[10:30:54.491] Conditions captured: <none>
[10:30:54.491] Early signaling: FALSE
[10:30:54.491] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.491] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.502] Chunk #1 of 1 ... DONE
[10:30:54.502] Launching 1 futures (chunks) ... DONE
[10:30:54.502] Resolving 1 futures (chunks) ...
[10:30:54.502] resolve() on list ...
[10:30:54.502]  recursive: 0
[10:30:54.503]  length: 1
[10:30:54.503] 
[10:30:54.545] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.545] - Validating connection of MultisessionFuture
[10:30:54.545] - received message: FutureResult
[10:30:54.545] - Received FutureResult
[10:30:54.545] - Erased future from FutureRegistry
[10:30:54.545] result() for ClusterFuture ...
[10:30:54.546] - result already collected: FutureResult
[10:30:54.546] result() for ClusterFuture ... done
[10:30:54.546] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.546] Future #1
[10:30:54.546] result() for ClusterFuture ...
[10:30:54.546] - result already collected: FutureResult
[10:30:54.546] result() for ClusterFuture ... done
[10:30:54.546] result() for ClusterFuture ...
[10:30:54.546] - result already collected: FutureResult
[10:30:54.546] result() for ClusterFuture ... done
[10:30:54.546] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:54.547] - nx: 1
[10:30:54.547] - relay: TRUE
[10:30:54.547] - stdout: TRUE
[10:30:54.547] - signal: TRUE
[10:30:54.547] - resignal: FALSE
[10:30:54.547] - force: TRUE
[10:30:54.547] - relayed: [n=1] FALSE
[10:30:54.547] - queued futures: [n=1] FALSE
[10:30:54.547]  - until=1
[10:30:54.547]  - relaying element #1
[10:30:54.547] result() for ClusterFuture ...
[10:30:54.547] - result already collected: FutureResult
[10:30:54.548] result() for ClusterFuture ... done
[10:30:54.548] result() for ClusterFuture ...
[10:30:54.548] - result already collected: FutureResult
[10:30:54.548] result() for ClusterFuture ... done
[10:30:54.548] result() for ClusterFuture ...
[10:30:54.548] - result already collected: FutureResult
[10:30:54.548] result() for ClusterFuture ... done
[10:30:54.548] result() for ClusterFuture ...
[10:30:54.548] - result already collected: FutureResult
[10:30:54.548] result() for ClusterFuture ... done
[10:30:54.548] - relayed: [n=1] TRUE
[10:30:54.549] - queued futures: [n=1] TRUE
[10:30:54.549] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:54.549]  length: 0 (resolved future 1)
[10:30:54.549] Relaying remaining futures
[10:30:54.549] signalConditionsASAP(NULL, pos=0) ...
[10:30:54.549] - nx: 1
[10:30:54.549] - relay: TRUE
[10:30:54.549] - stdout: TRUE
[10:30:54.549] - signal: TRUE
[10:30:54.549] - resignal: FALSE
[10:30:54.549] - force: TRUE
[10:30:54.549] - relayed: [n=1] TRUE
[10:30:54.550] - queued futures: [n=1] TRUE
 - flush all
[10:30:54.550] - relayed: [n=1] TRUE
[10:30:54.550] - queued futures: [n=1] TRUE
[10:30:54.550] signalConditionsASAP(NULL, pos=0) ... done
[10:30:54.550] resolve() on list ... DONE
[10:30:54.550] result() for ClusterFuture ...
[10:30:54.550] - result already collected: FutureResult
[10:30:54.550] result() for ClusterFuture ... done
[10:30:54.550] result() for ClusterFuture ...
[10:30:54.550] - result already collected: FutureResult
[10:30:54.550] result() for ClusterFuture ... done
[10:30:54.551]  - Number of value chunks collected: 1
[10:30:54.551] Resolving 1 futures (chunks) ... DONE
[10:30:54.551] Reducing values from 1 chunks ...
[10:30:54.551]  - Number of values collected after concatenation: 1
[10:30:54.551]  - Number of values expected: 1
[10:30:54.551] Reducing values from 1 chunks ... DONE
[10:30:54.551] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[10:30:54.551] future_mapply() ...
[10:30:54.555] Number of chunks: 2
[10:30:54.556] getGlobalsAndPackagesXApply() ...
[10:30:54.556]  - future.globals: TRUE
[10:30:54.556] getGlobalsAndPackages() ...
[10:30:54.556] Searching for globals...
[10:30:54.557] - globals found: [1] ‘FUN’
[10:30:54.557] Searching for globals ... DONE
[10:30:54.557] Resolving globals: FALSE
[10:30:54.558] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[10:30:54.558] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[10:30:54.558] - globals: [1] ‘FUN’
[10:30:54.558] 
[10:30:54.558] getGlobalsAndPackages() ... DONE
[10:30:54.558]  - globals found/used: [n=1] ‘FUN’
[10:30:54.558]  - needed namespaces: [n=0] 
[10:30:54.559] Finding globals ... DONE
[10:30:54.559] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:54.559] List of 2
[10:30:54.559]  $ ...future.FUN:function (x, y)  
[10:30:54.559]  $ MoreArgs     :List of 1
[10:30:54.559]   ..$ y: int [1:2] 3 4
[10:30:54.559]  - attr(*, "where")=List of 2
[10:30:54.559]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:54.559]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:54.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:54.559]  - attr(*, "resolved")= logi FALSE
[10:30:54.559]  - attr(*, "total_size")= num NA
[10:30:54.562] Packages to be attached in all futures: [n=0] 
[10:30:54.562] getGlobalsAndPackagesXApply() ... DONE
[10:30:54.562] Number of futures (= number of chunks): 2
[10:30:54.562] Launching 2 futures (chunks) ...
[10:30:54.562] Chunk #1 of 2 ...
[10:30:54.562]  - Finding globals in '...' for chunk #1 ...
[10:30:54.562] getGlobalsAndPackages() ...
[10:30:54.563] Searching for globals...
[10:30:54.563] 
[10:30:54.563] Searching for globals ... DONE
[10:30:54.563] - globals: [0] <none>
[10:30:54.563] getGlobalsAndPackages() ... DONE
[10:30:54.563]    + additional globals found: [n=0] 
[10:30:54.563]    + additional namespaces needed: [n=0] 
[10:30:54.563]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:54.563]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.564]  - seeds: <none>
[10:30:54.564]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.564] getGlobalsAndPackages() ...
[10:30:54.564] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.564] Resolving globals: FALSE
[10:30:54.564] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[10:30:54.565] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[10:30:54.565] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.565] 
[10:30:54.565] getGlobalsAndPackages() ... DONE
[10:30:54.566] run() for ‘Future’ ...
[10:30:54.566] - state: ‘created’
[10:30:54.566] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.580] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.580]   - Field: ‘node’
[10:30:54.581]   - Field: ‘label’
[10:30:54.581]   - Field: ‘local’
[10:30:54.581]   - Field: ‘owner’
[10:30:54.581]   - Field: ‘envir’
[10:30:54.581]   - Field: ‘workers’
[10:30:54.581]   - Field: ‘packages’
[10:30:54.581]   - Field: ‘gc’
[10:30:54.581]   - Field: ‘conditions’
[10:30:54.581]   - Field: ‘persistent’
[10:30:54.581]   - Field: ‘expr’
[10:30:54.582]   - Field: ‘uuid’
[10:30:54.582]   - Field: ‘seed’
[10:30:54.582]   - Field: ‘version’
[10:30:54.582]   - Field: ‘result’
[10:30:54.582]   - Field: ‘asynchronous’
[10:30:54.582]   - Field: ‘calls’
[10:30:54.582]   - Field: ‘globals’
[10:30:54.582]   - Field: ‘stdout’
[10:30:54.582]   - Field: ‘earlySignal’
[10:30:54.582]   - Field: ‘lazy’
[10:30:54.582]   - Field: ‘state’
[10:30:54.583] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.583] - Launch lazy future ...
[10:30:54.583] Packages needed by the future expression (n = 0): <none>
[10:30:54.583] Packages needed by future strategies (n = 0): <none>
[10:30:54.583] {
[10:30:54.583]     {
[10:30:54.583]         {
[10:30:54.583]             ...future.startTime <- base::Sys.time()
[10:30:54.583]             {
[10:30:54.583]                 {
[10:30:54.583]                   {
[10:30:54.583]                     {
[10:30:54.583]                       base::local({
[10:30:54.583]                         has_future <- base::requireNamespace("future", 
[10:30:54.583]                           quietly = TRUE)
[10:30:54.583]                         if (has_future) {
[10:30:54.583]                           ns <- base::getNamespace("future")
[10:30:54.583]                           version <- ns[[".package"]][["version"]]
[10:30:54.583]                           if (is.null(version)) 
[10:30:54.583]                             version <- utils::packageVersion("future")
[10:30:54.583]                         }
[10:30:54.583]                         else {
[10:30:54.583]                           version <- NULL
[10:30:54.583]                         }
[10:30:54.583]                         if (!has_future || version < "1.8.0") {
[10:30:54.583]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.583]                             "", base::R.version$version.string), 
[10:30:54.583]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.583]                               "release", "version")], collapse = " "), 
[10:30:54.583]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.583]                             info)
[10:30:54.583]                           info <- base::paste(info, collapse = "; ")
[10:30:54.583]                           if (!has_future) {
[10:30:54.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.583]                               info)
[10:30:54.583]                           }
[10:30:54.583]                           else {
[10:30:54.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.583]                               info, version)
[10:30:54.583]                           }
[10:30:54.583]                           base::stop(msg)
[10:30:54.583]                         }
[10:30:54.583]                       })
[10:30:54.583]                     }
[10:30:54.583]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.583]                     base::options(mc.cores = 1L)
[10:30:54.583]                   }
[10:30:54.583]                   ...future.strategy.old <- future::plan("list")
[10:30:54.583]                   options(future.plan = NULL)
[10:30:54.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.583]                 }
[10:30:54.583]                 ...future.workdir <- getwd()
[10:30:54.583]             }
[10:30:54.583]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.583]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.583]         }
[10:30:54.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.583]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.583]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.583]             base::names(...future.oldOptions))
[10:30:54.583]     }
[10:30:54.583]     if (FALSE) {
[10:30:54.583]     }
[10:30:54.583]     else {
[10:30:54.583]         if (TRUE) {
[10:30:54.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.583]                 open = "w")
[10:30:54.583]         }
[10:30:54.583]         else {
[10:30:54.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.583]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.583]         }
[10:30:54.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.583]             base::sink(type = "output", split = FALSE)
[10:30:54.583]             base::close(...future.stdout)
[10:30:54.583]         }, add = TRUE)
[10:30:54.583]     }
[10:30:54.583]     ...future.frame <- base::sys.nframe()
[10:30:54.583]     ...future.conditions <- base::list()
[10:30:54.583]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.583]     if (FALSE) {
[10:30:54.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.583]     }
[10:30:54.583]     ...future.result <- base::tryCatch({
[10:30:54.583]         base::withCallingHandlers({
[10:30:54.583]             ...future.value <- base::withVisible(base::local({
[10:30:54.583]                 ...future.makeSendCondition <- base::local({
[10:30:54.583]                   sendCondition <- NULL
[10:30:54.583]                   function(frame = 1L) {
[10:30:54.583]                     if (is.function(sendCondition)) 
[10:30:54.583]                       return(sendCondition)
[10:30:54.583]                     ns <- getNamespace("parallel")
[10:30:54.583]                     if (exists("sendData", mode = "function", 
[10:30:54.583]                       envir = ns)) {
[10:30:54.583]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.583]                         envir = ns)
[10:30:54.583]                       envir <- sys.frame(frame)
[10:30:54.583]                       master <- NULL
[10:30:54.583]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.583]                         !identical(envir, emptyenv())) {
[10:30:54.583]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.583]                           inherits = FALSE)) {
[10:30:54.583]                           master <- get("master", mode = "list", 
[10:30:54.583]                             envir = envir, inherits = FALSE)
[10:30:54.583]                           if (inherits(master, c("SOCKnode", 
[10:30:54.583]                             "SOCK0node"))) {
[10:30:54.583]                             sendCondition <<- function(cond) {
[10:30:54.583]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.583]                                 success = TRUE)
[10:30:54.583]                               parallel_sendData(master, data)
[10:30:54.583]                             }
[10:30:54.583]                             return(sendCondition)
[10:30:54.583]                           }
[10:30:54.583]                         }
[10:30:54.583]                         frame <- frame + 1L
[10:30:54.583]                         envir <- sys.frame(frame)
[10:30:54.583]                       }
[10:30:54.583]                     }
[10:30:54.583]                     sendCondition <<- function(cond) NULL
[10:30:54.583]                   }
[10:30:54.583]                 })
[10:30:54.583]                 withCallingHandlers({
[10:30:54.583]                   {
[10:30:54.583]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.583]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.583]                       ...future.globals.maxSize)) {
[10:30:54.583]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.583]                       on.exit(options(oopts), add = TRUE)
[10:30:54.583]                     }
[10:30:54.583]                     {
[10:30:54.583]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.583]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.583]                         USE.NAMES = FALSE)
[10:30:54.583]                       do.call(mapply, args = args)
[10:30:54.583]                     }
[10:30:54.583]                   }
[10:30:54.583]                 }, immediateCondition = function(cond) {
[10:30:54.583]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.583]                   sendCondition(cond)
[10:30:54.583]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.583]                   {
[10:30:54.583]                     inherits <- base::inherits
[10:30:54.583]                     invokeRestart <- base::invokeRestart
[10:30:54.583]                     is.null <- base::is.null
[10:30:54.583]                     muffled <- FALSE
[10:30:54.583]                     if (inherits(cond, "message")) {
[10:30:54.583]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.583]                       if (muffled) 
[10:30:54.583]                         invokeRestart("muffleMessage")
[10:30:54.583]                     }
[10:30:54.583]                     else if (inherits(cond, "warning")) {
[10:30:54.583]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.583]                       if (muffled) 
[10:30:54.583]                         invokeRestart("muffleWarning")
[10:30:54.583]                     }
[10:30:54.583]                     else if (inherits(cond, "condition")) {
[10:30:54.583]                       if (!is.null(pattern)) {
[10:30:54.583]                         computeRestarts <- base::computeRestarts
[10:30:54.583]                         grepl <- base::grepl
[10:30:54.583]                         restarts <- computeRestarts(cond)
[10:30:54.583]                         for (restart in restarts) {
[10:30:54.583]                           name <- restart$name
[10:30:54.583]                           if (is.null(name)) 
[10:30:54.583]                             next
[10:30:54.583]                           if (!grepl(pattern, name)) 
[10:30:54.583]                             next
[10:30:54.583]                           invokeRestart(restart)
[10:30:54.583]                           muffled <- TRUE
[10:30:54.583]                           break
[10:30:54.583]                         }
[10:30:54.583]                       }
[10:30:54.583]                     }
[10:30:54.583]                     invisible(muffled)
[10:30:54.583]                   }
[10:30:54.583]                   muffleCondition(cond)
[10:30:54.583]                 })
[10:30:54.583]             }))
[10:30:54.583]             future::FutureResult(value = ...future.value$value, 
[10:30:54.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.583]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.583]                     ...future.globalenv.names))
[10:30:54.583]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.583]         }, condition = base::local({
[10:30:54.583]             c <- base::c
[10:30:54.583]             inherits <- base::inherits
[10:30:54.583]             invokeRestart <- base::invokeRestart
[10:30:54.583]             length <- base::length
[10:30:54.583]             list <- base::list
[10:30:54.583]             seq.int <- base::seq.int
[10:30:54.583]             signalCondition <- base::signalCondition
[10:30:54.583]             sys.calls <- base::sys.calls
[10:30:54.583]             `[[` <- base::`[[`
[10:30:54.583]             `+` <- base::`+`
[10:30:54.583]             `<<-` <- base::`<<-`
[10:30:54.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.583]                   3L)]
[10:30:54.583]             }
[10:30:54.583]             function(cond) {
[10:30:54.583]                 is_error <- inherits(cond, "error")
[10:30:54.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.583]                   NULL)
[10:30:54.583]                 if (is_error) {
[10:30:54.583]                   sessionInformation <- function() {
[10:30:54.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.583]                       search = base::search(), system = base::Sys.info())
[10:30:54.583]                   }
[10:30:54.583]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.583]                     cond$call), session = sessionInformation(), 
[10:30:54.583]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.583]                   signalCondition(cond)
[10:30:54.583]                 }
[10:30:54.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.583]                 "immediateCondition"))) {
[10:30:54.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.583]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.583]                   if (TRUE && !signal) {
[10:30:54.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.583]                     {
[10:30:54.583]                       inherits <- base::inherits
[10:30:54.583]                       invokeRestart <- base::invokeRestart
[10:30:54.583]                       is.null <- base::is.null
[10:30:54.583]                       muffled <- FALSE
[10:30:54.583]                       if (inherits(cond, "message")) {
[10:30:54.583]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.583]                         if (muffled) 
[10:30:54.583]                           invokeRestart("muffleMessage")
[10:30:54.583]                       }
[10:30:54.583]                       else if (inherits(cond, "warning")) {
[10:30:54.583]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.583]                         if (muffled) 
[10:30:54.583]                           invokeRestart("muffleWarning")
[10:30:54.583]                       }
[10:30:54.583]                       else if (inherits(cond, "condition")) {
[10:30:54.583]                         if (!is.null(pattern)) {
[10:30:54.583]                           computeRestarts <- base::computeRestarts
[10:30:54.583]                           grepl <- base::grepl
[10:30:54.583]                           restarts <- computeRestarts(cond)
[10:30:54.583]                           for (restart in restarts) {
[10:30:54.583]                             name <- restart$name
[10:30:54.583]                             if (is.null(name)) 
[10:30:54.583]                               next
[10:30:54.583]                             if (!grepl(pattern, name)) 
[10:30:54.583]                               next
[10:30:54.583]                             invokeRestart(restart)
[10:30:54.583]                             muffled <- TRUE
[10:30:54.583]                             break
[10:30:54.583]                           }
[10:30:54.583]                         }
[10:30:54.583]                       }
[10:30:54.583]                       invisible(muffled)
[10:30:54.583]                     }
[10:30:54.583]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.583]                   }
[10:30:54.583]                 }
[10:30:54.583]                 else {
[10:30:54.583]                   if (TRUE) {
[10:30:54.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.583]                     {
[10:30:54.583]                       inherits <- base::inherits
[10:30:54.583]                       invokeRestart <- base::invokeRestart
[10:30:54.583]                       is.null <- base::is.null
[10:30:54.583]                       muffled <- FALSE
[10:30:54.583]                       if (inherits(cond, "message")) {
[10:30:54.583]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.583]                         if (muffled) 
[10:30:54.583]                           invokeRestart("muffleMessage")
[10:30:54.583]                       }
[10:30:54.583]                       else if (inherits(cond, "warning")) {
[10:30:54.583]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.583]                         if (muffled) 
[10:30:54.583]                           invokeRestart("muffleWarning")
[10:30:54.583]                       }
[10:30:54.583]                       else if (inherits(cond, "condition")) {
[10:30:54.583]                         if (!is.null(pattern)) {
[10:30:54.583]                           computeRestarts <- base::computeRestarts
[10:30:54.583]                           grepl <- base::grepl
[10:30:54.583]                           restarts <- computeRestarts(cond)
[10:30:54.583]                           for (restart in restarts) {
[10:30:54.583]                             name <- restart$name
[10:30:54.583]                             if (is.null(name)) 
[10:30:54.583]                               next
[10:30:54.583]                             if (!grepl(pattern, name)) 
[10:30:54.583]                               next
[10:30:54.583]                             invokeRestart(restart)
[10:30:54.583]                             muffled <- TRUE
[10:30:54.583]                             break
[10:30:54.583]                           }
[10:30:54.583]                         }
[10:30:54.583]                       }
[10:30:54.583]                       invisible(muffled)
[10:30:54.583]                     }
[10:30:54.583]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.583]                   }
[10:30:54.583]                 }
[10:30:54.583]             }
[10:30:54.583]         }))
[10:30:54.583]     }, error = function(ex) {
[10:30:54.583]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.583]                 ...future.rng), started = ...future.startTime, 
[10:30:54.583]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.583]             version = "1.8"), class = "FutureResult")
[10:30:54.583]     }, finally = {
[10:30:54.583]         if (!identical(...future.workdir, getwd())) 
[10:30:54.583]             setwd(...future.workdir)
[10:30:54.583]         {
[10:30:54.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.583]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.583]             }
[10:30:54.583]             base::options(...future.oldOptions)
[10:30:54.583]             if (.Platform$OS.type == "windows") {
[10:30:54.583]                 old_names <- names(...future.oldEnvVars)
[10:30:54.583]                 envs <- base::Sys.getenv()
[10:30:54.583]                 names <- names(envs)
[10:30:54.583]                 common <- intersect(names, old_names)
[10:30:54.583]                 added <- setdiff(names, old_names)
[10:30:54.583]                 removed <- setdiff(old_names, names)
[10:30:54.583]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.583]                   envs[common]]
[10:30:54.583]                 NAMES <- toupper(changed)
[10:30:54.583]                 args <- list()
[10:30:54.583]                 for (kk in seq_along(NAMES)) {
[10:30:54.583]                   name <- changed[[kk]]
[10:30:54.583]                   NAME <- NAMES[[kk]]
[10:30:54.583]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.583]                     next
[10:30:54.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.583]                 }
[10:30:54.583]                 NAMES <- toupper(added)
[10:30:54.583]                 for (kk in seq_along(NAMES)) {
[10:30:54.583]                   name <- added[[kk]]
[10:30:54.583]                   NAME <- NAMES[[kk]]
[10:30:54.583]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.583]                     next
[10:30:54.583]                   args[[name]] <- ""
[10:30:54.583]                 }
[10:30:54.583]                 NAMES <- toupper(removed)
[10:30:54.583]                 for (kk in seq_along(NAMES)) {
[10:30:54.583]                   name <- removed[[kk]]
[10:30:54.583]                   NAME <- NAMES[[kk]]
[10:30:54.583]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.583]                     next
[10:30:54.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.583]                 }
[10:30:54.583]                 if (length(args) > 0) 
[10:30:54.583]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.583]             }
[10:30:54.583]             else {
[10:30:54.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.583]             }
[10:30:54.583]             {
[10:30:54.583]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.583]                   0L) {
[10:30:54.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.583]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.583]                   base::options(opts)
[10:30:54.583]                 }
[10:30:54.583]                 {
[10:30:54.583]                   {
[10:30:54.583]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.583]                     NULL
[10:30:54.583]                   }
[10:30:54.583]                   options(future.plan = NULL)
[10:30:54.583]                   if (is.na(NA_character_)) 
[10:30:54.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.583]                     .init = FALSE)
[10:30:54.583]                 }
[10:30:54.583]             }
[10:30:54.583]         }
[10:30:54.583]     })
[10:30:54.583]     if (TRUE) {
[10:30:54.583]         base::sink(type = "output", split = FALSE)
[10:30:54.583]         if (TRUE) {
[10:30:54.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.583]         }
[10:30:54.583]         else {
[10:30:54.583]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.583]         }
[10:30:54.583]         base::close(...future.stdout)
[10:30:54.583]         ...future.stdout <- NULL
[10:30:54.583]     }
[10:30:54.583]     ...future.result$conditions <- ...future.conditions
[10:30:54.583]     ...future.result$finished <- base::Sys.time()
[10:30:54.583]     ...future.result
[10:30:54.583] }
[10:30:54.586] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[10:30:54.586] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[10:30:54.587] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[10:30:54.587] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[10:30:54.587] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[10:30:54.590] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:30:54.591] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:30:54.591] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:54.591] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.591] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:54.591] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.592] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[10:30:54.592] MultisessionFuture started
[10:30:54.592] - Launch lazy future ... done
[10:30:54.592] run() for ‘MultisessionFuture’ ... done
[10:30:54.592] Created future:
[10:30:54.592] MultisessionFuture:
[10:30:54.592] Label: ‘future_mapply-1’
[10:30:54.592] Expression:
[10:30:54.592] {
[10:30:54.592]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.592]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.592]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.592]         on.exit(options(oopts), add = TRUE)
[10:30:54.592]     }
[10:30:54.592]     {
[10:30:54.592]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.592]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.592]         do.call(mapply, args = args)
[10:30:54.592]     }
[10:30:54.592] }
[10:30:54.592] Lazy evaluation: FALSE
[10:30:54.592] Asynchronous evaluation: TRUE
[10:30:54.592] Local evaluation: TRUE
[10:30:54.592] Environment: R_GlobalEnv
[10:30:54.592] Capture standard output: TRUE
[10:30:54.592] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.592] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.592] Packages: <none>
[10:30:54.592] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.592] Resolved: FALSE
[10:30:54.592] Value: <not collected>
[10:30:54.592] Conditions captured: <none>
[10:30:54.592] Early signaling: FALSE
[10:30:54.592] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.592] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.604] Chunk #1 of 2 ... DONE
[10:30:54.604] Chunk #2 of 2 ...
[10:30:54.604]  - Finding globals in '...' for chunk #2 ...
[10:30:54.604] getGlobalsAndPackages() ...
[10:30:54.604] Searching for globals...
[10:30:54.605] 
[10:30:54.605] Searching for globals ... DONE
[10:30:54.605] - globals: [0] <none>
[10:30:54.605] getGlobalsAndPackages() ... DONE
[10:30:54.605]    + additional globals found: [n=0] 
[10:30:54.605]    + additional namespaces needed: [n=0] 
[10:30:54.605]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:54.605]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.606]  - seeds: <none>
[10:30:54.606]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.606] getGlobalsAndPackages() ...
[10:30:54.606] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.606] Resolving globals: FALSE
[10:30:54.606] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[10:30:54.607] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[10:30:54.607] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.607] 
[10:30:54.607] getGlobalsAndPackages() ... DONE
[10:30:54.607] run() for ‘Future’ ...
[10:30:54.608] - state: ‘created’
[10:30:54.608] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.621] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.622]   - Field: ‘node’
[10:30:54.622]   - Field: ‘label’
[10:30:54.622]   - Field: ‘local’
[10:30:54.622]   - Field: ‘owner’
[10:30:54.622]   - Field: ‘envir’
[10:30:54.622]   - Field: ‘workers’
[10:30:54.622]   - Field: ‘packages’
[10:30:54.622]   - Field: ‘gc’
[10:30:54.622]   - Field: ‘conditions’
[10:30:54.623]   - Field: ‘persistent’
[10:30:54.623]   - Field: ‘expr’
[10:30:54.623]   - Field: ‘uuid’
[10:30:54.623]   - Field: ‘seed’
[10:30:54.623]   - Field: ‘version’
[10:30:54.623]   - Field: ‘result’
[10:30:54.623]   - Field: ‘asynchronous’
[10:30:54.623]   - Field: ‘calls’
[10:30:54.623]   - Field: ‘globals’
[10:30:54.623]   - Field: ‘stdout’
[10:30:54.623]   - Field: ‘earlySignal’
[10:30:54.624]   - Field: ‘lazy’
[10:30:54.624]   - Field: ‘state’
[10:30:54.624] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.624] - Launch lazy future ...
[10:30:54.624] Packages needed by the future expression (n = 0): <none>
[10:30:54.624] Packages needed by future strategies (n = 0): <none>
[10:30:54.625] {
[10:30:54.625]     {
[10:30:54.625]         {
[10:30:54.625]             ...future.startTime <- base::Sys.time()
[10:30:54.625]             {
[10:30:54.625]                 {
[10:30:54.625]                   {
[10:30:54.625]                     {
[10:30:54.625]                       base::local({
[10:30:54.625]                         has_future <- base::requireNamespace("future", 
[10:30:54.625]                           quietly = TRUE)
[10:30:54.625]                         if (has_future) {
[10:30:54.625]                           ns <- base::getNamespace("future")
[10:30:54.625]                           version <- ns[[".package"]][["version"]]
[10:30:54.625]                           if (is.null(version)) 
[10:30:54.625]                             version <- utils::packageVersion("future")
[10:30:54.625]                         }
[10:30:54.625]                         else {
[10:30:54.625]                           version <- NULL
[10:30:54.625]                         }
[10:30:54.625]                         if (!has_future || version < "1.8.0") {
[10:30:54.625]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.625]                             "", base::R.version$version.string), 
[10:30:54.625]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.625]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.625]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.625]                               "release", "version")], collapse = " "), 
[10:30:54.625]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.625]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.625]                             info)
[10:30:54.625]                           info <- base::paste(info, collapse = "; ")
[10:30:54.625]                           if (!has_future) {
[10:30:54.625]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.625]                               info)
[10:30:54.625]                           }
[10:30:54.625]                           else {
[10:30:54.625]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.625]                               info, version)
[10:30:54.625]                           }
[10:30:54.625]                           base::stop(msg)
[10:30:54.625]                         }
[10:30:54.625]                       })
[10:30:54.625]                     }
[10:30:54.625]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.625]                     base::options(mc.cores = 1L)
[10:30:54.625]                   }
[10:30:54.625]                   ...future.strategy.old <- future::plan("list")
[10:30:54.625]                   options(future.plan = NULL)
[10:30:54.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.625]                 }
[10:30:54.625]                 ...future.workdir <- getwd()
[10:30:54.625]             }
[10:30:54.625]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.625]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.625]         }
[10:30:54.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.625]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.625]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.625]             base::names(...future.oldOptions))
[10:30:54.625]     }
[10:30:54.625]     if (FALSE) {
[10:30:54.625]     }
[10:30:54.625]     else {
[10:30:54.625]         if (TRUE) {
[10:30:54.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.625]                 open = "w")
[10:30:54.625]         }
[10:30:54.625]         else {
[10:30:54.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.625]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.625]         }
[10:30:54.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.625]             base::sink(type = "output", split = FALSE)
[10:30:54.625]             base::close(...future.stdout)
[10:30:54.625]         }, add = TRUE)
[10:30:54.625]     }
[10:30:54.625]     ...future.frame <- base::sys.nframe()
[10:30:54.625]     ...future.conditions <- base::list()
[10:30:54.625]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.625]     if (FALSE) {
[10:30:54.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.625]     }
[10:30:54.625]     ...future.result <- base::tryCatch({
[10:30:54.625]         base::withCallingHandlers({
[10:30:54.625]             ...future.value <- base::withVisible(base::local({
[10:30:54.625]                 ...future.makeSendCondition <- base::local({
[10:30:54.625]                   sendCondition <- NULL
[10:30:54.625]                   function(frame = 1L) {
[10:30:54.625]                     if (is.function(sendCondition)) 
[10:30:54.625]                       return(sendCondition)
[10:30:54.625]                     ns <- getNamespace("parallel")
[10:30:54.625]                     if (exists("sendData", mode = "function", 
[10:30:54.625]                       envir = ns)) {
[10:30:54.625]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.625]                         envir = ns)
[10:30:54.625]                       envir <- sys.frame(frame)
[10:30:54.625]                       master <- NULL
[10:30:54.625]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.625]                         !identical(envir, emptyenv())) {
[10:30:54.625]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.625]                           inherits = FALSE)) {
[10:30:54.625]                           master <- get("master", mode = "list", 
[10:30:54.625]                             envir = envir, inherits = FALSE)
[10:30:54.625]                           if (inherits(master, c("SOCKnode", 
[10:30:54.625]                             "SOCK0node"))) {
[10:30:54.625]                             sendCondition <<- function(cond) {
[10:30:54.625]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.625]                                 success = TRUE)
[10:30:54.625]                               parallel_sendData(master, data)
[10:30:54.625]                             }
[10:30:54.625]                             return(sendCondition)
[10:30:54.625]                           }
[10:30:54.625]                         }
[10:30:54.625]                         frame <- frame + 1L
[10:30:54.625]                         envir <- sys.frame(frame)
[10:30:54.625]                       }
[10:30:54.625]                     }
[10:30:54.625]                     sendCondition <<- function(cond) NULL
[10:30:54.625]                   }
[10:30:54.625]                 })
[10:30:54.625]                 withCallingHandlers({
[10:30:54.625]                   {
[10:30:54.625]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.625]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.625]                       ...future.globals.maxSize)) {
[10:30:54.625]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.625]                       on.exit(options(oopts), add = TRUE)
[10:30:54.625]                     }
[10:30:54.625]                     {
[10:30:54.625]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.625]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.625]                         USE.NAMES = FALSE)
[10:30:54.625]                       do.call(mapply, args = args)
[10:30:54.625]                     }
[10:30:54.625]                   }
[10:30:54.625]                 }, immediateCondition = function(cond) {
[10:30:54.625]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.625]                   sendCondition(cond)
[10:30:54.625]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.625]                   {
[10:30:54.625]                     inherits <- base::inherits
[10:30:54.625]                     invokeRestart <- base::invokeRestart
[10:30:54.625]                     is.null <- base::is.null
[10:30:54.625]                     muffled <- FALSE
[10:30:54.625]                     if (inherits(cond, "message")) {
[10:30:54.625]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.625]                       if (muffled) 
[10:30:54.625]                         invokeRestart("muffleMessage")
[10:30:54.625]                     }
[10:30:54.625]                     else if (inherits(cond, "warning")) {
[10:30:54.625]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.625]                       if (muffled) 
[10:30:54.625]                         invokeRestart("muffleWarning")
[10:30:54.625]                     }
[10:30:54.625]                     else if (inherits(cond, "condition")) {
[10:30:54.625]                       if (!is.null(pattern)) {
[10:30:54.625]                         computeRestarts <- base::computeRestarts
[10:30:54.625]                         grepl <- base::grepl
[10:30:54.625]                         restarts <- computeRestarts(cond)
[10:30:54.625]                         for (restart in restarts) {
[10:30:54.625]                           name <- restart$name
[10:30:54.625]                           if (is.null(name)) 
[10:30:54.625]                             next
[10:30:54.625]                           if (!grepl(pattern, name)) 
[10:30:54.625]                             next
[10:30:54.625]                           invokeRestart(restart)
[10:30:54.625]                           muffled <- TRUE
[10:30:54.625]                           break
[10:30:54.625]                         }
[10:30:54.625]                       }
[10:30:54.625]                     }
[10:30:54.625]                     invisible(muffled)
[10:30:54.625]                   }
[10:30:54.625]                   muffleCondition(cond)
[10:30:54.625]                 })
[10:30:54.625]             }))
[10:30:54.625]             future::FutureResult(value = ...future.value$value, 
[10:30:54.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.625]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.625]                     ...future.globalenv.names))
[10:30:54.625]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.625]         }, condition = base::local({
[10:30:54.625]             c <- base::c
[10:30:54.625]             inherits <- base::inherits
[10:30:54.625]             invokeRestart <- base::invokeRestart
[10:30:54.625]             length <- base::length
[10:30:54.625]             list <- base::list
[10:30:54.625]             seq.int <- base::seq.int
[10:30:54.625]             signalCondition <- base::signalCondition
[10:30:54.625]             sys.calls <- base::sys.calls
[10:30:54.625]             `[[` <- base::`[[`
[10:30:54.625]             `+` <- base::`+`
[10:30:54.625]             `<<-` <- base::`<<-`
[10:30:54.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.625]                   3L)]
[10:30:54.625]             }
[10:30:54.625]             function(cond) {
[10:30:54.625]                 is_error <- inherits(cond, "error")
[10:30:54.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.625]                   NULL)
[10:30:54.625]                 if (is_error) {
[10:30:54.625]                   sessionInformation <- function() {
[10:30:54.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.625]                       search = base::search(), system = base::Sys.info())
[10:30:54.625]                   }
[10:30:54.625]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.625]                     cond$call), session = sessionInformation(), 
[10:30:54.625]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.625]                   signalCondition(cond)
[10:30:54.625]                 }
[10:30:54.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.625]                 "immediateCondition"))) {
[10:30:54.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.625]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.625]                   if (TRUE && !signal) {
[10:30:54.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.625]                     {
[10:30:54.625]                       inherits <- base::inherits
[10:30:54.625]                       invokeRestart <- base::invokeRestart
[10:30:54.625]                       is.null <- base::is.null
[10:30:54.625]                       muffled <- FALSE
[10:30:54.625]                       if (inherits(cond, "message")) {
[10:30:54.625]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.625]                         if (muffled) 
[10:30:54.625]                           invokeRestart("muffleMessage")
[10:30:54.625]                       }
[10:30:54.625]                       else if (inherits(cond, "warning")) {
[10:30:54.625]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.625]                         if (muffled) 
[10:30:54.625]                           invokeRestart("muffleWarning")
[10:30:54.625]                       }
[10:30:54.625]                       else if (inherits(cond, "condition")) {
[10:30:54.625]                         if (!is.null(pattern)) {
[10:30:54.625]                           computeRestarts <- base::computeRestarts
[10:30:54.625]                           grepl <- base::grepl
[10:30:54.625]                           restarts <- computeRestarts(cond)
[10:30:54.625]                           for (restart in restarts) {
[10:30:54.625]                             name <- restart$name
[10:30:54.625]                             if (is.null(name)) 
[10:30:54.625]                               next
[10:30:54.625]                             if (!grepl(pattern, name)) 
[10:30:54.625]                               next
[10:30:54.625]                             invokeRestart(restart)
[10:30:54.625]                             muffled <- TRUE
[10:30:54.625]                             break
[10:30:54.625]                           }
[10:30:54.625]                         }
[10:30:54.625]                       }
[10:30:54.625]                       invisible(muffled)
[10:30:54.625]                     }
[10:30:54.625]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.625]                   }
[10:30:54.625]                 }
[10:30:54.625]                 else {
[10:30:54.625]                   if (TRUE) {
[10:30:54.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.625]                     {
[10:30:54.625]                       inherits <- base::inherits
[10:30:54.625]                       invokeRestart <- base::invokeRestart
[10:30:54.625]                       is.null <- base::is.null
[10:30:54.625]                       muffled <- FALSE
[10:30:54.625]                       if (inherits(cond, "message")) {
[10:30:54.625]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.625]                         if (muffled) 
[10:30:54.625]                           invokeRestart("muffleMessage")
[10:30:54.625]                       }
[10:30:54.625]                       else if (inherits(cond, "warning")) {
[10:30:54.625]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.625]                         if (muffled) 
[10:30:54.625]                           invokeRestart("muffleWarning")
[10:30:54.625]                       }
[10:30:54.625]                       else if (inherits(cond, "condition")) {
[10:30:54.625]                         if (!is.null(pattern)) {
[10:30:54.625]                           computeRestarts <- base::computeRestarts
[10:30:54.625]                           grepl <- base::grepl
[10:30:54.625]                           restarts <- computeRestarts(cond)
[10:30:54.625]                           for (restart in restarts) {
[10:30:54.625]                             name <- restart$name
[10:30:54.625]                             if (is.null(name)) 
[10:30:54.625]                               next
[10:30:54.625]                             if (!grepl(pattern, name)) 
[10:30:54.625]                               next
[10:30:54.625]                             invokeRestart(restart)
[10:30:54.625]                             muffled <- TRUE
[10:30:54.625]                             break
[10:30:54.625]                           }
[10:30:54.625]                         }
[10:30:54.625]                       }
[10:30:54.625]                       invisible(muffled)
[10:30:54.625]                     }
[10:30:54.625]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.625]                   }
[10:30:54.625]                 }
[10:30:54.625]             }
[10:30:54.625]         }))
[10:30:54.625]     }, error = function(ex) {
[10:30:54.625]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.625]                 ...future.rng), started = ...future.startTime, 
[10:30:54.625]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.625]             version = "1.8"), class = "FutureResult")
[10:30:54.625]     }, finally = {
[10:30:54.625]         if (!identical(...future.workdir, getwd())) 
[10:30:54.625]             setwd(...future.workdir)
[10:30:54.625]         {
[10:30:54.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.625]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.625]             }
[10:30:54.625]             base::options(...future.oldOptions)
[10:30:54.625]             if (.Platform$OS.type == "windows") {
[10:30:54.625]                 old_names <- names(...future.oldEnvVars)
[10:30:54.625]                 envs <- base::Sys.getenv()
[10:30:54.625]                 names <- names(envs)
[10:30:54.625]                 common <- intersect(names, old_names)
[10:30:54.625]                 added <- setdiff(names, old_names)
[10:30:54.625]                 removed <- setdiff(old_names, names)
[10:30:54.625]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.625]                   envs[common]]
[10:30:54.625]                 NAMES <- toupper(changed)
[10:30:54.625]                 args <- list()
[10:30:54.625]                 for (kk in seq_along(NAMES)) {
[10:30:54.625]                   name <- changed[[kk]]
[10:30:54.625]                   NAME <- NAMES[[kk]]
[10:30:54.625]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.625]                     next
[10:30:54.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.625]                 }
[10:30:54.625]                 NAMES <- toupper(added)
[10:30:54.625]                 for (kk in seq_along(NAMES)) {
[10:30:54.625]                   name <- added[[kk]]
[10:30:54.625]                   NAME <- NAMES[[kk]]
[10:30:54.625]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.625]                     next
[10:30:54.625]                   args[[name]] <- ""
[10:30:54.625]                 }
[10:30:54.625]                 NAMES <- toupper(removed)
[10:30:54.625]                 for (kk in seq_along(NAMES)) {
[10:30:54.625]                   name <- removed[[kk]]
[10:30:54.625]                   NAME <- NAMES[[kk]]
[10:30:54.625]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.625]                     next
[10:30:54.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.625]                 }
[10:30:54.625]                 if (length(args) > 0) 
[10:30:54.625]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.625]             }
[10:30:54.625]             else {
[10:30:54.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.625]             }
[10:30:54.625]             {
[10:30:54.625]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.625]                   0L) {
[10:30:54.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.625]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.625]                   base::options(opts)
[10:30:54.625]                 }
[10:30:54.625]                 {
[10:30:54.625]                   {
[10:30:54.625]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.625]                     NULL
[10:30:54.625]                   }
[10:30:54.625]                   options(future.plan = NULL)
[10:30:54.625]                   if (is.na(NA_character_)) 
[10:30:54.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.625]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.625]                     .init = FALSE)
[10:30:54.625]                 }
[10:30:54.625]             }
[10:30:54.625]         }
[10:30:54.625]     })
[10:30:54.625]     if (TRUE) {
[10:30:54.625]         base::sink(type = "output", split = FALSE)
[10:30:54.625]         if (TRUE) {
[10:30:54.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.625]         }
[10:30:54.625]         else {
[10:30:54.625]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.625]         }
[10:30:54.625]         base::close(...future.stdout)
[10:30:54.625]         ...future.stdout <- NULL
[10:30:54.625]     }
[10:30:54.625]     ...future.result$conditions <- ...future.conditions
[10:30:54.625]     ...future.result$finished <- base::Sys.time()
[10:30:54.625]     ...future.result
[10:30:54.625] }
[10:30:54.627] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[10:30:54.628] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[10:30:54.628] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[10:30:54.628] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[10:30:54.629] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[10:30:54.629] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:30:54.629] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:30:54.629] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:54.630] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.630] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:54.630] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.630] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[10:30:54.631] MultisessionFuture started
[10:30:54.631] - Launch lazy future ... done
[10:30:54.631] run() for ‘MultisessionFuture’ ... done
[10:30:54.631] Created future:
[10:30:54.631] MultisessionFuture:
[10:30:54.631] Label: ‘future_mapply-2’
[10:30:54.631] Expression:
[10:30:54.631] {
[10:30:54.631]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.631]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.631]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.631]         on.exit(options(oopts), add = TRUE)
[10:30:54.631]     }
[10:30:54.631]     {
[10:30:54.631]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.631]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.631]         do.call(mapply, args = args)
[10:30:54.631]     }
[10:30:54.631] }
[10:30:54.631] Lazy evaluation: FALSE
[10:30:54.631] Asynchronous evaluation: TRUE
[10:30:54.631] Local evaluation: TRUE
[10:30:54.631] Environment: R_GlobalEnv
[10:30:54.631] Capture standard output: TRUE
[10:30:54.631] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.631] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.631] Packages: <none>
[10:30:54.631] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.631] Resolved: FALSE
[10:30:54.631] Value: <not collected>
[10:30:54.631] Conditions captured: <none>
[10:30:54.631] Early signaling: FALSE
[10:30:54.631] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.631] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.643] Chunk #2 of 2 ... DONE
[10:30:54.643] Launching 2 futures (chunks) ... DONE
[10:30:54.643] Resolving 2 futures (chunks) ...
[10:30:54.643] resolve() on list ...
[10:30:54.643]  recursive: 0
[10:30:54.643]  length: 2
[10:30:54.643] 
[10:30:54.644] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.644] - Validating connection of MultisessionFuture
[10:30:54.644] - received message: FutureResult
[10:30:54.644] - Received FutureResult
[10:30:54.644] - Erased future from FutureRegistry
[10:30:54.644] result() for ClusterFuture ...
[10:30:54.644] - result already collected: FutureResult
[10:30:54.645] result() for ClusterFuture ... done
[10:30:54.645] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.645] Future #1
[10:30:54.645] result() for ClusterFuture ...
[10:30:54.645] - result already collected: FutureResult
[10:30:54.645] result() for ClusterFuture ... done
[10:30:54.645] result() for ClusterFuture ...
[10:30:54.645] - result already collected: FutureResult
[10:30:54.645] result() for ClusterFuture ... done
[10:30:54.645] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:54.646] - nx: 2
[10:30:54.646] - relay: TRUE
[10:30:54.646] - stdout: TRUE
[10:30:54.646] - signal: TRUE
[10:30:54.646] - resignal: FALSE
[10:30:54.646] - force: TRUE
[10:30:54.646] - relayed: [n=2] FALSE, FALSE
[10:30:54.646] - queued futures: [n=2] FALSE, FALSE
[10:30:54.646]  - until=1
[10:30:54.646]  - relaying element #1
[10:30:54.646] result() for ClusterFuture ...
[10:30:54.646] - result already collected: FutureResult
[10:30:54.647] result() for ClusterFuture ... done
[10:30:54.647] result() for ClusterFuture ...
[10:30:54.647] - result already collected: FutureResult
[10:30:54.647] result() for ClusterFuture ... done
[10:30:54.647] result() for ClusterFuture ...
[10:30:54.647] - result already collected: FutureResult
[10:30:54.647] result() for ClusterFuture ... done
[10:30:54.647] result() for ClusterFuture ...
[10:30:54.647] - result already collected: FutureResult
[10:30:54.647] result() for ClusterFuture ... done
[10:30:54.647] - relayed: [n=2] TRUE, FALSE
[10:30:54.648] - queued futures: [n=2] TRUE, FALSE
[10:30:54.648] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:54.648]  length: 1 (resolved future 1)
[10:30:54.674] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.675] - Validating connection of MultisessionFuture
[10:30:54.675] - received message: FutureResult
[10:30:54.675] - Received FutureResult
[10:30:54.675] - Erased future from FutureRegistry
[10:30:54.675] result() for ClusterFuture ...
[10:30:54.675] - result already collected: FutureResult
[10:30:54.675] result() for ClusterFuture ... done
[10:30:54.676] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.676] Future #2
[10:30:54.676] result() for ClusterFuture ...
[10:30:54.676] - result already collected: FutureResult
[10:30:54.676] result() for ClusterFuture ... done
[10:30:54.676] result() for ClusterFuture ...
[10:30:54.676] - result already collected: FutureResult
[10:30:54.676] result() for ClusterFuture ... done
[10:30:54.676] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:54.676] - nx: 2
[10:30:54.676] - relay: TRUE
[10:30:54.677] - stdout: TRUE
[10:30:54.677] - signal: TRUE
[10:30:54.677] - resignal: FALSE
[10:30:54.677] - force: TRUE
[10:30:54.677] - relayed: [n=2] TRUE, FALSE
[10:30:54.677] - queued futures: [n=2] TRUE, FALSE
[10:30:54.677]  - until=2
[10:30:54.677]  - relaying element #2
[10:30:54.677] result() for ClusterFuture ...
[10:30:54.677] - result already collected: FutureResult
[10:30:54.677] result() for ClusterFuture ... done
[10:30:54.678] result() for ClusterFuture ...
[10:30:54.678] - result already collected: FutureResult
[10:30:54.678] result() for ClusterFuture ... done
[10:30:54.678] result() for ClusterFuture ...
[10:30:54.678] - result already collected: FutureResult
[10:30:54.678] result() for ClusterFuture ... done
[10:30:54.678] result() for ClusterFuture ...
[10:30:54.678] - result already collected: FutureResult
[10:30:54.678] result() for ClusterFuture ... done
[10:30:54.678] - relayed: [n=2] TRUE, TRUE
[10:30:54.678] - queued futures: [n=2] TRUE, TRUE
[10:30:54.678] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:54.679]  length: 0 (resolved future 2)
[10:30:54.679] Relaying remaining futures
[10:30:54.679] signalConditionsASAP(NULL, pos=0) ...
[10:30:54.679] - nx: 2
[10:30:54.679] - relay: TRUE
[10:30:54.679] - stdout: TRUE
[10:30:54.679] - signal: TRUE
[10:30:54.679] - resignal: FALSE
[10:30:54.679] - force: TRUE
[10:30:54.679] - relayed: [n=2] TRUE, TRUE
[10:30:54.679] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:54.680] - relayed: [n=2] TRUE, TRUE
[10:30:54.680] - queued futures: [n=2] TRUE, TRUE
[10:30:54.680] signalConditionsASAP(NULL, pos=0) ... done
[10:30:54.680] resolve() on list ... DONE
[10:30:54.680] result() for ClusterFuture ...
[10:30:54.680] - result already collected: FutureResult
[10:30:54.680] result() for ClusterFuture ... done
[10:30:54.680] result() for ClusterFuture ...
[10:30:54.680] - result already collected: FutureResult
[10:30:54.680] result() for ClusterFuture ... done
[10:30:54.680] result() for ClusterFuture ...
[10:30:54.680] - result already collected: FutureResult
[10:30:54.681] result() for ClusterFuture ... done
[10:30:54.681] result() for ClusterFuture ...
[10:30:54.681] - result already collected: FutureResult
[10:30:54.681] result() for ClusterFuture ... done
[10:30:54.681]  - Number of value chunks collected: 2
[10:30:54.681] Resolving 2 futures (chunks) ... DONE
[10:30:54.681] Reducing values from 2 chunks ...
[10:30:54.681]  - Number of values collected after concatenation: 2
[10:30:54.681]  - Number of values expected: 2
[10:30:54.681] Reducing values from 2 chunks ... DONE
[10:30:54.681] future_mapply() ... DONE
[10:30:54.682] future_mapply() ...
[10:30:54.682] Generating random seeds ...
[10:30:54.682] Generating random seed streams for 2 elements ...
[10:30:54.682] Generating random seed streams for 2 elements ... DONE
[10:30:54.682] Generating random seeds ... DONE
[10:30:54.682] Will set RNG state on exit: 10407, -948834570, 2058285408, -743802738, 669445418, -509989916, -668196096
[10:30:54.686] Number of chunks: 2
[10:30:54.687] getGlobalsAndPackagesXApply() ...
[10:30:54.687]  - future.globals: TRUE
[10:30:54.687] getGlobalsAndPackages() ...
[10:30:54.687] Searching for globals...
[10:30:54.688] - globals found: [1] ‘FUN’
[10:30:54.688] Searching for globals ... DONE
[10:30:54.688] Resolving globals: FALSE
[10:30:54.689] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[10:30:54.689] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[10:30:54.689] - globals: [1] ‘FUN’
[10:30:54.689] 
[10:30:54.689] getGlobalsAndPackages() ... DONE
[10:30:54.689]  - globals found/used: [n=1] ‘FUN’
[10:30:54.690]  - needed namespaces: [n=0] 
[10:30:54.690] Finding globals ... DONE
[10:30:54.690] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:54.690] List of 2
[10:30:54.690]  $ ...future.FUN:function (x, y)  
[10:30:54.690]  $ MoreArgs     :List of 1
[10:30:54.690]   ..$ y: int [1:2] 3 4
[10:30:54.690]  - attr(*, "where")=List of 2
[10:30:54.690]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:54.690]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:54.690]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:54.690]  - attr(*, "resolved")= logi FALSE
[10:30:54.690]  - attr(*, "total_size")= num NA
[10:30:54.693] Packages to be attached in all futures: [n=0] 
[10:30:54.693] getGlobalsAndPackagesXApply() ... DONE
[10:30:54.693] Number of futures (= number of chunks): 2
[10:30:54.693] Launching 2 futures (chunks) ...
[10:30:54.693] Chunk #1 of 2 ...
[10:30:54.694]  - Finding globals in '...' for chunk #1 ...
[10:30:54.694] getGlobalsAndPackages() ...
[10:30:54.694] Searching for globals...
[10:30:54.694] 
[10:30:54.694] Searching for globals ... DONE
[10:30:54.694] - globals: [0] <none>
[10:30:54.694] getGlobalsAndPackages() ... DONE
[10:30:54.694]    + additional globals found: [n=0] 
[10:30:54.694]    + additional namespaces needed: [n=0] 
[10:30:54.694]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:54.695]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.695]  - seeds: [1] <seeds>
[10:30:54.695]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.695] getGlobalsAndPackages() ...
[10:30:54.695] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.695] Resolving globals: FALSE
[10:30:54.696] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[10:30:54.696] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:54.696] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.696] 
[10:30:54.696] getGlobalsAndPackages() ... DONE
[10:30:54.697] run() for ‘Future’ ...
[10:30:54.697] - state: ‘created’
[10:30:54.697] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.711] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.711]   - Field: ‘node’
[10:30:54.711]   - Field: ‘label’
[10:30:54.711]   - Field: ‘local’
[10:30:54.711]   - Field: ‘owner’
[10:30:54.712]   - Field: ‘envir’
[10:30:54.712]   - Field: ‘workers’
[10:30:54.712]   - Field: ‘packages’
[10:30:54.712]   - Field: ‘gc’
[10:30:54.712]   - Field: ‘conditions’
[10:30:54.712]   - Field: ‘persistent’
[10:30:54.712]   - Field: ‘expr’
[10:30:54.712]   - Field: ‘uuid’
[10:30:54.712]   - Field: ‘seed’
[10:30:54.712]   - Field: ‘version’
[10:30:54.712]   - Field: ‘result’
[10:30:54.713]   - Field: ‘asynchronous’
[10:30:54.713]   - Field: ‘calls’
[10:30:54.713]   - Field: ‘globals’
[10:30:54.713]   - Field: ‘stdout’
[10:30:54.713]   - Field: ‘earlySignal’
[10:30:54.713]   - Field: ‘lazy’
[10:30:54.713]   - Field: ‘state’
[10:30:54.713] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.713] - Launch lazy future ...
[10:30:54.714] Packages needed by the future expression (n = 0): <none>
[10:30:54.714] Packages needed by future strategies (n = 0): <none>
[10:30:54.714] {
[10:30:54.714]     {
[10:30:54.714]         {
[10:30:54.714]             ...future.startTime <- base::Sys.time()
[10:30:54.714]             {
[10:30:54.714]                 {
[10:30:54.714]                   {
[10:30:54.714]                     {
[10:30:54.714]                       base::local({
[10:30:54.714]                         has_future <- base::requireNamespace("future", 
[10:30:54.714]                           quietly = TRUE)
[10:30:54.714]                         if (has_future) {
[10:30:54.714]                           ns <- base::getNamespace("future")
[10:30:54.714]                           version <- ns[[".package"]][["version"]]
[10:30:54.714]                           if (is.null(version)) 
[10:30:54.714]                             version <- utils::packageVersion("future")
[10:30:54.714]                         }
[10:30:54.714]                         else {
[10:30:54.714]                           version <- NULL
[10:30:54.714]                         }
[10:30:54.714]                         if (!has_future || version < "1.8.0") {
[10:30:54.714]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.714]                             "", base::R.version$version.string), 
[10:30:54.714]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.714]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.714]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.714]                               "release", "version")], collapse = " "), 
[10:30:54.714]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.714]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.714]                             info)
[10:30:54.714]                           info <- base::paste(info, collapse = "; ")
[10:30:54.714]                           if (!has_future) {
[10:30:54.714]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.714]                               info)
[10:30:54.714]                           }
[10:30:54.714]                           else {
[10:30:54.714]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.714]                               info, version)
[10:30:54.714]                           }
[10:30:54.714]                           base::stop(msg)
[10:30:54.714]                         }
[10:30:54.714]                       })
[10:30:54.714]                     }
[10:30:54.714]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.714]                     base::options(mc.cores = 1L)
[10:30:54.714]                   }
[10:30:54.714]                   ...future.strategy.old <- future::plan("list")
[10:30:54.714]                   options(future.plan = NULL)
[10:30:54.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.714]                 }
[10:30:54.714]                 ...future.workdir <- getwd()
[10:30:54.714]             }
[10:30:54.714]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.714]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.714]         }
[10:30:54.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.714]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.714]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.714]             base::names(...future.oldOptions))
[10:30:54.714]     }
[10:30:54.714]     if (FALSE) {
[10:30:54.714]     }
[10:30:54.714]     else {
[10:30:54.714]         if (TRUE) {
[10:30:54.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.714]                 open = "w")
[10:30:54.714]         }
[10:30:54.714]         else {
[10:30:54.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.714]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.714]         }
[10:30:54.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.714]             base::sink(type = "output", split = FALSE)
[10:30:54.714]             base::close(...future.stdout)
[10:30:54.714]         }, add = TRUE)
[10:30:54.714]     }
[10:30:54.714]     ...future.frame <- base::sys.nframe()
[10:30:54.714]     ...future.conditions <- base::list()
[10:30:54.714]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.714]     if (FALSE) {
[10:30:54.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.714]     }
[10:30:54.714]     ...future.result <- base::tryCatch({
[10:30:54.714]         base::withCallingHandlers({
[10:30:54.714]             ...future.value <- base::withVisible(base::local({
[10:30:54.714]                 ...future.makeSendCondition <- base::local({
[10:30:54.714]                   sendCondition <- NULL
[10:30:54.714]                   function(frame = 1L) {
[10:30:54.714]                     if (is.function(sendCondition)) 
[10:30:54.714]                       return(sendCondition)
[10:30:54.714]                     ns <- getNamespace("parallel")
[10:30:54.714]                     if (exists("sendData", mode = "function", 
[10:30:54.714]                       envir = ns)) {
[10:30:54.714]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.714]                         envir = ns)
[10:30:54.714]                       envir <- sys.frame(frame)
[10:30:54.714]                       master <- NULL
[10:30:54.714]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.714]                         !identical(envir, emptyenv())) {
[10:30:54.714]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.714]                           inherits = FALSE)) {
[10:30:54.714]                           master <- get("master", mode = "list", 
[10:30:54.714]                             envir = envir, inherits = FALSE)
[10:30:54.714]                           if (inherits(master, c("SOCKnode", 
[10:30:54.714]                             "SOCK0node"))) {
[10:30:54.714]                             sendCondition <<- function(cond) {
[10:30:54.714]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.714]                                 success = TRUE)
[10:30:54.714]                               parallel_sendData(master, data)
[10:30:54.714]                             }
[10:30:54.714]                             return(sendCondition)
[10:30:54.714]                           }
[10:30:54.714]                         }
[10:30:54.714]                         frame <- frame + 1L
[10:30:54.714]                         envir <- sys.frame(frame)
[10:30:54.714]                       }
[10:30:54.714]                     }
[10:30:54.714]                     sendCondition <<- function(cond) NULL
[10:30:54.714]                   }
[10:30:54.714]                 })
[10:30:54.714]                 withCallingHandlers({
[10:30:54.714]                   {
[10:30:54.714]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.714]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.714]                       ...future.globals.maxSize)) {
[10:30:54.714]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.714]                       on.exit(options(oopts), add = TRUE)
[10:30:54.714]                     }
[10:30:54.714]                     {
[10:30:54.714]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:54.714]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:54.714]                           envir = globalenv(), inherits = FALSE)
[10:30:54.714]                         ...future.FUN(...)
[10:30:54.714]                       }
[10:30:54.714]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:54.714]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:54.714]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.714]                         USE.NAMES = FALSE)
[10:30:54.714]                       do.call(mapply, args = args)
[10:30:54.714]                     }
[10:30:54.714]                   }
[10:30:54.714]                 }, immediateCondition = function(cond) {
[10:30:54.714]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.714]                   sendCondition(cond)
[10:30:54.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.714]                   {
[10:30:54.714]                     inherits <- base::inherits
[10:30:54.714]                     invokeRestart <- base::invokeRestart
[10:30:54.714]                     is.null <- base::is.null
[10:30:54.714]                     muffled <- FALSE
[10:30:54.714]                     if (inherits(cond, "message")) {
[10:30:54.714]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.714]                       if (muffled) 
[10:30:54.714]                         invokeRestart("muffleMessage")
[10:30:54.714]                     }
[10:30:54.714]                     else if (inherits(cond, "warning")) {
[10:30:54.714]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.714]                       if (muffled) 
[10:30:54.714]                         invokeRestart("muffleWarning")
[10:30:54.714]                     }
[10:30:54.714]                     else if (inherits(cond, "condition")) {
[10:30:54.714]                       if (!is.null(pattern)) {
[10:30:54.714]                         computeRestarts <- base::computeRestarts
[10:30:54.714]                         grepl <- base::grepl
[10:30:54.714]                         restarts <- computeRestarts(cond)
[10:30:54.714]                         for (restart in restarts) {
[10:30:54.714]                           name <- restart$name
[10:30:54.714]                           if (is.null(name)) 
[10:30:54.714]                             next
[10:30:54.714]                           if (!grepl(pattern, name)) 
[10:30:54.714]                             next
[10:30:54.714]                           invokeRestart(restart)
[10:30:54.714]                           muffled <- TRUE
[10:30:54.714]                           break
[10:30:54.714]                         }
[10:30:54.714]                       }
[10:30:54.714]                     }
[10:30:54.714]                     invisible(muffled)
[10:30:54.714]                   }
[10:30:54.714]                   muffleCondition(cond)
[10:30:54.714]                 })
[10:30:54.714]             }))
[10:30:54.714]             future::FutureResult(value = ...future.value$value, 
[10:30:54.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.714]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.714]                     ...future.globalenv.names))
[10:30:54.714]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.714]         }, condition = base::local({
[10:30:54.714]             c <- base::c
[10:30:54.714]             inherits <- base::inherits
[10:30:54.714]             invokeRestart <- base::invokeRestart
[10:30:54.714]             length <- base::length
[10:30:54.714]             list <- base::list
[10:30:54.714]             seq.int <- base::seq.int
[10:30:54.714]             signalCondition <- base::signalCondition
[10:30:54.714]             sys.calls <- base::sys.calls
[10:30:54.714]             `[[` <- base::`[[`
[10:30:54.714]             `+` <- base::`+`
[10:30:54.714]             `<<-` <- base::`<<-`
[10:30:54.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.714]                   3L)]
[10:30:54.714]             }
[10:30:54.714]             function(cond) {
[10:30:54.714]                 is_error <- inherits(cond, "error")
[10:30:54.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.714]                   NULL)
[10:30:54.714]                 if (is_error) {
[10:30:54.714]                   sessionInformation <- function() {
[10:30:54.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.714]                       search = base::search(), system = base::Sys.info())
[10:30:54.714]                   }
[10:30:54.714]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.714]                     cond$call), session = sessionInformation(), 
[10:30:54.714]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.714]                   signalCondition(cond)
[10:30:54.714]                 }
[10:30:54.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.714]                 "immediateCondition"))) {
[10:30:54.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.714]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.714]                   if (TRUE && !signal) {
[10:30:54.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.714]                     {
[10:30:54.714]                       inherits <- base::inherits
[10:30:54.714]                       invokeRestart <- base::invokeRestart
[10:30:54.714]                       is.null <- base::is.null
[10:30:54.714]                       muffled <- FALSE
[10:30:54.714]                       if (inherits(cond, "message")) {
[10:30:54.714]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.714]                         if (muffled) 
[10:30:54.714]                           invokeRestart("muffleMessage")
[10:30:54.714]                       }
[10:30:54.714]                       else if (inherits(cond, "warning")) {
[10:30:54.714]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.714]                         if (muffled) 
[10:30:54.714]                           invokeRestart("muffleWarning")
[10:30:54.714]                       }
[10:30:54.714]                       else if (inherits(cond, "condition")) {
[10:30:54.714]                         if (!is.null(pattern)) {
[10:30:54.714]                           computeRestarts <- base::computeRestarts
[10:30:54.714]                           grepl <- base::grepl
[10:30:54.714]                           restarts <- computeRestarts(cond)
[10:30:54.714]                           for (restart in restarts) {
[10:30:54.714]                             name <- restart$name
[10:30:54.714]                             if (is.null(name)) 
[10:30:54.714]                               next
[10:30:54.714]                             if (!grepl(pattern, name)) 
[10:30:54.714]                               next
[10:30:54.714]                             invokeRestart(restart)
[10:30:54.714]                             muffled <- TRUE
[10:30:54.714]                             break
[10:30:54.714]                           }
[10:30:54.714]                         }
[10:30:54.714]                       }
[10:30:54.714]                       invisible(muffled)
[10:30:54.714]                     }
[10:30:54.714]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.714]                   }
[10:30:54.714]                 }
[10:30:54.714]                 else {
[10:30:54.714]                   if (TRUE) {
[10:30:54.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.714]                     {
[10:30:54.714]                       inherits <- base::inherits
[10:30:54.714]                       invokeRestart <- base::invokeRestart
[10:30:54.714]                       is.null <- base::is.null
[10:30:54.714]                       muffled <- FALSE
[10:30:54.714]                       if (inherits(cond, "message")) {
[10:30:54.714]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.714]                         if (muffled) 
[10:30:54.714]                           invokeRestart("muffleMessage")
[10:30:54.714]                       }
[10:30:54.714]                       else if (inherits(cond, "warning")) {
[10:30:54.714]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.714]                         if (muffled) 
[10:30:54.714]                           invokeRestart("muffleWarning")
[10:30:54.714]                       }
[10:30:54.714]                       else if (inherits(cond, "condition")) {
[10:30:54.714]                         if (!is.null(pattern)) {
[10:30:54.714]                           computeRestarts <- base::computeRestarts
[10:30:54.714]                           grepl <- base::grepl
[10:30:54.714]                           restarts <- computeRestarts(cond)
[10:30:54.714]                           for (restart in restarts) {
[10:30:54.714]                             name <- restart$name
[10:30:54.714]                             if (is.null(name)) 
[10:30:54.714]                               next
[10:30:54.714]                             if (!grepl(pattern, name)) 
[10:30:54.714]                               next
[10:30:54.714]                             invokeRestart(restart)
[10:30:54.714]                             muffled <- TRUE
[10:30:54.714]                             break
[10:30:54.714]                           }
[10:30:54.714]                         }
[10:30:54.714]                       }
[10:30:54.714]                       invisible(muffled)
[10:30:54.714]                     }
[10:30:54.714]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.714]                   }
[10:30:54.714]                 }
[10:30:54.714]             }
[10:30:54.714]         }))
[10:30:54.714]     }, error = function(ex) {
[10:30:54.714]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.714]                 ...future.rng), started = ...future.startTime, 
[10:30:54.714]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.714]             version = "1.8"), class = "FutureResult")
[10:30:54.714]     }, finally = {
[10:30:54.714]         if (!identical(...future.workdir, getwd())) 
[10:30:54.714]             setwd(...future.workdir)
[10:30:54.714]         {
[10:30:54.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.714]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.714]             }
[10:30:54.714]             base::options(...future.oldOptions)
[10:30:54.714]             if (.Platform$OS.type == "windows") {
[10:30:54.714]                 old_names <- names(...future.oldEnvVars)
[10:30:54.714]                 envs <- base::Sys.getenv()
[10:30:54.714]                 names <- names(envs)
[10:30:54.714]                 common <- intersect(names, old_names)
[10:30:54.714]                 added <- setdiff(names, old_names)
[10:30:54.714]                 removed <- setdiff(old_names, names)
[10:30:54.714]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.714]                   envs[common]]
[10:30:54.714]                 NAMES <- toupper(changed)
[10:30:54.714]                 args <- list()
[10:30:54.714]                 for (kk in seq_along(NAMES)) {
[10:30:54.714]                   name <- changed[[kk]]
[10:30:54.714]                   NAME <- NAMES[[kk]]
[10:30:54.714]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.714]                     next
[10:30:54.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.714]                 }
[10:30:54.714]                 NAMES <- toupper(added)
[10:30:54.714]                 for (kk in seq_along(NAMES)) {
[10:30:54.714]                   name <- added[[kk]]
[10:30:54.714]                   NAME <- NAMES[[kk]]
[10:30:54.714]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.714]                     next
[10:30:54.714]                   args[[name]] <- ""
[10:30:54.714]                 }
[10:30:54.714]                 NAMES <- toupper(removed)
[10:30:54.714]                 for (kk in seq_along(NAMES)) {
[10:30:54.714]                   name <- removed[[kk]]
[10:30:54.714]                   NAME <- NAMES[[kk]]
[10:30:54.714]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.714]                     next
[10:30:54.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.714]                 }
[10:30:54.714]                 if (length(args) > 0) 
[10:30:54.714]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.714]             }
[10:30:54.714]             else {
[10:30:54.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.714]             }
[10:30:54.714]             {
[10:30:54.714]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.714]                   0L) {
[10:30:54.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.714]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.714]                   base::options(opts)
[10:30:54.714]                 }
[10:30:54.714]                 {
[10:30:54.714]                   {
[10:30:54.714]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.714]                     NULL
[10:30:54.714]                   }
[10:30:54.714]                   options(future.plan = NULL)
[10:30:54.714]                   if (is.na(NA_character_)) 
[10:30:54.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.714]                     .init = FALSE)
[10:30:54.714]                 }
[10:30:54.714]             }
[10:30:54.714]         }
[10:30:54.714]     })
[10:30:54.714]     if (TRUE) {
[10:30:54.714]         base::sink(type = "output", split = FALSE)
[10:30:54.714]         if (TRUE) {
[10:30:54.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.714]         }
[10:30:54.714]         else {
[10:30:54.714]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.714]         }
[10:30:54.714]         base::close(...future.stdout)
[10:30:54.714]         ...future.stdout <- NULL
[10:30:54.714]     }
[10:30:54.714]     ...future.result$conditions <- ...future.conditions
[10:30:54.714]     ...future.result$finished <- base::Sys.time()
[10:30:54.714]     ...future.result
[10:30:54.714] }
[10:30:54.717] Exporting 5 global objects (1.85 KiB) to cluster node #1 ...
[10:30:54.717] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[10:30:54.718] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[10:30:54.718] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[10:30:54.718] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[10:30:54.718] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:30:54.719] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:30:54.719] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[10:30:54.719] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[10:30:54.719] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:54.719] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.719] Exporting 5 global objects (1.85 KiB) to cluster node #1 ... DONE
[10:30:54.720] MultisessionFuture started
[10:30:54.720] - Launch lazy future ... done
[10:30:54.720] run() for ‘MultisessionFuture’ ... done
[10:30:54.720] Created future:
[10:30:54.720] MultisessionFuture:
[10:30:54.720] Label: ‘future_mapply-1’
[10:30:54.720] Expression:
[10:30:54.720] {
[10:30:54.720]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.720]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.720]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.720]         on.exit(options(oopts), add = TRUE)
[10:30:54.720]     }
[10:30:54.720]     {
[10:30:54.720]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:54.720]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:54.720]                 inherits = FALSE)
[10:30:54.720]             ...future.FUN(...)
[10:30:54.720]         }
[10:30:54.720]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:54.720]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:54.720]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.720]         do.call(mapply, args = args)
[10:30:54.720]     }
[10:30:54.720] }
[10:30:54.720] Lazy evaluation: FALSE
[10:30:54.720] Asynchronous evaluation: TRUE
[10:30:54.720] Local evaluation: TRUE
[10:30:54.720] Environment: R_GlobalEnv
[10:30:54.720] Capture standard output: TRUE
[10:30:54.720] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.720] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.720] Packages: <none>
[10:30:54.720] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:54.720] Resolved: FALSE
[10:30:54.720] Value: <not collected>
[10:30:54.720] Conditions captured: <none>
[10:30:54.720] Early signaling: FALSE
[10:30:54.720] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.720] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.732] Chunk #1 of 2 ... DONE
[10:30:54.732] Chunk #2 of 2 ...
[10:30:54.732]  - Finding globals in '...' for chunk #2 ...
[10:30:54.732] getGlobalsAndPackages() ...
[10:30:54.733] Searching for globals...
[10:30:54.733] 
[10:30:54.733] Searching for globals ... DONE
[10:30:54.733] - globals: [0] <none>
[10:30:54.733] getGlobalsAndPackages() ... DONE
[10:30:54.733]    + additional globals found: [n=0] 
[10:30:54.733]    + additional namespaces needed: [n=0] 
[10:30:54.733]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:54.734]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.734]  - seeds: [1] <seeds>
[10:30:54.734]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.734] getGlobalsAndPackages() ...
[10:30:54.734] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.734] Resolving globals: FALSE
[10:30:54.735] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[10:30:54.735] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[10:30:54.735] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.735] 
[10:30:54.735] getGlobalsAndPackages() ... DONE
[10:30:54.736] run() for ‘Future’ ...
[10:30:54.736] - state: ‘created’
[10:30:54.736] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.751] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.751]   - Field: ‘node’
[10:30:54.751]   - Field: ‘label’
[10:30:54.751]   - Field: ‘local’
[10:30:54.751]   - Field: ‘owner’
[10:30:54.751]   - Field: ‘envir’
[10:30:54.752]   - Field: ‘workers’
[10:30:54.752]   - Field: ‘packages’
[10:30:54.752]   - Field: ‘gc’
[10:30:54.752]   - Field: ‘conditions’
[10:30:54.752]   - Field: ‘persistent’
[10:30:54.752]   - Field: ‘expr’
[10:30:54.752]   - Field: ‘uuid’
[10:30:54.752]   - Field: ‘seed’
[10:30:54.752]   - Field: ‘version’
[10:30:54.752]   - Field: ‘result’
[10:30:54.752]   - Field: ‘asynchronous’
[10:30:54.753]   - Field: ‘calls’
[10:30:54.753]   - Field: ‘globals’
[10:30:54.753]   - Field: ‘stdout’
[10:30:54.753]   - Field: ‘earlySignal’
[10:30:54.753]   - Field: ‘lazy’
[10:30:54.753]   - Field: ‘state’
[10:30:54.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.753] - Launch lazy future ...
[10:30:54.754] Packages needed by the future expression (n = 0): <none>
[10:30:54.754] Packages needed by future strategies (n = 0): <none>
[10:30:54.754] {
[10:30:54.754]     {
[10:30:54.754]         {
[10:30:54.754]             ...future.startTime <- base::Sys.time()
[10:30:54.754]             {
[10:30:54.754]                 {
[10:30:54.754]                   {
[10:30:54.754]                     {
[10:30:54.754]                       base::local({
[10:30:54.754]                         has_future <- base::requireNamespace("future", 
[10:30:54.754]                           quietly = TRUE)
[10:30:54.754]                         if (has_future) {
[10:30:54.754]                           ns <- base::getNamespace("future")
[10:30:54.754]                           version <- ns[[".package"]][["version"]]
[10:30:54.754]                           if (is.null(version)) 
[10:30:54.754]                             version <- utils::packageVersion("future")
[10:30:54.754]                         }
[10:30:54.754]                         else {
[10:30:54.754]                           version <- NULL
[10:30:54.754]                         }
[10:30:54.754]                         if (!has_future || version < "1.8.0") {
[10:30:54.754]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.754]                             "", base::R.version$version.string), 
[10:30:54.754]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.754]                               "release", "version")], collapse = " "), 
[10:30:54.754]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.754]                             info)
[10:30:54.754]                           info <- base::paste(info, collapse = "; ")
[10:30:54.754]                           if (!has_future) {
[10:30:54.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.754]                               info)
[10:30:54.754]                           }
[10:30:54.754]                           else {
[10:30:54.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.754]                               info, version)
[10:30:54.754]                           }
[10:30:54.754]                           base::stop(msg)
[10:30:54.754]                         }
[10:30:54.754]                       })
[10:30:54.754]                     }
[10:30:54.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.754]                     base::options(mc.cores = 1L)
[10:30:54.754]                   }
[10:30:54.754]                   ...future.strategy.old <- future::plan("list")
[10:30:54.754]                   options(future.plan = NULL)
[10:30:54.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.754]                 }
[10:30:54.754]                 ...future.workdir <- getwd()
[10:30:54.754]             }
[10:30:54.754]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.754]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.754]         }
[10:30:54.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.754]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.754]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.754]             base::names(...future.oldOptions))
[10:30:54.754]     }
[10:30:54.754]     if (FALSE) {
[10:30:54.754]     }
[10:30:54.754]     else {
[10:30:54.754]         if (TRUE) {
[10:30:54.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.754]                 open = "w")
[10:30:54.754]         }
[10:30:54.754]         else {
[10:30:54.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.754]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.754]         }
[10:30:54.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.754]             base::sink(type = "output", split = FALSE)
[10:30:54.754]             base::close(...future.stdout)
[10:30:54.754]         }, add = TRUE)
[10:30:54.754]     }
[10:30:54.754]     ...future.frame <- base::sys.nframe()
[10:30:54.754]     ...future.conditions <- base::list()
[10:30:54.754]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.754]     if (FALSE) {
[10:30:54.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.754]     }
[10:30:54.754]     ...future.result <- base::tryCatch({
[10:30:54.754]         base::withCallingHandlers({
[10:30:54.754]             ...future.value <- base::withVisible(base::local({
[10:30:54.754]                 ...future.makeSendCondition <- base::local({
[10:30:54.754]                   sendCondition <- NULL
[10:30:54.754]                   function(frame = 1L) {
[10:30:54.754]                     if (is.function(sendCondition)) 
[10:30:54.754]                       return(sendCondition)
[10:30:54.754]                     ns <- getNamespace("parallel")
[10:30:54.754]                     if (exists("sendData", mode = "function", 
[10:30:54.754]                       envir = ns)) {
[10:30:54.754]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.754]                         envir = ns)
[10:30:54.754]                       envir <- sys.frame(frame)
[10:30:54.754]                       master <- NULL
[10:30:54.754]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.754]                         !identical(envir, emptyenv())) {
[10:30:54.754]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.754]                           inherits = FALSE)) {
[10:30:54.754]                           master <- get("master", mode = "list", 
[10:30:54.754]                             envir = envir, inherits = FALSE)
[10:30:54.754]                           if (inherits(master, c("SOCKnode", 
[10:30:54.754]                             "SOCK0node"))) {
[10:30:54.754]                             sendCondition <<- function(cond) {
[10:30:54.754]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.754]                                 success = TRUE)
[10:30:54.754]                               parallel_sendData(master, data)
[10:30:54.754]                             }
[10:30:54.754]                             return(sendCondition)
[10:30:54.754]                           }
[10:30:54.754]                         }
[10:30:54.754]                         frame <- frame + 1L
[10:30:54.754]                         envir <- sys.frame(frame)
[10:30:54.754]                       }
[10:30:54.754]                     }
[10:30:54.754]                     sendCondition <<- function(cond) NULL
[10:30:54.754]                   }
[10:30:54.754]                 })
[10:30:54.754]                 withCallingHandlers({
[10:30:54.754]                   {
[10:30:54.754]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.754]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.754]                       ...future.globals.maxSize)) {
[10:30:54.754]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.754]                       on.exit(options(oopts), add = TRUE)
[10:30:54.754]                     }
[10:30:54.754]                     {
[10:30:54.754]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:54.754]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:54.754]                           envir = globalenv(), inherits = FALSE)
[10:30:54.754]                         ...future.FUN(...)
[10:30:54.754]                       }
[10:30:54.754]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:54.754]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:54.754]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.754]                         USE.NAMES = FALSE)
[10:30:54.754]                       do.call(mapply, args = args)
[10:30:54.754]                     }
[10:30:54.754]                   }
[10:30:54.754]                 }, immediateCondition = function(cond) {
[10:30:54.754]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.754]                   sendCondition(cond)
[10:30:54.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.754]                   {
[10:30:54.754]                     inherits <- base::inherits
[10:30:54.754]                     invokeRestart <- base::invokeRestart
[10:30:54.754]                     is.null <- base::is.null
[10:30:54.754]                     muffled <- FALSE
[10:30:54.754]                     if (inherits(cond, "message")) {
[10:30:54.754]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.754]                       if (muffled) 
[10:30:54.754]                         invokeRestart("muffleMessage")
[10:30:54.754]                     }
[10:30:54.754]                     else if (inherits(cond, "warning")) {
[10:30:54.754]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.754]                       if (muffled) 
[10:30:54.754]                         invokeRestart("muffleWarning")
[10:30:54.754]                     }
[10:30:54.754]                     else if (inherits(cond, "condition")) {
[10:30:54.754]                       if (!is.null(pattern)) {
[10:30:54.754]                         computeRestarts <- base::computeRestarts
[10:30:54.754]                         grepl <- base::grepl
[10:30:54.754]                         restarts <- computeRestarts(cond)
[10:30:54.754]                         for (restart in restarts) {
[10:30:54.754]                           name <- restart$name
[10:30:54.754]                           if (is.null(name)) 
[10:30:54.754]                             next
[10:30:54.754]                           if (!grepl(pattern, name)) 
[10:30:54.754]                             next
[10:30:54.754]                           invokeRestart(restart)
[10:30:54.754]                           muffled <- TRUE
[10:30:54.754]                           break
[10:30:54.754]                         }
[10:30:54.754]                       }
[10:30:54.754]                     }
[10:30:54.754]                     invisible(muffled)
[10:30:54.754]                   }
[10:30:54.754]                   muffleCondition(cond)
[10:30:54.754]                 })
[10:30:54.754]             }))
[10:30:54.754]             future::FutureResult(value = ...future.value$value, 
[10:30:54.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.754]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.754]                     ...future.globalenv.names))
[10:30:54.754]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.754]         }, condition = base::local({
[10:30:54.754]             c <- base::c
[10:30:54.754]             inherits <- base::inherits
[10:30:54.754]             invokeRestart <- base::invokeRestart
[10:30:54.754]             length <- base::length
[10:30:54.754]             list <- base::list
[10:30:54.754]             seq.int <- base::seq.int
[10:30:54.754]             signalCondition <- base::signalCondition
[10:30:54.754]             sys.calls <- base::sys.calls
[10:30:54.754]             `[[` <- base::`[[`
[10:30:54.754]             `+` <- base::`+`
[10:30:54.754]             `<<-` <- base::`<<-`
[10:30:54.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.754]                   3L)]
[10:30:54.754]             }
[10:30:54.754]             function(cond) {
[10:30:54.754]                 is_error <- inherits(cond, "error")
[10:30:54.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.754]                   NULL)
[10:30:54.754]                 if (is_error) {
[10:30:54.754]                   sessionInformation <- function() {
[10:30:54.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.754]                       search = base::search(), system = base::Sys.info())
[10:30:54.754]                   }
[10:30:54.754]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.754]                     cond$call), session = sessionInformation(), 
[10:30:54.754]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.754]                   signalCondition(cond)
[10:30:54.754]                 }
[10:30:54.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.754]                 "immediateCondition"))) {
[10:30:54.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.754]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.754]                   if (TRUE && !signal) {
[10:30:54.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.754]                     {
[10:30:54.754]                       inherits <- base::inherits
[10:30:54.754]                       invokeRestart <- base::invokeRestart
[10:30:54.754]                       is.null <- base::is.null
[10:30:54.754]                       muffled <- FALSE
[10:30:54.754]                       if (inherits(cond, "message")) {
[10:30:54.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.754]                         if (muffled) 
[10:30:54.754]                           invokeRestart("muffleMessage")
[10:30:54.754]                       }
[10:30:54.754]                       else if (inherits(cond, "warning")) {
[10:30:54.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.754]                         if (muffled) 
[10:30:54.754]                           invokeRestart("muffleWarning")
[10:30:54.754]                       }
[10:30:54.754]                       else if (inherits(cond, "condition")) {
[10:30:54.754]                         if (!is.null(pattern)) {
[10:30:54.754]                           computeRestarts <- base::computeRestarts
[10:30:54.754]                           grepl <- base::grepl
[10:30:54.754]                           restarts <- computeRestarts(cond)
[10:30:54.754]                           for (restart in restarts) {
[10:30:54.754]                             name <- restart$name
[10:30:54.754]                             if (is.null(name)) 
[10:30:54.754]                               next
[10:30:54.754]                             if (!grepl(pattern, name)) 
[10:30:54.754]                               next
[10:30:54.754]                             invokeRestart(restart)
[10:30:54.754]                             muffled <- TRUE
[10:30:54.754]                             break
[10:30:54.754]                           }
[10:30:54.754]                         }
[10:30:54.754]                       }
[10:30:54.754]                       invisible(muffled)
[10:30:54.754]                     }
[10:30:54.754]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.754]                   }
[10:30:54.754]                 }
[10:30:54.754]                 else {
[10:30:54.754]                   if (TRUE) {
[10:30:54.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.754]                     {
[10:30:54.754]                       inherits <- base::inherits
[10:30:54.754]                       invokeRestart <- base::invokeRestart
[10:30:54.754]                       is.null <- base::is.null
[10:30:54.754]                       muffled <- FALSE
[10:30:54.754]                       if (inherits(cond, "message")) {
[10:30:54.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.754]                         if (muffled) 
[10:30:54.754]                           invokeRestart("muffleMessage")
[10:30:54.754]                       }
[10:30:54.754]                       else if (inherits(cond, "warning")) {
[10:30:54.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.754]                         if (muffled) 
[10:30:54.754]                           invokeRestart("muffleWarning")
[10:30:54.754]                       }
[10:30:54.754]                       else if (inherits(cond, "condition")) {
[10:30:54.754]                         if (!is.null(pattern)) {
[10:30:54.754]                           computeRestarts <- base::computeRestarts
[10:30:54.754]                           grepl <- base::grepl
[10:30:54.754]                           restarts <- computeRestarts(cond)
[10:30:54.754]                           for (restart in restarts) {
[10:30:54.754]                             name <- restart$name
[10:30:54.754]                             if (is.null(name)) 
[10:30:54.754]                               next
[10:30:54.754]                             if (!grepl(pattern, name)) 
[10:30:54.754]                               next
[10:30:54.754]                             invokeRestart(restart)
[10:30:54.754]                             muffled <- TRUE
[10:30:54.754]                             break
[10:30:54.754]                           }
[10:30:54.754]                         }
[10:30:54.754]                       }
[10:30:54.754]                       invisible(muffled)
[10:30:54.754]                     }
[10:30:54.754]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.754]                   }
[10:30:54.754]                 }
[10:30:54.754]             }
[10:30:54.754]         }))
[10:30:54.754]     }, error = function(ex) {
[10:30:54.754]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.754]                 ...future.rng), started = ...future.startTime, 
[10:30:54.754]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.754]             version = "1.8"), class = "FutureResult")
[10:30:54.754]     }, finally = {
[10:30:54.754]         if (!identical(...future.workdir, getwd())) 
[10:30:54.754]             setwd(...future.workdir)
[10:30:54.754]         {
[10:30:54.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.754]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.754]             }
[10:30:54.754]             base::options(...future.oldOptions)
[10:30:54.754]             if (.Platform$OS.type == "windows") {
[10:30:54.754]                 old_names <- names(...future.oldEnvVars)
[10:30:54.754]                 envs <- base::Sys.getenv()
[10:30:54.754]                 names <- names(envs)
[10:30:54.754]                 common <- intersect(names, old_names)
[10:30:54.754]                 added <- setdiff(names, old_names)
[10:30:54.754]                 removed <- setdiff(old_names, names)
[10:30:54.754]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.754]                   envs[common]]
[10:30:54.754]                 NAMES <- toupper(changed)
[10:30:54.754]                 args <- list()
[10:30:54.754]                 for (kk in seq_along(NAMES)) {
[10:30:54.754]                   name <- changed[[kk]]
[10:30:54.754]                   NAME <- NAMES[[kk]]
[10:30:54.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.754]                     next
[10:30:54.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.754]                 }
[10:30:54.754]                 NAMES <- toupper(added)
[10:30:54.754]                 for (kk in seq_along(NAMES)) {
[10:30:54.754]                   name <- added[[kk]]
[10:30:54.754]                   NAME <- NAMES[[kk]]
[10:30:54.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.754]                     next
[10:30:54.754]                   args[[name]] <- ""
[10:30:54.754]                 }
[10:30:54.754]                 NAMES <- toupper(removed)
[10:30:54.754]                 for (kk in seq_along(NAMES)) {
[10:30:54.754]                   name <- removed[[kk]]
[10:30:54.754]                   NAME <- NAMES[[kk]]
[10:30:54.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.754]                     next
[10:30:54.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.754]                 }
[10:30:54.754]                 if (length(args) > 0) 
[10:30:54.754]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.754]             }
[10:30:54.754]             else {
[10:30:54.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.754]             }
[10:30:54.754]             {
[10:30:54.754]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.754]                   0L) {
[10:30:54.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.754]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.754]                   base::options(opts)
[10:30:54.754]                 }
[10:30:54.754]                 {
[10:30:54.754]                   {
[10:30:54.754]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.754]                     NULL
[10:30:54.754]                   }
[10:30:54.754]                   options(future.plan = NULL)
[10:30:54.754]                   if (is.na(NA_character_)) 
[10:30:54.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.754]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.754]                     .init = FALSE)
[10:30:54.754]                 }
[10:30:54.754]             }
[10:30:54.754]         }
[10:30:54.754]     })
[10:30:54.754]     if (TRUE) {
[10:30:54.754]         base::sink(type = "output", split = FALSE)
[10:30:54.754]         if (TRUE) {
[10:30:54.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.754]         }
[10:30:54.754]         else {
[10:30:54.754]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.754]         }
[10:30:54.754]         base::close(...future.stdout)
[10:30:54.754]         ...future.stdout <- NULL
[10:30:54.754]     }
[10:30:54.754]     ...future.result$conditions <- ...future.conditions
[10:30:54.754]     ...future.result$finished <- base::Sys.time()
[10:30:54.754]     ...future.result
[10:30:54.754] }
[10:30:54.757] Exporting 5 global objects (1.85 KiB) to cluster node #2 ...
[10:30:54.757] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[10:30:54.758] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[10:30:54.758] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[10:30:54.758] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[10:30:54.758] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:30:54.759] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:30:54.759] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[10:30:54.759] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[10:30:54.759] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:54.760] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.760] Exporting 5 global objects (1.85 KiB) to cluster node #2 ... DONE
[10:30:54.760] MultisessionFuture started
[10:30:54.761] - Launch lazy future ... done
[10:30:54.761] run() for ‘MultisessionFuture’ ... done
[10:30:54.761] Created future:
[10:30:54.761] MultisessionFuture:
[10:30:54.761] Label: ‘future_mapply-2’
[10:30:54.761] Expression:
[10:30:54.761] {
[10:30:54.761]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.761]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.761]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.761]         on.exit(options(oopts), add = TRUE)
[10:30:54.761]     }
[10:30:54.761]     {
[10:30:54.761]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:54.761]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:54.761]                 inherits = FALSE)
[10:30:54.761]             ...future.FUN(...)
[10:30:54.761]         }
[10:30:54.761]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:54.761]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:54.761]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.761]         do.call(mapply, args = args)
[10:30:54.761]     }
[10:30:54.761] }
[10:30:54.761] Lazy evaluation: FALSE
[10:30:54.761] Asynchronous evaluation: TRUE
[10:30:54.761] Local evaluation: TRUE
[10:30:54.761] Environment: R_GlobalEnv
[10:30:54.761] Capture standard output: TRUE
[10:30:54.761] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.761] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.761] Packages: <none>
[10:30:54.761] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:54.761] Resolved: FALSE
[10:30:54.761] Value: <not collected>
[10:30:54.761] Conditions captured: <none>
[10:30:54.761] Early signaling: FALSE
[10:30:54.761] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.761] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.773] Chunk #2 of 2 ... DONE
[10:30:54.773] Launching 2 futures (chunks) ... DONE
[10:30:54.773] Resolving 2 futures (chunks) ...
[10:30:54.773] resolve() on list ...
[10:30:54.773]  recursive: 0
[10:30:54.773]  length: 2
[10:30:54.773] 
[10:30:54.774] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.774] - Validating connection of MultisessionFuture
[10:30:54.774] - received message: FutureResult
[10:30:54.774] - Received FutureResult
[10:30:54.775] - Erased future from FutureRegistry
[10:30:54.775] result() for ClusterFuture ...
[10:30:54.775] - result already collected: FutureResult
[10:30:54.775] result() for ClusterFuture ... done
[10:30:54.775] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.775] Future #1
[10:30:54.775] result() for ClusterFuture ...
[10:30:54.775] - result already collected: FutureResult
[10:30:54.775] result() for ClusterFuture ... done
[10:30:54.775] result() for ClusterFuture ...
[10:30:54.775] - result already collected: FutureResult
[10:30:54.776] result() for ClusterFuture ... done
[10:30:54.776] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:54.776] - nx: 2
[10:30:54.776] - relay: TRUE
[10:30:54.779] - stdout: TRUE
[10:30:54.779] - signal: TRUE
[10:30:54.779] - resignal: FALSE
[10:30:54.779] - force: TRUE
[10:30:54.779] - relayed: [n=2] FALSE, FALSE
[10:30:54.779] - queued futures: [n=2] FALSE, FALSE
[10:30:54.779]  - until=1
[10:30:54.779]  - relaying element #1
[10:30:54.779] result() for ClusterFuture ...
[10:30:54.780] - result already collected: FutureResult
[10:30:54.780] result() for ClusterFuture ... done
[10:30:54.780] result() for ClusterFuture ...
[10:30:54.780] - result already collected: FutureResult
[10:30:54.780] result() for ClusterFuture ... done
[10:30:54.780] result() for ClusterFuture ...
[10:30:54.780] - result already collected: FutureResult
[10:30:54.780] result() for ClusterFuture ... done
[10:30:54.780] result() for ClusterFuture ...
[10:30:54.780] - result already collected: FutureResult
[10:30:54.780] result() for ClusterFuture ... done
[10:30:54.781] - relayed: [n=2] TRUE, FALSE
[10:30:54.781] - queued futures: [n=2] TRUE, FALSE
[10:30:54.781] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:54.781]  length: 1 (resolved future 1)
[10:30:54.803] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.803] - Validating connection of MultisessionFuture
[10:30:54.803] - received message: FutureResult
[10:30:54.803] - Received FutureResult
[10:30:54.803] - Erased future from FutureRegistry
[10:30:54.804] result() for ClusterFuture ...
[10:30:54.804] - result already collected: FutureResult
[10:30:54.804] result() for ClusterFuture ... done
[10:30:54.804] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.804] Future #2
[10:30:54.804] result() for ClusterFuture ...
[10:30:54.804] - result already collected: FutureResult
[10:30:54.804] result() for ClusterFuture ... done
[10:30:54.804] result() for ClusterFuture ...
[10:30:54.804] - result already collected: FutureResult
[10:30:54.804] result() for ClusterFuture ... done
[10:30:54.805] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:54.805] - nx: 2
[10:30:54.805] - relay: TRUE
[10:30:54.805] - stdout: TRUE
[10:30:54.805] - signal: TRUE
[10:30:54.805] - resignal: FALSE
[10:30:54.805] - force: TRUE
[10:30:54.805] - relayed: [n=2] TRUE, FALSE
[10:30:54.805] - queued futures: [n=2] TRUE, FALSE
[10:30:54.805]  - until=2
[10:30:54.805]  - relaying element #2
[10:30:54.805] result() for ClusterFuture ...
[10:30:54.806] - result already collected: FutureResult
[10:30:54.806] result() for ClusterFuture ... done
[10:30:54.806] result() for ClusterFuture ...
[10:30:54.806] - result already collected: FutureResult
[10:30:54.806] result() for ClusterFuture ... done
[10:30:54.806] result() for ClusterFuture ...
[10:30:54.806] - result already collected: FutureResult
[10:30:54.806] result() for ClusterFuture ... done
[10:30:54.806] result() for ClusterFuture ...
[10:30:54.806] - result already collected: FutureResult
[10:30:54.806] result() for ClusterFuture ... done
[10:30:54.807] - relayed: [n=2] TRUE, TRUE
[10:30:54.807] - queued futures: [n=2] TRUE, TRUE
[10:30:54.807] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:54.807]  length: 0 (resolved future 2)
[10:30:54.807] Relaying remaining futures
[10:30:54.807] signalConditionsASAP(NULL, pos=0) ...
[10:30:54.807] - nx: 2
[10:30:54.807] - relay: TRUE
[10:30:54.807] - stdout: TRUE
[10:30:54.807] - signal: TRUE
[10:30:54.807] - resignal: FALSE
[10:30:54.807] - force: TRUE
[10:30:54.808] - relayed: [n=2] TRUE, TRUE
[10:30:54.808] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:54.808] - relayed: [n=2] TRUE, TRUE
[10:30:54.808] - queued futures: [n=2] TRUE, TRUE
[10:30:54.808] signalConditionsASAP(NULL, pos=0) ... done
[10:30:54.808] resolve() on list ... DONE
[10:30:54.808] result() for ClusterFuture ...
[10:30:54.808] - result already collected: FutureResult
[10:30:54.808] result() for ClusterFuture ... done
[10:30:54.808] result() for ClusterFuture ...
[10:30:54.808] - result already collected: FutureResult
[10:30:54.809] result() for ClusterFuture ... done
[10:30:54.809] result() for ClusterFuture ...
[10:30:54.809] - result already collected: FutureResult
[10:30:54.809] result() for ClusterFuture ... done
[10:30:54.809] result() for ClusterFuture ...
[10:30:54.809] - result already collected: FutureResult
[10:30:54.809] result() for ClusterFuture ... done
[10:30:54.809]  - Number of value chunks collected: 2
[10:30:54.809] Resolving 2 futures (chunks) ... DONE
[10:30:54.809] Reducing values from 2 chunks ...
[10:30:54.809]  - Number of values collected after concatenation: 2
[10:30:54.810]  - Number of values expected: 2
[10:30:54.810] Reducing values from 2 chunks ... DONE
[10:30:54.810] future_mapply() ... DONE
[10:30:54.810] future_mapply() ...
[10:30:54.814] Number of chunks: 2
[10:30:54.814] getGlobalsAndPackagesXApply() ...
[10:30:54.814]  - future.globals: TRUE
[10:30:54.814] getGlobalsAndPackages() ...
[10:30:54.814] Searching for globals...
[10:30:54.815] - globals found: [1] ‘FUN’
[10:30:54.815] Searching for globals ... DONE
[10:30:54.815] Resolving globals: FALSE
[10:30:54.816] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[10:30:54.816] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[10:30:54.816] - globals: [1] ‘FUN’
[10:30:54.816] 
[10:30:54.816] getGlobalsAndPackages() ... DONE
[10:30:54.816]  - globals found/used: [n=1] ‘FUN’
[10:30:54.816]  - needed namespaces: [n=0] 
[10:30:54.817] Finding globals ... DONE
[10:30:54.817] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:54.817] List of 2
[10:30:54.817]  $ ...future.FUN:function (x, y)  
[10:30:54.817]  $ MoreArgs     :List of 1
[10:30:54.817]   ..$ y: int [1:2] 3 4
[10:30:54.817]  - attr(*, "where")=List of 2
[10:30:54.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:54.817]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:54.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:54.817]  - attr(*, "resolved")= logi FALSE
[10:30:54.817]  - attr(*, "total_size")= num NA
[10:30:54.820] Packages to be attached in all futures: [n=0] 
[10:30:54.820] getGlobalsAndPackagesXApply() ... DONE
[10:30:54.820] Number of futures (= number of chunks): 2
[10:30:54.820] Launching 2 futures (chunks) ...
[10:30:54.820] Chunk #1 of 2 ...
[10:30:54.820]  - Finding globals in '...' for chunk #1 ...
[10:30:54.820] getGlobalsAndPackages() ...
[10:30:54.820] Searching for globals...
[10:30:54.821] 
[10:30:54.821] Searching for globals ... DONE
[10:30:54.821] - globals: [0] <none>
[10:30:54.821] getGlobalsAndPackages() ... DONE
[10:30:54.821]    + additional globals found: [n=0] 
[10:30:54.821]    + additional namespaces needed: [n=0] 
[10:30:54.821]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:54.821]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.821]  - seeds: <none>
[10:30:54.821]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.822] getGlobalsAndPackages() ...
[10:30:54.822] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.822] Resolving globals: FALSE
[10:30:54.822] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[10:30:54.823] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[10:30:54.823] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.823] 
[10:30:54.823] getGlobalsAndPackages() ... DONE
[10:30:54.823] run() for ‘Future’ ...
[10:30:54.823] - state: ‘created’
[10:30:54.823] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.837] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.837] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.837]   - Field: ‘node’
[10:30:54.837]   - Field: ‘label’
[10:30:54.837]   - Field: ‘local’
[10:30:54.838]   - Field: ‘owner’
[10:30:54.838]   - Field: ‘envir’
[10:30:54.838]   - Field: ‘workers’
[10:30:54.838]   - Field: ‘packages’
[10:30:54.838]   - Field: ‘gc’
[10:30:54.838]   - Field: ‘conditions’
[10:30:54.838]   - Field: ‘persistent’
[10:30:54.838]   - Field: ‘expr’
[10:30:54.838]   - Field: ‘uuid’
[10:30:54.838]   - Field: ‘seed’
[10:30:54.838]   - Field: ‘version’
[10:30:54.839]   - Field: ‘result’
[10:30:54.839]   - Field: ‘asynchronous’
[10:30:54.839]   - Field: ‘calls’
[10:30:54.839]   - Field: ‘globals’
[10:30:54.839]   - Field: ‘stdout’
[10:30:54.839]   - Field: ‘earlySignal’
[10:30:54.839]   - Field: ‘lazy’
[10:30:54.839]   - Field: ‘state’
[10:30:54.839] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.839] - Launch lazy future ...
[10:30:54.840] Packages needed by the future expression (n = 0): <none>
[10:30:54.840] Packages needed by future strategies (n = 0): <none>
[10:30:54.840] {
[10:30:54.840]     {
[10:30:54.840]         {
[10:30:54.840]             ...future.startTime <- base::Sys.time()
[10:30:54.840]             {
[10:30:54.840]                 {
[10:30:54.840]                   {
[10:30:54.840]                     {
[10:30:54.840]                       base::local({
[10:30:54.840]                         has_future <- base::requireNamespace("future", 
[10:30:54.840]                           quietly = TRUE)
[10:30:54.840]                         if (has_future) {
[10:30:54.840]                           ns <- base::getNamespace("future")
[10:30:54.840]                           version <- ns[[".package"]][["version"]]
[10:30:54.840]                           if (is.null(version)) 
[10:30:54.840]                             version <- utils::packageVersion("future")
[10:30:54.840]                         }
[10:30:54.840]                         else {
[10:30:54.840]                           version <- NULL
[10:30:54.840]                         }
[10:30:54.840]                         if (!has_future || version < "1.8.0") {
[10:30:54.840]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.840]                             "", base::R.version$version.string), 
[10:30:54.840]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.840]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.840]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.840]                               "release", "version")], collapse = " "), 
[10:30:54.840]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.840]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.840]                             info)
[10:30:54.840]                           info <- base::paste(info, collapse = "; ")
[10:30:54.840]                           if (!has_future) {
[10:30:54.840]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.840]                               info)
[10:30:54.840]                           }
[10:30:54.840]                           else {
[10:30:54.840]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.840]                               info, version)
[10:30:54.840]                           }
[10:30:54.840]                           base::stop(msg)
[10:30:54.840]                         }
[10:30:54.840]                       })
[10:30:54.840]                     }
[10:30:54.840]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.840]                     base::options(mc.cores = 1L)
[10:30:54.840]                   }
[10:30:54.840]                   ...future.strategy.old <- future::plan("list")
[10:30:54.840]                   options(future.plan = NULL)
[10:30:54.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.840]                 }
[10:30:54.840]                 ...future.workdir <- getwd()
[10:30:54.840]             }
[10:30:54.840]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.840]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.840]         }
[10:30:54.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.840]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.840]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.840]             base::names(...future.oldOptions))
[10:30:54.840]     }
[10:30:54.840]     if (FALSE) {
[10:30:54.840]     }
[10:30:54.840]     else {
[10:30:54.840]         if (TRUE) {
[10:30:54.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.840]                 open = "w")
[10:30:54.840]         }
[10:30:54.840]         else {
[10:30:54.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.840]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.840]         }
[10:30:54.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.840]             base::sink(type = "output", split = FALSE)
[10:30:54.840]             base::close(...future.stdout)
[10:30:54.840]         }, add = TRUE)
[10:30:54.840]     }
[10:30:54.840]     ...future.frame <- base::sys.nframe()
[10:30:54.840]     ...future.conditions <- base::list()
[10:30:54.840]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.840]     if (FALSE) {
[10:30:54.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.840]     }
[10:30:54.840]     ...future.result <- base::tryCatch({
[10:30:54.840]         base::withCallingHandlers({
[10:30:54.840]             ...future.value <- base::withVisible(base::local({
[10:30:54.840]                 ...future.makeSendCondition <- base::local({
[10:30:54.840]                   sendCondition <- NULL
[10:30:54.840]                   function(frame = 1L) {
[10:30:54.840]                     if (is.function(sendCondition)) 
[10:30:54.840]                       return(sendCondition)
[10:30:54.840]                     ns <- getNamespace("parallel")
[10:30:54.840]                     if (exists("sendData", mode = "function", 
[10:30:54.840]                       envir = ns)) {
[10:30:54.840]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.840]                         envir = ns)
[10:30:54.840]                       envir <- sys.frame(frame)
[10:30:54.840]                       master <- NULL
[10:30:54.840]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.840]                         !identical(envir, emptyenv())) {
[10:30:54.840]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.840]                           inherits = FALSE)) {
[10:30:54.840]                           master <- get("master", mode = "list", 
[10:30:54.840]                             envir = envir, inherits = FALSE)
[10:30:54.840]                           if (inherits(master, c("SOCKnode", 
[10:30:54.840]                             "SOCK0node"))) {
[10:30:54.840]                             sendCondition <<- function(cond) {
[10:30:54.840]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.840]                                 success = TRUE)
[10:30:54.840]                               parallel_sendData(master, data)
[10:30:54.840]                             }
[10:30:54.840]                             return(sendCondition)
[10:30:54.840]                           }
[10:30:54.840]                         }
[10:30:54.840]                         frame <- frame + 1L
[10:30:54.840]                         envir <- sys.frame(frame)
[10:30:54.840]                       }
[10:30:54.840]                     }
[10:30:54.840]                     sendCondition <<- function(cond) NULL
[10:30:54.840]                   }
[10:30:54.840]                 })
[10:30:54.840]                 withCallingHandlers({
[10:30:54.840]                   {
[10:30:54.840]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.840]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.840]                       ...future.globals.maxSize)) {
[10:30:54.840]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.840]                       on.exit(options(oopts), add = TRUE)
[10:30:54.840]                     }
[10:30:54.840]                     {
[10:30:54.840]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.840]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.840]                         USE.NAMES = FALSE)
[10:30:54.840]                       do.call(mapply, args = args)
[10:30:54.840]                     }
[10:30:54.840]                   }
[10:30:54.840]                 }, immediateCondition = function(cond) {
[10:30:54.840]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.840]                   sendCondition(cond)
[10:30:54.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.840]                   {
[10:30:54.840]                     inherits <- base::inherits
[10:30:54.840]                     invokeRestart <- base::invokeRestart
[10:30:54.840]                     is.null <- base::is.null
[10:30:54.840]                     muffled <- FALSE
[10:30:54.840]                     if (inherits(cond, "message")) {
[10:30:54.840]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.840]                       if (muffled) 
[10:30:54.840]                         invokeRestart("muffleMessage")
[10:30:54.840]                     }
[10:30:54.840]                     else if (inherits(cond, "warning")) {
[10:30:54.840]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.840]                       if (muffled) 
[10:30:54.840]                         invokeRestart("muffleWarning")
[10:30:54.840]                     }
[10:30:54.840]                     else if (inherits(cond, "condition")) {
[10:30:54.840]                       if (!is.null(pattern)) {
[10:30:54.840]                         computeRestarts <- base::computeRestarts
[10:30:54.840]                         grepl <- base::grepl
[10:30:54.840]                         restarts <- computeRestarts(cond)
[10:30:54.840]                         for (restart in restarts) {
[10:30:54.840]                           name <- restart$name
[10:30:54.840]                           if (is.null(name)) 
[10:30:54.840]                             next
[10:30:54.840]                           if (!grepl(pattern, name)) 
[10:30:54.840]                             next
[10:30:54.840]                           invokeRestart(restart)
[10:30:54.840]                           muffled <- TRUE
[10:30:54.840]                           break
[10:30:54.840]                         }
[10:30:54.840]                       }
[10:30:54.840]                     }
[10:30:54.840]                     invisible(muffled)
[10:30:54.840]                   }
[10:30:54.840]                   muffleCondition(cond)
[10:30:54.840]                 })
[10:30:54.840]             }))
[10:30:54.840]             future::FutureResult(value = ...future.value$value, 
[10:30:54.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.840]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.840]                     ...future.globalenv.names))
[10:30:54.840]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.840]         }, condition = base::local({
[10:30:54.840]             c <- base::c
[10:30:54.840]             inherits <- base::inherits
[10:30:54.840]             invokeRestart <- base::invokeRestart
[10:30:54.840]             length <- base::length
[10:30:54.840]             list <- base::list
[10:30:54.840]             seq.int <- base::seq.int
[10:30:54.840]             signalCondition <- base::signalCondition
[10:30:54.840]             sys.calls <- base::sys.calls
[10:30:54.840]             `[[` <- base::`[[`
[10:30:54.840]             `+` <- base::`+`
[10:30:54.840]             `<<-` <- base::`<<-`
[10:30:54.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.840]                   3L)]
[10:30:54.840]             }
[10:30:54.840]             function(cond) {
[10:30:54.840]                 is_error <- inherits(cond, "error")
[10:30:54.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.840]                   NULL)
[10:30:54.840]                 if (is_error) {
[10:30:54.840]                   sessionInformation <- function() {
[10:30:54.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.840]                       search = base::search(), system = base::Sys.info())
[10:30:54.840]                   }
[10:30:54.840]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.840]                     cond$call), session = sessionInformation(), 
[10:30:54.840]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.840]                   signalCondition(cond)
[10:30:54.840]                 }
[10:30:54.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.840]                 "immediateCondition"))) {
[10:30:54.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.840]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.840]                   if (TRUE && !signal) {
[10:30:54.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.840]                     {
[10:30:54.840]                       inherits <- base::inherits
[10:30:54.840]                       invokeRestart <- base::invokeRestart
[10:30:54.840]                       is.null <- base::is.null
[10:30:54.840]                       muffled <- FALSE
[10:30:54.840]                       if (inherits(cond, "message")) {
[10:30:54.840]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.840]                         if (muffled) 
[10:30:54.840]                           invokeRestart("muffleMessage")
[10:30:54.840]                       }
[10:30:54.840]                       else if (inherits(cond, "warning")) {
[10:30:54.840]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.840]                         if (muffled) 
[10:30:54.840]                           invokeRestart("muffleWarning")
[10:30:54.840]                       }
[10:30:54.840]                       else if (inherits(cond, "condition")) {
[10:30:54.840]                         if (!is.null(pattern)) {
[10:30:54.840]                           computeRestarts <- base::computeRestarts
[10:30:54.840]                           grepl <- base::grepl
[10:30:54.840]                           restarts <- computeRestarts(cond)
[10:30:54.840]                           for (restart in restarts) {
[10:30:54.840]                             name <- restart$name
[10:30:54.840]                             if (is.null(name)) 
[10:30:54.840]                               next
[10:30:54.840]                             if (!grepl(pattern, name)) 
[10:30:54.840]                               next
[10:30:54.840]                             invokeRestart(restart)
[10:30:54.840]                             muffled <- TRUE
[10:30:54.840]                             break
[10:30:54.840]                           }
[10:30:54.840]                         }
[10:30:54.840]                       }
[10:30:54.840]                       invisible(muffled)
[10:30:54.840]                     }
[10:30:54.840]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.840]                   }
[10:30:54.840]                 }
[10:30:54.840]                 else {
[10:30:54.840]                   if (TRUE) {
[10:30:54.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.840]                     {
[10:30:54.840]                       inherits <- base::inherits
[10:30:54.840]                       invokeRestart <- base::invokeRestart
[10:30:54.840]                       is.null <- base::is.null
[10:30:54.840]                       muffled <- FALSE
[10:30:54.840]                       if (inherits(cond, "message")) {
[10:30:54.840]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.840]                         if (muffled) 
[10:30:54.840]                           invokeRestart("muffleMessage")
[10:30:54.840]                       }
[10:30:54.840]                       else if (inherits(cond, "warning")) {
[10:30:54.840]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.840]                         if (muffled) 
[10:30:54.840]                           invokeRestart("muffleWarning")
[10:30:54.840]                       }
[10:30:54.840]                       else if (inherits(cond, "condition")) {
[10:30:54.840]                         if (!is.null(pattern)) {
[10:30:54.840]                           computeRestarts <- base::computeRestarts
[10:30:54.840]                           grepl <- base::grepl
[10:30:54.840]                           restarts <- computeRestarts(cond)
[10:30:54.840]                           for (restart in restarts) {
[10:30:54.840]                             name <- restart$name
[10:30:54.840]                             if (is.null(name)) 
[10:30:54.840]                               next
[10:30:54.840]                             if (!grepl(pattern, name)) 
[10:30:54.840]                               next
[10:30:54.840]                             invokeRestart(restart)
[10:30:54.840]                             muffled <- TRUE
[10:30:54.840]                             break
[10:30:54.840]                           }
[10:30:54.840]                         }
[10:30:54.840]                       }
[10:30:54.840]                       invisible(muffled)
[10:30:54.840]                     }
[10:30:54.840]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.840]                   }
[10:30:54.840]                 }
[10:30:54.840]             }
[10:30:54.840]         }))
[10:30:54.840]     }, error = function(ex) {
[10:30:54.840]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.840]                 ...future.rng), started = ...future.startTime, 
[10:30:54.840]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.840]             version = "1.8"), class = "FutureResult")
[10:30:54.840]     }, finally = {
[10:30:54.840]         if (!identical(...future.workdir, getwd())) 
[10:30:54.840]             setwd(...future.workdir)
[10:30:54.840]         {
[10:30:54.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.840]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.840]             }
[10:30:54.840]             base::options(...future.oldOptions)
[10:30:54.840]             if (.Platform$OS.type == "windows") {
[10:30:54.840]                 old_names <- names(...future.oldEnvVars)
[10:30:54.840]                 envs <- base::Sys.getenv()
[10:30:54.840]                 names <- names(envs)
[10:30:54.840]                 common <- intersect(names, old_names)
[10:30:54.840]                 added <- setdiff(names, old_names)
[10:30:54.840]                 removed <- setdiff(old_names, names)
[10:30:54.840]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.840]                   envs[common]]
[10:30:54.840]                 NAMES <- toupper(changed)
[10:30:54.840]                 args <- list()
[10:30:54.840]                 for (kk in seq_along(NAMES)) {
[10:30:54.840]                   name <- changed[[kk]]
[10:30:54.840]                   NAME <- NAMES[[kk]]
[10:30:54.840]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.840]                     next
[10:30:54.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.840]                 }
[10:30:54.840]                 NAMES <- toupper(added)
[10:30:54.840]                 for (kk in seq_along(NAMES)) {
[10:30:54.840]                   name <- added[[kk]]
[10:30:54.840]                   NAME <- NAMES[[kk]]
[10:30:54.840]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.840]                     next
[10:30:54.840]                   args[[name]] <- ""
[10:30:54.840]                 }
[10:30:54.840]                 NAMES <- toupper(removed)
[10:30:54.840]                 for (kk in seq_along(NAMES)) {
[10:30:54.840]                   name <- removed[[kk]]
[10:30:54.840]                   NAME <- NAMES[[kk]]
[10:30:54.840]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.840]                     next
[10:30:54.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.840]                 }
[10:30:54.840]                 if (length(args) > 0) 
[10:30:54.840]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.840]             }
[10:30:54.840]             else {
[10:30:54.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.840]             }
[10:30:54.840]             {
[10:30:54.840]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.840]                   0L) {
[10:30:54.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.840]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.840]                   base::options(opts)
[10:30:54.840]                 }
[10:30:54.840]                 {
[10:30:54.840]                   {
[10:30:54.840]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.840]                     NULL
[10:30:54.840]                   }
[10:30:54.840]                   options(future.plan = NULL)
[10:30:54.840]                   if (is.na(NA_character_)) 
[10:30:54.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.840]                     .init = FALSE)
[10:30:54.840]                 }
[10:30:54.840]             }
[10:30:54.840]         }
[10:30:54.840]     })
[10:30:54.840]     if (TRUE) {
[10:30:54.840]         base::sink(type = "output", split = FALSE)
[10:30:54.840]         if (TRUE) {
[10:30:54.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.840]         }
[10:30:54.840]         else {
[10:30:54.840]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.840]         }
[10:30:54.840]         base::close(...future.stdout)
[10:30:54.840]         ...future.stdout <- NULL
[10:30:54.840]     }
[10:30:54.840]     ...future.result$conditions <- ...future.conditions
[10:30:54.840]     ...future.result$finished <- base::Sys.time()
[10:30:54.840]     ...future.result
[10:30:54.840] }
[10:30:54.843] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[10:30:54.843] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[10:30:54.843] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[10:30:54.844] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[10:30:54.844] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[10:30:54.844] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:30:54.844] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:30:54.844] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:54.845] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.845] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:54.845] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.845] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[10:30:54.846] MultisessionFuture started
[10:30:54.846] - Launch lazy future ... done
[10:30:54.846] run() for ‘MultisessionFuture’ ... done
[10:30:54.846] Created future:
[10:30:54.846] MultisessionFuture:
[10:30:54.846] Label: ‘future_.mapply-1’
[10:30:54.846] Expression:
[10:30:54.846] {
[10:30:54.846]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.846]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.846]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.846]         on.exit(options(oopts), add = TRUE)
[10:30:54.846]     }
[10:30:54.846]     {
[10:30:54.846]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.846]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.846]         do.call(mapply, args = args)
[10:30:54.846]     }
[10:30:54.846] }
[10:30:54.846] Lazy evaluation: FALSE
[10:30:54.846] Asynchronous evaluation: TRUE
[10:30:54.846] Local evaluation: TRUE
[10:30:54.846] Environment: R_GlobalEnv
[10:30:54.846] Capture standard output: TRUE
[10:30:54.846] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.846] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.846] Packages: <none>
[10:30:54.846] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.846] Resolved: FALSE
[10:30:54.846] Value: <not collected>
[10:30:54.846] Conditions captured: <none>
[10:30:54.846] Early signaling: FALSE
[10:30:54.846] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.846] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.858] Chunk #1 of 2 ... DONE
[10:30:54.858] Chunk #2 of 2 ...
[10:30:54.858]  - Finding globals in '...' for chunk #2 ...
[10:30:54.858] getGlobalsAndPackages() ...
[10:30:54.858] Searching for globals...
[10:30:54.858] 
[10:30:54.858] Searching for globals ... DONE
[10:30:54.858] - globals: [0] <none>
[10:30:54.859] getGlobalsAndPackages() ... DONE
[10:30:54.859]    + additional globals found: [n=0] 
[10:30:54.859]    + additional namespaces needed: [n=0] 
[10:30:54.859]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:54.859]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.859]  - seeds: <none>
[10:30:54.859]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.859] getGlobalsAndPackages() ...
[10:30:54.859] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.859] Resolving globals: FALSE
[10:30:54.860] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[10:30:54.860] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[10:30:54.860] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.861] 
[10:30:54.861] getGlobalsAndPackages() ... DONE
[10:30:54.861] run() for ‘Future’ ...
[10:30:54.861] - state: ‘created’
[10:30:54.861] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.875] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.875] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.875]   - Field: ‘node’
[10:30:54.875]   - Field: ‘label’
[10:30:54.875]   - Field: ‘local’
[10:30:54.875]   - Field: ‘owner’
[10:30:54.875]   - Field: ‘envir’
[10:30:54.875]   - Field: ‘workers’
[10:30:54.876]   - Field: ‘packages’
[10:30:54.876]   - Field: ‘gc’
[10:30:54.876]   - Field: ‘conditions’
[10:30:54.876]   - Field: ‘persistent’
[10:30:54.876]   - Field: ‘expr’
[10:30:54.876]   - Field: ‘uuid’
[10:30:54.876]   - Field: ‘seed’
[10:30:54.876]   - Field: ‘version’
[10:30:54.876]   - Field: ‘result’
[10:30:54.876]   - Field: ‘asynchronous’
[10:30:54.876]   - Field: ‘calls’
[10:30:54.877]   - Field: ‘globals’
[10:30:54.877]   - Field: ‘stdout’
[10:30:54.877]   - Field: ‘earlySignal’
[10:30:54.877]   - Field: ‘lazy’
[10:30:54.877]   - Field: ‘state’
[10:30:54.877] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.877] - Launch lazy future ...
[10:30:54.877] Packages needed by the future expression (n = 0): <none>
[10:30:54.878] Packages needed by future strategies (n = 0): <none>
[10:30:54.878] {
[10:30:54.878]     {
[10:30:54.878]         {
[10:30:54.878]             ...future.startTime <- base::Sys.time()
[10:30:54.878]             {
[10:30:54.878]                 {
[10:30:54.878]                   {
[10:30:54.878]                     {
[10:30:54.878]                       base::local({
[10:30:54.878]                         has_future <- base::requireNamespace("future", 
[10:30:54.878]                           quietly = TRUE)
[10:30:54.878]                         if (has_future) {
[10:30:54.878]                           ns <- base::getNamespace("future")
[10:30:54.878]                           version <- ns[[".package"]][["version"]]
[10:30:54.878]                           if (is.null(version)) 
[10:30:54.878]                             version <- utils::packageVersion("future")
[10:30:54.878]                         }
[10:30:54.878]                         else {
[10:30:54.878]                           version <- NULL
[10:30:54.878]                         }
[10:30:54.878]                         if (!has_future || version < "1.8.0") {
[10:30:54.878]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.878]                             "", base::R.version$version.string), 
[10:30:54.878]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.878]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.878]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.878]                               "release", "version")], collapse = " "), 
[10:30:54.878]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.878]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.878]                             info)
[10:30:54.878]                           info <- base::paste(info, collapse = "; ")
[10:30:54.878]                           if (!has_future) {
[10:30:54.878]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.878]                               info)
[10:30:54.878]                           }
[10:30:54.878]                           else {
[10:30:54.878]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.878]                               info, version)
[10:30:54.878]                           }
[10:30:54.878]                           base::stop(msg)
[10:30:54.878]                         }
[10:30:54.878]                       })
[10:30:54.878]                     }
[10:30:54.878]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.878]                     base::options(mc.cores = 1L)
[10:30:54.878]                   }
[10:30:54.878]                   ...future.strategy.old <- future::plan("list")
[10:30:54.878]                   options(future.plan = NULL)
[10:30:54.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.878]                 }
[10:30:54.878]                 ...future.workdir <- getwd()
[10:30:54.878]             }
[10:30:54.878]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.878]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.878]         }
[10:30:54.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.878]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.878]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.878]             base::names(...future.oldOptions))
[10:30:54.878]     }
[10:30:54.878]     if (FALSE) {
[10:30:54.878]     }
[10:30:54.878]     else {
[10:30:54.878]         if (TRUE) {
[10:30:54.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.878]                 open = "w")
[10:30:54.878]         }
[10:30:54.878]         else {
[10:30:54.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.878]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.878]         }
[10:30:54.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.878]             base::sink(type = "output", split = FALSE)
[10:30:54.878]             base::close(...future.stdout)
[10:30:54.878]         }, add = TRUE)
[10:30:54.878]     }
[10:30:54.878]     ...future.frame <- base::sys.nframe()
[10:30:54.878]     ...future.conditions <- base::list()
[10:30:54.878]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.878]     if (FALSE) {
[10:30:54.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.878]     }
[10:30:54.878]     ...future.result <- base::tryCatch({
[10:30:54.878]         base::withCallingHandlers({
[10:30:54.878]             ...future.value <- base::withVisible(base::local({
[10:30:54.878]                 ...future.makeSendCondition <- base::local({
[10:30:54.878]                   sendCondition <- NULL
[10:30:54.878]                   function(frame = 1L) {
[10:30:54.878]                     if (is.function(sendCondition)) 
[10:30:54.878]                       return(sendCondition)
[10:30:54.878]                     ns <- getNamespace("parallel")
[10:30:54.878]                     if (exists("sendData", mode = "function", 
[10:30:54.878]                       envir = ns)) {
[10:30:54.878]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.878]                         envir = ns)
[10:30:54.878]                       envir <- sys.frame(frame)
[10:30:54.878]                       master <- NULL
[10:30:54.878]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.878]                         !identical(envir, emptyenv())) {
[10:30:54.878]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.878]                           inherits = FALSE)) {
[10:30:54.878]                           master <- get("master", mode = "list", 
[10:30:54.878]                             envir = envir, inherits = FALSE)
[10:30:54.878]                           if (inherits(master, c("SOCKnode", 
[10:30:54.878]                             "SOCK0node"))) {
[10:30:54.878]                             sendCondition <<- function(cond) {
[10:30:54.878]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.878]                                 success = TRUE)
[10:30:54.878]                               parallel_sendData(master, data)
[10:30:54.878]                             }
[10:30:54.878]                             return(sendCondition)
[10:30:54.878]                           }
[10:30:54.878]                         }
[10:30:54.878]                         frame <- frame + 1L
[10:30:54.878]                         envir <- sys.frame(frame)
[10:30:54.878]                       }
[10:30:54.878]                     }
[10:30:54.878]                     sendCondition <<- function(cond) NULL
[10:30:54.878]                   }
[10:30:54.878]                 })
[10:30:54.878]                 withCallingHandlers({
[10:30:54.878]                   {
[10:30:54.878]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.878]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.878]                       ...future.globals.maxSize)) {
[10:30:54.878]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.878]                       on.exit(options(oopts), add = TRUE)
[10:30:54.878]                     }
[10:30:54.878]                     {
[10:30:54.878]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.878]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.878]                         USE.NAMES = FALSE)
[10:30:54.878]                       do.call(mapply, args = args)
[10:30:54.878]                     }
[10:30:54.878]                   }
[10:30:54.878]                 }, immediateCondition = function(cond) {
[10:30:54.878]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.878]                   sendCondition(cond)
[10:30:54.878]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.878]                   {
[10:30:54.878]                     inherits <- base::inherits
[10:30:54.878]                     invokeRestart <- base::invokeRestart
[10:30:54.878]                     is.null <- base::is.null
[10:30:54.878]                     muffled <- FALSE
[10:30:54.878]                     if (inherits(cond, "message")) {
[10:30:54.878]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.878]                       if (muffled) 
[10:30:54.878]                         invokeRestart("muffleMessage")
[10:30:54.878]                     }
[10:30:54.878]                     else if (inherits(cond, "warning")) {
[10:30:54.878]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.878]                       if (muffled) 
[10:30:54.878]                         invokeRestart("muffleWarning")
[10:30:54.878]                     }
[10:30:54.878]                     else if (inherits(cond, "condition")) {
[10:30:54.878]                       if (!is.null(pattern)) {
[10:30:54.878]                         computeRestarts <- base::computeRestarts
[10:30:54.878]                         grepl <- base::grepl
[10:30:54.878]                         restarts <- computeRestarts(cond)
[10:30:54.878]                         for (restart in restarts) {
[10:30:54.878]                           name <- restart$name
[10:30:54.878]                           if (is.null(name)) 
[10:30:54.878]                             next
[10:30:54.878]                           if (!grepl(pattern, name)) 
[10:30:54.878]                             next
[10:30:54.878]                           invokeRestart(restart)
[10:30:54.878]                           muffled <- TRUE
[10:30:54.878]                           break
[10:30:54.878]                         }
[10:30:54.878]                       }
[10:30:54.878]                     }
[10:30:54.878]                     invisible(muffled)
[10:30:54.878]                   }
[10:30:54.878]                   muffleCondition(cond)
[10:30:54.878]                 })
[10:30:54.878]             }))
[10:30:54.878]             future::FutureResult(value = ...future.value$value, 
[10:30:54.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.878]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.878]                     ...future.globalenv.names))
[10:30:54.878]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.878]         }, condition = base::local({
[10:30:54.878]             c <- base::c
[10:30:54.878]             inherits <- base::inherits
[10:30:54.878]             invokeRestart <- base::invokeRestart
[10:30:54.878]             length <- base::length
[10:30:54.878]             list <- base::list
[10:30:54.878]             seq.int <- base::seq.int
[10:30:54.878]             signalCondition <- base::signalCondition
[10:30:54.878]             sys.calls <- base::sys.calls
[10:30:54.878]             `[[` <- base::`[[`
[10:30:54.878]             `+` <- base::`+`
[10:30:54.878]             `<<-` <- base::`<<-`
[10:30:54.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.878]                   3L)]
[10:30:54.878]             }
[10:30:54.878]             function(cond) {
[10:30:54.878]                 is_error <- inherits(cond, "error")
[10:30:54.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.878]                   NULL)
[10:30:54.878]                 if (is_error) {
[10:30:54.878]                   sessionInformation <- function() {
[10:30:54.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.878]                       search = base::search(), system = base::Sys.info())
[10:30:54.878]                   }
[10:30:54.878]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.878]                     cond$call), session = sessionInformation(), 
[10:30:54.878]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.878]                   signalCondition(cond)
[10:30:54.878]                 }
[10:30:54.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.878]                 "immediateCondition"))) {
[10:30:54.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.878]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.878]                   if (TRUE && !signal) {
[10:30:54.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.878]                     {
[10:30:54.878]                       inherits <- base::inherits
[10:30:54.878]                       invokeRestart <- base::invokeRestart
[10:30:54.878]                       is.null <- base::is.null
[10:30:54.878]                       muffled <- FALSE
[10:30:54.878]                       if (inherits(cond, "message")) {
[10:30:54.878]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.878]                         if (muffled) 
[10:30:54.878]                           invokeRestart("muffleMessage")
[10:30:54.878]                       }
[10:30:54.878]                       else if (inherits(cond, "warning")) {
[10:30:54.878]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.878]                         if (muffled) 
[10:30:54.878]                           invokeRestart("muffleWarning")
[10:30:54.878]                       }
[10:30:54.878]                       else if (inherits(cond, "condition")) {
[10:30:54.878]                         if (!is.null(pattern)) {
[10:30:54.878]                           computeRestarts <- base::computeRestarts
[10:30:54.878]                           grepl <- base::grepl
[10:30:54.878]                           restarts <- computeRestarts(cond)
[10:30:54.878]                           for (restart in restarts) {
[10:30:54.878]                             name <- restart$name
[10:30:54.878]                             if (is.null(name)) 
[10:30:54.878]                               next
[10:30:54.878]                             if (!grepl(pattern, name)) 
[10:30:54.878]                               next
[10:30:54.878]                             invokeRestart(restart)
[10:30:54.878]                             muffled <- TRUE
[10:30:54.878]                             break
[10:30:54.878]                           }
[10:30:54.878]                         }
[10:30:54.878]                       }
[10:30:54.878]                       invisible(muffled)
[10:30:54.878]                     }
[10:30:54.878]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.878]                   }
[10:30:54.878]                 }
[10:30:54.878]                 else {
[10:30:54.878]                   if (TRUE) {
[10:30:54.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.878]                     {
[10:30:54.878]                       inherits <- base::inherits
[10:30:54.878]                       invokeRestart <- base::invokeRestart
[10:30:54.878]                       is.null <- base::is.null
[10:30:54.878]                       muffled <- FALSE
[10:30:54.878]                       if (inherits(cond, "message")) {
[10:30:54.878]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.878]                         if (muffled) 
[10:30:54.878]                           invokeRestart("muffleMessage")
[10:30:54.878]                       }
[10:30:54.878]                       else if (inherits(cond, "warning")) {
[10:30:54.878]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.878]                         if (muffled) 
[10:30:54.878]                           invokeRestart("muffleWarning")
[10:30:54.878]                       }
[10:30:54.878]                       else if (inherits(cond, "condition")) {
[10:30:54.878]                         if (!is.null(pattern)) {
[10:30:54.878]                           computeRestarts <- base::computeRestarts
[10:30:54.878]                           grepl <- base::grepl
[10:30:54.878]                           restarts <- computeRestarts(cond)
[10:30:54.878]                           for (restart in restarts) {
[10:30:54.878]                             name <- restart$name
[10:30:54.878]                             if (is.null(name)) 
[10:30:54.878]                               next
[10:30:54.878]                             if (!grepl(pattern, name)) 
[10:30:54.878]                               next
[10:30:54.878]                             invokeRestart(restart)
[10:30:54.878]                             muffled <- TRUE
[10:30:54.878]                             break
[10:30:54.878]                           }
[10:30:54.878]                         }
[10:30:54.878]                       }
[10:30:54.878]                       invisible(muffled)
[10:30:54.878]                     }
[10:30:54.878]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.878]                   }
[10:30:54.878]                 }
[10:30:54.878]             }
[10:30:54.878]         }))
[10:30:54.878]     }, error = function(ex) {
[10:30:54.878]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.878]                 ...future.rng), started = ...future.startTime, 
[10:30:54.878]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.878]             version = "1.8"), class = "FutureResult")
[10:30:54.878]     }, finally = {
[10:30:54.878]         if (!identical(...future.workdir, getwd())) 
[10:30:54.878]             setwd(...future.workdir)
[10:30:54.878]         {
[10:30:54.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.878]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.878]             }
[10:30:54.878]             base::options(...future.oldOptions)
[10:30:54.878]             if (.Platform$OS.type == "windows") {
[10:30:54.878]                 old_names <- names(...future.oldEnvVars)
[10:30:54.878]                 envs <- base::Sys.getenv()
[10:30:54.878]                 names <- names(envs)
[10:30:54.878]                 common <- intersect(names, old_names)
[10:30:54.878]                 added <- setdiff(names, old_names)
[10:30:54.878]                 removed <- setdiff(old_names, names)
[10:30:54.878]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.878]                   envs[common]]
[10:30:54.878]                 NAMES <- toupper(changed)
[10:30:54.878]                 args <- list()
[10:30:54.878]                 for (kk in seq_along(NAMES)) {
[10:30:54.878]                   name <- changed[[kk]]
[10:30:54.878]                   NAME <- NAMES[[kk]]
[10:30:54.878]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.878]                     next
[10:30:54.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.878]                 }
[10:30:54.878]                 NAMES <- toupper(added)
[10:30:54.878]                 for (kk in seq_along(NAMES)) {
[10:30:54.878]                   name <- added[[kk]]
[10:30:54.878]                   NAME <- NAMES[[kk]]
[10:30:54.878]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.878]                     next
[10:30:54.878]                   args[[name]] <- ""
[10:30:54.878]                 }
[10:30:54.878]                 NAMES <- toupper(removed)
[10:30:54.878]                 for (kk in seq_along(NAMES)) {
[10:30:54.878]                   name <- removed[[kk]]
[10:30:54.878]                   NAME <- NAMES[[kk]]
[10:30:54.878]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.878]                     next
[10:30:54.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.878]                 }
[10:30:54.878]                 if (length(args) > 0) 
[10:30:54.878]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.878]             }
[10:30:54.878]             else {
[10:30:54.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.878]             }
[10:30:54.878]             {
[10:30:54.878]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.878]                   0L) {
[10:30:54.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.878]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.878]                   base::options(opts)
[10:30:54.878]                 }
[10:30:54.878]                 {
[10:30:54.878]                   {
[10:30:54.878]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.878]                     NULL
[10:30:54.878]                   }
[10:30:54.878]                   options(future.plan = NULL)
[10:30:54.878]                   if (is.na(NA_character_)) 
[10:30:54.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.878]                     .init = FALSE)
[10:30:54.878]                 }
[10:30:54.878]             }
[10:30:54.878]         }
[10:30:54.878]     })
[10:30:54.878]     if (TRUE) {
[10:30:54.878]         base::sink(type = "output", split = FALSE)
[10:30:54.878]         if (TRUE) {
[10:30:54.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.878]         }
[10:30:54.878]         else {
[10:30:54.878]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.878]         }
[10:30:54.878]         base::close(...future.stdout)
[10:30:54.878]         ...future.stdout <- NULL
[10:30:54.878]     }
[10:30:54.878]     ...future.result$conditions <- ...future.conditions
[10:30:54.878]     ...future.result$finished <- base::Sys.time()
[10:30:54.878]     ...future.result
[10:30:54.878] }
[10:30:54.881] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[10:30:54.881] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[10:30:54.881] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[10:30:54.881] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[10:30:54.882] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[10:30:54.882] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:30:54.882] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:30:54.882] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:54.882] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.883] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:54.883] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:54.883] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[10:30:54.883] MultisessionFuture started
[10:30:54.884] - Launch lazy future ... done
[10:30:54.884] run() for ‘MultisessionFuture’ ... done
[10:30:54.884] Created future:
[10:30:54.884] MultisessionFuture:
[10:30:54.884] Label: ‘future_.mapply-2’
[10:30:54.884] Expression:
[10:30:54.884] {
[10:30:54.884]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.884]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.884]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.884]         on.exit(options(oopts), add = TRUE)
[10:30:54.884]     }
[10:30:54.884]     {
[10:30:54.884]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.884]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.884]         do.call(mapply, args = args)
[10:30:54.884]     }
[10:30:54.884] }
[10:30:54.884] Lazy evaluation: FALSE
[10:30:54.884] Asynchronous evaluation: TRUE
[10:30:54.884] Local evaluation: TRUE
[10:30:54.884] Environment: R_GlobalEnv
[10:30:54.884] Capture standard output: TRUE
[10:30:54.884] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.884] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.884] Packages: <none>
[10:30:54.884] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.884] Resolved: FALSE
[10:30:54.884] Value: <not collected>
[10:30:54.884] Conditions captured: <none>
[10:30:54.884] Early signaling: FALSE
[10:30:54.884] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.884] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.895] Chunk #2 of 2 ... DONE
[10:30:54.895] Launching 2 futures (chunks) ... DONE
[10:30:54.896] Resolving 2 futures (chunks) ...
[10:30:54.896] resolve() on list ...
[10:30:54.896]  recursive: 0
[10:30:54.896]  length: 2
[10:30:54.896] 
[10:30:54.896] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.897] - Validating connection of MultisessionFuture
[10:30:54.897] - received message: FutureResult
[10:30:54.897] - Received FutureResult
[10:30:54.897] - Erased future from FutureRegistry
[10:30:54.897] result() for ClusterFuture ...
[10:30:54.897] - result already collected: FutureResult
[10:30:54.897] result() for ClusterFuture ... done
[10:30:54.897] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.897] Future #1
[10:30:54.898] result() for ClusterFuture ...
[10:30:54.898] - result already collected: FutureResult
[10:30:54.898] result() for ClusterFuture ... done
[10:30:54.898] result() for ClusterFuture ...
[10:30:54.898] - result already collected: FutureResult
[10:30:54.898] result() for ClusterFuture ... done
[10:30:54.898] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:54.898] - nx: 2
[10:30:54.898] - relay: TRUE
[10:30:54.898] - stdout: TRUE
[10:30:54.898] - signal: TRUE
[10:30:54.899] - resignal: FALSE
[10:30:54.899] - force: TRUE
[10:30:54.899] - relayed: [n=2] FALSE, FALSE
[10:30:54.899] - queued futures: [n=2] FALSE, FALSE
[10:30:54.899]  - until=1
[10:30:54.899]  - relaying element #1
[10:30:54.899] result() for ClusterFuture ...
[10:30:54.899] - result already collected: FutureResult
[10:30:54.899] result() for ClusterFuture ... done
[10:30:54.899] result() for ClusterFuture ...
[10:30:54.899] - result already collected: FutureResult
[10:30:54.899] result() for ClusterFuture ... done
[10:30:54.900] result() for ClusterFuture ...
[10:30:54.900] - result already collected: FutureResult
[10:30:54.900] result() for ClusterFuture ... done
[10:30:54.900] result() for ClusterFuture ...
[10:30:54.900] - result already collected: FutureResult
[10:30:54.900] result() for ClusterFuture ... done
[10:30:54.900] - relayed: [n=2] TRUE, FALSE
[10:30:54.900] - queued futures: [n=2] TRUE, FALSE
[10:30:54.900] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:54.900]  length: 1 (resolved future 1)
[10:30:54.926] receiveMessageFromWorker() for ClusterFuture ...
[10:30:54.927] - Validating connection of MultisessionFuture
[10:30:54.927] - received message: FutureResult
[10:30:54.927] - Received FutureResult
[10:30:54.927] - Erased future from FutureRegistry
[10:30:54.927] result() for ClusterFuture ...
[10:30:54.927] - result already collected: FutureResult
[10:30:54.928] result() for ClusterFuture ... done
[10:30:54.928] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:54.928] Future #2
[10:30:54.928] result() for ClusterFuture ...
[10:30:54.928] - result already collected: FutureResult
[10:30:54.928] result() for ClusterFuture ... done
[10:30:54.928] result() for ClusterFuture ...
[10:30:54.928] - result already collected: FutureResult
[10:30:54.928] result() for ClusterFuture ... done
[10:30:54.928] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:54.928] - nx: 2
[10:30:54.929] - relay: TRUE
[10:30:54.929] - stdout: TRUE
[10:30:54.929] - signal: TRUE
[10:30:54.929] - resignal: FALSE
[10:30:54.929] - force: TRUE
[10:30:54.929] - relayed: [n=2] TRUE, FALSE
[10:30:54.929] - queued futures: [n=2] TRUE, FALSE
[10:30:54.929]  - until=2
[10:30:54.929]  - relaying element #2
[10:30:54.929] result() for ClusterFuture ...
[10:30:54.929] - result already collected: FutureResult
[10:30:54.930] result() for ClusterFuture ... done
[10:30:54.930] result() for ClusterFuture ...
[10:30:54.930] - result already collected: FutureResult
[10:30:54.930] result() for ClusterFuture ... done
[10:30:54.930] result() for ClusterFuture ...
[10:30:54.930] - result already collected: FutureResult
[10:30:54.930] result() for ClusterFuture ... done
[10:30:54.930] result() for ClusterFuture ...
[10:30:54.930] - result already collected: FutureResult
[10:30:54.930] result() for ClusterFuture ... done
[10:30:54.930] - relayed: [n=2] TRUE, TRUE
[10:30:54.931] - queued futures: [n=2] TRUE, TRUE
[10:30:54.931] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:54.931]  length: 0 (resolved future 2)
[10:30:54.931] Relaying remaining futures
[10:30:54.931] signalConditionsASAP(NULL, pos=0) ...
[10:30:54.931] - nx: 2
[10:30:54.931] - relay: TRUE
[10:30:54.931] - stdout: TRUE
[10:30:54.931] - signal: TRUE
[10:30:54.931] - resignal: FALSE
[10:30:54.931] - force: TRUE
[10:30:54.932] - relayed: [n=2] TRUE, TRUE
[10:30:54.932] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:54.932] - relayed: [n=2] TRUE, TRUE
[10:30:54.932] - queued futures: [n=2] TRUE, TRUE
[10:30:54.932] signalConditionsASAP(NULL, pos=0) ... done
[10:30:54.932] resolve() on list ... DONE
[10:30:54.932] result() for ClusterFuture ...
[10:30:54.932] - result already collected: FutureResult
[10:30:54.932] result() for ClusterFuture ... done
[10:30:54.932] result() for ClusterFuture ...
[10:30:54.932] - result already collected: FutureResult
[10:30:54.933] result() for ClusterFuture ... done
[10:30:54.933] result() for ClusterFuture ...
[10:30:54.933] - result already collected: FutureResult
[10:30:54.933] result() for ClusterFuture ... done
[10:30:54.933] result() for ClusterFuture ...
[10:30:54.933] - result already collected: FutureResult
[10:30:54.933] result() for ClusterFuture ... done
[10:30:54.933]  - Number of value chunks collected: 2
[10:30:54.933] Resolving 2 futures (chunks) ... DONE
[10:30:54.933] Reducing values from 2 chunks ...
[10:30:54.934]  - Number of values collected after concatenation: 2
[10:30:54.934]  - Number of values expected: 2
[10:30:54.934] Reducing values from 2 chunks ... DONE
[10:30:54.934] future_mapply() ... DONE
- Recycle arguments to same length ...
[10:30:54.934] future_mapply() ...
[10:30:54.938] Number of chunks: 2
[10:30:54.938] getGlobalsAndPackagesXApply() ...
[10:30:54.938]  - future.globals: TRUE
[10:30:54.938] getGlobalsAndPackages() ...
[10:30:54.938] Searching for globals...
[10:30:54.939] - globals found: [1] ‘FUN’
[10:30:54.939] Searching for globals ... DONE
[10:30:54.939] Resolving globals: FALSE
[10:30:54.940] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:54.940] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:54.940] - globals: [1] ‘FUN’
[10:30:54.940] 
[10:30:54.940] getGlobalsAndPackages() ... DONE
[10:30:54.940]  - globals found/used: [n=1] ‘FUN’
[10:30:54.940]  - needed namespaces: [n=0] 
[10:30:54.941] Finding globals ... DONE
[10:30:54.941] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:54.941] List of 2
[10:30:54.941]  $ ...future.FUN:function (x, ...)  
[10:30:54.941]  $ MoreArgs     : NULL
[10:30:54.941]  - attr(*, "where")=List of 2
[10:30:54.941]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:54.941]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:54.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:54.941]  - attr(*, "resolved")= logi FALSE
[10:30:54.941]  - attr(*, "total_size")= num NA
[10:30:54.943] Packages to be attached in all futures: [n=0] 
[10:30:54.944] getGlobalsAndPackagesXApply() ... DONE
[10:30:54.944] Number of futures (= number of chunks): 2
[10:30:54.944] Launching 2 futures (chunks) ...
[10:30:54.944] Chunk #1 of 2 ...
[10:30:54.944]  - Finding globals in '...' for chunk #1 ...
[10:30:54.944] getGlobalsAndPackages() ...
[10:30:54.944] Searching for globals...
[10:30:54.945] 
[10:30:54.945] Searching for globals ... DONE
[10:30:54.945] - globals: [0] <none>
[10:30:54.945] getGlobalsAndPackages() ... DONE
[10:30:54.945]    + additional globals found: [n=0] 
[10:30:54.945]    + additional namespaces needed: [n=0] 
[10:30:54.945]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:54.948]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.948]  - seeds: <none>
[10:30:54.948]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.948] getGlobalsAndPackages() ...
[10:30:54.949] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.949] Resolving globals: FALSE
[10:30:54.949] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:54.950] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:54.950] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.950] 
[10:30:54.950] getGlobalsAndPackages() ... DONE
[10:30:54.950] run() for ‘Future’ ...
[10:30:54.950] - state: ‘created’
[10:30:54.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:54.964] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:54.964]   - Field: ‘node’
[10:30:54.965]   - Field: ‘label’
[10:30:54.965]   - Field: ‘local’
[10:30:54.965]   - Field: ‘owner’
[10:30:54.965]   - Field: ‘envir’
[10:30:54.965]   - Field: ‘workers’
[10:30:54.965]   - Field: ‘packages’
[10:30:54.965]   - Field: ‘gc’
[10:30:54.965]   - Field: ‘conditions’
[10:30:54.965]   - Field: ‘persistent’
[10:30:54.965]   - Field: ‘expr’
[10:30:54.966]   - Field: ‘uuid’
[10:30:54.966]   - Field: ‘seed’
[10:30:54.966]   - Field: ‘version’
[10:30:54.966]   - Field: ‘result’
[10:30:54.966]   - Field: ‘asynchronous’
[10:30:54.966]   - Field: ‘calls’
[10:30:54.966]   - Field: ‘globals’
[10:30:54.966]   - Field: ‘stdout’
[10:30:54.966]   - Field: ‘earlySignal’
[10:30:54.966]   - Field: ‘lazy’
[10:30:54.966]   - Field: ‘state’
[10:30:54.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:54.967] - Launch lazy future ...
[10:30:54.967] Packages needed by the future expression (n = 0): <none>
[10:30:54.967] Packages needed by future strategies (n = 0): <none>
[10:30:54.967] {
[10:30:54.967]     {
[10:30:54.967]         {
[10:30:54.967]             ...future.startTime <- base::Sys.time()
[10:30:54.967]             {
[10:30:54.967]                 {
[10:30:54.967]                   {
[10:30:54.967]                     {
[10:30:54.967]                       base::local({
[10:30:54.967]                         has_future <- base::requireNamespace("future", 
[10:30:54.967]                           quietly = TRUE)
[10:30:54.967]                         if (has_future) {
[10:30:54.967]                           ns <- base::getNamespace("future")
[10:30:54.967]                           version <- ns[[".package"]][["version"]]
[10:30:54.967]                           if (is.null(version)) 
[10:30:54.967]                             version <- utils::packageVersion("future")
[10:30:54.967]                         }
[10:30:54.967]                         else {
[10:30:54.967]                           version <- NULL
[10:30:54.967]                         }
[10:30:54.967]                         if (!has_future || version < "1.8.0") {
[10:30:54.967]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:54.967]                             "", base::R.version$version.string), 
[10:30:54.967]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:54.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:54.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:54.967]                               "release", "version")], collapse = " "), 
[10:30:54.967]                             hostname = base::Sys.info()[["nodename"]])
[10:30:54.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:54.967]                             info)
[10:30:54.967]                           info <- base::paste(info, collapse = "; ")
[10:30:54.967]                           if (!has_future) {
[10:30:54.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:54.967]                               info)
[10:30:54.967]                           }
[10:30:54.967]                           else {
[10:30:54.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:54.967]                               info, version)
[10:30:54.967]                           }
[10:30:54.967]                           base::stop(msg)
[10:30:54.967]                         }
[10:30:54.967]                       })
[10:30:54.967]                     }
[10:30:54.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:54.967]                     base::options(mc.cores = 1L)
[10:30:54.967]                   }
[10:30:54.967]                   ...future.strategy.old <- future::plan("list")
[10:30:54.967]                   options(future.plan = NULL)
[10:30:54.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:54.967]                 }
[10:30:54.967]                 ...future.workdir <- getwd()
[10:30:54.967]             }
[10:30:54.967]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:54.967]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:54.967]         }
[10:30:54.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:54.967]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:54.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:54.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:54.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:54.967]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:54.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:54.967]             base::names(...future.oldOptions))
[10:30:54.967]     }
[10:30:54.967]     if (FALSE) {
[10:30:54.967]     }
[10:30:54.967]     else {
[10:30:54.967]         if (TRUE) {
[10:30:54.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:54.967]                 open = "w")
[10:30:54.967]         }
[10:30:54.967]         else {
[10:30:54.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:54.967]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:54.967]         }
[10:30:54.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:54.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:54.967]             base::sink(type = "output", split = FALSE)
[10:30:54.967]             base::close(...future.stdout)
[10:30:54.967]         }, add = TRUE)
[10:30:54.967]     }
[10:30:54.967]     ...future.frame <- base::sys.nframe()
[10:30:54.967]     ...future.conditions <- base::list()
[10:30:54.967]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:54.967]     if (FALSE) {
[10:30:54.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:54.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:54.967]     }
[10:30:54.967]     ...future.result <- base::tryCatch({
[10:30:54.967]         base::withCallingHandlers({
[10:30:54.967]             ...future.value <- base::withVisible(base::local({
[10:30:54.967]                 ...future.makeSendCondition <- base::local({
[10:30:54.967]                   sendCondition <- NULL
[10:30:54.967]                   function(frame = 1L) {
[10:30:54.967]                     if (is.function(sendCondition)) 
[10:30:54.967]                       return(sendCondition)
[10:30:54.967]                     ns <- getNamespace("parallel")
[10:30:54.967]                     if (exists("sendData", mode = "function", 
[10:30:54.967]                       envir = ns)) {
[10:30:54.967]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:54.967]                         envir = ns)
[10:30:54.967]                       envir <- sys.frame(frame)
[10:30:54.967]                       master <- NULL
[10:30:54.967]                       while (!identical(envir, .GlobalEnv) && 
[10:30:54.967]                         !identical(envir, emptyenv())) {
[10:30:54.967]                         if (exists("master", mode = "list", envir = envir, 
[10:30:54.967]                           inherits = FALSE)) {
[10:30:54.967]                           master <- get("master", mode = "list", 
[10:30:54.967]                             envir = envir, inherits = FALSE)
[10:30:54.967]                           if (inherits(master, c("SOCKnode", 
[10:30:54.967]                             "SOCK0node"))) {
[10:30:54.967]                             sendCondition <<- function(cond) {
[10:30:54.967]                               data <- list(type = "VALUE", value = cond, 
[10:30:54.967]                                 success = TRUE)
[10:30:54.967]                               parallel_sendData(master, data)
[10:30:54.967]                             }
[10:30:54.967]                             return(sendCondition)
[10:30:54.967]                           }
[10:30:54.967]                         }
[10:30:54.967]                         frame <- frame + 1L
[10:30:54.967]                         envir <- sys.frame(frame)
[10:30:54.967]                       }
[10:30:54.967]                     }
[10:30:54.967]                     sendCondition <<- function(cond) NULL
[10:30:54.967]                   }
[10:30:54.967]                 })
[10:30:54.967]                 withCallingHandlers({
[10:30:54.967]                   {
[10:30:54.967]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.967]                     if (!identical(...future.globals.maxSize.org, 
[10:30:54.967]                       ...future.globals.maxSize)) {
[10:30:54.967]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.967]                       on.exit(options(oopts), add = TRUE)
[10:30:54.967]                     }
[10:30:54.967]                     {
[10:30:54.967]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.967]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:54.967]                         USE.NAMES = FALSE)
[10:30:54.967]                       do.call(mapply, args = args)
[10:30:54.967]                     }
[10:30:54.967]                   }
[10:30:54.967]                 }, immediateCondition = function(cond) {
[10:30:54.967]                   sendCondition <- ...future.makeSendCondition()
[10:30:54.967]                   sendCondition(cond)
[10:30:54.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.967]                   {
[10:30:54.967]                     inherits <- base::inherits
[10:30:54.967]                     invokeRestart <- base::invokeRestart
[10:30:54.967]                     is.null <- base::is.null
[10:30:54.967]                     muffled <- FALSE
[10:30:54.967]                     if (inherits(cond, "message")) {
[10:30:54.967]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:54.967]                       if (muffled) 
[10:30:54.967]                         invokeRestart("muffleMessage")
[10:30:54.967]                     }
[10:30:54.967]                     else if (inherits(cond, "warning")) {
[10:30:54.967]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:54.967]                       if (muffled) 
[10:30:54.967]                         invokeRestart("muffleWarning")
[10:30:54.967]                     }
[10:30:54.967]                     else if (inherits(cond, "condition")) {
[10:30:54.967]                       if (!is.null(pattern)) {
[10:30:54.967]                         computeRestarts <- base::computeRestarts
[10:30:54.967]                         grepl <- base::grepl
[10:30:54.967]                         restarts <- computeRestarts(cond)
[10:30:54.967]                         for (restart in restarts) {
[10:30:54.967]                           name <- restart$name
[10:30:54.967]                           if (is.null(name)) 
[10:30:54.967]                             next
[10:30:54.967]                           if (!grepl(pattern, name)) 
[10:30:54.967]                             next
[10:30:54.967]                           invokeRestart(restart)
[10:30:54.967]                           muffled <- TRUE
[10:30:54.967]                           break
[10:30:54.967]                         }
[10:30:54.967]                       }
[10:30:54.967]                     }
[10:30:54.967]                     invisible(muffled)
[10:30:54.967]                   }
[10:30:54.967]                   muffleCondition(cond)
[10:30:54.967]                 })
[10:30:54.967]             }))
[10:30:54.967]             future::FutureResult(value = ...future.value$value, 
[10:30:54.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.967]                   ...future.rng), globalenv = if (FALSE) 
[10:30:54.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:54.967]                     ...future.globalenv.names))
[10:30:54.967]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:54.967]         }, condition = base::local({
[10:30:54.967]             c <- base::c
[10:30:54.967]             inherits <- base::inherits
[10:30:54.967]             invokeRestart <- base::invokeRestart
[10:30:54.967]             length <- base::length
[10:30:54.967]             list <- base::list
[10:30:54.967]             seq.int <- base::seq.int
[10:30:54.967]             signalCondition <- base::signalCondition
[10:30:54.967]             sys.calls <- base::sys.calls
[10:30:54.967]             `[[` <- base::`[[`
[10:30:54.967]             `+` <- base::`+`
[10:30:54.967]             `<<-` <- base::`<<-`
[10:30:54.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:54.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:54.967]                   3L)]
[10:30:54.967]             }
[10:30:54.967]             function(cond) {
[10:30:54.967]                 is_error <- inherits(cond, "error")
[10:30:54.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:54.967]                   NULL)
[10:30:54.967]                 if (is_error) {
[10:30:54.967]                   sessionInformation <- function() {
[10:30:54.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:54.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:54.967]                       search = base::search(), system = base::Sys.info())
[10:30:54.967]                   }
[10:30:54.967]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:54.967]                     cond$call), session = sessionInformation(), 
[10:30:54.967]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:54.967]                   signalCondition(cond)
[10:30:54.967]                 }
[10:30:54.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:54.967]                 "immediateCondition"))) {
[10:30:54.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:54.967]                   ...future.conditions[[length(...future.conditions) + 
[10:30:54.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:54.967]                   if (TRUE && !signal) {
[10:30:54.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.967]                     {
[10:30:54.967]                       inherits <- base::inherits
[10:30:54.967]                       invokeRestart <- base::invokeRestart
[10:30:54.967]                       is.null <- base::is.null
[10:30:54.967]                       muffled <- FALSE
[10:30:54.967]                       if (inherits(cond, "message")) {
[10:30:54.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.967]                         if (muffled) 
[10:30:54.967]                           invokeRestart("muffleMessage")
[10:30:54.967]                       }
[10:30:54.967]                       else if (inherits(cond, "warning")) {
[10:30:54.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.967]                         if (muffled) 
[10:30:54.967]                           invokeRestart("muffleWarning")
[10:30:54.967]                       }
[10:30:54.967]                       else if (inherits(cond, "condition")) {
[10:30:54.967]                         if (!is.null(pattern)) {
[10:30:54.967]                           computeRestarts <- base::computeRestarts
[10:30:54.967]                           grepl <- base::grepl
[10:30:54.967]                           restarts <- computeRestarts(cond)
[10:30:54.967]                           for (restart in restarts) {
[10:30:54.967]                             name <- restart$name
[10:30:54.967]                             if (is.null(name)) 
[10:30:54.967]                               next
[10:30:54.967]                             if (!grepl(pattern, name)) 
[10:30:54.967]                               next
[10:30:54.967]                             invokeRestart(restart)
[10:30:54.967]                             muffled <- TRUE
[10:30:54.967]                             break
[10:30:54.967]                           }
[10:30:54.967]                         }
[10:30:54.967]                       }
[10:30:54.967]                       invisible(muffled)
[10:30:54.967]                     }
[10:30:54.967]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.967]                   }
[10:30:54.967]                 }
[10:30:54.967]                 else {
[10:30:54.967]                   if (TRUE) {
[10:30:54.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:54.967]                     {
[10:30:54.967]                       inherits <- base::inherits
[10:30:54.967]                       invokeRestart <- base::invokeRestart
[10:30:54.967]                       is.null <- base::is.null
[10:30:54.967]                       muffled <- FALSE
[10:30:54.967]                       if (inherits(cond, "message")) {
[10:30:54.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:54.967]                         if (muffled) 
[10:30:54.967]                           invokeRestart("muffleMessage")
[10:30:54.967]                       }
[10:30:54.967]                       else if (inherits(cond, "warning")) {
[10:30:54.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:54.967]                         if (muffled) 
[10:30:54.967]                           invokeRestart("muffleWarning")
[10:30:54.967]                       }
[10:30:54.967]                       else if (inherits(cond, "condition")) {
[10:30:54.967]                         if (!is.null(pattern)) {
[10:30:54.967]                           computeRestarts <- base::computeRestarts
[10:30:54.967]                           grepl <- base::grepl
[10:30:54.967]                           restarts <- computeRestarts(cond)
[10:30:54.967]                           for (restart in restarts) {
[10:30:54.967]                             name <- restart$name
[10:30:54.967]                             if (is.null(name)) 
[10:30:54.967]                               next
[10:30:54.967]                             if (!grepl(pattern, name)) 
[10:30:54.967]                               next
[10:30:54.967]                             invokeRestart(restart)
[10:30:54.967]                             muffled <- TRUE
[10:30:54.967]                             break
[10:30:54.967]                           }
[10:30:54.967]                         }
[10:30:54.967]                       }
[10:30:54.967]                       invisible(muffled)
[10:30:54.967]                     }
[10:30:54.967]                     muffleCondition(cond, pattern = "^muffle")
[10:30:54.967]                   }
[10:30:54.967]                 }
[10:30:54.967]             }
[10:30:54.967]         }))
[10:30:54.967]     }, error = function(ex) {
[10:30:54.967]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:54.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:54.967]                 ...future.rng), started = ...future.startTime, 
[10:30:54.967]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:54.967]             version = "1.8"), class = "FutureResult")
[10:30:54.967]     }, finally = {
[10:30:54.967]         if (!identical(...future.workdir, getwd())) 
[10:30:54.967]             setwd(...future.workdir)
[10:30:54.967]         {
[10:30:54.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:54.967]                 ...future.oldOptions$nwarnings <- NULL
[10:30:54.967]             }
[10:30:54.967]             base::options(...future.oldOptions)
[10:30:54.967]             if (.Platform$OS.type == "windows") {
[10:30:54.967]                 old_names <- names(...future.oldEnvVars)
[10:30:54.967]                 envs <- base::Sys.getenv()
[10:30:54.967]                 names <- names(envs)
[10:30:54.967]                 common <- intersect(names, old_names)
[10:30:54.967]                 added <- setdiff(names, old_names)
[10:30:54.967]                 removed <- setdiff(old_names, names)
[10:30:54.967]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:54.967]                   envs[common]]
[10:30:54.967]                 NAMES <- toupper(changed)
[10:30:54.967]                 args <- list()
[10:30:54.967]                 for (kk in seq_along(NAMES)) {
[10:30:54.967]                   name <- changed[[kk]]
[10:30:54.967]                   NAME <- NAMES[[kk]]
[10:30:54.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.967]                     next
[10:30:54.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.967]                 }
[10:30:54.967]                 NAMES <- toupper(added)
[10:30:54.967]                 for (kk in seq_along(NAMES)) {
[10:30:54.967]                   name <- added[[kk]]
[10:30:54.967]                   NAME <- NAMES[[kk]]
[10:30:54.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.967]                     next
[10:30:54.967]                   args[[name]] <- ""
[10:30:54.967]                 }
[10:30:54.967]                 NAMES <- toupper(removed)
[10:30:54.967]                 for (kk in seq_along(NAMES)) {
[10:30:54.967]                   name <- removed[[kk]]
[10:30:54.967]                   NAME <- NAMES[[kk]]
[10:30:54.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:54.967]                     next
[10:30:54.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:54.967]                 }
[10:30:54.967]                 if (length(args) > 0) 
[10:30:54.967]                   base::do.call(base::Sys.setenv, args = args)
[10:30:54.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:54.967]             }
[10:30:54.967]             else {
[10:30:54.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:54.967]             }
[10:30:54.967]             {
[10:30:54.967]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:54.967]                   0L) {
[10:30:54.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:54.967]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:54.967]                   base::options(opts)
[10:30:54.967]                 }
[10:30:54.967]                 {
[10:30:54.967]                   {
[10:30:54.967]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:54.967]                     NULL
[10:30:54.967]                   }
[10:30:54.967]                   options(future.plan = NULL)
[10:30:54.967]                   if (is.na(NA_character_)) 
[10:30:54.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:54.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:54.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:54.967]                     .init = FALSE)
[10:30:54.967]                 }
[10:30:54.967]             }
[10:30:54.967]         }
[10:30:54.967]     })
[10:30:54.967]     if (TRUE) {
[10:30:54.967]         base::sink(type = "output", split = FALSE)
[10:30:54.967]         if (TRUE) {
[10:30:54.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:54.967]         }
[10:30:54.967]         else {
[10:30:54.967]             ...future.result["stdout"] <- base::list(NULL)
[10:30:54.967]         }
[10:30:54.967]         base::close(...future.stdout)
[10:30:54.967]         ...future.stdout <- NULL
[10:30:54.967]     }
[10:30:54.967]     ...future.result$conditions <- ...future.conditions
[10:30:54.967]     ...future.result$finished <- base::Sys.time()
[10:30:54.967]     ...future.result
[10:30:54.967] }
[10:30:54.970] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[10:30:54.970] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[10:30:54.971] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[10:30:54.971] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:54.971] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.972] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[10:30:54.972] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[10:30:54.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:54.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.973] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:54.973] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:54.973] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[10:30:54.974] MultisessionFuture started
[10:30:54.974] - Launch lazy future ... done
[10:30:54.974] run() for ‘MultisessionFuture’ ... done
[10:30:54.974] Created future:
[10:30:54.974] MultisessionFuture:
[10:30:54.974] Label: ‘future_mapply-1’
[10:30:54.974] Expression:
[10:30:54.974] {
[10:30:54.974]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:54.974]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:54.974]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:54.974]         on.exit(options(oopts), add = TRUE)
[10:30:54.974]     }
[10:30:54.974]     {
[10:30:54.974]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:54.974]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:54.974]         do.call(mapply, args = args)
[10:30:54.974]     }
[10:30:54.974] }
[10:30:54.974] Lazy evaluation: FALSE
[10:30:54.974] Asynchronous evaluation: TRUE
[10:30:54.974] Local evaluation: TRUE
[10:30:54.974] Environment: R_GlobalEnv
[10:30:54.974] Capture standard output: TRUE
[10:30:54.974] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:54.974] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:54.974] Packages: <none>
[10:30:54.974] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:54.974] Resolved: FALSE
[10:30:54.974] Value: <not collected>
[10:30:54.974] Conditions captured: <none>
[10:30:54.974] Early signaling: FALSE
[10:30:54.974] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:54.974] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:54.986] Chunk #1 of 2 ... DONE
[10:30:54.986] Chunk #2 of 2 ...
[10:30:54.986]  - Finding globals in '...' for chunk #2 ...
[10:30:54.986] getGlobalsAndPackages() ...
[10:30:54.986] Searching for globals...
[10:30:54.987] 
[10:30:54.987] Searching for globals ... DONE
[10:30:54.987] - globals: [0] <none>
[10:30:54.987] getGlobalsAndPackages() ... DONE
[10:30:54.987]    + additional globals found: [n=0] 
[10:30:54.987]    + additional namespaces needed: [n=0] 
[10:30:54.987]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:54.987]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:54.987]  - seeds: <none>
[10:30:54.987]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.987] getGlobalsAndPackages() ...
[10:30:54.988] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.988] Resolving globals: FALSE
[10:30:54.988] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:54.989] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:54.989] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:54.989] 
[10:30:54.989] getGlobalsAndPackages() ... DONE
[10:30:54.989] run() for ‘Future’ ...
[10:30:54.989] - state: ‘created’
[10:30:54.990] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:55.004] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.004] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:55.004]   - Field: ‘node’
[10:30:55.004]   - Field: ‘label’
[10:30:55.004]   - Field: ‘local’
[10:30:55.004]   - Field: ‘owner’
[10:30:55.005]   - Field: ‘envir’
[10:30:55.005]   - Field: ‘workers’
[10:30:55.005]   - Field: ‘packages’
[10:30:55.005]   - Field: ‘gc’
[10:30:55.005]   - Field: ‘conditions’
[10:30:55.005]   - Field: ‘persistent’
[10:30:55.005]   - Field: ‘expr’
[10:30:55.005]   - Field: ‘uuid’
[10:30:55.005]   - Field: ‘seed’
[10:30:55.005]   - Field: ‘version’
[10:30:55.005]   - Field: ‘result’
[10:30:55.006]   - Field: ‘asynchronous’
[10:30:55.006]   - Field: ‘calls’
[10:30:55.006]   - Field: ‘globals’
[10:30:55.006]   - Field: ‘stdout’
[10:30:55.006]   - Field: ‘earlySignal’
[10:30:55.006]   - Field: ‘lazy’
[10:30:55.006]   - Field: ‘state’
[10:30:55.006] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:55.006] - Launch lazy future ...
[10:30:55.007] Packages needed by the future expression (n = 0): <none>
[10:30:55.007] Packages needed by future strategies (n = 0): <none>
[10:30:55.007] {
[10:30:55.007]     {
[10:30:55.007]         {
[10:30:55.007]             ...future.startTime <- base::Sys.time()
[10:30:55.007]             {
[10:30:55.007]                 {
[10:30:55.007]                   {
[10:30:55.007]                     {
[10:30:55.007]                       base::local({
[10:30:55.007]                         has_future <- base::requireNamespace("future", 
[10:30:55.007]                           quietly = TRUE)
[10:30:55.007]                         if (has_future) {
[10:30:55.007]                           ns <- base::getNamespace("future")
[10:30:55.007]                           version <- ns[[".package"]][["version"]]
[10:30:55.007]                           if (is.null(version)) 
[10:30:55.007]                             version <- utils::packageVersion("future")
[10:30:55.007]                         }
[10:30:55.007]                         else {
[10:30:55.007]                           version <- NULL
[10:30:55.007]                         }
[10:30:55.007]                         if (!has_future || version < "1.8.0") {
[10:30:55.007]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:55.007]                             "", base::R.version$version.string), 
[10:30:55.007]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:55.007]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:55.007]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:55.007]                               "release", "version")], collapse = " "), 
[10:30:55.007]                             hostname = base::Sys.info()[["nodename"]])
[10:30:55.007]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:55.007]                             info)
[10:30:55.007]                           info <- base::paste(info, collapse = "; ")
[10:30:55.007]                           if (!has_future) {
[10:30:55.007]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:55.007]                               info)
[10:30:55.007]                           }
[10:30:55.007]                           else {
[10:30:55.007]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:55.007]                               info, version)
[10:30:55.007]                           }
[10:30:55.007]                           base::stop(msg)
[10:30:55.007]                         }
[10:30:55.007]                       })
[10:30:55.007]                     }
[10:30:55.007]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:55.007]                     base::options(mc.cores = 1L)
[10:30:55.007]                   }
[10:30:55.007]                   ...future.strategy.old <- future::plan("list")
[10:30:55.007]                   options(future.plan = NULL)
[10:30:55.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:55.007]                 }
[10:30:55.007]                 ...future.workdir <- getwd()
[10:30:55.007]             }
[10:30:55.007]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:55.007]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:55.007]         }
[10:30:55.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:55.007]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:55.007]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:55.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:55.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:55.007]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:55.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:55.007]             base::names(...future.oldOptions))
[10:30:55.007]     }
[10:30:55.007]     if (FALSE) {
[10:30:55.007]     }
[10:30:55.007]     else {
[10:30:55.007]         if (TRUE) {
[10:30:55.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:55.007]                 open = "w")
[10:30:55.007]         }
[10:30:55.007]         else {
[10:30:55.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:55.007]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:55.007]         }
[10:30:55.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:55.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:55.007]             base::sink(type = "output", split = FALSE)
[10:30:55.007]             base::close(...future.stdout)
[10:30:55.007]         }, add = TRUE)
[10:30:55.007]     }
[10:30:55.007]     ...future.frame <- base::sys.nframe()
[10:30:55.007]     ...future.conditions <- base::list()
[10:30:55.007]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:55.007]     if (FALSE) {
[10:30:55.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:55.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:55.007]     }
[10:30:55.007]     ...future.result <- base::tryCatch({
[10:30:55.007]         base::withCallingHandlers({
[10:30:55.007]             ...future.value <- base::withVisible(base::local({
[10:30:55.007]                 ...future.makeSendCondition <- base::local({
[10:30:55.007]                   sendCondition <- NULL
[10:30:55.007]                   function(frame = 1L) {
[10:30:55.007]                     if (is.function(sendCondition)) 
[10:30:55.007]                       return(sendCondition)
[10:30:55.007]                     ns <- getNamespace("parallel")
[10:30:55.007]                     if (exists("sendData", mode = "function", 
[10:30:55.007]                       envir = ns)) {
[10:30:55.007]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:55.007]                         envir = ns)
[10:30:55.007]                       envir <- sys.frame(frame)
[10:30:55.007]                       master <- NULL
[10:30:55.007]                       while (!identical(envir, .GlobalEnv) && 
[10:30:55.007]                         !identical(envir, emptyenv())) {
[10:30:55.007]                         if (exists("master", mode = "list", envir = envir, 
[10:30:55.007]                           inherits = FALSE)) {
[10:30:55.007]                           master <- get("master", mode = "list", 
[10:30:55.007]                             envir = envir, inherits = FALSE)
[10:30:55.007]                           if (inherits(master, c("SOCKnode", 
[10:30:55.007]                             "SOCK0node"))) {
[10:30:55.007]                             sendCondition <<- function(cond) {
[10:30:55.007]                               data <- list(type = "VALUE", value = cond, 
[10:30:55.007]                                 success = TRUE)
[10:30:55.007]                               parallel_sendData(master, data)
[10:30:55.007]                             }
[10:30:55.007]                             return(sendCondition)
[10:30:55.007]                           }
[10:30:55.007]                         }
[10:30:55.007]                         frame <- frame + 1L
[10:30:55.007]                         envir <- sys.frame(frame)
[10:30:55.007]                       }
[10:30:55.007]                     }
[10:30:55.007]                     sendCondition <<- function(cond) NULL
[10:30:55.007]                   }
[10:30:55.007]                 })
[10:30:55.007]                 withCallingHandlers({
[10:30:55.007]                   {
[10:30:55.007]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.007]                     if (!identical(...future.globals.maxSize.org, 
[10:30:55.007]                       ...future.globals.maxSize)) {
[10:30:55.007]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.007]                       on.exit(options(oopts), add = TRUE)
[10:30:55.007]                     }
[10:30:55.007]                     {
[10:30:55.007]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.007]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:55.007]                         USE.NAMES = FALSE)
[10:30:55.007]                       do.call(mapply, args = args)
[10:30:55.007]                     }
[10:30:55.007]                   }
[10:30:55.007]                 }, immediateCondition = function(cond) {
[10:30:55.007]                   sendCondition <- ...future.makeSendCondition()
[10:30:55.007]                   sendCondition(cond)
[10:30:55.007]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.007]                   {
[10:30:55.007]                     inherits <- base::inherits
[10:30:55.007]                     invokeRestart <- base::invokeRestart
[10:30:55.007]                     is.null <- base::is.null
[10:30:55.007]                     muffled <- FALSE
[10:30:55.007]                     if (inherits(cond, "message")) {
[10:30:55.007]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:55.007]                       if (muffled) 
[10:30:55.007]                         invokeRestart("muffleMessage")
[10:30:55.007]                     }
[10:30:55.007]                     else if (inherits(cond, "warning")) {
[10:30:55.007]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:55.007]                       if (muffled) 
[10:30:55.007]                         invokeRestart("muffleWarning")
[10:30:55.007]                     }
[10:30:55.007]                     else if (inherits(cond, "condition")) {
[10:30:55.007]                       if (!is.null(pattern)) {
[10:30:55.007]                         computeRestarts <- base::computeRestarts
[10:30:55.007]                         grepl <- base::grepl
[10:30:55.007]                         restarts <- computeRestarts(cond)
[10:30:55.007]                         for (restart in restarts) {
[10:30:55.007]                           name <- restart$name
[10:30:55.007]                           if (is.null(name)) 
[10:30:55.007]                             next
[10:30:55.007]                           if (!grepl(pattern, name)) 
[10:30:55.007]                             next
[10:30:55.007]                           invokeRestart(restart)
[10:30:55.007]                           muffled <- TRUE
[10:30:55.007]                           break
[10:30:55.007]                         }
[10:30:55.007]                       }
[10:30:55.007]                     }
[10:30:55.007]                     invisible(muffled)
[10:30:55.007]                   }
[10:30:55.007]                   muffleCondition(cond)
[10:30:55.007]                 })
[10:30:55.007]             }))
[10:30:55.007]             future::FutureResult(value = ...future.value$value, 
[10:30:55.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.007]                   ...future.rng), globalenv = if (FALSE) 
[10:30:55.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:55.007]                     ...future.globalenv.names))
[10:30:55.007]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:55.007]         }, condition = base::local({
[10:30:55.007]             c <- base::c
[10:30:55.007]             inherits <- base::inherits
[10:30:55.007]             invokeRestart <- base::invokeRestart
[10:30:55.007]             length <- base::length
[10:30:55.007]             list <- base::list
[10:30:55.007]             seq.int <- base::seq.int
[10:30:55.007]             signalCondition <- base::signalCondition
[10:30:55.007]             sys.calls <- base::sys.calls
[10:30:55.007]             `[[` <- base::`[[`
[10:30:55.007]             `+` <- base::`+`
[10:30:55.007]             `<<-` <- base::`<<-`
[10:30:55.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:55.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:55.007]                   3L)]
[10:30:55.007]             }
[10:30:55.007]             function(cond) {
[10:30:55.007]                 is_error <- inherits(cond, "error")
[10:30:55.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:55.007]                   NULL)
[10:30:55.007]                 if (is_error) {
[10:30:55.007]                   sessionInformation <- function() {
[10:30:55.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:55.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:55.007]                       search = base::search(), system = base::Sys.info())
[10:30:55.007]                   }
[10:30:55.007]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:55.007]                     cond$call), session = sessionInformation(), 
[10:30:55.007]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:55.007]                   signalCondition(cond)
[10:30:55.007]                 }
[10:30:55.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:55.007]                 "immediateCondition"))) {
[10:30:55.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:55.007]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:55.007]                   if (TRUE && !signal) {
[10:30:55.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.007]                     {
[10:30:55.007]                       inherits <- base::inherits
[10:30:55.007]                       invokeRestart <- base::invokeRestart
[10:30:55.007]                       is.null <- base::is.null
[10:30:55.007]                       muffled <- FALSE
[10:30:55.007]                       if (inherits(cond, "message")) {
[10:30:55.007]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.007]                         if (muffled) 
[10:30:55.007]                           invokeRestart("muffleMessage")
[10:30:55.007]                       }
[10:30:55.007]                       else if (inherits(cond, "warning")) {
[10:30:55.007]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.007]                         if (muffled) 
[10:30:55.007]                           invokeRestart("muffleWarning")
[10:30:55.007]                       }
[10:30:55.007]                       else if (inherits(cond, "condition")) {
[10:30:55.007]                         if (!is.null(pattern)) {
[10:30:55.007]                           computeRestarts <- base::computeRestarts
[10:30:55.007]                           grepl <- base::grepl
[10:30:55.007]                           restarts <- computeRestarts(cond)
[10:30:55.007]                           for (restart in restarts) {
[10:30:55.007]                             name <- restart$name
[10:30:55.007]                             if (is.null(name)) 
[10:30:55.007]                               next
[10:30:55.007]                             if (!grepl(pattern, name)) 
[10:30:55.007]                               next
[10:30:55.007]                             invokeRestart(restart)
[10:30:55.007]                             muffled <- TRUE
[10:30:55.007]                             break
[10:30:55.007]                           }
[10:30:55.007]                         }
[10:30:55.007]                       }
[10:30:55.007]                       invisible(muffled)
[10:30:55.007]                     }
[10:30:55.007]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.007]                   }
[10:30:55.007]                 }
[10:30:55.007]                 else {
[10:30:55.007]                   if (TRUE) {
[10:30:55.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.007]                     {
[10:30:55.007]                       inherits <- base::inherits
[10:30:55.007]                       invokeRestart <- base::invokeRestart
[10:30:55.007]                       is.null <- base::is.null
[10:30:55.007]                       muffled <- FALSE
[10:30:55.007]                       if (inherits(cond, "message")) {
[10:30:55.007]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.007]                         if (muffled) 
[10:30:55.007]                           invokeRestart("muffleMessage")
[10:30:55.007]                       }
[10:30:55.007]                       else if (inherits(cond, "warning")) {
[10:30:55.007]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.007]                         if (muffled) 
[10:30:55.007]                           invokeRestart("muffleWarning")
[10:30:55.007]                       }
[10:30:55.007]                       else if (inherits(cond, "condition")) {
[10:30:55.007]                         if (!is.null(pattern)) {
[10:30:55.007]                           computeRestarts <- base::computeRestarts
[10:30:55.007]                           grepl <- base::grepl
[10:30:55.007]                           restarts <- computeRestarts(cond)
[10:30:55.007]                           for (restart in restarts) {
[10:30:55.007]                             name <- restart$name
[10:30:55.007]                             if (is.null(name)) 
[10:30:55.007]                               next
[10:30:55.007]                             if (!grepl(pattern, name)) 
[10:30:55.007]                               next
[10:30:55.007]                             invokeRestart(restart)
[10:30:55.007]                             muffled <- TRUE
[10:30:55.007]                             break
[10:30:55.007]                           }
[10:30:55.007]                         }
[10:30:55.007]                       }
[10:30:55.007]                       invisible(muffled)
[10:30:55.007]                     }
[10:30:55.007]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.007]                   }
[10:30:55.007]                 }
[10:30:55.007]             }
[10:30:55.007]         }))
[10:30:55.007]     }, error = function(ex) {
[10:30:55.007]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:55.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.007]                 ...future.rng), started = ...future.startTime, 
[10:30:55.007]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:55.007]             version = "1.8"), class = "FutureResult")
[10:30:55.007]     }, finally = {
[10:30:55.007]         if (!identical(...future.workdir, getwd())) 
[10:30:55.007]             setwd(...future.workdir)
[10:30:55.007]         {
[10:30:55.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:55.007]                 ...future.oldOptions$nwarnings <- NULL
[10:30:55.007]             }
[10:30:55.007]             base::options(...future.oldOptions)
[10:30:55.007]             if (.Platform$OS.type == "windows") {
[10:30:55.007]                 old_names <- names(...future.oldEnvVars)
[10:30:55.007]                 envs <- base::Sys.getenv()
[10:30:55.007]                 names <- names(envs)
[10:30:55.007]                 common <- intersect(names, old_names)
[10:30:55.007]                 added <- setdiff(names, old_names)
[10:30:55.007]                 removed <- setdiff(old_names, names)
[10:30:55.007]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:55.007]                   envs[common]]
[10:30:55.007]                 NAMES <- toupper(changed)
[10:30:55.007]                 args <- list()
[10:30:55.007]                 for (kk in seq_along(NAMES)) {
[10:30:55.007]                   name <- changed[[kk]]
[10:30:55.007]                   NAME <- NAMES[[kk]]
[10:30:55.007]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.007]                     next
[10:30:55.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.007]                 }
[10:30:55.007]                 NAMES <- toupper(added)
[10:30:55.007]                 for (kk in seq_along(NAMES)) {
[10:30:55.007]                   name <- added[[kk]]
[10:30:55.007]                   NAME <- NAMES[[kk]]
[10:30:55.007]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.007]                     next
[10:30:55.007]                   args[[name]] <- ""
[10:30:55.007]                 }
[10:30:55.007]                 NAMES <- toupper(removed)
[10:30:55.007]                 for (kk in seq_along(NAMES)) {
[10:30:55.007]                   name <- removed[[kk]]
[10:30:55.007]                   NAME <- NAMES[[kk]]
[10:30:55.007]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.007]                     next
[10:30:55.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.007]                 }
[10:30:55.007]                 if (length(args) > 0) 
[10:30:55.007]                   base::do.call(base::Sys.setenv, args = args)
[10:30:55.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:55.007]             }
[10:30:55.007]             else {
[10:30:55.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:55.007]             }
[10:30:55.007]             {
[10:30:55.007]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:55.007]                   0L) {
[10:30:55.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:55.007]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:55.007]                   base::options(opts)
[10:30:55.007]                 }
[10:30:55.007]                 {
[10:30:55.007]                   {
[10:30:55.007]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:55.007]                     NULL
[10:30:55.007]                   }
[10:30:55.007]                   options(future.plan = NULL)
[10:30:55.007]                   if (is.na(NA_character_)) 
[10:30:55.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:55.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:55.007]                     .init = FALSE)
[10:30:55.007]                 }
[10:30:55.007]             }
[10:30:55.007]         }
[10:30:55.007]     })
[10:30:55.007]     if (TRUE) {
[10:30:55.007]         base::sink(type = "output", split = FALSE)
[10:30:55.007]         if (TRUE) {
[10:30:55.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:55.007]         }
[10:30:55.007]         else {
[10:30:55.007]             ...future.result["stdout"] <- base::list(NULL)
[10:30:55.007]         }
[10:30:55.007]         base::close(...future.stdout)
[10:30:55.007]         ...future.stdout <- NULL
[10:30:55.007]     }
[10:30:55.007]     ...future.result$conditions <- ...future.conditions
[10:30:55.007]     ...future.result$finished <- base::Sys.time()
[10:30:55.007]     ...future.result
[10:30:55.007] }
[10:30:55.010] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[10:30:55.010] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[10:30:55.011] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[10:30:55.011] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:55.011] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.011] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[10:30:55.012] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[10:30:55.012] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:55.012] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.012] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:55.013] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.013] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[10:30:55.014] MultisessionFuture started
[10:30:55.014] - Launch lazy future ... done
[10:30:55.014] run() for ‘MultisessionFuture’ ... done
[10:30:55.014] Created future:
[10:30:55.014] MultisessionFuture:
[10:30:55.014] Label: ‘future_mapply-2’
[10:30:55.014] Expression:
[10:30:55.014] {
[10:30:55.014]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.014]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:55.014]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.014]         on.exit(options(oopts), add = TRUE)
[10:30:55.014]     }
[10:30:55.014]     {
[10:30:55.014]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.014]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:55.014]         do.call(mapply, args = args)
[10:30:55.014]     }
[10:30:55.014] }
[10:30:55.014] Lazy evaluation: FALSE
[10:30:55.014] Asynchronous evaluation: TRUE
[10:30:55.014] Local evaluation: TRUE
[10:30:55.014] Environment: R_GlobalEnv
[10:30:55.014] Capture standard output: TRUE
[10:30:55.014] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:55.014] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:55.014] Packages: <none>
[10:30:55.014] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:55.014] Resolved: FALSE
[10:30:55.014] Value: <not collected>
[10:30:55.014] Conditions captured: <none>
[10:30:55.014] Early signaling: FALSE
[10:30:55.014] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:55.014] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.026] Chunk #2 of 2 ... DONE
[10:30:55.026] Launching 2 futures (chunks) ... DONE
[10:30:55.026] Resolving 2 futures (chunks) ...
[10:30:55.026] resolve() on list ...
[10:30:55.026]  recursive: 0
[10:30:55.026]  length: 2
[10:30:55.026] 
[10:30:55.027] receiveMessageFromWorker() for ClusterFuture ...
[10:30:55.027] - Validating connection of MultisessionFuture
[10:30:55.027] - received message: FutureResult
[10:30:55.027] - Received FutureResult
[10:30:55.027] - Erased future from FutureRegistry
[10:30:55.027] result() for ClusterFuture ...
[10:30:55.027] - result already collected: FutureResult
[10:30:55.028] result() for ClusterFuture ... done
[10:30:55.028] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:55.028] Future #1
[10:30:55.028] result() for ClusterFuture ...
[10:30:55.028] - result already collected: FutureResult
[10:30:55.028] result() for ClusterFuture ... done
[10:30:55.028] result() for ClusterFuture ...
[10:30:55.028] - result already collected: FutureResult
[10:30:55.028] result() for ClusterFuture ... done
[10:30:55.028] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:55.028] - nx: 2
[10:30:55.029] - relay: TRUE
[10:30:55.029] - stdout: TRUE
[10:30:55.029] - signal: TRUE
[10:30:55.029] - resignal: FALSE
[10:30:55.029] - force: TRUE
[10:30:55.029] - relayed: [n=2] FALSE, FALSE
[10:30:55.029] - queued futures: [n=2] FALSE, FALSE
[10:30:55.029]  - until=1
[10:30:55.029]  - relaying element #1
[10:30:55.029] result() for ClusterFuture ...
[10:30:55.029] - result already collected: FutureResult
[10:30:55.030] result() for ClusterFuture ... done
[10:30:55.030] result() for ClusterFuture ...
[10:30:55.030] - result already collected: FutureResult
[10:30:55.030] result() for ClusterFuture ... done
[10:30:55.030] result() for ClusterFuture ...
[10:30:55.030] - result already collected: FutureResult
[10:30:55.030] result() for ClusterFuture ... done
[10:30:55.030] result() for ClusterFuture ...
[10:30:55.030] - result already collected: FutureResult
[10:30:55.030] result() for ClusterFuture ... done
[10:30:55.030] - relayed: [n=2] TRUE, FALSE
[10:30:55.031] - queued futures: [n=2] TRUE, FALSE
[10:30:55.031] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:55.031]  length: 1 (resolved future 1)
[10:30:55.059] receiveMessageFromWorker() for ClusterFuture ...
[10:30:55.059] - Validating connection of MultisessionFuture
[10:30:55.059] - received message: FutureResult
[10:30:55.059] - Received FutureResult
[10:30:55.059] - Erased future from FutureRegistry
[10:30:55.059] result() for ClusterFuture ...
[10:30:55.059] - result already collected: FutureResult
[10:30:55.060] result() for ClusterFuture ... done
[10:30:55.060] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:55.060] Future #2
[10:30:55.060] result() for ClusterFuture ...
[10:30:55.060] - result already collected: FutureResult
[10:30:55.060] result() for ClusterFuture ... done
[10:30:55.060] result() for ClusterFuture ...
[10:30:55.060] - result already collected: FutureResult
[10:30:55.060] result() for ClusterFuture ... done
[10:30:55.060] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:55.060] - nx: 2
[10:30:55.061] - relay: TRUE
[10:30:55.061] - stdout: TRUE
[10:30:55.061] - signal: TRUE
[10:30:55.061] - resignal: FALSE
[10:30:55.061] - force: TRUE
[10:30:55.061] - relayed: [n=2] TRUE, FALSE
[10:30:55.061] - queued futures: [n=2] TRUE, FALSE
[10:30:55.061]  - until=2
[10:30:55.061]  - relaying element #2
[10:30:55.061] result() for ClusterFuture ...
[10:30:55.061] - result already collected: FutureResult
[10:30:55.062] result() for ClusterFuture ... done
[10:30:55.062] result() for ClusterFuture ...
[10:30:55.062] - result already collected: FutureResult
[10:30:55.062] result() for ClusterFuture ... done
[10:30:55.062] result() for ClusterFuture ...
[10:30:55.062] - result already collected: FutureResult
[10:30:55.062] result() for ClusterFuture ... done
[10:30:55.062] result() for ClusterFuture ...
[10:30:55.062] - result already collected: FutureResult
[10:30:55.062] result() for ClusterFuture ... done
[10:30:55.062] - relayed: [n=2] TRUE, TRUE
[10:30:55.062] - queued futures: [n=2] TRUE, TRUE
[10:30:55.063] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:55.063]  length: 0 (resolved future 2)
[10:30:55.063] Relaying remaining futures
[10:30:55.063] signalConditionsASAP(NULL, pos=0) ...
[10:30:55.063] - nx: 2
[10:30:55.063] - relay: TRUE
[10:30:55.063] - stdout: TRUE
[10:30:55.063] - signal: TRUE
[10:30:55.063] - resignal: FALSE
[10:30:55.063] - force: TRUE
[10:30:55.063] - relayed: [n=2] TRUE, TRUE
[10:30:55.063] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:55.064] - relayed: [n=2] TRUE, TRUE
[10:30:55.064] - queued futures: [n=2] TRUE, TRUE
[10:30:55.064] signalConditionsASAP(NULL, pos=0) ... done
[10:30:55.064] resolve() on list ... DONE
[10:30:55.064] result() for ClusterFuture ...
[10:30:55.064] - result already collected: FutureResult
[10:30:55.064] result() for ClusterFuture ... done
[10:30:55.064] result() for ClusterFuture ...
[10:30:55.064] - result already collected: FutureResult
[10:30:55.064] result() for ClusterFuture ... done
[10:30:55.065] result() for ClusterFuture ...
[10:30:55.065] - result already collected: FutureResult
[10:30:55.065] result() for ClusterFuture ... done
[10:30:55.065] result() for ClusterFuture ...
[10:30:55.065] - result already collected: FutureResult
[10:30:55.065] result() for ClusterFuture ... done
[10:30:55.065]  - Number of value chunks collected: 2
[10:30:55.065] Resolving 2 futures (chunks) ... DONE
[10:30:55.065] Reducing values from 2 chunks ...
[10:30:55.065]  - Number of values collected after concatenation: 4
[10:30:55.065]  - Number of values expected: 4
[10:30:55.066] Reducing values from 2 chunks ... DONE
[10:30:55.066] future_mapply() ... DONE
- Parallel RNG ...
[10:30:55.066] future_mapply() ...
[10:30:55.066] Generating random seeds ...
[10:30:55.066] Generating random seed streams for 4 elements ...
[10:30:55.066] Generating random seed streams for 4 elements ... DONE
[10:30:55.066] Generating random seeds ... DONE
[10:30:55.066] Will set RNG state on exit: 10407, -743802738, -1924731576, 951271269, -668196096, 158975941, 1927356275
[10:30:55.071] Number of chunks: 2
[10:30:55.071] getGlobalsAndPackagesXApply() ...
[10:30:55.071]  - future.globals: TRUE
[10:30:55.071] getGlobalsAndPackages() ...
[10:30:55.071] Searching for globals...
[10:30:55.073] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:30:55.073] Searching for globals ... DONE
[10:30:55.073] Resolving globals: FALSE
[10:30:55.073] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[10:30:55.074] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[10:30:55.074] - globals: [1] ‘FUN’
[10:30:55.074] - packages: [1] ‘stats’
[10:30:55.074] getGlobalsAndPackages() ... DONE
[10:30:55.074]  - globals found/used: [n=1] ‘FUN’
[10:30:55.074]  - needed namespaces: [n=1] ‘stats’
[10:30:55.074] Finding globals ... DONE
[10:30:55.075] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:55.075] List of 2
[10:30:55.075]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:30:55.075]  $ MoreArgs     :List of 1
[10:30:55.075]   ..$ min: num 1
[10:30:55.075]  - attr(*, "where")=List of 2
[10:30:55.075]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:55.075]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:55.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:55.075]  - attr(*, "resolved")= logi FALSE
[10:30:55.075]  - attr(*, "total_size")= num NA
[10:30:55.078] Packages to be attached in all futures: [n=1] ‘stats’
[10:30:55.078] getGlobalsAndPackagesXApply() ... DONE
[10:30:55.078] Number of futures (= number of chunks): 2
[10:30:55.078] Launching 2 futures (chunks) ...
[10:30:55.078] Chunk #1 of 2 ...
[10:30:55.078]  - Finding globals in '...' for chunk #1 ...
[10:30:55.078] getGlobalsAndPackages() ...
[10:30:55.078] Searching for globals...
[10:30:55.079] 
[10:30:55.079] Searching for globals ... DONE
[10:30:55.079] - globals: [0] <none>
[10:30:55.079] getGlobalsAndPackages() ... DONE
[10:30:55.079]    + additional globals found: [n=0] 
[10:30:55.079]    + additional namespaces needed: [n=0] 
[10:30:55.079]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:55.079]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:55.079]  - seeds: [2] <seeds>
[10:30:55.080]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.080] getGlobalsAndPackages() ...
[10:30:55.080] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.080] Resolving globals: FALSE
[10:30:55.080] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[10:30:55.081] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[10:30:55.081] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.081] - packages: [1] ‘stats’
[10:30:55.081] getGlobalsAndPackages() ... DONE
[10:30:55.082] run() for ‘Future’ ...
[10:30:55.082] - state: ‘created’
[10:30:55.082] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:55.096] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.097] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:55.097]   - Field: ‘node’
[10:30:55.097]   - Field: ‘label’
[10:30:55.097]   - Field: ‘local’
[10:30:55.097]   - Field: ‘owner’
[10:30:55.097]   - Field: ‘envir’
[10:30:55.097]   - Field: ‘workers’
[10:30:55.097]   - Field: ‘packages’
[10:30:55.097]   - Field: ‘gc’
[10:30:55.098]   - Field: ‘conditions’
[10:30:55.098]   - Field: ‘persistent’
[10:30:55.098]   - Field: ‘expr’
[10:30:55.098]   - Field: ‘uuid’
[10:30:55.098]   - Field: ‘seed’
[10:30:55.098]   - Field: ‘version’
[10:30:55.098]   - Field: ‘result’
[10:30:55.098]   - Field: ‘asynchronous’
[10:30:55.098]   - Field: ‘calls’
[10:30:55.098]   - Field: ‘globals’
[10:30:55.098]   - Field: ‘stdout’
[10:30:55.099]   - Field: ‘earlySignal’
[10:30:55.099]   - Field: ‘lazy’
[10:30:55.099]   - Field: ‘state’
[10:30:55.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:55.099] - Launch lazy future ...
[10:30:55.099] Packages needed by the future expression (n = 1): ‘stats’
[10:30:55.099] Packages needed by future strategies (n = 0): <none>
[10:30:55.100] {
[10:30:55.100]     {
[10:30:55.100]         {
[10:30:55.100]             ...future.startTime <- base::Sys.time()
[10:30:55.100]             {
[10:30:55.100]                 {
[10:30:55.100]                   {
[10:30:55.100]                     {
[10:30:55.100]                       {
[10:30:55.100]                         base::local({
[10:30:55.100]                           has_future <- base::requireNamespace("future", 
[10:30:55.100]                             quietly = TRUE)
[10:30:55.100]                           if (has_future) {
[10:30:55.100]                             ns <- base::getNamespace("future")
[10:30:55.100]                             version <- ns[[".package"]][["version"]]
[10:30:55.100]                             if (is.null(version)) 
[10:30:55.100]                               version <- utils::packageVersion("future")
[10:30:55.100]                           }
[10:30:55.100]                           else {
[10:30:55.100]                             version <- NULL
[10:30:55.100]                           }
[10:30:55.100]                           if (!has_future || version < "1.8.0") {
[10:30:55.100]                             info <- base::c(r_version = base::gsub("R version ", 
[10:30:55.100]                               "", base::R.version$version.string), 
[10:30:55.100]                               platform = base::sprintf("%s (%s-bit)", 
[10:30:55.100]                                 base::R.version$platform, 8 * 
[10:30:55.100]                                   base::.Machine$sizeof.pointer), 
[10:30:55.100]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:55.100]                                 "release", "version")], collapse = " "), 
[10:30:55.100]                               hostname = base::Sys.info()[["nodename"]])
[10:30:55.100]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:30:55.100]                               info)
[10:30:55.100]                             info <- base::paste(info, collapse = "; ")
[10:30:55.100]                             if (!has_future) {
[10:30:55.100]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:55.100]                                 info)
[10:30:55.100]                             }
[10:30:55.100]                             else {
[10:30:55.100]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:55.100]                                 info, version)
[10:30:55.100]                             }
[10:30:55.100]                             base::stop(msg)
[10:30:55.100]                           }
[10:30:55.100]                         })
[10:30:55.100]                       }
[10:30:55.100]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:55.100]                       base::options(mc.cores = 1L)
[10:30:55.100]                     }
[10:30:55.100]                     base::local({
[10:30:55.100]                       for (pkg in "stats") {
[10:30:55.100]                         base::loadNamespace(pkg)
[10:30:55.100]                         base::library(pkg, character.only = TRUE)
[10:30:55.100]                       }
[10:30:55.100]                     })
[10:30:55.100]                   }
[10:30:55.100]                   ...future.strategy.old <- future::plan("list")
[10:30:55.100]                   options(future.plan = NULL)
[10:30:55.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:55.100]                 }
[10:30:55.100]                 ...future.workdir <- getwd()
[10:30:55.100]             }
[10:30:55.100]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:55.100]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:55.100]         }
[10:30:55.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:55.100]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:55.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:55.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:55.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:55.100]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:55.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:55.100]             base::names(...future.oldOptions))
[10:30:55.100]     }
[10:30:55.100]     if (FALSE) {
[10:30:55.100]     }
[10:30:55.100]     else {
[10:30:55.100]         if (TRUE) {
[10:30:55.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:55.100]                 open = "w")
[10:30:55.100]         }
[10:30:55.100]         else {
[10:30:55.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:55.100]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:55.100]         }
[10:30:55.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:55.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:55.100]             base::sink(type = "output", split = FALSE)
[10:30:55.100]             base::close(...future.stdout)
[10:30:55.100]         }, add = TRUE)
[10:30:55.100]     }
[10:30:55.100]     ...future.frame <- base::sys.nframe()
[10:30:55.100]     ...future.conditions <- base::list()
[10:30:55.100]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:55.100]     if (FALSE) {
[10:30:55.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:55.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:55.100]     }
[10:30:55.100]     ...future.result <- base::tryCatch({
[10:30:55.100]         base::withCallingHandlers({
[10:30:55.100]             ...future.value <- base::withVisible(base::local({
[10:30:55.100]                 ...future.makeSendCondition <- base::local({
[10:30:55.100]                   sendCondition <- NULL
[10:30:55.100]                   function(frame = 1L) {
[10:30:55.100]                     if (is.function(sendCondition)) 
[10:30:55.100]                       return(sendCondition)
[10:30:55.100]                     ns <- getNamespace("parallel")
[10:30:55.100]                     if (exists("sendData", mode = "function", 
[10:30:55.100]                       envir = ns)) {
[10:30:55.100]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:55.100]                         envir = ns)
[10:30:55.100]                       envir <- sys.frame(frame)
[10:30:55.100]                       master <- NULL
[10:30:55.100]                       while (!identical(envir, .GlobalEnv) && 
[10:30:55.100]                         !identical(envir, emptyenv())) {
[10:30:55.100]                         if (exists("master", mode = "list", envir = envir, 
[10:30:55.100]                           inherits = FALSE)) {
[10:30:55.100]                           master <- get("master", mode = "list", 
[10:30:55.100]                             envir = envir, inherits = FALSE)
[10:30:55.100]                           if (inherits(master, c("SOCKnode", 
[10:30:55.100]                             "SOCK0node"))) {
[10:30:55.100]                             sendCondition <<- function(cond) {
[10:30:55.100]                               data <- list(type = "VALUE", value = cond, 
[10:30:55.100]                                 success = TRUE)
[10:30:55.100]                               parallel_sendData(master, data)
[10:30:55.100]                             }
[10:30:55.100]                             return(sendCondition)
[10:30:55.100]                           }
[10:30:55.100]                         }
[10:30:55.100]                         frame <- frame + 1L
[10:30:55.100]                         envir <- sys.frame(frame)
[10:30:55.100]                       }
[10:30:55.100]                     }
[10:30:55.100]                     sendCondition <<- function(cond) NULL
[10:30:55.100]                   }
[10:30:55.100]                 })
[10:30:55.100]                 withCallingHandlers({
[10:30:55.100]                   {
[10:30:55.100]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.100]                     if (!identical(...future.globals.maxSize.org, 
[10:30:55.100]                       ...future.globals.maxSize)) {
[10:30:55.100]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.100]                       on.exit(options(oopts), add = TRUE)
[10:30:55.100]                     }
[10:30:55.100]                     {
[10:30:55.100]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:55.100]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:55.100]                           envir = globalenv(), inherits = FALSE)
[10:30:55.100]                         ...future.FUN(...)
[10:30:55.100]                       }
[10:30:55.100]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:55.100]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:55.100]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:55.100]                         USE.NAMES = FALSE)
[10:30:55.100]                       do.call(mapply, args = args)
[10:30:55.100]                     }
[10:30:55.100]                   }
[10:30:55.100]                 }, immediateCondition = function(cond) {
[10:30:55.100]                   sendCondition <- ...future.makeSendCondition()
[10:30:55.100]                   sendCondition(cond)
[10:30:55.100]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.100]                   {
[10:30:55.100]                     inherits <- base::inherits
[10:30:55.100]                     invokeRestart <- base::invokeRestart
[10:30:55.100]                     is.null <- base::is.null
[10:30:55.100]                     muffled <- FALSE
[10:30:55.100]                     if (inherits(cond, "message")) {
[10:30:55.100]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:55.100]                       if (muffled) 
[10:30:55.100]                         invokeRestart("muffleMessage")
[10:30:55.100]                     }
[10:30:55.100]                     else if (inherits(cond, "warning")) {
[10:30:55.100]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:55.100]                       if (muffled) 
[10:30:55.100]                         invokeRestart("muffleWarning")
[10:30:55.100]                     }
[10:30:55.100]                     else if (inherits(cond, "condition")) {
[10:30:55.100]                       if (!is.null(pattern)) {
[10:30:55.100]                         computeRestarts <- base::computeRestarts
[10:30:55.100]                         grepl <- base::grepl
[10:30:55.100]                         restarts <- computeRestarts(cond)
[10:30:55.100]                         for (restart in restarts) {
[10:30:55.100]                           name <- restart$name
[10:30:55.100]                           if (is.null(name)) 
[10:30:55.100]                             next
[10:30:55.100]                           if (!grepl(pattern, name)) 
[10:30:55.100]                             next
[10:30:55.100]                           invokeRestart(restart)
[10:30:55.100]                           muffled <- TRUE
[10:30:55.100]                           break
[10:30:55.100]                         }
[10:30:55.100]                       }
[10:30:55.100]                     }
[10:30:55.100]                     invisible(muffled)
[10:30:55.100]                   }
[10:30:55.100]                   muffleCondition(cond)
[10:30:55.100]                 })
[10:30:55.100]             }))
[10:30:55.100]             future::FutureResult(value = ...future.value$value, 
[10:30:55.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.100]                   ...future.rng), globalenv = if (FALSE) 
[10:30:55.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:55.100]                     ...future.globalenv.names))
[10:30:55.100]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:55.100]         }, condition = base::local({
[10:30:55.100]             c <- base::c
[10:30:55.100]             inherits <- base::inherits
[10:30:55.100]             invokeRestart <- base::invokeRestart
[10:30:55.100]             length <- base::length
[10:30:55.100]             list <- base::list
[10:30:55.100]             seq.int <- base::seq.int
[10:30:55.100]             signalCondition <- base::signalCondition
[10:30:55.100]             sys.calls <- base::sys.calls
[10:30:55.100]             `[[` <- base::`[[`
[10:30:55.100]             `+` <- base::`+`
[10:30:55.100]             `<<-` <- base::`<<-`
[10:30:55.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:55.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:55.100]                   3L)]
[10:30:55.100]             }
[10:30:55.100]             function(cond) {
[10:30:55.100]                 is_error <- inherits(cond, "error")
[10:30:55.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:55.100]                   NULL)
[10:30:55.100]                 if (is_error) {
[10:30:55.100]                   sessionInformation <- function() {
[10:30:55.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:55.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:55.100]                       search = base::search(), system = base::Sys.info())
[10:30:55.100]                   }
[10:30:55.100]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:55.100]                     cond$call), session = sessionInformation(), 
[10:30:55.100]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:55.100]                   signalCondition(cond)
[10:30:55.100]                 }
[10:30:55.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:55.100]                 "immediateCondition"))) {
[10:30:55.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:55.100]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:55.100]                   if (TRUE && !signal) {
[10:30:55.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.100]                     {
[10:30:55.100]                       inherits <- base::inherits
[10:30:55.100]                       invokeRestart <- base::invokeRestart
[10:30:55.100]                       is.null <- base::is.null
[10:30:55.100]                       muffled <- FALSE
[10:30:55.100]                       if (inherits(cond, "message")) {
[10:30:55.100]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.100]                         if (muffled) 
[10:30:55.100]                           invokeRestart("muffleMessage")
[10:30:55.100]                       }
[10:30:55.100]                       else if (inherits(cond, "warning")) {
[10:30:55.100]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.100]                         if (muffled) 
[10:30:55.100]                           invokeRestart("muffleWarning")
[10:30:55.100]                       }
[10:30:55.100]                       else if (inherits(cond, "condition")) {
[10:30:55.100]                         if (!is.null(pattern)) {
[10:30:55.100]                           computeRestarts <- base::computeRestarts
[10:30:55.100]                           grepl <- base::grepl
[10:30:55.100]                           restarts <- computeRestarts(cond)
[10:30:55.100]                           for (restart in restarts) {
[10:30:55.100]                             name <- restart$name
[10:30:55.100]                             if (is.null(name)) 
[10:30:55.100]                               next
[10:30:55.100]                             if (!grepl(pattern, name)) 
[10:30:55.100]                               next
[10:30:55.100]                             invokeRestart(restart)
[10:30:55.100]                             muffled <- TRUE
[10:30:55.100]                             break
[10:30:55.100]                           }
[10:30:55.100]                         }
[10:30:55.100]                       }
[10:30:55.100]                       invisible(muffled)
[10:30:55.100]                     }
[10:30:55.100]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.100]                   }
[10:30:55.100]                 }
[10:30:55.100]                 else {
[10:30:55.100]                   if (TRUE) {
[10:30:55.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.100]                     {
[10:30:55.100]                       inherits <- base::inherits
[10:30:55.100]                       invokeRestart <- base::invokeRestart
[10:30:55.100]                       is.null <- base::is.null
[10:30:55.100]                       muffled <- FALSE
[10:30:55.100]                       if (inherits(cond, "message")) {
[10:30:55.100]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.100]                         if (muffled) 
[10:30:55.100]                           invokeRestart("muffleMessage")
[10:30:55.100]                       }
[10:30:55.100]                       else if (inherits(cond, "warning")) {
[10:30:55.100]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.100]                         if (muffled) 
[10:30:55.100]                           invokeRestart("muffleWarning")
[10:30:55.100]                       }
[10:30:55.100]                       else if (inherits(cond, "condition")) {
[10:30:55.100]                         if (!is.null(pattern)) {
[10:30:55.100]                           computeRestarts <- base::computeRestarts
[10:30:55.100]                           grepl <- base::grepl
[10:30:55.100]                           restarts <- computeRestarts(cond)
[10:30:55.100]                           for (restart in restarts) {
[10:30:55.100]                             name <- restart$name
[10:30:55.100]                             if (is.null(name)) 
[10:30:55.100]                               next
[10:30:55.100]                             if (!grepl(pattern, name)) 
[10:30:55.100]                               next
[10:30:55.100]                             invokeRestart(restart)
[10:30:55.100]                             muffled <- TRUE
[10:30:55.100]                             break
[10:30:55.100]                           }
[10:30:55.100]                         }
[10:30:55.100]                       }
[10:30:55.100]                       invisible(muffled)
[10:30:55.100]                     }
[10:30:55.100]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.100]                   }
[10:30:55.100]                 }
[10:30:55.100]             }
[10:30:55.100]         }))
[10:30:55.100]     }, error = function(ex) {
[10:30:55.100]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:55.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.100]                 ...future.rng), started = ...future.startTime, 
[10:30:55.100]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:55.100]             version = "1.8"), class = "FutureResult")
[10:30:55.100]     }, finally = {
[10:30:55.100]         if (!identical(...future.workdir, getwd())) 
[10:30:55.100]             setwd(...future.workdir)
[10:30:55.100]         {
[10:30:55.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:55.100]                 ...future.oldOptions$nwarnings <- NULL
[10:30:55.100]             }
[10:30:55.100]             base::options(...future.oldOptions)
[10:30:55.100]             if (.Platform$OS.type == "windows") {
[10:30:55.100]                 old_names <- names(...future.oldEnvVars)
[10:30:55.100]                 envs <- base::Sys.getenv()
[10:30:55.100]                 names <- names(envs)
[10:30:55.100]                 common <- intersect(names, old_names)
[10:30:55.100]                 added <- setdiff(names, old_names)
[10:30:55.100]                 removed <- setdiff(old_names, names)
[10:30:55.100]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:55.100]                   envs[common]]
[10:30:55.100]                 NAMES <- toupper(changed)
[10:30:55.100]                 args <- list()
[10:30:55.100]                 for (kk in seq_along(NAMES)) {
[10:30:55.100]                   name <- changed[[kk]]
[10:30:55.100]                   NAME <- NAMES[[kk]]
[10:30:55.100]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.100]                     next
[10:30:55.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.100]                 }
[10:30:55.100]                 NAMES <- toupper(added)
[10:30:55.100]                 for (kk in seq_along(NAMES)) {
[10:30:55.100]                   name <- added[[kk]]
[10:30:55.100]                   NAME <- NAMES[[kk]]
[10:30:55.100]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.100]                     next
[10:30:55.100]                   args[[name]] <- ""
[10:30:55.100]                 }
[10:30:55.100]                 NAMES <- toupper(removed)
[10:30:55.100]                 for (kk in seq_along(NAMES)) {
[10:30:55.100]                   name <- removed[[kk]]
[10:30:55.100]                   NAME <- NAMES[[kk]]
[10:30:55.100]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.100]                     next
[10:30:55.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.100]                 }
[10:30:55.100]                 if (length(args) > 0) 
[10:30:55.100]                   base::do.call(base::Sys.setenv, args = args)
[10:30:55.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:55.100]             }
[10:30:55.100]             else {
[10:30:55.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:55.100]             }
[10:30:55.100]             {
[10:30:55.100]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:55.100]                   0L) {
[10:30:55.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:55.100]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:55.100]                   base::options(opts)
[10:30:55.100]                 }
[10:30:55.100]                 {
[10:30:55.100]                   {
[10:30:55.100]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:55.100]                     NULL
[10:30:55.100]                   }
[10:30:55.100]                   options(future.plan = NULL)
[10:30:55.100]                   if (is.na(NA_character_)) 
[10:30:55.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:55.100]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:55.100]                     .init = FALSE)
[10:30:55.100]                 }
[10:30:55.100]             }
[10:30:55.100]         }
[10:30:55.100]     })
[10:30:55.100]     if (TRUE) {
[10:30:55.100]         base::sink(type = "output", split = FALSE)
[10:30:55.100]         if (TRUE) {
[10:30:55.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:55.100]         }
[10:30:55.100]         else {
[10:30:55.100]             ...future.result["stdout"] <- base::list(NULL)
[10:30:55.100]         }
[10:30:55.100]         base::close(...future.stdout)
[10:30:55.100]         ...future.stdout <- NULL
[10:30:55.100]     }
[10:30:55.100]     ...future.result$conditions <- ...future.conditions
[10:30:55.100]     ...future.result$finished <- base::Sys.time()
[10:30:55.100]     ...future.result
[10:30:55.100] }
[10:30:55.103] Exporting 5 global objects (2.47 KiB) to cluster node #1 ...
[10:30:55.103] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ...
[10:30:55.103] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ... DONE
[10:30:55.104] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[10:30:55.104] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[10:30:55.104] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[10:30:55.104] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[10:30:55.105] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ...
[10:30:55.105] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ... DONE
[10:30:55.105] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:55.106] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:55.106] Exporting 5 global objects (2.47 KiB) to cluster node #1 ... DONE
[10:30:55.106] MultisessionFuture started
[10:30:55.106] - Launch lazy future ... done
[10:30:55.107] run() for ‘MultisessionFuture’ ... done
[10:30:55.107] Created future:
[10:30:55.107] MultisessionFuture:
[10:30:55.107] Label: ‘future_mapply-1’
[10:30:55.107] Expression:
[10:30:55.107] {
[10:30:55.107]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.107]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:55.107]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.107]         on.exit(options(oopts), add = TRUE)
[10:30:55.107]     }
[10:30:55.107]     {
[10:30:55.107]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:55.107]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:55.107]                 inherits = FALSE)
[10:30:55.107]             ...future.FUN(...)
[10:30:55.107]         }
[10:30:55.107]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:55.107]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:55.107]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:55.107]         do.call(mapply, args = args)
[10:30:55.107]     }
[10:30:55.107] }
[10:30:55.107] Lazy evaluation: FALSE
[10:30:55.107] Asynchronous evaluation: TRUE
[10:30:55.107] Local evaluation: TRUE
[10:30:55.107] Environment: R_GlobalEnv
[10:30:55.107] Capture standard output: TRUE
[10:30:55.107] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:55.107] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:55.107] Packages: 1 packages (‘stats’)
[10:30:55.107] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:55.107] Resolved: FALSE
[10:30:55.107] Value: <not collected>
[10:30:55.107] Conditions captured: <none>
[10:30:55.107] Early signaling: FALSE
[10:30:55.107] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:55.107] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.118] Chunk #1 of 2 ... DONE
[10:30:55.119] Chunk #2 of 2 ...
[10:30:55.119]  - Finding globals in '...' for chunk #2 ...
[10:30:55.119] getGlobalsAndPackages() ...
[10:30:55.119] Searching for globals...
[10:30:55.119] 
[10:30:55.119] Searching for globals ... DONE
[10:30:55.120] - globals: [0] <none>
[10:30:55.120] getGlobalsAndPackages() ... DONE
[10:30:55.120]    + additional globals found: [n=0] 
[10:30:55.120]    + additional namespaces needed: [n=0] 
[10:30:55.120]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:55.120]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:55.120]  - seeds: [2] <seeds>
[10:30:55.120]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.120] getGlobalsAndPackages() ...
[10:30:55.120] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.121] Resolving globals: FALSE
[10:30:55.121] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[10:30:55.122] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[10:30:55.122] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.122] - packages: [1] ‘stats’
[10:30:55.122] getGlobalsAndPackages() ... DONE
[10:30:55.122] run() for ‘Future’ ...
[10:30:55.122] - state: ‘created’
[10:30:55.122] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:55.140] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:55.140]   - Field: ‘node’
[10:30:55.140]   - Field: ‘label’
[10:30:55.140]   - Field: ‘local’
[10:30:55.140]   - Field: ‘owner’
[10:30:55.141]   - Field: ‘envir’
[10:30:55.141]   - Field: ‘workers’
[10:30:55.141]   - Field: ‘packages’
[10:30:55.141]   - Field: ‘gc’
[10:30:55.141]   - Field: ‘conditions’
[10:30:55.141]   - Field: ‘persistent’
[10:30:55.141]   - Field: ‘expr’
[10:30:55.141]   - Field: ‘uuid’
[10:30:55.141]   - Field: ‘seed’
[10:30:55.141]   - Field: ‘version’
[10:30:55.141]   - Field: ‘result’
[10:30:55.142]   - Field: ‘asynchronous’
[10:30:55.142]   - Field: ‘calls’
[10:30:55.142]   - Field: ‘globals’
[10:30:55.142]   - Field: ‘stdout’
[10:30:55.142]   - Field: ‘earlySignal’
[10:30:55.142]   - Field: ‘lazy’
[10:30:55.142]   - Field: ‘state’
[10:30:55.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:55.142] - Launch lazy future ...
[10:30:55.143] Packages needed by the future expression (n = 1): ‘stats’
[10:30:55.143] Packages needed by future strategies (n = 0): <none>
[10:30:55.143] {
[10:30:55.143]     {
[10:30:55.143]         {
[10:30:55.143]             ...future.startTime <- base::Sys.time()
[10:30:55.143]             {
[10:30:55.143]                 {
[10:30:55.143]                   {
[10:30:55.143]                     {
[10:30:55.143]                       {
[10:30:55.143]                         base::local({
[10:30:55.143]                           has_future <- base::requireNamespace("future", 
[10:30:55.143]                             quietly = TRUE)
[10:30:55.143]                           if (has_future) {
[10:30:55.143]                             ns <- base::getNamespace("future")
[10:30:55.143]                             version <- ns[[".package"]][["version"]]
[10:30:55.143]                             if (is.null(version)) 
[10:30:55.143]                               version <- utils::packageVersion("future")
[10:30:55.143]                           }
[10:30:55.143]                           else {
[10:30:55.143]                             version <- NULL
[10:30:55.143]                           }
[10:30:55.143]                           if (!has_future || version < "1.8.0") {
[10:30:55.143]                             info <- base::c(r_version = base::gsub("R version ", 
[10:30:55.143]                               "", base::R.version$version.string), 
[10:30:55.143]                               platform = base::sprintf("%s (%s-bit)", 
[10:30:55.143]                                 base::R.version$platform, 8 * 
[10:30:55.143]                                   base::.Machine$sizeof.pointer), 
[10:30:55.143]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:55.143]                                 "release", "version")], collapse = " "), 
[10:30:55.143]                               hostname = base::Sys.info()[["nodename"]])
[10:30:55.143]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:30:55.143]                               info)
[10:30:55.143]                             info <- base::paste(info, collapse = "; ")
[10:30:55.143]                             if (!has_future) {
[10:30:55.143]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:55.143]                                 info)
[10:30:55.143]                             }
[10:30:55.143]                             else {
[10:30:55.143]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:55.143]                                 info, version)
[10:30:55.143]                             }
[10:30:55.143]                             base::stop(msg)
[10:30:55.143]                           }
[10:30:55.143]                         })
[10:30:55.143]                       }
[10:30:55.143]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:55.143]                       base::options(mc.cores = 1L)
[10:30:55.143]                     }
[10:30:55.143]                     base::local({
[10:30:55.143]                       for (pkg in "stats") {
[10:30:55.143]                         base::loadNamespace(pkg)
[10:30:55.143]                         base::library(pkg, character.only = TRUE)
[10:30:55.143]                       }
[10:30:55.143]                     })
[10:30:55.143]                   }
[10:30:55.143]                   ...future.strategy.old <- future::plan("list")
[10:30:55.143]                   options(future.plan = NULL)
[10:30:55.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:55.143]                 }
[10:30:55.143]                 ...future.workdir <- getwd()
[10:30:55.143]             }
[10:30:55.143]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:55.143]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:55.143]         }
[10:30:55.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:55.143]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:55.143]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:55.143]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:55.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:55.143]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:55.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:55.143]             base::names(...future.oldOptions))
[10:30:55.143]     }
[10:30:55.143]     if (FALSE) {
[10:30:55.143]     }
[10:30:55.143]     else {
[10:30:55.143]         if (TRUE) {
[10:30:55.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:55.143]                 open = "w")
[10:30:55.143]         }
[10:30:55.143]         else {
[10:30:55.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:55.143]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:55.143]         }
[10:30:55.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:55.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:55.143]             base::sink(type = "output", split = FALSE)
[10:30:55.143]             base::close(...future.stdout)
[10:30:55.143]         }, add = TRUE)
[10:30:55.143]     }
[10:30:55.143]     ...future.frame <- base::sys.nframe()
[10:30:55.143]     ...future.conditions <- base::list()
[10:30:55.143]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:55.143]     if (FALSE) {
[10:30:55.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:55.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:55.143]     }
[10:30:55.143]     ...future.result <- base::tryCatch({
[10:30:55.143]         base::withCallingHandlers({
[10:30:55.143]             ...future.value <- base::withVisible(base::local({
[10:30:55.143]                 ...future.makeSendCondition <- base::local({
[10:30:55.143]                   sendCondition <- NULL
[10:30:55.143]                   function(frame = 1L) {
[10:30:55.143]                     if (is.function(sendCondition)) 
[10:30:55.143]                       return(sendCondition)
[10:30:55.143]                     ns <- getNamespace("parallel")
[10:30:55.143]                     if (exists("sendData", mode = "function", 
[10:30:55.143]                       envir = ns)) {
[10:30:55.143]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:55.143]                         envir = ns)
[10:30:55.143]                       envir <- sys.frame(frame)
[10:30:55.143]                       master <- NULL
[10:30:55.143]                       while (!identical(envir, .GlobalEnv) && 
[10:30:55.143]                         !identical(envir, emptyenv())) {
[10:30:55.143]                         if (exists("master", mode = "list", envir = envir, 
[10:30:55.143]                           inherits = FALSE)) {
[10:30:55.143]                           master <- get("master", mode = "list", 
[10:30:55.143]                             envir = envir, inherits = FALSE)
[10:30:55.143]                           if (inherits(master, c("SOCKnode", 
[10:30:55.143]                             "SOCK0node"))) {
[10:30:55.143]                             sendCondition <<- function(cond) {
[10:30:55.143]                               data <- list(type = "VALUE", value = cond, 
[10:30:55.143]                                 success = TRUE)
[10:30:55.143]                               parallel_sendData(master, data)
[10:30:55.143]                             }
[10:30:55.143]                             return(sendCondition)
[10:30:55.143]                           }
[10:30:55.143]                         }
[10:30:55.143]                         frame <- frame + 1L
[10:30:55.143]                         envir <- sys.frame(frame)
[10:30:55.143]                       }
[10:30:55.143]                     }
[10:30:55.143]                     sendCondition <<- function(cond) NULL
[10:30:55.143]                   }
[10:30:55.143]                 })
[10:30:55.143]                 withCallingHandlers({
[10:30:55.143]                   {
[10:30:55.143]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.143]                     if (!identical(...future.globals.maxSize.org, 
[10:30:55.143]                       ...future.globals.maxSize)) {
[10:30:55.143]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.143]                       on.exit(options(oopts), add = TRUE)
[10:30:55.143]                     }
[10:30:55.143]                     {
[10:30:55.143]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:55.143]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:30:55.143]                           envir = globalenv(), inherits = FALSE)
[10:30:55.143]                         ...future.FUN(...)
[10:30:55.143]                       }
[10:30:55.143]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:55.143]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:55.143]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:55.143]                         USE.NAMES = FALSE)
[10:30:55.143]                       do.call(mapply, args = args)
[10:30:55.143]                     }
[10:30:55.143]                   }
[10:30:55.143]                 }, immediateCondition = function(cond) {
[10:30:55.143]                   sendCondition <- ...future.makeSendCondition()
[10:30:55.143]                   sendCondition(cond)
[10:30:55.143]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.143]                   {
[10:30:55.143]                     inherits <- base::inherits
[10:30:55.143]                     invokeRestart <- base::invokeRestart
[10:30:55.143]                     is.null <- base::is.null
[10:30:55.143]                     muffled <- FALSE
[10:30:55.143]                     if (inherits(cond, "message")) {
[10:30:55.143]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:55.143]                       if (muffled) 
[10:30:55.143]                         invokeRestart("muffleMessage")
[10:30:55.143]                     }
[10:30:55.143]                     else if (inherits(cond, "warning")) {
[10:30:55.143]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:55.143]                       if (muffled) 
[10:30:55.143]                         invokeRestart("muffleWarning")
[10:30:55.143]                     }
[10:30:55.143]                     else if (inherits(cond, "condition")) {
[10:30:55.143]                       if (!is.null(pattern)) {
[10:30:55.143]                         computeRestarts <- base::computeRestarts
[10:30:55.143]                         grepl <- base::grepl
[10:30:55.143]                         restarts <- computeRestarts(cond)
[10:30:55.143]                         for (restart in restarts) {
[10:30:55.143]                           name <- restart$name
[10:30:55.143]                           if (is.null(name)) 
[10:30:55.143]                             next
[10:30:55.143]                           if (!grepl(pattern, name)) 
[10:30:55.143]                             next
[10:30:55.143]                           invokeRestart(restart)
[10:30:55.143]                           muffled <- TRUE
[10:30:55.143]                           break
[10:30:55.143]                         }
[10:30:55.143]                       }
[10:30:55.143]                     }
[10:30:55.143]                     invisible(muffled)
[10:30:55.143]                   }
[10:30:55.143]                   muffleCondition(cond)
[10:30:55.143]                 })
[10:30:55.143]             }))
[10:30:55.143]             future::FutureResult(value = ...future.value$value, 
[10:30:55.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.143]                   ...future.rng), globalenv = if (FALSE) 
[10:30:55.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:55.143]                     ...future.globalenv.names))
[10:30:55.143]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:55.143]         }, condition = base::local({
[10:30:55.143]             c <- base::c
[10:30:55.143]             inherits <- base::inherits
[10:30:55.143]             invokeRestart <- base::invokeRestart
[10:30:55.143]             length <- base::length
[10:30:55.143]             list <- base::list
[10:30:55.143]             seq.int <- base::seq.int
[10:30:55.143]             signalCondition <- base::signalCondition
[10:30:55.143]             sys.calls <- base::sys.calls
[10:30:55.143]             `[[` <- base::`[[`
[10:30:55.143]             `+` <- base::`+`
[10:30:55.143]             `<<-` <- base::`<<-`
[10:30:55.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:55.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:55.143]                   3L)]
[10:30:55.143]             }
[10:30:55.143]             function(cond) {
[10:30:55.143]                 is_error <- inherits(cond, "error")
[10:30:55.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:55.143]                   NULL)
[10:30:55.143]                 if (is_error) {
[10:30:55.143]                   sessionInformation <- function() {
[10:30:55.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:55.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:55.143]                       search = base::search(), system = base::Sys.info())
[10:30:55.143]                   }
[10:30:55.143]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:55.143]                     cond$call), session = sessionInformation(), 
[10:30:55.143]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:55.143]                   signalCondition(cond)
[10:30:55.143]                 }
[10:30:55.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:55.143]                 "immediateCondition"))) {
[10:30:55.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:55.143]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:55.143]                   if (TRUE && !signal) {
[10:30:55.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.143]                     {
[10:30:55.143]                       inherits <- base::inherits
[10:30:55.143]                       invokeRestart <- base::invokeRestart
[10:30:55.143]                       is.null <- base::is.null
[10:30:55.143]                       muffled <- FALSE
[10:30:55.143]                       if (inherits(cond, "message")) {
[10:30:55.143]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.143]                         if (muffled) 
[10:30:55.143]                           invokeRestart("muffleMessage")
[10:30:55.143]                       }
[10:30:55.143]                       else if (inherits(cond, "warning")) {
[10:30:55.143]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.143]                         if (muffled) 
[10:30:55.143]                           invokeRestart("muffleWarning")
[10:30:55.143]                       }
[10:30:55.143]                       else if (inherits(cond, "condition")) {
[10:30:55.143]                         if (!is.null(pattern)) {
[10:30:55.143]                           computeRestarts <- base::computeRestarts
[10:30:55.143]                           grepl <- base::grepl
[10:30:55.143]                           restarts <- computeRestarts(cond)
[10:30:55.143]                           for (restart in restarts) {
[10:30:55.143]                             name <- restart$name
[10:30:55.143]                             if (is.null(name)) 
[10:30:55.143]                               next
[10:30:55.143]                             if (!grepl(pattern, name)) 
[10:30:55.143]                               next
[10:30:55.143]                             invokeRestart(restart)
[10:30:55.143]                             muffled <- TRUE
[10:30:55.143]                             break
[10:30:55.143]                           }
[10:30:55.143]                         }
[10:30:55.143]                       }
[10:30:55.143]                       invisible(muffled)
[10:30:55.143]                     }
[10:30:55.143]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.143]                   }
[10:30:55.143]                 }
[10:30:55.143]                 else {
[10:30:55.143]                   if (TRUE) {
[10:30:55.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.143]                     {
[10:30:55.143]                       inherits <- base::inherits
[10:30:55.143]                       invokeRestart <- base::invokeRestart
[10:30:55.143]                       is.null <- base::is.null
[10:30:55.143]                       muffled <- FALSE
[10:30:55.143]                       if (inherits(cond, "message")) {
[10:30:55.143]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.143]                         if (muffled) 
[10:30:55.143]                           invokeRestart("muffleMessage")
[10:30:55.143]                       }
[10:30:55.143]                       else if (inherits(cond, "warning")) {
[10:30:55.143]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.143]                         if (muffled) 
[10:30:55.143]                           invokeRestart("muffleWarning")
[10:30:55.143]                       }
[10:30:55.143]                       else if (inherits(cond, "condition")) {
[10:30:55.143]                         if (!is.null(pattern)) {
[10:30:55.143]                           computeRestarts <- base::computeRestarts
[10:30:55.143]                           grepl <- base::grepl
[10:30:55.143]                           restarts <- computeRestarts(cond)
[10:30:55.143]                           for (restart in restarts) {
[10:30:55.143]                             name <- restart$name
[10:30:55.143]                             if (is.null(name)) 
[10:30:55.143]                               next
[10:30:55.143]                             if (!grepl(pattern, name)) 
[10:30:55.143]                               next
[10:30:55.143]                             invokeRestart(restart)
[10:30:55.143]                             muffled <- TRUE
[10:30:55.143]                             break
[10:30:55.143]                           }
[10:30:55.143]                         }
[10:30:55.143]                       }
[10:30:55.143]                       invisible(muffled)
[10:30:55.143]                     }
[10:30:55.143]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.143]                   }
[10:30:55.143]                 }
[10:30:55.143]             }
[10:30:55.143]         }))
[10:30:55.143]     }, error = function(ex) {
[10:30:55.143]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:55.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.143]                 ...future.rng), started = ...future.startTime, 
[10:30:55.143]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:55.143]             version = "1.8"), class = "FutureResult")
[10:30:55.143]     }, finally = {
[10:30:55.143]         if (!identical(...future.workdir, getwd())) 
[10:30:55.143]             setwd(...future.workdir)
[10:30:55.143]         {
[10:30:55.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:55.143]                 ...future.oldOptions$nwarnings <- NULL
[10:30:55.143]             }
[10:30:55.143]             base::options(...future.oldOptions)
[10:30:55.143]             if (.Platform$OS.type == "windows") {
[10:30:55.143]                 old_names <- names(...future.oldEnvVars)
[10:30:55.143]                 envs <- base::Sys.getenv()
[10:30:55.143]                 names <- names(envs)
[10:30:55.143]                 common <- intersect(names, old_names)
[10:30:55.143]                 added <- setdiff(names, old_names)
[10:30:55.143]                 removed <- setdiff(old_names, names)
[10:30:55.143]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:55.143]                   envs[common]]
[10:30:55.143]                 NAMES <- toupper(changed)
[10:30:55.143]                 args <- list()
[10:30:55.143]                 for (kk in seq_along(NAMES)) {
[10:30:55.143]                   name <- changed[[kk]]
[10:30:55.143]                   NAME <- NAMES[[kk]]
[10:30:55.143]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.143]                     next
[10:30:55.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.143]                 }
[10:30:55.143]                 NAMES <- toupper(added)
[10:30:55.143]                 for (kk in seq_along(NAMES)) {
[10:30:55.143]                   name <- added[[kk]]
[10:30:55.143]                   NAME <- NAMES[[kk]]
[10:30:55.143]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.143]                     next
[10:30:55.143]                   args[[name]] <- ""
[10:30:55.143]                 }
[10:30:55.143]                 NAMES <- toupper(removed)
[10:30:55.143]                 for (kk in seq_along(NAMES)) {
[10:30:55.143]                   name <- removed[[kk]]
[10:30:55.143]                   NAME <- NAMES[[kk]]
[10:30:55.143]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.143]                     next
[10:30:55.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.143]                 }
[10:30:55.143]                 if (length(args) > 0) 
[10:30:55.143]                   base::do.call(base::Sys.setenv, args = args)
[10:30:55.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:55.143]             }
[10:30:55.143]             else {
[10:30:55.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:55.143]             }
[10:30:55.143]             {
[10:30:55.143]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:55.143]                   0L) {
[10:30:55.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:55.143]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:55.143]                   base::options(opts)
[10:30:55.143]                 }
[10:30:55.143]                 {
[10:30:55.143]                   {
[10:30:55.143]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:55.143]                     NULL
[10:30:55.143]                   }
[10:30:55.143]                   options(future.plan = NULL)
[10:30:55.143]                   if (is.na(NA_character_)) 
[10:30:55.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:55.143]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:55.143]                     .init = FALSE)
[10:30:55.143]                 }
[10:30:55.143]             }
[10:30:55.143]         }
[10:30:55.143]     })
[10:30:55.143]     if (TRUE) {
[10:30:55.143]         base::sink(type = "output", split = FALSE)
[10:30:55.143]         if (TRUE) {
[10:30:55.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:55.143]         }
[10:30:55.143]         else {
[10:30:55.143]             ...future.result["stdout"] <- base::list(NULL)
[10:30:55.143]         }
[10:30:55.143]         base::close(...future.stdout)
[10:30:55.143]         ...future.stdout <- NULL
[10:30:55.143]     }
[10:30:55.143]     ...future.result$conditions <- ...future.conditions
[10:30:55.143]     ...future.result$finished <- base::Sys.time()
[10:30:55.143]     ...future.result
[10:30:55.143] }
[10:30:55.146] Exporting 5 global objects (2.47 KiB) to cluster node #2 ...
[10:30:55.146] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ...
[10:30:55.147] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ... DONE
[10:30:55.147] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[10:30:55.147] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[10:30:55.147] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[10:30:55.148] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[10:30:55.148] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ...
[10:30:55.148] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ... DONE
[10:30:55.149] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:55.149] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.149] Exporting 5 global objects (2.47 KiB) to cluster node #2 ... DONE
[10:30:55.150] MultisessionFuture started
[10:30:55.150] - Launch lazy future ... done
[10:30:55.150] run() for ‘MultisessionFuture’ ... done
[10:30:55.150] Created future:
[10:30:55.150] MultisessionFuture:
[10:30:55.150] Label: ‘future_mapply-2’
[10:30:55.150] Expression:
[10:30:55.150] {
[10:30:55.150]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.150]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:55.150]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.150]         on.exit(options(oopts), add = TRUE)
[10:30:55.150]     }
[10:30:55.150]     {
[10:30:55.150]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:30:55.150]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:30:55.150]                 inherits = FALSE)
[10:30:55.150]             ...future.FUN(...)
[10:30:55.150]         }
[10:30:55.150]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:30:55.150]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:30:55.150]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:55.150]         do.call(mapply, args = args)
[10:30:55.150]     }
[10:30:55.150] }
[10:30:55.150] Lazy evaluation: FALSE
[10:30:55.150] Asynchronous evaluation: TRUE
[10:30:55.150] Local evaluation: TRUE
[10:30:55.150] Environment: R_GlobalEnv
[10:30:55.150] Capture standard output: TRUE
[10:30:55.150] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:55.150] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:55.150] Packages: 1 packages (‘stats’)
[10:30:55.150] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:30:55.150] Resolved: FALSE
[10:30:55.150] Value: <not collected>
[10:30:55.150] Conditions captured: <none>
[10:30:55.150] Early signaling: FALSE
[10:30:55.150] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:55.150] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.162] Chunk #2 of 2 ... DONE
[10:30:55.162] Launching 2 futures (chunks) ... DONE
[10:30:55.162] Resolving 2 futures (chunks) ...
[10:30:55.162] resolve() on list ...
[10:30:55.162]  recursive: 0
[10:30:55.162]  length: 2
[10:30:55.162] 
[10:30:55.163] receiveMessageFromWorker() for ClusterFuture ...
[10:30:55.163] - Validating connection of MultisessionFuture
[10:30:55.163] - received message: FutureResult
[10:30:55.163] - Received FutureResult
[10:30:55.163] - Erased future from FutureRegistry
[10:30:55.164] result() for ClusterFuture ...
[10:30:55.164] - result already collected: FutureResult
[10:30:55.164] result() for ClusterFuture ... done
[10:30:55.164] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:55.164] Future #1
[10:30:55.164] result() for ClusterFuture ...
[10:30:55.164] - result already collected: FutureResult
[10:30:55.164] result() for ClusterFuture ... done
[10:30:55.164] result() for ClusterFuture ...
[10:30:55.164] - result already collected: FutureResult
[10:30:55.164] result() for ClusterFuture ... done
[10:30:55.165] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:55.165] - nx: 2
[10:30:55.165] - relay: TRUE
[10:30:55.165] - stdout: TRUE
[10:30:55.165] - signal: TRUE
[10:30:55.165] - resignal: FALSE
[10:30:55.165] - force: TRUE
[10:30:55.165] - relayed: [n=2] FALSE, FALSE
[10:30:55.165] - queued futures: [n=2] FALSE, FALSE
[10:30:55.165]  - until=1
[10:30:55.165]  - relaying element #1
[10:30:55.165] result() for ClusterFuture ...
[10:30:55.166] - result already collected: FutureResult
[10:30:55.166] result() for ClusterFuture ... done
[10:30:55.166] result() for ClusterFuture ...
[10:30:55.166] - result already collected: FutureResult
[10:30:55.166] result() for ClusterFuture ... done
[10:30:55.166] result() for ClusterFuture ...
[10:30:55.166] - result already collected: FutureResult
[10:30:55.166] result() for ClusterFuture ... done
[10:30:55.166] result() for ClusterFuture ...
[10:30:55.166] - result already collected: FutureResult
[10:30:55.166] result() for ClusterFuture ... done
[10:30:55.167] - relayed: [n=2] TRUE, FALSE
[10:30:55.167] - queued futures: [n=2] TRUE, FALSE
[10:30:55.167] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:55.167]  length: 1 (resolved future 1)
[10:30:55.195] receiveMessageFromWorker() for ClusterFuture ...
[10:30:55.195] - Validating connection of MultisessionFuture
[10:30:55.195] - received message: FutureResult
[10:30:55.195] - Received FutureResult
[10:30:55.195] - Erased future from FutureRegistry
[10:30:55.196] result() for ClusterFuture ...
[10:30:55.196] - result already collected: FutureResult
[10:30:55.196] result() for ClusterFuture ... done
[10:30:55.196] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:55.196] Future #2
[10:30:55.196] result() for ClusterFuture ...
[10:30:55.196] - result already collected: FutureResult
[10:30:55.196] result() for ClusterFuture ... done
[10:30:55.196] result() for ClusterFuture ...
[10:30:55.196] - result already collected: FutureResult
[10:30:55.196] result() for ClusterFuture ... done
[10:30:55.197] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:55.197] - nx: 2
[10:30:55.197] - relay: TRUE
[10:30:55.197] - stdout: TRUE
[10:30:55.197] - signal: TRUE
[10:30:55.197] - resignal: FALSE
[10:30:55.197] - force: TRUE
[10:30:55.197] - relayed: [n=2] TRUE, FALSE
[10:30:55.197] - queued futures: [n=2] TRUE, FALSE
[10:30:55.197]  - until=2
[10:30:55.197]  - relaying element #2
[10:30:55.198] result() for ClusterFuture ...
[10:30:55.198] - result already collected: FutureResult
[10:30:55.198] result() for ClusterFuture ... done
[10:30:55.198] result() for ClusterFuture ...
[10:30:55.198] - result already collected: FutureResult
[10:30:55.198] result() for ClusterFuture ... done
[10:30:55.198] result() for ClusterFuture ...
[10:30:55.198] - result already collected: FutureResult
[10:30:55.198] result() for ClusterFuture ... done
[10:30:55.198] result() for ClusterFuture ...
[10:30:55.198] - result already collected: FutureResult
[10:30:55.199] result() for ClusterFuture ... done
[10:30:55.199] - relayed: [n=2] TRUE, TRUE
[10:30:55.199] - queued futures: [n=2] TRUE, TRUE
[10:30:55.199] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:55.199]  length: 0 (resolved future 2)
[10:30:55.199] Relaying remaining futures
[10:30:55.199] signalConditionsASAP(NULL, pos=0) ...
[10:30:55.199] - nx: 2
[10:30:55.199] - relay: TRUE
[10:30:55.199] - stdout: TRUE
[10:30:55.199] - signal: TRUE
[10:30:55.199] - resignal: FALSE
[10:30:55.200] - force: TRUE
[10:30:55.200] - relayed: [n=2] TRUE, TRUE
[10:30:55.200] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:55.200] - relayed: [n=2] TRUE, TRUE
[10:30:55.200] - queued futures: [n=2] TRUE, TRUE
[10:30:55.200] signalConditionsASAP(NULL, pos=0) ... done
[10:30:55.200] resolve() on list ... DONE
[10:30:55.200] result() for ClusterFuture ...
[10:30:55.200] - result already collected: FutureResult
[10:30:55.200] result() for ClusterFuture ... done
[10:30:55.200] result() for ClusterFuture ...
[10:30:55.201] - result already collected: FutureResult
[10:30:55.201] result() for ClusterFuture ... done
[10:30:55.201] result() for ClusterFuture ...
[10:30:55.201] - result already collected: FutureResult
[10:30:55.201] result() for ClusterFuture ... done
[10:30:55.201] result() for ClusterFuture ...
[10:30:55.201] - result already collected: FutureResult
[10:30:55.201] result() for ClusterFuture ... done
[10:30:55.201]  - Number of value chunks collected: 2
[10:30:55.201] Resolving 2 futures (chunks) ... DONE
[10:30:55.201] Reducing values from 2 chunks ...
[10:30:55.202]  - Number of values collected after concatenation: 4
[10:30:55.202]  - Number of values expected: 4
[10:30:55.202] Reducing values from 2 chunks ... DONE
[10:30:55.202] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[10:30:55.202] future_mapply() ...
[10:30:55.206] Number of chunks: 2
[10:30:55.206] getGlobalsAndPackagesXApply() ...
[10:30:55.207]  - future.globals: TRUE
[10:30:55.207] getGlobalsAndPackages() ...
[10:30:55.207] Searching for globals...
[10:30:55.208] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:30:55.208] Searching for globals ... DONE
[10:30:55.208] Resolving globals: FALSE
[10:30:55.208] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[10:30:55.209] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[10:30:55.209] - globals: [1] ‘FUN’
[10:30:55.209] - packages: [1] ‘stats’
[10:30:55.209] getGlobalsAndPackages() ... DONE
[10:30:55.209]  - globals found/used: [n=1] ‘FUN’
[10:30:55.209]  - needed namespaces: [n=1] ‘stats’
[10:30:55.209] Finding globals ... DONE
[10:30:55.210] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:55.210] List of 2
[10:30:55.210]  $ ...future.FUN:function (x, w, ...)  
[10:30:55.210]  $ MoreArgs     : NULL
[10:30:55.210]  - attr(*, "where")=List of 2
[10:30:55.210]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:55.210]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:55.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:55.210]  - attr(*, "resolved")= logi FALSE
[10:30:55.210]  - attr(*, "total_size")= num NA
[10:30:55.212] Packages to be attached in all futures: [n=1] ‘stats’
[10:30:55.212] getGlobalsAndPackagesXApply() ... DONE
[10:30:55.213] Number of futures (= number of chunks): 2
[10:30:55.213] Launching 2 futures (chunks) ...
[10:30:55.213] Chunk #1 of 2 ...
[10:30:55.213]  - Finding globals in '...' for chunk #1 ...
[10:30:55.213] getGlobalsAndPackages() ...
[10:30:55.213] Searching for globals...
[10:30:55.213] 
[10:30:55.214] Searching for globals ... DONE
[10:30:55.214] - globals: [0] <none>
[10:30:55.214] getGlobalsAndPackages() ... DONE
[10:30:55.214]    + additional globals found: [n=0] 
[10:30:55.214]    + additional namespaces needed: [n=0] 
[10:30:55.214]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:55.214]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:55.214]  - seeds: <none>
[10:30:55.214]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.214] getGlobalsAndPackages() ...
[10:30:55.214] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.215] Resolving globals: FALSE
[10:30:55.215] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[10:30:55.215] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:55.216] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.216] - packages: [1] ‘stats’
[10:30:55.216] getGlobalsAndPackages() ... DONE
[10:30:55.216] run() for ‘Future’ ...
[10:30:55.216] - state: ‘created’
[10:30:55.216] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:55.230] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.230] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:55.231]   - Field: ‘node’
[10:30:55.231]   - Field: ‘label’
[10:30:55.231]   - Field: ‘local’
[10:30:55.231]   - Field: ‘owner’
[10:30:55.231]   - Field: ‘envir’
[10:30:55.231]   - Field: ‘workers’
[10:30:55.231]   - Field: ‘packages’
[10:30:55.231]   - Field: ‘gc’
[10:30:55.231]   - Field: ‘conditions’
[10:30:55.231]   - Field: ‘persistent’
[10:30:55.232]   - Field: ‘expr’
[10:30:55.232]   - Field: ‘uuid’
[10:30:55.232]   - Field: ‘seed’
[10:30:55.232]   - Field: ‘version’
[10:30:55.232]   - Field: ‘result’
[10:30:55.232]   - Field: ‘asynchronous’
[10:30:55.232]   - Field: ‘calls’
[10:30:55.232]   - Field: ‘globals’
[10:30:55.232]   - Field: ‘stdout’
[10:30:55.232]   - Field: ‘earlySignal’
[10:30:55.232]   - Field: ‘lazy’
[10:30:55.233]   - Field: ‘state’
[10:30:55.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:55.233] - Launch lazy future ...
[10:30:55.233] Packages needed by the future expression (n = 1): ‘stats’
[10:30:55.233] Packages needed by future strategies (n = 0): <none>
[10:30:55.234] {
[10:30:55.234]     {
[10:30:55.234]         {
[10:30:55.234]             ...future.startTime <- base::Sys.time()
[10:30:55.234]             {
[10:30:55.234]                 {
[10:30:55.234]                   {
[10:30:55.234]                     {
[10:30:55.234]                       {
[10:30:55.234]                         base::local({
[10:30:55.234]                           has_future <- base::requireNamespace("future", 
[10:30:55.234]                             quietly = TRUE)
[10:30:55.234]                           if (has_future) {
[10:30:55.234]                             ns <- base::getNamespace("future")
[10:30:55.234]                             version <- ns[[".package"]][["version"]]
[10:30:55.234]                             if (is.null(version)) 
[10:30:55.234]                               version <- utils::packageVersion("future")
[10:30:55.234]                           }
[10:30:55.234]                           else {
[10:30:55.234]                             version <- NULL
[10:30:55.234]                           }
[10:30:55.234]                           if (!has_future || version < "1.8.0") {
[10:30:55.234]                             info <- base::c(r_version = base::gsub("R version ", 
[10:30:55.234]                               "", base::R.version$version.string), 
[10:30:55.234]                               platform = base::sprintf("%s (%s-bit)", 
[10:30:55.234]                                 base::R.version$platform, 8 * 
[10:30:55.234]                                   base::.Machine$sizeof.pointer), 
[10:30:55.234]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:55.234]                                 "release", "version")], collapse = " "), 
[10:30:55.234]                               hostname = base::Sys.info()[["nodename"]])
[10:30:55.234]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:30:55.234]                               info)
[10:30:55.234]                             info <- base::paste(info, collapse = "; ")
[10:30:55.234]                             if (!has_future) {
[10:30:55.234]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:55.234]                                 info)
[10:30:55.234]                             }
[10:30:55.234]                             else {
[10:30:55.234]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:55.234]                                 info, version)
[10:30:55.234]                             }
[10:30:55.234]                             base::stop(msg)
[10:30:55.234]                           }
[10:30:55.234]                         })
[10:30:55.234]                       }
[10:30:55.234]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:55.234]                       base::options(mc.cores = 1L)
[10:30:55.234]                     }
[10:30:55.234]                     base::local({
[10:30:55.234]                       for (pkg in "stats") {
[10:30:55.234]                         base::loadNamespace(pkg)
[10:30:55.234]                         base::library(pkg, character.only = TRUE)
[10:30:55.234]                       }
[10:30:55.234]                     })
[10:30:55.234]                   }
[10:30:55.234]                   ...future.strategy.old <- future::plan("list")
[10:30:55.234]                   options(future.plan = NULL)
[10:30:55.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:55.234]                 }
[10:30:55.234]                 ...future.workdir <- getwd()
[10:30:55.234]             }
[10:30:55.234]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:55.234]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:55.234]         }
[10:30:55.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:55.234]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:55.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:55.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:55.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:55.234]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:55.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:55.234]             base::names(...future.oldOptions))
[10:30:55.234]     }
[10:30:55.234]     if (FALSE) {
[10:30:55.234]     }
[10:30:55.234]     else {
[10:30:55.234]         if (TRUE) {
[10:30:55.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:55.234]                 open = "w")
[10:30:55.234]         }
[10:30:55.234]         else {
[10:30:55.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:55.234]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:55.234]         }
[10:30:55.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:55.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:55.234]             base::sink(type = "output", split = FALSE)
[10:30:55.234]             base::close(...future.stdout)
[10:30:55.234]         }, add = TRUE)
[10:30:55.234]     }
[10:30:55.234]     ...future.frame <- base::sys.nframe()
[10:30:55.234]     ...future.conditions <- base::list()
[10:30:55.234]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:55.234]     if (FALSE) {
[10:30:55.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:55.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:55.234]     }
[10:30:55.234]     ...future.result <- base::tryCatch({
[10:30:55.234]         base::withCallingHandlers({
[10:30:55.234]             ...future.value <- base::withVisible(base::local({
[10:30:55.234]                 ...future.makeSendCondition <- base::local({
[10:30:55.234]                   sendCondition <- NULL
[10:30:55.234]                   function(frame = 1L) {
[10:30:55.234]                     if (is.function(sendCondition)) 
[10:30:55.234]                       return(sendCondition)
[10:30:55.234]                     ns <- getNamespace("parallel")
[10:30:55.234]                     if (exists("sendData", mode = "function", 
[10:30:55.234]                       envir = ns)) {
[10:30:55.234]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:55.234]                         envir = ns)
[10:30:55.234]                       envir <- sys.frame(frame)
[10:30:55.234]                       master <- NULL
[10:30:55.234]                       while (!identical(envir, .GlobalEnv) && 
[10:30:55.234]                         !identical(envir, emptyenv())) {
[10:30:55.234]                         if (exists("master", mode = "list", envir = envir, 
[10:30:55.234]                           inherits = FALSE)) {
[10:30:55.234]                           master <- get("master", mode = "list", 
[10:30:55.234]                             envir = envir, inherits = FALSE)
[10:30:55.234]                           if (inherits(master, c("SOCKnode", 
[10:30:55.234]                             "SOCK0node"))) {
[10:30:55.234]                             sendCondition <<- function(cond) {
[10:30:55.234]                               data <- list(type = "VALUE", value = cond, 
[10:30:55.234]                                 success = TRUE)
[10:30:55.234]                               parallel_sendData(master, data)
[10:30:55.234]                             }
[10:30:55.234]                             return(sendCondition)
[10:30:55.234]                           }
[10:30:55.234]                         }
[10:30:55.234]                         frame <- frame + 1L
[10:30:55.234]                         envir <- sys.frame(frame)
[10:30:55.234]                       }
[10:30:55.234]                     }
[10:30:55.234]                     sendCondition <<- function(cond) NULL
[10:30:55.234]                   }
[10:30:55.234]                 })
[10:30:55.234]                 withCallingHandlers({
[10:30:55.234]                   {
[10:30:55.234]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.234]                     if (!identical(...future.globals.maxSize.org, 
[10:30:55.234]                       ...future.globals.maxSize)) {
[10:30:55.234]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.234]                       on.exit(options(oopts), add = TRUE)
[10:30:55.234]                     }
[10:30:55.234]                     {
[10:30:55.234]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.234]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:55.234]                         USE.NAMES = FALSE)
[10:30:55.234]                       do.call(mapply, args = args)
[10:30:55.234]                     }
[10:30:55.234]                   }
[10:30:55.234]                 }, immediateCondition = function(cond) {
[10:30:55.234]                   sendCondition <- ...future.makeSendCondition()
[10:30:55.234]                   sendCondition(cond)
[10:30:55.234]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.234]                   {
[10:30:55.234]                     inherits <- base::inherits
[10:30:55.234]                     invokeRestart <- base::invokeRestart
[10:30:55.234]                     is.null <- base::is.null
[10:30:55.234]                     muffled <- FALSE
[10:30:55.234]                     if (inherits(cond, "message")) {
[10:30:55.234]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:55.234]                       if (muffled) 
[10:30:55.234]                         invokeRestart("muffleMessage")
[10:30:55.234]                     }
[10:30:55.234]                     else if (inherits(cond, "warning")) {
[10:30:55.234]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:55.234]                       if (muffled) 
[10:30:55.234]                         invokeRestart("muffleWarning")
[10:30:55.234]                     }
[10:30:55.234]                     else if (inherits(cond, "condition")) {
[10:30:55.234]                       if (!is.null(pattern)) {
[10:30:55.234]                         computeRestarts <- base::computeRestarts
[10:30:55.234]                         grepl <- base::grepl
[10:30:55.234]                         restarts <- computeRestarts(cond)
[10:30:55.234]                         for (restart in restarts) {
[10:30:55.234]                           name <- restart$name
[10:30:55.234]                           if (is.null(name)) 
[10:30:55.234]                             next
[10:30:55.234]                           if (!grepl(pattern, name)) 
[10:30:55.234]                             next
[10:30:55.234]                           invokeRestart(restart)
[10:30:55.234]                           muffled <- TRUE
[10:30:55.234]                           break
[10:30:55.234]                         }
[10:30:55.234]                       }
[10:30:55.234]                     }
[10:30:55.234]                     invisible(muffled)
[10:30:55.234]                   }
[10:30:55.234]                   muffleCondition(cond)
[10:30:55.234]                 })
[10:30:55.234]             }))
[10:30:55.234]             future::FutureResult(value = ...future.value$value, 
[10:30:55.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.234]                   ...future.rng), globalenv = if (FALSE) 
[10:30:55.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:55.234]                     ...future.globalenv.names))
[10:30:55.234]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:55.234]         }, condition = base::local({
[10:30:55.234]             c <- base::c
[10:30:55.234]             inherits <- base::inherits
[10:30:55.234]             invokeRestart <- base::invokeRestart
[10:30:55.234]             length <- base::length
[10:30:55.234]             list <- base::list
[10:30:55.234]             seq.int <- base::seq.int
[10:30:55.234]             signalCondition <- base::signalCondition
[10:30:55.234]             sys.calls <- base::sys.calls
[10:30:55.234]             `[[` <- base::`[[`
[10:30:55.234]             `+` <- base::`+`
[10:30:55.234]             `<<-` <- base::`<<-`
[10:30:55.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:55.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:55.234]                   3L)]
[10:30:55.234]             }
[10:30:55.234]             function(cond) {
[10:30:55.234]                 is_error <- inherits(cond, "error")
[10:30:55.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:55.234]                   NULL)
[10:30:55.234]                 if (is_error) {
[10:30:55.234]                   sessionInformation <- function() {
[10:30:55.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:55.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:55.234]                       search = base::search(), system = base::Sys.info())
[10:30:55.234]                   }
[10:30:55.234]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:55.234]                     cond$call), session = sessionInformation(), 
[10:30:55.234]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:55.234]                   signalCondition(cond)
[10:30:55.234]                 }
[10:30:55.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:55.234]                 "immediateCondition"))) {
[10:30:55.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:55.234]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:55.234]                   if (TRUE && !signal) {
[10:30:55.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.234]                     {
[10:30:55.234]                       inherits <- base::inherits
[10:30:55.234]                       invokeRestart <- base::invokeRestart
[10:30:55.234]                       is.null <- base::is.null
[10:30:55.234]                       muffled <- FALSE
[10:30:55.234]                       if (inherits(cond, "message")) {
[10:30:55.234]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.234]                         if (muffled) 
[10:30:55.234]                           invokeRestart("muffleMessage")
[10:30:55.234]                       }
[10:30:55.234]                       else if (inherits(cond, "warning")) {
[10:30:55.234]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.234]                         if (muffled) 
[10:30:55.234]                           invokeRestart("muffleWarning")
[10:30:55.234]                       }
[10:30:55.234]                       else if (inherits(cond, "condition")) {
[10:30:55.234]                         if (!is.null(pattern)) {
[10:30:55.234]                           computeRestarts <- base::computeRestarts
[10:30:55.234]                           grepl <- base::grepl
[10:30:55.234]                           restarts <- computeRestarts(cond)
[10:30:55.234]                           for (restart in restarts) {
[10:30:55.234]                             name <- restart$name
[10:30:55.234]                             if (is.null(name)) 
[10:30:55.234]                               next
[10:30:55.234]                             if (!grepl(pattern, name)) 
[10:30:55.234]                               next
[10:30:55.234]                             invokeRestart(restart)
[10:30:55.234]                             muffled <- TRUE
[10:30:55.234]                             break
[10:30:55.234]                           }
[10:30:55.234]                         }
[10:30:55.234]                       }
[10:30:55.234]                       invisible(muffled)
[10:30:55.234]                     }
[10:30:55.234]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.234]                   }
[10:30:55.234]                 }
[10:30:55.234]                 else {
[10:30:55.234]                   if (TRUE) {
[10:30:55.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.234]                     {
[10:30:55.234]                       inherits <- base::inherits
[10:30:55.234]                       invokeRestart <- base::invokeRestart
[10:30:55.234]                       is.null <- base::is.null
[10:30:55.234]                       muffled <- FALSE
[10:30:55.234]                       if (inherits(cond, "message")) {
[10:30:55.234]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.234]                         if (muffled) 
[10:30:55.234]                           invokeRestart("muffleMessage")
[10:30:55.234]                       }
[10:30:55.234]                       else if (inherits(cond, "warning")) {
[10:30:55.234]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.234]                         if (muffled) 
[10:30:55.234]                           invokeRestart("muffleWarning")
[10:30:55.234]                       }
[10:30:55.234]                       else if (inherits(cond, "condition")) {
[10:30:55.234]                         if (!is.null(pattern)) {
[10:30:55.234]                           computeRestarts <- base::computeRestarts
[10:30:55.234]                           grepl <- base::grepl
[10:30:55.234]                           restarts <- computeRestarts(cond)
[10:30:55.234]                           for (restart in restarts) {
[10:30:55.234]                             name <- restart$name
[10:30:55.234]                             if (is.null(name)) 
[10:30:55.234]                               next
[10:30:55.234]                             if (!grepl(pattern, name)) 
[10:30:55.234]                               next
[10:30:55.234]                             invokeRestart(restart)
[10:30:55.234]                             muffled <- TRUE
[10:30:55.234]                             break
[10:30:55.234]                           }
[10:30:55.234]                         }
[10:30:55.234]                       }
[10:30:55.234]                       invisible(muffled)
[10:30:55.234]                     }
[10:30:55.234]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.234]                   }
[10:30:55.234]                 }
[10:30:55.234]             }
[10:30:55.234]         }))
[10:30:55.234]     }, error = function(ex) {
[10:30:55.234]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:55.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.234]                 ...future.rng), started = ...future.startTime, 
[10:30:55.234]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:55.234]             version = "1.8"), class = "FutureResult")
[10:30:55.234]     }, finally = {
[10:30:55.234]         if (!identical(...future.workdir, getwd())) 
[10:30:55.234]             setwd(...future.workdir)
[10:30:55.234]         {
[10:30:55.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:55.234]                 ...future.oldOptions$nwarnings <- NULL
[10:30:55.234]             }
[10:30:55.234]             base::options(...future.oldOptions)
[10:30:55.234]             if (.Platform$OS.type == "windows") {
[10:30:55.234]                 old_names <- names(...future.oldEnvVars)
[10:30:55.234]                 envs <- base::Sys.getenv()
[10:30:55.234]                 names <- names(envs)
[10:30:55.234]                 common <- intersect(names, old_names)
[10:30:55.234]                 added <- setdiff(names, old_names)
[10:30:55.234]                 removed <- setdiff(old_names, names)
[10:30:55.234]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:55.234]                   envs[common]]
[10:30:55.234]                 NAMES <- toupper(changed)
[10:30:55.234]                 args <- list()
[10:30:55.234]                 for (kk in seq_along(NAMES)) {
[10:30:55.234]                   name <- changed[[kk]]
[10:30:55.234]                   NAME <- NAMES[[kk]]
[10:30:55.234]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.234]                     next
[10:30:55.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.234]                 }
[10:30:55.234]                 NAMES <- toupper(added)
[10:30:55.234]                 for (kk in seq_along(NAMES)) {
[10:30:55.234]                   name <- added[[kk]]
[10:30:55.234]                   NAME <- NAMES[[kk]]
[10:30:55.234]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.234]                     next
[10:30:55.234]                   args[[name]] <- ""
[10:30:55.234]                 }
[10:30:55.234]                 NAMES <- toupper(removed)
[10:30:55.234]                 for (kk in seq_along(NAMES)) {
[10:30:55.234]                   name <- removed[[kk]]
[10:30:55.234]                   NAME <- NAMES[[kk]]
[10:30:55.234]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.234]                     next
[10:30:55.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.234]                 }
[10:30:55.234]                 if (length(args) > 0) 
[10:30:55.234]                   base::do.call(base::Sys.setenv, args = args)
[10:30:55.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:55.234]             }
[10:30:55.234]             else {
[10:30:55.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:55.234]             }
[10:30:55.234]             {
[10:30:55.234]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:55.234]                   0L) {
[10:30:55.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:55.234]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:55.234]                   base::options(opts)
[10:30:55.234]                 }
[10:30:55.234]                 {
[10:30:55.234]                   {
[10:30:55.234]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:55.234]                     NULL
[10:30:55.234]                   }
[10:30:55.234]                   options(future.plan = NULL)
[10:30:55.234]                   if (is.na(NA_character_)) 
[10:30:55.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:55.234]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:55.234]                     .init = FALSE)
[10:30:55.234]                 }
[10:30:55.234]             }
[10:30:55.234]         }
[10:30:55.234]     })
[10:30:55.234]     if (TRUE) {
[10:30:55.234]         base::sink(type = "output", split = FALSE)
[10:30:55.234]         if (TRUE) {
[10:30:55.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:55.234]         }
[10:30:55.234]         else {
[10:30:55.234]             ...future.result["stdout"] <- base::list(NULL)
[10:30:55.234]         }
[10:30:55.234]         base::close(...future.stdout)
[10:30:55.234]         ...future.stdout <- NULL
[10:30:55.234]     }
[10:30:55.234]     ...future.result$conditions <- ...future.conditions
[10:30:55.234]     ...future.result$finished <- base::Sys.time()
[10:30:55.234]     ...future.result
[10:30:55.234] }
[10:30:55.237] Exporting 5 global objects (2.07 KiB) to cluster node #1 ...
[10:30:55.237] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ...
[10:30:55.237] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ... DONE
[10:30:55.238] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:55.238] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:55.238] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ...
[10:30:55.238] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ... DONE
[10:30:55.239] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:55.239] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:55.239] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:55.239] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:55.239] Exporting 5 global objects (2.07 KiB) to cluster node #1 ... DONE
[10:30:55.240] MultisessionFuture started
[10:30:55.240] - Launch lazy future ... done
[10:30:55.240] run() for ‘MultisessionFuture’ ... done
[10:30:55.240] Created future:
[10:30:55.240] MultisessionFuture:
[10:30:55.240] Label: ‘future_Map-1’
[10:30:55.240] Expression:
[10:30:55.240] {
[10:30:55.240]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.240]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:55.240]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.240]         on.exit(options(oopts), add = TRUE)
[10:30:55.240]     }
[10:30:55.240]     {
[10:30:55.240]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.240]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:55.240]         do.call(mapply, args = args)
[10:30:55.240]     }
[10:30:55.240] }
[10:30:55.240] Lazy evaluation: FALSE
[10:30:55.240] Asynchronous evaluation: TRUE
[10:30:55.240] Local evaluation: TRUE
[10:30:55.240] Environment: R_GlobalEnv
[10:30:55.240] Capture standard output: TRUE
[10:30:55.240] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:55.240] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:55.240] Packages: 1 packages (‘stats’)
[10:30:55.240] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:55.240] Resolved: FALSE
[10:30:55.240] Value: <not collected>
[10:30:55.240] Conditions captured: <none>
[10:30:55.240] Early signaling: FALSE
[10:30:55.240] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:55.240] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.252] Chunk #1 of 2 ... DONE
[10:30:55.252] Chunk #2 of 2 ...
[10:30:55.252]  - Finding globals in '...' for chunk #2 ...
[10:30:55.252] getGlobalsAndPackages() ...
[10:30:55.252] Searching for globals...
[10:30:55.253] 
[10:30:55.253] Searching for globals ... DONE
[10:30:55.253] - globals: [0] <none>
[10:30:55.253] getGlobalsAndPackages() ... DONE
[10:30:55.253]    + additional globals found: [n=0] 
[10:30:55.253]    + additional namespaces needed: [n=0] 
[10:30:55.253]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:55.253]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:55.253]  - seeds: <none>
[10:30:55.254]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.254] getGlobalsAndPackages() ...
[10:30:55.254] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.254] Resolving globals: FALSE
[10:30:55.254] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[10:30:55.255] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:55.255] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.255] - packages: [1] ‘stats’
[10:30:55.255] getGlobalsAndPackages() ... DONE
[10:30:55.255] run() for ‘Future’ ...
[10:30:55.256] - state: ‘created’
[10:30:55.256] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:55.270] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.270] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:55.270]   - Field: ‘node’
[10:30:55.270]   - Field: ‘label’
[10:30:55.270]   - Field: ‘local’
[10:30:55.270]   - Field: ‘owner’
[10:30:55.270]   - Field: ‘envir’
[10:30:55.270]   - Field: ‘workers’
[10:30:55.270]   - Field: ‘packages’
[10:30:55.271]   - Field: ‘gc’
[10:30:55.271]   - Field: ‘conditions’
[10:30:55.271]   - Field: ‘persistent’
[10:30:55.271]   - Field: ‘expr’
[10:30:55.271]   - Field: ‘uuid’
[10:30:55.271]   - Field: ‘seed’
[10:30:55.271]   - Field: ‘version’
[10:30:55.271]   - Field: ‘result’
[10:30:55.271]   - Field: ‘asynchronous’
[10:30:55.271]   - Field: ‘calls’
[10:30:55.271]   - Field: ‘globals’
[10:30:55.272]   - Field: ‘stdout’
[10:30:55.272]   - Field: ‘earlySignal’
[10:30:55.272]   - Field: ‘lazy’
[10:30:55.272]   - Field: ‘state’
[10:30:55.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:55.272] - Launch lazy future ...
[10:30:55.272] Packages needed by the future expression (n = 1): ‘stats’
[10:30:55.272] Packages needed by future strategies (n = 0): <none>
[10:30:55.273] {
[10:30:55.273]     {
[10:30:55.273]         {
[10:30:55.273]             ...future.startTime <- base::Sys.time()
[10:30:55.273]             {
[10:30:55.273]                 {
[10:30:55.273]                   {
[10:30:55.273]                     {
[10:30:55.273]                       {
[10:30:55.273]                         base::local({
[10:30:55.273]                           has_future <- base::requireNamespace("future", 
[10:30:55.273]                             quietly = TRUE)
[10:30:55.273]                           if (has_future) {
[10:30:55.273]                             ns <- base::getNamespace("future")
[10:30:55.273]                             version <- ns[[".package"]][["version"]]
[10:30:55.273]                             if (is.null(version)) 
[10:30:55.273]                               version <- utils::packageVersion("future")
[10:30:55.273]                           }
[10:30:55.273]                           else {
[10:30:55.273]                             version <- NULL
[10:30:55.273]                           }
[10:30:55.273]                           if (!has_future || version < "1.8.0") {
[10:30:55.273]                             info <- base::c(r_version = base::gsub("R version ", 
[10:30:55.273]                               "", base::R.version$version.string), 
[10:30:55.273]                               platform = base::sprintf("%s (%s-bit)", 
[10:30:55.273]                                 base::R.version$platform, 8 * 
[10:30:55.273]                                   base::.Machine$sizeof.pointer), 
[10:30:55.273]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:55.273]                                 "release", "version")], collapse = " "), 
[10:30:55.273]                               hostname = base::Sys.info()[["nodename"]])
[10:30:55.273]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:30:55.273]                               info)
[10:30:55.273]                             info <- base::paste(info, collapse = "; ")
[10:30:55.273]                             if (!has_future) {
[10:30:55.273]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:55.273]                                 info)
[10:30:55.273]                             }
[10:30:55.273]                             else {
[10:30:55.273]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:55.273]                                 info, version)
[10:30:55.273]                             }
[10:30:55.273]                             base::stop(msg)
[10:30:55.273]                           }
[10:30:55.273]                         })
[10:30:55.273]                       }
[10:30:55.273]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:55.273]                       base::options(mc.cores = 1L)
[10:30:55.273]                     }
[10:30:55.273]                     base::local({
[10:30:55.273]                       for (pkg in "stats") {
[10:30:55.273]                         base::loadNamespace(pkg)
[10:30:55.273]                         base::library(pkg, character.only = TRUE)
[10:30:55.273]                       }
[10:30:55.273]                     })
[10:30:55.273]                   }
[10:30:55.273]                   ...future.strategy.old <- future::plan("list")
[10:30:55.273]                   options(future.plan = NULL)
[10:30:55.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:55.273]                 }
[10:30:55.273]                 ...future.workdir <- getwd()
[10:30:55.273]             }
[10:30:55.273]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:55.273]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:55.273]         }
[10:30:55.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:55.273]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:55.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:55.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:55.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:55.273]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:55.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:55.273]             base::names(...future.oldOptions))
[10:30:55.273]     }
[10:30:55.273]     if (FALSE) {
[10:30:55.273]     }
[10:30:55.273]     else {
[10:30:55.273]         if (TRUE) {
[10:30:55.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:55.273]                 open = "w")
[10:30:55.273]         }
[10:30:55.273]         else {
[10:30:55.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:55.273]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:55.273]         }
[10:30:55.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:55.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:55.273]             base::sink(type = "output", split = FALSE)
[10:30:55.273]             base::close(...future.stdout)
[10:30:55.273]         }, add = TRUE)
[10:30:55.273]     }
[10:30:55.273]     ...future.frame <- base::sys.nframe()
[10:30:55.273]     ...future.conditions <- base::list()
[10:30:55.273]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:55.273]     if (FALSE) {
[10:30:55.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:55.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:55.273]     }
[10:30:55.273]     ...future.result <- base::tryCatch({
[10:30:55.273]         base::withCallingHandlers({
[10:30:55.273]             ...future.value <- base::withVisible(base::local({
[10:30:55.273]                 ...future.makeSendCondition <- base::local({
[10:30:55.273]                   sendCondition <- NULL
[10:30:55.273]                   function(frame = 1L) {
[10:30:55.273]                     if (is.function(sendCondition)) 
[10:30:55.273]                       return(sendCondition)
[10:30:55.273]                     ns <- getNamespace("parallel")
[10:30:55.273]                     if (exists("sendData", mode = "function", 
[10:30:55.273]                       envir = ns)) {
[10:30:55.273]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:55.273]                         envir = ns)
[10:30:55.273]                       envir <- sys.frame(frame)
[10:30:55.273]                       master <- NULL
[10:30:55.273]                       while (!identical(envir, .GlobalEnv) && 
[10:30:55.273]                         !identical(envir, emptyenv())) {
[10:30:55.273]                         if (exists("master", mode = "list", envir = envir, 
[10:30:55.273]                           inherits = FALSE)) {
[10:30:55.273]                           master <- get("master", mode = "list", 
[10:30:55.273]                             envir = envir, inherits = FALSE)
[10:30:55.273]                           if (inherits(master, c("SOCKnode", 
[10:30:55.273]                             "SOCK0node"))) {
[10:30:55.273]                             sendCondition <<- function(cond) {
[10:30:55.273]                               data <- list(type = "VALUE", value = cond, 
[10:30:55.273]                                 success = TRUE)
[10:30:55.273]                               parallel_sendData(master, data)
[10:30:55.273]                             }
[10:30:55.273]                             return(sendCondition)
[10:30:55.273]                           }
[10:30:55.273]                         }
[10:30:55.273]                         frame <- frame + 1L
[10:30:55.273]                         envir <- sys.frame(frame)
[10:30:55.273]                       }
[10:30:55.273]                     }
[10:30:55.273]                     sendCondition <<- function(cond) NULL
[10:30:55.273]                   }
[10:30:55.273]                 })
[10:30:55.273]                 withCallingHandlers({
[10:30:55.273]                   {
[10:30:55.273]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.273]                     if (!identical(...future.globals.maxSize.org, 
[10:30:55.273]                       ...future.globals.maxSize)) {
[10:30:55.273]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.273]                       on.exit(options(oopts), add = TRUE)
[10:30:55.273]                     }
[10:30:55.273]                     {
[10:30:55.273]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.273]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:55.273]                         USE.NAMES = FALSE)
[10:30:55.273]                       do.call(mapply, args = args)
[10:30:55.273]                     }
[10:30:55.273]                   }
[10:30:55.273]                 }, immediateCondition = function(cond) {
[10:30:55.273]                   sendCondition <- ...future.makeSendCondition()
[10:30:55.273]                   sendCondition(cond)
[10:30:55.273]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.273]                   {
[10:30:55.273]                     inherits <- base::inherits
[10:30:55.273]                     invokeRestart <- base::invokeRestart
[10:30:55.273]                     is.null <- base::is.null
[10:30:55.273]                     muffled <- FALSE
[10:30:55.273]                     if (inherits(cond, "message")) {
[10:30:55.273]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:55.273]                       if (muffled) 
[10:30:55.273]                         invokeRestart("muffleMessage")
[10:30:55.273]                     }
[10:30:55.273]                     else if (inherits(cond, "warning")) {
[10:30:55.273]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:55.273]                       if (muffled) 
[10:30:55.273]                         invokeRestart("muffleWarning")
[10:30:55.273]                     }
[10:30:55.273]                     else if (inherits(cond, "condition")) {
[10:30:55.273]                       if (!is.null(pattern)) {
[10:30:55.273]                         computeRestarts <- base::computeRestarts
[10:30:55.273]                         grepl <- base::grepl
[10:30:55.273]                         restarts <- computeRestarts(cond)
[10:30:55.273]                         for (restart in restarts) {
[10:30:55.273]                           name <- restart$name
[10:30:55.273]                           if (is.null(name)) 
[10:30:55.273]                             next
[10:30:55.273]                           if (!grepl(pattern, name)) 
[10:30:55.273]                             next
[10:30:55.273]                           invokeRestart(restart)
[10:30:55.273]                           muffled <- TRUE
[10:30:55.273]                           break
[10:30:55.273]                         }
[10:30:55.273]                       }
[10:30:55.273]                     }
[10:30:55.273]                     invisible(muffled)
[10:30:55.273]                   }
[10:30:55.273]                   muffleCondition(cond)
[10:30:55.273]                 })
[10:30:55.273]             }))
[10:30:55.273]             future::FutureResult(value = ...future.value$value, 
[10:30:55.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.273]                   ...future.rng), globalenv = if (FALSE) 
[10:30:55.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:55.273]                     ...future.globalenv.names))
[10:30:55.273]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:55.273]         }, condition = base::local({
[10:30:55.273]             c <- base::c
[10:30:55.273]             inherits <- base::inherits
[10:30:55.273]             invokeRestart <- base::invokeRestart
[10:30:55.273]             length <- base::length
[10:30:55.273]             list <- base::list
[10:30:55.273]             seq.int <- base::seq.int
[10:30:55.273]             signalCondition <- base::signalCondition
[10:30:55.273]             sys.calls <- base::sys.calls
[10:30:55.273]             `[[` <- base::`[[`
[10:30:55.273]             `+` <- base::`+`
[10:30:55.273]             `<<-` <- base::`<<-`
[10:30:55.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:55.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:55.273]                   3L)]
[10:30:55.273]             }
[10:30:55.273]             function(cond) {
[10:30:55.273]                 is_error <- inherits(cond, "error")
[10:30:55.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:55.273]                   NULL)
[10:30:55.273]                 if (is_error) {
[10:30:55.273]                   sessionInformation <- function() {
[10:30:55.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:55.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:55.273]                       search = base::search(), system = base::Sys.info())
[10:30:55.273]                   }
[10:30:55.273]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:55.273]                     cond$call), session = sessionInformation(), 
[10:30:55.273]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:55.273]                   signalCondition(cond)
[10:30:55.273]                 }
[10:30:55.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:55.273]                 "immediateCondition"))) {
[10:30:55.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:55.273]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:55.273]                   if (TRUE && !signal) {
[10:30:55.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.273]                     {
[10:30:55.273]                       inherits <- base::inherits
[10:30:55.273]                       invokeRestart <- base::invokeRestart
[10:30:55.273]                       is.null <- base::is.null
[10:30:55.273]                       muffled <- FALSE
[10:30:55.273]                       if (inherits(cond, "message")) {
[10:30:55.273]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.273]                         if (muffled) 
[10:30:55.273]                           invokeRestart("muffleMessage")
[10:30:55.273]                       }
[10:30:55.273]                       else if (inherits(cond, "warning")) {
[10:30:55.273]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.273]                         if (muffled) 
[10:30:55.273]                           invokeRestart("muffleWarning")
[10:30:55.273]                       }
[10:30:55.273]                       else if (inherits(cond, "condition")) {
[10:30:55.273]                         if (!is.null(pattern)) {
[10:30:55.273]                           computeRestarts <- base::computeRestarts
[10:30:55.273]                           grepl <- base::grepl
[10:30:55.273]                           restarts <- computeRestarts(cond)
[10:30:55.273]                           for (restart in restarts) {
[10:30:55.273]                             name <- restart$name
[10:30:55.273]                             if (is.null(name)) 
[10:30:55.273]                               next
[10:30:55.273]                             if (!grepl(pattern, name)) 
[10:30:55.273]                               next
[10:30:55.273]                             invokeRestart(restart)
[10:30:55.273]                             muffled <- TRUE
[10:30:55.273]                             break
[10:30:55.273]                           }
[10:30:55.273]                         }
[10:30:55.273]                       }
[10:30:55.273]                       invisible(muffled)
[10:30:55.273]                     }
[10:30:55.273]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.273]                   }
[10:30:55.273]                 }
[10:30:55.273]                 else {
[10:30:55.273]                   if (TRUE) {
[10:30:55.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.273]                     {
[10:30:55.273]                       inherits <- base::inherits
[10:30:55.273]                       invokeRestart <- base::invokeRestart
[10:30:55.273]                       is.null <- base::is.null
[10:30:55.273]                       muffled <- FALSE
[10:30:55.273]                       if (inherits(cond, "message")) {
[10:30:55.273]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.273]                         if (muffled) 
[10:30:55.273]                           invokeRestart("muffleMessage")
[10:30:55.273]                       }
[10:30:55.273]                       else if (inherits(cond, "warning")) {
[10:30:55.273]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.273]                         if (muffled) 
[10:30:55.273]                           invokeRestart("muffleWarning")
[10:30:55.273]                       }
[10:30:55.273]                       else if (inherits(cond, "condition")) {
[10:30:55.273]                         if (!is.null(pattern)) {
[10:30:55.273]                           computeRestarts <- base::computeRestarts
[10:30:55.273]                           grepl <- base::grepl
[10:30:55.273]                           restarts <- computeRestarts(cond)
[10:30:55.273]                           for (restart in restarts) {
[10:30:55.273]                             name <- restart$name
[10:30:55.273]                             if (is.null(name)) 
[10:30:55.273]                               next
[10:30:55.273]                             if (!grepl(pattern, name)) 
[10:30:55.273]                               next
[10:30:55.273]                             invokeRestart(restart)
[10:30:55.273]                             muffled <- TRUE
[10:30:55.273]                             break
[10:30:55.273]                           }
[10:30:55.273]                         }
[10:30:55.273]                       }
[10:30:55.273]                       invisible(muffled)
[10:30:55.273]                     }
[10:30:55.273]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.273]                   }
[10:30:55.273]                 }
[10:30:55.273]             }
[10:30:55.273]         }))
[10:30:55.273]     }, error = function(ex) {
[10:30:55.273]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:55.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.273]                 ...future.rng), started = ...future.startTime, 
[10:30:55.273]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:55.273]             version = "1.8"), class = "FutureResult")
[10:30:55.273]     }, finally = {
[10:30:55.273]         if (!identical(...future.workdir, getwd())) 
[10:30:55.273]             setwd(...future.workdir)
[10:30:55.273]         {
[10:30:55.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:55.273]                 ...future.oldOptions$nwarnings <- NULL
[10:30:55.273]             }
[10:30:55.273]             base::options(...future.oldOptions)
[10:30:55.273]             if (.Platform$OS.type == "windows") {
[10:30:55.273]                 old_names <- names(...future.oldEnvVars)
[10:30:55.273]                 envs <- base::Sys.getenv()
[10:30:55.273]                 names <- names(envs)
[10:30:55.273]                 common <- intersect(names, old_names)
[10:30:55.273]                 added <- setdiff(names, old_names)
[10:30:55.273]                 removed <- setdiff(old_names, names)
[10:30:55.273]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:55.273]                   envs[common]]
[10:30:55.273]                 NAMES <- toupper(changed)
[10:30:55.273]                 args <- list()
[10:30:55.273]                 for (kk in seq_along(NAMES)) {
[10:30:55.273]                   name <- changed[[kk]]
[10:30:55.273]                   NAME <- NAMES[[kk]]
[10:30:55.273]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.273]                     next
[10:30:55.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.273]                 }
[10:30:55.273]                 NAMES <- toupper(added)
[10:30:55.273]                 for (kk in seq_along(NAMES)) {
[10:30:55.273]                   name <- added[[kk]]
[10:30:55.273]                   NAME <- NAMES[[kk]]
[10:30:55.273]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.273]                     next
[10:30:55.273]                   args[[name]] <- ""
[10:30:55.273]                 }
[10:30:55.273]                 NAMES <- toupper(removed)
[10:30:55.273]                 for (kk in seq_along(NAMES)) {
[10:30:55.273]                   name <- removed[[kk]]
[10:30:55.273]                   NAME <- NAMES[[kk]]
[10:30:55.273]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.273]                     next
[10:30:55.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.273]                 }
[10:30:55.273]                 if (length(args) > 0) 
[10:30:55.273]                   base::do.call(base::Sys.setenv, args = args)
[10:30:55.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:55.273]             }
[10:30:55.273]             else {
[10:30:55.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:55.273]             }
[10:30:55.273]             {
[10:30:55.273]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:55.273]                   0L) {
[10:30:55.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:55.273]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:55.273]                   base::options(opts)
[10:30:55.273]                 }
[10:30:55.273]                 {
[10:30:55.273]                   {
[10:30:55.273]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:55.273]                     NULL
[10:30:55.273]                   }
[10:30:55.273]                   options(future.plan = NULL)
[10:30:55.273]                   if (is.na(NA_character_)) 
[10:30:55.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:55.273]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:55.273]                     .init = FALSE)
[10:30:55.273]                 }
[10:30:55.273]             }
[10:30:55.273]         }
[10:30:55.273]     })
[10:30:55.273]     if (TRUE) {
[10:30:55.273]         base::sink(type = "output", split = FALSE)
[10:30:55.273]         if (TRUE) {
[10:30:55.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:55.273]         }
[10:30:55.273]         else {
[10:30:55.273]             ...future.result["stdout"] <- base::list(NULL)
[10:30:55.273]         }
[10:30:55.273]         base::close(...future.stdout)
[10:30:55.273]         ...future.stdout <- NULL
[10:30:55.273]     }
[10:30:55.273]     ...future.result$conditions <- ...future.conditions
[10:30:55.273]     ...future.result$finished <- base::Sys.time()
[10:30:55.273]     ...future.result
[10:30:55.273] }
[10:30:55.276] Exporting 5 global objects (2.41 KiB) to cluster node #2 ...
[10:30:55.276] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ...
[10:30:55.276] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ... DONE
[10:30:55.276] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:55.277] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.277] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ...
[10:30:55.277] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ... DONE
[10:30:55.278] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:55.278] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.278] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:55.278] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.279] Exporting 5 global objects (2.41 KiB) to cluster node #2 ... DONE
[10:30:55.279] MultisessionFuture started
[10:30:55.279] - Launch lazy future ... done
[10:30:55.279] run() for ‘MultisessionFuture’ ... done
[10:30:55.280] Created future:
[10:30:55.280] MultisessionFuture:
[10:30:55.280] Label: ‘future_Map-2’
[10:30:55.280] Expression:
[10:30:55.280] {
[10:30:55.280]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.280]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:55.280]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.280]         on.exit(options(oopts), add = TRUE)
[10:30:55.280]     }
[10:30:55.280]     {
[10:30:55.280]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.280]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:55.280]         do.call(mapply, args = args)
[10:30:55.280]     }
[10:30:55.280] }
[10:30:55.280] Lazy evaluation: FALSE
[10:30:55.280] Asynchronous evaluation: TRUE
[10:30:55.280] Local evaluation: TRUE
[10:30:55.280] Environment: R_GlobalEnv
[10:30:55.280] Capture standard output: TRUE
[10:30:55.280] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:55.280] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:55.280] Packages: 1 packages (‘stats’)
[10:30:55.280] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:55.280] Resolved: FALSE
[10:30:55.280] Value: <not collected>
[10:30:55.280] Conditions captured: <none>
[10:30:55.280] Early signaling: FALSE
[10:30:55.280] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:55.280] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.291] Chunk #2 of 2 ... DONE
[10:30:55.291] Launching 2 futures (chunks) ... DONE
[10:30:55.291] Resolving 2 futures (chunks) ...
[10:30:55.292] resolve() on list ...
[10:30:55.292]  recursive: 0
[10:30:55.292]  length: 2
[10:30:55.292] 
[10:30:55.292] receiveMessageFromWorker() for ClusterFuture ...
[10:30:55.292] - Validating connection of MultisessionFuture
[10:30:55.293] - received message: FutureResult
[10:30:55.293] - Received FutureResult
[10:30:55.293] - Erased future from FutureRegistry
[10:30:55.293] result() for ClusterFuture ...
[10:30:55.293] - result already collected: FutureResult
[10:30:55.293] result() for ClusterFuture ... done
[10:30:55.293] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:55.293] Future #1
[10:30:55.294] result() for ClusterFuture ...
[10:30:55.294] - result already collected: FutureResult
[10:30:55.294] result() for ClusterFuture ... done
[10:30:55.294] result() for ClusterFuture ...
[10:30:55.294] - result already collected: FutureResult
[10:30:55.294] result() for ClusterFuture ... done
[10:30:55.294] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:55.294] - nx: 2
[10:30:55.294] - relay: TRUE
[10:30:55.294] - stdout: TRUE
[10:30:55.294] - signal: TRUE
[10:30:55.294] - resignal: FALSE
[10:30:55.295] - force: TRUE
[10:30:55.295] - relayed: [n=2] FALSE, FALSE
[10:30:55.295] - queued futures: [n=2] FALSE, FALSE
[10:30:55.295]  - until=1
[10:30:55.295]  - relaying element #1
[10:30:55.295] result() for ClusterFuture ...
[10:30:55.295] - result already collected: FutureResult
[10:30:55.295] result() for ClusterFuture ... done
[10:30:55.295] result() for ClusterFuture ...
[10:30:55.295] - result already collected: FutureResult
[10:30:55.296] result() for ClusterFuture ... done
[10:30:55.296] result() for ClusterFuture ...
[10:30:55.296] - result already collected: FutureResult
[10:30:55.296] result() for ClusterFuture ... done
[10:30:55.296] result() for ClusterFuture ...
[10:30:55.296] - result already collected: FutureResult
[10:30:55.296] result() for ClusterFuture ... done
[10:30:55.296] - relayed: [n=2] TRUE, FALSE
[10:30:55.296] - queued futures: [n=2] TRUE, FALSE
[10:30:55.296] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:55.296]  length: 1 (resolved future 1)
[10:30:55.323] receiveMessageFromWorker() for ClusterFuture ...
[10:30:55.323] - Validating connection of MultisessionFuture
[10:30:55.323] - received message: FutureResult
[10:30:55.323] - Received FutureResult
[10:30:55.323] - Erased future from FutureRegistry
[10:30:55.324] result() for ClusterFuture ...
[10:30:55.324] - result already collected: FutureResult
[10:30:55.324] result() for ClusterFuture ... done
[10:30:55.324] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:55.324] Future #2
[10:30:55.324] result() for ClusterFuture ...
[10:30:55.324] - result already collected: FutureResult
[10:30:55.324] result() for ClusterFuture ... done
[10:30:55.324] result() for ClusterFuture ...
[10:30:55.324] - result already collected: FutureResult
[10:30:55.325] result() for ClusterFuture ... done
[10:30:55.325] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:55.325] - nx: 2
[10:30:55.325] - relay: TRUE
[10:30:55.325] - stdout: TRUE
[10:30:55.325] - signal: TRUE
[10:30:55.325] - resignal: FALSE
[10:30:55.325] - force: TRUE
[10:30:55.325] - relayed: [n=2] TRUE, FALSE
[10:30:55.325] - queued futures: [n=2] TRUE, FALSE
[10:30:55.325]  - until=2
[10:30:55.326]  - relaying element #2
[10:30:55.326] result() for ClusterFuture ...
[10:30:55.326] - result already collected: FutureResult
[10:30:55.326] result() for ClusterFuture ... done
[10:30:55.326] result() for ClusterFuture ...
[10:30:55.329] - result already collected: FutureResult
[10:30:55.329] result() for ClusterFuture ... done
[10:30:55.329] result() for ClusterFuture ...
[10:30:55.329] - result already collected: FutureResult
[10:30:55.330] result() for ClusterFuture ... done
[10:30:55.330] result() for ClusterFuture ...
[10:30:55.330] - result already collected: FutureResult
[10:30:55.330] result() for ClusterFuture ... done
[10:30:55.330] - relayed: [n=2] TRUE, TRUE
[10:30:55.330] - queued futures: [n=2] TRUE, TRUE
[10:30:55.330] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:55.330]  length: 0 (resolved future 2)
[10:30:55.330] Relaying remaining futures
[10:30:55.330] signalConditionsASAP(NULL, pos=0) ...
[10:30:55.330] - nx: 2
[10:30:55.331] - relay: TRUE
[10:30:55.331] - stdout: TRUE
[10:30:55.331] - signal: TRUE
[10:30:55.331] - resignal: FALSE
[10:30:55.331] - force: TRUE
[10:30:55.331] - relayed: [n=2] TRUE, TRUE
[10:30:55.331] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:55.331] - relayed: [n=2] TRUE, TRUE
[10:30:55.331] - queued futures: [n=2] TRUE, TRUE
[10:30:55.331] signalConditionsASAP(NULL, pos=0) ... done
[10:30:55.331] resolve() on list ... DONE
[10:30:55.332] result() for ClusterFuture ...
[10:30:55.332] - result already collected: FutureResult
[10:30:55.332] result() for ClusterFuture ... done
[10:30:55.332] result() for ClusterFuture ...
[10:30:55.332] - result already collected: FutureResult
[10:30:55.332] result() for ClusterFuture ... done
[10:30:55.332] result() for ClusterFuture ...
[10:30:55.332] - result already collected: FutureResult
[10:30:55.332] result() for ClusterFuture ... done
[10:30:55.332] result() for ClusterFuture ...
[10:30:55.332] - result already collected: FutureResult
[10:30:55.332] result() for ClusterFuture ... done
[10:30:55.333]  - Number of value chunks collected: 2
[10:30:55.333] Resolving 2 futures (chunks) ... DONE
[10:30:55.333] Reducing values from 2 chunks ...
[10:30:55.333]  - Number of values collected after concatenation: 5
[10:30:55.333]  - Number of values expected: 5
[10:30:55.333] Reducing values from 2 chunks ... DONE
[10:30:55.333] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[10:30:55.335] future_mapply() ...
[10:30:55.339] Number of chunks: 2
[10:30:55.339] getGlobalsAndPackagesXApply() ...
[10:30:55.339]  - future.globals: TRUE
[10:30:55.339] getGlobalsAndPackages() ...
[10:30:55.339] Searching for globals...
[10:30:55.340] - globals found: [1] ‘FUN’
[10:30:55.340] Searching for globals ... DONE
[10:30:55.340] Resolving globals: FALSE
[10:30:55.340] The total size of the 1 globals is 56 bytes (56 bytes)
[10:30:55.341] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[10:30:55.341] - globals: [1] ‘FUN’
[10:30:55.341] 
[10:30:55.341] getGlobalsAndPackages() ... DONE
[10:30:55.341]  - globals found/used: [n=1] ‘FUN’
[10:30:55.341]  - needed namespaces: [n=0] 
[10:30:55.341] Finding globals ... DONE
[10:30:55.341] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:55.342] List of 2
[10:30:55.342]  $ ...future.FUN:function (e1, e2)  
[10:30:55.342]  $ MoreArgs     : NULL
[10:30:55.342]  - attr(*, "where")=List of 2
[10:30:55.342]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:55.342]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:55.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:55.342]  - attr(*, "resolved")= logi FALSE
[10:30:55.342]  - attr(*, "total_size")= num NA
[10:30:55.344] Packages to be attached in all futures: [n=0] 
[10:30:55.344] getGlobalsAndPackagesXApply() ... DONE
[10:30:55.344] Number of futures (= number of chunks): 2
[10:30:55.344] Launching 2 futures (chunks) ...
[10:30:55.345] Chunk #1 of 2 ...
[10:30:55.345]  - Finding globals in '...' for chunk #1 ...
[10:30:55.345] getGlobalsAndPackages() ...
[10:30:55.345] Searching for globals...
[10:30:55.345] 
[10:30:55.345] Searching for globals ... DONE
[10:30:55.345] - globals: [0] <none>
[10:30:55.345] getGlobalsAndPackages() ... DONE
[10:30:55.346]    + additional globals found: [n=0] 
[10:30:55.346]    + additional namespaces needed: [n=0] 
[10:30:55.346]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:55.346]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:55.346]  - seeds: <none>
[10:30:55.346]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.346] getGlobalsAndPackages() ...
[10:30:55.346] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.346] Resolving globals: FALSE
[10:30:55.347] The total size of the 5 globals is 168 bytes (168 bytes)
[10:30:55.347] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:55.347] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.347] 
[10:30:55.347] getGlobalsAndPackages() ... DONE
[10:30:55.348] run() for ‘Future’ ...
[10:30:55.348] - state: ‘created’
[10:30:55.348] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:55.362] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:55.362]   - Field: ‘node’
[10:30:55.362]   - Field: ‘label’
[10:30:55.362]   - Field: ‘local’
[10:30:55.362]   - Field: ‘owner’
[10:30:55.362]   - Field: ‘envir’
[10:30:55.362]   - Field: ‘workers’
[10:30:55.362]   - Field: ‘packages’
[10:30:55.363]   - Field: ‘gc’
[10:30:55.363]   - Field: ‘conditions’
[10:30:55.363]   - Field: ‘persistent’
[10:30:55.363]   - Field: ‘expr’
[10:30:55.363]   - Field: ‘uuid’
[10:30:55.363]   - Field: ‘seed’
[10:30:55.363]   - Field: ‘version’
[10:30:55.363]   - Field: ‘result’
[10:30:55.363]   - Field: ‘asynchronous’
[10:30:55.363]   - Field: ‘calls’
[10:30:55.363]   - Field: ‘globals’
[10:30:55.364]   - Field: ‘stdout’
[10:30:55.364]   - Field: ‘earlySignal’
[10:30:55.364]   - Field: ‘lazy’
[10:30:55.364]   - Field: ‘state’
[10:30:55.364] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:55.364] - Launch lazy future ...
[10:30:55.364] Packages needed by the future expression (n = 0): <none>
[10:30:55.364] Packages needed by future strategies (n = 0): <none>
[10:30:55.365] {
[10:30:55.365]     {
[10:30:55.365]         {
[10:30:55.365]             ...future.startTime <- base::Sys.time()
[10:30:55.365]             {
[10:30:55.365]                 {
[10:30:55.365]                   {
[10:30:55.365]                     {
[10:30:55.365]                       base::local({
[10:30:55.365]                         has_future <- base::requireNamespace("future", 
[10:30:55.365]                           quietly = TRUE)
[10:30:55.365]                         if (has_future) {
[10:30:55.365]                           ns <- base::getNamespace("future")
[10:30:55.365]                           version <- ns[[".package"]][["version"]]
[10:30:55.365]                           if (is.null(version)) 
[10:30:55.365]                             version <- utils::packageVersion("future")
[10:30:55.365]                         }
[10:30:55.365]                         else {
[10:30:55.365]                           version <- NULL
[10:30:55.365]                         }
[10:30:55.365]                         if (!has_future || version < "1.8.0") {
[10:30:55.365]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:55.365]                             "", base::R.version$version.string), 
[10:30:55.365]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:55.365]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:55.365]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:55.365]                               "release", "version")], collapse = " "), 
[10:30:55.365]                             hostname = base::Sys.info()[["nodename"]])
[10:30:55.365]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:55.365]                             info)
[10:30:55.365]                           info <- base::paste(info, collapse = "; ")
[10:30:55.365]                           if (!has_future) {
[10:30:55.365]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:55.365]                               info)
[10:30:55.365]                           }
[10:30:55.365]                           else {
[10:30:55.365]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:55.365]                               info, version)
[10:30:55.365]                           }
[10:30:55.365]                           base::stop(msg)
[10:30:55.365]                         }
[10:30:55.365]                       })
[10:30:55.365]                     }
[10:30:55.365]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:55.365]                     base::options(mc.cores = 1L)
[10:30:55.365]                   }
[10:30:55.365]                   ...future.strategy.old <- future::plan("list")
[10:30:55.365]                   options(future.plan = NULL)
[10:30:55.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:55.365]                 }
[10:30:55.365]                 ...future.workdir <- getwd()
[10:30:55.365]             }
[10:30:55.365]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:55.365]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:55.365]         }
[10:30:55.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:55.365]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:55.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:55.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:55.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:55.365]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:55.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:55.365]             base::names(...future.oldOptions))
[10:30:55.365]     }
[10:30:55.365]     if (FALSE) {
[10:30:55.365]     }
[10:30:55.365]     else {
[10:30:55.365]         if (TRUE) {
[10:30:55.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:55.365]                 open = "w")
[10:30:55.365]         }
[10:30:55.365]         else {
[10:30:55.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:55.365]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:55.365]         }
[10:30:55.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:55.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:55.365]             base::sink(type = "output", split = FALSE)
[10:30:55.365]             base::close(...future.stdout)
[10:30:55.365]         }, add = TRUE)
[10:30:55.365]     }
[10:30:55.365]     ...future.frame <- base::sys.nframe()
[10:30:55.365]     ...future.conditions <- base::list()
[10:30:55.365]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:55.365]     if (FALSE) {
[10:30:55.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:55.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:55.365]     }
[10:30:55.365]     ...future.result <- base::tryCatch({
[10:30:55.365]         base::withCallingHandlers({
[10:30:55.365]             ...future.value <- base::withVisible(base::local({
[10:30:55.365]                 ...future.makeSendCondition <- base::local({
[10:30:55.365]                   sendCondition <- NULL
[10:30:55.365]                   function(frame = 1L) {
[10:30:55.365]                     if (is.function(sendCondition)) 
[10:30:55.365]                       return(sendCondition)
[10:30:55.365]                     ns <- getNamespace("parallel")
[10:30:55.365]                     if (exists("sendData", mode = "function", 
[10:30:55.365]                       envir = ns)) {
[10:30:55.365]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:55.365]                         envir = ns)
[10:30:55.365]                       envir <- sys.frame(frame)
[10:30:55.365]                       master <- NULL
[10:30:55.365]                       while (!identical(envir, .GlobalEnv) && 
[10:30:55.365]                         !identical(envir, emptyenv())) {
[10:30:55.365]                         if (exists("master", mode = "list", envir = envir, 
[10:30:55.365]                           inherits = FALSE)) {
[10:30:55.365]                           master <- get("master", mode = "list", 
[10:30:55.365]                             envir = envir, inherits = FALSE)
[10:30:55.365]                           if (inherits(master, c("SOCKnode", 
[10:30:55.365]                             "SOCK0node"))) {
[10:30:55.365]                             sendCondition <<- function(cond) {
[10:30:55.365]                               data <- list(type = "VALUE", value = cond, 
[10:30:55.365]                                 success = TRUE)
[10:30:55.365]                               parallel_sendData(master, data)
[10:30:55.365]                             }
[10:30:55.365]                             return(sendCondition)
[10:30:55.365]                           }
[10:30:55.365]                         }
[10:30:55.365]                         frame <- frame + 1L
[10:30:55.365]                         envir <- sys.frame(frame)
[10:30:55.365]                       }
[10:30:55.365]                     }
[10:30:55.365]                     sendCondition <<- function(cond) NULL
[10:30:55.365]                   }
[10:30:55.365]                 })
[10:30:55.365]                 withCallingHandlers({
[10:30:55.365]                   {
[10:30:55.365]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.365]                     if (!identical(...future.globals.maxSize.org, 
[10:30:55.365]                       ...future.globals.maxSize)) {
[10:30:55.365]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.365]                       on.exit(options(oopts), add = TRUE)
[10:30:55.365]                     }
[10:30:55.365]                     {
[10:30:55.365]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.365]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:55.365]                         USE.NAMES = FALSE)
[10:30:55.365]                       do.call(mapply, args = args)
[10:30:55.365]                     }
[10:30:55.365]                   }
[10:30:55.365]                 }, immediateCondition = function(cond) {
[10:30:55.365]                   sendCondition <- ...future.makeSendCondition()
[10:30:55.365]                   sendCondition(cond)
[10:30:55.365]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.365]                   {
[10:30:55.365]                     inherits <- base::inherits
[10:30:55.365]                     invokeRestart <- base::invokeRestart
[10:30:55.365]                     is.null <- base::is.null
[10:30:55.365]                     muffled <- FALSE
[10:30:55.365]                     if (inherits(cond, "message")) {
[10:30:55.365]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:55.365]                       if (muffled) 
[10:30:55.365]                         invokeRestart("muffleMessage")
[10:30:55.365]                     }
[10:30:55.365]                     else if (inherits(cond, "warning")) {
[10:30:55.365]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:55.365]                       if (muffled) 
[10:30:55.365]                         invokeRestart("muffleWarning")
[10:30:55.365]                     }
[10:30:55.365]                     else if (inherits(cond, "condition")) {
[10:30:55.365]                       if (!is.null(pattern)) {
[10:30:55.365]                         computeRestarts <- base::computeRestarts
[10:30:55.365]                         grepl <- base::grepl
[10:30:55.365]                         restarts <- computeRestarts(cond)
[10:30:55.365]                         for (restart in restarts) {
[10:30:55.365]                           name <- restart$name
[10:30:55.365]                           if (is.null(name)) 
[10:30:55.365]                             next
[10:30:55.365]                           if (!grepl(pattern, name)) 
[10:30:55.365]                             next
[10:30:55.365]                           invokeRestart(restart)
[10:30:55.365]                           muffled <- TRUE
[10:30:55.365]                           break
[10:30:55.365]                         }
[10:30:55.365]                       }
[10:30:55.365]                     }
[10:30:55.365]                     invisible(muffled)
[10:30:55.365]                   }
[10:30:55.365]                   muffleCondition(cond)
[10:30:55.365]                 })
[10:30:55.365]             }))
[10:30:55.365]             future::FutureResult(value = ...future.value$value, 
[10:30:55.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.365]                   ...future.rng), globalenv = if (FALSE) 
[10:30:55.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:55.365]                     ...future.globalenv.names))
[10:30:55.365]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:55.365]         }, condition = base::local({
[10:30:55.365]             c <- base::c
[10:30:55.365]             inherits <- base::inherits
[10:30:55.365]             invokeRestart <- base::invokeRestart
[10:30:55.365]             length <- base::length
[10:30:55.365]             list <- base::list
[10:30:55.365]             seq.int <- base::seq.int
[10:30:55.365]             signalCondition <- base::signalCondition
[10:30:55.365]             sys.calls <- base::sys.calls
[10:30:55.365]             `[[` <- base::`[[`
[10:30:55.365]             `+` <- base::`+`
[10:30:55.365]             `<<-` <- base::`<<-`
[10:30:55.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:55.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:55.365]                   3L)]
[10:30:55.365]             }
[10:30:55.365]             function(cond) {
[10:30:55.365]                 is_error <- inherits(cond, "error")
[10:30:55.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:55.365]                   NULL)
[10:30:55.365]                 if (is_error) {
[10:30:55.365]                   sessionInformation <- function() {
[10:30:55.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:55.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:55.365]                       search = base::search(), system = base::Sys.info())
[10:30:55.365]                   }
[10:30:55.365]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:55.365]                     cond$call), session = sessionInformation(), 
[10:30:55.365]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:55.365]                   signalCondition(cond)
[10:30:55.365]                 }
[10:30:55.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:55.365]                 "immediateCondition"))) {
[10:30:55.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:55.365]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:55.365]                   if (TRUE && !signal) {
[10:30:55.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.365]                     {
[10:30:55.365]                       inherits <- base::inherits
[10:30:55.365]                       invokeRestart <- base::invokeRestart
[10:30:55.365]                       is.null <- base::is.null
[10:30:55.365]                       muffled <- FALSE
[10:30:55.365]                       if (inherits(cond, "message")) {
[10:30:55.365]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.365]                         if (muffled) 
[10:30:55.365]                           invokeRestart("muffleMessage")
[10:30:55.365]                       }
[10:30:55.365]                       else if (inherits(cond, "warning")) {
[10:30:55.365]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.365]                         if (muffled) 
[10:30:55.365]                           invokeRestart("muffleWarning")
[10:30:55.365]                       }
[10:30:55.365]                       else if (inherits(cond, "condition")) {
[10:30:55.365]                         if (!is.null(pattern)) {
[10:30:55.365]                           computeRestarts <- base::computeRestarts
[10:30:55.365]                           grepl <- base::grepl
[10:30:55.365]                           restarts <- computeRestarts(cond)
[10:30:55.365]                           for (restart in restarts) {
[10:30:55.365]                             name <- restart$name
[10:30:55.365]                             if (is.null(name)) 
[10:30:55.365]                               next
[10:30:55.365]                             if (!grepl(pattern, name)) 
[10:30:55.365]                               next
[10:30:55.365]                             invokeRestart(restart)
[10:30:55.365]                             muffled <- TRUE
[10:30:55.365]                             break
[10:30:55.365]                           }
[10:30:55.365]                         }
[10:30:55.365]                       }
[10:30:55.365]                       invisible(muffled)
[10:30:55.365]                     }
[10:30:55.365]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.365]                   }
[10:30:55.365]                 }
[10:30:55.365]                 else {
[10:30:55.365]                   if (TRUE) {
[10:30:55.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.365]                     {
[10:30:55.365]                       inherits <- base::inherits
[10:30:55.365]                       invokeRestart <- base::invokeRestart
[10:30:55.365]                       is.null <- base::is.null
[10:30:55.365]                       muffled <- FALSE
[10:30:55.365]                       if (inherits(cond, "message")) {
[10:30:55.365]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.365]                         if (muffled) 
[10:30:55.365]                           invokeRestart("muffleMessage")
[10:30:55.365]                       }
[10:30:55.365]                       else if (inherits(cond, "warning")) {
[10:30:55.365]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.365]                         if (muffled) 
[10:30:55.365]                           invokeRestart("muffleWarning")
[10:30:55.365]                       }
[10:30:55.365]                       else if (inherits(cond, "condition")) {
[10:30:55.365]                         if (!is.null(pattern)) {
[10:30:55.365]                           computeRestarts <- base::computeRestarts
[10:30:55.365]                           grepl <- base::grepl
[10:30:55.365]                           restarts <- computeRestarts(cond)
[10:30:55.365]                           for (restart in restarts) {
[10:30:55.365]                             name <- restart$name
[10:30:55.365]                             if (is.null(name)) 
[10:30:55.365]                               next
[10:30:55.365]                             if (!grepl(pattern, name)) 
[10:30:55.365]                               next
[10:30:55.365]                             invokeRestart(restart)
[10:30:55.365]                             muffled <- TRUE
[10:30:55.365]                             break
[10:30:55.365]                           }
[10:30:55.365]                         }
[10:30:55.365]                       }
[10:30:55.365]                       invisible(muffled)
[10:30:55.365]                     }
[10:30:55.365]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.365]                   }
[10:30:55.365]                 }
[10:30:55.365]             }
[10:30:55.365]         }))
[10:30:55.365]     }, error = function(ex) {
[10:30:55.365]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:55.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.365]                 ...future.rng), started = ...future.startTime, 
[10:30:55.365]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:55.365]             version = "1.8"), class = "FutureResult")
[10:30:55.365]     }, finally = {
[10:30:55.365]         if (!identical(...future.workdir, getwd())) 
[10:30:55.365]             setwd(...future.workdir)
[10:30:55.365]         {
[10:30:55.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:55.365]                 ...future.oldOptions$nwarnings <- NULL
[10:30:55.365]             }
[10:30:55.365]             base::options(...future.oldOptions)
[10:30:55.365]             if (.Platform$OS.type == "windows") {
[10:30:55.365]                 old_names <- names(...future.oldEnvVars)
[10:30:55.365]                 envs <- base::Sys.getenv()
[10:30:55.365]                 names <- names(envs)
[10:30:55.365]                 common <- intersect(names, old_names)
[10:30:55.365]                 added <- setdiff(names, old_names)
[10:30:55.365]                 removed <- setdiff(old_names, names)
[10:30:55.365]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:55.365]                   envs[common]]
[10:30:55.365]                 NAMES <- toupper(changed)
[10:30:55.365]                 args <- list()
[10:30:55.365]                 for (kk in seq_along(NAMES)) {
[10:30:55.365]                   name <- changed[[kk]]
[10:30:55.365]                   NAME <- NAMES[[kk]]
[10:30:55.365]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.365]                     next
[10:30:55.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.365]                 }
[10:30:55.365]                 NAMES <- toupper(added)
[10:30:55.365]                 for (kk in seq_along(NAMES)) {
[10:30:55.365]                   name <- added[[kk]]
[10:30:55.365]                   NAME <- NAMES[[kk]]
[10:30:55.365]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.365]                     next
[10:30:55.365]                   args[[name]] <- ""
[10:30:55.365]                 }
[10:30:55.365]                 NAMES <- toupper(removed)
[10:30:55.365]                 for (kk in seq_along(NAMES)) {
[10:30:55.365]                   name <- removed[[kk]]
[10:30:55.365]                   NAME <- NAMES[[kk]]
[10:30:55.365]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.365]                     next
[10:30:55.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.365]                 }
[10:30:55.365]                 if (length(args) > 0) 
[10:30:55.365]                   base::do.call(base::Sys.setenv, args = args)
[10:30:55.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:55.365]             }
[10:30:55.365]             else {
[10:30:55.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:55.365]             }
[10:30:55.365]             {
[10:30:55.365]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:55.365]                   0L) {
[10:30:55.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:55.365]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:55.365]                   base::options(opts)
[10:30:55.365]                 }
[10:30:55.365]                 {
[10:30:55.365]                   {
[10:30:55.365]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:55.365]                     NULL
[10:30:55.365]                   }
[10:30:55.365]                   options(future.plan = NULL)
[10:30:55.365]                   if (is.na(NA_character_)) 
[10:30:55.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:55.365]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:55.365]                     .init = FALSE)
[10:30:55.365]                 }
[10:30:55.365]             }
[10:30:55.365]         }
[10:30:55.365]     })
[10:30:55.365]     if (TRUE) {
[10:30:55.365]         base::sink(type = "output", split = FALSE)
[10:30:55.365]         if (TRUE) {
[10:30:55.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:55.365]         }
[10:30:55.365]         else {
[10:30:55.365]             ...future.result["stdout"] <- base::list(NULL)
[10:30:55.365]         }
[10:30:55.365]         base::close(...future.stdout)
[10:30:55.365]         ...future.stdout <- NULL
[10:30:55.365]     }
[10:30:55.365]     ...future.result$conditions <- ...future.conditions
[10:30:55.365]     ...future.result$finished <- base::Sys.time()
[10:30:55.365]     ...future.result
[10:30:55.365] }
[10:30:55.368] Exporting 5 global objects (168 bytes) to cluster node #1 ...
[10:30:55.368] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[10:30:55.368] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[10:30:55.368] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:55.369] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:55.369] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:30:55.369] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:30:55.369] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:55.370] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:55.370] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:55.370] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:55.370] Exporting 5 global objects (168 bytes) to cluster node #1 ... DONE
[10:30:55.371] MultisessionFuture started
[10:30:55.371] - Launch lazy future ... done
[10:30:55.371] run() for ‘MultisessionFuture’ ... done
[10:30:55.371] Created future:
[10:30:55.371] MultisessionFuture:
[10:30:55.371] Label: ‘future_Map-1’
[10:30:55.371] Expression:
[10:30:55.371] {
[10:30:55.371]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.371]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:55.371]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.371]         on.exit(options(oopts), add = TRUE)
[10:30:55.371]     }
[10:30:55.371]     {
[10:30:55.371]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.371]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:55.371]         do.call(mapply, args = args)
[10:30:55.371]     }
[10:30:55.371] }
[10:30:55.371] Lazy evaluation: FALSE
[10:30:55.371] Asynchronous evaluation: TRUE
[10:30:55.371] Local evaluation: TRUE
[10:30:55.371] Environment: R_GlobalEnv
[10:30:55.371] Capture standard output: TRUE
[10:30:55.371] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:55.371] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:55.371] Packages: <none>
[10:30:55.371] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:55.371] Resolved: FALSE
[10:30:55.371] Value: <not collected>
[10:30:55.371] Conditions captured: <none>
[10:30:55.371] Early signaling: FALSE
[10:30:55.371] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:55.371] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.383] Chunk #1 of 2 ... DONE
[10:30:55.383] Chunk #2 of 2 ...
[10:30:55.383]  - Finding globals in '...' for chunk #2 ...
[10:30:55.383] getGlobalsAndPackages() ...
[10:30:55.383] Searching for globals...
[10:30:55.384] 
[10:30:55.384] Searching for globals ... DONE
[10:30:55.384] - globals: [0] <none>
[10:30:55.384] getGlobalsAndPackages() ... DONE
[10:30:55.384]    + additional globals found: [n=0] 
[10:30:55.384]    + additional namespaces needed: [n=0] 
[10:30:55.384]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:55.384]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:55.384]  - seeds: <none>
[10:30:55.384]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.385] getGlobalsAndPackages() ...
[10:30:55.385] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.385] Resolving globals: FALSE
[10:30:55.385] The total size of the 5 globals is 280 bytes (280 bytes)
[10:30:55.386] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:55.386] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.386] 
[10:30:55.386] getGlobalsAndPackages() ... DONE
[10:30:55.387] run() for ‘Future’ ...
[10:30:55.387] - state: ‘created’
[10:30:55.387] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:55.401] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:55.402]   - Field: ‘node’
[10:30:55.402]   - Field: ‘label’
[10:30:55.402]   - Field: ‘local’
[10:30:55.402]   - Field: ‘owner’
[10:30:55.402]   - Field: ‘envir’
[10:30:55.402]   - Field: ‘workers’
[10:30:55.402]   - Field: ‘packages’
[10:30:55.402]   - Field: ‘gc’
[10:30:55.402]   - Field: ‘conditions’
[10:30:55.402]   - Field: ‘persistent’
[10:30:55.403]   - Field: ‘expr’
[10:30:55.403]   - Field: ‘uuid’
[10:30:55.403]   - Field: ‘seed’
[10:30:55.403]   - Field: ‘version’
[10:30:55.403]   - Field: ‘result’
[10:30:55.403]   - Field: ‘asynchronous’
[10:30:55.403]   - Field: ‘calls’
[10:30:55.403]   - Field: ‘globals’
[10:30:55.403]   - Field: ‘stdout’
[10:30:55.403]   - Field: ‘earlySignal’
[10:30:55.403]   - Field: ‘lazy’
[10:30:55.404]   - Field: ‘state’
[10:30:55.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:55.404] - Launch lazy future ...
[10:30:55.404] Packages needed by the future expression (n = 0): <none>
[10:30:55.404] Packages needed by future strategies (n = 0): <none>
[10:30:55.405] {
[10:30:55.405]     {
[10:30:55.405]         {
[10:30:55.405]             ...future.startTime <- base::Sys.time()
[10:30:55.405]             {
[10:30:55.405]                 {
[10:30:55.405]                   {
[10:30:55.405]                     {
[10:30:55.405]                       base::local({
[10:30:55.405]                         has_future <- base::requireNamespace("future", 
[10:30:55.405]                           quietly = TRUE)
[10:30:55.405]                         if (has_future) {
[10:30:55.405]                           ns <- base::getNamespace("future")
[10:30:55.405]                           version <- ns[[".package"]][["version"]]
[10:30:55.405]                           if (is.null(version)) 
[10:30:55.405]                             version <- utils::packageVersion("future")
[10:30:55.405]                         }
[10:30:55.405]                         else {
[10:30:55.405]                           version <- NULL
[10:30:55.405]                         }
[10:30:55.405]                         if (!has_future || version < "1.8.0") {
[10:30:55.405]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:55.405]                             "", base::R.version$version.string), 
[10:30:55.405]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:55.405]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:55.405]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:55.405]                               "release", "version")], collapse = " "), 
[10:30:55.405]                             hostname = base::Sys.info()[["nodename"]])
[10:30:55.405]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:55.405]                             info)
[10:30:55.405]                           info <- base::paste(info, collapse = "; ")
[10:30:55.405]                           if (!has_future) {
[10:30:55.405]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:55.405]                               info)
[10:30:55.405]                           }
[10:30:55.405]                           else {
[10:30:55.405]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:55.405]                               info, version)
[10:30:55.405]                           }
[10:30:55.405]                           base::stop(msg)
[10:30:55.405]                         }
[10:30:55.405]                       })
[10:30:55.405]                     }
[10:30:55.405]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:55.405]                     base::options(mc.cores = 1L)
[10:30:55.405]                   }
[10:30:55.405]                   ...future.strategy.old <- future::plan("list")
[10:30:55.405]                   options(future.plan = NULL)
[10:30:55.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:55.405]                 }
[10:30:55.405]                 ...future.workdir <- getwd()
[10:30:55.405]             }
[10:30:55.405]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:55.405]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:55.405]         }
[10:30:55.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:55.405]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:55.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:55.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:55.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:55.405]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:55.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:55.405]             base::names(...future.oldOptions))
[10:30:55.405]     }
[10:30:55.405]     if (FALSE) {
[10:30:55.405]     }
[10:30:55.405]     else {
[10:30:55.405]         if (TRUE) {
[10:30:55.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:55.405]                 open = "w")
[10:30:55.405]         }
[10:30:55.405]         else {
[10:30:55.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:55.405]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:55.405]         }
[10:30:55.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:55.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:55.405]             base::sink(type = "output", split = FALSE)
[10:30:55.405]             base::close(...future.stdout)
[10:30:55.405]         }, add = TRUE)
[10:30:55.405]     }
[10:30:55.405]     ...future.frame <- base::sys.nframe()
[10:30:55.405]     ...future.conditions <- base::list()
[10:30:55.405]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:55.405]     if (FALSE) {
[10:30:55.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:55.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:55.405]     }
[10:30:55.405]     ...future.result <- base::tryCatch({
[10:30:55.405]         base::withCallingHandlers({
[10:30:55.405]             ...future.value <- base::withVisible(base::local({
[10:30:55.405]                 ...future.makeSendCondition <- base::local({
[10:30:55.405]                   sendCondition <- NULL
[10:30:55.405]                   function(frame = 1L) {
[10:30:55.405]                     if (is.function(sendCondition)) 
[10:30:55.405]                       return(sendCondition)
[10:30:55.405]                     ns <- getNamespace("parallel")
[10:30:55.405]                     if (exists("sendData", mode = "function", 
[10:30:55.405]                       envir = ns)) {
[10:30:55.405]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:55.405]                         envir = ns)
[10:30:55.405]                       envir <- sys.frame(frame)
[10:30:55.405]                       master <- NULL
[10:30:55.405]                       while (!identical(envir, .GlobalEnv) && 
[10:30:55.405]                         !identical(envir, emptyenv())) {
[10:30:55.405]                         if (exists("master", mode = "list", envir = envir, 
[10:30:55.405]                           inherits = FALSE)) {
[10:30:55.405]                           master <- get("master", mode = "list", 
[10:30:55.405]                             envir = envir, inherits = FALSE)
[10:30:55.405]                           if (inherits(master, c("SOCKnode", 
[10:30:55.405]                             "SOCK0node"))) {
[10:30:55.405]                             sendCondition <<- function(cond) {
[10:30:55.405]                               data <- list(type = "VALUE", value = cond, 
[10:30:55.405]                                 success = TRUE)
[10:30:55.405]                               parallel_sendData(master, data)
[10:30:55.405]                             }
[10:30:55.405]                             return(sendCondition)
[10:30:55.405]                           }
[10:30:55.405]                         }
[10:30:55.405]                         frame <- frame + 1L
[10:30:55.405]                         envir <- sys.frame(frame)
[10:30:55.405]                       }
[10:30:55.405]                     }
[10:30:55.405]                     sendCondition <<- function(cond) NULL
[10:30:55.405]                   }
[10:30:55.405]                 })
[10:30:55.405]                 withCallingHandlers({
[10:30:55.405]                   {
[10:30:55.405]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.405]                     if (!identical(...future.globals.maxSize.org, 
[10:30:55.405]                       ...future.globals.maxSize)) {
[10:30:55.405]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.405]                       on.exit(options(oopts), add = TRUE)
[10:30:55.405]                     }
[10:30:55.405]                     {
[10:30:55.405]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.405]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:55.405]                         USE.NAMES = FALSE)
[10:30:55.405]                       do.call(mapply, args = args)
[10:30:55.405]                     }
[10:30:55.405]                   }
[10:30:55.405]                 }, immediateCondition = function(cond) {
[10:30:55.405]                   sendCondition <- ...future.makeSendCondition()
[10:30:55.405]                   sendCondition(cond)
[10:30:55.405]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.405]                   {
[10:30:55.405]                     inherits <- base::inherits
[10:30:55.405]                     invokeRestart <- base::invokeRestart
[10:30:55.405]                     is.null <- base::is.null
[10:30:55.405]                     muffled <- FALSE
[10:30:55.405]                     if (inherits(cond, "message")) {
[10:30:55.405]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:55.405]                       if (muffled) 
[10:30:55.405]                         invokeRestart("muffleMessage")
[10:30:55.405]                     }
[10:30:55.405]                     else if (inherits(cond, "warning")) {
[10:30:55.405]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:55.405]                       if (muffled) 
[10:30:55.405]                         invokeRestart("muffleWarning")
[10:30:55.405]                     }
[10:30:55.405]                     else if (inherits(cond, "condition")) {
[10:30:55.405]                       if (!is.null(pattern)) {
[10:30:55.405]                         computeRestarts <- base::computeRestarts
[10:30:55.405]                         grepl <- base::grepl
[10:30:55.405]                         restarts <- computeRestarts(cond)
[10:30:55.405]                         for (restart in restarts) {
[10:30:55.405]                           name <- restart$name
[10:30:55.405]                           if (is.null(name)) 
[10:30:55.405]                             next
[10:30:55.405]                           if (!grepl(pattern, name)) 
[10:30:55.405]                             next
[10:30:55.405]                           invokeRestart(restart)
[10:30:55.405]                           muffled <- TRUE
[10:30:55.405]                           break
[10:30:55.405]                         }
[10:30:55.405]                       }
[10:30:55.405]                     }
[10:30:55.405]                     invisible(muffled)
[10:30:55.405]                   }
[10:30:55.405]                   muffleCondition(cond)
[10:30:55.405]                 })
[10:30:55.405]             }))
[10:30:55.405]             future::FutureResult(value = ...future.value$value, 
[10:30:55.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.405]                   ...future.rng), globalenv = if (FALSE) 
[10:30:55.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:55.405]                     ...future.globalenv.names))
[10:30:55.405]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:55.405]         }, condition = base::local({
[10:30:55.405]             c <- base::c
[10:30:55.405]             inherits <- base::inherits
[10:30:55.405]             invokeRestart <- base::invokeRestart
[10:30:55.405]             length <- base::length
[10:30:55.405]             list <- base::list
[10:30:55.405]             seq.int <- base::seq.int
[10:30:55.405]             signalCondition <- base::signalCondition
[10:30:55.405]             sys.calls <- base::sys.calls
[10:30:55.405]             `[[` <- base::`[[`
[10:30:55.405]             `+` <- base::`+`
[10:30:55.405]             `<<-` <- base::`<<-`
[10:30:55.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:55.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:55.405]                   3L)]
[10:30:55.405]             }
[10:30:55.405]             function(cond) {
[10:30:55.405]                 is_error <- inherits(cond, "error")
[10:30:55.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:55.405]                   NULL)
[10:30:55.405]                 if (is_error) {
[10:30:55.405]                   sessionInformation <- function() {
[10:30:55.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:55.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:55.405]                       search = base::search(), system = base::Sys.info())
[10:30:55.405]                   }
[10:30:55.405]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:55.405]                     cond$call), session = sessionInformation(), 
[10:30:55.405]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:55.405]                   signalCondition(cond)
[10:30:55.405]                 }
[10:30:55.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:55.405]                 "immediateCondition"))) {
[10:30:55.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:55.405]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:55.405]                   if (TRUE && !signal) {
[10:30:55.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.405]                     {
[10:30:55.405]                       inherits <- base::inherits
[10:30:55.405]                       invokeRestart <- base::invokeRestart
[10:30:55.405]                       is.null <- base::is.null
[10:30:55.405]                       muffled <- FALSE
[10:30:55.405]                       if (inherits(cond, "message")) {
[10:30:55.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.405]                         if (muffled) 
[10:30:55.405]                           invokeRestart("muffleMessage")
[10:30:55.405]                       }
[10:30:55.405]                       else if (inherits(cond, "warning")) {
[10:30:55.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.405]                         if (muffled) 
[10:30:55.405]                           invokeRestart("muffleWarning")
[10:30:55.405]                       }
[10:30:55.405]                       else if (inherits(cond, "condition")) {
[10:30:55.405]                         if (!is.null(pattern)) {
[10:30:55.405]                           computeRestarts <- base::computeRestarts
[10:30:55.405]                           grepl <- base::grepl
[10:30:55.405]                           restarts <- computeRestarts(cond)
[10:30:55.405]                           for (restart in restarts) {
[10:30:55.405]                             name <- restart$name
[10:30:55.405]                             if (is.null(name)) 
[10:30:55.405]                               next
[10:30:55.405]                             if (!grepl(pattern, name)) 
[10:30:55.405]                               next
[10:30:55.405]                             invokeRestart(restart)
[10:30:55.405]                             muffled <- TRUE
[10:30:55.405]                             break
[10:30:55.405]                           }
[10:30:55.405]                         }
[10:30:55.405]                       }
[10:30:55.405]                       invisible(muffled)
[10:30:55.405]                     }
[10:30:55.405]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.405]                   }
[10:30:55.405]                 }
[10:30:55.405]                 else {
[10:30:55.405]                   if (TRUE) {
[10:30:55.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.405]                     {
[10:30:55.405]                       inherits <- base::inherits
[10:30:55.405]                       invokeRestart <- base::invokeRestart
[10:30:55.405]                       is.null <- base::is.null
[10:30:55.405]                       muffled <- FALSE
[10:30:55.405]                       if (inherits(cond, "message")) {
[10:30:55.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.405]                         if (muffled) 
[10:30:55.405]                           invokeRestart("muffleMessage")
[10:30:55.405]                       }
[10:30:55.405]                       else if (inherits(cond, "warning")) {
[10:30:55.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.405]                         if (muffled) 
[10:30:55.405]                           invokeRestart("muffleWarning")
[10:30:55.405]                       }
[10:30:55.405]                       else if (inherits(cond, "condition")) {
[10:30:55.405]                         if (!is.null(pattern)) {
[10:30:55.405]                           computeRestarts <- base::computeRestarts
[10:30:55.405]                           grepl <- base::grepl
[10:30:55.405]                           restarts <- computeRestarts(cond)
[10:30:55.405]                           for (restart in restarts) {
[10:30:55.405]                             name <- restart$name
[10:30:55.405]                             if (is.null(name)) 
[10:30:55.405]                               next
[10:30:55.405]                             if (!grepl(pattern, name)) 
[10:30:55.405]                               next
[10:30:55.405]                             invokeRestart(restart)
[10:30:55.405]                             muffled <- TRUE
[10:30:55.405]                             break
[10:30:55.405]                           }
[10:30:55.405]                         }
[10:30:55.405]                       }
[10:30:55.405]                       invisible(muffled)
[10:30:55.405]                     }
[10:30:55.405]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.405]                   }
[10:30:55.405]                 }
[10:30:55.405]             }
[10:30:55.405]         }))
[10:30:55.405]     }, error = function(ex) {
[10:30:55.405]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:55.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.405]                 ...future.rng), started = ...future.startTime, 
[10:30:55.405]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:55.405]             version = "1.8"), class = "FutureResult")
[10:30:55.405]     }, finally = {
[10:30:55.405]         if (!identical(...future.workdir, getwd())) 
[10:30:55.405]             setwd(...future.workdir)
[10:30:55.405]         {
[10:30:55.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:55.405]                 ...future.oldOptions$nwarnings <- NULL
[10:30:55.405]             }
[10:30:55.405]             base::options(...future.oldOptions)
[10:30:55.405]             if (.Platform$OS.type == "windows") {
[10:30:55.405]                 old_names <- names(...future.oldEnvVars)
[10:30:55.405]                 envs <- base::Sys.getenv()
[10:30:55.405]                 names <- names(envs)
[10:30:55.405]                 common <- intersect(names, old_names)
[10:30:55.405]                 added <- setdiff(names, old_names)
[10:30:55.405]                 removed <- setdiff(old_names, names)
[10:30:55.405]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:55.405]                   envs[common]]
[10:30:55.405]                 NAMES <- toupper(changed)
[10:30:55.405]                 args <- list()
[10:30:55.405]                 for (kk in seq_along(NAMES)) {
[10:30:55.405]                   name <- changed[[kk]]
[10:30:55.405]                   NAME <- NAMES[[kk]]
[10:30:55.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.405]                     next
[10:30:55.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.405]                 }
[10:30:55.405]                 NAMES <- toupper(added)
[10:30:55.405]                 for (kk in seq_along(NAMES)) {
[10:30:55.405]                   name <- added[[kk]]
[10:30:55.405]                   NAME <- NAMES[[kk]]
[10:30:55.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.405]                     next
[10:30:55.405]                   args[[name]] <- ""
[10:30:55.405]                 }
[10:30:55.405]                 NAMES <- toupper(removed)
[10:30:55.405]                 for (kk in seq_along(NAMES)) {
[10:30:55.405]                   name <- removed[[kk]]
[10:30:55.405]                   NAME <- NAMES[[kk]]
[10:30:55.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.405]                     next
[10:30:55.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.405]                 }
[10:30:55.405]                 if (length(args) > 0) 
[10:30:55.405]                   base::do.call(base::Sys.setenv, args = args)
[10:30:55.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:55.405]             }
[10:30:55.405]             else {
[10:30:55.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:55.405]             }
[10:30:55.405]             {
[10:30:55.405]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:55.405]                   0L) {
[10:30:55.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:55.405]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:55.405]                   base::options(opts)
[10:30:55.405]                 }
[10:30:55.405]                 {
[10:30:55.405]                   {
[10:30:55.405]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:55.405]                     NULL
[10:30:55.405]                   }
[10:30:55.405]                   options(future.plan = NULL)
[10:30:55.405]                   if (is.na(NA_character_)) 
[10:30:55.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:55.405]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:55.405]                     .init = FALSE)
[10:30:55.405]                 }
[10:30:55.405]             }
[10:30:55.405]         }
[10:30:55.405]     })
[10:30:55.405]     if (TRUE) {
[10:30:55.405]         base::sink(type = "output", split = FALSE)
[10:30:55.405]         if (TRUE) {
[10:30:55.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:55.405]         }
[10:30:55.405]         else {
[10:30:55.405]             ...future.result["stdout"] <- base::list(NULL)
[10:30:55.405]         }
[10:30:55.405]         base::close(...future.stdout)
[10:30:55.405]         ...future.stdout <- NULL
[10:30:55.405]     }
[10:30:55.405]     ...future.result$conditions <- ...future.conditions
[10:30:55.405]     ...future.result$finished <- base::Sys.time()
[10:30:55.405]     ...future.result
[10:30:55.405] }
[10:30:55.408] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[10:30:55.408] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[10:30:55.408] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[10:30:55.408] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:55.409] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.409] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[10:30:55.409] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[10:30:55.409] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:55.410] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.410] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:55.410] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.410] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[10:30:55.411] MultisessionFuture started
[10:30:55.411] - Launch lazy future ... done
[10:30:55.411] run() for ‘MultisessionFuture’ ... done
[10:30:55.411] Created future:
[10:30:55.412] MultisessionFuture:
[10:30:55.412] Label: ‘future_Map-2’
[10:30:55.412] Expression:
[10:30:55.412] {
[10:30:55.412]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.412]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:55.412]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.412]         on.exit(options(oopts), add = TRUE)
[10:30:55.412]     }
[10:30:55.412]     {
[10:30:55.412]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.412]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:55.412]         do.call(mapply, args = args)
[10:30:55.412]     }
[10:30:55.412] }
[10:30:55.412] Lazy evaluation: FALSE
[10:30:55.412] Asynchronous evaluation: TRUE
[10:30:55.412] Local evaluation: TRUE
[10:30:55.412] Environment: R_GlobalEnv
[10:30:55.412] Capture standard output: TRUE
[10:30:55.412] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:55.412] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:55.412] Packages: <none>
[10:30:55.412] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:55.412] Resolved: FALSE
[10:30:55.412] Value: <not collected>
[10:30:55.412] Conditions captured: <none>
[10:30:55.412] Early signaling: FALSE
[10:30:55.412] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:55.412] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.423] Chunk #2 of 2 ... DONE
[10:30:55.423] Launching 2 futures (chunks) ... DONE
[10:30:55.423] Resolving 2 futures (chunks) ...
[10:30:55.423] resolve() on list ...
[10:30:55.424]  recursive: 0
[10:30:55.424]  length: 2
[10:30:55.424] 
[10:30:55.424] receiveMessageFromWorker() for ClusterFuture ...
[10:30:55.424] - Validating connection of MultisessionFuture
[10:30:55.425] - received message: FutureResult
[10:30:55.425] - Received FutureResult
[10:30:55.425] - Erased future from FutureRegistry
[10:30:55.425] result() for ClusterFuture ...
[10:30:55.425] - result already collected: FutureResult
[10:30:55.425] result() for ClusterFuture ... done
[10:30:55.425] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:55.425] Future #1
[10:30:55.425] result() for ClusterFuture ...
[10:30:55.426] - result already collected: FutureResult
[10:30:55.426] result() for ClusterFuture ... done
[10:30:55.426] result() for ClusterFuture ...
[10:30:55.426] - result already collected: FutureResult
[10:30:55.426] result() for ClusterFuture ... done
[10:30:55.426] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:55.426] - nx: 2
[10:30:55.426] - relay: TRUE
[10:30:55.426] - stdout: TRUE
[10:30:55.426] - signal: TRUE
[10:30:55.426] - resignal: FALSE
[10:30:55.426] - force: TRUE
[10:30:55.427] - relayed: [n=2] FALSE, FALSE
[10:30:55.427] - queued futures: [n=2] FALSE, FALSE
[10:30:55.427]  - until=1
[10:30:55.427]  - relaying element #1
[10:30:55.427] result() for ClusterFuture ...
[10:30:55.427] - result already collected: FutureResult
[10:30:55.427] result() for ClusterFuture ... done
[10:30:55.427] result() for ClusterFuture ...
[10:30:55.427] - result already collected: FutureResult
[10:30:55.427] result() for ClusterFuture ... done
[10:30:55.427] result() for ClusterFuture ...
[10:30:55.428] - result already collected: FutureResult
[10:30:55.428] result() for ClusterFuture ... done
[10:30:55.428] result() for ClusterFuture ...
[10:30:55.428] - result already collected: FutureResult
[10:30:55.428] result() for ClusterFuture ... done
[10:30:55.428] - relayed: [n=2] TRUE, FALSE
[10:30:55.428] - queued futures: [n=2] TRUE, FALSE
[10:30:55.428] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:55.428]  length: 1 (resolved future 1)
[10:30:55.455] receiveMessageFromWorker() for ClusterFuture ...
[10:30:55.455] - Validating connection of MultisessionFuture
[10:30:55.455] - received message: FutureResult
[10:30:55.455] - Received FutureResult
[10:30:55.455] - Erased future from FutureRegistry
[10:30:55.455] result() for ClusterFuture ...
[10:30:55.455] - result already collected: FutureResult
[10:30:55.456] result() for ClusterFuture ... done
[10:30:55.456] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:55.456] Future #2
[10:30:55.456] result() for ClusterFuture ...
[10:30:55.456] - result already collected: FutureResult
[10:30:55.456] result() for ClusterFuture ... done
[10:30:55.456] result() for ClusterFuture ...
[10:30:55.456] - result already collected: FutureResult
[10:30:55.456] result() for ClusterFuture ... done
[10:30:55.456] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:55.456] - nx: 2
[10:30:55.457] - relay: TRUE
[10:30:55.457] - stdout: TRUE
[10:30:55.457] - signal: TRUE
[10:30:55.457] - resignal: FALSE
[10:30:55.457] - force: TRUE
[10:30:55.457] - relayed: [n=2] TRUE, FALSE
[10:30:55.457] - queued futures: [n=2] TRUE, FALSE
[10:30:55.457]  - until=2
[10:30:55.457]  - relaying element #2
[10:30:55.457] result() for ClusterFuture ...
[10:30:55.457] - result already collected: FutureResult
[10:30:55.458] result() for ClusterFuture ... done
[10:30:55.458] result() for ClusterFuture ...
[10:30:55.458] - result already collected: FutureResult
[10:30:55.458] result() for ClusterFuture ... done
[10:30:55.458] result() for ClusterFuture ...
[10:30:55.458] - result already collected: FutureResult
[10:30:55.458] result() for ClusterFuture ... done
[10:30:55.458] result() for ClusterFuture ...
[10:30:55.458] - result already collected: FutureResult
[10:30:55.458] result() for ClusterFuture ... done
[10:30:55.458] - relayed: [n=2] TRUE, TRUE
[10:30:55.459] - queued futures: [n=2] TRUE, TRUE
[10:30:55.459] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:55.459]  length: 0 (resolved future 2)
[10:30:55.459] Relaying remaining futures
[10:30:55.459] signalConditionsASAP(NULL, pos=0) ...
[10:30:55.459] - nx: 2
[10:30:55.459] - relay: TRUE
[10:30:55.459] - stdout: TRUE
[10:30:55.459] - signal: TRUE
[10:30:55.459] - resignal: FALSE
[10:30:55.459] - force: TRUE
[10:30:55.459] - relayed: [n=2] TRUE, TRUE
[10:30:55.460] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:55.460] - relayed: [n=2] TRUE, TRUE
[10:30:55.460] - queued futures: [n=2] TRUE, TRUE
[10:30:55.460] signalConditionsASAP(NULL, pos=0) ... done
[10:30:55.460] resolve() on list ... DONE
[10:30:55.460] result() for ClusterFuture ...
[10:30:55.460] - result already collected: FutureResult
[10:30:55.460] result() for ClusterFuture ... done
[10:30:55.460] result() for ClusterFuture ...
[10:30:55.460] - result already collected: FutureResult
[10:30:55.461] result() for ClusterFuture ... done
[10:30:55.461] result() for ClusterFuture ...
[10:30:55.461] - result already collected: FutureResult
[10:30:55.461] result() for ClusterFuture ... done
[10:30:55.461] result() for ClusterFuture ...
[10:30:55.461] - result already collected: FutureResult
[10:30:55.461] result() for ClusterFuture ... done
[10:30:55.461]  - Number of value chunks collected: 2
[10:30:55.461] Resolving 2 futures (chunks) ... DONE
[10:30:55.461] Reducing values from 2 chunks ...
[10:30:55.461]  - Number of values collected after concatenation: 3
[10:30:55.462]  - Number of values expected: 3
[10:30:55.462] Reducing values from 2 chunks ... DONE
[10:30:55.462] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[10:30:55.462] future_mapply() ...
[10:30:55.467] Number of chunks: 2
[10:30:55.467] getGlobalsAndPackagesXApply() ...
[10:30:55.467]  - future.globals: TRUE
[10:30:55.467] getGlobalsAndPackages() ...
[10:30:55.467] Searching for globals...
[10:30:55.468] - globals found: [1] ‘FUN’
[10:30:55.468] Searching for globals ... DONE
[10:30:55.469] Resolving globals: FALSE
[10:30:55.469] The total size of the 1 globals is 848 bytes (848 bytes)
[10:30:55.469] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:30:55.469] - globals: [1] ‘FUN’
[10:30:55.469] 
[10:30:55.470] getGlobalsAndPackages() ... DONE
[10:30:55.470]  - globals found/used: [n=1] ‘FUN’
[10:30:55.470]  - needed namespaces: [n=0] 
[10:30:55.470] Finding globals ... DONE
[10:30:55.470] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:30:55.470] List of 2
[10:30:55.470]  $ ...future.FUN:function (x)  
[10:30:55.470]  $ MoreArgs     : NULL
[10:30:55.470]  - attr(*, "where")=List of 2
[10:30:55.470]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:30:55.470]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:30:55.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:30:55.470]  - attr(*, "resolved")= logi FALSE
[10:30:55.470]  - attr(*, "total_size")= num NA
[10:30:55.473] Packages to be attached in all futures: [n=0] 
[10:30:55.473] getGlobalsAndPackagesXApply() ... DONE
[10:30:55.473] Number of futures (= number of chunks): 2
[10:30:55.473] Launching 2 futures (chunks) ...
[10:30:55.473] Chunk #1 of 2 ...
[10:30:55.473]  - Finding globals in '...' for chunk #1 ...
[10:30:55.474] getGlobalsAndPackages() ...
[10:30:55.474] Searching for globals...
[10:30:55.474] 
[10:30:55.474] Searching for globals ... DONE
[10:30:55.474] - globals: [0] <none>
[10:30:55.474] getGlobalsAndPackages() ... DONE
[10:30:55.474]    + additional globals found: [n=0] 
[10:30:55.474]    + additional namespaces needed: [n=0] 
[10:30:55.474]  - Finding globals in '...' for chunk #1 ... DONE
[10:30:55.475]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:55.475]  - seeds: <none>
[10:30:55.475]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.475] getGlobalsAndPackages() ...
[10:30:55.475] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.475] Resolving globals: FALSE
[10:30:55.476] The total size of the 5 globals is 904 bytes (904 bytes)
[10:30:55.476] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:55.476] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.476] 
[10:30:55.476] getGlobalsAndPackages() ... DONE
[10:30:55.477] run() for ‘Future’ ...
[10:30:55.477] - state: ‘created’
[10:30:55.477] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:55.494] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:55.494]   - Field: ‘node’
[10:30:55.494]   - Field: ‘label’
[10:30:55.494]   - Field: ‘local’
[10:30:55.494]   - Field: ‘owner’
[10:30:55.494]   - Field: ‘envir’
[10:30:55.494]   - Field: ‘workers’
[10:30:55.495]   - Field: ‘packages’
[10:30:55.495]   - Field: ‘gc’
[10:30:55.495]   - Field: ‘conditions’
[10:30:55.495]   - Field: ‘persistent’
[10:30:55.495]   - Field: ‘expr’
[10:30:55.495]   - Field: ‘uuid’
[10:30:55.495]   - Field: ‘seed’
[10:30:55.495]   - Field: ‘version’
[10:30:55.495]   - Field: ‘result’
[10:30:55.495]   - Field: ‘asynchronous’
[10:30:55.495]   - Field: ‘calls’
[10:30:55.496]   - Field: ‘globals’
[10:30:55.496]   - Field: ‘stdout’
[10:30:55.496]   - Field: ‘earlySignal’
[10:30:55.496]   - Field: ‘lazy’
[10:30:55.496]   - Field: ‘state’
[10:30:55.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:55.496] - Launch lazy future ...
[10:30:55.496] Packages needed by the future expression (n = 0): <none>
[10:30:55.496] Packages needed by future strategies (n = 0): <none>
[10:30:55.497] {
[10:30:55.497]     {
[10:30:55.497]         {
[10:30:55.497]             ...future.startTime <- base::Sys.time()
[10:30:55.497]             {
[10:30:55.497]                 {
[10:30:55.497]                   {
[10:30:55.497]                     {
[10:30:55.497]                       base::local({
[10:30:55.497]                         has_future <- base::requireNamespace("future", 
[10:30:55.497]                           quietly = TRUE)
[10:30:55.497]                         if (has_future) {
[10:30:55.497]                           ns <- base::getNamespace("future")
[10:30:55.497]                           version <- ns[[".package"]][["version"]]
[10:30:55.497]                           if (is.null(version)) 
[10:30:55.497]                             version <- utils::packageVersion("future")
[10:30:55.497]                         }
[10:30:55.497]                         else {
[10:30:55.497]                           version <- NULL
[10:30:55.497]                         }
[10:30:55.497]                         if (!has_future || version < "1.8.0") {
[10:30:55.497]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:55.497]                             "", base::R.version$version.string), 
[10:30:55.497]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:55.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:55.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:55.497]                               "release", "version")], collapse = " "), 
[10:30:55.497]                             hostname = base::Sys.info()[["nodename"]])
[10:30:55.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:55.497]                             info)
[10:30:55.497]                           info <- base::paste(info, collapse = "; ")
[10:30:55.497]                           if (!has_future) {
[10:30:55.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:55.497]                               info)
[10:30:55.497]                           }
[10:30:55.497]                           else {
[10:30:55.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:55.497]                               info, version)
[10:30:55.497]                           }
[10:30:55.497]                           base::stop(msg)
[10:30:55.497]                         }
[10:30:55.497]                       })
[10:30:55.497]                     }
[10:30:55.497]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:55.497]                     base::options(mc.cores = 1L)
[10:30:55.497]                   }
[10:30:55.497]                   ...future.strategy.old <- future::plan("list")
[10:30:55.497]                   options(future.plan = NULL)
[10:30:55.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:55.497]                 }
[10:30:55.497]                 ...future.workdir <- getwd()
[10:30:55.497]             }
[10:30:55.497]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:55.497]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:55.497]         }
[10:30:55.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:55.497]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:55.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:55.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:55.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:55.497]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:55.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:55.497]             base::names(...future.oldOptions))
[10:30:55.497]     }
[10:30:55.497]     if (FALSE) {
[10:30:55.497]     }
[10:30:55.497]     else {
[10:30:55.497]         if (TRUE) {
[10:30:55.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:55.497]                 open = "w")
[10:30:55.497]         }
[10:30:55.497]         else {
[10:30:55.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:55.497]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:55.497]         }
[10:30:55.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:55.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:55.497]             base::sink(type = "output", split = FALSE)
[10:30:55.497]             base::close(...future.stdout)
[10:30:55.497]         }, add = TRUE)
[10:30:55.497]     }
[10:30:55.497]     ...future.frame <- base::sys.nframe()
[10:30:55.497]     ...future.conditions <- base::list()
[10:30:55.497]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:55.497]     if (FALSE) {
[10:30:55.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:55.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:55.497]     }
[10:30:55.497]     ...future.result <- base::tryCatch({
[10:30:55.497]         base::withCallingHandlers({
[10:30:55.497]             ...future.value <- base::withVisible(base::local({
[10:30:55.497]                 ...future.makeSendCondition <- base::local({
[10:30:55.497]                   sendCondition <- NULL
[10:30:55.497]                   function(frame = 1L) {
[10:30:55.497]                     if (is.function(sendCondition)) 
[10:30:55.497]                       return(sendCondition)
[10:30:55.497]                     ns <- getNamespace("parallel")
[10:30:55.497]                     if (exists("sendData", mode = "function", 
[10:30:55.497]                       envir = ns)) {
[10:30:55.497]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:55.497]                         envir = ns)
[10:30:55.497]                       envir <- sys.frame(frame)
[10:30:55.497]                       master <- NULL
[10:30:55.497]                       while (!identical(envir, .GlobalEnv) && 
[10:30:55.497]                         !identical(envir, emptyenv())) {
[10:30:55.497]                         if (exists("master", mode = "list", envir = envir, 
[10:30:55.497]                           inherits = FALSE)) {
[10:30:55.497]                           master <- get("master", mode = "list", 
[10:30:55.497]                             envir = envir, inherits = FALSE)
[10:30:55.497]                           if (inherits(master, c("SOCKnode", 
[10:30:55.497]                             "SOCK0node"))) {
[10:30:55.497]                             sendCondition <<- function(cond) {
[10:30:55.497]                               data <- list(type = "VALUE", value = cond, 
[10:30:55.497]                                 success = TRUE)
[10:30:55.497]                               parallel_sendData(master, data)
[10:30:55.497]                             }
[10:30:55.497]                             return(sendCondition)
[10:30:55.497]                           }
[10:30:55.497]                         }
[10:30:55.497]                         frame <- frame + 1L
[10:30:55.497]                         envir <- sys.frame(frame)
[10:30:55.497]                       }
[10:30:55.497]                     }
[10:30:55.497]                     sendCondition <<- function(cond) NULL
[10:30:55.497]                   }
[10:30:55.497]                 })
[10:30:55.497]                 withCallingHandlers({
[10:30:55.497]                   {
[10:30:55.497]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.497]                     if (!identical(...future.globals.maxSize.org, 
[10:30:55.497]                       ...future.globals.maxSize)) {
[10:30:55.497]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.497]                       on.exit(options(oopts), add = TRUE)
[10:30:55.497]                     }
[10:30:55.497]                     {
[10:30:55.497]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.497]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:55.497]                         USE.NAMES = FALSE)
[10:30:55.497]                       do.call(mapply, args = args)
[10:30:55.497]                     }
[10:30:55.497]                   }
[10:30:55.497]                 }, immediateCondition = function(cond) {
[10:30:55.497]                   sendCondition <- ...future.makeSendCondition()
[10:30:55.497]                   sendCondition(cond)
[10:30:55.497]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.497]                   {
[10:30:55.497]                     inherits <- base::inherits
[10:30:55.497]                     invokeRestart <- base::invokeRestart
[10:30:55.497]                     is.null <- base::is.null
[10:30:55.497]                     muffled <- FALSE
[10:30:55.497]                     if (inherits(cond, "message")) {
[10:30:55.497]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:55.497]                       if (muffled) 
[10:30:55.497]                         invokeRestart("muffleMessage")
[10:30:55.497]                     }
[10:30:55.497]                     else if (inherits(cond, "warning")) {
[10:30:55.497]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:55.497]                       if (muffled) 
[10:30:55.497]                         invokeRestart("muffleWarning")
[10:30:55.497]                     }
[10:30:55.497]                     else if (inherits(cond, "condition")) {
[10:30:55.497]                       if (!is.null(pattern)) {
[10:30:55.497]                         computeRestarts <- base::computeRestarts
[10:30:55.497]                         grepl <- base::grepl
[10:30:55.497]                         restarts <- computeRestarts(cond)
[10:30:55.497]                         for (restart in restarts) {
[10:30:55.497]                           name <- restart$name
[10:30:55.497]                           if (is.null(name)) 
[10:30:55.497]                             next
[10:30:55.497]                           if (!grepl(pattern, name)) 
[10:30:55.497]                             next
[10:30:55.497]                           invokeRestart(restart)
[10:30:55.497]                           muffled <- TRUE
[10:30:55.497]                           break
[10:30:55.497]                         }
[10:30:55.497]                       }
[10:30:55.497]                     }
[10:30:55.497]                     invisible(muffled)
[10:30:55.497]                   }
[10:30:55.497]                   muffleCondition(cond)
[10:30:55.497]                 })
[10:30:55.497]             }))
[10:30:55.497]             future::FutureResult(value = ...future.value$value, 
[10:30:55.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.497]                   ...future.rng), globalenv = if (FALSE) 
[10:30:55.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:55.497]                     ...future.globalenv.names))
[10:30:55.497]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:55.497]         }, condition = base::local({
[10:30:55.497]             c <- base::c
[10:30:55.497]             inherits <- base::inherits
[10:30:55.497]             invokeRestart <- base::invokeRestart
[10:30:55.497]             length <- base::length
[10:30:55.497]             list <- base::list
[10:30:55.497]             seq.int <- base::seq.int
[10:30:55.497]             signalCondition <- base::signalCondition
[10:30:55.497]             sys.calls <- base::sys.calls
[10:30:55.497]             `[[` <- base::`[[`
[10:30:55.497]             `+` <- base::`+`
[10:30:55.497]             `<<-` <- base::`<<-`
[10:30:55.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:55.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:55.497]                   3L)]
[10:30:55.497]             }
[10:30:55.497]             function(cond) {
[10:30:55.497]                 is_error <- inherits(cond, "error")
[10:30:55.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:55.497]                   NULL)
[10:30:55.497]                 if (is_error) {
[10:30:55.497]                   sessionInformation <- function() {
[10:30:55.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:55.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:55.497]                       search = base::search(), system = base::Sys.info())
[10:30:55.497]                   }
[10:30:55.497]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:55.497]                     cond$call), session = sessionInformation(), 
[10:30:55.497]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:55.497]                   signalCondition(cond)
[10:30:55.497]                 }
[10:30:55.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:55.497]                 "immediateCondition"))) {
[10:30:55.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:55.497]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:55.497]                   if (TRUE && !signal) {
[10:30:55.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.497]                     {
[10:30:55.497]                       inherits <- base::inherits
[10:30:55.497]                       invokeRestart <- base::invokeRestart
[10:30:55.497]                       is.null <- base::is.null
[10:30:55.497]                       muffled <- FALSE
[10:30:55.497]                       if (inherits(cond, "message")) {
[10:30:55.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.497]                         if (muffled) 
[10:30:55.497]                           invokeRestart("muffleMessage")
[10:30:55.497]                       }
[10:30:55.497]                       else if (inherits(cond, "warning")) {
[10:30:55.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.497]                         if (muffled) 
[10:30:55.497]                           invokeRestart("muffleWarning")
[10:30:55.497]                       }
[10:30:55.497]                       else if (inherits(cond, "condition")) {
[10:30:55.497]                         if (!is.null(pattern)) {
[10:30:55.497]                           computeRestarts <- base::computeRestarts
[10:30:55.497]                           grepl <- base::grepl
[10:30:55.497]                           restarts <- computeRestarts(cond)
[10:30:55.497]                           for (restart in restarts) {
[10:30:55.497]                             name <- restart$name
[10:30:55.497]                             if (is.null(name)) 
[10:30:55.497]                               next
[10:30:55.497]                             if (!grepl(pattern, name)) 
[10:30:55.497]                               next
[10:30:55.497]                             invokeRestart(restart)
[10:30:55.497]                             muffled <- TRUE
[10:30:55.497]                             break
[10:30:55.497]                           }
[10:30:55.497]                         }
[10:30:55.497]                       }
[10:30:55.497]                       invisible(muffled)
[10:30:55.497]                     }
[10:30:55.497]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.497]                   }
[10:30:55.497]                 }
[10:30:55.497]                 else {
[10:30:55.497]                   if (TRUE) {
[10:30:55.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.497]                     {
[10:30:55.497]                       inherits <- base::inherits
[10:30:55.497]                       invokeRestart <- base::invokeRestart
[10:30:55.497]                       is.null <- base::is.null
[10:30:55.497]                       muffled <- FALSE
[10:30:55.497]                       if (inherits(cond, "message")) {
[10:30:55.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.497]                         if (muffled) 
[10:30:55.497]                           invokeRestart("muffleMessage")
[10:30:55.497]                       }
[10:30:55.497]                       else if (inherits(cond, "warning")) {
[10:30:55.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.497]                         if (muffled) 
[10:30:55.497]                           invokeRestart("muffleWarning")
[10:30:55.497]                       }
[10:30:55.497]                       else if (inherits(cond, "condition")) {
[10:30:55.497]                         if (!is.null(pattern)) {
[10:30:55.497]                           computeRestarts <- base::computeRestarts
[10:30:55.497]                           grepl <- base::grepl
[10:30:55.497]                           restarts <- computeRestarts(cond)
[10:30:55.497]                           for (restart in restarts) {
[10:30:55.497]                             name <- restart$name
[10:30:55.497]                             if (is.null(name)) 
[10:30:55.497]                               next
[10:30:55.497]                             if (!grepl(pattern, name)) 
[10:30:55.497]                               next
[10:30:55.497]                             invokeRestart(restart)
[10:30:55.497]                             muffled <- TRUE
[10:30:55.497]                             break
[10:30:55.497]                           }
[10:30:55.497]                         }
[10:30:55.497]                       }
[10:30:55.497]                       invisible(muffled)
[10:30:55.497]                     }
[10:30:55.497]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.497]                   }
[10:30:55.497]                 }
[10:30:55.497]             }
[10:30:55.497]         }))
[10:30:55.497]     }, error = function(ex) {
[10:30:55.497]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:55.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.497]                 ...future.rng), started = ...future.startTime, 
[10:30:55.497]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:55.497]             version = "1.8"), class = "FutureResult")
[10:30:55.497]     }, finally = {
[10:30:55.497]         if (!identical(...future.workdir, getwd())) 
[10:30:55.497]             setwd(...future.workdir)
[10:30:55.497]         {
[10:30:55.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:55.497]                 ...future.oldOptions$nwarnings <- NULL
[10:30:55.497]             }
[10:30:55.497]             base::options(...future.oldOptions)
[10:30:55.497]             if (.Platform$OS.type == "windows") {
[10:30:55.497]                 old_names <- names(...future.oldEnvVars)
[10:30:55.497]                 envs <- base::Sys.getenv()
[10:30:55.497]                 names <- names(envs)
[10:30:55.497]                 common <- intersect(names, old_names)
[10:30:55.497]                 added <- setdiff(names, old_names)
[10:30:55.497]                 removed <- setdiff(old_names, names)
[10:30:55.497]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:55.497]                   envs[common]]
[10:30:55.497]                 NAMES <- toupper(changed)
[10:30:55.497]                 args <- list()
[10:30:55.497]                 for (kk in seq_along(NAMES)) {
[10:30:55.497]                   name <- changed[[kk]]
[10:30:55.497]                   NAME <- NAMES[[kk]]
[10:30:55.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.497]                     next
[10:30:55.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.497]                 }
[10:30:55.497]                 NAMES <- toupper(added)
[10:30:55.497]                 for (kk in seq_along(NAMES)) {
[10:30:55.497]                   name <- added[[kk]]
[10:30:55.497]                   NAME <- NAMES[[kk]]
[10:30:55.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.497]                     next
[10:30:55.497]                   args[[name]] <- ""
[10:30:55.497]                 }
[10:30:55.497]                 NAMES <- toupper(removed)
[10:30:55.497]                 for (kk in seq_along(NAMES)) {
[10:30:55.497]                   name <- removed[[kk]]
[10:30:55.497]                   NAME <- NAMES[[kk]]
[10:30:55.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.497]                     next
[10:30:55.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.497]                 }
[10:30:55.497]                 if (length(args) > 0) 
[10:30:55.497]                   base::do.call(base::Sys.setenv, args = args)
[10:30:55.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:55.497]             }
[10:30:55.497]             else {
[10:30:55.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:55.497]             }
[10:30:55.497]             {
[10:30:55.497]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:55.497]                   0L) {
[10:30:55.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:55.497]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:55.497]                   base::options(opts)
[10:30:55.497]                 }
[10:30:55.497]                 {
[10:30:55.497]                   {
[10:30:55.497]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:55.497]                     NULL
[10:30:55.497]                   }
[10:30:55.497]                   options(future.plan = NULL)
[10:30:55.497]                   if (is.na(NA_character_)) 
[10:30:55.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:55.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:55.497]                     .init = FALSE)
[10:30:55.497]                 }
[10:30:55.497]             }
[10:30:55.497]         }
[10:30:55.497]     })
[10:30:55.497]     if (TRUE) {
[10:30:55.497]         base::sink(type = "output", split = FALSE)
[10:30:55.497]         if (TRUE) {
[10:30:55.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:55.497]         }
[10:30:55.497]         else {
[10:30:55.497]             ...future.result["stdout"] <- base::list(NULL)
[10:30:55.497]         }
[10:30:55.497]         base::close(...future.stdout)
[10:30:55.497]         ...future.stdout <- NULL
[10:30:55.497]     }
[10:30:55.497]     ...future.result$conditions <- ...future.conditions
[10:30:55.497]     ...future.result$finished <- base::Sys.time()
[10:30:55.497]     ...future.result
[10:30:55.497] }
[10:30:55.500] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[10:30:55.500] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:30:55.500] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:30:55.500] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:30:55.501] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:30:55.501] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:30:55.501] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:30:55.501] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:30:55.502] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:30:55.502] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:30:55.502] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:30:55.502] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[10:30:55.503] MultisessionFuture started
[10:30:55.503] - Launch lazy future ... done
[10:30:55.503] run() for ‘MultisessionFuture’ ... done
[10:30:55.503] Created future:
[10:30:55.503] MultisessionFuture:
[10:30:55.503] Label: ‘future_mapply-1’
[10:30:55.503] Expression:
[10:30:55.503] {
[10:30:55.503]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.503]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:55.503]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.503]         on.exit(options(oopts), add = TRUE)
[10:30:55.503]     }
[10:30:55.503]     {
[10:30:55.503]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.503]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:55.503]         do.call(mapply, args = args)
[10:30:55.503]     }
[10:30:55.503] }
[10:30:55.503] Lazy evaluation: FALSE
[10:30:55.503] Asynchronous evaluation: TRUE
[10:30:55.503] Local evaluation: TRUE
[10:30:55.503] Environment: R_GlobalEnv
[10:30:55.503] Capture standard output: TRUE
[10:30:55.503] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:55.503] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:55.503] Packages: <none>
[10:30:55.503] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:55.503] Resolved: FALSE
[10:30:55.503] Value: <not collected>
[10:30:55.503] Conditions captured: <none>
[10:30:55.503] Early signaling: FALSE
[10:30:55.503] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:55.503] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.515] Chunk #1 of 2 ... DONE
[10:30:55.515] Chunk #2 of 2 ...
[10:30:55.515]  - Finding globals in '...' for chunk #2 ...
[10:30:55.515] getGlobalsAndPackages() ...
[10:30:55.515] Searching for globals...
[10:30:55.515] 
[10:30:55.516] Searching for globals ... DONE
[10:30:55.516] - globals: [0] <none>
[10:30:55.516] getGlobalsAndPackages() ... DONE
[10:30:55.516]    + additional globals found: [n=0] 
[10:30:55.516]    + additional namespaces needed: [n=0] 
[10:30:55.516]  - Finding globals in '...' for chunk #2 ... DONE
[10:30:55.516]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:30:55.516]  - seeds: <none>
[10:30:55.516]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.516] getGlobalsAndPackages() ...
[10:30:55.516] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.517] Resolving globals: FALSE
[10:30:55.517] The total size of the 5 globals is 904 bytes (904 bytes)
[10:30:55.518] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:30:55.518] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:30:55.518] 
[10:30:55.518] getGlobalsAndPackages() ... DONE
[10:30:55.518] run() for ‘Future’ ...
[10:30:55.518] - state: ‘created’
[10:30:55.518] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:30:55.533] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:30:55.533]   - Field: ‘node’
[10:30:55.533]   - Field: ‘label’
[10:30:55.533]   - Field: ‘local’
[10:30:55.533]   - Field: ‘owner’
[10:30:55.534]   - Field: ‘envir’
[10:30:55.534]   - Field: ‘workers’
[10:30:55.534]   - Field: ‘packages’
[10:30:55.534]   - Field: ‘gc’
[10:30:55.534]   - Field: ‘conditions’
[10:30:55.534]   - Field: ‘persistent’
[10:30:55.534]   - Field: ‘expr’
[10:30:55.534]   - Field: ‘uuid’
[10:30:55.534]   - Field: ‘seed’
[10:30:55.534]   - Field: ‘version’
[10:30:55.534]   - Field: ‘result’
[10:30:55.535]   - Field: ‘asynchronous’
[10:30:55.535]   - Field: ‘calls’
[10:30:55.535]   - Field: ‘globals’
[10:30:55.535]   - Field: ‘stdout’
[10:30:55.535]   - Field: ‘earlySignal’
[10:30:55.535]   - Field: ‘lazy’
[10:30:55.535]   - Field: ‘state’
[10:30:55.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:30:55.535] - Launch lazy future ...
[10:30:55.536] Packages needed by the future expression (n = 0): <none>
[10:30:55.536] Packages needed by future strategies (n = 0): <none>
[10:30:55.536] {
[10:30:55.536]     {
[10:30:55.536]         {
[10:30:55.536]             ...future.startTime <- base::Sys.time()
[10:30:55.536]             {
[10:30:55.536]                 {
[10:30:55.536]                   {
[10:30:55.536]                     {
[10:30:55.536]                       base::local({
[10:30:55.536]                         has_future <- base::requireNamespace("future", 
[10:30:55.536]                           quietly = TRUE)
[10:30:55.536]                         if (has_future) {
[10:30:55.536]                           ns <- base::getNamespace("future")
[10:30:55.536]                           version <- ns[[".package"]][["version"]]
[10:30:55.536]                           if (is.null(version)) 
[10:30:55.536]                             version <- utils::packageVersion("future")
[10:30:55.536]                         }
[10:30:55.536]                         else {
[10:30:55.536]                           version <- NULL
[10:30:55.536]                         }
[10:30:55.536]                         if (!has_future || version < "1.8.0") {
[10:30:55.536]                           info <- base::c(r_version = base::gsub("R version ", 
[10:30:55.536]                             "", base::R.version$version.string), 
[10:30:55.536]                             platform = base::sprintf("%s (%s-bit)", 
[10:30:55.536]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:30:55.536]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:30:55.536]                               "release", "version")], collapse = " "), 
[10:30:55.536]                             hostname = base::Sys.info()[["nodename"]])
[10:30:55.536]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:30:55.536]                             info)
[10:30:55.536]                           info <- base::paste(info, collapse = "; ")
[10:30:55.536]                           if (!has_future) {
[10:30:55.536]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:30:55.536]                               info)
[10:30:55.536]                           }
[10:30:55.536]                           else {
[10:30:55.536]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:30:55.536]                               info, version)
[10:30:55.536]                           }
[10:30:55.536]                           base::stop(msg)
[10:30:55.536]                         }
[10:30:55.536]                       })
[10:30:55.536]                     }
[10:30:55.536]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:30:55.536]                     base::options(mc.cores = 1L)
[10:30:55.536]                   }
[10:30:55.536]                   ...future.strategy.old <- future::plan("list")
[10:30:55.536]                   options(future.plan = NULL)
[10:30:55.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:30:55.536]                 }
[10:30:55.536]                 ...future.workdir <- getwd()
[10:30:55.536]             }
[10:30:55.536]             ...future.oldOptions <- base::as.list(base::.Options)
[10:30:55.536]             ...future.oldEnvVars <- base::Sys.getenv()
[10:30:55.536]         }
[10:30:55.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:30:55.536]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:30:55.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:30:55.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:30:55.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:30:55.536]             future.stdout.windows.reencode = NULL, width = 80L)
[10:30:55.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:30:55.536]             base::names(...future.oldOptions))
[10:30:55.536]     }
[10:30:55.536]     if (FALSE) {
[10:30:55.536]     }
[10:30:55.536]     else {
[10:30:55.536]         if (TRUE) {
[10:30:55.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:30:55.536]                 open = "w")
[10:30:55.536]         }
[10:30:55.536]         else {
[10:30:55.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:30:55.536]                 windows = "NUL", "/dev/null"), open = "w")
[10:30:55.536]         }
[10:30:55.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:30:55.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:30:55.536]             base::sink(type = "output", split = FALSE)
[10:30:55.536]             base::close(...future.stdout)
[10:30:55.536]         }, add = TRUE)
[10:30:55.536]     }
[10:30:55.536]     ...future.frame <- base::sys.nframe()
[10:30:55.536]     ...future.conditions <- base::list()
[10:30:55.536]     ...future.rng <- base::globalenv()$.Random.seed
[10:30:55.536]     if (FALSE) {
[10:30:55.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:30:55.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:30:55.536]     }
[10:30:55.536]     ...future.result <- base::tryCatch({
[10:30:55.536]         base::withCallingHandlers({
[10:30:55.536]             ...future.value <- base::withVisible(base::local({
[10:30:55.536]                 ...future.makeSendCondition <- base::local({
[10:30:55.536]                   sendCondition <- NULL
[10:30:55.536]                   function(frame = 1L) {
[10:30:55.536]                     if (is.function(sendCondition)) 
[10:30:55.536]                       return(sendCondition)
[10:30:55.536]                     ns <- getNamespace("parallel")
[10:30:55.536]                     if (exists("sendData", mode = "function", 
[10:30:55.536]                       envir = ns)) {
[10:30:55.536]                       parallel_sendData <- get("sendData", mode = "function", 
[10:30:55.536]                         envir = ns)
[10:30:55.536]                       envir <- sys.frame(frame)
[10:30:55.536]                       master <- NULL
[10:30:55.536]                       while (!identical(envir, .GlobalEnv) && 
[10:30:55.536]                         !identical(envir, emptyenv())) {
[10:30:55.536]                         if (exists("master", mode = "list", envir = envir, 
[10:30:55.536]                           inherits = FALSE)) {
[10:30:55.536]                           master <- get("master", mode = "list", 
[10:30:55.536]                             envir = envir, inherits = FALSE)
[10:30:55.536]                           if (inherits(master, c("SOCKnode", 
[10:30:55.536]                             "SOCK0node"))) {
[10:30:55.536]                             sendCondition <<- function(cond) {
[10:30:55.536]                               data <- list(type = "VALUE", value = cond, 
[10:30:55.536]                                 success = TRUE)
[10:30:55.536]                               parallel_sendData(master, data)
[10:30:55.536]                             }
[10:30:55.536]                             return(sendCondition)
[10:30:55.536]                           }
[10:30:55.536]                         }
[10:30:55.536]                         frame <- frame + 1L
[10:30:55.536]                         envir <- sys.frame(frame)
[10:30:55.536]                       }
[10:30:55.536]                     }
[10:30:55.536]                     sendCondition <<- function(cond) NULL
[10:30:55.536]                   }
[10:30:55.536]                 })
[10:30:55.536]                 withCallingHandlers({
[10:30:55.536]                   {
[10:30:55.536]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.536]                     if (!identical(...future.globals.maxSize.org, 
[10:30:55.536]                       ...future.globals.maxSize)) {
[10:30:55.536]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.536]                       on.exit(options(oopts), add = TRUE)
[10:30:55.536]                     }
[10:30:55.536]                     {
[10:30:55.536]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.536]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:30:55.536]                         USE.NAMES = FALSE)
[10:30:55.536]                       do.call(mapply, args = args)
[10:30:55.536]                     }
[10:30:55.536]                   }
[10:30:55.536]                 }, immediateCondition = function(cond) {
[10:30:55.536]                   sendCondition <- ...future.makeSendCondition()
[10:30:55.536]                   sendCondition(cond)
[10:30:55.536]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.536]                   {
[10:30:55.536]                     inherits <- base::inherits
[10:30:55.536]                     invokeRestart <- base::invokeRestart
[10:30:55.536]                     is.null <- base::is.null
[10:30:55.536]                     muffled <- FALSE
[10:30:55.536]                     if (inherits(cond, "message")) {
[10:30:55.536]                       muffled <- grepl(pattern, "muffleMessage")
[10:30:55.536]                       if (muffled) 
[10:30:55.536]                         invokeRestart("muffleMessage")
[10:30:55.536]                     }
[10:30:55.536]                     else if (inherits(cond, "warning")) {
[10:30:55.536]                       muffled <- grepl(pattern, "muffleWarning")
[10:30:55.536]                       if (muffled) 
[10:30:55.536]                         invokeRestart("muffleWarning")
[10:30:55.536]                     }
[10:30:55.536]                     else if (inherits(cond, "condition")) {
[10:30:55.536]                       if (!is.null(pattern)) {
[10:30:55.536]                         computeRestarts <- base::computeRestarts
[10:30:55.536]                         grepl <- base::grepl
[10:30:55.536]                         restarts <- computeRestarts(cond)
[10:30:55.536]                         for (restart in restarts) {
[10:30:55.536]                           name <- restart$name
[10:30:55.536]                           if (is.null(name)) 
[10:30:55.536]                             next
[10:30:55.536]                           if (!grepl(pattern, name)) 
[10:30:55.536]                             next
[10:30:55.536]                           invokeRestart(restart)
[10:30:55.536]                           muffled <- TRUE
[10:30:55.536]                           break
[10:30:55.536]                         }
[10:30:55.536]                       }
[10:30:55.536]                     }
[10:30:55.536]                     invisible(muffled)
[10:30:55.536]                   }
[10:30:55.536]                   muffleCondition(cond)
[10:30:55.536]                 })
[10:30:55.536]             }))
[10:30:55.536]             future::FutureResult(value = ...future.value$value, 
[10:30:55.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.536]                   ...future.rng), globalenv = if (FALSE) 
[10:30:55.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:30:55.536]                     ...future.globalenv.names))
[10:30:55.536]                 else NULL, started = ...future.startTime, version = "1.8")
[10:30:55.536]         }, condition = base::local({
[10:30:55.536]             c <- base::c
[10:30:55.536]             inherits <- base::inherits
[10:30:55.536]             invokeRestart <- base::invokeRestart
[10:30:55.536]             length <- base::length
[10:30:55.536]             list <- base::list
[10:30:55.536]             seq.int <- base::seq.int
[10:30:55.536]             signalCondition <- base::signalCondition
[10:30:55.536]             sys.calls <- base::sys.calls
[10:30:55.536]             `[[` <- base::`[[`
[10:30:55.536]             `+` <- base::`+`
[10:30:55.536]             `<<-` <- base::`<<-`
[10:30:55.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:30:55.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:30:55.536]                   3L)]
[10:30:55.536]             }
[10:30:55.536]             function(cond) {
[10:30:55.536]                 is_error <- inherits(cond, "error")
[10:30:55.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:30:55.536]                   NULL)
[10:30:55.536]                 if (is_error) {
[10:30:55.536]                   sessionInformation <- function() {
[10:30:55.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:30:55.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:30:55.536]                       search = base::search(), system = base::Sys.info())
[10:30:55.536]                   }
[10:30:55.536]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:30:55.536]                     cond$call), session = sessionInformation(), 
[10:30:55.536]                     timestamp = base::Sys.time(), signaled = 0L)
[10:30:55.536]                   signalCondition(cond)
[10:30:55.536]                 }
[10:30:55.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:30:55.536]                 "immediateCondition"))) {
[10:30:55.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:30:55.536]                   ...future.conditions[[length(...future.conditions) + 
[10:30:55.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:30:55.536]                   if (TRUE && !signal) {
[10:30:55.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.536]                     {
[10:30:55.536]                       inherits <- base::inherits
[10:30:55.536]                       invokeRestart <- base::invokeRestart
[10:30:55.536]                       is.null <- base::is.null
[10:30:55.536]                       muffled <- FALSE
[10:30:55.536]                       if (inherits(cond, "message")) {
[10:30:55.536]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.536]                         if (muffled) 
[10:30:55.536]                           invokeRestart("muffleMessage")
[10:30:55.536]                       }
[10:30:55.536]                       else if (inherits(cond, "warning")) {
[10:30:55.536]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.536]                         if (muffled) 
[10:30:55.536]                           invokeRestart("muffleWarning")
[10:30:55.536]                       }
[10:30:55.536]                       else if (inherits(cond, "condition")) {
[10:30:55.536]                         if (!is.null(pattern)) {
[10:30:55.536]                           computeRestarts <- base::computeRestarts
[10:30:55.536]                           grepl <- base::grepl
[10:30:55.536]                           restarts <- computeRestarts(cond)
[10:30:55.536]                           for (restart in restarts) {
[10:30:55.536]                             name <- restart$name
[10:30:55.536]                             if (is.null(name)) 
[10:30:55.536]                               next
[10:30:55.536]                             if (!grepl(pattern, name)) 
[10:30:55.536]                               next
[10:30:55.536]                             invokeRestart(restart)
[10:30:55.536]                             muffled <- TRUE
[10:30:55.536]                             break
[10:30:55.536]                           }
[10:30:55.536]                         }
[10:30:55.536]                       }
[10:30:55.536]                       invisible(muffled)
[10:30:55.536]                     }
[10:30:55.536]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.536]                   }
[10:30:55.536]                 }
[10:30:55.536]                 else {
[10:30:55.536]                   if (TRUE) {
[10:30:55.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:30:55.536]                     {
[10:30:55.536]                       inherits <- base::inherits
[10:30:55.536]                       invokeRestart <- base::invokeRestart
[10:30:55.536]                       is.null <- base::is.null
[10:30:55.536]                       muffled <- FALSE
[10:30:55.536]                       if (inherits(cond, "message")) {
[10:30:55.536]                         muffled <- grepl(pattern, "muffleMessage")
[10:30:55.536]                         if (muffled) 
[10:30:55.536]                           invokeRestart("muffleMessage")
[10:30:55.536]                       }
[10:30:55.536]                       else if (inherits(cond, "warning")) {
[10:30:55.536]                         muffled <- grepl(pattern, "muffleWarning")
[10:30:55.536]                         if (muffled) 
[10:30:55.536]                           invokeRestart("muffleWarning")
[10:30:55.536]                       }
[10:30:55.536]                       else if (inherits(cond, "condition")) {
[10:30:55.536]                         if (!is.null(pattern)) {
[10:30:55.536]                           computeRestarts <- base::computeRestarts
[10:30:55.536]                           grepl <- base::grepl
[10:30:55.536]                           restarts <- computeRestarts(cond)
[10:30:55.536]                           for (restart in restarts) {
[10:30:55.536]                             name <- restart$name
[10:30:55.536]                             if (is.null(name)) 
[10:30:55.536]                               next
[10:30:55.536]                             if (!grepl(pattern, name)) 
[10:30:55.536]                               next
[10:30:55.536]                             invokeRestart(restart)
[10:30:55.536]                             muffled <- TRUE
[10:30:55.536]                             break
[10:30:55.536]                           }
[10:30:55.536]                         }
[10:30:55.536]                       }
[10:30:55.536]                       invisible(muffled)
[10:30:55.536]                     }
[10:30:55.536]                     muffleCondition(cond, pattern = "^muffle")
[10:30:55.536]                   }
[10:30:55.536]                 }
[10:30:55.536]             }
[10:30:55.536]         }))
[10:30:55.536]     }, error = function(ex) {
[10:30:55.536]         base::structure(base::list(value = NULL, visible = NULL, 
[10:30:55.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:30:55.536]                 ...future.rng), started = ...future.startTime, 
[10:30:55.536]             finished = Sys.time(), session_uuid = NA_character_, 
[10:30:55.536]             version = "1.8"), class = "FutureResult")
[10:30:55.536]     }, finally = {
[10:30:55.536]         if (!identical(...future.workdir, getwd())) 
[10:30:55.536]             setwd(...future.workdir)
[10:30:55.536]         {
[10:30:55.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:30:55.536]                 ...future.oldOptions$nwarnings <- NULL
[10:30:55.536]             }
[10:30:55.536]             base::options(...future.oldOptions)
[10:30:55.536]             if (.Platform$OS.type == "windows") {
[10:30:55.536]                 old_names <- names(...future.oldEnvVars)
[10:30:55.536]                 envs <- base::Sys.getenv()
[10:30:55.536]                 names <- names(envs)
[10:30:55.536]                 common <- intersect(names, old_names)
[10:30:55.536]                 added <- setdiff(names, old_names)
[10:30:55.536]                 removed <- setdiff(old_names, names)
[10:30:55.536]                 changed <- common[...future.oldEnvVars[common] != 
[10:30:55.536]                   envs[common]]
[10:30:55.536]                 NAMES <- toupper(changed)
[10:30:55.536]                 args <- list()
[10:30:55.536]                 for (kk in seq_along(NAMES)) {
[10:30:55.536]                   name <- changed[[kk]]
[10:30:55.536]                   NAME <- NAMES[[kk]]
[10:30:55.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.536]                     next
[10:30:55.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.536]                 }
[10:30:55.536]                 NAMES <- toupper(added)
[10:30:55.536]                 for (kk in seq_along(NAMES)) {
[10:30:55.536]                   name <- added[[kk]]
[10:30:55.536]                   NAME <- NAMES[[kk]]
[10:30:55.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.536]                     next
[10:30:55.536]                   args[[name]] <- ""
[10:30:55.536]                 }
[10:30:55.536]                 NAMES <- toupper(removed)
[10:30:55.536]                 for (kk in seq_along(NAMES)) {
[10:30:55.536]                   name <- removed[[kk]]
[10:30:55.536]                   NAME <- NAMES[[kk]]
[10:30:55.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:30:55.536]                     next
[10:30:55.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:30:55.536]                 }
[10:30:55.536]                 if (length(args) > 0) 
[10:30:55.536]                   base::do.call(base::Sys.setenv, args = args)
[10:30:55.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:30:55.536]             }
[10:30:55.536]             else {
[10:30:55.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:30:55.536]             }
[10:30:55.536]             {
[10:30:55.536]                 if (base::length(...future.futureOptionsAdded) > 
[10:30:55.536]                   0L) {
[10:30:55.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:30:55.536]                   base::names(opts) <- ...future.futureOptionsAdded
[10:30:55.536]                   base::options(opts)
[10:30:55.536]                 }
[10:30:55.536]                 {
[10:30:55.536]                   {
[10:30:55.536]                     base::options(mc.cores = ...future.mc.cores.old)
[10:30:55.536]                     NULL
[10:30:55.536]                   }
[10:30:55.536]                   options(future.plan = NULL)
[10:30:55.536]                   if (is.na(NA_character_)) 
[10:30:55.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:30:55.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:30:55.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:30:55.536]                     .init = FALSE)
[10:30:55.536]                 }
[10:30:55.536]             }
[10:30:55.536]         }
[10:30:55.536]     })
[10:30:55.536]     if (TRUE) {
[10:30:55.536]         base::sink(type = "output", split = FALSE)
[10:30:55.536]         if (TRUE) {
[10:30:55.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:30:55.536]         }
[10:30:55.536]         else {
[10:30:55.536]             ...future.result["stdout"] <- base::list(NULL)
[10:30:55.536]         }
[10:30:55.536]         base::close(...future.stdout)
[10:30:55.536]         ...future.stdout <- NULL
[10:30:55.536]     }
[10:30:55.536]     ...future.result$conditions <- ...future.conditions
[10:30:55.536]     ...future.result$finished <- base::Sys.time()
[10:30:55.536]     ...future.result
[10:30:55.536] }
[10:30:55.539] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[10:30:55.539] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[10:30:55.540] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[10:30:55.540] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:30:55.540] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.540] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:30:55.541] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:30:55.541] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:30:55.541] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.541] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:30:55.542] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:30:55.542] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[10:30:55.542] MultisessionFuture started
[10:30:55.543] - Launch lazy future ... done
[10:30:55.543] run() for ‘MultisessionFuture’ ... done
[10:30:55.543] Created future:
[10:30:55.543] MultisessionFuture:
[10:30:55.543] Label: ‘future_mapply-2’
[10:30:55.543] Expression:
[10:30:55.543] {
[10:30:55.543]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:30:55.543]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:30:55.543]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:30:55.543]         on.exit(options(oopts), add = TRUE)
[10:30:55.543]     }
[10:30:55.543]     {
[10:30:55.543]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:30:55.543]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:30:55.543]         do.call(mapply, args = args)
[10:30:55.543]     }
[10:30:55.543] }
[10:30:55.543] Lazy evaluation: FALSE
[10:30:55.543] Asynchronous evaluation: TRUE
[10:30:55.543] Local evaluation: TRUE
[10:30:55.543] Environment: R_GlobalEnv
[10:30:55.543] Capture standard output: TRUE
[10:30:55.543] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:30:55.543] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:30:55.543] Packages: <none>
[10:30:55.543] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:30:55.543] Resolved: FALSE
[10:30:55.543] Value: <not collected>
[10:30:55.543] Conditions captured: <none>
[10:30:55.543] Early signaling: FALSE
[10:30:55.543] Owner process: 78bde34c-faef-48b1-32ce-a556aeab027c
[10:30:55.543] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:30:55.555] Chunk #2 of 2 ... DONE
[10:30:55.555] Launching 2 futures (chunks) ... DONE
[10:30:55.555] Resolving 2 futures (chunks) ...
[10:30:55.555] resolve() on list ...
[10:30:55.555]  recursive: 0
[10:30:55.555]  length: 2
[10:30:55.555] 
[10:30:55.556] receiveMessageFromWorker() for ClusterFuture ...
[10:30:55.556] - Validating connection of MultisessionFuture
[10:30:55.556] - received message: FutureResult
[10:30:55.556] - Received FutureResult
[10:30:55.556] - Erased future from FutureRegistry
[10:30:55.556] result() for ClusterFuture ...
[10:30:55.556] - result already collected: FutureResult
[10:30:55.556] result() for ClusterFuture ... done
[10:30:55.557] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:55.557] Future #1
[10:30:55.557] result() for ClusterFuture ...
[10:30:55.557] - result already collected: FutureResult
[10:30:55.557] result() for ClusterFuture ... done
[10:30:55.557] result() for ClusterFuture ...
[10:30:55.557] - result already collected: FutureResult
[10:30:55.557] result() for ClusterFuture ... done
[10:30:55.557] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:30:55.557] - nx: 2
[10:30:55.557] - relay: TRUE
[10:30:55.558] - stdout: TRUE
[10:30:55.558] - signal: TRUE
[10:30:55.558] - resignal: FALSE
[10:30:55.558] - force: TRUE
[10:30:55.558] - relayed: [n=2] FALSE, FALSE
[10:30:55.558] - queued futures: [n=2] FALSE, FALSE
[10:30:55.558]  - until=1
[10:30:55.558]  - relaying element #1
[10:30:55.558] result() for ClusterFuture ...
[10:30:55.558] - result already collected: FutureResult
[10:30:55.558] result() for ClusterFuture ... done
[10:30:55.558] result() for ClusterFuture ...
[10:30:55.559] - result already collected: FutureResult
[10:30:55.559] result() for ClusterFuture ... done
[10:30:55.559] result() for ClusterFuture ...
[10:30:55.559] - result already collected: FutureResult
[10:30:55.559] result() for ClusterFuture ... done
[10:30:55.559] result() for ClusterFuture ...
[10:30:55.559] - result already collected: FutureResult
[10:30:55.559] result() for ClusterFuture ... done
[10:30:55.559] - relayed: [n=2] TRUE, FALSE
[10:30:55.559] - queued futures: [n=2] TRUE, FALSE
[10:30:55.559] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:30:55.560]  length: 1 (resolved future 1)
[10:30:55.587] receiveMessageFromWorker() for ClusterFuture ...
[10:30:55.587] - Validating connection of MultisessionFuture
[10:30:55.587] - received message: FutureResult
[10:30:55.587] - Received FutureResult
[10:30:55.587] - Erased future from FutureRegistry
[10:30:55.587] result() for ClusterFuture ...
[10:30:55.587] - result already collected: FutureResult
[10:30:55.588] result() for ClusterFuture ... done
[10:30:55.588] receiveMessageFromWorker() for ClusterFuture ... done
[10:30:55.588] Future #2
[10:30:55.588] result() for ClusterFuture ...
[10:30:55.588] - result already collected: FutureResult
[10:30:55.588] result() for ClusterFuture ... done
[10:30:55.588] result() for ClusterFuture ...
[10:30:55.588] - result already collected: FutureResult
[10:30:55.588] result() for ClusterFuture ... done
[10:30:55.588] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:30:55.588] - nx: 2
[10:30:55.589] - relay: TRUE
[10:30:55.589] - stdout: TRUE
[10:30:55.589] - signal: TRUE
[10:30:55.589] - resignal: FALSE
[10:30:55.589] - force: TRUE
[10:30:55.589] - relayed: [n=2] TRUE, FALSE
[10:30:55.589] - queued futures: [n=2] TRUE, FALSE
[10:30:55.589]  - until=2
[10:30:55.589]  - relaying element #2
[10:30:55.589] result() for ClusterFuture ...
[10:30:55.589] - result already collected: FutureResult
[10:30:55.590] result() for ClusterFuture ... done
[10:30:55.590] result() for ClusterFuture ...
[10:30:55.590] - result already collected: FutureResult
[10:30:55.590] result() for ClusterFuture ... done
[10:30:55.590] result() for ClusterFuture ...
[10:30:55.590] - result already collected: FutureResult
[10:30:55.590] result() for ClusterFuture ... done
[10:30:55.590] result() for ClusterFuture ...
[10:30:55.590] - result already collected: FutureResult
[10:30:55.590] result() for ClusterFuture ... done
[10:30:55.590] - relayed: [n=2] TRUE, TRUE
[10:30:55.591] - queued futures: [n=2] TRUE, TRUE
[10:30:55.591] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:30:55.591]  length: 0 (resolved future 2)
[10:30:55.591] Relaying remaining futures
[10:30:55.591] signalConditionsASAP(NULL, pos=0) ...
[10:30:55.591] - nx: 2
[10:30:55.591] - relay: TRUE
[10:30:55.591] - stdout: TRUE
[10:30:55.591] - signal: TRUE
[10:30:55.591] - resignal: FALSE
[10:30:55.591] - force: TRUE
[10:30:55.591] - relayed: [n=2] TRUE, TRUE
[10:30:55.592] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:30:55.592] - relayed: [n=2] TRUE, TRUE
[10:30:55.592] - queued futures: [n=2] TRUE, TRUE
[10:30:55.592] signalConditionsASAP(NULL, pos=0) ... done
[10:30:55.592] resolve() on list ... DONE
[10:30:55.592] result() for ClusterFuture ...
[10:30:55.592] - result already collected: FutureResult
[10:30:55.592] result() for ClusterFuture ... done
[10:30:55.592] result() for ClusterFuture ...
[10:30:55.592] - result already collected: FutureResult
[10:30:55.592] result() for ClusterFuture ... done
[10:30:55.593] result() for ClusterFuture ...
[10:30:55.593] - result already collected: FutureResult
[10:30:55.593] result() for ClusterFuture ... done
[10:30:55.593] result() for ClusterFuture ...
[10:30:55.593] - result already collected: FutureResult
[10:30:55.593] result() for ClusterFuture ... done
[10:30:55.593]  - Number of value chunks collected: 2
[10:30:55.593] Resolving 2 futures (chunks) ... DONE
[10:30:55.593] Reducing values from 2 chunks ...
[10:30:55.593]  - Number of values collected after concatenation: 2
[10:30:55.593]  - Number of values expected: 2
[10:30:55.594] Reducing values from 2 chunks ... DONE
[10:30:55.594] future_mapply() ... DONE
[10:30:55.594] plan(): Setting new future strategy stack:
[10:30:55.594] List of future strategies:
[10:30:55.594] 1. sequential:
[10:30:55.594]    - args: function (..., envir = parent.frame())
[10:30:55.594]    - tweaked: FALSE
[10:30:55.594]    - call: plan(sequential)
[10:30:55.595] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[10:30:55.596] plan(): Setting new future strategy stack:
[10:30:55.596] List of future strategies:
[10:30:55.596] 1. FutureStrategy:
[10:30:55.596]    - args: function (..., envir = parent.frame())
[10:30:55.596]    - tweaked: FALSE
[10:30:55.596]    - call: future::plan(oplan)
[10:30:55.597] plan(): nbrOfWorkers() = 1
> 
