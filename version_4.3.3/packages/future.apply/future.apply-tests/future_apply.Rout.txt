
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:29:48.046] plan(): Setting new future strategy stack:
[10:29:48.047] List of future strategies:
[10:29:48.047] 1. sequential:
[10:29:48.047]    - args: function (..., envir = parent.frame())
[10:29:48.047]    - tweaked: FALSE
[10:29:48.047]    - call: future::plan("sequential")
[10:29:48.060] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:29:48.117] plan(): Setting new future strategy stack:
[10:29:48.117] List of future strategies:
[10:29:48.117] 1. sequential:
[10:29:48.117]    - args: function (..., envir = parent.frame())
[10:29:48.117]    - tweaked: FALSE
[10:29:48.117]    - call: plan(strategy)
[10:29:48.128] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[10:29:48.129] getGlobalsAndPackagesXApply() ...
[10:29:48.129]  - future.globals: TRUE
[10:29:48.130] getGlobalsAndPackages() ...
[10:29:48.130] Searching for globals...
[10:29:48.170] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:29:48.171] Searching for globals ... DONE
[10:29:48.171] Resolving globals: FALSE
[10:29:48.173] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:29:48.174] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:29:48.174] - globals: [1] ‘FUN’
[10:29:48.174] 
[10:29:48.174] getGlobalsAndPackages() ... DONE
[10:29:48.174]  - globals found/used: [n=1] ‘FUN’
[10:29:48.174]  - needed namespaces: [n=0] 
[10:29:48.174] Finding globals ... DONE
[10:29:48.174]  - use_args: TRUE
[10:29:48.174]  - Getting '...' globals ...
[10:29:48.175] resolve() on list ...
[10:29:48.175]  recursive: 0
[10:29:48.176]  length: 1
[10:29:48.176]  elements: ‘...’
[10:29:48.176]  length: 0 (resolved future 1)
[10:29:48.176] resolve() on list ... DONE
[10:29:48.176]    - '...' content: [n=0] 
[10:29:48.176] List of 1
[10:29:48.176]  $ ...: list()
[10:29:48.176]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.176]  - attr(*, "where")=List of 1
[10:29:48.176]   ..$ ...:<environment: 0x5618a1c22918> 
[10:29:48.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.176]  - attr(*, "resolved")= logi TRUE
[10:29:48.176]  - attr(*, "total_size")= num NA
[10:29:48.181]  - Getting '...' globals ... DONE
[10:29:48.181] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.181] List of 2
[10:29:48.181]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.181]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.181]  $ ...          : list()
[10:29:48.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.181]  - attr(*, "where")=List of 2
[10:29:48.181]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.181]   ..$ ...          :<environment: 0x5618a1c22918> 
[10:29:48.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.181]  - attr(*, "resolved")= logi FALSE
[10:29:48.181]  - attr(*, "total_size")= num 354224
[10:29:48.184] Packages to be attached in all futures: [n=0] 
[10:29:48.184] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.184] future_lapply() ...
[10:29:48.218] Number of chunks: 1
[10:29:48.218] getGlobalsAndPackagesXApply() ...
[10:29:48.218]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.219]  - use_args: TRUE
[10:29:48.219] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.219] List of 2
[10:29:48.219]  $ ...          : list()
[10:29:48.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.219]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.219]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.219]  - attr(*, "where")=List of 2
[10:29:48.219]   ..$ ...          :<environment: 0x5618a1c22918> 
[10:29:48.219]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:48.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.219]  - attr(*, "resolved")= logi FALSE
[10:29:48.219]  - attr(*, "total_size")= num NA
[10:29:48.222] Packages to be attached in all futures: [n=0] 
[10:29:48.223] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.223] Number of futures (= number of chunks): 1
[10:29:48.223] Launching 1 futures (chunks) ...
[10:29:48.223] Chunk #1 of 1 ...
[10:29:48.223]  - seeds: <none>
[10:29:48.224]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.224] getGlobalsAndPackages() ...
[10:29:48.224] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.224] Resolving globals: FALSE
[10:29:48.224] Tweak future expression to call with '...' arguments ...
[10:29:48.224] {
[10:29:48.224]     do.call(function(...) {
[10:29:48.224]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.224]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.224]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.224]             on.exit(options(oopts), add = TRUE)
[10:29:48.224]         }
[10:29:48.224]         {
[10:29:48.224]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.224]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.224]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.224]             })
[10:29:48.224]         }
[10:29:48.224]     }, args = future.call.arguments)
[10:29:48.224] }
[10:29:48.225] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.225] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.225] 
[10:29:48.225] getGlobalsAndPackages() ... DONE
[10:29:48.226] run() for ‘Future’ ...
[10:29:48.226] - state: ‘created’
[10:29:48.226] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:48.227] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.227] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:48.227]   - Field: ‘label’
[10:29:48.227]   - Field: ‘local’
[10:29:48.227]   - Field: ‘owner’
[10:29:48.227]   - Field: ‘envir’
[10:29:48.227]   - Field: ‘packages’
[10:29:48.227]   - Field: ‘gc’
[10:29:48.227]   - Field: ‘conditions’
[10:29:48.228]   - Field: ‘expr’
[10:29:48.228]   - Field: ‘uuid’
[10:29:48.228]   - Field: ‘seed’
[10:29:48.228]   - Field: ‘version’
[10:29:48.228]   - Field: ‘result’
[10:29:48.228]   - Field: ‘asynchronous’
[10:29:48.228]   - Field: ‘calls’
[10:29:48.228]   - Field: ‘globals’
[10:29:48.228]   - Field: ‘stdout’
[10:29:48.228]   - Field: ‘earlySignal’
[10:29:48.228]   - Field: ‘lazy’
[10:29:48.229]   - Field: ‘state’
[10:29:48.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:48.229] - Launch lazy future ...
[10:29:48.230] Packages needed by the future expression (n = 0): <none>
[10:29:48.230] Packages needed by future strategies (n = 0): <none>
[10:29:48.231] {
[10:29:48.231]     {
[10:29:48.231]         {
[10:29:48.231]             ...future.startTime <- base::Sys.time()
[10:29:48.231]             {
[10:29:48.231]                 {
[10:29:48.231]                   {
[10:29:48.231]                     base::local({
[10:29:48.231]                       has_future <- base::requireNamespace("future", 
[10:29:48.231]                         quietly = TRUE)
[10:29:48.231]                       if (has_future) {
[10:29:48.231]                         ns <- base::getNamespace("future")
[10:29:48.231]                         version <- ns[[".package"]][["version"]]
[10:29:48.231]                         if (is.null(version)) 
[10:29:48.231]                           version <- utils::packageVersion("future")
[10:29:48.231]                       }
[10:29:48.231]                       else {
[10:29:48.231]                         version <- NULL
[10:29:48.231]                       }
[10:29:48.231]                       if (!has_future || version < "1.8.0") {
[10:29:48.231]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.231]                           "", base::R.version$version.string), 
[10:29:48.231]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:48.231]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.231]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.231]                             "release", "version")], collapse = " "), 
[10:29:48.231]                           hostname = base::Sys.info()[["nodename"]])
[10:29:48.231]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.231]                           info)
[10:29:48.231]                         info <- base::paste(info, collapse = "; ")
[10:29:48.231]                         if (!has_future) {
[10:29:48.231]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.231]                             info)
[10:29:48.231]                         }
[10:29:48.231]                         else {
[10:29:48.231]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.231]                             info, version)
[10:29:48.231]                         }
[10:29:48.231]                         base::stop(msg)
[10:29:48.231]                       }
[10:29:48.231]                     })
[10:29:48.231]                   }
[10:29:48.231]                   ...future.strategy.old <- future::plan("list")
[10:29:48.231]                   options(future.plan = NULL)
[10:29:48.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.231]                 }
[10:29:48.231]                 ...future.workdir <- getwd()
[10:29:48.231]             }
[10:29:48.231]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.231]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.231]         }
[10:29:48.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.231]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.231]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.231]             base::names(...future.oldOptions))
[10:29:48.231]     }
[10:29:48.231]     if (FALSE) {
[10:29:48.231]     }
[10:29:48.231]     else {
[10:29:48.231]         if (TRUE) {
[10:29:48.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.231]                 open = "w")
[10:29:48.231]         }
[10:29:48.231]         else {
[10:29:48.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.231]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.231]         }
[10:29:48.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.231]             base::sink(type = "output", split = FALSE)
[10:29:48.231]             base::close(...future.stdout)
[10:29:48.231]         }, add = TRUE)
[10:29:48.231]     }
[10:29:48.231]     ...future.frame <- base::sys.nframe()
[10:29:48.231]     ...future.conditions <- base::list()
[10:29:48.231]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.231]     if (FALSE) {
[10:29:48.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.231]     }
[10:29:48.231]     ...future.result <- base::tryCatch({
[10:29:48.231]         base::withCallingHandlers({
[10:29:48.231]             ...future.value <- base::withVisible(base::local({
[10:29:48.231]                 do.call(function(...) {
[10:29:48.231]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.231]                   if (!identical(...future.globals.maxSize.org, 
[10:29:48.231]                     ...future.globals.maxSize)) {
[10:29:48.231]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.231]                     on.exit(options(oopts), add = TRUE)
[10:29:48.231]                   }
[10:29:48.231]                   {
[10:29:48.231]                     lapply(seq_along(...future.elements_ii), 
[10:29:48.231]                       FUN = function(jj) {
[10:29:48.231]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.231]                         ...future.FUN(...future.X_jj, ...)
[10:29:48.231]                       })
[10:29:48.231]                   }
[10:29:48.231]                 }, args = future.call.arguments)
[10:29:48.231]             }))
[10:29:48.231]             future::FutureResult(value = ...future.value$value, 
[10:29:48.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.231]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.231]                     ...future.globalenv.names))
[10:29:48.231]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.231]         }, condition = base::local({
[10:29:48.231]             c <- base::c
[10:29:48.231]             inherits <- base::inherits
[10:29:48.231]             invokeRestart <- base::invokeRestart
[10:29:48.231]             length <- base::length
[10:29:48.231]             list <- base::list
[10:29:48.231]             seq.int <- base::seq.int
[10:29:48.231]             signalCondition <- base::signalCondition
[10:29:48.231]             sys.calls <- base::sys.calls
[10:29:48.231]             `[[` <- base::`[[`
[10:29:48.231]             `+` <- base::`+`
[10:29:48.231]             `<<-` <- base::`<<-`
[10:29:48.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.231]                   3L)]
[10:29:48.231]             }
[10:29:48.231]             function(cond) {
[10:29:48.231]                 is_error <- inherits(cond, "error")
[10:29:48.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.231]                   NULL)
[10:29:48.231]                 if (is_error) {
[10:29:48.231]                   sessionInformation <- function() {
[10:29:48.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.231]                       search = base::search(), system = base::Sys.info())
[10:29:48.231]                   }
[10:29:48.231]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.231]                     cond$call), session = sessionInformation(), 
[10:29:48.231]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.231]                   signalCondition(cond)
[10:29:48.231]                 }
[10:29:48.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.231]                 "immediateCondition"))) {
[10:29:48.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.231]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.231]                   if (TRUE && !signal) {
[10:29:48.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.231]                     {
[10:29:48.231]                       inherits <- base::inherits
[10:29:48.231]                       invokeRestart <- base::invokeRestart
[10:29:48.231]                       is.null <- base::is.null
[10:29:48.231]                       muffled <- FALSE
[10:29:48.231]                       if (inherits(cond, "message")) {
[10:29:48.231]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.231]                         if (muffled) 
[10:29:48.231]                           invokeRestart("muffleMessage")
[10:29:48.231]                       }
[10:29:48.231]                       else if (inherits(cond, "warning")) {
[10:29:48.231]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.231]                         if (muffled) 
[10:29:48.231]                           invokeRestart("muffleWarning")
[10:29:48.231]                       }
[10:29:48.231]                       else if (inherits(cond, "condition")) {
[10:29:48.231]                         if (!is.null(pattern)) {
[10:29:48.231]                           computeRestarts <- base::computeRestarts
[10:29:48.231]                           grepl <- base::grepl
[10:29:48.231]                           restarts <- computeRestarts(cond)
[10:29:48.231]                           for (restart in restarts) {
[10:29:48.231]                             name <- restart$name
[10:29:48.231]                             if (is.null(name)) 
[10:29:48.231]                               next
[10:29:48.231]                             if (!grepl(pattern, name)) 
[10:29:48.231]                               next
[10:29:48.231]                             invokeRestart(restart)
[10:29:48.231]                             muffled <- TRUE
[10:29:48.231]                             break
[10:29:48.231]                           }
[10:29:48.231]                         }
[10:29:48.231]                       }
[10:29:48.231]                       invisible(muffled)
[10:29:48.231]                     }
[10:29:48.231]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.231]                   }
[10:29:48.231]                 }
[10:29:48.231]                 else {
[10:29:48.231]                   if (TRUE) {
[10:29:48.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.231]                     {
[10:29:48.231]                       inherits <- base::inherits
[10:29:48.231]                       invokeRestart <- base::invokeRestart
[10:29:48.231]                       is.null <- base::is.null
[10:29:48.231]                       muffled <- FALSE
[10:29:48.231]                       if (inherits(cond, "message")) {
[10:29:48.231]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.231]                         if (muffled) 
[10:29:48.231]                           invokeRestart("muffleMessage")
[10:29:48.231]                       }
[10:29:48.231]                       else if (inherits(cond, "warning")) {
[10:29:48.231]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.231]                         if (muffled) 
[10:29:48.231]                           invokeRestart("muffleWarning")
[10:29:48.231]                       }
[10:29:48.231]                       else if (inherits(cond, "condition")) {
[10:29:48.231]                         if (!is.null(pattern)) {
[10:29:48.231]                           computeRestarts <- base::computeRestarts
[10:29:48.231]                           grepl <- base::grepl
[10:29:48.231]                           restarts <- computeRestarts(cond)
[10:29:48.231]                           for (restart in restarts) {
[10:29:48.231]                             name <- restart$name
[10:29:48.231]                             if (is.null(name)) 
[10:29:48.231]                               next
[10:29:48.231]                             if (!grepl(pattern, name)) 
[10:29:48.231]                               next
[10:29:48.231]                             invokeRestart(restart)
[10:29:48.231]                             muffled <- TRUE
[10:29:48.231]                             break
[10:29:48.231]                           }
[10:29:48.231]                         }
[10:29:48.231]                       }
[10:29:48.231]                       invisible(muffled)
[10:29:48.231]                     }
[10:29:48.231]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.231]                   }
[10:29:48.231]                 }
[10:29:48.231]             }
[10:29:48.231]         }))
[10:29:48.231]     }, error = function(ex) {
[10:29:48.231]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.231]                 ...future.rng), started = ...future.startTime, 
[10:29:48.231]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.231]             version = "1.8"), class = "FutureResult")
[10:29:48.231]     }, finally = {
[10:29:48.231]         if (!identical(...future.workdir, getwd())) 
[10:29:48.231]             setwd(...future.workdir)
[10:29:48.231]         {
[10:29:48.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.231]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.231]             }
[10:29:48.231]             base::options(...future.oldOptions)
[10:29:48.231]             if (.Platform$OS.type == "windows") {
[10:29:48.231]                 old_names <- names(...future.oldEnvVars)
[10:29:48.231]                 envs <- base::Sys.getenv()
[10:29:48.231]                 names <- names(envs)
[10:29:48.231]                 common <- intersect(names, old_names)
[10:29:48.231]                 added <- setdiff(names, old_names)
[10:29:48.231]                 removed <- setdiff(old_names, names)
[10:29:48.231]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.231]                   envs[common]]
[10:29:48.231]                 NAMES <- toupper(changed)
[10:29:48.231]                 args <- list()
[10:29:48.231]                 for (kk in seq_along(NAMES)) {
[10:29:48.231]                   name <- changed[[kk]]
[10:29:48.231]                   NAME <- NAMES[[kk]]
[10:29:48.231]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.231]                     next
[10:29:48.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.231]                 }
[10:29:48.231]                 NAMES <- toupper(added)
[10:29:48.231]                 for (kk in seq_along(NAMES)) {
[10:29:48.231]                   name <- added[[kk]]
[10:29:48.231]                   NAME <- NAMES[[kk]]
[10:29:48.231]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.231]                     next
[10:29:48.231]                   args[[name]] <- ""
[10:29:48.231]                 }
[10:29:48.231]                 NAMES <- toupper(removed)
[10:29:48.231]                 for (kk in seq_along(NAMES)) {
[10:29:48.231]                   name <- removed[[kk]]
[10:29:48.231]                   NAME <- NAMES[[kk]]
[10:29:48.231]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.231]                     next
[10:29:48.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.231]                 }
[10:29:48.231]                 if (length(args) > 0) 
[10:29:48.231]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.231]             }
[10:29:48.231]             else {
[10:29:48.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.231]             }
[10:29:48.231]             {
[10:29:48.231]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.231]                   0L) {
[10:29:48.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.231]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.231]                   base::options(opts)
[10:29:48.231]                 }
[10:29:48.231]                 {
[10:29:48.231]                   {
[10:29:48.231]                     NULL
[10:29:48.231]                     RNGkind("Mersenne-Twister")
[10:29:48.231]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:48.231]                       inherits = FALSE)
[10:29:48.231]                   }
[10:29:48.231]                   options(future.plan = NULL)
[10:29:48.231]                   if (is.na(NA_character_)) 
[10:29:48.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.231]                     .init = FALSE)
[10:29:48.231]                 }
[10:29:48.231]             }
[10:29:48.231]         }
[10:29:48.231]     })
[10:29:48.231]     if (TRUE) {
[10:29:48.231]         base::sink(type = "output", split = FALSE)
[10:29:48.231]         if (TRUE) {
[10:29:48.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.231]         }
[10:29:48.231]         else {
[10:29:48.231]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.231]         }
[10:29:48.231]         base::close(...future.stdout)
[10:29:48.231]         ...future.stdout <- NULL
[10:29:48.231]     }
[10:29:48.231]     ...future.result$conditions <- ...future.conditions
[10:29:48.231]     ...future.result$finished <- base::Sys.time()
[10:29:48.231]     ...future.result
[10:29:48.231] }
[10:29:48.232] assign_globals() ...
[10:29:48.233] List of 5
[10:29:48.233]  $ future.call.arguments    : list()
[10:29:48.233]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.233]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.233]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.233]  $ ...future.elements_ii    :List of 2
[10:29:48.233]   ..$ : num [1:4] 1 3 1 7
[10:29:48.233]   ..$ : num [1:4] 2 4 6 8
[10:29:48.233]  $ ...future.seeds_ii       : NULL
[10:29:48.233]  $ ...future.globals.maxSize: num Inf
[10:29:48.233]  - attr(*, "resolved")= logi FALSE
[10:29:48.233]  - attr(*, "total_size")= num NA
[10:29:48.233]  - attr(*, "where")=List of 5
[10:29:48.233]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.233]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.233]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.233]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.233]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.233]  - attr(*, "already-done")= logi TRUE
[10:29:48.238] - copied ‘future.call.arguments’ to environment
[10:29:48.238] - copied ‘...future.FUN’ to environment
[10:29:48.238] - copied ‘...future.elements_ii’ to environment
[10:29:48.238] - copied ‘...future.seeds_ii’ to environment
[10:29:48.238] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.238] assign_globals() ... done
[10:29:48.239] plan(): Setting new future strategy stack:
[10:29:48.239] List of future strategies:
[10:29:48.239] 1. sequential:
[10:29:48.239]    - args: function (..., envir = parent.frame())
[10:29:48.239]    - tweaked: FALSE
[10:29:48.239]    - call: NULL
[10:29:48.239] plan(): nbrOfWorkers() = 1
[10:29:48.240] plan(): Setting new future strategy stack:
[10:29:48.241] List of future strategies:
[10:29:48.241] 1. sequential:
[10:29:48.241]    - args: function (..., envir = parent.frame())
[10:29:48.241]    - tweaked: FALSE
[10:29:48.241]    - call: plan(strategy)
[10:29:48.241] plan(): nbrOfWorkers() = 1
[10:29:48.241] SequentialFuture started (and completed)
[10:29:48.242] - Launch lazy future ... done
[10:29:48.242] run() for ‘SequentialFuture’ ... done
[10:29:48.242] Created future:
[10:29:48.242] SequentialFuture:
[10:29:48.242] Label: ‘future_apply-1’
[10:29:48.242] Expression:
[10:29:48.242] {
[10:29:48.242]     do.call(function(...) {
[10:29:48.242]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.242]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.242]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.242]             on.exit(options(oopts), add = TRUE)
[10:29:48.242]         }
[10:29:48.242]         {
[10:29:48.242]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.242]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.242]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.242]             })
[10:29:48.242]         }
[10:29:48.242]     }, args = future.call.arguments)
[10:29:48.242] }
[10:29:48.242] Lazy evaluation: FALSE
[10:29:48.242] Asynchronous evaluation: FALSE
[10:29:48.242] Local evaluation: TRUE
[10:29:48.242] Environment: R_GlobalEnv
[10:29:48.242] Capture standard output: TRUE
[10:29:48.242] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.242] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.242] Packages: <none>
[10:29:48.242] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.242] Resolved: TRUE
[10:29:48.242] Value: 2.21 KiB of class ‘list’
[10:29:48.242] Early signaling: FALSE
[10:29:48.242] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.242] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.246] Chunk #1 of 1 ... DONE
[10:29:48.246] Launching 1 futures (chunks) ... DONE
[10:29:48.246] Resolving 1 futures (chunks) ...
[10:29:48.246] resolve() on list ...
[10:29:48.246]  recursive: 0
[10:29:48.246]  length: 1
[10:29:48.246] 
[10:29:48.246] resolved() for ‘SequentialFuture’ ...
[10:29:48.247] - state: ‘finished’
[10:29:48.247] - run: TRUE
[10:29:48.247] - result: ‘FutureResult’
[10:29:48.247] resolved() for ‘SequentialFuture’ ... done
[10:29:48.247] Future #1
[10:29:48.247] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:48.247] - nx: 1
[10:29:48.248] - relay: TRUE
[10:29:48.248] - stdout: TRUE
[10:29:48.248] - signal: TRUE
[10:29:48.248] - resignal: FALSE
[10:29:48.248] - force: TRUE
[10:29:48.248] - relayed: [n=1] FALSE
[10:29:48.248] - queued futures: [n=1] FALSE
[10:29:48.248]  - until=1
[10:29:48.248]  - relaying element #1
[10:29:48.248] - relayed: [n=1] TRUE
[10:29:48.249] - queued futures: [n=1] TRUE
[10:29:48.249] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:48.249]  length: 0 (resolved future 1)
[10:29:48.249] Relaying remaining futures
[10:29:48.249] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.249] - nx: 1
[10:29:48.249] - relay: TRUE
[10:29:48.249] - stdout: TRUE
[10:29:48.249] - signal: TRUE
[10:29:48.250] - resignal: FALSE
[10:29:48.250] - force: TRUE
[10:29:48.250] - relayed: [n=1] TRUE
[10:29:48.250] - queued futures: [n=1] TRUE
 - flush all
[10:29:48.250] - relayed: [n=1] TRUE
[10:29:48.250] - queued futures: [n=1] TRUE
[10:29:48.250] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.250] resolve() on list ... DONE
[10:29:48.250]  - Number of value chunks collected: 1
[10:29:48.250] Resolving 1 futures (chunks) ... DONE
[10:29:48.251] Reducing values from 1 chunks ...
[10:29:48.251]  - Number of values collected after concatenation: 2
[10:29:48.251]  - Number of values expected: 2
[10:29:48.251] Reducing values from 1 chunks ... DONE
[10:29:48.251] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:29:48.252] getGlobalsAndPackagesXApply() ...
[10:29:48.252]  - future.globals: TRUE
[10:29:48.252] getGlobalsAndPackages() ...
[10:29:48.252] Searching for globals...
[10:29:48.286] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:29:48.286] Searching for globals ... DONE
[10:29:48.286] Resolving globals: FALSE
[10:29:48.288] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:29:48.288] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:29:48.289] - globals: [1] ‘FUN’
[10:29:48.289] 
[10:29:48.289] getGlobalsAndPackages() ... DONE
[10:29:48.289]  - globals found/used: [n=1] ‘FUN’
[10:29:48.289]  - needed namespaces: [n=0] 
[10:29:48.289] Finding globals ... DONE
[10:29:48.289]  - use_args: TRUE
[10:29:48.289]  - Getting '...' globals ...
[10:29:48.290] resolve() on list ...
[10:29:48.290]  recursive: 0
[10:29:48.290]  length: 1
[10:29:48.290]  elements: ‘...’
[10:29:48.290]  length: 0 (resolved future 1)
[10:29:48.290] resolve() on list ... DONE
[10:29:48.290]    - '...' content: [n=0] 
[10:29:48.290] List of 1
[10:29:48.290]  $ ...: list()
[10:29:48.290]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.290]  - attr(*, "where")=List of 1
[10:29:48.290]   ..$ ...:<environment: 0x56189fc41568> 
[10:29:48.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.290]  - attr(*, "resolved")= logi TRUE
[10:29:48.290]  - attr(*, "total_size")= num NA
[10:29:48.293]  - Getting '...' globals ... DONE
[10:29:48.293] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.293] List of 2
[10:29:48.293]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.293]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.293]  $ ...          : list()
[10:29:48.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.293]  - attr(*, "where")=List of 2
[10:29:48.293]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.293]   ..$ ...          :<environment: 0x56189fc41568> 
[10:29:48.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.293]  - attr(*, "resolved")= logi FALSE
[10:29:48.293]  - attr(*, "total_size")= num 354224
[10:29:48.296] Packages to be attached in all futures: [n=0] 
[10:29:48.296] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.296] future_lapply() ...
[10:29:48.328] Number of chunks: 1
[10:29:48.329] getGlobalsAndPackagesXApply() ...
[10:29:48.329]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.329]  - use_args: TRUE
[10:29:48.329] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.329] List of 2
[10:29:48.329]  $ ...          : list()
[10:29:48.329]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.329]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.329]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.329]  - attr(*, "where")=List of 2
[10:29:48.329]   ..$ ...          :<environment: 0x56189fc41568> 
[10:29:48.329]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:48.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.329]  - attr(*, "resolved")= logi FALSE
[10:29:48.329]  - attr(*, "total_size")= num NA
[10:29:48.332] Packages to be attached in all futures: [n=0] 
[10:29:48.333] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.333] Number of futures (= number of chunks): 1
[10:29:48.333] Launching 1 futures (chunks) ...
[10:29:48.333] Chunk #1 of 1 ...
[10:29:48.333]  - seeds: <none>
[10:29:48.333]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.333] getGlobalsAndPackages() ...
[10:29:48.333] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.334] Resolving globals: FALSE
[10:29:48.334] Tweak future expression to call with '...' arguments ...
[10:29:48.334] {
[10:29:48.334]     do.call(function(...) {
[10:29:48.334]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.334]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.334]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.334]             on.exit(options(oopts), add = TRUE)
[10:29:48.334]         }
[10:29:48.334]         {
[10:29:48.334]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.334]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.334]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.334]             })
[10:29:48.334]         }
[10:29:48.334]     }, args = future.call.arguments)
[10:29:48.334] }
[10:29:48.334] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.334] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.334] 
[10:29:48.335] getGlobalsAndPackages() ... DONE
[10:29:48.335] run() for ‘Future’ ...
[10:29:48.335] - state: ‘created’
[10:29:48.335] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:48.335] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:48.336]   - Field: ‘label’
[10:29:48.336]   - Field: ‘local’
[10:29:48.336]   - Field: ‘owner’
[10:29:48.336]   - Field: ‘envir’
[10:29:48.336]   - Field: ‘packages’
[10:29:48.336]   - Field: ‘gc’
[10:29:48.336]   - Field: ‘conditions’
[10:29:48.336]   - Field: ‘expr’
[10:29:48.336]   - Field: ‘uuid’
[10:29:48.336]   - Field: ‘seed’
[10:29:48.337]   - Field: ‘version’
[10:29:48.337]   - Field: ‘result’
[10:29:48.337]   - Field: ‘asynchronous’
[10:29:48.337]   - Field: ‘calls’
[10:29:48.337]   - Field: ‘globals’
[10:29:48.337]   - Field: ‘stdout’
[10:29:48.337]   - Field: ‘earlySignal’
[10:29:48.337]   - Field: ‘lazy’
[10:29:48.337]   - Field: ‘state’
[10:29:48.337] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:48.338] - Launch lazy future ...
[10:29:48.338] Packages needed by the future expression (n = 0): <none>
[10:29:48.338] Packages needed by future strategies (n = 0): <none>
[10:29:48.338] {
[10:29:48.338]     {
[10:29:48.338]         {
[10:29:48.338]             ...future.startTime <- base::Sys.time()
[10:29:48.338]             {
[10:29:48.338]                 {
[10:29:48.338]                   {
[10:29:48.338]                     base::local({
[10:29:48.338]                       has_future <- base::requireNamespace("future", 
[10:29:48.338]                         quietly = TRUE)
[10:29:48.338]                       if (has_future) {
[10:29:48.338]                         ns <- base::getNamespace("future")
[10:29:48.338]                         version <- ns[[".package"]][["version"]]
[10:29:48.338]                         if (is.null(version)) 
[10:29:48.338]                           version <- utils::packageVersion("future")
[10:29:48.338]                       }
[10:29:48.338]                       else {
[10:29:48.338]                         version <- NULL
[10:29:48.338]                       }
[10:29:48.338]                       if (!has_future || version < "1.8.0") {
[10:29:48.338]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.338]                           "", base::R.version$version.string), 
[10:29:48.338]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:48.338]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.338]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.338]                             "release", "version")], collapse = " "), 
[10:29:48.338]                           hostname = base::Sys.info()[["nodename"]])
[10:29:48.338]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.338]                           info)
[10:29:48.338]                         info <- base::paste(info, collapse = "; ")
[10:29:48.338]                         if (!has_future) {
[10:29:48.338]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.338]                             info)
[10:29:48.338]                         }
[10:29:48.338]                         else {
[10:29:48.338]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.338]                             info, version)
[10:29:48.338]                         }
[10:29:48.338]                         base::stop(msg)
[10:29:48.338]                       }
[10:29:48.338]                     })
[10:29:48.338]                   }
[10:29:48.338]                   ...future.strategy.old <- future::plan("list")
[10:29:48.338]                   options(future.plan = NULL)
[10:29:48.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.338]                 }
[10:29:48.338]                 ...future.workdir <- getwd()
[10:29:48.338]             }
[10:29:48.338]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.338]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.338]         }
[10:29:48.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.338]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.338]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.338]             base::names(...future.oldOptions))
[10:29:48.338]     }
[10:29:48.338]     if (FALSE) {
[10:29:48.338]     }
[10:29:48.338]     else {
[10:29:48.338]         if (TRUE) {
[10:29:48.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.338]                 open = "w")
[10:29:48.338]         }
[10:29:48.338]         else {
[10:29:48.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.338]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.338]         }
[10:29:48.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.338]             base::sink(type = "output", split = FALSE)
[10:29:48.338]             base::close(...future.stdout)
[10:29:48.338]         }, add = TRUE)
[10:29:48.338]     }
[10:29:48.338]     ...future.frame <- base::sys.nframe()
[10:29:48.338]     ...future.conditions <- base::list()
[10:29:48.338]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.338]     if (FALSE) {
[10:29:48.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.338]     }
[10:29:48.338]     ...future.result <- base::tryCatch({
[10:29:48.338]         base::withCallingHandlers({
[10:29:48.338]             ...future.value <- base::withVisible(base::local({
[10:29:48.338]                 do.call(function(...) {
[10:29:48.338]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.338]                   if (!identical(...future.globals.maxSize.org, 
[10:29:48.338]                     ...future.globals.maxSize)) {
[10:29:48.338]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.338]                     on.exit(options(oopts), add = TRUE)
[10:29:48.338]                   }
[10:29:48.338]                   {
[10:29:48.338]                     lapply(seq_along(...future.elements_ii), 
[10:29:48.338]                       FUN = function(jj) {
[10:29:48.338]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.338]                         ...future.FUN(...future.X_jj, ...)
[10:29:48.338]                       })
[10:29:48.338]                   }
[10:29:48.338]                 }, args = future.call.arguments)
[10:29:48.338]             }))
[10:29:48.338]             future::FutureResult(value = ...future.value$value, 
[10:29:48.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.338]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.338]                     ...future.globalenv.names))
[10:29:48.338]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.338]         }, condition = base::local({
[10:29:48.338]             c <- base::c
[10:29:48.338]             inherits <- base::inherits
[10:29:48.338]             invokeRestart <- base::invokeRestart
[10:29:48.338]             length <- base::length
[10:29:48.338]             list <- base::list
[10:29:48.338]             seq.int <- base::seq.int
[10:29:48.338]             signalCondition <- base::signalCondition
[10:29:48.338]             sys.calls <- base::sys.calls
[10:29:48.338]             `[[` <- base::`[[`
[10:29:48.338]             `+` <- base::`+`
[10:29:48.338]             `<<-` <- base::`<<-`
[10:29:48.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.338]                   3L)]
[10:29:48.338]             }
[10:29:48.338]             function(cond) {
[10:29:48.338]                 is_error <- inherits(cond, "error")
[10:29:48.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.338]                   NULL)
[10:29:48.338]                 if (is_error) {
[10:29:48.338]                   sessionInformation <- function() {
[10:29:48.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.338]                       search = base::search(), system = base::Sys.info())
[10:29:48.338]                   }
[10:29:48.338]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.338]                     cond$call), session = sessionInformation(), 
[10:29:48.338]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.338]                   signalCondition(cond)
[10:29:48.338]                 }
[10:29:48.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.338]                 "immediateCondition"))) {
[10:29:48.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.338]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.338]                   if (TRUE && !signal) {
[10:29:48.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.338]                     {
[10:29:48.338]                       inherits <- base::inherits
[10:29:48.338]                       invokeRestart <- base::invokeRestart
[10:29:48.338]                       is.null <- base::is.null
[10:29:48.338]                       muffled <- FALSE
[10:29:48.338]                       if (inherits(cond, "message")) {
[10:29:48.338]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.338]                         if (muffled) 
[10:29:48.338]                           invokeRestart("muffleMessage")
[10:29:48.338]                       }
[10:29:48.338]                       else if (inherits(cond, "warning")) {
[10:29:48.338]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.338]                         if (muffled) 
[10:29:48.338]                           invokeRestart("muffleWarning")
[10:29:48.338]                       }
[10:29:48.338]                       else if (inherits(cond, "condition")) {
[10:29:48.338]                         if (!is.null(pattern)) {
[10:29:48.338]                           computeRestarts <- base::computeRestarts
[10:29:48.338]                           grepl <- base::grepl
[10:29:48.338]                           restarts <- computeRestarts(cond)
[10:29:48.338]                           for (restart in restarts) {
[10:29:48.338]                             name <- restart$name
[10:29:48.338]                             if (is.null(name)) 
[10:29:48.338]                               next
[10:29:48.338]                             if (!grepl(pattern, name)) 
[10:29:48.338]                               next
[10:29:48.338]                             invokeRestart(restart)
[10:29:48.338]                             muffled <- TRUE
[10:29:48.338]                             break
[10:29:48.338]                           }
[10:29:48.338]                         }
[10:29:48.338]                       }
[10:29:48.338]                       invisible(muffled)
[10:29:48.338]                     }
[10:29:48.338]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.338]                   }
[10:29:48.338]                 }
[10:29:48.338]                 else {
[10:29:48.338]                   if (TRUE) {
[10:29:48.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.338]                     {
[10:29:48.338]                       inherits <- base::inherits
[10:29:48.338]                       invokeRestart <- base::invokeRestart
[10:29:48.338]                       is.null <- base::is.null
[10:29:48.338]                       muffled <- FALSE
[10:29:48.338]                       if (inherits(cond, "message")) {
[10:29:48.338]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.338]                         if (muffled) 
[10:29:48.338]                           invokeRestart("muffleMessage")
[10:29:48.338]                       }
[10:29:48.338]                       else if (inherits(cond, "warning")) {
[10:29:48.338]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.338]                         if (muffled) 
[10:29:48.338]                           invokeRestart("muffleWarning")
[10:29:48.338]                       }
[10:29:48.338]                       else if (inherits(cond, "condition")) {
[10:29:48.338]                         if (!is.null(pattern)) {
[10:29:48.338]                           computeRestarts <- base::computeRestarts
[10:29:48.338]                           grepl <- base::grepl
[10:29:48.338]                           restarts <- computeRestarts(cond)
[10:29:48.338]                           for (restart in restarts) {
[10:29:48.338]                             name <- restart$name
[10:29:48.338]                             if (is.null(name)) 
[10:29:48.338]                               next
[10:29:48.338]                             if (!grepl(pattern, name)) 
[10:29:48.338]                               next
[10:29:48.338]                             invokeRestart(restart)
[10:29:48.338]                             muffled <- TRUE
[10:29:48.338]                             break
[10:29:48.338]                           }
[10:29:48.338]                         }
[10:29:48.338]                       }
[10:29:48.338]                       invisible(muffled)
[10:29:48.338]                     }
[10:29:48.338]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.338]                   }
[10:29:48.338]                 }
[10:29:48.338]             }
[10:29:48.338]         }))
[10:29:48.338]     }, error = function(ex) {
[10:29:48.338]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.338]                 ...future.rng), started = ...future.startTime, 
[10:29:48.338]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.338]             version = "1.8"), class = "FutureResult")
[10:29:48.338]     }, finally = {
[10:29:48.338]         if (!identical(...future.workdir, getwd())) 
[10:29:48.338]             setwd(...future.workdir)
[10:29:48.338]         {
[10:29:48.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.338]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.338]             }
[10:29:48.338]             base::options(...future.oldOptions)
[10:29:48.338]             if (.Platform$OS.type == "windows") {
[10:29:48.338]                 old_names <- names(...future.oldEnvVars)
[10:29:48.338]                 envs <- base::Sys.getenv()
[10:29:48.338]                 names <- names(envs)
[10:29:48.338]                 common <- intersect(names, old_names)
[10:29:48.338]                 added <- setdiff(names, old_names)
[10:29:48.338]                 removed <- setdiff(old_names, names)
[10:29:48.338]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.338]                   envs[common]]
[10:29:48.338]                 NAMES <- toupper(changed)
[10:29:48.338]                 args <- list()
[10:29:48.338]                 for (kk in seq_along(NAMES)) {
[10:29:48.338]                   name <- changed[[kk]]
[10:29:48.338]                   NAME <- NAMES[[kk]]
[10:29:48.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.338]                     next
[10:29:48.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.338]                 }
[10:29:48.338]                 NAMES <- toupper(added)
[10:29:48.338]                 for (kk in seq_along(NAMES)) {
[10:29:48.338]                   name <- added[[kk]]
[10:29:48.338]                   NAME <- NAMES[[kk]]
[10:29:48.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.338]                     next
[10:29:48.338]                   args[[name]] <- ""
[10:29:48.338]                 }
[10:29:48.338]                 NAMES <- toupper(removed)
[10:29:48.338]                 for (kk in seq_along(NAMES)) {
[10:29:48.338]                   name <- removed[[kk]]
[10:29:48.338]                   NAME <- NAMES[[kk]]
[10:29:48.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.338]                     next
[10:29:48.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.338]                 }
[10:29:48.338]                 if (length(args) > 0) 
[10:29:48.338]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.338]             }
[10:29:48.338]             else {
[10:29:48.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.338]             }
[10:29:48.338]             {
[10:29:48.338]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.338]                   0L) {
[10:29:48.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.338]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.338]                   base::options(opts)
[10:29:48.338]                 }
[10:29:48.338]                 {
[10:29:48.338]                   {
[10:29:48.338]                     NULL
[10:29:48.338]                     RNGkind("Mersenne-Twister")
[10:29:48.338]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:48.338]                       inherits = FALSE)
[10:29:48.338]                   }
[10:29:48.338]                   options(future.plan = NULL)
[10:29:48.338]                   if (is.na(NA_character_)) 
[10:29:48.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.338]                     .init = FALSE)
[10:29:48.338]                 }
[10:29:48.338]             }
[10:29:48.338]         }
[10:29:48.338]     })
[10:29:48.338]     if (TRUE) {
[10:29:48.338]         base::sink(type = "output", split = FALSE)
[10:29:48.338]         if (TRUE) {
[10:29:48.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.338]         }
[10:29:48.338]         else {
[10:29:48.338]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.338]         }
[10:29:48.338]         base::close(...future.stdout)
[10:29:48.338]         ...future.stdout <- NULL
[10:29:48.338]     }
[10:29:48.338]     ...future.result$conditions <- ...future.conditions
[10:29:48.338]     ...future.result$finished <- base::Sys.time()
[10:29:48.338]     ...future.result
[10:29:48.338] }
[10:29:48.340] assign_globals() ...
[10:29:48.340] List of 5
[10:29:48.340]  $ future.call.arguments    : list()
[10:29:48.340]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.340]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.340]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.340]  $ ...future.elements_ii    :List of 2
[10:29:48.340]   ..$ : num [1:4] 1 3 1 7
[10:29:48.340]   ..$ : num [1:4] 2 4 6 8
[10:29:48.340]  $ ...future.seeds_ii       : NULL
[10:29:48.340]  $ ...future.globals.maxSize: num Inf
[10:29:48.340]  - attr(*, "resolved")= logi FALSE
[10:29:48.340]  - attr(*, "total_size")= num NA
[10:29:48.340]  - attr(*, "where")=List of 5
[10:29:48.340]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.340]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.340]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.340]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.340]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.340]  - attr(*, "already-done")= logi TRUE
[10:29:48.347] - copied ‘future.call.arguments’ to environment
[10:29:48.347] - copied ‘...future.FUN’ to environment
[10:29:48.347] - copied ‘...future.elements_ii’ to environment
[10:29:48.347] - copied ‘...future.seeds_ii’ to environment
[10:29:48.347] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.347] assign_globals() ... done
[10:29:48.347] plan(): Setting new future strategy stack:
[10:29:48.347] List of future strategies:
[10:29:48.347] 1. sequential:
[10:29:48.347]    - args: function (..., envir = parent.frame())
[10:29:48.347]    - tweaked: FALSE
[10:29:48.347]    - call: NULL
[10:29:48.348] plan(): nbrOfWorkers() = 1
[10:29:48.349] plan(): Setting new future strategy stack:
[10:29:48.349] List of future strategies:
[10:29:48.349] 1. sequential:
[10:29:48.349]    - args: function (..., envir = parent.frame())
[10:29:48.349]    - tweaked: FALSE
[10:29:48.349]    - call: plan(strategy)
[10:29:48.349] plan(): nbrOfWorkers() = 1
[10:29:48.349] SequentialFuture started (and completed)
[10:29:48.350] - Launch lazy future ... done
[10:29:48.350] run() for ‘SequentialFuture’ ... done
[10:29:48.350] Created future:
[10:29:48.350] SequentialFuture:
[10:29:48.350] Label: ‘future_apply-1’
[10:29:48.350] Expression:
[10:29:48.350] {
[10:29:48.350]     do.call(function(...) {
[10:29:48.350]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.350]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.350]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.350]             on.exit(options(oopts), add = TRUE)
[10:29:48.350]         }
[10:29:48.350]         {
[10:29:48.350]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.350]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.350]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.350]             })
[10:29:48.350]         }
[10:29:48.350]     }, args = future.call.arguments)
[10:29:48.350] }
[10:29:48.350] Lazy evaluation: FALSE
[10:29:48.350] Asynchronous evaluation: FALSE
[10:29:48.350] Local evaluation: TRUE
[10:29:48.350] Environment: R_GlobalEnv
[10:29:48.350] Capture standard output: TRUE
[10:29:48.350] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.350] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.350] Packages: <none>
[10:29:48.350] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.350] Resolved: TRUE
[10:29:48.350] Value: 2.21 KiB of class ‘list’
[10:29:48.350] Early signaling: FALSE
[10:29:48.350] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.350] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.351] Chunk #1 of 1 ... DONE
[10:29:48.351] Launching 1 futures (chunks) ... DONE
[10:29:48.351] Resolving 1 futures (chunks) ...
[10:29:48.351] resolve() on list ...
[10:29:48.351]  recursive: 0
[10:29:48.351]  length: 1
[10:29:48.351] 
[10:29:48.352] resolved() for ‘SequentialFuture’ ...
[10:29:48.352] - state: ‘finished’
[10:29:48.352] - run: TRUE
[10:29:48.352] - result: ‘FutureResult’
[10:29:48.352] resolved() for ‘SequentialFuture’ ... done
[10:29:48.352] Future #1
[10:29:48.352] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:48.352] - nx: 1
[10:29:48.352] - relay: TRUE
[10:29:48.352] - stdout: TRUE
[10:29:48.353] - signal: TRUE
[10:29:48.353] - resignal: FALSE
[10:29:48.353] - force: TRUE
[10:29:48.353] - relayed: [n=1] FALSE
[10:29:48.353] - queued futures: [n=1] FALSE
[10:29:48.353]  - until=1
[10:29:48.353]  - relaying element #1
[10:29:48.353] - relayed: [n=1] TRUE
[10:29:48.353] - queued futures: [n=1] TRUE
[10:29:48.353] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:48.354]  length: 0 (resolved future 1)
[10:29:48.354] Relaying remaining futures
[10:29:48.354] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.354] - nx: 1
[10:29:48.354] - relay: TRUE
[10:29:48.354] - stdout: TRUE
[10:29:48.354] - signal: TRUE
[10:29:48.354] - resignal: FALSE
[10:29:48.354] - force: TRUE
[10:29:48.354] - relayed: [n=1] TRUE
[10:29:48.354] - queued futures: [n=1] TRUE
 - flush all
[10:29:48.355] - relayed: [n=1] TRUE
[10:29:48.355] - queued futures: [n=1] TRUE
[10:29:48.355] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.355] resolve() on list ... DONE
[10:29:48.355]  - Number of value chunks collected: 1
[10:29:48.355] Resolving 1 futures (chunks) ... DONE
[10:29:48.355] Reducing values from 1 chunks ...
[10:29:48.355]  - Number of values collected after concatenation: 2
[10:29:48.355]  - Number of values expected: 2
[10:29:48.355] Reducing values from 1 chunks ... DONE
[10:29:48.355] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:29:48.358] getGlobalsAndPackagesXApply() ...
[10:29:48.358]  - future.globals: TRUE
[10:29:48.358] getGlobalsAndPackages() ...
[10:29:48.358] Searching for globals...
[10:29:48.359] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:48.359] Searching for globals ... DONE
[10:29:48.359] Resolving globals: FALSE
[10:29:48.360] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:48.360] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:48.360] - globals: [1] ‘FUN’
[10:29:48.360] - packages: [1] ‘stats’
[10:29:48.361] getGlobalsAndPackages() ... DONE
[10:29:48.361]  - globals found/used: [n=1] ‘FUN’
[10:29:48.361]  - needed namespaces: [n=1] ‘stats’
[10:29:48.361] Finding globals ... DONE
[10:29:48.361]  - use_args: TRUE
[10:29:48.361]  - Getting '...' globals ...
[10:29:48.361] resolve() on list ...
[10:29:48.361]  recursive: 0
[10:29:48.362]  length: 1
[10:29:48.362]  elements: ‘...’
[10:29:48.362]  length: 0 (resolved future 1)
[10:29:48.362] resolve() on list ... DONE
[10:29:48.362]    - '...' content: [n=0] 
[10:29:48.362] List of 1
[10:29:48.362]  $ ...: list()
[10:29:48.362]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.362]  - attr(*, "where")=List of 1
[10:29:48.362]   ..$ ...:<environment: 0x5618a1b38c08> 
[10:29:48.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.362]  - attr(*, "resolved")= logi TRUE
[10:29:48.362]  - attr(*, "total_size")= num NA
[10:29:48.364]  - Getting '...' globals ... DONE
[10:29:48.365] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.365] List of 2
[10:29:48.365]  $ ...future.FUN:function (x, ...)  
[10:29:48.365]  $ ...          : list()
[10:29:48.365]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.365]  - attr(*, "where")=List of 2
[10:29:48.365]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.365]   ..$ ...          :<environment: 0x5618a1b38c08> 
[10:29:48.365]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.365]  - attr(*, "resolved")= logi FALSE
[10:29:48.365]  - attr(*, "total_size")= num 1248
[10:29:48.367] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:48.367] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.368] future_lapply() ...
[10:29:48.370] Number of chunks: 1
[10:29:48.370] getGlobalsAndPackagesXApply() ...
[10:29:48.370]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.370]  - use_args: TRUE
[10:29:48.370] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.370] List of 2
[10:29:48.370]  $ ...          : list()
[10:29:48.370]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.370]  $ ...future.FUN:function (x, ...)  
[10:29:48.370]  - attr(*, "where")=List of 2
[10:29:48.370]   ..$ ...          :<environment: 0x5618a1b38c08> 
[10:29:48.370]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:29:48.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.370]  - attr(*, "resolved")= logi FALSE
[10:29:48.370]  - attr(*, "total_size")= num NA
[10:29:48.373] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:48.373] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.373] Number of futures (= number of chunks): 1
[10:29:48.373] Launching 1 futures (chunks) ...
[10:29:48.373] Chunk #1 of 1 ...
[10:29:48.374]  - seeds: <none>
[10:29:48.374]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.374] getGlobalsAndPackages() ...
[10:29:48.374] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.374] Resolving globals: FALSE
[10:29:48.374] Tweak future expression to call with '...' arguments ...
[10:29:48.374] {
[10:29:48.374]     do.call(function(...) {
[10:29:48.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.374]             on.exit(options(oopts), add = TRUE)
[10:29:48.374]         }
[10:29:48.374]         {
[10:29:48.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.374]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.374]             })
[10:29:48.374]         }
[10:29:48.374]     }, args = future.call.arguments)
[10:29:48.374] }
[10:29:48.375] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.375] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.375] - packages: [1] ‘stats’
[10:29:48.375] getGlobalsAndPackages() ... DONE
[10:29:48.375] run() for ‘Future’ ...
[10:29:48.376] - state: ‘created’
[10:29:48.376] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:48.376] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:48.376]   - Field: ‘label’
[10:29:48.376]   - Field: ‘local’
[10:29:48.376]   - Field: ‘owner’
[10:29:48.376]   - Field: ‘envir’
[10:29:48.377]   - Field: ‘packages’
[10:29:48.377]   - Field: ‘gc’
[10:29:48.377]   - Field: ‘conditions’
[10:29:48.377]   - Field: ‘expr’
[10:29:48.377]   - Field: ‘uuid’
[10:29:48.377]   - Field: ‘seed’
[10:29:48.377]   - Field: ‘version’
[10:29:48.377]   - Field: ‘result’
[10:29:48.377]   - Field: ‘asynchronous’
[10:29:48.377]   - Field: ‘calls’
[10:29:48.377]   - Field: ‘globals’
[10:29:48.378]   - Field: ‘stdout’
[10:29:48.378]   - Field: ‘earlySignal’
[10:29:48.378]   - Field: ‘lazy’
[10:29:48.378]   - Field: ‘state’
[10:29:48.378] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:48.378] - Launch lazy future ...
[10:29:48.378] Packages needed by the future expression (n = 1): ‘stats’
[10:29:48.378] Packages needed by future strategies (n = 0): <none>
[10:29:48.379] {
[10:29:48.379]     {
[10:29:48.379]         {
[10:29:48.379]             ...future.startTime <- base::Sys.time()
[10:29:48.379]             {
[10:29:48.379]                 {
[10:29:48.379]                   {
[10:29:48.379]                     {
[10:29:48.379]                       base::local({
[10:29:48.379]                         has_future <- base::requireNamespace("future", 
[10:29:48.379]                           quietly = TRUE)
[10:29:48.379]                         if (has_future) {
[10:29:48.379]                           ns <- base::getNamespace("future")
[10:29:48.379]                           version <- ns[[".package"]][["version"]]
[10:29:48.379]                           if (is.null(version)) 
[10:29:48.379]                             version <- utils::packageVersion("future")
[10:29:48.379]                         }
[10:29:48.379]                         else {
[10:29:48.379]                           version <- NULL
[10:29:48.379]                         }
[10:29:48.379]                         if (!has_future || version < "1.8.0") {
[10:29:48.379]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.379]                             "", base::R.version$version.string), 
[10:29:48.379]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:48.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.379]                               "release", "version")], collapse = " "), 
[10:29:48.379]                             hostname = base::Sys.info()[["nodename"]])
[10:29:48.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.379]                             info)
[10:29:48.379]                           info <- base::paste(info, collapse = "; ")
[10:29:48.379]                           if (!has_future) {
[10:29:48.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.379]                               info)
[10:29:48.379]                           }
[10:29:48.379]                           else {
[10:29:48.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.379]                               info, version)
[10:29:48.379]                           }
[10:29:48.379]                           base::stop(msg)
[10:29:48.379]                         }
[10:29:48.379]                       })
[10:29:48.379]                     }
[10:29:48.379]                     base::local({
[10:29:48.379]                       for (pkg in "stats") {
[10:29:48.379]                         base::loadNamespace(pkg)
[10:29:48.379]                         base::library(pkg, character.only = TRUE)
[10:29:48.379]                       }
[10:29:48.379]                     })
[10:29:48.379]                   }
[10:29:48.379]                   ...future.strategy.old <- future::plan("list")
[10:29:48.379]                   options(future.plan = NULL)
[10:29:48.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.379]                 }
[10:29:48.379]                 ...future.workdir <- getwd()
[10:29:48.379]             }
[10:29:48.379]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.379]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.379]         }
[10:29:48.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.379]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.379]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.379]             base::names(...future.oldOptions))
[10:29:48.379]     }
[10:29:48.379]     if (FALSE) {
[10:29:48.379]     }
[10:29:48.379]     else {
[10:29:48.379]         if (TRUE) {
[10:29:48.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.379]                 open = "w")
[10:29:48.379]         }
[10:29:48.379]         else {
[10:29:48.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.379]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.379]         }
[10:29:48.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.379]             base::sink(type = "output", split = FALSE)
[10:29:48.379]             base::close(...future.stdout)
[10:29:48.379]         }, add = TRUE)
[10:29:48.379]     }
[10:29:48.379]     ...future.frame <- base::sys.nframe()
[10:29:48.379]     ...future.conditions <- base::list()
[10:29:48.379]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.379]     if (FALSE) {
[10:29:48.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.379]     }
[10:29:48.379]     ...future.result <- base::tryCatch({
[10:29:48.379]         base::withCallingHandlers({
[10:29:48.379]             ...future.value <- base::withVisible(base::local({
[10:29:48.379]                 do.call(function(...) {
[10:29:48.379]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.379]                   if (!identical(...future.globals.maxSize.org, 
[10:29:48.379]                     ...future.globals.maxSize)) {
[10:29:48.379]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.379]                     on.exit(options(oopts), add = TRUE)
[10:29:48.379]                   }
[10:29:48.379]                   {
[10:29:48.379]                     lapply(seq_along(...future.elements_ii), 
[10:29:48.379]                       FUN = function(jj) {
[10:29:48.379]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.379]                         ...future.FUN(...future.X_jj, ...)
[10:29:48.379]                       })
[10:29:48.379]                   }
[10:29:48.379]                 }, args = future.call.arguments)
[10:29:48.379]             }))
[10:29:48.379]             future::FutureResult(value = ...future.value$value, 
[10:29:48.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.379]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.379]                     ...future.globalenv.names))
[10:29:48.379]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.379]         }, condition = base::local({
[10:29:48.379]             c <- base::c
[10:29:48.379]             inherits <- base::inherits
[10:29:48.379]             invokeRestart <- base::invokeRestart
[10:29:48.379]             length <- base::length
[10:29:48.379]             list <- base::list
[10:29:48.379]             seq.int <- base::seq.int
[10:29:48.379]             signalCondition <- base::signalCondition
[10:29:48.379]             sys.calls <- base::sys.calls
[10:29:48.379]             `[[` <- base::`[[`
[10:29:48.379]             `+` <- base::`+`
[10:29:48.379]             `<<-` <- base::`<<-`
[10:29:48.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.379]                   3L)]
[10:29:48.379]             }
[10:29:48.379]             function(cond) {
[10:29:48.379]                 is_error <- inherits(cond, "error")
[10:29:48.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.379]                   NULL)
[10:29:48.379]                 if (is_error) {
[10:29:48.379]                   sessionInformation <- function() {
[10:29:48.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.379]                       search = base::search(), system = base::Sys.info())
[10:29:48.379]                   }
[10:29:48.379]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.379]                     cond$call), session = sessionInformation(), 
[10:29:48.379]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.379]                   signalCondition(cond)
[10:29:48.379]                 }
[10:29:48.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.379]                 "immediateCondition"))) {
[10:29:48.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.379]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.379]                   if (TRUE && !signal) {
[10:29:48.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.379]                     {
[10:29:48.379]                       inherits <- base::inherits
[10:29:48.379]                       invokeRestart <- base::invokeRestart
[10:29:48.379]                       is.null <- base::is.null
[10:29:48.379]                       muffled <- FALSE
[10:29:48.379]                       if (inherits(cond, "message")) {
[10:29:48.379]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.379]                         if (muffled) 
[10:29:48.379]                           invokeRestart("muffleMessage")
[10:29:48.379]                       }
[10:29:48.379]                       else if (inherits(cond, "warning")) {
[10:29:48.379]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.379]                         if (muffled) 
[10:29:48.379]                           invokeRestart("muffleWarning")
[10:29:48.379]                       }
[10:29:48.379]                       else if (inherits(cond, "condition")) {
[10:29:48.379]                         if (!is.null(pattern)) {
[10:29:48.379]                           computeRestarts <- base::computeRestarts
[10:29:48.379]                           grepl <- base::grepl
[10:29:48.379]                           restarts <- computeRestarts(cond)
[10:29:48.379]                           for (restart in restarts) {
[10:29:48.379]                             name <- restart$name
[10:29:48.379]                             if (is.null(name)) 
[10:29:48.379]                               next
[10:29:48.379]                             if (!grepl(pattern, name)) 
[10:29:48.379]                               next
[10:29:48.379]                             invokeRestart(restart)
[10:29:48.379]                             muffled <- TRUE
[10:29:48.379]                             break
[10:29:48.379]                           }
[10:29:48.379]                         }
[10:29:48.379]                       }
[10:29:48.379]                       invisible(muffled)
[10:29:48.379]                     }
[10:29:48.379]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.379]                   }
[10:29:48.379]                 }
[10:29:48.379]                 else {
[10:29:48.379]                   if (TRUE) {
[10:29:48.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.379]                     {
[10:29:48.379]                       inherits <- base::inherits
[10:29:48.379]                       invokeRestart <- base::invokeRestart
[10:29:48.379]                       is.null <- base::is.null
[10:29:48.379]                       muffled <- FALSE
[10:29:48.379]                       if (inherits(cond, "message")) {
[10:29:48.379]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.379]                         if (muffled) 
[10:29:48.379]                           invokeRestart("muffleMessage")
[10:29:48.379]                       }
[10:29:48.379]                       else if (inherits(cond, "warning")) {
[10:29:48.379]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.379]                         if (muffled) 
[10:29:48.379]                           invokeRestart("muffleWarning")
[10:29:48.379]                       }
[10:29:48.379]                       else if (inherits(cond, "condition")) {
[10:29:48.379]                         if (!is.null(pattern)) {
[10:29:48.379]                           computeRestarts <- base::computeRestarts
[10:29:48.379]                           grepl <- base::grepl
[10:29:48.379]                           restarts <- computeRestarts(cond)
[10:29:48.379]                           for (restart in restarts) {
[10:29:48.379]                             name <- restart$name
[10:29:48.379]                             if (is.null(name)) 
[10:29:48.379]                               next
[10:29:48.379]                             if (!grepl(pattern, name)) 
[10:29:48.379]                               next
[10:29:48.379]                             invokeRestart(restart)
[10:29:48.379]                             muffled <- TRUE
[10:29:48.379]                             break
[10:29:48.379]                           }
[10:29:48.379]                         }
[10:29:48.379]                       }
[10:29:48.379]                       invisible(muffled)
[10:29:48.379]                     }
[10:29:48.379]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.379]                   }
[10:29:48.379]                 }
[10:29:48.379]             }
[10:29:48.379]         }))
[10:29:48.379]     }, error = function(ex) {
[10:29:48.379]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.379]                 ...future.rng), started = ...future.startTime, 
[10:29:48.379]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.379]             version = "1.8"), class = "FutureResult")
[10:29:48.379]     }, finally = {
[10:29:48.379]         if (!identical(...future.workdir, getwd())) 
[10:29:48.379]             setwd(...future.workdir)
[10:29:48.379]         {
[10:29:48.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.379]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.379]             }
[10:29:48.379]             base::options(...future.oldOptions)
[10:29:48.379]             if (.Platform$OS.type == "windows") {
[10:29:48.379]                 old_names <- names(...future.oldEnvVars)
[10:29:48.379]                 envs <- base::Sys.getenv()
[10:29:48.379]                 names <- names(envs)
[10:29:48.379]                 common <- intersect(names, old_names)
[10:29:48.379]                 added <- setdiff(names, old_names)
[10:29:48.379]                 removed <- setdiff(old_names, names)
[10:29:48.379]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.379]                   envs[common]]
[10:29:48.379]                 NAMES <- toupper(changed)
[10:29:48.379]                 args <- list()
[10:29:48.379]                 for (kk in seq_along(NAMES)) {
[10:29:48.379]                   name <- changed[[kk]]
[10:29:48.379]                   NAME <- NAMES[[kk]]
[10:29:48.379]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.379]                     next
[10:29:48.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.379]                 }
[10:29:48.379]                 NAMES <- toupper(added)
[10:29:48.379]                 for (kk in seq_along(NAMES)) {
[10:29:48.379]                   name <- added[[kk]]
[10:29:48.379]                   NAME <- NAMES[[kk]]
[10:29:48.379]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.379]                     next
[10:29:48.379]                   args[[name]] <- ""
[10:29:48.379]                 }
[10:29:48.379]                 NAMES <- toupper(removed)
[10:29:48.379]                 for (kk in seq_along(NAMES)) {
[10:29:48.379]                   name <- removed[[kk]]
[10:29:48.379]                   NAME <- NAMES[[kk]]
[10:29:48.379]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.379]                     next
[10:29:48.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.379]                 }
[10:29:48.379]                 if (length(args) > 0) 
[10:29:48.379]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.379]             }
[10:29:48.379]             else {
[10:29:48.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.379]             }
[10:29:48.379]             {
[10:29:48.379]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.379]                   0L) {
[10:29:48.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.379]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.379]                   base::options(opts)
[10:29:48.379]                 }
[10:29:48.379]                 {
[10:29:48.379]                   {
[10:29:48.379]                     NULL
[10:29:48.379]                     RNGkind("Mersenne-Twister")
[10:29:48.379]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:48.379]                       inherits = FALSE)
[10:29:48.379]                   }
[10:29:48.379]                   options(future.plan = NULL)
[10:29:48.379]                   if (is.na(NA_character_)) 
[10:29:48.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.379]                     .init = FALSE)
[10:29:48.379]                 }
[10:29:48.379]             }
[10:29:48.379]         }
[10:29:48.379]     })
[10:29:48.379]     if (TRUE) {
[10:29:48.379]         base::sink(type = "output", split = FALSE)
[10:29:48.379]         if (TRUE) {
[10:29:48.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.379]         }
[10:29:48.379]         else {
[10:29:48.379]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.379]         }
[10:29:48.379]         base::close(...future.stdout)
[10:29:48.379]         ...future.stdout <- NULL
[10:29:48.379]     }
[10:29:48.379]     ...future.result$conditions <- ...future.conditions
[10:29:48.379]     ...future.result$finished <- base::Sys.time()
[10:29:48.379]     ...future.result
[10:29:48.379] }
[10:29:48.381] assign_globals() ...
[10:29:48.381] List of 5
[10:29:48.381]  $ future.call.arguments    : list()
[10:29:48.381]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.381]  $ ...future.FUN            :function (x, ...)  
[10:29:48.381]  $ ...future.elements_ii    :List of 2
[10:29:48.381]   ..$ : num [1:4] 1 3 1 7
[10:29:48.381]   ..$ : num [1:4] 2 4 6 8
[10:29:48.381]  $ ...future.seeds_ii       : NULL
[10:29:48.381]  $ ...future.globals.maxSize: num Inf
[10:29:48.381]  - attr(*, "resolved")= logi FALSE
[10:29:48.381]  - attr(*, "total_size")= num NA
[10:29:48.381]  - attr(*, "where")=List of 5
[10:29:48.381]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.381]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.381]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.381]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.381]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.381]  - attr(*, "already-done")= logi TRUE
[10:29:48.386] - copied ‘future.call.arguments’ to environment
[10:29:48.386] - copied ‘...future.FUN’ to environment
[10:29:48.386] - copied ‘...future.elements_ii’ to environment
[10:29:48.386] - copied ‘...future.seeds_ii’ to environment
[10:29:48.386] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.386] assign_globals() ... done
[10:29:48.387] plan(): Setting new future strategy stack:
[10:29:48.387] List of future strategies:
[10:29:48.387] 1. sequential:
[10:29:48.387]    - args: function (..., envir = parent.frame())
[10:29:48.387]    - tweaked: FALSE
[10:29:48.387]    - call: NULL
[10:29:48.387] plan(): nbrOfWorkers() = 1
[10:29:48.388] plan(): Setting new future strategy stack:
[10:29:48.388] List of future strategies:
[10:29:48.388] 1. sequential:
[10:29:48.388]    - args: function (..., envir = parent.frame())
[10:29:48.388]    - tweaked: FALSE
[10:29:48.388]    - call: plan(strategy)
[10:29:48.388] plan(): nbrOfWorkers() = 1
[10:29:48.389] SequentialFuture started (and completed)
[10:29:48.389] - Launch lazy future ... done
[10:29:48.389] run() for ‘SequentialFuture’ ... done
[10:29:48.389] Created future:
[10:29:48.389] SequentialFuture:
[10:29:48.389] Label: ‘future_apply-1’
[10:29:48.389] Expression:
[10:29:48.389] {
[10:29:48.389]     do.call(function(...) {
[10:29:48.389]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.389]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.389]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.389]             on.exit(options(oopts), add = TRUE)
[10:29:48.389]         }
[10:29:48.389]         {
[10:29:48.389]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.389]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.389]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.389]             })
[10:29:48.389]         }
[10:29:48.389]     }, args = future.call.arguments)
[10:29:48.389] }
[10:29:48.389] Lazy evaluation: FALSE
[10:29:48.389] Asynchronous evaluation: FALSE
[10:29:48.389] Local evaluation: TRUE
[10:29:48.389] Environment: R_GlobalEnv
[10:29:48.389] Capture standard output: TRUE
[10:29:48.389] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.389] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.389] Packages: 1 packages (‘stats’)
[10:29:48.389] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.389] Resolved: TRUE
[10:29:48.389] Value: 1.14 KiB of class ‘list’
[10:29:48.389] Early signaling: FALSE
[10:29:48.389] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.389] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.390] Chunk #1 of 1 ... DONE
[10:29:48.390] Launching 1 futures (chunks) ... DONE
[10:29:48.390] Resolving 1 futures (chunks) ...
[10:29:48.390] resolve() on list ...
[10:29:48.390]  recursive: 0
[10:29:48.391]  length: 1
[10:29:48.391] 
[10:29:48.391] resolved() for ‘SequentialFuture’ ...
[10:29:48.391] - state: ‘finished’
[10:29:48.391] - run: TRUE
[10:29:48.391] - result: ‘FutureResult’
[10:29:48.391] resolved() for ‘SequentialFuture’ ... done
[10:29:48.391] Future #1
[10:29:48.391] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:48.391] - nx: 1
[10:29:48.392] - relay: TRUE
[10:29:48.392] - stdout: TRUE
[10:29:48.392] - signal: TRUE
[10:29:48.393] - resignal: FALSE
[10:29:48.393] - force: TRUE
[10:29:48.393] - relayed: [n=1] FALSE
[10:29:48.393] - queued futures: [n=1] FALSE
[10:29:48.394]  - until=1
[10:29:48.394]  - relaying element #1
[10:29:48.394] - relayed: [n=1] TRUE
[10:29:48.394] - queued futures: [n=1] TRUE
[10:29:48.394] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:48.394]  length: 0 (resolved future 1)
[10:29:48.394] Relaying remaining futures
[10:29:48.394] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.394] - nx: 1
[10:29:48.394] - relay: TRUE
[10:29:48.395] - stdout: TRUE
[10:29:48.395] - signal: TRUE
[10:29:48.395] - resignal: FALSE
[10:29:48.395] - force: TRUE
[10:29:48.395] - relayed: [n=1] TRUE
[10:29:48.395] - queued futures: [n=1] TRUE
 - flush all
[10:29:48.395] - relayed: [n=1] TRUE
[10:29:48.395] - queued futures: [n=1] TRUE
[10:29:48.395] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.395] resolve() on list ... DONE
[10:29:48.396]  - Number of value chunks collected: 1
[10:29:48.396] Resolving 1 futures (chunks) ... DONE
[10:29:48.396] Reducing values from 1 chunks ...
[10:29:48.396]  - Number of values collected after concatenation: 2
[10:29:48.396]  - Number of values expected: 2
[10:29:48.396] Reducing values from 1 chunks ... DONE
[10:29:48.396] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:29:48.397] getGlobalsAndPackagesXApply() ...
[10:29:48.397]  - future.globals: TRUE
[10:29:48.397] getGlobalsAndPackages() ...
[10:29:48.397] Searching for globals...
[10:29:48.398] - globals found: [1] ‘FUN’
[10:29:48.398] Searching for globals ... DONE
[10:29:48.398] Resolving globals: FALSE
[10:29:48.399] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:48.399] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:48.399] - globals: [1] ‘FUN’
[10:29:48.399] 
[10:29:48.399] getGlobalsAndPackages() ... DONE
[10:29:48.399]  - globals found/used: [n=1] ‘FUN’
[10:29:48.399]  - needed namespaces: [n=0] 
[10:29:48.400] Finding globals ... DONE
[10:29:48.400]  - use_args: TRUE
[10:29:48.400]  - Getting '...' globals ...
[10:29:48.400] resolve() on list ...
[10:29:48.400]  recursive: 0
[10:29:48.400]  length: 1
[10:29:48.400]  elements: ‘...’
[10:29:48.400]  length: 0 (resolved future 1)
[10:29:48.401] resolve() on list ... DONE
[10:29:48.401]    - '...' content: [n=0] 
[10:29:48.401] List of 1
[10:29:48.401]  $ ...: list()
[10:29:48.401]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.401]  - attr(*, "where")=List of 1
[10:29:48.401]   ..$ ...:<environment: 0x5618a0531bd0> 
[10:29:48.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.401]  - attr(*, "resolved")= logi TRUE
[10:29:48.401]  - attr(*, "total_size")= num NA
[10:29:48.403]  - Getting '...' globals ... DONE
[10:29:48.403] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.403] List of 2
[10:29:48.403]  $ ...future.FUN:function (x)  
[10:29:48.403]  $ ...          : list()
[10:29:48.403]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.403]  - attr(*, "where")=List of 2
[10:29:48.403]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.403]   ..$ ...          :<environment: 0x5618a0531bd0> 
[10:29:48.403]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.403]  - attr(*, "resolved")= logi FALSE
[10:29:48.403]  - attr(*, "total_size")= num 848
[10:29:48.406] Packages to be attached in all futures: [n=0] 
[10:29:48.406] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.406] future_lapply() ...
[10:29:48.407] Number of chunks: 1
[10:29:48.407] getGlobalsAndPackagesXApply() ...
[10:29:48.407]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.407]  - use_args: TRUE
[10:29:48.407] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.407] List of 2
[10:29:48.407]  $ ...          : list()
[10:29:48.407]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.407]  $ ...future.FUN:function (x)  
[10:29:48.407]  - attr(*, "where")=List of 2
[10:29:48.407]   ..$ ...          :<environment: 0x5618a0531bd0> 
[10:29:48.407]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:48.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.407]  - attr(*, "resolved")= logi FALSE
[10:29:48.407]  - attr(*, "total_size")= num NA
[10:29:48.410] Packages to be attached in all futures: [n=0] 
[10:29:48.411] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.411] Number of futures (= number of chunks): 1
[10:29:48.411] Launching 1 futures (chunks) ...
[10:29:48.411] Chunk #1 of 1 ...
[10:29:48.411]  - seeds: <none>
[10:29:48.411]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.411] getGlobalsAndPackages() ...
[10:29:48.411] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.412] Resolving globals: FALSE
[10:29:48.412] Tweak future expression to call with '...' arguments ...
[10:29:48.412] {
[10:29:48.412]     do.call(function(...) {
[10:29:48.412]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.412]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.412]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.412]             on.exit(options(oopts), add = TRUE)
[10:29:48.412]         }
[10:29:48.412]         {
[10:29:48.412]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.412]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.412]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.412]             })
[10:29:48.412]         }
[10:29:48.412]     }, args = future.call.arguments)
[10:29:48.412] }
[10:29:48.412] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.412] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.412] 
[10:29:48.413] getGlobalsAndPackages() ... DONE
[10:29:48.413] run() for ‘Future’ ...
[10:29:48.413] - state: ‘created’
[10:29:48.413] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:48.413] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.413] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:48.414]   - Field: ‘label’
[10:29:48.414]   - Field: ‘local’
[10:29:48.414]   - Field: ‘owner’
[10:29:48.414]   - Field: ‘envir’
[10:29:48.415]   - Field: ‘packages’
[10:29:48.415]   - Field: ‘gc’
[10:29:48.415]   - Field: ‘conditions’
[10:29:48.415]   - Field: ‘expr’
[10:29:48.415]   - Field: ‘uuid’
[10:29:48.416]   - Field: ‘seed’
[10:29:48.416]   - Field: ‘version’
[10:29:48.416]   - Field: ‘result’
[10:29:48.416]   - Field: ‘asynchronous’
[10:29:48.416]   - Field: ‘calls’
[10:29:48.416]   - Field: ‘globals’
[10:29:48.416]   - Field: ‘stdout’
[10:29:48.416]   - Field: ‘earlySignal’
[10:29:48.416]   - Field: ‘lazy’
[10:29:48.416]   - Field: ‘state’
[10:29:48.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:48.417] - Launch lazy future ...
[10:29:48.417] Packages needed by the future expression (n = 0): <none>
[10:29:48.417] Packages needed by future strategies (n = 0): <none>
[10:29:48.417] {
[10:29:48.417]     {
[10:29:48.417]         {
[10:29:48.417]             ...future.startTime <- base::Sys.time()
[10:29:48.417]             {
[10:29:48.417]                 {
[10:29:48.417]                   {
[10:29:48.417]                     base::local({
[10:29:48.417]                       has_future <- base::requireNamespace("future", 
[10:29:48.417]                         quietly = TRUE)
[10:29:48.417]                       if (has_future) {
[10:29:48.417]                         ns <- base::getNamespace("future")
[10:29:48.417]                         version <- ns[[".package"]][["version"]]
[10:29:48.417]                         if (is.null(version)) 
[10:29:48.417]                           version <- utils::packageVersion("future")
[10:29:48.417]                       }
[10:29:48.417]                       else {
[10:29:48.417]                         version <- NULL
[10:29:48.417]                       }
[10:29:48.417]                       if (!has_future || version < "1.8.0") {
[10:29:48.417]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.417]                           "", base::R.version$version.string), 
[10:29:48.417]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:48.417]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.417]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.417]                             "release", "version")], collapse = " "), 
[10:29:48.417]                           hostname = base::Sys.info()[["nodename"]])
[10:29:48.417]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.417]                           info)
[10:29:48.417]                         info <- base::paste(info, collapse = "; ")
[10:29:48.417]                         if (!has_future) {
[10:29:48.417]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.417]                             info)
[10:29:48.417]                         }
[10:29:48.417]                         else {
[10:29:48.417]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.417]                             info, version)
[10:29:48.417]                         }
[10:29:48.417]                         base::stop(msg)
[10:29:48.417]                       }
[10:29:48.417]                     })
[10:29:48.417]                   }
[10:29:48.417]                   ...future.strategy.old <- future::plan("list")
[10:29:48.417]                   options(future.plan = NULL)
[10:29:48.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.417]                 }
[10:29:48.417]                 ...future.workdir <- getwd()
[10:29:48.417]             }
[10:29:48.417]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.417]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.417]         }
[10:29:48.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.417]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.417]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.417]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.417]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.417]             base::names(...future.oldOptions))
[10:29:48.417]     }
[10:29:48.417]     if (FALSE) {
[10:29:48.417]     }
[10:29:48.417]     else {
[10:29:48.417]         if (TRUE) {
[10:29:48.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.417]                 open = "w")
[10:29:48.417]         }
[10:29:48.417]         else {
[10:29:48.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.417]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.417]         }
[10:29:48.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.417]             base::sink(type = "output", split = FALSE)
[10:29:48.417]             base::close(...future.stdout)
[10:29:48.417]         }, add = TRUE)
[10:29:48.417]     }
[10:29:48.417]     ...future.frame <- base::sys.nframe()
[10:29:48.417]     ...future.conditions <- base::list()
[10:29:48.417]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.417]     if (FALSE) {
[10:29:48.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.417]     }
[10:29:48.417]     ...future.result <- base::tryCatch({
[10:29:48.417]         base::withCallingHandlers({
[10:29:48.417]             ...future.value <- base::withVisible(base::local({
[10:29:48.417]                 do.call(function(...) {
[10:29:48.417]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.417]                   if (!identical(...future.globals.maxSize.org, 
[10:29:48.417]                     ...future.globals.maxSize)) {
[10:29:48.417]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.417]                     on.exit(options(oopts), add = TRUE)
[10:29:48.417]                   }
[10:29:48.417]                   {
[10:29:48.417]                     lapply(seq_along(...future.elements_ii), 
[10:29:48.417]                       FUN = function(jj) {
[10:29:48.417]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.417]                         ...future.FUN(...future.X_jj, ...)
[10:29:48.417]                       })
[10:29:48.417]                   }
[10:29:48.417]                 }, args = future.call.arguments)
[10:29:48.417]             }))
[10:29:48.417]             future::FutureResult(value = ...future.value$value, 
[10:29:48.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.417]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.417]                     ...future.globalenv.names))
[10:29:48.417]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.417]         }, condition = base::local({
[10:29:48.417]             c <- base::c
[10:29:48.417]             inherits <- base::inherits
[10:29:48.417]             invokeRestart <- base::invokeRestart
[10:29:48.417]             length <- base::length
[10:29:48.417]             list <- base::list
[10:29:48.417]             seq.int <- base::seq.int
[10:29:48.417]             signalCondition <- base::signalCondition
[10:29:48.417]             sys.calls <- base::sys.calls
[10:29:48.417]             `[[` <- base::`[[`
[10:29:48.417]             `+` <- base::`+`
[10:29:48.417]             `<<-` <- base::`<<-`
[10:29:48.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.417]                   3L)]
[10:29:48.417]             }
[10:29:48.417]             function(cond) {
[10:29:48.417]                 is_error <- inherits(cond, "error")
[10:29:48.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.417]                   NULL)
[10:29:48.417]                 if (is_error) {
[10:29:48.417]                   sessionInformation <- function() {
[10:29:48.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.417]                       search = base::search(), system = base::Sys.info())
[10:29:48.417]                   }
[10:29:48.417]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.417]                     cond$call), session = sessionInformation(), 
[10:29:48.417]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.417]                   signalCondition(cond)
[10:29:48.417]                 }
[10:29:48.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.417]                 "immediateCondition"))) {
[10:29:48.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.417]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.417]                   if (TRUE && !signal) {
[10:29:48.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.417]                     {
[10:29:48.417]                       inherits <- base::inherits
[10:29:48.417]                       invokeRestart <- base::invokeRestart
[10:29:48.417]                       is.null <- base::is.null
[10:29:48.417]                       muffled <- FALSE
[10:29:48.417]                       if (inherits(cond, "message")) {
[10:29:48.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.417]                         if (muffled) 
[10:29:48.417]                           invokeRestart("muffleMessage")
[10:29:48.417]                       }
[10:29:48.417]                       else if (inherits(cond, "warning")) {
[10:29:48.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.417]                         if (muffled) 
[10:29:48.417]                           invokeRestart("muffleWarning")
[10:29:48.417]                       }
[10:29:48.417]                       else if (inherits(cond, "condition")) {
[10:29:48.417]                         if (!is.null(pattern)) {
[10:29:48.417]                           computeRestarts <- base::computeRestarts
[10:29:48.417]                           grepl <- base::grepl
[10:29:48.417]                           restarts <- computeRestarts(cond)
[10:29:48.417]                           for (restart in restarts) {
[10:29:48.417]                             name <- restart$name
[10:29:48.417]                             if (is.null(name)) 
[10:29:48.417]                               next
[10:29:48.417]                             if (!grepl(pattern, name)) 
[10:29:48.417]                               next
[10:29:48.417]                             invokeRestart(restart)
[10:29:48.417]                             muffled <- TRUE
[10:29:48.417]                             break
[10:29:48.417]                           }
[10:29:48.417]                         }
[10:29:48.417]                       }
[10:29:48.417]                       invisible(muffled)
[10:29:48.417]                     }
[10:29:48.417]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.417]                   }
[10:29:48.417]                 }
[10:29:48.417]                 else {
[10:29:48.417]                   if (TRUE) {
[10:29:48.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.417]                     {
[10:29:48.417]                       inherits <- base::inherits
[10:29:48.417]                       invokeRestart <- base::invokeRestart
[10:29:48.417]                       is.null <- base::is.null
[10:29:48.417]                       muffled <- FALSE
[10:29:48.417]                       if (inherits(cond, "message")) {
[10:29:48.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.417]                         if (muffled) 
[10:29:48.417]                           invokeRestart("muffleMessage")
[10:29:48.417]                       }
[10:29:48.417]                       else if (inherits(cond, "warning")) {
[10:29:48.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.417]                         if (muffled) 
[10:29:48.417]                           invokeRestart("muffleWarning")
[10:29:48.417]                       }
[10:29:48.417]                       else if (inherits(cond, "condition")) {
[10:29:48.417]                         if (!is.null(pattern)) {
[10:29:48.417]                           computeRestarts <- base::computeRestarts
[10:29:48.417]                           grepl <- base::grepl
[10:29:48.417]                           restarts <- computeRestarts(cond)
[10:29:48.417]                           for (restart in restarts) {
[10:29:48.417]                             name <- restart$name
[10:29:48.417]                             if (is.null(name)) 
[10:29:48.417]                               next
[10:29:48.417]                             if (!grepl(pattern, name)) 
[10:29:48.417]                               next
[10:29:48.417]                             invokeRestart(restart)
[10:29:48.417]                             muffled <- TRUE
[10:29:48.417]                             break
[10:29:48.417]                           }
[10:29:48.417]                         }
[10:29:48.417]                       }
[10:29:48.417]                       invisible(muffled)
[10:29:48.417]                     }
[10:29:48.417]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.417]                   }
[10:29:48.417]                 }
[10:29:48.417]             }
[10:29:48.417]         }))
[10:29:48.417]     }, error = function(ex) {
[10:29:48.417]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.417]                 ...future.rng), started = ...future.startTime, 
[10:29:48.417]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.417]             version = "1.8"), class = "FutureResult")
[10:29:48.417]     }, finally = {
[10:29:48.417]         if (!identical(...future.workdir, getwd())) 
[10:29:48.417]             setwd(...future.workdir)
[10:29:48.417]         {
[10:29:48.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.417]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.417]             }
[10:29:48.417]             base::options(...future.oldOptions)
[10:29:48.417]             if (.Platform$OS.type == "windows") {
[10:29:48.417]                 old_names <- names(...future.oldEnvVars)
[10:29:48.417]                 envs <- base::Sys.getenv()
[10:29:48.417]                 names <- names(envs)
[10:29:48.417]                 common <- intersect(names, old_names)
[10:29:48.417]                 added <- setdiff(names, old_names)
[10:29:48.417]                 removed <- setdiff(old_names, names)
[10:29:48.417]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.417]                   envs[common]]
[10:29:48.417]                 NAMES <- toupper(changed)
[10:29:48.417]                 args <- list()
[10:29:48.417]                 for (kk in seq_along(NAMES)) {
[10:29:48.417]                   name <- changed[[kk]]
[10:29:48.417]                   NAME <- NAMES[[kk]]
[10:29:48.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.417]                     next
[10:29:48.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.417]                 }
[10:29:48.417]                 NAMES <- toupper(added)
[10:29:48.417]                 for (kk in seq_along(NAMES)) {
[10:29:48.417]                   name <- added[[kk]]
[10:29:48.417]                   NAME <- NAMES[[kk]]
[10:29:48.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.417]                     next
[10:29:48.417]                   args[[name]] <- ""
[10:29:48.417]                 }
[10:29:48.417]                 NAMES <- toupper(removed)
[10:29:48.417]                 for (kk in seq_along(NAMES)) {
[10:29:48.417]                   name <- removed[[kk]]
[10:29:48.417]                   NAME <- NAMES[[kk]]
[10:29:48.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.417]                     next
[10:29:48.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.417]                 }
[10:29:48.417]                 if (length(args) > 0) 
[10:29:48.417]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.417]             }
[10:29:48.417]             else {
[10:29:48.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.417]             }
[10:29:48.417]             {
[10:29:48.417]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.417]                   0L) {
[10:29:48.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.417]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.417]                   base::options(opts)
[10:29:48.417]                 }
[10:29:48.417]                 {
[10:29:48.417]                   {
[10:29:48.417]                     NULL
[10:29:48.417]                     RNGkind("Mersenne-Twister")
[10:29:48.417]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:48.417]                       inherits = FALSE)
[10:29:48.417]                   }
[10:29:48.417]                   options(future.plan = NULL)
[10:29:48.417]                   if (is.na(NA_character_)) 
[10:29:48.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.417]                     .init = FALSE)
[10:29:48.417]                 }
[10:29:48.417]             }
[10:29:48.417]         }
[10:29:48.417]     })
[10:29:48.417]     if (TRUE) {
[10:29:48.417]         base::sink(type = "output", split = FALSE)
[10:29:48.417]         if (TRUE) {
[10:29:48.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.417]         }
[10:29:48.417]         else {
[10:29:48.417]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.417]         }
[10:29:48.417]         base::close(...future.stdout)
[10:29:48.417]         ...future.stdout <- NULL
[10:29:48.417]     }
[10:29:48.417]     ...future.result$conditions <- ...future.conditions
[10:29:48.417]     ...future.result$finished <- base::Sys.time()
[10:29:48.417]     ...future.result
[10:29:48.417] }
[10:29:48.419] assign_globals() ...
[10:29:48.419] List of 5
[10:29:48.419]  $ future.call.arguments    : list()
[10:29:48.419]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.419]  $ ...future.FUN            :function (x)  
[10:29:48.419]  $ ...future.elements_ii    :List of 2
[10:29:48.419]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:29:48.419]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:29:48.419]  $ ...future.seeds_ii       : NULL
[10:29:48.419]  $ ...future.globals.maxSize: num Inf
[10:29:48.419]  - attr(*, "resolved")= logi FALSE
[10:29:48.419]  - attr(*, "total_size")= num NA
[10:29:48.419]  - attr(*, "where")=List of 5
[10:29:48.419]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.419]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.419]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.419]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.419]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.419]  - attr(*, "already-done")= logi TRUE
[10:29:48.424] - copied ‘future.call.arguments’ to environment
[10:29:48.424] - copied ‘...future.FUN’ to environment
[10:29:48.424] - copied ‘...future.elements_ii’ to environment
[10:29:48.424] - copied ‘...future.seeds_ii’ to environment
[10:29:48.424] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.425] assign_globals() ... done
[10:29:48.425] plan(): Setting new future strategy stack:
[10:29:48.425] List of future strategies:
[10:29:48.425] 1. sequential:
[10:29:48.425]    - args: function (..., envir = parent.frame())
[10:29:48.425]    - tweaked: FALSE
[10:29:48.425]    - call: NULL
[10:29:48.425] plan(): nbrOfWorkers() = 1
[10:29:48.426] plan(): Setting new future strategy stack:
[10:29:48.426] List of future strategies:
[10:29:48.426] 1. sequential:
[10:29:48.426]    - args: function (..., envir = parent.frame())
[10:29:48.426]    - tweaked: FALSE
[10:29:48.426]    - call: plan(strategy)
[10:29:48.426] plan(): nbrOfWorkers() = 1
[10:29:48.427] SequentialFuture started (and completed)
[10:29:48.427] - Launch lazy future ... done
[10:29:48.427] run() for ‘SequentialFuture’ ... done
[10:29:48.427] Created future:
[10:29:48.427] SequentialFuture:
[10:29:48.427] Label: ‘future_apply-1’
[10:29:48.427] Expression:
[10:29:48.427] {
[10:29:48.427]     do.call(function(...) {
[10:29:48.427]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.427]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.427]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.427]             on.exit(options(oopts), add = TRUE)
[10:29:48.427]         }
[10:29:48.427]         {
[10:29:48.427]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.427]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.427]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.427]             })
[10:29:48.427]         }
[10:29:48.427]     }, args = future.call.arguments)
[10:29:48.427] }
[10:29:48.427] Lazy evaluation: FALSE
[10:29:48.427] Asynchronous evaluation: FALSE
[10:29:48.427] Local evaluation: TRUE
[10:29:48.427] Environment: R_GlobalEnv
[10:29:48.427] Capture standard output: TRUE
[10:29:48.427] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.427] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.427] Packages: <none>
[10:29:48.427] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.427] Resolved: TRUE
[10:29:48.427] Value: 224 bytes of class ‘list’
[10:29:48.427] Early signaling: FALSE
[10:29:48.427] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.427] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.428] Chunk #1 of 1 ... DONE
[10:29:48.428] Launching 1 futures (chunks) ... DONE
[10:29:48.428] Resolving 1 futures (chunks) ...
[10:29:48.428] resolve() on list ...
[10:29:48.428]  recursive: 0
[10:29:48.428]  length: 1
[10:29:48.428] 
[10:29:48.429] resolved() for ‘SequentialFuture’ ...
[10:29:48.429] - state: ‘finished’
[10:29:48.429] - run: TRUE
[10:29:48.429] - result: ‘FutureResult’
[10:29:48.429] resolved() for ‘SequentialFuture’ ... done
[10:29:48.429] Future #1
[10:29:48.429] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:48.429] - nx: 1
[10:29:48.429] - relay: TRUE
[10:29:48.429] - stdout: TRUE
[10:29:48.430] - signal: TRUE
[10:29:48.430] - resignal: FALSE
[10:29:48.430] - force: TRUE
[10:29:48.430] - relayed: [n=1] FALSE
[10:29:48.430] - queued futures: [n=1] FALSE
[10:29:48.430]  - until=1
[10:29:48.430]  - relaying element #1
[10:29:48.430] - relayed: [n=1] TRUE
[10:29:48.430] - queued futures: [n=1] TRUE
[10:29:48.430] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:48.431]  length: 0 (resolved future 1)
[10:29:48.431] Relaying remaining futures
[10:29:48.431] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.431] - nx: 1
[10:29:48.431] - relay: TRUE
[10:29:48.431] - stdout: TRUE
[10:29:48.431] - signal: TRUE
[10:29:48.431] - resignal: FALSE
[10:29:48.431] - force: TRUE
[10:29:48.431] - relayed: [n=1] TRUE
[10:29:48.431] - queued futures: [n=1] TRUE
 - flush all
[10:29:48.431] - relayed: [n=1] TRUE
[10:29:48.432] - queued futures: [n=1] TRUE
[10:29:48.432] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.432] resolve() on list ... DONE
[10:29:48.432]  - Number of value chunks collected: 1
[10:29:48.432] Resolving 1 futures (chunks) ... DONE
[10:29:48.432] Reducing values from 1 chunks ...
[10:29:48.432]  - Number of values collected after concatenation: 2
[10:29:48.432]  - Number of values expected: 2
[10:29:48.432] Reducing values from 1 chunks ... DONE
[10:29:48.432] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:29:48.433] getGlobalsAndPackagesXApply() ...
[10:29:48.433]  - future.globals: TRUE
[10:29:48.433] getGlobalsAndPackages() ...
[10:29:48.433] Searching for globals...
[10:29:48.434] - globals found: [1] ‘FUN’
[10:29:48.434] Searching for globals ... DONE
[10:29:48.434] Resolving globals: FALSE
[10:29:48.434] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:48.435] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:48.435] - globals: [1] ‘FUN’
[10:29:48.435] 
[10:29:48.435] getGlobalsAndPackages() ... DONE
[10:29:48.435]  - globals found/used: [n=1] ‘FUN’
[10:29:48.435]  - needed namespaces: [n=0] 
[10:29:48.435] Finding globals ... DONE
[10:29:48.435]  - use_args: TRUE
[10:29:48.436]  - Getting '...' globals ...
[10:29:48.436] resolve() on list ...
[10:29:48.436]  recursive: 0
[10:29:48.436]  length: 1
[10:29:48.436]  elements: ‘...’
[10:29:48.436]  length: 0 (resolved future 1)
[10:29:48.436] resolve() on list ... DONE
[10:29:48.436]    - '...' content: [n=0] 
[10:29:48.437] List of 1
[10:29:48.437]  $ ...: list()
[10:29:48.437]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.437]  - attr(*, "where")=List of 1
[10:29:48.437]   ..$ ...:<environment: 0x5618a20ba7d8> 
[10:29:48.437]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.437]  - attr(*, "resolved")= logi TRUE
[10:29:48.437]  - attr(*, "total_size")= num NA
[10:29:48.440]  - Getting '...' globals ... DONE
[10:29:48.440] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.441] List of 2
[10:29:48.441]  $ ...future.FUN:function (x)  
[10:29:48.441]  $ ...          : list()
[10:29:48.441]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.441]  - attr(*, "where")=List of 2
[10:29:48.441]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.441]   ..$ ...          :<environment: 0x5618a20ba7d8> 
[10:29:48.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.441]  - attr(*, "resolved")= logi FALSE
[10:29:48.441]  - attr(*, "total_size")= num 848
[10:29:48.443] Packages to be attached in all futures: [n=0] 
[10:29:48.443] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.444] future_lapply() ...
[10:29:48.444] Number of chunks: 1
[10:29:48.444] getGlobalsAndPackagesXApply() ...
[10:29:48.444]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.445]  - use_args: TRUE
[10:29:48.445] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.445] List of 2
[10:29:48.445]  $ ...          : list()
[10:29:48.445]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.445]  $ ...future.FUN:function (x)  
[10:29:48.445]  - attr(*, "where")=List of 2
[10:29:48.445]   ..$ ...          :<environment: 0x5618a20ba7d8> 
[10:29:48.445]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:48.445]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.445]  - attr(*, "resolved")= logi FALSE
[10:29:48.445]  - attr(*, "total_size")= num NA
[10:29:48.448] Packages to be attached in all futures: [n=0] 
[10:29:48.448] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.448] Number of futures (= number of chunks): 1
[10:29:48.448] Launching 1 futures (chunks) ...
[10:29:48.448] Chunk #1 of 1 ...
[10:29:48.449]  - seeds: <none>
[10:29:48.449]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.449] getGlobalsAndPackages() ...
[10:29:48.449] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.449] Resolving globals: FALSE
[10:29:48.449] Tweak future expression to call with '...' arguments ...
[10:29:48.449] {
[10:29:48.449]     do.call(function(...) {
[10:29:48.449]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.449]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.449]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.449]             on.exit(options(oopts), add = TRUE)
[10:29:48.449]         }
[10:29:48.449]         {
[10:29:48.449]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.449]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.449]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.449]             })
[10:29:48.449]         }
[10:29:48.449]     }, args = future.call.arguments)
[10:29:48.449] }
[10:29:48.450] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.450] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.450] 
[10:29:48.450] getGlobalsAndPackages() ... DONE
[10:29:48.450] run() for ‘Future’ ...
[10:29:48.451] - state: ‘created’
[10:29:48.451] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:48.451] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.451] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:48.451]   - Field: ‘label’
[10:29:48.451]   - Field: ‘local’
[10:29:48.451]   - Field: ‘owner’
[10:29:48.451]   - Field: ‘envir’
[10:29:48.452]   - Field: ‘packages’
[10:29:48.452]   - Field: ‘gc’
[10:29:48.452]   - Field: ‘conditions’
[10:29:48.452]   - Field: ‘expr’
[10:29:48.452]   - Field: ‘uuid’
[10:29:48.452]   - Field: ‘seed’
[10:29:48.452]   - Field: ‘version’
[10:29:48.452]   - Field: ‘result’
[10:29:48.452]   - Field: ‘asynchronous’
[10:29:48.452]   - Field: ‘calls’
[10:29:48.452]   - Field: ‘globals’
[10:29:48.453]   - Field: ‘stdout’
[10:29:48.453]   - Field: ‘earlySignal’
[10:29:48.453]   - Field: ‘lazy’
[10:29:48.453]   - Field: ‘state’
[10:29:48.453] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:48.453] - Launch lazy future ...
[10:29:48.453] Packages needed by the future expression (n = 0): <none>
[10:29:48.453] Packages needed by future strategies (n = 0): <none>
[10:29:48.454] {
[10:29:48.454]     {
[10:29:48.454]         {
[10:29:48.454]             ...future.startTime <- base::Sys.time()
[10:29:48.454]             {
[10:29:48.454]                 {
[10:29:48.454]                   {
[10:29:48.454]                     base::local({
[10:29:48.454]                       has_future <- base::requireNamespace("future", 
[10:29:48.454]                         quietly = TRUE)
[10:29:48.454]                       if (has_future) {
[10:29:48.454]                         ns <- base::getNamespace("future")
[10:29:48.454]                         version <- ns[[".package"]][["version"]]
[10:29:48.454]                         if (is.null(version)) 
[10:29:48.454]                           version <- utils::packageVersion("future")
[10:29:48.454]                       }
[10:29:48.454]                       else {
[10:29:48.454]                         version <- NULL
[10:29:48.454]                       }
[10:29:48.454]                       if (!has_future || version < "1.8.0") {
[10:29:48.454]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.454]                           "", base::R.version$version.string), 
[10:29:48.454]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:48.454]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.454]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.454]                             "release", "version")], collapse = " "), 
[10:29:48.454]                           hostname = base::Sys.info()[["nodename"]])
[10:29:48.454]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.454]                           info)
[10:29:48.454]                         info <- base::paste(info, collapse = "; ")
[10:29:48.454]                         if (!has_future) {
[10:29:48.454]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.454]                             info)
[10:29:48.454]                         }
[10:29:48.454]                         else {
[10:29:48.454]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.454]                             info, version)
[10:29:48.454]                         }
[10:29:48.454]                         base::stop(msg)
[10:29:48.454]                       }
[10:29:48.454]                     })
[10:29:48.454]                   }
[10:29:48.454]                   ...future.strategy.old <- future::plan("list")
[10:29:48.454]                   options(future.plan = NULL)
[10:29:48.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.454]                 }
[10:29:48.454]                 ...future.workdir <- getwd()
[10:29:48.454]             }
[10:29:48.454]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.454]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.454]         }
[10:29:48.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.454]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.454]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.454]             base::names(...future.oldOptions))
[10:29:48.454]     }
[10:29:48.454]     if (FALSE) {
[10:29:48.454]     }
[10:29:48.454]     else {
[10:29:48.454]         if (TRUE) {
[10:29:48.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.454]                 open = "w")
[10:29:48.454]         }
[10:29:48.454]         else {
[10:29:48.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.454]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.454]         }
[10:29:48.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.454]             base::sink(type = "output", split = FALSE)
[10:29:48.454]             base::close(...future.stdout)
[10:29:48.454]         }, add = TRUE)
[10:29:48.454]     }
[10:29:48.454]     ...future.frame <- base::sys.nframe()
[10:29:48.454]     ...future.conditions <- base::list()
[10:29:48.454]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.454]     if (FALSE) {
[10:29:48.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.454]     }
[10:29:48.454]     ...future.result <- base::tryCatch({
[10:29:48.454]         base::withCallingHandlers({
[10:29:48.454]             ...future.value <- base::withVisible(base::local({
[10:29:48.454]                 do.call(function(...) {
[10:29:48.454]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.454]                   if (!identical(...future.globals.maxSize.org, 
[10:29:48.454]                     ...future.globals.maxSize)) {
[10:29:48.454]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.454]                     on.exit(options(oopts), add = TRUE)
[10:29:48.454]                   }
[10:29:48.454]                   {
[10:29:48.454]                     lapply(seq_along(...future.elements_ii), 
[10:29:48.454]                       FUN = function(jj) {
[10:29:48.454]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.454]                         ...future.FUN(...future.X_jj, ...)
[10:29:48.454]                       })
[10:29:48.454]                   }
[10:29:48.454]                 }, args = future.call.arguments)
[10:29:48.454]             }))
[10:29:48.454]             future::FutureResult(value = ...future.value$value, 
[10:29:48.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.454]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.454]                     ...future.globalenv.names))
[10:29:48.454]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.454]         }, condition = base::local({
[10:29:48.454]             c <- base::c
[10:29:48.454]             inherits <- base::inherits
[10:29:48.454]             invokeRestart <- base::invokeRestart
[10:29:48.454]             length <- base::length
[10:29:48.454]             list <- base::list
[10:29:48.454]             seq.int <- base::seq.int
[10:29:48.454]             signalCondition <- base::signalCondition
[10:29:48.454]             sys.calls <- base::sys.calls
[10:29:48.454]             `[[` <- base::`[[`
[10:29:48.454]             `+` <- base::`+`
[10:29:48.454]             `<<-` <- base::`<<-`
[10:29:48.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.454]                   3L)]
[10:29:48.454]             }
[10:29:48.454]             function(cond) {
[10:29:48.454]                 is_error <- inherits(cond, "error")
[10:29:48.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.454]                   NULL)
[10:29:48.454]                 if (is_error) {
[10:29:48.454]                   sessionInformation <- function() {
[10:29:48.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.454]                       search = base::search(), system = base::Sys.info())
[10:29:48.454]                   }
[10:29:48.454]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.454]                     cond$call), session = sessionInformation(), 
[10:29:48.454]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.454]                   signalCondition(cond)
[10:29:48.454]                 }
[10:29:48.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.454]                 "immediateCondition"))) {
[10:29:48.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.454]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.454]                   if (TRUE && !signal) {
[10:29:48.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.454]                     {
[10:29:48.454]                       inherits <- base::inherits
[10:29:48.454]                       invokeRestart <- base::invokeRestart
[10:29:48.454]                       is.null <- base::is.null
[10:29:48.454]                       muffled <- FALSE
[10:29:48.454]                       if (inherits(cond, "message")) {
[10:29:48.454]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.454]                         if (muffled) 
[10:29:48.454]                           invokeRestart("muffleMessage")
[10:29:48.454]                       }
[10:29:48.454]                       else if (inherits(cond, "warning")) {
[10:29:48.454]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.454]                         if (muffled) 
[10:29:48.454]                           invokeRestart("muffleWarning")
[10:29:48.454]                       }
[10:29:48.454]                       else if (inherits(cond, "condition")) {
[10:29:48.454]                         if (!is.null(pattern)) {
[10:29:48.454]                           computeRestarts <- base::computeRestarts
[10:29:48.454]                           grepl <- base::grepl
[10:29:48.454]                           restarts <- computeRestarts(cond)
[10:29:48.454]                           for (restart in restarts) {
[10:29:48.454]                             name <- restart$name
[10:29:48.454]                             if (is.null(name)) 
[10:29:48.454]                               next
[10:29:48.454]                             if (!grepl(pattern, name)) 
[10:29:48.454]                               next
[10:29:48.454]                             invokeRestart(restart)
[10:29:48.454]                             muffled <- TRUE
[10:29:48.454]                             break
[10:29:48.454]                           }
[10:29:48.454]                         }
[10:29:48.454]                       }
[10:29:48.454]                       invisible(muffled)
[10:29:48.454]                     }
[10:29:48.454]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.454]                   }
[10:29:48.454]                 }
[10:29:48.454]                 else {
[10:29:48.454]                   if (TRUE) {
[10:29:48.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.454]                     {
[10:29:48.454]                       inherits <- base::inherits
[10:29:48.454]                       invokeRestart <- base::invokeRestart
[10:29:48.454]                       is.null <- base::is.null
[10:29:48.454]                       muffled <- FALSE
[10:29:48.454]                       if (inherits(cond, "message")) {
[10:29:48.454]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.454]                         if (muffled) 
[10:29:48.454]                           invokeRestart("muffleMessage")
[10:29:48.454]                       }
[10:29:48.454]                       else if (inherits(cond, "warning")) {
[10:29:48.454]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.454]                         if (muffled) 
[10:29:48.454]                           invokeRestart("muffleWarning")
[10:29:48.454]                       }
[10:29:48.454]                       else if (inherits(cond, "condition")) {
[10:29:48.454]                         if (!is.null(pattern)) {
[10:29:48.454]                           computeRestarts <- base::computeRestarts
[10:29:48.454]                           grepl <- base::grepl
[10:29:48.454]                           restarts <- computeRestarts(cond)
[10:29:48.454]                           for (restart in restarts) {
[10:29:48.454]                             name <- restart$name
[10:29:48.454]                             if (is.null(name)) 
[10:29:48.454]                               next
[10:29:48.454]                             if (!grepl(pattern, name)) 
[10:29:48.454]                               next
[10:29:48.454]                             invokeRestart(restart)
[10:29:48.454]                             muffled <- TRUE
[10:29:48.454]                             break
[10:29:48.454]                           }
[10:29:48.454]                         }
[10:29:48.454]                       }
[10:29:48.454]                       invisible(muffled)
[10:29:48.454]                     }
[10:29:48.454]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.454]                   }
[10:29:48.454]                 }
[10:29:48.454]             }
[10:29:48.454]         }))
[10:29:48.454]     }, error = function(ex) {
[10:29:48.454]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.454]                 ...future.rng), started = ...future.startTime, 
[10:29:48.454]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.454]             version = "1.8"), class = "FutureResult")
[10:29:48.454]     }, finally = {
[10:29:48.454]         if (!identical(...future.workdir, getwd())) 
[10:29:48.454]             setwd(...future.workdir)
[10:29:48.454]         {
[10:29:48.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.454]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.454]             }
[10:29:48.454]             base::options(...future.oldOptions)
[10:29:48.454]             if (.Platform$OS.type == "windows") {
[10:29:48.454]                 old_names <- names(...future.oldEnvVars)
[10:29:48.454]                 envs <- base::Sys.getenv()
[10:29:48.454]                 names <- names(envs)
[10:29:48.454]                 common <- intersect(names, old_names)
[10:29:48.454]                 added <- setdiff(names, old_names)
[10:29:48.454]                 removed <- setdiff(old_names, names)
[10:29:48.454]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.454]                   envs[common]]
[10:29:48.454]                 NAMES <- toupper(changed)
[10:29:48.454]                 args <- list()
[10:29:48.454]                 for (kk in seq_along(NAMES)) {
[10:29:48.454]                   name <- changed[[kk]]
[10:29:48.454]                   NAME <- NAMES[[kk]]
[10:29:48.454]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.454]                     next
[10:29:48.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.454]                 }
[10:29:48.454]                 NAMES <- toupper(added)
[10:29:48.454]                 for (kk in seq_along(NAMES)) {
[10:29:48.454]                   name <- added[[kk]]
[10:29:48.454]                   NAME <- NAMES[[kk]]
[10:29:48.454]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.454]                     next
[10:29:48.454]                   args[[name]] <- ""
[10:29:48.454]                 }
[10:29:48.454]                 NAMES <- toupper(removed)
[10:29:48.454]                 for (kk in seq_along(NAMES)) {
[10:29:48.454]                   name <- removed[[kk]]
[10:29:48.454]                   NAME <- NAMES[[kk]]
[10:29:48.454]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.454]                     next
[10:29:48.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.454]                 }
[10:29:48.454]                 if (length(args) > 0) 
[10:29:48.454]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.454]             }
[10:29:48.454]             else {
[10:29:48.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.454]             }
[10:29:48.454]             {
[10:29:48.454]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.454]                   0L) {
[10:29:48.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.454]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.454]                   base::options(opts)
[10:29:48.454]                 }
[10:29:48.454]                 {
[10:29:48.454]                   {
[10:29:48.454]                     NULL
[10:29:48.454]                     RNGkind("Mersenne-Twister")
[10:29:48.454]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:48.454]                       inherits = FALSE)
[10:29:48.454]                   }
[10:29:48.454]                   options(future.plan = NULL)
[10:29:48.454]                   if (is.na(NA_character_)) 
[10:29:48.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.454]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.454]                     .init = FALSE)
[10:29:48.454]                 }
[10:29:48.454]             }
[10:29:48.454]         }
[10:29:48.454]     })
[10:29:48.454]     if (TRUE) {
[10:29:48.454]         base::sink(type = "output", split = FALSE)
[10:29:48.454]         if (TRUE) {
[10:29:48.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.454]         }
[10:29:48.454]         else {
[10:29:48.454]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.454]         }
[10:29:48.454]         base::close(...future.stdout)
[10:29:48.454]         ...future.stdout <- NULL
[10:29:48.454]     }
[10:29:48.454]     ...future.result$conditions <- ...future.conditions
[10:29:48.454]     ...future.result$finished <- base::Sys.time()
[10:29:48.454]     ...future.result
[10:29:48.454] }
[10:29:48.456] assign_globals() ...
[10:29:48.456] List of 5
[10:29:48.456]  $ future.call.arguments    : list()
[10:29:48.456]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.456]  $ ...future.FUN            :function (x)  
[10:29:48.456]  $ ...future.elements_ii    :List of 6
[10:29:48.456]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:29:48.456]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:29:48.456]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:29:48.456]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:29:48.456]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:29:48.456]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:29:48.456]  $ ...future.seeds_ii       : NULL
[10:29:48.456]  $ ...future.globals.maxSize: num Inf
[10:29:48.456]  - attr(*, "resolved")= logi FALSE
[10:29:48.456]  - attr(*, "total_size")= num NA
[10:29:48.456]  - attr(*, "where")=List of 5
[10:29:48.456]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.456]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.456]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.456]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.456]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.456]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.456]  - attr(*, "already-done")= logi TRUE
[10:29:48.463] - copied ‘future.call.arguments’ to environment
[10:29:48.463] - copied ‘...future.FUN’ to environment
[10:29:48.463] - copied ‘...future.elements_ii’ to environment
[10:29:48.463] - copied ‘...future.seeds_ii’ to environment
[10:29:48.463] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.464] assign_globals() ... done
[10:29:48.464] plan(): Setting new future strategy stack:
[10:29:48.464] List of future strategies:
[10:29:48.464] 1. sequential:
[10:29:48.464]    - args: function (..., envir = parent.frame())
[10:29:48.464]    - tweaked: FALSE
[10:29:48.464]    - call: NULL
[10:29:48.464] plan(): nbrOfWorkers() = 1
[10:29:48.465] plan(): Setting new future strategy stack:
[10:29:48.465] List of future strategies:
[10:29:48.465] 1. sequential:
[10:29:48.465]    - args: function (..., envir = parent.frame())
[10:29:48.465]    - tweaked: FALSE
[10:29:48.465]    - call: plan(strategy)
[10:29:48.465] plan(): nbrOfWorkers() = 1
[10:29:48.466] SequentialFuture started (and completed)
[10:29:48.466] - Launch lazy future ... done
[10:29:48.466] run() for ‘SequentialFuture’ ... done
[10:29:48.466] Created future:
[10:29:48.466] SequentialFuture:
[10:29:48.466] Label: ‘future_apply-1’
[10:29:48.466] Expression:
[10:29:48.466] {
[10:29:48.466]     do.call(function(...) {
[10:29:48.466]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.466]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.466]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.466]             on.exit(options(oopts), add = TRUE)
[10:29:48.466]         }
[10:29:48.466]         {
[10:29:48.466]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.466]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.466]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.466]             })
[10:29:48.466]         }
[10:29:48.466]     }, args = future.call.arguments)
[10:29:48.466] }
[10:29:48.466] Lazy evaluation: FALSE
[10:29:48.466] Asynchronous evaluation: FALSE
[10:29:48.466] Local evaluation: TRUE
[10:29:48.466] Environment: R_GlobalEnv
[10:29:48.466] Capture standard output: TRUE
[10:29:48.466] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.466] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.466] Packages: <none>
[10:29:48.466] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.466] Resolved: TRUE
[10:29:48.466] Value: 672 bytes of class ‘list’
[10:29:48.466] Early signaling: FALSE
[10:29:48.466] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.466] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.467] Chunk #1 of 1 ... DONE
[10:29:48.467] Launching 1 futures (chunks) ... DONE
[10:29:48.467] Resolving 1 futures (chunks) ...
[10:29:48.467] resolve() on list ...
[10:29:48.467]  recursive: 0
[10:29:48.467]  length: 1
[10:29:48.468] 
[10:29:48.468] resolved() for ‘SequentialFuture’ ...
[10:29:48.468] - state: ‘finished’
[10:29:48.468] - run: TRUE
[10:29:48.468] - result: ‘FutureResult’
[10:29:48.468] resolved() for ‘SequentialFuture’ ... done
[10:29:48.468] Future #1
[10:29:48.468] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:48.468] - nx: 1
[10:29:48.468] - relay: TRUE
[10:29:48.469] - stdout: TRUE
[10:29:48.469] - signal: TRUE
[10:29:48.469] - resignal: FALSE
[10:29:48.469] - force: TRUE
[10:29:48.469] - relayed: [n=1] FALSE
[10:29:48.469] - queued futures: [n=1] FALSE
[10:29:48.469]  - until=1
[10:29:48.469]  - relaying element #1
[10:29:48.469] - relayed: [n=1] TRUE
[10:29:48.469] - queued futures: [n=1] TRUE
[10:29:48.470] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:48.470]  length: 0 (resolved future 1)
[10:29:48.470] Relaying remaining futures
[10:29:48.470] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.470] - nx: 1
[10:29:48.470] - relay: TRUE
[10:29:48.470] - stdout: TRUE
[10:29:48.470] - signal: TRUE
[10:29:48.470] - resignal: FALSE
[10:29:48.470] - force: TRUE
[10:29:48.470] - relayed: [n=1] TRUE
[10:29:48.470] - queued futures: [n=1] TRUE
 - flush all
[10:29:48.471] - relayed: [n=1] TRUE
[10:29:48.471] - queued futures: [n=1] TRUE
[10:29:48.471] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.471] resolve() on list ... DONE
[10:29:48.471]  - Number of value chunks collected: 1
[10:29:48.471] Resolving 1 futures (chunks) ... DONE
[10:29:48.471] Reducing values from 1 chunks ...
[10:29:48.471]  - Number of values collected after concatenation: 6
[10:29:48.471]  - Number of values expected: 6
[10:29:48.471] Reducing values from 1 chunks ... DONE
[10:29:48.472] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:29:48.472] getGlobalsAndPackagesXApply() ...
[10:29:48.472]  - future.globals: TRUE
[10:29:48.472] getGlobalsAndPackages() ...
[10:29:48.472] Searching for globals...
[10:29:48.473] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:29:48.474] Searching for globals ... DONE
[10:29:48.474] Resolving globals: FALSE
[10:29:48.474] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[10:29:48.474] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[10:29:48.475] - globals: [1] ‘FUN’
[10:29:48.475] 
[10:29:48.475] getGlobalsAndPackages() ... DONE
[10:29:48.475]  - globals found/used: [n=1] ‘FUN’
[10:29:48.475]  - needed namespaces: [n=0] 
[10:29:48.475] Finding globals ... DONE
[10:29:48.475]  - use_args: TRUE
[10:29:48.475]  - Getting '...' globals ...
[10:29:48.475] resolve() on list ...
[10:29:48.476]  recursive: 0
[10:29:48.476]  length: 1
[10:29:48.476]  elements: ‘...’
[10:29:48.476]  length: 0 (resolved future 1)
[10:29:48.476] resolve() on list ... DONE
[10:29:48.476]    - '...' content: [n=0] 
[10:29:48.476] List of 1
[10:29:48.476]  $ ...: list()
[10:29:48.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.476]  - attr(*, "where")=List of 1
[10:29:48.476]   ..$ ...:<environment: 0x5618a1bf9e90> 
[10:29:48.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.476]  - attr(*, "resolved")= logi TRUE
[10:29:48.476]  - attr(*, "total_size")= num NA
[10:29:48.478]  - Getting '...' globals ... DONE
[10:29:48.479] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.479] List of 2
[10:29:48.479]  $ ...future.FUN:function (x)  
[10:29:48.479]  $ ...          : list()
[10:29:48.479]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.479]  - attr(*, "where")=List of 2
[10:29:48.479]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.479]   ..$ ...          :<environment: 0x5618a1bf9e90> 
[10:29:48.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.479]  - attr(*, "resolved")= logi FALSE
[10:29:48.479]  - attr(*, "total_size")= num 1768
[10:29:48.482] Packages to be attached in all futures: [n=0] 
[10:29:48.482] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.483] future_lapply() ...
[10:29:48.483] Number of chunks: 1
[10:29:48.483] getGlobalsAndPackagesXApply() ...
[10:29:48.483]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.483]  - use_args: TRUE
[10:29:48.484] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.484] List of 2
[10:29:48.484]  $ ...          : list()
[10:29:48.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.484]  $ ...future.FUN:function (x)  
[10:29:48.484]  - attr(*, "where")=List of 2
[10:29:48.484]   ..$ ...          :<environment: 0x5618a1bf9e90> 
[10:29:48.484]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:29:48.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.484]  - attr(*, "resolved")= logi FALSE
[10:29:48.484]  - attr(*, "total_size")= num NA
[10:29:48.486] Packages to be attached in all futures: [n=0] 
[10:29:48.486] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.487] Number of futures (= number of chunks): 1
[10:29:48.487] Launching 1 futures (chunks) ...
[10:29:48.487] Chunk #1 of 1 ...
[10:29:48.487]  - seeds: <none>
[10:29:48.487]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.487] getGlobalsAndPackages() ...
[10:29:48.487] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.487] Resolving globals: FALSE
[10:29:48.487] Tweak future expression to call with '...' arguments ...
[10:29:48.488] {
[10:29:48.488]     do.call(function(...) {
[10:29:48.488]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.488]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.488]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.488]             on.exit(options(oopts), add = TRUE)
[10:29:48.488]         }
[10:29:48.488]         {
[10:29:48.488]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.488]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.488]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.488]             })
[10:29:48.488]         }
[10:29:48.488]     }, args = future.call.arguments)
[10:29:48.488] }
[10:29:48.488] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.488] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.488] 
[10:29:48.488] getGlobalsAndPackages() ... DONE
[10:29:48.489] run() for ‘Future’ ...
[10:29:48.489] - state: ‘created’
[10:29:48.489] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:48.489] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.489] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:48.490]   - Field: ‘label’
[10:29:48.490]   - Field: ‘local’
[10:29:48.490]   - Field: ‘owner’
[10:29:48.490]   - Field: ‘envir’
[10:29:48.490]   - Field: ‘packages’
[10:29:48.490]   - Field: ‘gc’
[10:29:48.490]   - Field: ‘conditions’
[10:29:48.490]   - Field: ‘expr’
[10:29:48.490]   - Field: ‘uuid’
[10:29:48.490]   - Field: ‘seed’
[10:29:48.490]   - Field: ‘version’
[10:29:48.491]   - Field: ‘result’
[10:29:48.491]   - Field: ‘asynchronous’
[10:29:48.491]   - Field: ‘calls’
[10:29:48.491]   - Field: ‘globals’
[10:29:48.491]   - Field: ‘stdout’
[10:29:48.491]   - Field: ‘earlySignal’
[10:29:48.491]   - Field: ‘lazy’
[10:29:48.491]   - Field: ‘state’
[10:29:48.491] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:48.491] - Launch lazy future ...
[10:29:48.492] Packages needed by the future expression (n = 0): <none>
[10:29:48.492] Packages needed by future strategies (n = 0): <none>
[10:29:48.492] {
[10:29:48.492]     {
[10:29:48.492]         {
[10:29:48.492]             ...future.startTime <- base::Sys.time()
[10:29:48.492]             {
[10:29:48.492]                 {
[10:29:48.492]                   {
[10:29:48.492]                     base::local({
[10:29:48.492]                       has_future <- base::requireNamespace("future", 
[10:29:48.492]                         quietly = TRUE)
[10:29:48.492]                       if (has_future) {
[10:29:48.492]                         ns <- base::getNamespace("future")
[10:29:48.492]                         version <- ns[[".package"]][["version"]]
[10:29:48.492]                         if (is.null(version)) 
[10:29:48.492]                           version <- utils::packageVersion("future")
[10:29:48.492]                       }
[10:29:48.492]                       else {
[10:29:48.492]                         version <- NULL
[10:29:48.492]                       }
[10:29:48.492]                       if (!has_future || version < "1.8.0") {
[10:29:48.492]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.492]                           "", base::R.version$version.string), 
[10:29:48.492]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:48.492]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.492]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.492]                             "release", "version")], collapse = " "), 
[10:29:48.492]                           hostname = base::Sys.info()[["nodename"]])
[10:29:48.492]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.492]                           info)
[10:29:48.492]                         info <- base::paste(info, collapse = "; ")
[10:29:48.492]                         if (!has_future) {
[10:29:48.492]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.492]                             info)
[10:29:48.492]                         }
[10:29:48.492]                         else {
[10:29:48.492]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.492]                             info, version)
[10:29:48.492]                         }
[10:29:48.492]                         base::stop(msg)
[10:29:48.492]                       }
[10:29:48.492]                     })
[10:29:48.492]                   }
[10:29:48.492]                   ...future.strategy.old <- future::plan("list")
[10:29:48.492]                   options(future.plan = NULL)
[10:29:48.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.492]                 }
[10:29:48.492]                 ...future.workdir <- getwd()
[10:29:48.492]             }
[10:29:48.492]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.492]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.492]         }
[10:29:48.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.492]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.492]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.492]             base::names(...future.oldOptions))
[10:29:48.492]     }
[10:29:48.492]     if (FALSE) {
[10:29:48.492]     }
[10:29:48.492]     else {
[10:29:48.492]         if (TRUE) {
[10:29:48.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.492]                 open = "w")
[10:29:48.492]         }
[10:29:48.492]         else {
[10:29:48.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.492]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.492]         }
[10:29:48.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.492]             base::sink(type = "output", split = FALSE)
[10:29:48.492]             base::close(...future.stdout)
[10:29:48.492]         }, add = TRUE)
[10:29:48.492]     }
[10:29:48.492]     ...future.frame <- base::sys.nframe()
[10:29:48.492]     ...future.conditions <- base::list()
[10:29:48.492]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.492]     if (FALSE) {
[10:29:48.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.492]     }
[10:29:48.492]     ...future.result <- base::tryCatch({
[10:29:48.492]         base::withCallingHandlers({
[10:29:48.492]             ...future.value <- base::withVisible(base::local({
[10:29:48.492]                 do.call(function(...) {
[10:29:48.492]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.492]                   if (!identical(...future.globals.maxSize.org, 
[10:29:48.492]                     ...future.globals.maxSize)) {
[10:29:48.492]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.492]                     on.exit(options(oopts), add = TRUE)
[10:29:48.492]                   }
[10:29:48.492]                   {
[10:29:48.492]                     lapply(seq_along(...future.elements_ii), 
[10:29:48.492]                       FUN = function(jj) {
[10:29:48.492]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.492]                         ...future.FUN(...future.X_jj, ...)
[10:29:48.492]                       })
[10:29:48.492]                   }
[10:29:48.492]                 }, args = future.call.arguments)
[10:29:48.492]             }))
[10:29:48.492]             future::FutureResult(value = ...future.value$value, 
[10:29:48.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.492]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.492]                     ...future.globalenv.names))
[10:29:48.492]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.492]         }, condition = base::local({
[10:29:48.492]             c <- base::c
[10:29:48.492]             inherits <- base::inherits
[10:29:48.492]             invokeRestart <- base::invokeRestart
[10:29:48.492]             length <- base::length
[10:29:48.492]             list <- base::list
[10:29:48.492]             seq.int <- base::seq.int
[10:29:48.492]             signalCondition <- base::signalCondition
[10:29:48.492]             sys.calls <- base::sys.calls
[10:29:48.492]             `[[` <- base::`[[`
[10:29:48.492]             `+` <- base::`+`
[10:29:48.492]             `<<-` <- base::`<<-`
[10:29:48.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.492]                   3L)]
[10:29:48.492]             }
[10:29:48.492]             function(cond) {
[10:29:48.492]                 is_error <- inherits(cond, "error")
[10:29:48.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.492]                   NULL)
[10:29:48.492]                 if (is_error) {
[10:29:48.492]                   sessionInformation <- function() {
[10:29:48.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.492]                       search = base::search(), system = base::Sys.info())
[10:29:48.492]                   }
[10:29:48.492]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.492]                     cond$call), session = sessionInformation(), 
[10:29:48.492]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.492]                   signalCondition(cond)
[10:29:48.492]                 }
[10:29:48.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.492]                 "immediateCondition"))) {
[10:29:48.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.492]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.492]                   if (TRUE && !signal) {
[10:29:48.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.492]                     {
[10:29:48.492]                       inherits <- base::inherits
[10:29:48.492]                       invokeRestart <- base::invokeRestart
[10:29:48.492]                       is.null <- base::is.null
[10:29:48.492]                       muffled <- FALSE
[10:29:48.492]                       if (inherits(cond, "message")) {
[10:29:48.492]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.492]                         if (muffled) 
[10:29:48.492]                           invokeRestart("muffleMessage")
[10:29:48.492]                       }
[10:29:48.492]                       else if (inherits(cond, "warning")) {
[10:29:48.492]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.492]                         if (muffled) 
[10:29:48.492]                           invokeRestart("muffleWarning")
[10:29:48.492]                       }
[10:29:48.492]                       else if (inherits(cond, "condition")) {
[10:29:48.492]                         if (!is.null(pattern)) {
[10:29:48.492]                           computeRestarts <- base::computeRestarts
[10:29:48.492]                           grepl <- base::grepl
[10:29:48.492]                           restarts <- computeRestarts(cond)
[10:29:48.492]                           for (restart in restarts) {
[10:29:48.492]                             name <- restart$name
[10:29:48.492]                             if (is.null(name)) 
[10:29:48.492]                               next
[10:29:48.492]                             if (!grepl(pattern, name)) 
[10:29:48.492]                               next
[10:29:48.492]                             invokeRestart(restart)
[10:29:48.492]                             muffled <- TRUE
[10:29:48.492]                             break
[10:29:48.492]                           }
[10:29:48.492]                         }
[10:29:48.492]                       }
[10:29:48.492]                       invisible(muffled)
[10:29:48.492]                     }
[10:29:48.492]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.492]                   }
[10:29:48.492]                 }
[10:29:48.492]                 else {
[10:29:48.492]                   if (TRUE) {
[10:29:48.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.492]                     {
[10:29:48.492]                       inherits <- base::inherits
[10:29:48.492]                       invokeRestart <- base::invokeRestart
[10:29:48.492]                       is.null <- base::is.null
[10:29:48.492]                       muffled <- FALSE
[10:29:48.492]                       if (inherits(cond, "message")) {
[10:29:48.492]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.492]                         if (muffled) 
[10:29:48.492]                           invokeRestart("muffleMessage")
[10:29:48.492]                       }
[10:29:48.492]                       else if (inherits(cond, "warning")) {
[10:29:48.492]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.492]                         if (muffled) 
[10:29:48.492]                           invokeRestart("muffleWarning")
[10:29:48.492]                       }
[10:29:48.492]                       else if (inherits(cond, "condition")) {
[10:29:48.492]                         if (!is.null(pattern)) {
[10:29:48.492]                           computeRestarts <- base::computeRestarts
[10:29:48.492]                           grepl <- base::grepl
[10:29:48.492]                           restarts <- computeRestarts(cond)
[10:29:48.492]                           for (restart in restarts) {
[10:29:48.492]                             name <- restart$name
[10:29:48.492]                             if (is.null(name)) 
[10:29:48.492]                               next
[10:29:48.492]                             if (!grepl(pattern, name)) 
[10:29:48.492]                               next
[10:29:48.492]                             invokeRestart(restart)
[10:29:48.492]                             muffled <- TRUE
[10:29:48.492]                             break
[10:29:48.492]                           }
[10:29:48.492]                         }
[10:29:48.492]                       }
[10:29:48.492]                       invisible(muffled)
[10:29:48.492]                     }
[10:29:48.492]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.492]                   }
[10:29:48.492]                 }
[10:29:48.492]             }
[10:29:48.492]         }))
[10:29:48.492]     }, error = function(ex) {
[10:29:48.492]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.492]                 ...future.rng), started = ...future.startTime, 
[10:29:48.492]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.492]             version = "1.8"), class = "FutureResult")
[10:29:48.492]     }, finally = {
[10:29:48.492]         if (!identical(...future.workdir, getwd())) 
[10:29:48.492]             setwd(...future.workdir)
[10:29:48.492]         {
[10:29:48.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.492]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.492]             }
[10:29:48.492]             base::options(...future.oldOptions)
[10:29:48.492]             if (.Platform$OS.type == "windows") {
[10:29:48.492]                 old_names <- names(...future.oldEnvVars)
[10:29:48.492]                 envs <- base::Sys.getenv()
[10:29:48.492]                 names <- names(envs)
[10:29:48.492]                 common <- intersect(names, old_names)
[10:29:48.492]                 added <- setdiff(names, old_names)
[10:29:48.492]                 removed <- setdiff(old_names, names)
[10:29:48.492]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.492]                   envs[common]]
[10:29:48.492]                 NAMES <- toupper(changed)
[10:29:48.492]                 args <- list()
[10:29:48.492]                 for (kk in seq_along(NAMES)) {
[10:29:48.492]                   name <- changed[[kk]]
[10:29:48.492]                   NAME <- NAMES[[kk]]
[10:29:48.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.492]                     next
[10:29:48.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.492]                 }
[10:29:48.492]                 NAMES <- toupper(added)
[10:29:48.492]                 for (kk in seq_along(NAMES)) {
[10:29:48.492]                   name <- added[[kk]]
[10:29:48.492]                   NAME <- NAMES[[kk]]
[10:29:48.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.492]                     next
[10:29:48.492]                   args[[name]] <- ""
[10:29:48.492]                 }
[10:29:48.492]                 NAMES <- toupper(removed)
[10:29:48.492]                 for (kk in seq_along(NAMES)) {
[10:29:48.492]                   name <- removed[[kk]]
[10:29:48.492]                   NAME <- NAMES[[kk]]
[10:29:48.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.492]                     next
[10:29:48.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.492]                 }
[10:29:48.492]                 if (length(args) > 0) 
[10:29:48.492]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.492]             }
[10:29:48.492]             else {
[10:29:48.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.492]             }
[10:29:48.492]             {
[10:29:48.492]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.492]                   0L) {
[10:29:48.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.492]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.492]                   base::options(opts)
[10:29:48.492]                 }
[10:29:48.492]                 {
[10:29:48.492]                   {
[10:29:48.492]                     NULL
[10:29:48.492]                     RNGkind("Mersenne-Twister")
[10:29:48.492]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:48.492]                       inherits = FALSE)
[10:29:48.492]                   }
[10:29:48.492]                   options(future.plan = NULL)
[10:29:48.492]                   if (is.na(NA_character_)) 
[10:29:48.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.492]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.492]                     .init = FALSE)
[10:29:48.492]                 }
[10:29:48.492]             }
[10:29:48.492]         }
[10:29:48.492]     })
[10:29:48.492]     if (TRUE) {
[10:29:48.492]         base::sink(type = "output", split = FALSE)
[10:29:48.492]         if (TRUE) {
[10:29:48.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.492]         }
[10:29:48.492]         else {
[10:29:48.492]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.492]         }
[10:29:48.492]         base::close(...future.stdout)
[10:29:48.492]         ...future.stdout <- NULL
[10:29:48.492]     }
[10:29:48.492]     ...future.result$conditions <- ...future.conditions
[10:29:48.492]     ...future.result$finished <- base::Sys.time()
[10:29:48.492]     ...future.result
[10:29:48.492] }
[10:29:48.494] assign_globals() ...
[10:29:48.494] List of 5
[10:29:48.494]  $ future.call.arguments    : list()
[10:29:48.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.494]  $ ...future.FUN            :function (x)  
[10:29:48.494]  $ ...future.elements_ii    :List of 6
[10:29:48.494]   ..$ : int [1:4] 1 7 13 19
[10:29:48.494]   ..$ : int [1:4] 2 8 14 20
[10:29:48.494]   ..$ : int [1:4] 3 9 15 21
[10:29:48.494]   ..$ : int [1:4] 4 10 16 22
[10:29:48.494]   ..$ : int [1:4] 5 11 17 23
[10:29:48.494]   ..$ : int [1:4] 6 12 18 24
[10:29:48.494]  $ ...future.seeds_ii       : NULL
[10:29:48.494]  $ ...future.globals.maxSize: num Inf
[10:29:48.494]  - attr(*, "resolved")= logi FALSE
[10:29:48.494]  - attr(*, "total_size")= num NA
[10:29:48.494]  - attr(*, "where")=List of 5
[10:29:48.494]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.494]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.494]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.494]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.494]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.494]  - attr(*, "already-done")= logi TRUE
[10:29:48.500] - copied ‘future.call.arguments’ to environment
[10:29:48.500] - reassign environment for ‘...future.FUN’
[10:29:48.500] - copied ‘...future.FUN’ to environment
[10:29:48.500] - copied ‘...future.elements_ii’ to environment
[10:29:48.500] - copied ‘...future.seeds_ii’ to environment
[10:29:48.500] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.500] assign_globals() ... done
[10:29:48.501] plan(): Setting new future strategy stack:
[10:29:48.501] List of future strategies:
[10:29:48.501] 1. sequential:
[10:29:48.501]    - args: function (..., envir = parent.frame())
[10:29:48.501]    - tweaked: FALSE
[10:29:48.501]    - call: NULL
[10:29:48.501] plan(): nbrOfWorkers() = 1
[10:29:48.502] plan(): Setting new future strategy stack:
[10:29:48.526] List of future strategies:
[10:29:48.526] 1. sequential:
[10:29:48.526]    - args: function (..., envir = parent.frame())
[10:29:48.526]    - tweaked: FALSE
[10:29:48.526]    - call: plan(strategy)
[10:29:48.527] plan(): nbrOfWorkers() = 1
[10:29:48.527] SequentialFuture started (and completed)
[10:29:48.527] - Launch lazy future ... done
[10:29:48.528] run() for ‘SequentialFuture’ ... done
[10:29:48.528] Created future:
[10:29:48.528] SequentialFuture:
[10:29:48.528] Label: ‘future_apply-1’
[10:29:48.528] Expression:
[10:29:48.528] {
[10:29:48.528]     do.call(function(...) {
[10:29:48.528]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.528]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.528]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.528]             on.exit(options(oopts), add = TRUE)
[10:29:48.528]         }
[10:29:48.528]         {
[10:29:48.528]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.528]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.528]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.528]             })
[10:29:48.528]         }
[10:29:48.528]     }, args = future.call.arguments)
[10:29:48.528] }
[10:29:48.528] Lazy evaluation: FALSE
[10:29:48.528] Asynchronous evaluation: FALSE
[10:29:48.528] Local evaluation: TRUE
[10:29:48.528] Environment: R_GlobalEnv
[10:29:48.528] Capture standard output: TRUE
[10:29:48.528] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.528] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.528] Packages: <none>
[10:29:48.528] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.528] Resolved: TRUE
[10:29:48.528] Value: 1.03 KiB of class ‘list’
[10:29:48.528] Early signaling: FALSE
[10:29:48.528] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.528] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.529] Chunk #1 of 1 ... DONE
[10:29:48.529] Launching 1 futures (chunks) ... DONE
[10:29:48.529] Resolving 1 futures (chunks) ...
[10:29:48.529] resolve() on list ...
[10:29:48.530]  recursive: 0
[10:29:48.530]  length: 1
[10:29:48.530] 
[10:29:48.530] resolved() for ‘SequentialFuture’ ...
[10:29:48.530] - state: ‘finished’
[10:29:48.530] - run: TRUE
[10:29:48.530] - result: ‘FutureResult’
[10:29:48.530] resolved() for ‘SequentialFuture’ ... done
[10:29:48.530] Future #1
[10:29:48.530] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:48.531] - nx: 1
[10:29:48.531] - relay: TRUE
[10:29:48.531] - stdout: TRUE
[10:29:48.531] - signal: TRUE
[10:29:48.531] - resignal: FALSE
[10:29:48.531] - force: TRUE
[10:29:48.531] - relayed: [n=1] FALSE
[10:29:48.531] - queued futures: [n=1] FALSE
[10:29:48.531]  - until=1
[10:29:48.531]  - relaying element #1
[10:29:48.531] - relayed: [n=1] TRUE
[10:29:48.532] - queued futures: [n=1] TRUE
[10:29:48.532] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:48.532]  length: 0 (resolved future 1)
[10:29:48.532] Relaying remaining futures
[10:29:48.532] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.532] - nx: 1
[10:29:48.532] - relay: TRUE
[10:29:48.532] - stdout: TRUE
[10:29:48.532] - signal: TRUE
[10:29:48.532] - resignal: FALSE
[10:29:48.532] - force: TRUE
[10:29:48.532] - relayed: [n=1] TRUE
[10:29:48.533] - queued futures: [n=1] TRUE
 - flush all
[10:29:48.533] - relayed: [n=1] TRUE
[10:29:48.533] - queued futures: [n=1] TRUE
[10:29:48.533] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.533] resolve() on list ... DONE
[10:29:48.533]  - Number of value chunks collected: 1
[10:29:48.533] Resolving 1 futures (chunks) ... DONE
[10:29:48.533] Reducing values from 1 chunks ...
[10:29:48.533]  - Number of values collected after concatenation: 6
[10:29:48.534]  - Number of values expected: 6
[10:29:48.534] Reducing values from 1 chunks ... DONE
[10:29:48.534] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:29:48.534] getGlobalsAndPackagesXApply() ...
[10:29:48.534]  - future.globals: TRUE
[10:29:48.534] getGlobalsAndPackages() ...
[10:29:48.534] Searching for globals...
[10:29:48.535] - globals found: [1] ‘FUN’
[10:29:48.535] Searching for globals ... DONE
[10:29:48.536] Resolving globals: FALSE
[10:29:48.536] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:48.536] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:48.536] - globals: [1] ‘FUN’
[10:29:48.536] 
[10:29:48.536] getGlobalsAndPackages() ... DONE
[10:29:48.537]  - globals found/used: [n=1] ‘FUN’
[10:29:48.537]  - needed namespaces: [n=0] 
[10:29:48.537] Finding globals ... DONE
[10:29:48.537]  - use_args: TRUE
[10:29:48.537]  - Getting '...' globals ...
[10:29:48.537] resolve() on list ...
[10:29:48.537]  recursive: 0
[10:29:48.537]  length: 1
[10:29:48.537]  elements: ‘...’
[10:29:48.538]  length: 0 (resolved future 1)
[10:29:48.538] resolve() on list ... DONE
[10:29:48.538]    - '...' content: [n=0] 
[10:29:48.538] List of 1
[10:29:48.538]  $ ...: list()
[10:29:48.538]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.538]  - attr(*, "where")=List of 1
[10:29:48.538]   ..$ ...:<environment: 0x56189fba7ca0> 
[10:29:48.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.538]  - attr(*, "resolved")= logi TRUE
[10:29:48.538]  - attr(*, "total_size")= num NA
[10:29:48.540]  - Getting '...' globals ... DONE
[10:29:48.541] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.541] List of 2
[10:29:48.541]  $ ...future.FUN:function (x)  
[10:29:48.541]  $ ...          : list()
[10:29:48.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.541]  - attr(*, "where")=List of 2
[10:29:48.541]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.541]   ..$ ...          :<environment: 0x56189fba7ca0> 
[10:29:48.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.541]  - attr(*, "resolved")= logi FALSE
[10:29:48.541]  - attr(*, "total_size")= num 848
[10:29:48.543] Packages to be attached in all futures: [n=0] 
[10:29:48.543] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.544] future_lapply() ...
[10:29:48.544] Number of chunks: 1
[10:29:48.544] getGlobalsAndPackagesXApply() ...
[10:29:48.544]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.544]  - use_args: TRUE
[10:29:48.544] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.545] List of 2
[10:29:48.545]  $ ...          : list()
[10:29:48.545]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.545]  $ ...future.FUN:function (x)  
[10:29:48.545]  - attr(*, "where")=List of 2
[10:29:48.545]   ..$ ...          :<environment: 0x56189fba7ca0> 
[10:29:48.545]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:48.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.545]  - attr(*, "resolved")= logi FALSE
[10:29:48.545]  - attr(*, "total_size")= num NA
[10:29:48.548] Packages to be attached in all futures: [n=0] 
[10:29:48.548] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.548] Number of futures (= number of chunks): 1
[10:29:48.548] Launching 1 futures (chunks) ...
[10:29:48.548] Chunk #1 of 1 ...
[10:29:48.548]  - seeds: <none>
[10:29:48.548]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.549] getGlobalsAndPackages() ...
[10:29:48.549] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.549] Resolving globals: FALSE
[10:29:48.549] Tweak future expression to call with '...' arguments ...
[10:29:48.549] {
[10:29:48.549]     do.call(function(...) {
[10:29:48.549]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.549]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.549]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.549]             on.exit(options(oopts), add = TRUE)
[10:29:48.549]         }
[10:29:48.549]         {
[10:29:48.549]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.549]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.549]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.549]             })
[10:29:48.549]         }
[10:29:48.549]     }, args = future.call.arguments)
[10:29:48.549] }
[10:29:48.549] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.551] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.551] 
[10:29:48.551] getGlobalsAndPackages() ... DONE
[10:29:48.551] run() for ‘Future’ ...
[10:29:48.551] - state: ‘created’
[10:29:48.551] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:48.552] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.552] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:48.552]   - Field: ‘label’
[10:29:48.552]   - Field: ‘local’
[10:29:48.552]   - Field: ‘owner’
[10:29:48.552]   - Field: ‘envir’
[10:29:48.552]   - Field: ‘packages’
[10:29:48.552]   - Field: ‘gc’
[10:29:48.552]   - Field: ‘conditions’
[10:29:48.553]   - Field: ‘expr’
[10:29:48.553]   - Field: ‘uuid’
[10:29:48.553]   - Field: ‘seed’
[10:29:48.553]   - Field: ‘version’
[10:29:48.553]   - Field: ‘result’
[10:29:48.553]   - Field: ‘asynchronous’
[10:29:48.553]   - Field: ‘calls’
[10:29:48.553]   - Field: ‘globals’
[10:29:48.553]   - Field: ‘stdout’
[10:29:48.553]   - Field: ‘earlySignal’
[10:29:48.553]   - Field: ‘lazy’
[10:29:48.554]   - Field: ‘state’
[10:29:48.554] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:48.554] - Launch lazy future ...
[10:29:48.554] Packages needed by the future expression (n = 0): <none>
[10:29:48.554] Packages needed by future strategies (n = 0): <none>
[10:29:48.554] {
[10:29:48.554]     {
[10:29:48.554]         {
[10:29:48.554]             ...future.startTime <- base::Sys.time()
[10:29:48.554]             {
[10:29:48.554]                 {
[10:29:48.554]                   {
[10:29:48.554]                     base::local({
[10:29:48.554]                       has_future <- base::requireNamespace("future", 
[10:29:48.554]                         quietly = TRUE)
[10:29:48.554]                       if (has_future) {
[10:29:48.554]                         ns <- base::getNamespace("future")
[10:29:48.554]                         version <- ns[[".package"]][["version"]]
[10:29:48.554]                         if (is.null(version)) 
[10:29:48.554]                           version <- utils::packageVersion("future")
[10:29:48.554]                       }
[10:29:48.554]                       else {
[10:29:48.554]                         version <- NULL
[10:29:48.554]                       }
[10:29:48.554]                       if (!has_future || version < "1.8.0") {
[10:29:48.554]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.554]                           "", base::R.version$version.string), 
[10:29:48.554]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:48.554]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.554]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.554]                             "release", "version")], collapse = " "), 
[10:29:48.554]                           hostname = base::Sys.info()[["nodename"]])
[10:29:48.554]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.554]                           info)
[10:29:48.554]                         info <- base::paste(info, collapse = "; ")
[10:29:48.554]                         if (!has_future) {
[10:29:48.554]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.554]                             info)
[10:29:48.554]                         }
[10:29:48.554]                         else {
[10:29:48.554]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.554]                             info, version)
[10:29:48.554]                         }
[10:29:48.554]                         base::stop(msg)
[10:29:48.554]                       }
[10:29:48.554]                     })
[10:29:48.554]                   }
[10:29:48.554]                   ...future.strategy.old <- future::plan("list")
[10:29:48.554]                   options(future.plan = NULL)
[10:29:48.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.554]                 }
[10:29:48.554]                 ...future.workdir <- getwd()
[10:29:48.554]             }
[10:29:48.554]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.554]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.554]         }
[10:29:48.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.554]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.554]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.554]             base::names(...future.oldOptions))
[10:29:48.554]     }
[10:29:48.554]     if (FALSE) {
[10:29:48.554]     }
[10:29:48.554]     else {
[10:29:48.554]         if (TRUE) {
[10:29:48.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.554]                 open = "w")
[10:29:48.554]         }
[10:29:48.554]         else {
[10:29:48.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.554]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.554]         }
[10:29:48.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.554]             base::sink(type = "output", split = FALSE)
[10:29:48.554]             base::close(...future.stdout)
[10:29:48.554]         }, add = TRUE)
[10:29:48.554]     }
[10:29:48.554]     ...future.frame <- base::sys.nframe()
[10:29:48.554]     ...future.conditions <- base::list()
[10:29:48.554]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.554]     if (FALSE) {
[10:29:48.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.554]     }
[10:29:48.554]     ...future.result <- base::tryCatch({
[10:29:48.554]         base::withCallingHandlers({
[10:29:48.554]             ...future.value <- base::withVisible(base::local({
[10:29:48.554]                 do.call(function(...) {
[10:29:48.554]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.554]                   if (!identical(...future.globals.maxSize.org, 
[10:29:48.554]                     ...future.globals.maxSize)) {
[10:29:48.554]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.554]                     on.exit(options(oopts), add = TRUE)
[10:29:48.554]                   }
[10:29:48.554]                   {
[10:29:48.554]                     lapply(seq_along(...future.elements_ii), 
[10:29:48.554]                       FUN = function(jj) {
[10:29:48.554]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.554]                         ...future.FUN(...future.X_jj, ...)
[10:29:48.554]                       })
[10:29:48.554]                   }
[10:29:48.554]                 }, args = future.call.arguments)
[10:29:48.554]             }))
[10:29:48.554]             future::FutureResult(value = ...future.value$value, 
[10:29:48.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.554]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.554]                     ...future.globalenv.names))
[10:29:48.554]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.554]         }, condition = base::local({
[10:29:48.554]             c <- base::c
[10:29:48.554]             inherits <- base::inherits
[10:29:48.554]             invokeRestart <- base::invokeRestart
[10:29:48.554]             length <- base::length
[10:29:48.554]             list <- base::list
[10:29:48.554]             seq.int <- base::seq.int
[10:29:48.554]             signalCondition <- base::signalCondition
[10:29:48.554]             sys.calls <- base::sys.calls
[10:29:48.554]             `[[` <- base::`[[`
[10:29:48.554]             `+` <- base::`+`
[10:29:48.554]             `<<-` <- base::`<<-`
[10:29:48.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.554]                   3L)]
[10:29:48.554]             }
[10:29:48.554]             function(cond) {
[10:29:48.554]                 is_error <- inherits(cond, "error")
[10:29:48.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.554]                   NULL)
[10:29:48.554]                 if (is_error) {
[10:29:48.554]                   sessionInformation <- function() {
[10:29:48.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.554]                       search = base::search(), system = base::Sys.info())
[10:29:48.554]                   }
[10:29:48.554]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.554]                     cond$call), session = sessionInformation(), 
[10:29:48.554]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.554]                   signalCondition(cond)
[10:29:48.554]                 }
[10:29:48.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.554]                 "immediateCondition"))) {
[10:29:48.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.554]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.554]                   if (TRUE && !signal) {
[10:29:48.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.554]                     {
[10:29:48.554]                       inherits <- base::inherits
[10:29:48.554]                       invokeRestart <- base::invokeRestart
[10:29:48.554]                       is.null <- base::is.null
[10:29:48.554]                       muffled <- FALSE
[10:29:48.554]                       if (inherits(cond, "message")) {
[10:29:48.554]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.554]                         if (muffled) 
[10:29:48.554]                           invokeRestart("muffleMessage")
[10:29:48.554]                       }
[10:29:48.554]                       else if (inherits(cond, "warning")) {
[10:29:48.554]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.554]                         if (muffled) 
[10:29:48.554]                           invokeRestart("muffleWarning")
[10:29:48.554]                       }
[10:29:48.554]                       else if (inherits(cond, "condition")) {
[10:29:48.554]                         if (!is.null(pattern)) {
[10:29:48.554]                           computeRestarts <- base::computeRestarts
[10:29:48.554]                           grepl <- base::grepl
[10:29:48.554]                           restarts <- computeRestarts(cond)
[10:29:48.554]                           for (restart in restarts) {
[10:29:48.554]                             name <- restart$name
[10:29:48.554]                             if (is.null(name)) 
[10:29:48.554]                               next
[10:29:48.554]                             if (!grepl(pattern, name)) 
[10:29:48.554]                               next
[10:29:48.554]                             invokeRestart(restart)
[10:29:48.554]                             muffled <- TRUE
[10:29:48.554]                             break
[10:29:48.554]                           }
[10:29:48.554]                         }
[10:29:48.554]                       }
[10:29:48.554]                       invisible(muffled)
[10:29:48.554]                     }
[10:29:48.554]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.554]                   }
[10:29:48.554]                 }
[10:29:48.554]                 else {
[10:29:48.554]                   if (TRUE) {
[10:29:48.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.554]                     {
[10:29:48.554]                       inherits <- base::inherits
[10:29:48.554]                       invokeRestart <- base::invokeRestart
[10:29:48.554]                       is.null <- base::is.null
[10:29:48.554]                       muffled <- FALSE
[10:29:48.554]                       if (inherits(cond, "message")) {
[10:29:48.554]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.554]                         if (muffled) 
[10:29:48.554]                           invokeRestart("muffleMessage")
[10:29:48.554]                       }
[10:29:48.554]                       else if (inherits(cond, "warning")) {
[10:29:48.554]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.554]                         if (muffled) 
[10:29:48.554]                           invokeRestart("muffleWarning")
[10:29:48.554]                       }
[10:29:48.554]                       else if (inherits(cond, "condition")) {
[10:29:48.554]                         if (!is.null(pattern)) {
[10:29:48.554]                           computeRestarts <- base::computeRestarts
[10:29:48.554]                           grepl <- base::grepl
[10:29:48.554]                           restarts <- computeRestarts(cond)
[10:29:48.554]                           for (restart in restarts) {
[10:29:48.554]                             name <- restart$name
[10:29:48.554]                             if (is.null(name)) 
[10:29:48.554]                               next
[10:29:48.554]                             if (!grepl(pattern, name)) 
[10:29:48.554]                               next
[10:29:48.554]                             invokeRestart(restart)
[10:29:48.554]                             muffled <- TRUE
[10:29:48.554]                             break
[10:29:48.554]                           }
[10:29:48.554]                         }
[10:29:48.554]                       }
[10:29:48.554]                       invisible(muffled)
[10:29:48.554]                     }
[10:29:48.554]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.554]                   }
[10:29:48.554]                 }
[10:29:48.554]             }
[10:29:48.554]         }))
[10:29:48.554]     }, error = function(ex) {
[10:29:48.554]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.554]                 ...future.rng), started = ...future.startTime, 
[10:29:48.554]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.554]             version = "1.8"), class = "FutureResult")
[10:29:48.554]     }, finally = {
[10:29:48.554]         if (!identical(...future.workdir, getwd())) 
[10:29:48.554]             setwd(...future.workdir)
[10:29:48.554]         {
[10:29:48.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.554]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.554]             }
[10:29:48.554]             base::options(...future.oldOptions)
[10:29:48.554]             if (.Platform$OS.type == "windows") {
[10:29:48.554]                 old_names <- names(...future.oldEnvVars)
[10:29:48.554]                 envs <- base::Sys.getenv()
[10:29:48.554]                 names <- names(envs)
[10:29:48.554]                 common <- intersect(names, old_names)
[10:29:48.554]                 added <- setdiff(names, old_names)
[10:29:48.554]                 removed <- setdiff(old_names, names)
[10:29:48.554]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.554]                   envs[common]]
[10:29:48.554]                 NAMES <- toupper(changed)
[10:29:48.554]                 args <- list()
[10:29:48.554]                 for (kk in seq_along(NAMES)) {
[10:29:48.554]                   name <- changed[[kk]]
[10:29:48.554]                   NAME <- NAMES[[kk]]
[10:29:48.554]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.554]                     next
[10:29:48.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.554]                 }
[10:29:48.554]                 NAMES <- toupper(added)
[10:29:48.554]                 for (kk in seq_along(NAMES)) {
[10:29:48.554]                   name <- added[[kk]]
[10:29:48.554]                   NAME <- NAMES[[kk]]
[10:29:48.554]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.554]                     next
[10:29:48.554]                   args[[name]] <- ""
[10:29:48.554]                 }
[10:29:48.554]                 NAMES <- toupper(removed)
[10:29:48.554]                 for (kk in seq_along(NAMES)) {
[10:29:48.554]                   name <- removed[[kk]]
[10:29:48.554]                   NAME <- NAMES[[kk]]
[10:29:48.554]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.554]                     next
[10:29:48.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.554]                 }
[10:29:48.554]                 if (length(args) > 0) 
[10:29:48.554]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.554]             }
[10:29:48.554]             else {
[10:29:48.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.554]             }
[10:29:48.554]             {
[10:29:48.554]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.554]                   0L) {
[10:29:48.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.554]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.554]                   base::options(opts)
[10:29:48.554]                 }
[10:29:48.554]                 {
[10:29:48.554]                   {
[10:29:48.554]                     NULL
[10:29:48.554]                     RNGkind("Mersenne-Twister")
[10:29:48.554]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:48.554]                       inherits = FALSE)
[10:29:48.554]                   }
[10:29:48.554]                   options(future.plan = NULL)
[10:29:48.554]                   if (is.na(NA_character_)) 
[10:29:48.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.554]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.554]                     .init = FALSE)
[10:29:48.554]                 }
[10:29:48.554]             }
[10:29:48.554]         }
[10:29:48.554]     })
[10:29:48.554]     if (TRUE) {
[10:29:48.554]         base::sink(type = "output", split = FALSE)
[10:29:48.554]         if (TRUE) {
[10:29:48.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.554]         }
[10:29:48.554]         else {
[10:29:48.554]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.554]         }
[10:29:48.554]         base::close(...future.stdout)
[10:29:48.554]         ...future.stdout <- NULL
[10:29:48.554]     }
[10:29:48.554]     ...future.result$conditions <- ...future.conditions
[10:29:48.554]     ...future.result$finished <- base::Sys.time()
[10:29:48.554]     ...future.result
[10:29:48.554] }
[10:29:48.556] assign_globals() ...
[10:29:48.556] List of 5
[10:29:48.556]  $ future.call.arguments    : list()
[10:29:48.556]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.556]  $ ...future.FUN            :function (x)  
[10:29:48.556]  $ ...future.elements_ii    :List of 2
[10:29:48.556]   ..$ : int 1
[10:29:48.556]   ..$ : int 2
[10:29:48.556]  $ ...future.seeds_ii       : NULL
[10:29:48.556]  $ ...future.globals.maxSize: num Inf
[10:29:48.556]  - attr(*, "resolved")= logi FALSE
[10:29:48.556]  - attr(*, "total_size")= num NA
[10:29:48.556]  - attr(*, "where")=List of 5
[10:29:48.556]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.556]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.556]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.556]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.556]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.556]  - attr(*, "already-done")= logi TRUE
[10:29:48.561] - copied ‘future.call.arguments’ to environment
[10:29:48.561] - copied ‘...future.FUN’ to environment
[10:29:48.561] - copied ‘...future.elements_ii’ to environment
[10:29:48.561] - copied ‘...future.seeds_ii’ to environment
[10:29:48.562] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.562] assign_globals() ... done
[10:29:48.562] plan(): Setting new future strategy stack:
[10:29:48.562] List of future strategies:
[10:29:48.562] 1. sequential:
[10:29:48.562]    - args: function (..., envir = parent.frame())
[10:29:48.562]    - tweaked: FALSE
[10:29:48.562]    - call: NULL
[10:29:48.562] plan(): nbrOfWorkers() = 1
[10:29:48.563] plan(): Setting new future strategy stack:
[10:29:48.563] List of future strategies:
[10:29:48.563] 1. sequential:
[10:29:48.563]    - args: function (..., envir = parent.frame())
[10:29:48.563]    - tweaked: FALSE
[10:29:48.563]    - call: plan(strategy)
[10:29:48.563] plan(): nbrOfWorkers() = 1
[10:29:48.564] SequentialFuture started (and completed)
[10:29:48.564] - Launch lazy future ... done
[10:29:48.564] run() for ‘SequentialFuture’ ... done
[10:29:48.564] Created future:
[10:29:48.564] SequentialFuture:
[10:29:48.564] Label: ‘future_apply-1’
[10:29:48.564] Expression:
[10:29:48.564] {
[10:29:48.564]     do.call(function(...) {
[10:29:48.564]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.564]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.564]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.564]             on.exit(options(oopts), add = TRUE)
[10:29:48.564]         }
[10:29:48.564]         {
[10:29:48.564]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.564]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.564]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.564]             })
[10:29:48.564]         }
[10:29:48.564]     }, args = future.call.arguments)
[10:29:48.564] }
[10:29:48.564] Lazy evaluation: FALSE
[10:29:48.564] Asynchronous evaluation: FALSE
[10:29:48.564] Local evaluation: TRUE
[10:29:48.564] Environment: R_GlobalEnv
[10:29:48.564] Capture standard output: TRUE
[10:29:48.564] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.564] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.564] Packages: <none>
[10:29:48.564] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.564] Resolved: TRUE
[10:29:48.564] Value: 112 bytes of class ‘list’
[10:29:48.564] Early signaling: FALSE
[10:29:48.564] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.564] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.565] Chunk #1 of 1 ... DONE
[10:29:48.565] Launching 1 futures (chunks) ... DONE
[10:29:48.565] Resolving 1 futures (chunks) ...
[10:29:48.565] resolve() on list ...
[10:29:48.565]  recursive: 0
[10:29:48.565]  length: 1
[10:29:48.566] 
[10:29:48.566] resolved() for ‘SequentialFuture’ ...
[10:29:48.566] - state: ‘finished’
[10:29:48.566] - run: TRUE
[10:29:48.566] - result: ‘FutureResult’
[10:29:48.566] resolved() for ‘SequentialFuture’ ... done
[10:29:48.566] Future #1
[10:29:48.566] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:48.566] - nx: 1
[10:29:48.566] - relay: TRUE
[10:29:48.567] - stdout: TRUE
[10:29:48.567] - signal: TRUE
[10:29:48.567] - resignal: FALSE
[10:29:48.567] - force: TRUE
[10:29:48.567] - relayed: [n=1] FALSE
[10:29:48.567] - queued futures: [n=1] FALSE
[10:29:48.567]  - until=1
[10:29:48.567]  - relaying element #1
[10:29:48.567] - relayed: [n=1] TRUE
[10:29:48.567] - queued futures: [n=1] TRUE
[10:29:48.567] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:48.568]  length: 0 (resolved future 1)
[10:29:48.568] Relaying remaining futures
[10:29:48.568] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.568] - nx: 1
[10:29:48.568] - relay: TRUE
[10:29:48.568] - stdout: TRUE
[10:29:48.568] - signal: TRUE
[10:29:48.568] - resignal: FALSE
[10:29:48.568] - force: TRUE
[10:29:48.568] - relayed: [n=1] TRUE
[10:29:48.568] - queued futures: [n=1] TRUE
 - flush all
[10:29:48.569] - relayed: [n=1] TRUE
[10:29:48.569] - queued futures: [n=1] TRUE
[10:29:48.569] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.569] resolve() on list ... DONE
[10:29:48.569]  - Number of value chunks collected: 1
[10:29:48.569] Resolving 1 futures (chunks) ... DONE
[10:29:48.569] Reducing values from 1 chunks ...
[10:29:48.569]  - Number of values collected after concatenation: 2
[10:29:48.569]  - Number of values expected: 2
[10:29:48.569] Reducing values from 1 chunks ... DONE
[10:29:48.570] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:29:48.570] getGlobalsAndPackagesXApply() ...
[10:29:48.570]  - future.globals: TRUE
[10:29:48.570] getGlobalsAndPackages() ...
[10:29:48.570] Searching for globals...
[10:29:48.571] - globals found: [1] ‘FUN’
[10:29:48.571] Searching for globals ... DONE
[10:29:48.571] Resolving globals: FALSE
[10:29:48.572] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:48.572] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:48.572] - globals: [1] ‘FUN’
[10:29:48.572] 
[10:29:48.572] getGlobalsAndPackages() ... DONE
[10:29:48.572]  - globals found/used: [n=1] ‘FUN’
[10:29:48.572]  - needed namespaces: [n=0] 
[10:29:48.572] Finding globals ... DONE
[10:29:48.573]  - use_args: TRUE
[10:29:48.573]  - Getting '...' globals ...
[10:29:48.573] resolve() on list ...
[10:29:48.573]  recursive: 0
[10:29:48.573]  length: 1
[10:29:48.573]  elements: ‘...’
[10:29:48.573]  length: 0 (resolved future 1)
[10:29:48.573] resolve() on list ... DONE
[10:29:48.573]    - '...' content: [n=0] 
[10:29:48.574] List of 1
[10:29:48.574]  $ ...: list()
[10:29:48.574]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.574]  - attr(*, "where")=List of 1
[10:29:48.574]   ..$ ...:<environment: 0x5618a210e6c0> 
[10:29:48.574]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.574]  - attr(*, "resolved")= logi TRUE
[10:29:48.574]  - attr(*, "total_size")= num NA
[10:29:48.577]  - Getting '...' globals ... DONE
[10:29:48.577] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.577] List of 2
[10:29:48.577]  $ ...future.FUN:function (x)  
[10:29:48.577]  $ ...          : list()
[10:29:48.577]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.577]  - attr(*, "where")=List of 2
[10:29:48.577]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.577]   ..$ ...          :<environment: 0x5618a210e6c0> 
[10:29:48.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.577]  - attr(*, "resolved")= logi FALSE
[10:29:48.577]  - attr(*, "total_size")= num 848
[10:29:48.580] Packages to be attached in all futures: [n=0] 
[10:29:48.580] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.580] future_lapply() ...
[10:29:48.581] Number of chunks: 1
[10:29:48.581] getGlobalsAndPackagesXApply() ...
[10:29:48.581]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.581]  - use_args: TRUE
[10:29:48.581] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.581] List of 2
[10:29:48.581]  $ ...          : list()
[10:29:48.581]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.581]  $ ...future.FUN:function (x)  
[10:29:48.581]  - attr(*, "where")=List of 2
[10:29:48.581]   ..$ ...          :<environment: 0x5618a210e6c0> 
[10:29:48.581]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:48.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.581]  - attr(*, "resolved")= logi FALSE
[10:29:48.581]  - attr(*, "total_size")= num NA
[10:29:48.584] Packages to be attached in all futures: [n=0] 
[10:29:48.584] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.584] Number of futures (= number of chunks): 1
[10:29:48.585] Launching 1 futures (chunks) ...
[10:29:48.585] Chunk #1 of 1 ...
[10:29:48.585]  - seeds: <none>
[10:29:48.585]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.585] getGlobalsAndPackages() ...
[10:29:48.585] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.585] Resolving globals: FALSE
[10:29:48.585] Tweak future expression to call with '...' arguments ...
[10:29:48.585] {
[10:29:48.585]     do.call(function(...) {
[10:29:48.585]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.585]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.585]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.585]             on.exit(options(oopts), add = TRUE)
[10:29:48.585]         }
[10:29:48.585]         {
[10:29:48.585]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.585]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.585]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.585]             })
[10:29:48.585]         }
[10:29:48.585]     }, args = future.call.arguments)
[10:29:48.585] }
[10:29:48.586] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.586] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.586] 
[10:29:48.586] getGlobalsAndPackages() ... DONE
[10:29:48.587] run() for ‘Future’ ...
[10:29:48.587] - state: ‘created’
[10:29:48.587] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:48.587] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.587] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:48.587]   - Field: ‘label’
[10:29:48.587]   - Field: ‘local’
[10:29:48.587]   - Field: ‘owner’
[10:29:48.588]   - Field: ‘envir’
[10:29:48.588]   - Field: ‘packages’
[10:29:48.588]   - Field: ‘gc’
[10:29:48.588]   - Field: ‘conditions’
[10:29:48.588]   - Field: ‘expr’
[10:29:48.588]   - Field: ‘uuid’
[10:29:48.588]   - Field: ‘seed’
[10:29:48.588]   - Field: ‘version’
[10:29:48.588]   - Field: ‘result’
[10:29:48.588]   - Field: ‘asynchronous’
[10:29:48.588]   - Field: ‘calls’
[10:29:48.588]   - Field: ‘globals’
[10:29:48.589]   - Field: ‘stdout’
[10:29:48.589]   - Field: ‘earlySignal’
[10:29:48.589]   - Field: ‘lazy’
[10:29:48.589]   - Field: ‘state’
[10:29:48.589] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:48.589] - Launch lazy future ...
[10:29:48.589] Packages needed by the future expression (n = 0): <none>
[10:29:48.589] Packages needed by future strategies (n = 0): <none>
[10:29:48.590] {
[10:29:48.590]     {
[10:29:48.590]         {
[10:29:48.590]             ...future.startTime <- base::Sys.time()
[10:29:48.590]             {
[10:29:48.590]                 {
[10:29:48.590]                   {
[10:29:48.590]                     base::local({
[10:29:48.590]                       has_future <- base::requireNamespace("future", 
[10:29:48.590]                         quietly = TRUE)
[10:29:48.590]                       if (has_future) {
[10:29:48.590]                         ns <- base::getNamespace("future")
[10:29:48.590]                         version <- ns[[".package"]][["version"]]
[10:29:48.590]                         if (is.null(version)) 
[10:29:48.590]                           version <- utils::packageVersion("future")
[10:29:48.590]                       }
[10:29:48.590]                       else {
[10:29:48.590]                         version <- NULL
[10:29:48.590]                       }
[10:29:48.590]                       if (!has_future || version < "1.8.0") {
[10:29:48.590]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.590]                           "", base::R.version$version.string), 
[10:29:48.590]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:48.590]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.590]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.590]                             "release", "version")], collapse = " "), 
[10:29:48.590]                           hostname = base::Sys.info()[["nodename"]])
[10:29:48.590]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.590]                           info)
[10:29:48.590]                         info <- base::paste(info, collapse = "; ")
[10:29:48.590]                         if (!has_future) {
[10:29:48.590]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.590]                             info)
[10:29:48.590]                         }
[10:29:48.590]                         else {
[10:29:48.590]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.590]                             info, version)
[10:29:48.590]                         }
[10:29:48.590]                         base::stop(msg)
[10:29:48.590]                       }
[10:29:48.590]                     })
[10:29:48.590]                   }
[10:29:48.590]                   ...future.strategy.old <- future::plan("list")
[10:29:48.590]                   options(future.plan = NULL)
[10:29:48.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.590]                 }
[10:29:48.590]                 ...future.workdir <- getwd()
[10:29:48.590]             }
[10:29:48.590]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.590]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.590]         }
[10:29:48.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.590]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.590]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.590]             base::names(...future.oldOptions))
[10:29:48.590]     }
[10:29:48.590]     if (FALSE) {
[10:29:48.590]     }
[10:29:48.590]     else {
[10:29:48.590]         if (TRUE) {
[10:29:48.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.590]                 open = "w")
[10:29:48.590]         }
[10:29:48.590]         else {
[10:29:48.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.590]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.590]         }
[10:29:48.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.590]             base::sink(type = "output", split = FALSE)
[10:29:48.590]             base::close(...future.stdout)
[10:29:48.590]         }, add = TRUE)
[10:29:48.590]     }
[10:29:48.590]     ...future.frame <- base::sys.nframe()
[10:29:48.590]     ...future.conditions <- base::list()
[10:29:48.590]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.590]     if (FALSE) {
[10:29:48.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.590]     }
[10:29:48.590]     ...future.result <- base::tryCatch({
[10:29:48.590]         base::withCallingHandlers({
[10:29:48.590]             ...future.value <- base::withVisible(base::local({
[10:29:48.590]                 do.call(function(...) {
[10:29:48.590]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.590]                   if (!identical(...future.globals.maxSize.org, 
[10:29:48.590]                     ...future.globals.maxSize)) {
[10:29:48.590]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.590]                     on.exit(options(oopts), add = TRUE)
[10:29:48.590]                   }
[10:29:48.590]                   {
[10:29:48.590]                     lapply(seq_along(...future.elements_ii), 
[10:29:48.590]                       FUN = function(jj) {
[10:29:48.590]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.590]                         ...future.FUN(...future.X_jj, ...)
[10:29:48.590]                       })
[10:29:48.590]                   }
[10:29:48.590]                 }, args = future.call.arguments)
[10:29:48.590]             }))
[10:29:48.590]             future::FutureResult(value = ...future.value$value, 
[10:29:48.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.590]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.590]                     ...future.globalenv.names))
[10:29:48.590]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.590]         }, condition = base::local({
[10:29:48.590]             c <- base::c
[10:29:48.590]             inherits <- base::inherits
[10:29:48.590]             invokeRestart <- base::invokeRestart
[10:29:48.590]             length <- base::length
[10:29:48.590]             list <- base::list
[10:29:48.590]             seq.int <- base::seq.int
[10:29:48.590]             signalCondition <- base::signalCondition
[10:29:48.590]             sys.calls <- base::sys.calls
[10:29:48.590]             `[[` <- base::`[[`
[10:29:48.590]             `+` <- base::`+`
[10:29:48.590]             `<<-` <- base::`<<-`
[10:29:48.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.590]                   3L)]
[10:29:48.590]             }
[10:29:48.590]             function(cond) {
[10:29:48.590]                 is_error <- inherits(cond, "error")
[10:29:48.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.590]                   NULL)
[10:29:48.590]                 if (is_error) {
[10:29:48.590]                   sessionInformation <- function() {
[10:29:48.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.590]                       search = base::search(), system = base::Sys.info())
[10:29:48.590]                   }
[10:29:48.590]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.590]                     cond$call), session = sessionInformation(), 
[10:29:48.590]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.590]                   signalCondition(cond)
[10:29:48.590]                 }
[10:29:48.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.590]                 "immediateCondition"))) {
[10:29:48.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.590]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.590]                   if (TRUE && !signal) {
[10:29:48.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.590]                     {
[10:29:48.590]                       inherits <- base::inherits
[10:29:48.590]                       invokeRestart <- base::invokeRestart
[10:29:48.590]                       is.null <- base::is.null
[10:29:48.590]                       muffled <- FALSE
[10:29:48.590]                       if (inherits(cond, "message")) {
[10:29:48.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.590]                         if (muffled) 
[10:29:48.590]                           invokeRestart("muffleMessage")
[10:29:48.590]                       }
[10:29:48.590]                       else if (inherits(cond, "warning")) {
[10:29:48.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.590]                         if (muffled) 
[10:29:48.590]                           invokeRestart("muffleWarning")
[10:29:48.590]                       }
[10:29:48.590]                       else if (inherits(cond, "condition")) {
[10:29:48.590]                         if (!is.null(pattern)) {
[10:29:48.590]                           computeRestarts <- base::computeRestarts
[10:29:48.590]                           grepl <- base::grepl
[10:29:48.590]                           restarts <- computeRestarts(cond)
[10:29:48.590]                           for (restart in restarts) {
[10:29:48.590]                             name <- restart$name
[10:29:48.590]                             if (is.null(name)) 
[10:29:48.590]                               next
[10:29:48.590]                             if (!grepl(pattern, name)) 
[10:29:48.590]                               next
[10:29:48.590]                             invokeRestart(restart)
[10:29:48.590]                             muffled <- TRUE
[10:29:48.590]                             break
[10:29:48.590]                           }
[10:29:48.590]                         }
[10:29:48.590]                       }
[10:29:48.590]                       invisible(muffled)
[10:29:48.590]                     }
[10:29:48.590]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.590]                   }
[10:29:48.590]                 }
[10:29:48.590]                 else {
[10:29:48.590]                   if (TRUE) {
[10:29:48.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.590]                     {
[10:29:48.590]                       inherits <- base::inherits
[10:29:48.590]                       invokeRestart <- base::invokeRestart
[10:29:48.590]                       is.null <- base::is.null
[10:29:48.590]                       muffled <- FALSE
[10:29:48.590]                       if (inherits(cond, "message")) {
[10:29:48.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.590]                         if (muffled) 
[10:29:48.590]                           invokeRestart("muffleMessage")
[10:29:48.590]                       }
[10:29:48.590]                       else if (inherits(cond, "warning")) {
[10:29:48.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.590]                         if (muffled) 
[10:29:48.590]                           invokeRestart("muffleWarning")
[10:29:48.590]                       }
[10:29:48.590]                       else if (inherits(cond, "condition")) {
[10:29:48.590]                         if (!is.null(pattern)) {
[10:29:48.590]                           computeRestarts <- base::computeRestarts
[10:29:48.590]                           grepl <- base::grepl
[10:29:48.590]                           restarts <- computeRestarts(cond)
[10:29:48.590]                           for (restart in restarts) {
[10:29:48.590]                             name <- restart$name
[10:29:48.590]                             if (is.null(name)) 
[10:29:48.590]                               next
[10:29:48.590]                             if (!grepl(pattern, name)) 
[10:29:48.590]                               next
[10:29:48.590]                             invokeRestart(restart)
[10:29:48.590]                             muffled <- TRUE
[10:29:48.590]                             break
[10:29:48.590]                           }
[10:29:48.590]                         }
[10:29:48.590]                       }
[10:29:48.590]                       invisible(muffled)
[10:29:48.590]                     }
[10:29:48.590]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.590]                   }
[10:29:48.590]                 }
[10:29:48.590]             }
[10:29:48.590]         }))
[10:29:48.590]     }, error = function(ex) {
[10:29:48.590]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.590]                 ...future.rng), started = ...future.startTime, 
[10:29:48.590]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.590]             version = "1.8"), class = "FutureResult")
[10:29:48.590]     }, finally = {
[10:29:48.590]         if (!identical(...future.workdir, getwd())) 
[10:29:48.590]             setwd(...future.workdir)
[10:29:48.590]         {
[10:29:48.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.590]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.590]             }
[10:29:48.590]             base::options(...future.oldOptions)
[10:29:48.590]             if (.Platform$OS.type == "windows") {
[10:29:48.590]                 old_names <- names(...future.oldEnvVars)
[10:29:48.590]                 envs <- base::Sys.getenv()
[10:29:48.590]                 names <- names(envs)
[10:29:48.590]                 common <- intersect(names, old_names)
[10:29:48.590]                 added <- setdiff(names, old_names)
[10:29:48.590]                 removed <- setdiff(old_names, names)
[10:29:48.590]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.590]                   envs[common]]
[10:29:48.590]                 NAMES <- toupper(changed)
[10:29:48.590]                 args <- list()
[10:29:48.590]                 for (kk in seq_along(NAMES)) {
[10:29:48.590]                   name <- changed[[kk]]
[10:29:48.590]                   NAME <- NAMES[[kk]]
[10:29:48.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.590]                     next
[10:29:48.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.590]                 }
[10:29:48.590]                 NAMES <- toupper(added)
[10:29:48.590]                 for (kk in seq_along(NAMES)) {
[10:29:48.590]                   name <- added[[kk]]
[10:29:48.590]                   NAME <- NAMES[[kk]]
[10:29:48.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.590]                     next
[10:29:48.590]                   args[[name]] <- ""
[10:29:48.590]                 }
[10:29:48.590]                 NAMES <- toupper(removed)
[10:29:48.590]                 for (kk in seq_along(NAMES)) {
[10:29:48.590]                   name <- removed[[kk]]
[10:29:48.590]                   NAME <- NAMES[[kk]]
[10:29:48.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.590]                     next
[10:29:48.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.590]                 }
[10:29:48.590]                 if (length(args) > 0) 
[10:29:48.590]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.590]             }
[10:29:48.590]             else {
[10:29:48.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.590]             }
[10:29:48.590]             {
[10:29:48.590]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.590]                   0L) {
[10:29:48.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.590]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.590]                   base::options(opts)
[10:29:48.590]                 }
[10:29:48.590]                 {
[10:29:48.590]                   {
[10:29:48.590]                     NULL
[10:29:48.590]                     RNGkind("Mersenne-Twister")
[10:29:48.590]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:48.590]                       inherits = FALSE)
[10:29:48.590]                   }
[10:29:48.590]                   options(future.plan = NULL)
[10:29:48.590]                   if (is.na(NA_character_)) 
[10:29:48.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.590]                     .init = FALSE)
[10:29:48.590]                 }
[10:29:48.590]             }
[10:29:48.590]         }
[10:29:48.590]     })
[10:29:48.590]     if (TRUE) {
[10:29:48.590]         base::sink(type = "output", split = FALSE)
[10:29:48.590]         if (TRUE) {
[10:29:48.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.590]         }
[10:29:48.590]         else {
[10:29:48.590]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.590]         }
[10:29:48.590]         base::close(...future.stdout)
[10:29:48.590]         ...future.stdout <- NULL
[10:29:48.590]     }
[10:29:48.590]     ...future.result$conditions <- ...future.conditions
[10:29:48.590]     ...future.result$finished <- base::Sys.time()
[10:29:48.590]     ...future.result
[10:29:48.590] }
[10:29:48.591] assign_globals() ...
[10:29:48.592] List of 5
[10:29:48.592]  $ future.call.arguments    : list()
[10:29:48.592]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.592]  $ ...future.FUN            :function (x)  
[10:29:48.592]  $ ...future.elements_ii    :List of 2
[10:29:48.592]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[10:29:48.592]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[10:29:48.592]  $ ...future.seeds_ii       : NULL
[10:29:48.592]  $ ...future.globals.maxSize: num Inf
[10:29:48.592]  - attr(*, "resolved")= logi FALSE
[10:29:48.592]  - attr(*, "total_size")= num NA
[10:29:48.592]  - attr(*, "where")=List of 5
[10:29:48.592]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.592]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.592]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.592]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.592]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.592]  - attr(*, "already-done")= logi TRUE
[10:29:48.597] - copied ‘future.call.arguments’ to environment
[10:29:48.597] - copied ‘...future.FUN’ to environment
[10:29:48.597] - copied ‘...future.elements_ii’ to environment
[10:29:48.597] - copied ‘...future.seeds_ii’ to environment
[10:29:48.597] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.598] assign_globals() ... done
[10:29:48.598] plan(): Setting new future strategy stack:
[10:29:48.598] List of future strategies:
[10:29:48.598] 1. sequential:
[10:29:48.598]    - args: function (..., envir = parent.frame())
[10:29:48.598]    - tweaked: FALSE
[10:29:48.598]    - call: NULL
[10:29:48.599] plan(): nbrOfWorkers() = 1
[10:29:48.599] plan(): Setting new future strategy stack:
[10:29:48.599] List of future strategies:
[10:29:48.599] 1. sequential:
[10:29:48.599]    - args: function (..., envir = parent.frame())
[10:29:48.599]    - tweaked: FALSE
[10:29:48.599]    - call: plan(strategy)
[10:29:48.600] plan(): nbrOfWorkers() = 1
[10:29:48.600] SequentialFuture started (and completed)
[10:29:48.600] - Launch lazy future ... done
[10:29:48.600] run() for ‘SequentialFuture’ ... done
[10:29:48.600] Created future:
[10:29:48.600] SequentialFuture:
[10:29:48.600] Label: ‘future_apply-1’
[10:29:48.600] Expression:
[10:29:48.600] {
[10:29:48.600]     do.call(function(...) {
[10:29:48.600]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.600]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.600]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.600]             on.exit(options(oopts), add = TRUE)
[10:29:48.600]         }
[10:29:48.600]         {
[10:29:48.600]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.600]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.600]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.600]             })
[10:29:48.600]         }
[10:29:48.600]     }, args = future.call.arguments)
[10:29:48.600] }
[10:29:48.600] Lazy evaluation: FALSE
[10:29:48.600] Asynchronous evaluation: FALSE
[10:29:48.600] Local evaluation: TRUE
[10:29:48.600] Environment: R_GlobalEnv
[10:29:48.600] Capture standard output: TRUE
[10:29:48.600] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.600] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.600] Packages: <none>
[10:29:48.600] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.600] Resolved: TRUE
[10:29:48.600] Value: 496 bytes of class ‘list’
[10:29:48.600] Early signaling: FALSE
[10:29:48.600] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.600] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.601] Chunk #1 of 1 ... DONE
[10:29:48.601] Launching 1 futures (chunks) ... DONE
[10:29:48.601] Resolving 1 futures (chunks) ...
[10:29:48.602] resolve() on list ...
[10:29:48.602]  recursive: 0
[10:29:48.602]  length: 1
[10:29:48.602] 
[10:29:48.602] resolved() for ‘SequentialFuture’ ...
[10:29:48.602] - state: ‘finished’
[10:29:48.602] - run: TRUE
[10:29:48.602] - result: ‘FutureResult’
[10:29:48.602] resolved() for ‘SequentialFuture’ ... done
[10:29:48.602] Future #1
[10:29:48.603] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:48.603] - nx: 1
[10:29:48.603] - relay: TRUE
[10:29:48.603] - stdout: TRUE
[10:29:48.603] - signal: TRUE
[10:29:48.603] - resignal: FALSE
[10:29:48.603] - force: TRUE
[10:29:48.603] - relayed: [n=1] FALSE
[10:29:48.603] - queued futures: [n=1] FALSE
[10:29:48.603]  - until=1
[10:29:48.603]  - relaying element #1
[10:29:48.604] - relayed: [n=1] TRUE
[10:29:48.604] - queued futures: [n=1] TRUE
[10:29:48.604] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:48.604]  length: 0 (resolved future 1)
[10:29:48.604] Relaying remaining futures
[10:29:48.604] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.604] - nx: 1
[10:29:48.604] - relay: TRUE
[10:29:48.604] - stdout: TRUE
[10:29:48.604] - signal: TRUE
[10:29:48.604] - resignal: FALSE
[10:29:48.604] - force: TRUE
[10:29:48.605] - relayed: [n=1] TRUE
[10:29:48.605] - queued futures: [n=1] TRUE
 - flush all
[10:29:48.605] - relayed: [n=1] TRUE
[10:29:48.605] - queued futures: [n=1] TRUE
[10:29:48.605] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.605] resolve() on list ... DONE
[10:29:48.605]  - Number of value chunks collected: 1
[10:29:48.605] Resolving 1 futures (chunks) ... DONE
[10:29:48.605] Reducing values from 1 chunks ...
[10:29:48.605]  - Number of values collected after concatenation: 2
[10:29:48.606]  - Number of values expected: 2
[10:29:48.606] Reducing values from 1 chunks ... DONE
[10:29:48.606] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:29:48.606] getGlobalsAndPackagesXApply() ...
[10:29:48.606]  - future.globals: TRUE
[10:29:48.606] getGlobalsAndPackages() ...
[10:29:48.606] Searching for globals...
[10:29:48.609] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:29:48.609] Searching for globals ... DONE
[10:29:48.609] Resolving globals: FALSE
[10:29:48.610] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[10:29:48.610] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[10:29:48.610] - globals: [1] ‘FUN’
[10:29:48.610] 
[10:29:48.610] getGlobalsAndPackages() ... DONE
[10:29:48.610]  - globals found/used: [n=1] ‘FUN’
[10:29:48.611]  - needed namespaces: [n=0] 
[10:29:48.611] Finding globals ... DONE
[10:29:48.611]  - use_args: TRUE
[10:29:48.611]  - Getting '...' globals ...
[10:29:48.611] resolve() on list ...
[10:29:48.611]  recursive: 0
[10:29:48.611]  length: 1
[10:29:48.611]  elements: ‘...’
[10:29:48.611]  length: 0 (resolved future 1)
[10:29:48.612] resolve() on list ... DONE
[10:29:48.612]    - '...' content: [n=0] 
[10:29:48.612] List of 1
[10:29:48.612]  $ ...: list()
[10:29:48.612]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.612]  - attr(*, "where")=List of 1
[10:29:48.612]   ..$ ...:<environment: 0x56189fc4f6f0> 
[10:29:48.612]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.612]  - attr(*, "resolved")= logi TRUE
[10:29:48.612]  - attr(*, "total_size")= num NA
[10:29:48.614]  - Getting '...' globals ... DONE
[10:29:48.614] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.614] List of 2
[10:29:48.614]  $ ...future.FUN:function (x)  
[10:29:48.614]  $ ...          : list()
[10:29:48.614]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.614]  - attr(*, "where")=List of 2
[10:29:48.614]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.614]   ..$ ...          :<environment: 0x56189fc4f6f0> 
[10:29:48.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.614]  - attr(*, "resolved")= logi FALSE
[10:29:48.614]  - attr(*, "total_size")= num 9888
[10:29:48.617] Packages to be attached in all futures: [n=0] 
[10:29:48.617] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.617] future_lapply() ...
[10:29:48.619] Number of chunks: 1
[10:29:48.620] getGlobalsAndPackagesXApply() ...
[10:29:48.620]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.620]  - use_args: TRUE
[10:29:48.620] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.620] List of 2
[10:29:48.620]  $ ...          : list()
[10:29:48.620]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.620]  $ ...future.FUN:function (x)  
[10:29:48.620]  - attr(*, "where")=List of 2
[10:29:48.620]   ..$ ...          :<environment: 0x56189fc4f6f0> 
[10:29:48.620]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:29:48.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.620]  - attr(*, "resolved")= logi FALSE
[10:29:48.620]  - attr(*, "total_size")= num NA
[10:29:48.623] Packages to be attached in all futures: [n=0] 
[10:29:48.623] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.623] Number of futures (= number of chunks): 1
[10:29:48.624] Launching 1 futures (chunks) ...
[10:29:48.624] Chunk #1 of 1 ...
[10:29:48.624]  - seeds: <none>
[10:29:48.624]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.624] getGlobalsAndPackages() ...
[10:29:48.624] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.624] Resolving globals: FALSE
[10:29:48.624] Tweak future expression to call with '...' arguments ...
[10:29:48.625] {
[10:29:48.625]     do.call(function(...) {
[10:29:48.625]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.625]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.625]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.625]             on.exit(options(oopts), add = TRUE)
[10:29:48.625]         }
[10:29:48.625]         {
[10:29:48.625]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.625]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.625]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.625]             })
[10:29:48.625]         }
[10:29:48.625]     }, args = future.call.arguments)
[10:29:48.625] }
[10:29:48.625] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.625] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.625] 
[10:29:48.625] getGlobalsAndPackages() ... DONE
[10:29:48.626] run() for ‘Future’ ...
[10:29:48.626] - state: ‘created’
[10:29:48.626] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:48.626] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.626] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:48.626]   - Field: ‘label’
[10:29:48.626]   - Field: ‘local’
[10:29:48.627]   - Field: ‘owner’
[10:29:48.627]   - Field: ‘envir’
[10:29:48.627]   - Field: ‘packages’
[10:29:48.627]   - Field: ‘gc’
[10:29:48.627]   - Field: ‘conditions’
[10:29:48.627]   - Field: ‘expr’
[10:29:48.627]   - Field: ‘uuid’
[10:29:48.627]   - Field: ‘seed’
[10:29:48.627]   - Field: ‘version’
[10:29:48.627]   - Field: ‘result’
[10:29:48.628]   - Field: ‘asynchronous’
[10:29:48.628]   - Field: ‘calls’
[10:29:48.628]   - Field: ‘globals’
[10:29:48.628]   - Field: ‘stdout’
[10:29:48.628]   - Field: ‘earlySignal’
[10:29:48.628]   - Field: ‘lazy’
[10:29:48.628]   - Field: ‘state’
[10:29:48.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:48.628] - Launch lazy future ...
[10:29:48.628] Packages needed by the future expression (n = 0): <none>
[10:29:48.629] Packages needed by future strategies (n = 0): <none>
[10:29:48.629] {
[10:29:48.629]     {
[10:29:48.629]         {
[10:29:48.629]             ...future.startTime <- base::Sys.time()
[10:29:48.629]             {
[10:29:48.629]                 {
[10:29:48.629]                   {
[10:29:48.629]                     base::local({
[10:29:48.629]                       has_future <- base::requireNamespace("future", 
[10:29:48.629]                         quietly = TRUE)
[10:29:48.629]                       if (has_future) {
[10:29:48.629]                         ns <- base::getNamespace("future")
[10:29:48.629]                         version <- ns[[".package"]][["version"]]
[10:29:48.629]                         if (is.null(version)) 
[10:29:48.629]                           version <- utils::packageVersion("future")
[10:29:48.629]                       }
[10:29:48.629]                       else {
[10:29:48.629]                         version <- NULL
[10:29:48.629]                       }
[10:29:48.629]                       if (!has_future || version < "1.8.0") {
[10:29:48.629]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.629]                           "", base::R.version$version.string), 
[10:29:48.629]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:48.629]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.629]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.629]                             "release", "version")], collapse = " "), 
[10:29:48.629]                           hostname = base::Sys.info()[["nodename"]])
[10:29:48.629]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.629]                           info)
[10:29:48.629]                         info <- base::paste(info, collapse = "; ")
[10:29:48.629]                         if (!has_future) {
[10:29:48.629]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.629]                             info)
[10:29:48.629]                         }
[10:29:48.629]                         else {
[10:29:48.629]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.629]                             info, version)
[10:29:48.629]                         }
[10:29:48.629]                         base::stop(msg)
[10:29:48.629]                       }
[10:29:48.629]                     })
[10:29:48.629]                   }
[10:29:48.629]                   ...future.strategy.old <- future::plan("list")
[10:29:48.629]                   options(future.plan = NULL)
[10:29:48.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.629]                 }
[10:29:48.629]                 ...future.workdir <- getwd()
[10:29:48.629]             }
[10:29:48.629]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.629]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.629]         }
[10:29:48.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.629]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.629]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.629]             base::names(...future.oldOptions))
[10:29:48.629]     }
[10:29:48.629]     if (FALSE) {
[10:29:48.629]     }
[10:29:48.629]     else {
[10:29:48.629]         if (TRUE) {
[10:29:48.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.629]                 open = "w")
[10:29:48.629]         }
[10:29:48.629]         else {
[10:29:48.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.629]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.629]         }
[10:29:48.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.629]             base::sink(type = "output", split = FALSE)
[10:29:48.629]             base::close(...future.stdout)
[10:29:48.629]         }, add = TRUE)
[10:29:48.629]     }
[10:29:48.629]     ...future.frame <- base::sys.nframe()
[10:29:48.629]     ...future.conditions <- base::list()
[10:29:48.629]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.629]     if (FALSE) {
[10:29:48.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.629]     }
[10:29:48.629]     ...future.result <- base::tryCatch({
[10:29:48.629]         base::withCallingHandlers({
[10:29:48.629]             ...future.value <- base::withVisible(base::local({
[10:29:48.629]                 do.call(function(...) {
[10:29:48.629]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.629]                   if (!identical(...future.globals.maxSize.org, 
[10:29:48.629]                     ...future.globals.maxSize)) {
[10:29:48.629]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.629]                     on.exit(options(oopts), add = TRUE)
[10:29:48.629]                   }
[10:29:48.629]                   {
[10:29:48.629]                     lapply(seq_along(...future.elements_ii), 
[10:29:48.629]                       FUN = function(jj) {
[10:29:48.629]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.629]                         ...future.FUN(...future.X_jj, ...)
[10:29:48.629]                       })
[10:29:48.629]                   }
[10:29:48.629]                 }, args = future.call.arguments)
[10:29:48.629]             }))
[10:29:48.629]             future::FutureResult(value = ...future.value$value, 
[10:29:48.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.629]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.629]                     ...future.globalenv.names))
[10:29:48.629]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.629]         }, condition = base::local({
[10:29:48.629]             c <- base::c
[10:29:48.629]             inherits <- base::inherits
[10:29:48.629]             invokeRestart <- base::invokeRestart
[10:29:48.629]             length <- base::length
[10:29:48.629]             list <- base::list
[10:29:48.629]             seq.int <- base::seq.int
[10:29:48.629]             signalCondition <- base::signalCondition
[10:29:48.629]             sys.calls <- base::sys.calls
[10:29:48.629]             `[[` <- base::`[[`
[10:29:48.629]             `+` <- base::`+`
[10:29:48.629]             `<<-` <- base::`<<-`
[10:29:48.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.629]                   3L)]
[10:29:48.629]             }
[10:29:48.629]             function(cond) {
[10:29:48.629]                 is_error <- inherits(cond, "error")
[10:29:48.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.629]                   NULL)
[10:29:48.629]                 if (is_error) {
[10:29:48.629]                   sessionInformation <- function() {
[10:29:48.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.629]                       search = base::search(), system = base::Sys.info())
[10:29:48.629]                   }
[10:29:48.629]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.629]                     cond$call), session = sessionInformation(), 
[10:29:48.629]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.629]                   signalCondition(cond)
[10:29:48.629]                 }
[10:29:48.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.629]                 "immediateCondition"))) {
[10:29:48.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.629]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.629]                   if (TRUE && !signal) {
[10:29:48.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.629]                     {
[10:29:48.629]                       inherits <- base::inherits
[10:29:48.629]                       invokeRestart <- base::invokeRestart
[10:29:48.629]                       is.null <- base::is.null
[10:29:48.629]                       muffled <- FALSE
[10:29:48.629]                       if (inherits(cond, "message")) {
[10:29:48.629]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.629]                         if (muffled) 
[10:29:48.629]                           invokeRestart("muffleMessage")
[10:29:48.629]                       }
[10:29:48.629]                       else if (inherits(cond, "warning")) {
[10:29:48.629]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.629]                         if (muffled) 
[10:29:48.629]                           invokeRestart("muffleWarning")
[10:29:48.629]                       }
[10:29:48.629]                       else if (inherits(cond, "condition")) {
[10:29:48.629]                         if (!is.null(pattern)) {
[10:29:48.629]                           computeRestarts <- base::computeRestarts
[10:29:48.629]                           grepl <- base::grepl
[10:29:48.629]                           restarts <- computeRestarts(cond)
[10:29:48.629]                           for (restart in restarts) {
[10:29:48.629]                             name <- restart$name
[10:29:48.629]                             if (is.null(name)) 
[10:29:48.629]                               next
[10:29:48.629]                             if (!grepl(pattern, name)) 
[10:29:48.629]                               next
[10:29:48.629]                             invokeRestart(restart)
[10:29:48.629]                             muffled <- TRUE
[10:29:48.629]                             break
[10:29:48.629]                           }
[10:29:48.629]                         }
[10:29:48.629]                       }
[10:29:48.629]                       invisible(muffled)
[10:29:48.629]                     }
[10:29:48.629]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.629]                   }
[10:29:48.629]                 }
[10:29:48.629]                 else {
[10:29:48.629]                   if (TRUE) {
[10:29:48.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.629]                     {
[10:29:48.629]                       inherits <- base::inherits
[10:29:48.629]                       invokeRestart <- base::invokeRestart
[10:29:48.629]                       is.null <- base::is.null
[10:29:48.629]                       muffled <- FALSE
[10:29:48.629]                       if (inherits(cond, "message")) {
[10:29:48.629]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.629]                         if (muffled) 
[10:29:48.629]                           invokeRestart("muffleMessage")
[10:29:48.629]                       }
[10:29:48.629]                       else if (inherits(cond, "warning")) {
[10:29:48.629]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.629]                         if (muffled) 
[10:29:48.629]                           invokeRestart("muffleWarning")
[10:29:48.629]                       }
[10:29:48.629]                       else if (inherits(cond, "condition")) {
[10:29:48.629]                         if (!is.null(pattern)) {
[10:29:48.629]                           computeRestarts <- base::computeRestarts
[10:29:48.629]                           grepl <- base::grepl
[10:29:48.629]                           restarts <- computeRestarts(cond)
[10:29:48.629]                           for (restart in restarts) {
[10:29:48.629]                             name <- restart$name
[10:29:48.629]                             if (is.null(name)) 
[10:29:48.629]                               next
[10:29:48.629]                             if (!grepl(pattern, name)) 
[10:29:48.629]                               next
[10:29:48.629]                             invokeRestart(restart)
[10:29:48.629]                             muffled <- TRUE
[10:29:48.629]                             break
[10:29:48.629]                           }
[10:29:48.629]                         }
[10:29:48.629]                       }
[10:29:48.629]                       invisible(muffled)
[10:29:48.629]                     }
[10:29:48.629]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.629]                   }
[10:29:48.629]                 }
[10:29:48.629]             }
[10:29:48.629]         }))
[10:29:48.629]     }, error = function(ex) {
[10:29:48.629]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.629]                 ...future.rng), started = ...future.startTime, 
[10:29:48.629]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.629]             version = "1.8"), class = "FutureResult")
[10:29:48.629]     }, finally = {
[10:29:48.629]         if (!identical(...future.workdir, getwd())) 
[10:29:48.629]             setwd(...future.workdir)
[10:29:48.629]         {
[10:29:48.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.629]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.629]             }
[10:29:48.629]             base::options(...future.oldOptions)
[10:29:48.629]             if (.Platform$OS.type == "windows") {
[10:29:48.629]                 old_names <- names(...future.oldEnvVars)
[10:29:48.629]                 envs <- base::Sys.getenv()
[10:29:48.629]                 names <- names(envs)
[10:29:48.629]                 common <- intersect(names, old_names)
[10:29:48.629]                 added <- setdiff(names, old_names)
[10:29:48.629]                 removed <- setdiff(old_names, names)
[10:29:48.629]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.629]                   envs[common]]
[10:29:48.629]                 NAMES <- toupper(changed)
[10:29:48.629]                 args <- list()
[10:29:48.629]                 for (kk in seq_along(NAMES)) {
[10:29:48.629]                   name <- changed[[kk]]
[10:29:48.629]                   NAME <- NAMES[[kk]]
[10:29:48.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.629]                     next
[10:29:48.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.629]                 }
[10:29:48.629]                 NAMES <- toupper(added)
[10:29:48.629]                 for (kk in seq_along(NAMES)) {
[10:29:48.629]                   name <- added[[kk]]
[10:29:48.629]                   NAME <- NAMES[[kk]]
[10:29:48.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.629]                     next
[10:29:48.629]                   args[[name]] <- ""
[10:29:48.629]                 }
[10:29:48.629]                 NAMES <- toupper(removed)
[10:29:48.629]                 for (kk in seq_along(NAMES)) {
[10:29:48.629]                   name <- removed[[kk]]
[10:29:48.629]                   NAME <- NAMES[[kk]]
[10:29:48.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.629]                     next
[10:29:48.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.629]                 }
[10:29:48.629]                 if (length(args) > 0) 
[10:29:48.629]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.629]             }
[10:29:48.629]             else {
[10:29:48.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.629]             }
[10:29:48.629]             {
[10:29:48.629]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.629]                   0L) {
[10:29:48.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.629]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.629]                   base::options(opts)
[10:29:48.629]                 }
[10:29:48.629]                 {
[10:29:48.629]                   {
[10:29:48.629]                     NULL
[10:29:48.629]                     RNGkind("Mersenne-Twister")
[10:29:48.629]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:48.629]                       inherits = FALSE)
[10:29:48.629]                   }
[10:29:48.629]                   options(future.plan = NULL)
[10:29:48.629]                   if (is.na(NA_character_)) 
[10:29:48.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.629]                     .init = FALSE)
[10:29:48.629]                 }
[10:29:48.629]             }
[10:29:48.629]         }
[10:29:48.629]     })
[10:29:48.629]     if (TRUE) {
[10:29:48.629]         base::sink(type = "output", split = FALSE)
[10:29:48.629]         if (TRUE) {
[10:29:48.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.629]         }
[10:29:48.629]         else {
[10:29:48.629]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.629]         }
[10:29:48.629]         base::close(...future.stdout)
[10:29:48.629]         ...future.stdout <- NULL
[10:29:48.629]     }
[10:29:48.629]     ...future.result$conditions <- ...future.conditions
[10:29:48.629]     ...future.result$finished <- base::Sys.time()
[10:29:48.629]     ...future.result
[10:29:48.629] }
[10:29:48.631] assign_globals() ...
[10:29:48.631] List of 5
[10:29:48.631]  $ future.call.arguments    : list()
[10:29:48.631]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.631]  $ ...future.FUN            :function (x)  
[10:29:48.631]  $ ...future.elements_ii    :List of 2
[10:29:48.631]   ..$ : int [1:2] 1 3
[10:29:48.631]   ..$ : int [1:2] 2 4
[10:29:48.631]  $ ...future.seeds_ii       : NULL
[10:29:48.631]  $ ...future.globals.maxSize: num Inf
[10:29:48.631]  - attr(*, "resolved")= logi FALSE
[10:29:48.631]  - attr(*, "total_size")= num NA
[10:29:48.631]  - attr(*, "where")=List of 5
[10:29:48.631]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.631]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.631]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.631]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.631]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.631]  - attr(*, "already-done")= logi TRUE
[10:29:48.636] - copied ‘future.call.arguments’ to environment
[10:29:48.636] - reassign environment for ‘...future.FUN’
[10:29:48.636] - copied ‘...future.FUN’ to environment
[10:29:48.636] - copied ‘...future.elements_ii’ to environment
[10:29:48.636] - copied ‘...future.seeds_ii’ to environment
[10:29:48.636] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.636] assign_globals() ... done
[10:29:48.637] plan(): Setting new future strategy stack:
[10:29:48.637] List of future strategies:
[10:29:48.637] 1. sequential:
[10:29:48.637]    - args: function (..., envir = parent.frame())
[10:29:48.637]    - tweaked: FALSE
[10:29:48.637]    - call: NULL
[10:29:48.637] plan(): nbrOfWorkers() = 1
[10:29:48.638] plan(): Setting new future strategy stack:
[10:29:48.638] List of future strategies:
[10:29:48.638] 1. sequential:
[10:29:48.638]    - args: function (..., envir = parent.frame())
[10:29:48.638]    - tweaked: FALSE
[10:29:48.638]    - call: plan(strategy)
[10:29:48.638] plan(): nbrOfWorkers() = 1
[10:29:48.638] SequentialFuture started (and completed)
[10:29:48.639] - Launch lazy future ... done
[10:29:48.639] run() for ‘SequentialFuture’ ... done
[10:29:48.639] Created future:
[10:29:48.639] SequentialFuture:
[10:29:48.639] Label: ‘future_apply-1’
[10:29:48.639] Expression:
[10:29:48.639] {
[10:29:48.639]     do.call(function(...) {
[10:29:48.639]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.639]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.639]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.639]             on.exit(options(oopts), add = TRUE)
[10:29:48.639]         }
[10:29:48.639]         {
[10:29:48.639]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.639]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.639]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.639]             })
[10:29:48.639]         }
[10:29:48.639]     }, args = future.call.arguments)
[10:29:48.639] }
[10:29:48.639] Lazy evaluation: FALSE
[10:29:48.639] Asynchronous evaluation: FALSE
[10:29:48.639] Local evaluation: TRUE
[10:29:48.639] Environment: R_GlobalEnv
[10:29:48.639] Capture standard output: TRUE
[10:29:48.639] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.639] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.639] Packages: <none>
[10:29:48.639] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.639] Resolved: TRUE
[10:29:48.639] Value: 400 bytes of class ‘list’
[10:29:48.639] Early signaling: FALSE
[10:29:48.639] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.639] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.640] Chunk #1 of 1 ... DONE
[10:29:48.640] Launching 1 futures (chunks) ... DONE
[10:29:48.640] Resolving 1 futures (chunks) ...
[10:29:48.640] resolve() on list ...
[10:29:48.640]  recursive: 0
[10:29:48.640]  length: 1
[10:29:48.640] 
[10:29:48.641] resolved() for ‘SequentialFuture’ ...
[10:29:48.641] - state: ‘finished’
[10:29:48.641] - run: TRUE
[10:29:48.641] - result: ‘FutureResult’
[10:29:48.641] resolved() for ‘SequentialFuture’ ... done
[10:29:48.641] Future #1
[10:29:48.641] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:48.641] - nx: 1
[10:29:48.641] - relay: TRUE
[10:29:48.641] - stdout: TRUE
[10:29:48.642] - signal: TRUE
[10:29:48.642] - resignal: FALSE
[10:29:48.642] - force: TRUE
[10:29:48.642] - relayed: [n=1] FALSE
[10:29:48.642] - queued futures: [n=1] FALSE
[10:29:48.642]  - until=1
[10:29:48.642]  - relaying element #1
[10:29:48.642] - relayed: [n=1] TRUE
[10:29:48.642] - queued futures: [n=1] TRUE
[10:29:48.642] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:48.642]  length: 0 (resolved future 1)
[10:29:48.643] Relaying remaining futures
[10:29:48.643] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.643] - nx: 1
[10:29:48.643] - relay: TRUE
[10:29:48.643] - stdout: TRUE
[10:29:48.644] - signal: TRUE
[10:29:48.644] - resignal: FALSE
[10:29:48.645] - force: TRUE
[10:29:48.645] - relayed: [n=1] TRUE
[10:29:48.645] - queued futures: [n=1] TRUE
 - flush all
[10:29:48.645] - relayed: [n=1] TRUE
[10:29:48.645] - queued futures: [n=1] TRUE
[10:29:48.645] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.645] resolve() on list ... DONE
[10:29:48.645]  - Number of value chunks collected: 1
[10:29:48.646] Resolving 1 futures (chunks) ... DONE
[10:29:48.646] Reducing values from 1 chunks ...
[10:29:48.646]  - Number of values collected after concatenation: 2
[10:29:48.646]  - Number of values expected: 2
[10:29:48.646] Reducing values from 1 chunks ... DONE
[10:29:48.646] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:29:48.646] getGlobalsAndPackagesXApply() ...
[10:29:48.647]  - future.globals: TRUE
[10:29:48.647] getGlobalsAndPackages() ...
[10:29:48.647] Searching for globals...
[10:29:48.650] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:29:48.650] Searching for globals ... DONE
[10:29:48.650] Resolving globals: FALSE
[10:29:48.650] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[10:29:48.651] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[10:29:48.651] - globals: [1] ‘FUN’
[10:29:48.651] 
[10:29:48.651] getGlobalsAndPackages() ... DONE
[10:29:48.651]  - globals found/used: [n=1] ‘FUN’
[10:29:48.651]  - needed namespaces: [n=0] 
[10:29:48.651] Finding globals ... DONE
[10:29:48.651]  - use_args: TRUE
[10:29:48.652]  - Getting '...' globals ...
[10:29:48.652] resolve() on list ...
[10:29:48.652]  recursive: 0
[10:29:48.652]  length: 1
[10:29:48.652]  elements: ‘...’
[10:29:48.652]  length: 0 (resolved future 1)
[10:29:48.652] resolve() on list ... DONE
[10:29:48.652]    - '...' content: [n=0] 
[10:29:48.653] List of 1
[10:29:48.653]  $ ...: list()
[10:29:48.653]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.653]  - attr(*, "where")=List of 1
[10:29:48.653]   ..$ ...:<environment: 0x5618a13b0da8> 
[10:29:48.653]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.653]  - attr(*, "resolved")= logi TRUE
[10:29:48.653]  - attr(*, "total_size")= num NA
[10:29:48.655]  - Getting '...' globals ... DONE
[10:29:48.655] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.655] List of 2
[10:29:48.655]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:29:48.655]  $ ...          : list()
[10:29:48.655]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.655]  - attr(*, "where")=List of 2
[10:29:48.655]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.655]   ..$ ...          :<environment: 0x5618a13b0da8> 
[10:29:48.655]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.655]  - attr(*, "resolved")= logi FALSE
[10:29:48.655]  - attr(*, "total_size")= num 36296
[10:29:48.658] Packages to be attached in all futures: [n=0] 
[10:29:48.658] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.658] future_lapply() ...
[10:29:48.660] Generating random seeds ...
[10:29:48.660] Generating random seed streams for 2 elements ...
[10:29:48.661] Generating random seed streams for 2 elements ... DONE
[10:29:48.661] Generating random seeds ... DONE
[10:29:48.661] Will set RNG state on exit: 10407, -1769228967, 36920537, 1572730823, 1745592836, 237084171, 2134421823
[10:29:48.661] Number of chunks: 1
[10:29:48.661] getGlobalsAndPackagesXApply() ...
[10:29:48.661]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.661]  - use_args: TRUE
[10:29:48.662] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.662] List of 2
[10:29:48.662]  $ ...          : list()
[10:29:48.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.662]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:29:48.662]  - attr(*, "where")=List of 2
[10:29:48.662]   ..$ ...          :<environment: 0x5618a13b0da8> 
[10:29:48.662]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:48.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.662]  - attr(*, "resolved")= logi FALSE
[10:29:48.662]  - attr(*, "total_size")= num NA
[10:29:48.665] Packages to be attached in all futures: [n=0] 
[10:29:48.665] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.665] Number of futures (= number of chunks): 1
[10:29:48.665] Launching 1 futures (chunks) ...
[10:29:48.666] Chunk #1 of 1 ...
[10:29:48.666]  - seeds: [2] <seeds>
[10:29:48.667]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.667] getGlobalsAndPackages() ...
[10:29:48.667] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.667] Resolving globals: FALSE
[10:29:48.667] Tweak future expression to call with '...' arguments ...
[10:29:48.668] {
[10:29:48.668]     do.call(function(...) {
[10:29:48.668]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.668]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.668]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.668]             on.exit(options(oopts), add = TRUE)
[10:29:48.668]         }
[10:29:48.668]         {
[10:29:48.668]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.668]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.668]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:48.668]                   envir = globalenv(), inherits = FALSE)
[10:29:48.668]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.668]             })
[10:29:48.668]         }
[10:29:48.668]     }, args = future.call.arguments)
[10:29:48.668] }
[10:29:48.668] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.668] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.669] 
[10:29:48.669] getGlobalsAndPackages() ... DONE
[10:29:48.669] run() for ‘Future’ ...
[10:29:48.669] - state: ‘created’
[10:29:48.669] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:48.670] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.670] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:48.670]   - Field: ‘label’
[10:29:48.670]   - Field: ‘local’
[10:29:48.670]   - Field: ‘owner’
[10:29:48.670]   - Field: ‘envir’
[10:29:48.670]   - Field: ‘packages’
[10:29:48.670]   - Field: ‘gc’
[10:29:48.670]   - Field: ‘conditions’
[10:29:48.670]   - Field: ‘expr’
[10:29:48.671]   - Field: ‘uuid’
[10:29:48.671]   - Field: ‘seed’
[10:29:48.671]   - Field: ‘version’
[10:29:48.671]   - Field: ‘result’
[10:29:48.671]   - Field: ‘asynchronous’
[10:29:48.671]   - Field: ‘calls’
[10:29:48.671]   - Field: ‘globals’
[10:29:48.671]   - Field: ‘stdout’
[10:29:48.671]   - Field: ‘earlySignal’
[10:29:48.671]   - Field: ‘lazy’
[10:29:48.671]   - Field: ‘state’
[10:29:48.672] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:48.672] - Launch lazy future ...
[10:29:48.672] Packages needed by the future expression (n = 0): <none>
[10:29:48.672] Packages needed by future strategies (n = 0): <none>
[10:29:48.672] {
[10:29:48.672]     {
[10:29:48.672]         {
[10:29:48.672]             ...future.startTime <- base::Sys.time()
[10:29:48.672]             {
[10:29:48.672]                 {
[10:29:48.672]                   {
[10:29:48.672]                     base::local({
[10:29:48.672]                       has_future <- base::requireNamespace("future", 
[10:29:48.672]                         quietly = TRUE)
[10:29:48.672]                       if (has_future) {
[10:29:48.672]                         ns <- base::getNamespace("future")
[10:29:48.672]                         version <- ns[[".package"]][["version"]]
[10:29:48.672]                         if (is.null(version)) 
[10:29:48.672]                           version <- utils::packageVersion("future")
[10:29:48.672]                       }
[10:29:48.672]                       else {
[10:29:48.672]                         version <- NULL
[10:29:48.672]                       }
[10:29:48.672]                       if (!has_future || version < "1.8.0") {
[10:29:48.672]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.672]                           "", base::R.version$version.string), 
[10:29:48.672]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:48.672]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.672]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.672]                             "release", "version")], collapse = " "), 
[10:29:48.672]                           hostname = base::Sys.info()[["nodename"]])
[10:29:48.672]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.672]                           info)
[10:29:48.672]                         info <- base::paste(info, collapse = "; ")
[10:29:48.672]                         if (!has_future) {
[10:29:48.672]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.672]                             info)
[10:29:48.672]                         }
[10:29:48.672]                         else {
[10:29:48.672]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.672]                             info, version)
[10:29:48.672]                         }
[10:29:48.672]                         base::stop(msg)
[10:29:48.672]                       }
[10:29:48.672]                     })
[10:29:48.672]                   }
[10:29:48.672]                   ...future.strategy.old <- future::plan("list")
[10:29:48.672]                   options(future.plan = NULL)
[10:29:48.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.672]                 }
[10:29:48.672]                 ...future.workdir <- getwd()
[10:29:48.672]             }
[10:29:48.672]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.672]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.672]         }
[10:29:48.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.672]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.672]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.672]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.672]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.672]             base::names(...future.oldOptions))
[10:29:48.672]     }
[10:29:48.672]     if (FALSE) {
[10:29:48.672]     }
[10:29:48.672]     else {
[10:29:48.672]         if (TRUE) {
[10:29:48.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.672]                 open = "w")
[10:29:48.672]         }
[10:29:48.672]         else {
[10:29:48.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.672]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.672]         }
[10:29:48.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.672]             base::sink(type = "output", split = FALSE)
[10:29:48.672]             base::close(...future.stdout)
[10:29:48.672]         }, add = TRUE)
[10:29:48.672]     }
[10:29:48.672]     ...future.frame <- base::sys.nframe()
[10:29:48.672]     ...future.conditions <- base::list()
[10:29:48.672]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.672]     if (FALSE) {
[10:29:48.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.672]     }
[10:29:48.672]     ...future.result <- base::tryCatch({
[10:29:48.672]         base::withCallingHandlers({
[10:29:48.672]             ...future.value <- base::withVisible(base::local({
[10:29:48.672]                 do.call(function(...) {
[10:29:48.672]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.672]                   if (!identical(...future.globals.maxSize.org, 
[10:29:48.672]                     ...future.globals.maxSize)) {
[10:29:48.672]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.672]                     on.exit(options(oopts), add = TRUE)
[10:29:48.672]                   }
[10:29:48.672]                   {
[10:29:48.672]                     lapply(seq_along(...future.elements_ii), 
[10:29:48.672]                       FUN = function(jj) {
[10:29:48.672]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.672]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:48.672]                           envir = globalenv(), inherits = FALSE)
[10:29:48.672]                         ...future.FUN(...future.X_jj, ...)
[10:29:48.672]                       })
[10:29:48.672]                   }
[10:29:48.672]                 }, args = future.call.arguments)
[10:29:48.672]             }))
[10:29:48.672]             future::FutureResult(value = ...future.value$value, 
[10:29:48.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.672]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.672]                     ...future.globalenv.names))
[10:29:48.672]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.672]         }, condition = base::local({
[10:29:48.672]             c <- base::c
[10:29:48.672]             inherits <- base::inherits
[10:29:48.672]             invokeRestart <- base::invokeRestart
[10:29:48.672]             length <- base::length
[10:29:48.672]             list <- base::list
[10:29:48.672]             seq.int <- base::seq.int
[10:29:48.672]             signalCondition <- base::signalCondition
[10:29:48.672]             sys.calls <- base::sys.calls
[10:29:48.672]             `[[` <- base::`[[`
[10:29:48.672]             `+` <- base::`+`
[10:29:48.672]             `<<-` <- base::`<<-`
[10:29:48.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.672]                   3L)]
[10:29:48.672]             }
[10:29:48.672]             function(cond) {
[10:29:48.672]                 is_error <- inherits(cond, "error")
[10:29:48.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.672]                   NULL)
[10:29:48.672]                 if (is_error) {
[10:29:48.672]                   sessionInformation <- function() {
[10:29:48.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.672]                       search = base::search(), system = base::Sys.info())
[10:29:48.672]                   }
[10:29:48.672]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.672]                     cond$call), session = sessionInformation(), 
[10:29:48.672]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.672]                   signalCondition(cond)
[10:29:48.672]                 }
[10:29:48.672]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[10:29:48.672]                   signal <- TRUE && inherits(cond, character(0))
[10:29:48.672]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.672]                   if (TRUE && !signal) {
[10:29:48.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.672]                     {
[10:29:48.672]                       inherits <- base::inherits
[10:29:48.672]                       invokeRestart <- base::invokeRestart
[10:29:48.672]                       is.null <- base::is.null
[10:29:48.672]                       muffled <- FALSE
[10:29:48.672]                       if (inherits(cond, "message")) {
[10:29:48.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.672]                         if (muffled) 
[10:29:48.672]                           invokeRestart("muffleMessage")
[10:29:48.672]                       }
[10:29:48.672]                       else if (inherits(cond, "warning")) {
[10:29:48.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.672]                         if (muffled) 
[10:29:48.672]                           invokeRestart("muffleWarning")
[10:29:48.672]                       }
[10:29:48.672]                       else if (inherits(cond, "condition")) {
[10:29:48.672]                         if (!is.null(pattern)) {
[10:29:48.672]                           computeRestarts <- base::computeRestarts
[10:29:48.672]                           grepl <- base::grepl
[10:29:48.672]                           restarts <- computeRestarts(cond)
[10:29:48.672]                           for (restart in restarts) {
[10:29:48.672]                             name <- restart$name
[10:29:48.672]                             if (is.null(name)) 
[10:29:48.672]                               next
[10:29:48.672]                             if (!grepl(pattern, name)) 
[10:29:48.672]                               next
[10:29:48.672]                             invokeRestart(restart)
[10:29:48.672]                             muffled <- TRUE
[10:29:48.672]                             break
[10:29:48.672]                           }
[10:29:48.672]                         }
[10:29:48.672]                       }
[10:29:48.672]                       invisible(muffled)
[10:29:48.672]                     }
[10:29:48.672]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.672]                   }
[10:29:48.672]                 }
[10:29:48.672]                 else {
[10:29:48.672]                   if (FALSE) {
[10:29:48.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.672]                     {
[10:29:48.672]                       inherits <- base::inherits
[10:29:48.672]                       invokeRestart <- base::invokeRestart
[10:29:48.672]                       is.null <- base::is.null
[10:29:48.672]                       muffled <- FALSE
[10:29:48.672]                       if (inherits(cond, "message")) {
[10:29:48.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.672]                         if (muffled) 
[10:29:48.672]                           invokeRestart("muffleMessage")
[10:29:48.672]                       }
[10:29:48.672]                       else if (inherits(cond, "warning")) {
[10:29:48.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.672]                         if (muffled) 
[10:29:48.672]                           invokeRestart("muffleWarning")
[10:29:48.672]                       }
[10:29:48.672]                       else if (inherits(cond, "condition")) {
[10:29:48.672]                         if (!is.null(pattern)) {
[10:29:48.672]                           computeRestarts <- base::computeRestarts
[10:29:48.672]                           grepl <- base::grepl
[10:29:48.672]                           restarts <- computeRestarts(cond)
[10:29:48.672]                           for (restart in restarts) {
[10:29:48.672]                             name <- restart$name
[10:29:48.672]                             if (is.null(name)) 
[10:29:48.672]                               next
[10:29:48.672]                             if (!grepl(pattern, name)) 
[10:29:48.672]                               next
[10:29:48.672]                             invokeRestart(restart)
[10:29:48.672]                             muffled <- TRUE
[10:29:48.672]                             break
[10:29:48.672]                           }
[10:29:48.672]                         }
[10:29:48.672]                       }
[10:29:48.672]                       invisible(muffled)
[10:29:48.672]                     }
[10:29:48.672]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.672]                   }
[10:29:48.672]                 }
[10:29:48.672]             }
[10:29:48.672]         }))
[10:29:48.672]     }, error = function(ex) {
[10:29:48.672]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.672]                 ...future.rng), started = ...future.startTime, 
[10:29:48.672]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.672]             version = "1.8"), class = "FutureResult")
[10:29:48.672]     }, finally = {
[10:29:48.672]         if (!identical(...future.workdir, getwd())) 
[10:29:48.672]             setwd(...future.workdir)
[10:29:48.672]         {
[10:29:48.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.672]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.672]             }
[10:29:48.672]             base::options(...future.oldOptions)
[10:29:48.672]             if (.Platform$OS.type == "windows") {
[10:29:48.672]                 old_names <- names(...future.oldEnvVars)
[10:29:48.672]                 envs <- base::Sys.getenv()
[10:29:48.672]                 names <- names(envs)
[10:29:48.672]                 common <- intersect(names, old_names)
[10:29:48.672]                 added <- setdiff(names, old_names)
[10:29:48.672]                 removed <- setdiff(old_names, names)
[10:29:48.672]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.672]                   envs[common]]
[10:29:48.672]                 NAMES <- toupper(changed)
[10:29:48.672]                 args <- list()
[10:29:48.672]                 for (kk in seq_along(NAMES)) {
[10:29:48.672]                   name <- changed[[kk]]
[10:29:48.672]                   NAME <- NAMES[[kk]]
[10:29:48.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.672]                     next
[10:29:48.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.672]                 }
[10:29:48.672]                 NAMES <- toupper(added)
[10:29:48.672]                 for (kk in seq_along(NAMES)) {
[10:29:48.672]                   name <- added[[kk]]
[10:29:48.672]                   NAME <- NAMES[[kk]]
[10:29:48.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.672]                     next
[10:29:48.672]                   args[[name]] <- ""
[10:29:48.672]                 }
[10:29:48.672]                 NAMES <- toupper(removed)
[10:29:48.672]                 for (kk in seq_along(NAMES)) {
[10:29:48.672]                   name <- removed[[kk]]
[10:29:48.672]                   NAME <- NAMES[[kk]]
[10:29:48.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.672]                     next
[10:29:48.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.672]                 }
[10:29:48.672]                 if (length(args) > 0) 
[10:29:48.672]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.672]             }
[10:29:48.672]             else {
[10:29:48.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.672]             }
[10:29:48.672]             {
[10:29:48.672]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.672]                   0L) {
[10:29:48.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.672]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.672]                   base::options(opts)
[10:29:48.672]                 }
[10:29:48.672]                 {
[10:29:48.672]                   {
[10:29:48.672]                     base::assign(".Random.seed", c(10407L, -1769228967L, 
[10:29:48.672]                     36920537L, 1572730823L, 1745592836L, 237084171L, 
[10:29:48.672]                     2134421823L), envir = base::globalenv(), 
[10:29:48.672]                       inherits = FALSE)
[10:29:48.672]                     NULL
[10:29:48.672]                   }
[10:29:48.672]                   options(future.plan = NULL)
[10:29:48.672]                   if (is.na(NA_character_)) 
[10:29:48.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.672]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.672]                     .init = FALSE)
[10:29:48.672]                 }
[10:29:48.672]             }
[10:29:48.672]         }
[10:29:48.672]     })
[10:29:48.672]     if (TRUE) {
[10:29:48.672]         base::sink(type = "output", split = FALSE)
[10:29:48.672]         if (TRUE) {
[10:29:48.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.672]         }
[10:29:48.672]         else {
[10:29:48.672]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.672]         }
[10:29:48.672]         base::close(...future.stdout)
[10:29:48.672]         ...future.stdout <- NULL
[10:29:48.672]     }
[10:29:48.672]     ...future.result$conditions <- ...future.conditions
[10:29:48.672]     ...future.result$finished <- base::Sys.time()
[10:29:48.672]     ...future.result
[10:29:48.672] }
[10:29:48.674] assign_globals() ...
[10:29:48.674] List of 5
[10:29:48.674]  $ future.call.arguments    : list()
[10:29:48.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.674]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:29:48.674]  $ ...future.elements_ii    :List of 2
[10:29:48.674]   ..$ : int [1:2] 1 3
[10:29:48.674]   ..$ : int [1:2] 2 4
[10:29:48.674]  $ ...future.seeds_ii       :List of 2
[10:29:48.674]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:29:48.674]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:29:48.674]  $ ...future.globals.maxSize: num Inf
[10:29:48.674]  - attr(*, "resolved")= logi FALSE
[10:29:48.674]  - attr(*, "total_size")= num NA
[10:29:48.674]  - attr(*, "where")=List of 5
[10:29:48.674]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.674]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.674]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.674]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.674]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.674]  - attr(*, "already-done")= logi TRUE
[10:29:48.680] - copied ‘future.call.arguments’ to environment
[10:29:48.680] - copied ‘...future.FUN’ to environment
[10:29:48.680] - copied ‘...future.elements_ii’ to environment
[10:29:48.680] - copied ‘...future.seeds_ii’ to environment
[10:29:48.680] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.680] assign_globals() ... done
[10:29:48.681] plan(): Setting new future strategy stack:
[10:29:48.681] List of future strategies:
[10:29:48.681] 1. sequential:
[10:29:48.681]    - args: function (..., envir = parent.frame())
[10:29:48.681]    - tweaked: FALSE
[10:29:48.681]    - call: NULL
[10:29:48.681] plan(): nbrOfWorkers() = 1
[10:29:48.682] plan(): Setting new future strategy stack:
[10:29:48.682] List of future strategies:
[10:29:48.682] 1. sequential:
[10:29:48.682]    - args: function (..., envir = parent.frame())
[10:29:48.682]    - tweaked: FALSE
[10:29:48.682]    - call: plan(strategy)
[10:29:48.682] plan(): nbrOfWorkers() = 1
[10:29:48.682] SequentialFuture started (and completed)
[10:29:48.683] - Launch lazy future ... done
[10:29:48.683] run() for ‘SequentialFuture’ ... done
[10:29:48.683] Created future:
[10:29:48.683] SequentialFuture:
[10:29:48.683] Label: ‘future_apply-1’
[10:29:48.683] Expression:
[10:29:48.683] {
[10:29:48.683]     do.call(function(...) {
[10:29:48.683]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.683]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.683]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.683]             on.exit(options(oopts), add = TRUE)
[10:29:48.683]         }
[10:29:48.683]         {
[10:29:48.683]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.683]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.683]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:48.683]                   envir = globalenv(), inherits = FALSE)
[10:29:48.683]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.683]             })
[10:29:48.683]         }
[10:29:48.683]     }, args = future.call.arguments)
[10:29:48.683] }
[10:29:48.683] Lazy evaluation: FALSE
[10:29:48.683] Asynchronous evaluation: FALSE
[10:29:48.683] Local evaluation: TRUE
[10:29:48.683] Environment: R_GlobalEnv
[10:29:48.683] Capture standard output: TRUE
[10:29:48.683] Capture condition classes: <none>
[10:29:48.683] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.683] Packages: <none>
[10:29:48.683] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:29:48.683] Resolved: TRUE
[10:29:48.683] Value: 112 bytes of class ‘list’
[10:29:48.683] Early signaling: FALSE
[10:29:48.683] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.683] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:48.684] Chunk #1 of 1 ... DONE
[10:29:48.684] Launching 1 futures (chunks) ... DONE
[10:29:48.684] Resolving 1 futures (chunks) ...
[10:29:48.684] resolve() on list ...
[10:29:48.684]  recursive: 0
[10:29:48.684]  length: 1
[10:29:48.684] 
[10:29:48.684] resolved() for ‘SequentialFuture’ ...
[10:29:48.685] - state: ‘finished’
[10:29:48.685] - run: TRUE
[10:29:48.685] - result: ‘FutureResult’
[10:29:48.685] resolved() for ‘SequentialFuture’ ... done
[10:29:48.685] Future #1
[10:29:48.685] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:48.685] - nx: 1
[10:29:48.685] - relay: TRUE
[10:29:48.685] - stdout: TRUE
[10:29:48.685] - signal: TRUE
[10:29:48.685] - resignal: FALSE
[10:29:48.686] - force: TRUE
[10:29:48.686] - relayed: [n=1] FALSE
[10:29:48.686] - queued futures: [n=1] FALSE
[10:29:48.686]  - until=1
[10:29:48.686]  - relaying element #1
[10:29:48.686] - relayed: [n=1] TRUE
[10:29:48.686] - queued futures: [n=1] TRUE
[10:29:48.686] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:48.686]  length: 0 (resolved future 1)
[10:29:48.687] Relaying remaining futures
[10:29:48.687] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.687] - nx: 1
[10:29:48.687] - relay: TRUE
[10:29:48.687] - stdout: TRUE
[10:29:48.687] - signal: TRUE
[10:29:48.687] - resignal: FALSE
[10:29:48.687] - force: TRUE
[10:29:48.687] - relayed: [n=1] TRUE
[10:29:48.687] - queued futures: [n=1] TRUE
 - flush all
[10:29:48.687] - relayed: [n=1] TRUE
[10:29:48.687] - queued futures: [n=1] TRUE
[10:29:48.688] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.688] resolve() on list ... DONE
[10:29:48.688]  - Number of value chunks collected: 1
[10:29:48.688] Resolving 1 futures (chunks) ... DONE
[10:29:48.688] Reducing values from 1 chunks ...
[10:29:48.688]  - Number of values collected after concatenation: 2
[10:29:48.688]  - Number of values expected: 2
[10:29:48.688] Reducing values from 1 chunks ... DONE
[10:29:48.688] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:29:48.689] plan(): Setting new future strategy stack:
[10:29:48.689] List of future strategies:
[10:29:48.689] 1. sequential:
[10:29:48.689]    - args: function (..., envir = parent.frame())
[10:29:48.689]    - tweaked: FALSE
[10:29:48.689]    - call: plan(sequential)
[10:29:48.689] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:29:48.689] plan(): Setting new future strategy stack:
[10:29:48.690] List of future strategies:
[10:29:48.690] 1. multicore:
[10:29:48.690]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:48.690]    - tweaked: FALSE
[10:29:48.690]    - call: plan(strategy)
[10:29:48.695] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[10:29:48.695] getGlobalsAndPackagesXApply() ...
[10:29:48.695]  - future.globals: TRUE
[10:29:48.695] getGlobalsAndPackages() ...
[10:29:48.696] Searching for globals...
[10:29:48.730] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:29:48.730] Searching for globals ... DONE
[10:29:48.730] Resolving globals: FALSE
[10:29:48.732] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:29:48.732] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:29:48.732] - globals: [1] ‘FUN’
[10:29:48.732] 
[10:29:48.732] getGlobalsAndPackages() ... DONE
[10:29:48.732]  - globals found/used: [n=1] ‘FUN’
[10:29:48.732]  - needed namespaces: [n=0] 
[10:29:48.733] Finding globals ... DONE
[10:29:48.733]  - use_args: TRUE
[10:29:48.733]  - Getting '...' globals ...
[10:29:48.733] resolve() on list ...
[10:29:48.733]  recursive: 0
[10:29:48.733]  length: 1
[10:29:48.733]  elements: ‘...’
[10:29:48.734]  length: 0 (resolved future 1)
[10:29:48.734] resolve() on list ... DONE
[10:29:48.734]    - '...' content: [n=0] 
[10:29:48.734] List of 1
[10:29:48.734]  $ ...: list()
[10:29:48.734]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.734]  - attr(*, "where")=List of 1
[10:29:48.734]   ..$ ...:<environment: 0x5618a23af658> 
[10:29:48.734]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.734]  - attr(*, "resolved")= logi TRUE
[10:29:48.734]  - attr(*, "total_size")= num NA
[10:29:48.736]  - Getting '...' globals ... DONE
[10:29:48.736] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.737] List of 2
[10:29:48.737]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.737]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.737]  $ ...          : list()
[10:29:48.737]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.737]  - attr(*, "where")=List of 2
[10:29:48.737]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.737]   ..$ ...          :<environment: 0x5618a23af658> 
[10:29:48.737]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.737]  - attr(*, "resolved")= logi FALSE
[10:29:48.737]  - attr(*, "total_size")= num 354224
[10:29:48.739] Packages to be attached in all futures: [n=0] 
[10:29:48.739] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.743] future_lapply() ...
[10:29:48.778] Number of chunks: 2
[10:29:48.779] getGlobalsAndPackagesXApply() ...
[10:29:48.779]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.779]  - use_args: TRUE
[10:29:48.779] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.779] List of 2
[10:29:48.779]  $ ...          : list()
[10:29:48.779]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.779]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.779]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.779]  - attr(*, "where")=List of 2
[10:29:48.779]   ..$ ...          :<environment: 0x5618a23af658> 
[10:29:48.779]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:48.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.779]  - attr(*, "resolved")= logi FALSE
[10:29:48.779]  - attr(*, "total_size")= num NA
[10:29:48.782] Packages to be attached in all futures: [n=0] 
[10:29:48.782] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.783] Number of futures (= number of chunks): 2
[10:29:48.783] Launching 2 futures (chunks) ...
[10:29:48.783] Chunk #1 of 2 ...
[10:29:48.783]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:48.783]  - seeds: <none>
[10:29:48.783]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.783] getGlobalsAndPackages() ...
[10:29:48.783] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.783] Resolving globals: FALSE
[10:29:48.784] Tweak future expression to call with '...' arguments ...
[10:29:48.784] {
[10:29:48.784]     do.call(function(...) {
[10:29:48.784]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.784]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.784]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.784]             on.exit(options(oopts), add = TRUE)
[10:29:48.784]         }
[10:29:48.784]         {
[10:29:48.784]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.784]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.784]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.784]             })
[10:29:48.784]         }
[10:29:48.784]     }, args = future.call.arguments)
[10:29:48.784] }
[10:29:48.784] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.784] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.784] 
[10:29:48.785] getGlobalsAndPackages() ... DONE
[10:29:48.785] run() for ‘Future’ ...
[10:29:48.785] - state: ‘created’
[10:29:48.785] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:48.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:48.789] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:48.789]   - Field: ‘label’
[10:29:48.789]   - Field: ‘local’
[10:29:48.789]   - Field: ‘owner’
[10:29:48.789]   - Field: ‘envir’
[10:29:48.789]   - Field: ‘workers’
[10:29:48.789]   - Field: ‘packages’
[10:29:48.789]   - Field: ‘gc’
[10:29:48.789]   - Field: ‘job’
[10:29:48.789]   - Field: ‘conditions’
[10:29:48.790]   - Field: ‘expr’
[10:29:48.790]   - Field: ‘uuid’
[10:29:48.790]   - Field: ‘seed’
[10:29:48.790]   - Field: ‘version’
[10:29:48.790]   - Field: ‘result’
[10:29:48.790]   - Field: ‘asynchronous’
[10:29:48.790]   - Field: ‘calls’
[10:29:48.790]   - Field: ‘globals’
[10:29:48.790]   - Field: ‘stdout’
[10:29:48.790]   - Field: ‘earlySignal’
[10:29:48.790]   - Field: ‘lazy’
[10:29:48.790]   - Field: ‘state’
[10:29:48.791] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:48.791] - Launch lazy future ...
[10:29:48.792] Packages needed by the future expression (n = 0): <none>
[10:29:48.792] Packages needed by future strategies (n = 0): <none>
[10:29:48.792] {
[10:29:48.792]     {
[10:29:48.792]         {
[10:29:48.792]             ...future.startTime <- base::Sys.time()
[10:29:48.792]             {
[10:29:48.792]                 {
[10:29:48.792]                   {
[10:29:48.792]                     {
[10:29:48.792]                       base::local({
[10:29:48.792]                         has_future <- base::requireNamespace("future", 
[10:29:48.792]                           quietly = TRUE)
[10:29:48.792]                         if (has_future) {
[10:29:48.792]                           ns <- base::getNamespace("future")
[10:29:48.792]                           version <- ns[[".package"]][["version"]]
[10:29:48.792]                           if (is.null(version)) 
[10:29:48.792]                             version <- utils::packageVersion("future")
[10:29:48.792]                         }
[10:29:48.792]                         else {
[10:29:48.792]                           version <- NULL
[10:29:48.792]                         }
[10:29:48.792]                         if (!has_future || version < "1.8.0") {
[10:29:48.792]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.792]                             "", base::R.version$version.string), 
[10:29:48.792]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:48.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.792]                               "release", "version")], collapse = " "), 
[10:29:48.792]                             hostname = base::Sys.info()[["nodename"]])
[10:29:48.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.792]                             info)
[10:29:48.792]                           info <- base::paste(info, collapse = "; ")
[10:29:48.792]                           if (!has_future) {
[10:29:48.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.792]                               info)
[10:29:48.792]                           }
[10:29:48.792]                           else {
[10:29:48.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.792]                               info, version)
[10:29:48.792]                           }
[10:29:48.792]                           base::stop(msg)
[10:29:48.792]                         }
[10:29:48.792]                       })
[10:29:48.792]                     }
[10:29:48.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:48.792]                     base::options(mc.cores = 1L)
[10:29:48.792]                   }
[10:29:48.792]                   ...future.strategy.old <- future::plan("list")
[10:29:48.792]                   options(future.plan = NULL)
[10:29:48.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.792]                 }
[10:29:48.792]                 ...future.workdir <- getwd()
[10:29:48.792]             }
[10:29:48.792]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.792]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.792]         }
[10:29:48.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.792]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.792]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.792]             base::names(...future.oldOptions))
[10:29:48.792]     }
[10:29:48.792]     if (FALSE) {
[10:29:48.792]     }
[10:29:48.792]     else {
[10:29:48.792]         if (TRUE) {
[10:29:48.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.792]                 open = "w")
[10:29:48.792]         }
[10:29:48.792]         else {
[10:29:48.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.792]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.792]         }
[10:29:48.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.792]             base::sink(type = "output", split = FALSE)
[10:29:48.792]             base::close(...future.stdout)
[10:29:48.792]         }, add = TRUE)
[10:29:48.792]     }
[10:29:48.792]     ...future.frame <- base::sys.nframe()
[10:29:48.792]     ...future.conditions <- base::list()
[10:29:48.792]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.792]     if (FALSE) {
[10:29:48.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.792]     }
[10:29:48.792]     ...future.result <- base::tryCatch({
[10:29:48.792]         base::withCallingHandlers({
[10:29:48.792]             ...future.value <- base::withVisible(base::local({
[10:29:48.792]                 withCallingHandlers({
[10:29:48.792]                   {
[10:29:48.792]                     do.call(function(...) {
[10:29:48.792]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.792]                       if (!identical(...future.globals.maxSize.org, 
[10:29:48.792]                         ...future.globals.maxSize)) {
[10:29:48.792]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.792]                         on.exit(options(oopts), add = TRUE)
[10:29:48.792]                       }
[10:29:48.792]                       {
[10:29:48.792]                         lapply(seq_along(...future.elements_ii), 
[10:29:48.792]                           FUN = function(jj) {
[10:29:48.792]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.792]                             ...future.FUN(...future.X_jj, ...)
[10:29:48.792]                           })
[10:29:48.792]                       }
[10:29:48.792]                     }, args = future.call.arguments)
[10:29:48.792]                   }
[10:29:48.792]                 }, immediateCondition = function(cond) {
[10:29:48.792]                   save_rds <- function (object, pathname, ...) 
[10:29:48.792]                   {
[10:29:48.792]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:48.792]                     if (file_test("-f", pathname_tmp)) {
[10:29:48.792]                       fi_tmp <- file.info(pathname_tmp)
[10:29:48.792]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:48.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:48.792]                         fi_tmp[["mtime"]])
[10:29:48.792]                     }
[10:29:48.792]                     tryCatch({
[10:29:48.792]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:48.792]                     }, error = function(ex) {
[10:29:48.792]                       msg <- conditionMessage(ex)
[10:29:48.792]                       fi_tmp <- file.info(pathname_tmp)
[10:29:48.792]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:48.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:48.792]                         fi_tmp[["mtime"]], msg)
[10:29:48.792]                       ex$message <- msg
[10:29:48.792]                       stop(ex)
[10:29:48.792]                     })
[10:29:48.792]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:48.792]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:48.792]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:48.792]                       fi_tmp <- file.info(pathname_tmp)
[10:29:48.792]                       fi <- file.info(pathname)
[10:29:48.792]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:48.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:48.792]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:48.792]                         fi[["size"]], fi[["mtime"]])
[10:29:48.792]                       stop(msg)
[10:29:48.792]                     }
[10:29:48.792]                     invisible(pathname)
[10:29:48.792]                   }
[10:29:48.792]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:48.792]                     rootPath = tempdir()) 
[10:29:48.792]                   {
[10:29:48.792]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:48.792]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:48.792]                       tmpdir = path, fileext = ".rds")
[10:29:48.792]                     save_rds(obj, file)
[10:29:48.792]                   }
[10:29:48.792]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:48.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.792]                   {
[10:29:48.792]                     inherits <- base::inherits
[10:29:48.792]                     invokeRestart <- base::invokeRestart
[10:29:48.792]                     is.null <- base::is.null
[10:29:48.792]                     muffled <- FALSE
[10:29:48.792]                     if (inherits(cond, "message")) {
[10:29:48.792]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:48.792]                       if (muffled) 
[10:29:48.792]                         invokeRestart("muffleMessage")
[10:29:48.792]                     }
[10:29:48.792]                     else if (inherits(cond, "warning")) {
[10:29:48.792]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:48.792]                       if (muffled) 
[10:29:48.792]                         invokeRestart("muffleWarning")
[10:29:48.792]                     }
[10:29:48.792]                     else if (inherits(cond, "condition")) {
[10:29:48.792]                       if (!is.null(pattern)) {
[10:29:48.792]                         computeRestarts <- base::computeRestarts
[10:29:48.792]                         grepl <- base::grepl
[10:29:48.792]                         restarts <- computeRestarts(cond)
[10:29:48.792]                         for (restart in restarts) {
[10:29:48.792]                           name <- restart$name
[10:29:48.792]                           if (is.null(name)) 
[10:29:48.792]                             next
[10:29:48.792]                           if (!grepl(pattern, name)) 
[10:29:48.792]                             next
[10:29:48.792]                           invokeRestart(restart)
[10:29:48.792]                           muffled <- TRUE
[10:29:48.792]                           break
[10:29:48.792]                         }
[10:29:48.792]                       }
[10:29:48.792]                     }
[10:29:48.792]                     invisible(muffled)
[10:29:48.792]                   }
[10:29:48.792]                   muffleCondition(cond)
[10:29:48.792]                 })
[10:29:48.792]             }))
[10:29:48.792]             future::FutureResult(value = ...future.value$value, 
[10:29:48.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.792]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.792]                     ...future.globalenv.names))
[10:29:48.792]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.792]         }, condition = base::local({
[10:29:48.792]             c <- base::c
[10:29:48.792]             inherits <- base::inherits
[10:29:48.792]             invokeRestart <- base::invokeRestart
[10:29:48.792]             length <- base::length
[10:29:48.792]             list <- base::list
[10:29:48.792]             seq.int <- base::seq.int
[10:29:48.792]             signalCondition <- base::signalCondition
[10:29:48.792]             sys.calls <- base::sys.calls
[10:29:48.792]             `[[` <- base::`[[`
[10:29:48.792]             `+` <- base::`+`
[10:29:48.792]             `<<-` <- base::`<<-`
[10:29:48.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.792]                   3L)]
[10:29:48.792]             }
[10:29:48.792]             function(cond) {
[10:29:48.792]                 is_error <- inherits(cond, "error")
[10:29:48.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.792]                   NULL)
[10:29:48.792]                 if (is_error) {
[10:29:48.792]                   sessionInformation <- function() {
[10:29:48.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.792]                       search = base::search(), system = base::Sys.info())
[10:29:48.792]                   }
[10:29:48.792]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.792]                     cond$call), session = sessionInformation(), 
[10:29:48.792]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.792]                   signalCondition(cond)
[10:29:48.792]                 }
[10:29:48.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.792]                 "immediateCondition"))) {
[10:29:48.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.792]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.792]                   if (TRUE && !signal) {
[10:29:48.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.792]                     {
[10:29:48.792]                       inherits <- base::inherits
[10:29:48.792]                       invokeRestart <- base::invokeRestart
[10:29:48.792]                       is.null <- base::is.null
[10:29:48.792]                       muffled <- FALSE
[10:29:48.792]                       if (inherits(cond, "message")) {
[10:29:48.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.792]                         if (muffled) 
[10:29:48.792]                           invokeRestart("muffleMessage")
[10:29:48.792]                       }
[10:29:48.792]                       else if (inherits(cond, "warning")) {
[10:29:48.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.792]                         if (muffled) 
[10:29:48.792]                           invokeRestart("muffleWarning")
[10:29:48.792]                       }
[10:29:48.792]                       else if (inherits(cond, "condition")) {
[10:29:48.792]                         if (!is.null(pattern)) {
[10:29:48.792]                           computeRestarts <- base::computeRestarts
[10:29:48.792]                           grepl <- base::grepl
[10:29:48.792]                           restarts <- computeRestarts(cond)
[10:29:48.792]                           for (restart in restarts) {
[10:29:48.792]                             name <- restart$name
[10:29:48.792]                             if (is.null(name)) 
[10:29:48.792]                               next
[10:29:48.792]                             if (!grepl(pattern, name)) 
[10:29:48.792]                               next
[10:29:48.792]                             invokeRestart(restart)
[10:29:48.792]                             muffled <- TRUE
[10:29:48.792]                             break
[10:29:48.792]                           }
[10:29:48.792]                         }
[10:29:48.792]                       }
[10:29:48.792]                       invisible(muffled)
[10:29:48.792]                     }
[10:29:48.792]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.792]                   }
[10:29:48.792]                 }
[10:29:48.792]                 else {
[10:29:48.792]                   if (TRUE) {
[10:29:48.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.792]                     {
[10:29:48.792]                       inherits <- base::inherits
[10:29:48.792]                       invokeRestart <- base::invokeRestart
[10:29:48.792]                       is.null <- base::is.null
[10:29:48.792]                       muffled <- FALSE
[10:29:48.792]                       if (inherits(cond, "message")) {
[10:29:48.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.792]                         if (muffled) 
[10:29:48.792]                           invokeRestart("muffleMessage")
[10:29:48.792]                       }
[10:29:48.792]                       else if (inherits(cond, "warning")) {
[10:29:48.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.792]                         if (muffled) 
[10:29:48.792]                           invokeRestart("muffleWarning")
[10:29:48.792]                       }
[10:29:48.792]                       else if (inherits(cond, "condition")) {
[10:29:48.792]                         if (!is.null(pattern)) {
[10:29:48.792]                           computeRestarts <- base::computeRestarts
[10:29:48.792]                           grepl <- base::grepl
[10:29:48.792]                           restarts <- computeRestarts(cond)
[10:29:48.792]                           for (restart in restarts) {
[10:29:48.792]                             name <- restart$name
[10:29:48.792]                             if (is.null(name)) 
[10:29:48.792]                               next
[10:29:48.792]                             if (!grepl(pattern, name)) 
[10:29:48.792]                               next
[10:29:48.792]                             invokeRestart(restart)
[10:29:48.792]                             muffled <- TRUE
[10:29:48.792]                             break
[10:29:48.792]                           }
[10:29:48.792]                         }
[10:29:48.792]                       }
[10:29:48.792]                       invisible(muffled)
[10:29:48.792]                     }
[10:29:48.792]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.792]                   }
[10:29:48.792]                 }
[10:29:48.792]             }
[10:29:48.792]         }))
[10:29:48.792]     }, error = function(ex) {
[10:29:48.792]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.792]                 ...future.rng), started = ...future.startTime, 
[10:29:48.792]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.792]             version = "1.8"), class = "FutureResult")
[10:29:48.792]     }, finally = {
[10:29:48.792]         if (!identical(...future.workdir, getwd())) 
[10:29:48.792]             setwd(...future.workdir)
[10:29:48.792]         {
[10:29:48.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.792]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.792]             }
[10:29:48.792]             base::options(...future.oldOptions)
[10:29:48.792]             if (.Platform$OS.type == "windows") {
[10:29:48.792]                 old_names <- names(...future.oldEnvVars)
[10:29:48.792]                 envs <- base::Sys.getenv()
[10:29:48.792]                 names <- names(envs)
[10:29:48.792]                 common <- intersect(names, old_names)
[10:29:48.792]                 added <- setdiff(names, old_names)
[10:29:48.792]                 removed <- setdiff(old_names, names)
[10:29:48.792]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.792]                   envs[common]]
[10:29:48.792]                 NAMES <- toupper(changed)
[10:29:48.792]                 args <- list()
[10:29:48.792]                 for (kk in seq_along(NAMES)) {
[10:29:48.792]                   name <- changed[[kk]]
[10:29:48.792]                   NAME <- NAMES[[kk]]
[10:29:48.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.792]                     next
[10:29:48.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.792]                 }
[10:29:48.792]                 NAMES <- toupper(added)
[10:29:48.792]                 for (kk in seq_along(NAMES)) {
[10:29:48.792]                   name <- added[[kk]]
[10:29:48.792]                   NAME <- NAMES[[kk]]
[10:29:48.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.792]                     next
[10:29:48.792]                   args[[name]] <- ""
[10:29:48.792]                 }
[10:29:48.792]                 NAMES <- toupper(removed)
[10:29:48.792]                 for (kk in seq_along(NAMES)) {
[10:29:48.792]                   name <- removed[[kk]]
[10:29:48.792]                   NAME <- NAMES[[kk]]
[10:29:48.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.792]                     next
[10:29:48.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.792]                 }
[10:29:48.792]                 if (length(args) > 0) 
[10:29:48.792]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.792]             }
[10:29:48.792]             else {
[10:29:48.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.792]             }
[10:29:48.792]             {
[10:29:48.792]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.792]                   0L) {
[10:29:48.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.792]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.792]                   base::options(opts)
[10:29:48.792]                 }
[10:29:48.792]                 {
[10:29:48.792]                   {
[10:29:48.792]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:48.792]                     NULL
[10:29:48.792]                   }
[10:29:48.792]                   options(future.plan = NULL)
[10:29:48.792]                   if (is.na(NA_character_)) 
[10:29:48.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.792]                     .init = FALSE)
[10:29:48.792]                 }
[10:29:48.792]             }
[10:29:48.792]         }
[10:29:48.792]     })
[10:29:48.792]     if (TRUE) {
[10:29:48.792]         base::sink(type = "output", split = FALSE)
[10:29:48.792]         if (TRUE) {
[10:29:48.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.792]         }
[10:29:48.792]         else {
[10:29:48.792]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.792]         }
[10:29:48.792]         base::close(...future.stdout)
[10:29:48.792]         ...future.stdout <- NULL
[10:29:48.792]     }
[10:29:48.792]     ...future.result$conditions <- ...future.conditions
[10:29:48.792]     ...future.result$finished <- base::Sys.time()
[10:29:48.792]     ...future.result
[10:29:48.792] }
[10:29:48.795] assign_globals() ...
[10:29:48.795] List of 5
[10:29:48.795]  $ future.call.arguments    : list()
[10:29:48.795]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.795]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.795]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.795]  $ ...future.elements_ii    :List of 1
[10:29:48.795]   ..$ : num [1:4] 1 3 1 7
[10:29:48.795]  $ ...future.seeds_ii       : NULL
[10:29:48.795]  $ ...future.globals.maxSize: num Inf
[10:29:48.795]  - attr(*, "resolved")= logi FALSE
[10:29:48.795]  - attr(*, "total_size")= num NA
[10:29:48.795]  - attr(*, "where")=List of 5
[10:29:48.795]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.795]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.795]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.795]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.795]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.795]  - attr(*, "already-done")= logi TRUE
[10:29:48.800] - copied ‘future.call.arguments’ to environment
[10:29:48.801] - copied ‘...future.FUN’ to environment
[10:29:48.801] - copied ‘...future.elements_ii’ to environment
[10:29:48.801] - copied ‘...future.seeds_ii’ to environment
[10:29:48.801] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.801] assign_globals() ... done
[10:29:48.801] requestCore(): workers = 2
[10:29:48.804] MulticoreFuture started
[10:29:48.805] - Launch lazy future ... done
[10:29:48.805] plan(): Setting new future strategy stack:
[10:29:48.805] run() for ‘MulticoreFuture’ ... done
[10:29:48.806] Created future:
[10:29:48.805] List of future strategies:
[10:29:48.805] 1. sequential:
[10:29:48.805]    - args: function (..., envir = parent.frame())
[10:29:48.805]    - tweaked: FALSE
[10:29:48.805]    - call: NULL
[10:29:48.806] plan(): nbrOfWorkers() = 1
[10:29:48.809] plan(): Setting new future strategy stack:
[10:29:48.809] List of future strategies:
[10:29:48.809] 1. multicore:
[10:29:48.809]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:48.809]    - tweaked: FALSE
[10:29:48.809]    - call: plan(strategy)
[10:29:48.814] plan(): nbrOfWorkers() = 2
[10:29:48.806] MulticoreFuture:
[10:29:48.806] Label: ‘future_apply-1’
[10:29:48.806] Expression:
[10:29:48.806] {
[10:29:48.806]     do.call(function(...) {
[10:29:48.806]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.806]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.806]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.806]             on.exit(options(oopts), add = TRUE)
[10:29:48.806]         }
[10:29:48.806]         {
[10:29:48.806]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.806]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.806]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.806]             })
[10:29:48.806]         }
[10:29:48.806]     }, args = future.call.arguments)
[10:29:48.806] }
[10:29:48.806] Lazy evaluation: FALSE
[10:29:48.806] Asynchronous evaluation: TRUE
[10:29:48.806] Local evaluation: TRUE
[10:29:48.806] Environment: R_GlobalEnv
[10:29:48.806] Capture standard output: TRUE
[10:29:48.806] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.806] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.806] Packages: <none>
[10:29:48.806] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.806] Resolved: TRUE
[10:29:48.806] Value: <not collected>
[10:29:48.806] Conditions captured: <none>
[10:29:48.806] Early signaling: FALSE
[10:29:48.806] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.806] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:48.815] Chunk #1 of 2 ... DONE
[10:29:48.815] Chunk #2 of 2 ...
[10:29:48.816]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:48.816]  - seeds: <none>
[10:29:48.816]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.816] getGlobalsAndPackages() ...
[10:29:48.816] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.817] Resolving globals: FALSE
[10:29:48.817] Tweak future expression to call with '...' arguments ...
[10:29:48.817] {
[10:29:48.817]     do.call(function(...) {
[10:29:48.817]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.817]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.817]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.817]             on.exit(options(oopts), add = TRUE)
[10:29:48.817]         }
[10:29:48.817]         {
[10:29:48.817]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.817]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.817]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.817]             })
[10:29:48.817]         }
[10:29:48.817]     }, args = future.call.arguments)
[10:29:48.817] }
[10:29:48.817] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.818] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.818] 
[10:29:48.818] getGlobalsAndPackages() ... DONE
[10:29:48.819] run() for ‘Future’ ...
[10:29:48.819] - state: ‘created’
[10:29:48.819] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:48.824] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:48.824] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:48.824]   - Field: ‘label’
[10:29:48.824]   - Field: ‘local’
[10:29:48.825]   - Field: ‘owner’
[10:29:48.825]   - Field: ‘envir’
[10:29:48.825]   - Field: ‘workers’
[10:29:48.825]   - Field: ‘packages’
[10:29:48.825]   - Field: ‘gc’
[10:29:48.825]   - Field: ‘job’
[10:29:48.826]   - Field: ‘conditions’
[10:29:48.826]   - Field: ‘expr’
[10:29:48.826]   - Field: ‘uuid’
[10:29:48.826]   - Field: ‘seed’
[10:29:48.826]   - Field: ‘version’
[10:29:48.826]   - Field: ‘result’
[10:29:48.827]   - Field: ‘asynchronous’
[10:29:48.827]   - Field: ‘calls’
[10:29:48.827]   - Field: ‘globals’
[10:29:48.827]   - Field: ‘stdout’
[10:29:48.827]   - Field: ‘earlySignal’
[10:29:48.827]   - Field: ‘lazy’
[10:29:48.827]   - Field: ‘state’
[10:29:48.828] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:48.828] - Launch lazy future ...
[10:29:48.828] Packages needed by the future expression (n = 0): <none>
[10:29:48.828] Packages needed by future strategies (n = 0): <none>
[10:29:48.829] {
[10:29:48.829]     {
[10:29:48.829]         {
[10:29:48.829]             ...future.startTime <- base::Sys.time()
[10:29:48.829]             {
[10:29:48.829]                 {
[10:29:48.829]                   {
[10:29:48.829]                     {
[10:29:48.829]                       base::local({
[10:29:48.829]                         has_future <- base::requireNamespace("future", 
[10:29:48.829]                           quietly = TRUE)
[10:29:48.829]                         if (has_future) {
[10:29:48.829]                           ns <- base::getNamespace("future")
[10:29:48.829]                           version <- ns[[".package"]][["version"]]
[10:29:48.829]                           if (is.null(version)) 
[10:29:48.829]                             version <- utils::packageVersion("future")
[10:29:48.829]                         }
[10:29:48.829]                         else {
[10:29:48.829]                           version <- NULL
[10:29:48.829]                         }
[10:29:48.829]                         if (!has_future || version < "1.8.0") {
[10:29:48.829]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.829]                             "", base::R.version$version.string), 
[10:29:48.829]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:48.829]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.829]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.829]                               "release", "version")], collapse = " "), 
[10:29:48.829]                             hostname = base::Sys.info()[["nodename"]])
[10:29:48.829]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.829]                             info)
[10:29:48.829]                           info <- base::paste(info, collapse = "; ")
[10:29:48.829]                           if (!has_future) {
[10:29:48.829]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.829]                               info)
[10:29:48.829]                           }
[10:29:48.829]                           else {
[10:29:48.829]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.829]                               info, version)
[10:29:48.829]                           }
[10:29:48.829]                           base::stop(msg)
[10:29:48.829]                         }
[10:29:48.829]                       })
[10:29:48.829]                     }
[10:29:48.829]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:48.829]                     base::options(mc.cores = 1L)
[10:29:48.829]                   }
[10:29:48.829]                   ...future.strategy.old <- future::plan("list")
[10:29:48.829]                   options(future.plan = NULL)
[10:29:48.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.829]                 }
[10:29:48.829]                 ...future.workdir <- getwd()
[10:29:48.829]             }
[10:29:48.829]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.829]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.829]         }
[10:29:48.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.829]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.829]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.829]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.829]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.829]             base::names(...future.oldOptions))
[10:29:48.829]     }
[10:29:48.829]     if (FALSE) {
[10:29:48.829]     }
[10:29:48.829]     else {
[10:29:48.829]         if (TRUE) {
[10:29:48.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.829]                 open = "w")
[10:29:48.829]         }
[10:29:48.829]         else {
[10:29:48.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.829]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.829]         }
[10:29:48.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.829]             base::sink(type = "output", split = FALSE)
[10:29:48.829]             base::close(...future.stdout)
[10:29:48.829]         }, add = TRUE)
[10:29:48.829]     }
[10:29:48.829]     ...future.frame <- base::sys.nframe()
[10:29:48.829]     ...future.conditions <- base::list()
[10:29:48.829]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.829]     if (FALSE) {
[10:29:48.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.829]     }
[10:29:48.829]     ...future.result <- base::tryCatch({
[10:29:48.829]         base::withCallingHandlers({
[10:29:48.829]             ...future.value <- base::withVisible(base::local({
[10:29:48.829]                 withCallingHandlers({
[10:29:48.829]                   {
[10:29:48.829]                     do.call(function(...) {
[10:29:48.829]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.829]                       if (!identical(...future.globals.maxSize.org, 
[10:29:48.829]                         ...future.globals.maxSize)) {
[10:29:48.829]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.829]                         on.exit(options(oopts), add = TRUE)
[10:29:48.829]                       }
[10:29:48.829]                       {
[10:29:48.829]                         lapply(seq_along(...future.elements_ii), 
[10:29:48.829]                           FUN = function(jj) {
[10:29:48.829]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.829]                             ...future.FUN(...future.X_jj, ...)
[10:29:48.829]                           })
[10:29:48.829]                       }
[10:29:48.829]                     }, args = future.call.arguments)
[10:29:48.829]                   }
[10:29:48.829]                 }, immediateCondition = function(cond) {
[10:29:48.829]                   save_rds <- function (object, pathname, ...) 
[10:29:48.829]                   {
[10:29:48.829]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:48.829]                     if (file_test("-f", pathname_tmp)) {
[10:29:48.829]                       fi_tmp <- file.info(pathname_tmp)
[10:29:48.829]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:48.829]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:48.829]                         fi_tmp[["mtime"]])
[10:29:48.829]                     }
[10:29:48.829]                     tryCatch({
[10:29:48.829]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:48.829]                     }, error = function(ex) {
[10:29:48.829]                       msg <- conditionMessage(ex)
[10:29:48.829]                       fi_tmp <- file.info(pathname_tmp)
[10:29:48.829]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:48.829]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:48.829]                         fi_tmp[["mtime"]], msg)
[10:29:48.829]                       ex$message <- msg
[10:29:48.829]                       stop(ex)
[10:29:48.829]                     })
[10:29:48.829]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:48.829]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:48.829]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:48.829]                       fi_tmp <- file.info(pathname_tmp)
[10:29:48.829]                       fi <- file.info(pathname)
[10:29:48.829]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:48.829]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:48.829]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:48.829]                         fi[["size"]], fi[["mtime"]])
[10:29:48.829]                       stop(msg)
[10:29:48.829]                     }
[10:29:48.829]                     invisible(pathname)
[10:29:48.829]                   }
[10:29:48.829]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:48.829]                     rootPath = tempdir()) 
[10:29:48.829]                   {
[10:29:48.829]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:48.829]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:48.829]                       tmpdir = path, fileext = ".rds")
[10:29:48.829]                     save_rds(obj, file)
[10:29:48.829]                   }
[10:29:48.829]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:48.829]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.829]                   {
[10:29:48.829]                     inherits <- base::inherits
[10:29:48.829]                     invokeRestart <- base::invokeRestart
[10:29:48.829]                     is.null <- base::is.null
[10:29:48.829]                     muffled <- FALSE
[10:29:48.829]                     if (inherits(cond, "message")) {
[10:29:48.829]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:48.829]                       if (muffled) 
[10:29:48.829]                         invokeRestart("muffleMessage")
[10:29:48.829]                     }
[10:29:48.829]                     else if (inherits(cond, "warning")) {
[10:29:48.829]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:48.829]                       if (muffled) 
[10:29:48.829]                         invokeRestart("muffleWarning")
[10:29:48.829]                     }
[10:29:48.829]                     else if (inherits(cond, "condition")) {
[10:29:48.829]                       if (!is.null(pattern)) {
[10:29:48.829]                         computeRestarts <- base::computeRestarts
[10:29:48.829]                         grepl <- base::grepl
[10:29:48.829]                         restarts <- computeRestarts(cond)
[10:29:48.829]                         for (restart in restarts) {
[10:29:48.829]                           name <- restart$name
[10:29:48.829]                           if (is.null(name)) 
[10:29:48.829]                             next
[10:29:48.829]                           if (!grepl(pattern, name)) 
[10:29:48.829]                             next
[10:29:48.829]                           invokeRestart(restart)
[10:29:48.829]                           muffled <- TRUE
[10:29:48.829]                           break
[10:29:48.829]                         }
[10:29:48.829]                       }
[10:29:48.829]                     }
[10:29:48.829]                     invisible(muffled)
[10:29:48.829]                   }
[10:29:48.829]                   muffleCondition(cond)
[10:29:48.829]                 })
[10:29:48.829]             }))
[10:29:48.829]             future::FutureResult(value = ...future.value$value, 
[10:29:48.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.829]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.829]                     ...future.globalenv.names))
[10:29:48.829]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.829]         }, condition = base::local({
[10:29:48.829]             c <- base::c
[10:29:48.829]             inherits <- base::inherits
[10:29:48.829]             invokeRestart <- base::invokeRestart
[10:29:48.829]             length <- base::length
[10:29:48.829]             list <- base::list
[10:29:48.829]             seq.int <- base::seq.int
[10:29:48.829]             signalCondition <- base::signalCondition
[10:29:48.829]             sys.calls <- base::sys.calls
[10:29:48.829]             `[[` <- base::`[[`
[10:29:48.829]             `+` <- base::`+`
[10:29:48.829]             `<<-` <- base::`<<-`
[10:29:48.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.829]                   3L)]
[10:29:48.829]             }
[10:29:48.829]             function(cond) {
[10:29:48.829]                 is_error <- inherits(cond, "error")
[10:29:48.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.829]                   NULL)
[10:29:48.829]                 if (is_error) {
[10:29:48.829]                   sessionInformation <- function() {
[10:29:48.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.829]                       search = base::search(), system = base::Sys.info())
[10:29:48.829]                   }
[10:29:48.829]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.829]                     cond$call), session = sessionInformation(), 
[10:29:48.829]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.829]                   signalCondition(cond)
[10:29:48.829]                 }
[10:29:48.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.829]                 "immediateCondition"))) {
[10:29:48.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.829]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.829]                   if (TRUE && !signal) {
[10:29:48.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.829]                     {
[10:29:48.829]                       inherits <- base::inherits
[10:29:48.829]                       invokeRestart <- base::invokeRestart
[10:29:48.829]                       is.null <- base::is.null
[10:29:48.829]                       muffled <- FALSE
[10:29:48.829]                       if (inherits(cond, "message")) {
[10:29:48.829]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.829]                         if (muffled) 
[10:29:48.829]                           invokeRestart("muffleMessage")
[10:29:48.829]                       }
[10:29:48.829]                       else if (inherits(cond, "warning")) {
[10:29:48.829]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.829]                         if (muffled) 
[10:29:48.829]                           invokeRestart("muffleWarning")
[10:29:48.829]                       }
[10:29:48.829]                       else if (inherits(cond, "condition")) {
[10:29:48.829]                         if (!is.null(pattern)) {
[10:29:48.829]                           computeRestarts <- base::computeRestarts
[10:29:48.829]                           grepl <- base::grepl
[10:29:48.829]                           restarts <- computeRestarts(cond)
[10:29:48.829]                           for (restart in restarts) {
[10:29:48.829]                             name <- restart$name
[10:29:48.829]                             if (is.null(name)) 
[10:29:48.829]                               next
[10:29:48.829]                             if (!grepl(pattern, name)) 
[10:29:48.829]                               next
[10:29:48.829]                             invokeRestart(restart)
[10:29:48.829]                             muffled <- TRUE
[10:29:48.829]                             break
[10:29:48.829]                           }
[10:29:48.829]                         }
[10:29:48.829]                       }
[10:29:48.829]                       invisible(muffled)
[10:29:48.829]                     }
[10:29:48.829]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.829]                   }
[10:29:48.829]                 }
[10:29:48.829]                 else {
[10:29:48.829]                   if (TRUE) {
[10:29:48.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.829]                     {
[10:29:48.829]                       inherits <- base::inherits
[10:29:48.829]                       invokeRestart <- base::invokeRestart
[10:29:48.829]                       is.null <- base::is.null
[10:29:48.829]                       muffled <- FALSE
[10:29:48.829]                       if (inherits(cond, "message")) {
[10:29:48.829]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.829]                         if (muffled) 
[10:29:48.829]                           invokeRestart("muffleMessage")
[10:29:48.829]                       }
[10:29:48.829]                       else if (inherits(cond, "warning")) {
[10:29:48.829]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.829]                         if (muffled) 
[10:29:48.829]                           invokeRestart("muffleWarning")
[10:29:48.829]                       }
[10:29:48.829]                       else if (inherits(cond, "condition")) {
[10:29:48.829]                         if (!is.null(pattern)) {
[10:29:48.829]                           computeRestarts <- base::computeRestarts
[10:29:48.829]                           grepl <- base::grepl
[10:29:48.829]                           restarts <- computeRestarts(cond)
[10:29:48.829]                           for (restart in restarts) {
[10:29:48.829]                             name <- restart$name
[10:29:48.829]                             if (is.null(name)) 
[10:29:48.829]                               next
[10:29:48.829]                             if (!grepl(pattern, name)) 
[10:29:48.829]                               next
[10:29:48.829]                             invokeRestart(restart)
[10:29:48.829]                             muffled <- TRUE
[10:29:48.829]                             break
[10:29:48.829]                           }
[10:29:48.829]                         }
[10:29:48.829]                       }
[10:29:48.829]                       invisible(muffled)
[10:29:48.829]                     }
[10:29:48.829]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.829]                   }
[10:29:48.829]                 }
[10:29:48.829]             }
[10:29:48.829]         }))
[10:29:48.829]     }, error = function(ex) {
[10:29:48.829]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.829]                 ...future.rng), started = ...future.startTime, 
[10:29:48.829]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.829]             version = "1.8"), class = "FutureResult")
[10:29:48.829]     }, finally = {
[10:29:48.829]         if (!identical(...future.workdir, getwd())) 
[10:29:48.829]             setwd(...future.workdir)
[10:29:48.829]         {
[10:29:48.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.829]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.829]             }
[10:29:48.829]             base::options(...future.oldOptions)
[10:29:48.829]             if (.Platform$OS.type == "windows") {
[10:29:48.829]                 old_names <- names(...future.oldEnvVars)
[10:29:48.829]                 envs <- base::Sys.getenv()
[10:29:48.829]                 names <- names(envs)
[10:29:48.829]                 common <- intersect(names, old_names)
[10:29:48.829]                 added <- setdiff(names, old_names)
[10:29:48.829]                 removed <- setdiff(old_names, names)
[10:29:48.829]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.829]                   envs[common]]
[10:29:48.829]                 NAMES <- toupper(changed)
[10:29:48.829]                 args <- list()
[10:29:48.829]                 for (kk in seq_along(NAMES)) {
[10:29:48.829]                   name <- changed[[kk]]
[10:29:48.829]                   NAME <- NAMES[[kk]]
[10:29:48.829]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.829]                     next
[10:29:48.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.829]                 }
[10:29:48.829]                 NAMES <- toupper(added)
[10:29:48.829]                 for (kk in seq_along(NAMES)) {
[10:29:48.829]                   name <- added[[kk]]
[10:29:48.829]                   NAME <- NAMES[[kk]]
[10:29:48.829]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.829]                     next
[10:29:48.829]                   args[[name]] <- ""
[10:29:48.829]                 }
[10:29:48.829]                 NAMES <- toupper(removed)
[10:29:48.829]                 for (kk in seq_along(NAMES)) {
[10:29:48.829]                   name <- removed[[kk]]
[10:29:48.829]                   NAME <- NAMES[[kk]]
[10:29:48.829]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.829]                     next
[10:29:48.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.829]                 }
[10:29:48.829]                 if (length(args) > 0) 
[10:29:48.829]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.829]             }
[10:29:48.829]             else {
[10:29:48.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.829]             }
[10:29:48.829]             {
[10:29:48.829]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.829]                   0L) {
[10:29:48.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.829]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.829]                   base::options(opts)
[10:29:48.829]                 }
[10:29:48.829]                 {
[10:29:48.829]                   {
[10:29:48.829]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:48.829]                     NULL
[10:29:48.829]                   }
[10:29:48.829]                   options(future.plan = NULL)
[10:29:48.829]                   if (is.na(NA_character_)) 
[10:29:48.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.829]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.829]                     .init = FALSE)
[10:29:48.829]                 }
[10:29:48.829]             }
[10:29:48.829]         }
[10:29:48.829]     })
[10:29:48.829]     if (TRUE) {
[10:29:48.829]         base::sink(type = "output", split = FALSE)
[10:29:48.829]         if (TRUE) {
[10:29:48.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.829]         }
[10:29:48.829]         else {
[10:29:48.829]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.829]         }
[10:29:48.829]         base::close(...future.stdout)
[10:29:48.829]         ...future.stdout <- NULL
[10:29:48.829]     }
[10:29:48.829]     ...future.result$conditions <- ...future.conditions
[10:29:48.829]     ...future.result$finished <- base::Sys.time()
[10:29:48.829]     ...future.result
[10:29:48.829] }
[10:29:48.832] assign_globals() ...
[10:29:48.832] List of 5
[10:29:48.832]  $ future.call.arguments    : list()
[10:29:48.832]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.832]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.832]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.832]  $ ...future.elements_ii    :List of 1
[10:29:48.832]   ..$ : num [1:4] 2 4 6 8
[10:29:48.832]  $ ...future.seeds_ii       : NULL
[10:29:48.832]  $ ...future.globals.maxSize: num Inf
[10:29:48.832]  - attr(*, "resolved")= logi FALSE
[10:29:48.832]  - attr(*, "total_size")= num NA
[10:29:48.832]  - attr(*, "where")=List of 5
[10:29:48.832]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.832]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.832]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.832]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.832]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.832]  - attr(*, "already-done")= logi TRUE
[10:29:48.839] - copied ‘future.call.arguments’ to environment
[10:29:48.839] - copied ‘...future.FUN’ to environment
[10:29:48.840] - copied ‘...future.elements_ii’ to environment
[10:29:48.840] - copied ‘...future.seeds_ii’ to environment
[10:29:48.842] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.842] assign_globals() ... done
[10:29:48.843] requestCore(): workers = 2
[10:29:48.850] MulticoreFuture started
[10:29:48.850] - Launch lazy future ... done
[10:29:48.850] run() for ‘MulticoreFuture’ ... done
[10:29:48.851] Created future:
[10:29:48.851] plan(): Setting new future strategy stack:
[10:29:48.851] List of future strategies:
[10:29:48.851] 1. sequential:
[10:29:48.851]    - args: function (..., envir = parent.frame())
[10:29:48.851]    - tweaked: FALSE
[10:29:48.851]    - call: NULL
[10:29:48.852] plan(): nbrOfWorkers() = 1
[10:29:48.855] plan(): Setting new future strategy stack:
[10:29:48.855] List of future strategies:
[10:29:48.855] 1. multicore:
[10:29:48.855]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:48.855]    - tweaked: FALSE
[10:29:48.855]    - call: plan(strategy)
[10:29:48.861] plan(): nbrOfWorkers() = 2
[10:29:48.851] MulticoreFuture:
[10:29:48.851] Label: ‘future_apply-2’
[10:29:48.851] Expression:
[10:29:48.851] {
[10:29:48.851]     do.call(function(...) {
[10:29:48.851]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.851]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.851]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.851]             on.exit(options(oopts), add = TRUE)
[10:29:48.851]         }
[10:29:48.851]         {
[10:29:48.851]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.851]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.851]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.851]             })
[10:29:48.851]         }
[10:29:48.851]     }, args = future.call.arguments)
[10:29:48.851] }
[10:29:48.851] Lazy evaluation: FALSE
[10:29:48.851] Asynchronous evaluation: TRUE
[10:29:48.851] Local evaluation: TRUE
[10:29:48.851] Environment: R_GlobalEnv
[10:29:48.851] Capture standard output: TRUE
[10:29:48.851] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.851] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.851] Packages: <none>
[10:29:48.851] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.851] Resolved: TRUE
[10:29:48.851] Value: <not collected>
[10:29:48.851] Conditions captured: <none>
[10:29:48.851] Early signaling: FALSE
[10:29:48.851] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.851] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:48.862] Chunk #2 of 2 ... DONE
[10:29:48.862] Launching 2 futures (chunks) ... DONE
[10:29:48.862] Resolving 2 futures (chunks) ...
[10:29:48.863] resolve() on list ...
[10:29:48.863]  recursive: 0
[10:29:48.863]  length: 2
[10:29:48.863] 
[10:29:48.863] Future #1
[10:29:48.864] result() for MulticoreFuture ...
[10:29:48.866] result() for MulticoreFuture ...
[10:29:48.866] result() for MulticoreFuture ... done
[10:29:48.866] result() for MulticoreFuture ... done
[10:29:48.867] result() for MulticoreFuture ...
[10:29:48.867] result() for MulticoreFuture ... done
[10:29:48.867] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:48.867] - nx: 2
[10:29:48.867] - relay: TRUE
[10:29:48.867] - stdout: TRUE
[10:29:48.868] - signal: TRUE
[10:29:48.868] - resignal: FALSE
[10:29:48.868] - force: TRUE
[10:29:48.868] - relayed: [n=2] FALSE, FALSE
[10:29:48.868] - queued futures: [n=2] FALSE, FALSE
[10:29:48.868]  - until=1
[10:29:48.868]  - relaying element #1
[10:29:48.869] result() for MulticoreFuture ...
[10:29:48.869] result() for MulticoreFuture ... done
[10:29:48.869] result() for MulticoreFuture ...
[10:29:48.869] result() for MulticoreFuture ... done
[10:29:48.869] result() for MulticoreFuture ...
[10:29:48.869] result() for MulticoreFuture ... done
[10:29:48.870] result() for MulticoreFuture ...
[10:29:48.870] result() for MulticoreFuture ... done
[10:29:48.870] - relayed: [n=2] TRUE, FALSE
[10:29:48.870] - queued futures: [n=2] TRUE, FALSE
[10:29:48.870] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:48.870]  length: 1 (resolved future 1)
[10:29:48.871] Future #2
[10:29:48.871] result() for MulticoreFuture ...
[10:29:48.872] result() for MulticoreFuture ...
[10:29:48.872] result() for MulticoreFuture ... done
[10:29:48.872] result() for MulticoreFuture ... done
[10:29:48.872] result() for MulticoreFuture ...
[10:29:48.872] result() for MulticoreFuture ... done
[10:29:48.872] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:48.872] - nx: 2
[10:29:48.873] - relay: TRUE
[10:29:48.873] - stdout: TRUE
[10:29:48.873] - signal: TRUE
[10:29:48.873] - resignal: FALSE
[10:29:48.873] - force: TRUE
[10:29:48.873] - relayed: [n=2] TRUE, FALSE
[10:29:48.873] - queued futures: [n=2] TRUE, FALSE
[10:29:48.873]  - until=2
[10:29:48.874]  - relaying element #2
[10:29:48.874] result() for MulticoreFuture ...
[10:29:48.874] result() for MulticoreFuture ... done
[10:29:48.874] result() for MulticoreFuture ...
[10:29:48.874] result() for MulticoreFuture ... done
[10:29:48.874] result() for MulticoreFuture ...
[10:29:48.874] result() for MulticoreFuture ... done
[10:29:48.874] result() for MulticoreFuture ...
[10:29:48.875] result() for MulticoreFuture ... done
[10:29:48.875] - relayed: [n=2] TRUE, TRUE
[10:29:48.875] - queued futures: [n=2] TRUE, TRUE
[10:29:48.875] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:48.875]  length: 0 (resolved future 2)
[10:29:48.875] Relaying remaining futures
[10:29:48.875] signalConditionsASAP(NULL, pos=0) ...
[10:29:48.875] - nx: 2
[10:29:48.875] - relay: TRUE
[10:29:48.876] - stdout: TRUE
[10:29:48.876] - signal: TRUE
[10:29:48.876] - resignal: FALSE
[10:29:48.876] - force: TRUE
[10:29:48.876] - relayed: [n=2] TRUE, TRUE
[10:29:48.876] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:48.876] - relayed: [n=2] TRUE, TRUE
[10:29:48.876] - queued futures: [n=2] TRUE, TRUE
[10:29:48.877] signalConditionsASAP(NULL, pos=0) ... done
[10:29:48.877] resolve() on list ... DONE
[10:29:48.877] result() for MulticoreFuture ...
[10:29:48.877] result() for MulticoreFuture ... done
[10:29:48.877] result() for MulticoreFuture ...
[10:29:48.877] result() for MulticoreFuture ... done
[10:29:48.877] result() for MulticoreFuture ...
[10:29:48.877] result() for MulticoreFuture ... done
[10:29:48.878] result() for MulticoreFuture ...
[10:29:48.878] result() for MulticoreFuture ... done
[10:29:48.878]  - Number of value chunks collected: 2
[10:29:48.878] Resolving 2 futures (chunks) ... DONE
[10:29:48.878] Reducing values from 2 chunks ...
[10:29:48.878]  - Number of values collected after concatenation: 2
[10:29:48.878]  - Number of values expected: 2
[10:29:48.878] Reducing values from 2 chunks ... DONE
[10:29:48.878] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:29:48.879] getGlobalsAndPackagesXApply() ...
[10:29:48.879]  - future.globals: TRUE
[10:29:48.879] getGlobalsAndPackages() ...
[10:29:48.879] Searching for globals...
[10:29:48.918] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:29:48.918] Searching for globals ... DONE
[10:29:48.918] Resolving globals: FALSE
[10:29:48.920] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:29:48.922] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:29:48.922] - globals: [1] ‘FUN’
[10:29:48.923] 
[10:29:48.923] getGlobalsAndPackages() ... DONE
[10:29:48.923]  - globals found/used: [n=1] ‘FUN’
[10:29:48.923]  - needed namespaces: [n=0] 
[10:29:48.923] Finding globals ... DONE
[10:29:48.923]  - use_args: TRUE
[10:29:48.923]  - Getting '...' globals ...
[10:29:48.924] resolve() on list ...
[10:29:48.924]  recursive: 0
[10:29:48.924]  length: 1
[10:29:48.924]  elements: ‘...’
[10:29:48.924]  length: 0 (resolved future 1)
[10:29:48.924] resolve() on list ... DONE
[10:29:48.924]    - '...' content: [n=0] 
[10:29:48.924] List of 1
[10:29:48.924]  $ ...: list()
[10:29:48.924]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.924]  - attr(*, "where")=List of 1
[10:29:48.924]   ..$ ...:<environment: 0x5618a1f6a898> 
[10:29:48.924]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.924]  - attr(*, "resolved")= logi TRUE
[10:29:48.924]  - attr(*, "total_size")= num NA
[10:29:48.927]  - Getting '...' globals ... DONE
[10:29:48.927] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:48.927] List of 2
[10:29:48.927]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.927]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.927]  $ ...          : list()
[10:29:48.927]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.927]  - attr(*, "where")=List of 2
[10:29:48.927]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:48.927]   ..$ ...          :<environment: 0x5618a1f6a898> 
[10:29:48.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.927]  - attr(*, "resolved")= logi FALSE
[10:29:48.927]  - attr(*, "total_size")= num 354224
[10:29:48.930] Packages to be attached in all futures: [n=0] 
[10:29:48.930] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.934] future_lapply() ...
[10:29:48.971] Number of chunks: 2
[10:29:48.971] getGlobalsAndPackagesXApply() ...
[10:29:48.971]  - future.globals: <name-value list> with names ‘list()’
[10:29:48.971]  - use_args: TRUE
[10:29:48.972] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:48.972] List of 2
[10:29:48.972]  $ ...          : list()
[10:29:48.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.972]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.972]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.972]  - attr(*, "where")=List of 2
[10:29:48.972]   ..$ ...          :<environment: 0x5618a1f6a898> 
[10:29:48.972]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:48.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.972]  - attr(*, "resolved")= logi FALSE
[10:29:48.972]  - attr(*, "total_size")= num NA
[10:29:48.975] Packages to be attached in all futures: [n=0] 
[10:29:48.975] getGlobalsAndPackagesXApply() ... DONE
[10:29:48.975] Number of futures (= number of chunks): 2
[10:29:48.976] Launching 2 futures (chunks) ...
[10:29:48.976] Chunk #1 of 2 ...
[10:29:48.976]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:48.976]  - seeds: <none>
[10:29:48.976]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.976] getGlobalsAndPackages() ...
[10:29:48.976] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.976] Resolving globals: FALSE
[10:29:48.977] Tweak future expression to call with '...' arguments ...
[10:29:48.977] {
[10:29:48.977]     do.call(function(...) {
[10:29:48.977]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.977]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.977]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.977]             on.exit(options(oopts), add = TRUE)
[10:29:48.977]         }
[10:29:48.977]         {
[10:29:48.977]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.977]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.977]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.977]             })
[10:29:48.977]         }
[10:29:48.977]     }, args = future.call.arguments)
[10:29:48.977] }
[10:29:48.977] Tweak future expression to call with '...' arguments ... DONE
[10:29:48.977] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:48.977] 
[10:29:48.978] getGlobalsAndPackages() ... DONE
[10:29:48.978] run() for ‘Future’ ...
[10:29:48.978] - state: ‘created’
[10:29:48.978] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:48.982] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:48.982] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:48.982]   - Field: ‘label’
[10:29:48.982]   - Field: ‘local’
[10:29:48.982]   - Field: ‘owner’
[10:29:48.982]   - Field: ‘envir’
[10:29:48.982]   - Field: ‘workers’
[10:29:48.983]   - Field: ‘packages’
[10:29:48.983]   - Field: ‘gc’
[10:29:48.983]   - Field: ‘job’
[10:29:48.983]   - Field: ‘conditions’
[10:29:48.983]   - Field: ‘expr’
[10:29:48.983]   - Field: ‘uuid’
[10:29:48.983]   - Field: ‘seed’
[10:29:48.983]   - Field: ‘version’
[10:29:48.983]   - Field: ‘result’
[10:29:48.983]   - Field: ‘asynchronous’
[10:29:48.984]   - Field: ‘calls’
[10:29:48.985]   - Field: ‘globals’
[10:29:48.985]   - Field: ‘stdout’
[10:29:48.985]   - Field: ‘earlySignal’
[10:29:48.985]   - Field: ‘lazy’
[10:29:48.985]   - Field: ‘state’
[10:29:48.985] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:48.986] - Launch lazy future ...
[10:29:48.986] Packages needed by the future expression (n = 0): <none>
[10:29:48.986] Packages needed by future strategies (n = 0): <none>
[10:29:48.987] {
[10:29:48.987]     {
[10:29:48.987]         {
[10:29:48.987]             ...future.startTime <- base::Sys.time()
[10:29:48.987]             {
[10:29:48.987]                 {
[10:29:48.987]                   {
[10:29:48.987]                     {
[10:29:48.987]                       base::local({
[10:29:48.987]                         has_future <- base::requireNamespace("future", 
[10:29:48.987]                           quietly = TRUE)
[10:29:48.987]                         if (has_future) {
[10:29:48.987]                           ns <- base::getNamespace("future")
[10:29:48.987]                           version <- ns[[".package"]][["version"]]
[10:29:48.987]                           if (is.null(version)) 
[10:29:48.987]                             version <- utils::packageVersion("future")
[10:29:48.987]                         }
[10:29:48.987]                         else {
[10:29:48.987]                           version <- NULL
[10:29:48.987]                         }
[10:29:48.987]                         if (!has_future || version < "1.8.0") {
[10:29:48.987]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:48.987]                             "", base::R.version$version.string), 
[10:29:48.987]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:48.987]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:48.987]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:48.987]                               "release", "version")], collapse = " "), 
[10:29:48.987]                             hostname = base::Sys.info()[["nodename"]])
[10:29:48.987]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:48.987]                             info)
[10:29:48.987]                           info <- base::paste(info, collapse = "; ")
[10:29:48.987]                           if (!has_future) {
[10:29:48.987]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:48.987]                               info)
[10:29:48.987]                           }
[10:29:48.987]                           else {
[10:29:48.987]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:48.987]                               info, version)
[10:29:48.987]                           }
[10:29:48.987]                           base::stop(msg)
[10:29:48.987]                         }
[10:29:48.987]                       })
[10:29:48.987]                     }
[10:29:48.987]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:48.987]                     base::options(mc.cores = 1L)
[10:29:48.987]                   }
[10:29:48.987]                   ...future.strategy.old <- future::plan("list")
[10:29:48.987]                   options(future.plan = NULL)
[10:29:48.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:48.987]                 }
[10:29:48.987]                 ...future.workdir <- getwd()
[10:29:48.987]             }
[10:29:48.987]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:48.987]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:48.987]         }
[10:29:48.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:48.987]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:48.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:48.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:48.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:48.987]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:48.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:48.987]             base::names(...future.oldOptions))
[10:29:48.987]     }
[10:29:48.987]     if (FALSE) {
[10:29:48.987]     }
[10:29:48.987]     else {
[10:29:48.987]         if (TRUE) {
[10:29:48.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:48.987]                 open = "w")
[10:29:48.987]         }
[10:29:48.987]         else {
[10:29:48.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:48.987]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:48.987]         }
[10:29:48.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:48.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:48.987]             base::sink(type = "output", split = FALSE)
[10:29:48.987]             base::close(...future.stdout)
[10:29:48.987]         }, add = TRUE)
[10:29:48.987]     }
[10:29:48.987]     ...future.frame <- base::sys.nframe()
[10:29:48.987]     ...future.conditions <- base::list()
[10:29:48.987]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:48.987]     if (FALSE) {
[10:29:48.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:48.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:48.987]     }
[10:29:48.987]     ...future.result <- base::tryCatch({
[10:29:48.987]         base::withCallingHandlers({
[10:29:48.987]             ...future.value <- base::withVisible(base::local({
[10:29:48.987]                 withCallingHandlers({
[10:29:48.987]                   {
[10:29:48.987]                     do.call(function(...) {
[10:29:48.987]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.987]                       if (!identical(...future.globals.maxSize.org, 
[10:29:48.987]                         ...future.globals.maxSize)) {
[10:29:48.987]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.987]                         on.exit(options(oopts), add = TRUE)
[10:29:48.987]                       }
[10:29:48.987]                       {
[10:29:48.987]                         lapply(seq_along(...future.elements_ii), 
[10:29:48.987]                           FUN = function(jj) {
[10:29:48.987]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.987]                             ...future.FUN(...future.X_jj, ...)
[10:29:48.987]                           })
[10:29:48.987]                       }
[10:29:48.987]                     }, args = future.call.arguments)
[10:29:48.987]                   }
[10:29:48.987]                 }, immediateCondition = function(cond) {
[10:29:48.987]                   save_rds <- function (object, pathname, ...) 
[10:29:48.987]                   {
[10:29:48.987]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:48.987]                     if (file_test("-f", pathname_tmp)) {
[10:29:48.987]                       fi_tmp <- file.info(pathname_tmp)
[10:29:48.987]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:48.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:48.987]                         fi_tmp[["mtime"]])
[10:29:48.987]                     }
[10:29:48.987]                     tryCatch({
[10:29:48.987]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:48.987]                     }, error = function(ex) {
[10:29:48.987]                       msg <- conditionMessage(ex)
[10:29:48.987]                       fi_tmp <- file.info(pathname_tmp)
[10:29:48.987]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:48.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:48.987]                         fi_tmp[["mtime"]], msg)
[10:29:48.987]                       ex$message <- msg
[10:29:48.987]                       stop(ex)
[10:29:48.987]                     })
[10:29:48.987]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:48.987]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:48.987]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:48.987]                       fi_tmp <- file.info(pathname_tmp)
[10:29:48.987]                       fi <- file.info(pathname)
[10:29:48.987]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:48.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:48.987]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:48.987]                         fi[["size"]], fi[["mtime"]])
[10:29:48.987]                       stop(msg)
[10:29:48.987]                     }
[10:29:48.987]                     invisible(pathname)
[10:29:48.987]                   }
[10:29:48.987]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:48.987]                     rootPath = tempdir()) 
[10:29:48.987]                   {
[10:29:48.987]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:48.987]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:48.987]                       tmpdir = path, fileext = ".rds")
[10:29:48.987]                     save_rds(obj, file)
[10:29:48.987]                   }
[10:29:48.987]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:48.987]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.987]                   {
[10:29:48.987]                     inherits <- base::inherits
[10:29:48.987]                     invokeRestart <- base::invokeRestart
[10:29:48.987]                     is.null <- base::is.null
[10:29:48.987]                     muffled <- FALSE
[10:29:48.987]                     if (inherits(cond, "message")) {
[10:29:48.987]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:48.987]                       if (muffled) 
[10:29:48.987]                         invokeRestart("muffleMessage")
[10:29:48.987]                     }
[10:29:48.987]                     else if (inherits(cond, "warning")) {
[10:29:48.987]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:48.987]                       if (muffled) 
[10:29:48.987]                         invokeRestart("muffleWarning")
[10:29:48.987]                     }
[10:29:48.987]                     else if (inherits(cond, "condition")) {
[10:29:48.987]                       if (!is.null(pattern)) {
[10:29:48.987]                         computeRestarts <- base::computeRestarts
[10:29:48.987]                         grepl <- base::grepl
[10:29:48.987]                         restarts <- computeRestarts(cond)
[10:29:48.987]                         for (restart in restarts) {
[10:29:48.987]                           name <- restart$name
[10:29:48.987]                           if (is.null(name)) 
[10:29:48.987]                             next
[10:29:48.987]                           if (!grepl(pattern, name)) 
[10:29:48.987]                             next
[10:29:48.987]                           invokeRestart(restart)
[10:29:48.987]                           muffled <- TRUE
[10:29:48.987]                           break
[10:29:48.987]                         }
[10:29:48.987]                       }
[10:29:48.987]                     }
[10:29:48.987]                     invisible(muffled)
[10:29:48.987]                   }
[10:29:48.987]                   muffleCondition(cond)
[10:29:48.987]                 })
[10:29:48.987]             }))
[10:29:48.987]             future::FutureResult(value = ...future.value$value, 
[10:29:48.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.987]                   ...future.rng), globalenv = if (FALSE) 
[10:29:48.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:48.987]                     ...future.globalenv.names))
[10:29:48.987]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:48.987]         }, condition = base::local({
[10:29:48.987]             c <- base::c
[10:29:48.987]             inherits <- base::inherits
[10:29:48.987]             invokeRestart <- base::invokeRestart
[10:29:48.987]             length <- base::length
[10:29:48.987]             list <- base::list
[10:29:48.987]             seq.int <- base::seq.int
[10:29:48.987]             signalCondition <- base::signalCondition
[10:29:48.987]             sys.calls <- base::sys.calls
[10:29:48.987]             `[[` <- base::`[[`
[10:29:48.987]             `+` <- base::`+`
[10:29:48.987]             `<<-` <- base::`<<-`
[10:29:48.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:48.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:48.987]                   3L)]
[10:29:48.987]             }
[10:29:48.987]             function(cond) {
[10:29:48.987]                 is_error <- inherits(cond, "error")
[10:29:48.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:48.987]                   NULL)
[10:29:48.987]                 if (is_error) {
[10:29:48.987]                   sessionInformation <- function() {
[10:29:48.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:48.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:48.987]                       search = base::search(), system = base::Sys.info())
[10:29:48.987]                   }
[10:29:48.987]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:48.987]                     cond$call), session = sessionInformation(), 
[10:29:48.987]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:48.987]                   signalCondition(cond)
[10:29:48.987]                 }
[10:29:48.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:48.987]                 "immediateCondition"))) {
[10:29:48.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:48.987]                   ...future.conditions[[length(...future.conditions) + 
[10:29:48.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:48.987]                   if (TRUE && !signal) {
[10:29:48.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.987]                     {
[10:29:48.987]                       inherits <- base::inherits
[10:29:48.987]                       invokeRestart <- base::invokeRestart
[10:29:48.987]                       is.null <- base::is.null
[10:29:48.987]                       muffled <- FALSE
[10:29:48.987]                       if (inherits(cond, "message")) {
[10:29:48.987]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.987]                         if (muffled) 
[10:29:48.987]                           invokeRestart("muffleMessage")
[10:29:48.987]                       }
[10:29:48.987]                       else if (inherits(cond, "warning")) {
[10:29:48.987]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.987]                         if (muffled) 
[10:29:48.987]                           invokeRestart("muffleWarning")
[10:29:48.987]                       }
[10:29:48.987]                       else if (inherits(cond, "condition")) {
[10:29:48.987]                         if (!is.null(pattern)) {
[10:29:48.987]                           computeRestarts <- base::computeRestarts
[10:29:48.987]                           grepl <- base::grepl
[10:29:48.987]                           restarts <- computeRestarts(cond)
[10:29:48.987]                           for (restart in restarts) {
[10:29:48.987]                             name <- restart$name
[10:29:48.987]                             if (is.null(name)) 
[10:29:48.987]                               next
[10:29:48.987]                             if (!grepl(pattern, name)) 
[10:29:48.987]                               next
[10:29:48.987]                             invokeRestart(restart)
[10:29:48.987]                             muffled <- TRUE
[10:29:48.987]                             break
[10:29:48.987]                           }
[10:29:48.987]                         }
[10:29:48.987]                       }
[10:29:48.987]                       invisible(muffled)
[10:29:48.987]                     }
[10:29:48.987]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.987]                   }
[10:29:48.987]                 }
[10:29:48.987]                 else {
[10:29:48.987]                   if (TRUE) {
[10:29:48.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:48.987]                     {
[10:29:48.987]                       inherits <- base::inherits
[10:29:48.987]                       invokeRestart <- base::invokeRestart
[10:29:48.987]                       is.null <- base::is.null
[10:29:48.987]                       muffled <- FALSE
[10:29:48.987]                       if (inherits(cond, "message")) {
[10:29:48.987]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:48.987]                         if (muffled) 
[10:29:48.987]                           invokeRestart("muffleMessage")
[10:29:48.987]                       }
[10:29:48.987]                       else if (inherits(cond, "warning")) {
[10:29:48.987]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:48.987]                         if (muffled) 
[10:29:48.987]                           invokeRestart("muffleWarning")
[10:29:48.987]                       }
[10:29:48.987]                       else if (inherits(cond, "condition")) {
[10:29:48.987]                         if (!is.null(pattern)) {
[10:29:48.987]                           computeRestarts <- base::computeRestarts
[10:29:48.987]                           grepl <- base::grepl
[10:29:48.987]                           restarts <- computeRestarts(cond)
[10:29:48.987]                           for (restart in restarts) {
[10:29:48.987]                             name <- restart$name
[10:29:48.987]                             if (is.null(name)) 
[10:29:48.987]                               next
[10:29:48.987]                             if (!grepl(pattern, name)) 
[10:29:48.987]                               next
[10:29:48.987]                             invokeRestart(restart)
[10:29:48.987]                             muffled <- TRUE
[10:29:48.987]                             break
[10:29:48.987]                           }
[10:29:48.987]                         }
[10:29:48.987]                       }
[10:29:48.987]                       invisible(muffled)
[10:29:48.987]                     }
[10:29:48.987]                     muffleCondition(cond, pattern = "^muffle")
[10:29:48.987]                   }
[10:29:48.987]                 }
[10:29:48.987]             }
[10:29:48.987]         }))
[10:29:48.987]     }, error = function(ex) {
[10:29:48.987]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:48.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:48.987]                 ...future.rng), started = ...future.startTime, 
[10:29:48.987]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:48.987]             version = "1.8"), class = "FutureResult")
[10:29:48.987]     }, finally = {
[10:29:48.987]         if (!identical(...future.workdir, getwd())) 
[10:29:48.987]             setwd(...future.workdir)
[10:29:48.987]         {
[10:29:48.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:48.987]                 ...future.oldOptions$nwarnings <- NULL
[10:29:48.987]             }
[10:29:48.987]             base::options(...future.oldOptions)
[10:29:48.987]             if (.Platform$OS.type == "windows") {
[10:29:48.987]                 old_names <- names(...future.oldEnvVars)
[10:29:48.987]                 envs <- base::Sys.getenv()
[10:29:48.987]                 names <- names(envs)
[10:29:48.987]                 common <- intersect(names, old_names)
[10:29:48.987]                 added <- setdiff(names, old_names)
[10:29:48.987]                 removed <- setdiff(old_names, names)
[10:29:48.987]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:48.987]                   envs[common]]
[10:29:48.987]                 NAMES <- toupper(changed)
[10:29:48.987]                 args <- list()
[10:29:48.987]                 for (kk in seq_along(NAMES)) {
[10:29:48.987]                   name <- changed[[kk]]
[10:29:48.987]                   NAME <- NAMES[[kk]]
[10:29:48.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.987]                     next
[10:29:48.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.987]                 }
[10:29:48.987]                 NAMES <- toupper(added)
[10:29:48.987]                 for (kk in seq_along(NAMES)) {
[10:29:48.987]                   name <- added[[kk]]
[10:29:48.987]                   NAME <- NAMES[[kk]]
[10:29:48.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.987]                     next
[10:29:48.987]                   args[[name]] <- ""
[10:29:48.987]                 }
[10:29:48.987]                 NAMES <- toupper(removed)
[10:29:48.987]                 for (kk in seq_along(NAMES)) {
[10:29:48.987]                   name <- removed[[kk]]
[10:29:48.987]                   NAME <- NAMES[[kk]]
[10:29:48.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:48.987]                     next
[10:29:48.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:48.987]                 }
[10:29:48.987]                 if (length(args) > 0) 
[10:29:48.987]                   base::do.call(base::Sys.setenv, args = args)
[10:29:48.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:48.987]             }
[10:29:48.987]             else {
[10:29:48.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:48.987]             }
[10:29:48.987]             {
[10:29:48.987]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:48.987]                   0L) {
[10:29:48.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:48.987]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:48.987]                   base::options(opts)
[10:29:48.987]                 }
[10:29:48.987]                 {
[10:29:48.987]                   {
[10:29:48.987]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:48.987]                     NULL
[10:29:48.987]                   }
[10:29:48.987]                   options(future.plan = NULL)
[10:29:48.987]                   if (is.na(NA_character_)) 
[10:29:48.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:48.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:48.987]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:48.987]                     .init = FALSE)
[10:29:48.987]                 }
[10:29:48.987]             }
[10:29:48.987]         }
[10:29:48.987]     })
[10:29:48.987]     if (TRUE) {
[10:29:48.987]         base::sink(type = "output", split = FALSE)
[10:29:48.987]         if (TRUE) {
[10:29:48.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:48.987]         }
[10:29:48.987]         else {
[10:29:48.987]             ...future.result["stdout"] <- base::list(NULL)
[10:29:48.987]         }
[10:29:48.987]         base::close(...future.stdout)
[10:29:48.987]         ...future.stdout <- NULL
[10:29:48.987]     }
[10:29:48.987]     ...future.result$conditions <- ...future.conditions
[10:29:48.987]     ...future.result$finished <- base::Sys.time()
[10:29:48.987]     ...future.result
[10:29:48.987] }
[10:29:48.989] assign_globals() ...
[10:29:48.989] List of 5
[10:29:48.989]  $ future.call.arguments    : list()
[10:29:48.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:48.989]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:48.989]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:48.989]  $ ...future.elements_ii    :List of 1
[10:29:48.989]   ..$ : num [1:4] 1 3 1 7
[10:29:48.989]  $ ...future.seeds_ii       : NULL
[10:29:48.989]  $ ...future.globals.maxSize: num Inf
[10:29:48.989]  - attr(*, "resolved")= logi FALSE
[10:29:48.989]  - attr(*, "total_size")= num NA
[10:29:48.989]  - attr(*, "where")=List of 5
[10:29:48.989]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:48.989]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:48.989]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:48.989]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:48.989]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:48.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:48.989]  - attr(*, "already-done")= logi TRUE
[10:29:48.994] - copied ‘future.call.arguments’ to environment
[10:29:48.994] - copied ‘...future.FUN’ to environment
[10:29:48.994] - copied ‘...future.elements_ii’ to environment
[10:29:48.994] - copied ‘...future.seeds_ii’ to environment
[10:29:48.994] - copied ‘...future.globals.maxSize’ to environment
[10:29:48.994] assign_globals() ... done
[10:29:48.994] requestCore(): workers = 2
[10:29:48.997] MulticoreFuture started
[10:29:48.997] - Launch lazy future ... done
[10:29:48.997] run() for ‘MulticoreFuture’ ... done
[10:29:48.997] Created future:
[10:29:48.998] plan(): Setting new future strategy stack:
[10:29:48.998] List of future strategies:
[10:29:48.998] 1. sequential:
[10:29:48.998]    - args: function (..., envir = parent.frame())
[10:29:48.998]    - tweaked: FALSE
[10:29:48.998]    - call: NULL
[10:29:48.999] plan(): nbrOfWorkers() = 1
[10:29:49.001] plan(): Setting new future strategy stack:
[10:29:49.001] List of future strategies:
[10:29:49.001] 1. multicore:
[10:29:49.001]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.001]    - tweaked: FALSE
[10:29:49.001]    - call: plan(strategy)
[10:29:49.007] plan(): nbrOfWorkers() = 2
[10:29:48.998] MulticoreFuture:
[10:29:48.998] Label: ‘future_apply-1’
[10:29:48.998] Expression:
[10:29:48.998] {
[10:29:48.998]     do.call(function(...) {
[10:29:48.998]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:48.998]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:48.998]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:48.998]             on.exit(options(oopts), add = TRUE)
[10:29:48.998]         }
[10:29:48.998]         {
[10:29:48.998]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:48.998]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:48.998]                 ...future.FUN(...future.X_jj, ...)
[10:29:48.998]             })
[10:29:48.998]         }
[10:29:48.998]     }, args = future.call.arguments)
[10:29:48.998] }
[10:29:48.998] Lazy evaluation: FALSE
[10:29:48.998] Asynchronous evaluation: TRUE
[10:29:48.998] Local evaluation: TRUE
[10:29:48.998] Environment: R_GlobalEnv
[10:29:48.998] Capture standard output: TRUE
[10:29:48.998] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:48.998] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:48.998] Packages: <none>
[10:29:48.998] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:48.998] Resolved: TRUE
[10:29:48.998] Value: <not collected>
[10:29:48.998] Conditions captured: <none>
[10:29:48.998] Early signaling: FALSE
[10:29:48.998] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:48.998] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.008] Chunk #1 of 2 ... DONE
[10:29:49.008] Chunk #2 of 2 ...
[10:29:49.008]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.008]  - seeds: <none>
[10:29:49.008]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.009] getGlobalsAndPackages() ...
[10:29:49.009] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.009] Resolving globals: FALSE
[10:29:49.009] Tweak future expression to call with '...' arguments ...
[10:29:49.009] {
[10:29:49.009]     do.call(function(...) {
[10:29:49.009]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.009]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.009]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.009]             on.exit(options(oopts), add = TRUE)
[10:29:49.009]         }
[10:29:49.009]         {
[10:29:49.009]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.009]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.009]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.009]             })
[10:29:49.009]         }
[10:29:49.009]     }, args = future.call.arguments)
[10:29:49.009] }
[10:29:49.010] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.010] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.010] 
[10:29:49.011] getGlobalsAndPackages() ... DONE
[10:29:49.011] run() for ‘Future’ ...
[10:29:49.011] - state: ‘created’
[10:29:49.011] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.016] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.016]   - Field: ‘label’
[10:29:49.017]   - Field: ‘local’
[10:29:49.017]   - Field: ‘owner’
[10:29:49.017]   - Field: ‘envir’
[10:29:49.017]   - Field: ‘workers’
[10:29:49.018]   - Field: ‘packages’
[10:29:49.018]   - Field: ‘gc’
[10:29:49.018]   - Field: ‘job’
[10:29:49.018]   - Field: ‘conditions’
[10:29:49.018]   - Field: ‘expr’
[10:29:49.019]   - Field: ‘uuid’
[10:29:49.019]   - Field: ‘seed’
[10:29:49.019]   - Field: ‘version’
[10:29:49.019]   - Field: ‘result’
[10:29:49.019]   - Field: ‘asynchronous’
[10:29:49.019]   - Field: ‘calls’
[10:29:49.020]   - Field: ‘globals’
[10:29:49.020]   - Field: ‘stdout’
[10:29:49.020]   - Field: ‘earlySignal’
[10:29:49.020]   - Field: ‘lazy’
[10:29:49.020]   - Field: ‘state’
[10:29:49.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.021] - Launch lazy future ...
[10:29:49.021] Packages needed by the future expression (n = 0): <none>
[10:29:49.022] Packages needed by future strategies (n = 0): <none>
[10:29:49.023] {
[10:29:49.023]     {
[10:29:49.023]         {
[10:29:49.023]             ...future.startTime <- base::Sys.time()
[10:29:49.023]             {
[10:29:49.023]                 {
[10:29:49.023]                   {
[10:29:49.023]                     {
[10:29:49.023]                       base::local({
[10:29:49.023]                         has_future <- base::requireNamespace("future", 
[10:29:49.023]                           quietly = TRUE)
[10:29:49.023]                         if (has_future) {
[10:29:49.023]                           ns <- base::getNamespace("future")
[10:29:49.023]                           version <- ns[[".package"]][["version"]]
[10:29:49.023]                           if (is.null(version)) 
[10:29:49.023]                             version <- utils::packageVersion("future")
[10:29:49.023]                         }
[10:29:49.023]                         else {
[10:29:49.023]                           version <- NULL
[10:29:49.023]                         }
[10:29:49.023]                         if (!has_future || version < "1.8.0") {
[10:29:49.023]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.023]                             "", base::R.version$version.string), 
[10:29:49.023]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.023]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.023]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.023]                               "release", "version")], collapse = " "), 
[10:29:49.023]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.023]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.023]                             info)
[10:29:49.023]                           info <- base::paste(info, collapse = "; ")
[10:29:49.023]                           if (!has_future) {
[10:29:49.023]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.023]                               info)
[10:29:49.023]                           }
[10:29:49.023]                           else {
[10:29:49.023]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.023]                               info, version)
[10:29:49.023]                           }
[10:29:49.023]                           base::stop(msg)
[10:29:49.023]                         }
[10:29:49.023]                       })
[10:29:49.023]                     }
[10:29:49.023]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.023]                     base::options(mc.cores = 1L)
[10:29:49.023]                   }
[10:29:49.023]                   ...future.strategy.old <- future::plan("list")
[10:29:49.023]                   options(future.plan = NULL)
[10:29:49.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.023]                 }
[10:29:49.023]                 ...future.workdir <- getwd()
[10:29:49.023]             }
[10:29:49.023]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.023]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.023]         }
[10:29:49.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.023]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.023]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.023]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.023]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.023]             base::names(...future.oldOptions))
[10:29:49.023]     }
[10:29:49.023]     if (FALSE) {
[10:29:49.023]     }
[10:29:49.023]     else {
[10:29:49.023]         if (TRUE) {
[10:29:49.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.023]                 open = "w")
[10:29:49.023]         }
[10:29:49.023]         else {
[10:29:49.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.023]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.023]         }
[10:29:49.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.023]             base::sink(type = "output", split = FALSE)
[10:29:49.023]             base::close(...future.stdout)
[10:29:49.023]         }, add = TRUE)
[10:29:49.023]     }
[10:29:49.023]     ...future.frame <- base::sys.nframe()
[10:29:49.023]     ...future.conditions <- base::list()
[10:29:49.023]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.023]     if (FALSE) {
[10:29:49.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.023]     }
[10:29:49.023]     ...future.result <- base::tryCatch({
[10:29:49.023]         base::withCallingHandlers({
[10:29:49.023]             ...future.value <- base::withVisible(base::local({
[10:29:49.023]                 withCallingHandlers({
[10:29:49.023]                   {
[10:29:49.023]                     do.call(function(...) {
[10:29:49.023]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.023]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.023]                         ...future.globals.maxSize)) {
[10:29:49.023]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.023]                         on.exit(options(oopts), add = TRUE)
[10:29:49.023]                       }
[10:29:49.023]                       {
[10:29:49.023]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.023]                           FUN = function(jj) {
[10:29:49.023]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.023]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.023]                           })
[10:29:49.023]                       }
[10:29:49.023]                     }, args = future.call.arguments)
[10:29:49.023]                   }
[10:29:49.023]                 }, immediateCondition = function(cond) {
[10:29:49.023]                   save_rds <- function (object, pathname, ...) 
[10:29:49.023]                   {
[10:29:49.023]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.023]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.023]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.023]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.023]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.023]                         fi_tmp[["mtime"]])
[10:29:49.023]                     }
[10:29:49.023]                     tryCatch({
[10:29:49.023]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.023]                     }, error = function(ex) {
[10:29:49.023]                       msg <- conditionMessage(ex)
[10:29:49.023]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.023]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.023]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.023]                         fi_tmp[["mtime"]], msg)
[10:29:49.023]                       ex$message <- msg
[10:29:49.023]                       stop(ex)
[10:29:49.023]                     })
[10:29:49.023]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.023]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.023]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.023]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.023]                       fi <- file.info(pathname)
[10:29:49.023]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.023]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.023]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.023]                         fi[["size"]], fi[["mtime"]])
[10:29:49.023]                       stop(msg)
[10:29:49.023]                     }
[10:29:49.023]                     invisible(pathname)
[10:29:49.023]                   }
[10:29:49.023]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.023]                     rootPath = tempdir()) 
[10:29:49.023]                   {
[10:29:49.023]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.023]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.023]                       tmpdir = path, fileext = ".rds")
[10:29:49.023]                     save_rds(obj, file)
[10:29:49.023]                   }
[10:29:49.023]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.023]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.023]                   {
[10:29:49.023]                     inherits <- base::inherits
[10:29:49.023]                     invokeRestart <- base::invokeRestart
[10:29:49.023]                     is.null <- base::is.null
[10:29:49.023]                     muffled <- FALSE
[10:29:49.023]                     if (inherits(cond, "message")) {
[10:29:49.023]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.023]                       if (muffled) 
[10:29:49.023]                         invokeRestart("muffleMessage")
[10:29:49.023]                     }
[10:29:49.023]                     else if (inherits(cond, "warning")) {
[10:29:49.023]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.023]                       if (muffled) 
[10:29:49.023]                         invokeRestart("muffleWarning")
[10:29:49.023]                     }
[10:29:49.023]                     else if (inherits(cond, "condition")) {
[10:29:49.023]                       if (!is.null(pattern)) {
[10:29:49.023]                         computeRestarts <- base::computeRestarts
[10:29:49.023]                         grepl <- base::grepl
[10:29:49.023]                         restarts <- computeRestarts(cond)
[10:29:49.023]                         for (restart in restarts) {
[10:29:49.023]                           name <- restart$name
[10:29:49.023]                           if (is.null(name)) 
[10:29:49.023]                             next
[10:29:49.023]                           if (!grepl(pattern, name)) 
[10:29:49.023]                             next
[10:29:49.023]                           invokeRestart(restart)
[10:29:49.023]                           muffled <- TRUE
[10:29:49.023]                           break
[10:29:49.023]                         }
[10:29:49.023]                       }
[10:29:49.023]                     }
[10:29:49.023]                     invisible(muffled)
[10:29:49.023]                   }
[10:29:49.023]                   muffleCondition(cond)
[10:29:49.023]                 })
[10:29:49.023]             }))
[10:29:49.023]             future::FutureResult(value = ...future.value$value, 
[10:29:49.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.023]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.023]                     ...future.globalenv.names))
[10:29:49.023]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.023]         }, condition = base::local({
[10:29:49.023]             c <- base::c
[10:29:49.023]             inherits <- base::inherits
[10:29:49.023]             invokeRestart <- base::invokeRestart
[10:29:49.023]             length <- base::length
[10:29:49.023]             list <- base::list
[10:29:49.023]             seq.int <- base::seq.int
[10:29:49.023]             signalCondition <- base::signalCondition
[10:29:49.023]             sys.calls <- base::sys.calls
[10:29:49.023]             `[[` <- base::`[[`
[10:29:49.023]             `+` <- base::`+`
[10:29:49.023]             `<<-` <- base::`<<-`
[10:29:49.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.023]                   3L)]
[10:29:49.023]             }
[10:29:49.023]             function(cond) {
[10:29:49.023]                 is_error <- inherits(cond, "error")
[10:29:49.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.023]                   NULL)
[10:29:49.023]                 if (is_error) {
[10:29:49.023]                   sessionInformation <- function() {
[10:29:49.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.023]                       search = base::search(), system = base::Sys.info())
[10:29:49.023]                   }
[10:29:49.023]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.023]                     cond$call), session = sessionInformation(), 
[10:29:49.023]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.023]                   signalCondition(cond)
[10:29:49.023]                 }
[10:29:49.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.023]                 "immediateCondition"))) {
[10:29:49.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.023]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.023]                   if (TRUE && !signal) {
[10:29:49.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.023]                     {
[10:29:49.023]                       inherits <- base::inherits
[10:29:49.023]                       invokeRestart <- base::invokeRestart
[10:29:49.023]                       is.null <- base::is.null
[10:29:49.023]                       muffled <- FALSE
[10:29:49.023]                       if (inherits(cond, "message")) {
[10:29:49.023]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.023]                         if (muffled) 
[10:29:49.023]                           invokeRestart("muffleMessage")
[10:29:49.023]                       }
[10:29:49.023]                       else if (inherits(cond, "warning")) {
[10:29:49.023]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.023]                         if (muffled) 
[10:29:49.023]                           invokeRestart("muffleWarning")
[10:29:49.023]                       }
[10:29:49.023]                       else if (inherits(cond, "condition")) {
[10:29:49.023]                         if (!is.null(pattern)) {
[10:29:49.023]                           computeRestarts <- base::computeRestarts
[10:29:49.023]                           grepl <- base::grepl
[10:29:49.023]                           restarts <- computeRestarts(cond)
[10:29:49.023]                           for (restart in restarts) {
[10:29:49.023]                             name <- restart$name
[10:29:49.023]                             if (is.null(name)) 
[10:29:49.023]                               next
[10:29:49.023]                             if (!grepl(pattern, name)) 
[10:29:49.023]                               next
[10:29:49.023]                             invokeRestart(restart)
[10:29:49.023]                             muffled <- TRUE
[10:29:49.023]                             break
[10:29:49.023]                           }
[10:29:49.023]                         }
[10:29:49.023]                       }
[10:29:49.023]                       invisible(muffled)
[10:29:49.023]                     }
[10:29:49.023]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.023]                   }
[10:29:49.023]                 }
[10:29:49.023]                 else {
[10:29:49.023]                   if (TRUE) {
[10:29:49.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.023]                     {
[10:29:49.023]                       inherits <- base::inherits
[10:29:49.023]                       invokeRestart <- base::invokeRestart
[10:29:49.023]                       is.null <- base::is.null
[10:29:49.023]                       muffled <- FALSE
[10:29:49.023]                       if (inherits(cond, "message")) {
[10:29:49.023]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.023]                         if (muffled) 
[10:29:49.023]                           invokeRestart("muffleMessage")
[10:29:49.023]                       }
[10:29:49.023]                       else if (inherits(cond, "warning")) {
[10:29:49.023]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.023]                         if (muffled) 
[10:29:49.023]                           invokeRestart("muffleWarning")
[10:29:49.023]                       }
[10:29:49.023]                       else if (inherits(cond, "condition")) {
[10:29:49.023]                         if (!is.null(pattern)) {
[10:29:49.023]                           computeRestarts <- base::computeRestarts
[10:29:49.023]                           grepl <- base::grepl
[10:29:49.023]                           restarts <- computeRestarts(cond)
[10:29:49.023]                           for (restart in restarts) {
[10:29:49.023]                             name <- restart$name
[10:29:49.023]                             if (is.null(name)) 
[10:29:49.023]                               next
[10:29:49.023]                             if (!grepl(pattern, name)) 
[10:29:49.023]                               next
[10:29:49.023]                             invokeRestart(restart)
[10:29:49.023]                             muffled <- TRUE
[10:29:49.023]                             break
[10:29:49.023]                           }
[10:29:49.023]                         }
[10:29:49.023]                       }
[10:29:49.023]                       invisible(muffled)
[10:29:49.023]                     }
[10:29:49.023]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.023]                   }
[10:29:49.023]                 }
[10:29:49.023]             }
[10:29:49.023]         }))
[10:29:49.023]     }, error = function(ex) {
[10:29:49.023]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.023]                 ...future.rng), started = ...future.startTime, 
[10:29:49.023]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.023]             version = "1.8"), class = "FutureResult")
[10:29:49.023]     }, finally = {
[10:29:49.023]         if (!identical(...future.workdir, getwd())) 
[10:29:49.023]             setwd(...future.workdir)
[10:29:49.023]         {
[10:29:49.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.023]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.023]             }
[10:29:49.023]             base::options(...future.oldOptions)
[10:29:49.023]             if (.Platform$OS.type == "windows") {
[10:29:49.023]                 old_names <- names(...future.oldEnvVars)
[10:29:49.023]                 envs <- base::Sys.getenv()
[10:29:49.023]                 names <- names(envs)
[10:29:49.023]                 common <- intersect(names, old_names)
[10:29:49.023]                 added <- setdiff(names, old_names)
[10:29:49.023]                 removed <- setdiff(old_names, names)
[10:29:49.023]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.023]                   envs[common]]
[10:29:49.023]                 NAMES <- toupper(changed)
[10:29:49.023]                 args <- list()
[10:29:49.023]                 for (kk in seq_along(NAMES)) {
[10:29:49.023]                   name <- changed[[kk]]
[10:29:49.023]                   NAME <- NAMES[[kk]]
[10:29:49.023]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.023]                     next
[10:29:49.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.023]                 }
[10:29:49.023]                 NAMES <- toupper(added)
[10:29:49.023]                 for (kk in seq_along(NAMES)) {
[10:29:49.023]                   name <- added[[kk]]
[10:29:49.023]                   NAME <- NAMES[[kk]]
[10:29:49.023]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.023]                     next
[10:29:49.023]                   args[[name]] <- ""
[10:29:49.023]                 }
[10:29:49.023]                 NAMES <- toupper(removed)
[10:29:49.023]                 for (kk in seq_along(NAMES)) {
[10:29:49.023]                   name <- removed[[kk]]
[10:29:49.023]                   NAME <- NAMES[[kk]]
[10:29:49.023]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.023]                     next
[10:29:49.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.023]                 }
[10:29:49.023]                 if (length(args) > 0) 
[10:29:49.023]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.023]             }
[10:29:49.023]             else {
[10:29:49.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.023]             }
[10:29:49.023]             {
[10:29:49.023]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.023]                   0L) {
[10:29:49.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.023]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.023]                   base::options(opts)
[10:29:49.023]                 }
[10:29:49.023]                 {
[10:29:49.023]                   {
[10:29:49.023]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.023]                     NULL
[10:29:49.023]                   }
[10:29:49.023]                   options(future.plan = NULL)
[10:29:49.023]                   if (is.na(NA_character_)) 
[10:29:49.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.023]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.023]                     .init = FALSE)
[10:29:49.023]                 }
[10:29:49.023]             }
[10:29:49.023]         }
[10:29:49.023]     })
[10:29:49.023]     if (TRUE) {
[10:29:49.023]         base::sink(type = "output", split = FALSE)
[10:29:49.023]         if (TRUE) {
[10:29:49.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.023]         }
[10:29:49.023]         else {
[10:29:49.023]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.023]         }
[10:29:49.023]         base::close(...future.stdout)
[10:29:49.023]         ...future.stdout <- NULL
[10:29:49.023]     }
[10:29:49.023]     ...future.result$conditions <- ...future.conditions
[10:29:49.023]     ...future.result$finished <- base::Sys.time()
[10:29:49.023]     ...future.result
[10:29:49.023] }
[10:29:49.027] assign_globals() ...
[10:29:49.027] List of 5
[10:29:49.027]  $ future.call.arguments    : list()
[10:29:49.027]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.027]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:49.027]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:49.027]  $ ...future.elements_ii    :List of 1
[10:29:49.027]   ..$ : num [1:4] 2 4 6 8
[10:29:49.027]  $ ...future.seeds_ii       : NULL
[10:29:49.027]  $ ...future.globals.maxSize: num Inf
[10:29:49.027]  - attr(*, "resolved")= logi FALSE
[10:29:49.027]  - attr(*, "total_size")= num NA
[10:29:49.027]  - attr(*, "where")=List of 5
[10:29:49.027]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.027]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.027]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.027]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.027]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.027]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.027]  - attr(*, "already-done")= logi TRUE
[10:29:49.040] - copied ‘future.call.arguments’ to environment
[10:29:49.040] - copied ‘...future.FUN’ to environment
[10:29:49.040] - copied ‘...future.elements_ii’ to environment
[10:29:49.040] - copied ‘...future.seeds_ii’ to environment
[10:29:49.040] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.040] assign_globals() ... done
[10:29:49.041] requestCore(): workers = 2
[10:29:49.043] MulticoreFuture started
[10:29:49.044] - Launch lazy future ... done
[10:29:49.044] run() for ‘MulticoreFuture’ ... done
[10:29:49.044] Created future:
[10:29:49.044] plan(): Setting new future strategy stack:
[10:29:49.045] List of future strategies:
[10:29:49.045] 1. sequential:
[10:29:49.045]    - args: function (..., envir = parent.frame())
[10:29:49.045]    - tweaked: FALSE
[10:29:49.045]    - call: NULL
[10:29:49.046] plan(): nbrOfWorkers() = 1
[10:29:49.049] plan(): Setting new future strategy stack:
[10:29:49.049] List of future strategies:
[10:29:49.049] 1. multicore:
[10:29:49.049]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.049]    - tweaked: FALSE
[10:29:49.049]    - call: plan(strategy)
[10:29:49.055] plan(): nbrOfWorkers() = 2
[10:29:49.044] MulticoreFuture:
[10:29:49.044] Label: ‘future_apply-2’
[10:29:49.044] Expression:
[10:29:49.044] {
[10:29:49.044]     do.call(function(...) {
[10:29:49.044]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.044]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.044]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.044]             on.exit(options(oopts), add = TRUE)
[10:29:49.044]         }
[10:29:49.044]         {
[10:29:49.044]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.044]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.044]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.044]             })
[10:29:49.044]         }
[10:29:49.044]     }, args = future.call.arguments)
[10:29:49.044] }
[10:29:49.044] Lazy evaluation: FALSE
[10:29:49.044] Asynchronous evaluation: TRUE
[10:29:49.044] Local evaluation: TRUE
[10:29:49.044] Environment: R_GlobalEnv
[10:29:49.044] Capture standard output: TRUE
[10:29:49.044] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.044] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.044] Packages: <none>
[10:29:49.044] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.044] Resolved: TRUE
[10:29:49.044] Value: <not collected>
[10:29:49.044] Conditions captured: <none>
[10:29:49.044] Early signaling: FALSE
[10:29:49.044] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.044] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.056] Chunk #2 of 2 ... DONE
[10:29:49.057] Launching 2 futures (chunks) ... DONE
[10:29:49.057] Resolving 2 futures (chunks) ...
[10:29:49.057] resolve() on list ...
[10:29:49.057]  recursive: 0
[10:29:49.057]  length: 2
[10:29:49.058] 
[10:29:49.058] Future #1
[10:29:49.058] result() for MulticoreFuture ...
[10:29:49.059] result() for MulticoreFuture ...
[10:29:49.059] result() for MulticoreFuture ... done
[10:29:49.060] result() for MulticoreFuture ... done
[10:29:49.060] result() for MulticoreFuture ...
[10:29:49.060] result() for MulticoreFuture ... done
[10:29:49.060] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:49.061] - nx: 2
[10:29:49.061] - relay: TRUE
[10:29:49.061] - stdout: TRUE
[10:29:49.061] - signal: TRUE
[10:29:49.061] - resignal: FALSE
[10:29:49.062] - force: TRUE
[10:29:49.062] - relayed: [n=2] FALSE, FALSE
[10:29:49.062] - queued futures: [n=2] FALSE, FALSE
[10:29:49.062]  - until=1
[10:29:49.062]  - relaying element #1
[10:29:49.063] result() for MulticoreFuture ...
[10:29:49.063] result() for MulticoreFuture ... done
[10:29:49.063] result() for MulticoreFuture ...
[10:29:49.063] result() for MulticoreFuture ... done
[10:29:49.064] result() for MulticoreFuture ...
[10:29:49.064] result() for MulticoreFuture ... done
[10:29:49.064] result() for MulticoreFuture ...
[10:29:49.064] result() for MulticoreFuture ... done
[10:29:49.064] - relayed: [n=2] TRUE, FALSE
[10:29:49.064] - queued futures: [n=2] TRUE, FALSE
[10:29:49.064] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:49.065]  length: 1 (resolved future 1)
[10:29:49.065] Future #2
[10:29:49.065] result() for MulticoreFuture ...
[10:29:49.066] result() for MulticoreFuture ...
[10:29:49.066] result() for MulticoreFuture ... done
[10:29:49.066] result() for MulticoreFuture ... done
[10:29:49.066] result() for MulticoreFuture ...
[10:29:49.066] result() for MulticoreFuture ... done
[10:29:49.067] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:49.067] - nx: 2
[10:29:49.067] - relay: TRUE
[10:29:49.067] - stdout: TRUE
[10:29:49.067] - signal: TRUE
[10:29:49.067] - resignal: FALSE
[10:29:49.067] - force: TRUE
[10:29:49.067] - relayed: [n=2] TRUE, FALSE
[10:29:49.067] - queued futures: [n=2] TRUE, FALSE
[10:29:49.068]  - until=2
[10:29:49.068]  - relaying element #2
[10:29:49.068] result() for MulticoreFuture ...
[10:29:49.068] result() for MulticoreFuture ... done
[10:29:49.068] result() for MulticoreFuture ...
[10:29:49.068] result() for MulticoreFuture ... done
[10:29:49.068] result() for MulticoreFuture ...
[10:29:49.068] result() for MulticoreFuture ... done
[10:29:49.069] result() for MulticoreFuture ...
[10:29:49.069] result() for MulticoreFuture ... done
[10:29:49.069] - relayed: [n=2] TRUE, TRUE
[10:29:49.069] - queued futures: [n=2] TRUE, TRUE
[10:29:49.069] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:49.069]  length: 0 (resolved future 2)
[10:29:49.069] Relaying remaining futures
[10:29:49.069] signalConditionsASAP(NULL, pos=0) ...
[10:29:49.070] - nx: 2
[10:29:49.070] - relay: TRUE
[10:29:49.070] - stdout: TRUE
[10:29:49.070] - signal: TRUE
[10:29:49.070] - resignal: FALSE
[10:29:49.070] - force: TRUE
[10:29:49.070] - relayed: [n=2] TRUE, TRUE
[10:29:49.070] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:49.070] - relayed: [n=2] TRUE, TRUE
[10:29:49.071] - queued futures: [n=2] TRUE, TRUE
[10:29:49.071] signalConditionsASAP(NULL, pos=0) ... done
[10:29:49.071] resolve() on list ... DONE
[10:29:49.071] result() for MulticoreFuture ...
[10:29:49.071] result() for MulticoreFuture ... done
[10:29:49.071] result() for MulticoreFuture ...
[10:29:49.071] result() for MulticoreFuture ... done
[10:29:49.071] result() for MulticoreFuture ...
[10:29:49.072] result() for MulticoreFuture ... done
[10:29:49.072] result() for MulticoreFuture ...
[10:29:49.072] result() for MulticoreFuture ... done
[10:29:49.072]  - Number of value chunks collected: 2
[10:29:49.072] Resolving 2 futures (chunks) ... DONE
[10:29:49.072] Reducing values from 2 chunks ...
[10:29:49.072]  - Number of values collected after concatenation: 2
[10:29:49.072]  - Number of values expected: 2
[10:29:49.072] Reducing values from 2 chunks ... DONE
[10:29:49.073] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:29:49.074] getGlobalsAndPackagesXApply() ...
[10:29:49.074]  - future.globals: TRUE
[10:29:49.074] getGlobalsAndPackages() ...
[10:29:49.074] Searching for globals...
[10:29:49.076] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:49.076] Searching for globals ... DONE
[10:29:49.076] Resolving globals: FALSE
[10:29:49.076] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:49.077] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:49.077] - globals: [1] ‘FUN’
[10:29:49.077] - packages: [1] ‘stats’
[10:29:49.077] getGlobalsAndPackages() ... DONE
[10:29:49.077]  - globals found/used: [n=1] ‘FUN’
[10:29:49.077]  - needed namespaces: [n=1] ‘stats’
[10:29:49.078] Finding globals ... DONE
[10:29:49.078]  - use_args: TRUE
[10:29:49.078]  - Getting '...' globals ...
[10:29:49.078] resolve() on list ...
[10:29:49.078]  recursive: 0
[10:29:49.078]  length: 1
[10:29:49.078]  elements: ‘...’
[10:29:49.079]  length: 0 (resolved future 1)
[10:29:49.079] resolve() on list ... DONE
[10:29:49.079]    - '...' content: [n=0] 
[10:29:49.079] List of 1
[10:29:49.079]  $ ...: list()
[10:29:49.079]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.079]  - attr(*, "where")=List of 1
[10:29:49.079]   ..$ ...:<environment: 0x5618a1f5a038> 
[10:29:49.079]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.079]  - attr(*, "resolved")= logi TRUE
[10:29:49.079]  - attr(*, "total_size")= num NA
[10:29:49.086]  - Getting '...' globals ... DONE
[10:29:49.086] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:49.087] List of 2
[10:29:49.087]  $ ...future.FUN:function (x, ...)  
[10:29:49.087]  $ ...          : list()
[10:29:49.087]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.087]  - attr(*, "where")=List of 2
[10:29:49.087]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:49.087]   ..$ ...          :<environment: 0x5618a1f5a038> 
[10:29:49.087]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.087]  - attr(*, "resolved")= logi FALSE
[10:29:49.087]  - attr(*, "total_size")= num 1248
[10:29:49.090] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:49.090] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.093] future_lapply() ...
[10:29:49.097] Number of chunks: 2
[10:29:49.097] getGlobalsAndPackagesXApply() ...
[10:29:49.097]  - future.globals: <name-value list> with names ‘list()’
[10:29:49.098]  - use_args: TRUE
[10:29:49.098] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:49.098] List of 2
[10:29:49.098]  $ ...          : list()
[10:29:49.098]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.098]  $ ...future.FUN:function (x, ...)  
[10:29:49.098]  - attr(*, "where")=List of 2
[10:29:49.098]   ..$ ...          :<environment: 0x5618a1f5a038> 
[10:29:49.098]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:29:49.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.098]  - attr(*, "resolved")= logi FALSE
[10:29:49.098]  - attr(*, "total_size")= num NA
[10:29:49.101] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:49.101] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.101] Number of futures (= number of chunks): 2
[10:29:49.101] Launching 2 futures (chunks) ...
[10:29:49.101] Chunk #1 of 2 ...
[10:29:49.102]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.102]  - seeds: <none>
[10:29:49.102]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.102] getGlobalsAndPackages() ...
[10:29:49.102] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.102] Resolving globals: FALSE
[10:29:49.102] Tweak future expression to call with '...' arguments ...
[10:29:49.102] {
[10:29:49.102]     do.call(function(...) {
[10:29:49.102]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.102]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.102]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.102]             on.exit(options(oopts), add = TRUE)
[10:29:49.102]         }
[10:29:49.102]         {
[10:29:49.102]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.102]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.102]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.102]             })
[10:29:49.102]         }
[10:29:49.102]     }, args = future.call.arguments)
[10:29:49.102] }
[10:29:49.103] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.103] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.103] - packages: [1] ‘stats’
[10:29:49.103] getGlobalsAndPackages() ... DONE
[10:29:49.104] run() for ‘Future’ ...
[10:29:49.104] - state: ‘created’
[10:29:49.104] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.107] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.107] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.108]   - Field: ‘label’
[10:29:49.108]   - Field: ‘local’
[10:29:49.108]   - Field: ‘owner’
[10:29:49.108]   - Field: ‘envir’
[10:29:49.108]   - Field: ‘workers’
[10:29:49.108]   - Field: ‘packages’
[10:29:49.108]   - Field: ‘gc’
[10:29:49.108]   - Field: ‘job’
[10:29:49.108]   - Field: ‘conditions’
[10:29:49.109]   - Field: ‘expr’
[10:29:49.109]   - Field: ‘uuid’
[10:29:49.109]   - Field: ‘seed’
[10:29:49.109]   - Field: ‘version’
[10:29:49.109]   - Field: ‘result’
[10:29:49.109]   - Field: ‘asynchronous’
[10:29:49.109]   - Field: ‘calls’
[10:29:49.109]   - Field: ‘globals’
[10:29:49.109]   - Field: ‘stdout’
[10:29:49.109]   - Field: ‘earlySignal’
[10:29:49.110]   - Field: ‘lazy’
[10:29:49.110]   - Field: ‘state’
[10:29:49.110] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.110] - Launch lazy future ...
[10:29:49.110] Packages needed by the future expression (n = 1): ‘stats’
[10:29:49.110] Packages needed by future strategies (n = 0): <none>
[10:29:49.111] {
[10:29:49.111]     {
[10:29:49.111]         {
[10:29:49.111]             ...future.startTime <- base::Sys.time()
[10:29:49.111]             {
[10:29:49.111]                 {
[10:29:49.111]                   {
[10:29:49.111]                     {
[10:29:49.111]                       {
[10:29:49.111]                         base::local({
[10:29:49.111]                           has_future <- base::requireNamespace("future", 
[10:29:49.111]                             quietly = TRUE)
[10:29:49.111]                           if (has_future) {
[10:29:49.111]                             ns <- base::getNamespace("future")
[10:29:49.111]                             version <- ns[[".package"]][["version"]]
[10:29:49.111]                             if (is.null(version)) 
[10:29:49.111]                               version <- utils::packageVersion("future")
[10:29:49.111]                           }
[10:29:49.111]                           else {
[10:29:49.111]                             version <- NULL
[10:29:49.111]                           }
[10:29:49.111]                           if (!has_future || version < "1.8.0") {
[10:29:49.111]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.111]                               "", base::R.version$version.string), 
[10:29:49.111]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:49.111]                                 base::R.version$platform, 8 * 
[10:29:49.111]                                   base::.Machine$sizeof.pointer), 
[10:29:49.111]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.111]                                 "release", "version")], collapse = " "), 
[10:29:49.111]                               hostname = base::Sys.info()[["nodename"]])
[10:29:49.111]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.111]                               info)
[10:29:49.111]                             info <- base::paste(info, collapse = "; ")
[10:29:49.111]                             if (!has_future) {
[10:29:49.111]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.111]                                 info)
[10:29:49.111]                             }
[10:29:49.111]                             else {
[10:29:49.111]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.111]                                 info, version)
[10:29:49.111]                             }
[10:29:49.111]                             base::stop(msg)
[10:29:49.111]                           }
[10:29:49.111]                         })
[10:29:49.111]                       }
[10:29:49.111]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.111]                       base::options(mc.cores = 1L)
[10:29:49.111]                     }
[10:29:49.111]                     base::local({
[10:29:49.111]                       for (pkg in "stats") {
[10:29:49.111]                         base::loadNamespace(pkg)
[10:29:49.111]                         base::library(pkg, character.only = TRUE)
[10:29:49.111]                       }
[10:29:49.111]                     })
[10:29:49.111]                   }
[10:29:49.111]                   ...future.strategy.old <- future::plan("list")
[10:29:49.111]                   options(future.plan = NULL)
[10:29:49.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.111]                 }
[10:29:49.111]                 ...future.workdir <- getwd()
[10:29:49.111]             }
[10:29:49.111]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.111]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.111]         }
[10:29:49.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.111]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.111]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.111]             base::names(...future.oldOptions))
[10:29:49.111]     }
[10:29:49.111]     if (FALSE) {
[10:29:49.111]     }
[10:29:49.111]     else {
[10:29:49.111]         if (TRUE) {
[10:29:49.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.111]                 open = "w")
[10:29:49.111]         }
[10:29:49.111]         else {
[10:29:49.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.111]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.111]         }
[10:29:49.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.111]             base::sink(type = "output", split = FALSE)
[10:29:49.111]             base::close(...future.stdout)
[10:29:49.111]         }, add = TRUE)
[10:29:49.111]     }
[10:29:49.111]     ...future.frame <- base::sys.nframe()
[10:29:49.111]     ...future.conditions <- base::list()
[10:29:49.111]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.111]     if (FALSE) {
[10:29:49.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.111]     }
[10:29:49.111]     ...future.result <- base::tryCatch({
[10:29:49.111]         base::withCallingHandlers({
[10:29:49.111]             ...future.value <- base::withVisible(base::local({
[10:29:49.111]                 withCallingHandlers({
[10:29:49.111]                   {
[10:29:49.111]                     do.call(function(...) {
[10:29:49.111]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.111]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.111]                         ...future.globals.maxSize)) {
[10:29:49.111]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.111]                         on.exit(options(oopts), add = TRUE)
[10:29:49.111]                       }
[10:29:49.111]                       {
[10:29:49.111]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.111]                           FUN = function(jj) {
[10:29:49.111]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.111]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.111]                           })
[10:29:49.111]                       }
[10:29:49.111]                     }, args = future.call.arguments)
[10:29:49.111]                   }
[10:29:49.111]                 }, immediateCondition = function(cond) {
[10:29:49.111]                   save_rds <- function (object, pathname, ...) 
[10:29:49.111]                   {
[10:29:49.111]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.111]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.111]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.111]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.111]                         fi_tmp[["mtime"]])
[10:29:49.111]                     }
[10:29:49.111]                     tryCatch({
[10:29:49.111]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.111]                     }, error = function(ex) {
[10:29:49.111]                       msg <- conditionMessage(ex)
[10:29:49.111]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.111]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.111]                         fi_tmp[["mtime"]], msg)
[10:29:49.111]                       ex$message <- msg
[10:29:49.111]                       stop(ex)
[10:29:49.111]                     })
[10:29:49.111]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.111]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.111]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.111]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.111]                       fi <- file.info(pathname)
[10:29:49.111]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.111]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.111]                         fi[["size"]], fi[["mtime"]])
[10:29:49.111]                       stop(msg)
[10:29:49.111]                     }
[10:29:49.111]                     invisible(pathname)
[10:29:49.111]                   }
[10:29:49.111]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.111]                     rootPath = tempdir()) 
[10:29:49.111]                   {
[10:29:49.111]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.111]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.111]                       tmpdir = path, fileext = ".rds")
[10:29:49.111]                     save_rds(obj, file)
[10:29:49.111]                   }
[10:29:49.111]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.111]                   {
[10:29:49.111]                     inherits <- base::inherits
[10:29:49.111]                     invokeRestart <- base::invokeRestart
[10:29:49.111]                     is.null <- base::is.null
[10:29:49.111]                     muffled <- FALSE
[10:29:49.111]                     if (inherits(cond, "message")) {
[10:29:49.111]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.111]                       if (muffled) 
[10:29:49.111]                         invokeRestart("muffleMessage")
[10:29:49.111]                     }
[10:29:49.111]                     else if (inherits(cond, "warning")) {
[10:29:49.111]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.111]                       if (muffled) 
[10:29:49.111]                         invokeRestart("muffleWarning")
[10:29:49.111]                     }
[10:29:49.111]                     else if (inherits(cond, "condition")) {
[10:29:49.111]                       if (!is.null(pattern)) {
[10:29:49.111]                         computeRestarts <- base::computeRestarts
[10:29:49.111]                         grepl <- base::grepl
[10:29:49.111]                         restarts <- computeRestarts(cond)
[10:29:49.111]                         for (restart in restarts) {
[10:29:49.111]                           name <- restart$name
[10:29:49.111]                           if (is.null(name)) 
[10:29:49.111]                             next
[10:29:49.111]                           if (!grepl(pattern, name)) 
[10:29:49.111]                             next
[10:29:49.111]                           invokeRestart(restart)
[10:29:49.111]                           muffled <- TRUE
[10:29:49.111]                           break
[10:29:49.111]                         }
[10:29:49.111]                       }
[10:29:49.111]                     }
[10:29:49.111]                     invisible(muffled)
[10:29:49.111]                   }
[10:29:49.111]                   muffleCondition(cond)
[10:29:49.111]                 })
[10:29:49.111]             }))
[10:29:49.111]             future::FutureResult(value = ...future.value$value, 
[10:29:49.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.111]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.111]                     ...future.globalenv.names))
[10:29:49.111]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.111]         }, condition = base::local({
[10:29:49.111]             c <- base::c
[10:29:49.111]             inherits <- base::inherits
[10:29:49.111]             invokeRestart <- base::invokeRestart
[10:29:49.111]             length <- base::length
[10:29:49.111]             list <- base::list
[10:29:49.111]             seq.int <- base::seq.int
[10:29:49.111]             signalCondition <- base::signalCondition
[10:29:49.111]             sys.calls <- base::sys.calls
[10:29:49.111]             `[[` <- base::`[[`
[10:29:49.111]             `+` <- base::`+`
[10:29:49.111]             `<<-` <- base::`<<-`
[10:29:49.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.111]                   3L)]
[10:29:49.111]             }
[10:29:49.111]             function(cond) {
[10:29:49.111]                 is_error <- inherits(cond, "error")
[10:29:49.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.111]                   NULL)
[10:29:49.111]                 if (is_error) {
[10:29:49.111]                   sessionInformation <- function() {
[10:29:49.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.111]                       search = base::search(), system = base::Sys.info())
[10:29:49.111]                   }
[10:29:49.111]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.111]                     cond$call), session = sessionInformation(), 
[10:29:49.111]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.111]                   signalCondition(cond)
[10:29:49.111]                 }
[10:29:49.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.111]                 "immediateCondition"))) {
[10:29:49.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.111]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.111]                   if (TRUE && !signal) {
[10:29:49.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.111]                     {
[10:29:49.111]                       inherits <- base::inherits
[10:29:49.111]                       invokeRestart <- base::invokeRestart
[10:29:49.111]                       is.null <- base::is.null
[10:29:49.111]                       muffled <- FALSE
[10:29:49.111]                       if (inherits(cond, "message")) {
[10:29:49.111]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.111]                         if (muffled) 
[10:29:49.111]                           invokeRestart("muffleMessage")
[10:29:49.111]                       }
[10:29:49.111]                       else if (inherits(cond, "warning")) {
[10:29:49.111]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.111]                         if (muffled) 
[10:29:49.111]                           invokeRestart("muffleWarning")
[10:29:49.111]                       }
[10:29:49.111]                       else if (inherits(cond, "condition")) {
[10:29:49.111]                         if (!is.null(pattern)) {
[10:29:49.111]                           computeRestarts <- base::computeRestarts
[10:29:49.111]                           grepl <- base::grepl
[10:29:49.111]                           restarts <- computeRestarts(cond)
[10:29:49.111]                           for (restart in restarts) {
[10:29:49.111]                             name <- restart$name
[10:29:49.111]                             if (is.null(name)) 
[10:29:49.111]                               next
[10:29:49.111]                             if (!grepl(pattern, name)) 
[10:29:49.111]                               next
[10:29:49.111]                             invokeRestart(restart)
[10:29:49.111]                             muffled <- TRUE
[10:29:49.111]                             break
[10:29:49.111]                           }
[10:29:49.111]                         }
[10:29:49.111]                       }
[10:29:49.111]                       invisible(muffled)
[10:29:49.111]                     }
[10:29:49.111]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.111]                   }
[10:29:49.111]                 }
[10:29:49.111]                 else {
[10:29:49.111]                   if (TRUE) {
[10:29:49.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.111]                     {
[10:29:49.111]                       inherits <- base::inherits
[10:29:49.111]                       invokeRestart <- base::invokeRestart
[10:29:49.111]                       is.null <- base::is.null
[10:29:49.111]                       muffled <- FALSE
[10:29:49.111]                       if (inherits(cond, "message")) {
[10:29:49.111]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.111]                         if (muffled) 
[10:29:49.111]                           invokeRestart("muffleMessage")
[10:29:49.111]                       }
[10:29:49.111]                       else if (inherits(cond, "warning")) {
[10:29:49.111]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.111]                         if (muffled) 
[10:29:49.111]                           invokeRestart("muffleWarning")
[10:29:49.111]                       }
[10:29:49.111]                       else if (inherits(cond, "condition")) {
[10:29:49.111]                         if (!is.null(pattern)) {
[10:29:49.111]                           computeRestarts <- base::computeRestarts
[10:29:49.111]                           grepl <- base::grepl
[10:29:49.111]                           restarts <- computeRestarts(cond)
[10:29:49.111]                           for (restart in restarts) {
[10:29:49.111]                             name <- restart$name
[10:29:49.111]                             if (is.null(name)) 
[10:29:49.111]                               next
[10:29:49.111]                             if (!grepl(pattern, name)) 
[10:29:49.111]                               next
[10:29:49.111]                             invokeRestart(restart)
[10:29:49.111]                             muffled <- TRUE
[10:29:49.111]                             break
[10:29:49.111]                           }
[10:29:49.111]                         }
[10:29:49.111]                       }
[10:29:49.111]                       invisible(muffled)
[10:29:49.111]                     }
[10:29:49.111]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.111]                   }
[10:29:49.111]                 }
[10:29:49.111]             }
[10:29:49.111]         }))
[10:29:49.111]     }, error = function(ex) {
[10:29:49.111]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.111]                 ...future.rng), started = ...future.startTime, 
[10:29:49.111]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.111]             version = "1.8"), class = "FutureResult")
[10:29:49.111]     }, finally = {
[10:29:49.111]         if (!identical(...future.workdir, getwd())) 
[10:29:49.111]             setwd(...future.workdir)
[10:29:49.111]         {
[10:29:49.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.111]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.111]             }
[10:29:49.111]             base::options(...future.oldOptions)
[10:29:49.111]             if (.Platform$OS.type == "windows") {
[10:29:49.111]                 old_names <- names(...future.oldEnvVars)
[10:29:49.111]                 envs <- base::Sys.getenv()
[10:29:49.111]                 names <- names(envs)
[10:29:49.111]                 common <- intersect(names, old_names)
[10:29:49.111]                 added <- setdiff(names, old_names)
[10:29:49.111]                 removed <- setdiff(old_names, names)
[10:29:49.111]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.111]                   envs[common]]
[10:29:49.111]                 NAMES <- toupper(changed)
[10:29:49.111]                 args <- list()
[10:29:49.111]                 for (kk in seq_along(NAMES)) {
[10:29:49.111]                   name <- changed[[kk]]
[10:29:49.111]                   NAME <- NAMES[[kk]]
[10:29:49.111]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.111]                     next
[10:29:49.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.111]                 }
[10:29:49.111]                 NAMES <- toupper(added)
[10:29:49.111]                 for (kk in seq_along(NAMES)) {
[10:29:49.111]                   name <- added[[kk]]
[10:29:49.111]                   NAME <- NAMES[[kk]]
[10:29:49.111]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.111]                     next
[10:29:49.111]                   args[[name]] <- ""
[10:29:49.111]                 }
[10:29:49.111]                 NAMES <- toupper(removed)
[10:29:49.111]                 for (kk in seq_along(NAMES)) {
[10:29:49.111]                   name <- removed[[kk]]
[10:29:49.111]                   NAME <- NAMES[[kk]]
[10:29:49.111]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.111]                     next
[10:29:49.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.111]                 }
[10:29:49.111]                 if (length(args) > 0) 
[10:29:49.111]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.111]             }
[10:29:49.111]             else {
[10:29:49.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.111]             }
[10:29:49.111]             {
[10:29:49.111]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.111]                   0L) {
[10:29:49.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.111]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.111]                   base::options(opts)
[10:29:49.111]                 }
[10:29:49.111]                 {
[10:29:49.111]                   {
[10:29:49.111]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.111]                     NULL
[10:29:49.111]                   }
[10:29:49.111]                   options(future.plan = NULL)
[10:29:49.111]                   if (is.na(NA_character_)) 
[10:29:49.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.111]                     .init = FALSE)
[10:29:49.111]                 }
[10:29:49.111]             }
[10:29:49.111]         }
[10:29:49.111]     })
[10:29:49.111]     if (TRUE) {
[10:29:49.111]         base::sink(type = "output", split = FALSE)
[10:29:49.111]         if (TRUE) {
[10:29:49.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.111]         }
[10:29:49.111]         else {
[10:29:49.111]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.111]         }
[10:29:49.111]         base::close(...future.stdout)
[10:29:49.111]         ...future.stdout <- NULL
[10:29:49.111]     }
[10:29:49.111]     ...future.result$conditions <- ...future.conditions
[10:29:49.111]     ...future.result$finished <- base::Sys.time()
[10:29:49.111]     ...future.result
[10:29:49.111] }
[10:29:49.113] assign_globals() ...
[10:29:49.113] List of 5
[10:29:49.113]  $ future.call.arguments    : list()
[10:29:49.113]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.113]  $ ...future.FUN            :function (x, ...)  
[10:29:49.113]  $ ...future.elements_ii    :List of 1
[10:29:49.113]   ..$ : num [1:4] 1 3 1 7
[10:29:49.113]  $ ...future.seeds_ii       : NULL
[10:29:49.113]  $ ...future.globals.maxSize: num Inf
[10:29:49.113]  - attr(*, "resolved")= logi FALSE
[10:29:49.113]  - attr(*, "total_size")= num NA
[10:29:49.113]  - attr(*, "where")=List of 5
[10:29:49.113]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.113]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.113]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.113]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.113]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.113]  - attr(*, "already-done")= logi TRUE
[10:29:49.121] - copied ‘future.call.arguments’ to environment
[10:29:49.121] - copied ‘...future.FUN’ to environment
[10:29:49.121] - copied ‘...future.elements_ii’ to environment
[10:29:49.121] - copied ‘...future.seeds_ii’ to environment
[10:29:49.121] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.121] assign_globals() ... done
[10:29:49.121] requestCore(): workers = 2
[10:29:49.124] MulticoreFuture started
[10:29:49.124] - Launch lazy future ... done
[10:29:49.124] run() for ‘MulticoreFuture’ ... done
[10:29:49.125] Created future:
[10:29:49.125] plan(): Setting new future strategy stack:
[10:29:49.126] List of future strategies:
[10:29:49.126] 1. sequential:
[10:29:49.126]    - args: function (..., envir = parent.frame())
[10:29:49.126]    - tweaked: FALSE
[10:29:49.126]    - call: NULL
[10:29:49.126] plan(): nbrOfWorkers() = 1
[10:29:49.130] plan(): Setting new future strategy stack:
[10:29:49.130] List of future strategies:
[10:29:49.130] 1. multicore:
[10:29:49.130]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.130]    - tweaked: FALSE
[10:29:49.130]    - call: plan(strategy)
[10:29:49.135] plan(): nbrOfWorkers() = 2
[10:29:49.125] MulticoreFuture:
[10:29:49.125] Label: ‘future_apply-1’
[10:29:49.125] Expression:
[10:29:49.125] {
[10:29:49.125]     do.call(function(...) {
[10:29:49.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.125]             on.exit(options(oopts), add = TRUE)
[10:29:49.125]         }
[10:29:49.125]         {
[10:29:49.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.125]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.125]             })
[10:29:49.125]         }
[10:29:49.125]     }, args = future.call.arguments)
[10:29:49.125] }
[10:29:49.125] Lazy evaluation: FALSE
[10:29:49.125] Asynchronous evaluation: TRUE
[10:29:49.125] Local evaluation: TRUE
[10:29:49.125] Environment: R_GlobalEnv
[10:29:49.125] Capture standard output: TRUE
[10:29:49.125] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.125] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.125] Packages: 1 packages (‘stats’)
[10:29:49.125] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.125] Resolved: TRUE
[10:29:49.125] Value: <not collected>
[10:29:49.125] Conditions captured: <none>
[10:29:49.125] Early signaling: FALSE
[10:29:49.125] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.125] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.137] Chunk #1 of 2 ... DONE
[10:29:49.137] Chunk #2 of 2 ...
[10:29:49.137]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.137]  - seeds: <none>
[10:29:49.138]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.138] getGlobalsAndPackages() ...
[10:29:49.138] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.138] Resolving globals: FALSE
[10:29:49.138] Tweak future expression to call with '...' arguments ...
[10:29:49.139] {
[10:29:49.139]     do.call(function(...) {
[10:29:49.139]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.139]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.139]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.139]             on.exit(options(oopts), add = TRUE)
[10:29:49.139]         }
[10:29:49.139]         {
[10:29:49.139]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.139]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.139]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.139]             })
[10:29:49.139]         }
[10:29:49.139]     }, args = future.call.arguments)
[10:29:49.139] }
[10:29:49.139] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.140] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.140] - packages: [1] ‘stats’
[10:29:49.140] getGlobalsAndPackages() ... DONE
[10:29:49.141] run() for ‘Future’ ...
[10:29:49.141] - state: ‘created’
[10:29:49.141] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.146] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.146]   - Field: ‘label’
[10:29:49.147]   - Field: ‘local’
[10:29:49.147]   - Field: ‘owner’
[10:29:49.147]   - Field: ‘envir’
[10:29:49.147]   - Field: ‘workers’
[10:29:49.147]   - Field: ‘packages’
[10:29:49.147]   - Field: ‘gc’
[10:29:49.147]   - Field: ‘job’
[10:29:49.148]   - Field: ‘conditions’
[10:29:49.148]   - Field: ‘expr’
[10:29:49.148]   - Field: ‘uuid’
[10:29:49.148]   - Field: ‘seed’
[10:29:49.148]   - Field: ‘version’
[10:29:49.148]   - Field: ‘result’
[10:29:49.149]   - Field: ‘asynchronous’
[10:29:49.149]   - Field: ‘calls’
[10:29:49.149]   - Field: ‘globals’
[10:29:49.149]   - Field: ‘stdout’
[10:29:49.149]   - Field: ‘earlySignal’
[10:29:49.149]   - Field: ‘lazy’
[10:29:49.149]   - Field: ‘state’
[10:29:49.150] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.150] - Launch lazy future ...
[10:29:49.150] Packages needed by the future expression (n = 1): ‘stats’
[10:29:49.150] Packages needed by future strategies (n = 0): <none>
[10:29:49.151] {
[10:29:49.151]     {
[10:29:49.151]         {
[10:29:49.151]             ...future.startTime <- base::Sys.time()
[10:29:49.151]             {
[10:29:49.151]                 {
[10:29:49.151]                   {
[10:29:49.151]                     {
[10:29:49.151]                       {
[10:29:49.151]                         base::local({
[10:29:49.151]                           has_future <- base::requireNamespace("future", 
[10:29:49.151]                             quietly = TRUE)
[10:29:49.151]                           if (has_future) {
[10:29:49.151]                             ns <- base::getNamespace("future")
[10:29:49.151]                             version <- ns[[".package"]][["version"]]
[10:29:49.151]                             if (is.null(version)) 
[10:29:49.151]                               version <- utils::packageVersion("future")
[10:29:49.151]                           }
[10:29:49.151]                           else {
[10:29:49.151]                             version <- NULL
[10:29:49.151]                           }
[10:29:49.151]                           if (!has_future || version < "1.8.0") {
[10:29:49.151]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.151]                               "", base::R.version$version.string), 
[10:29:49.151]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:49.151]                                 base::R.version$platform, 8 * 
[10:29:49.151]                                   base::.Machine$sizeof.pointer), 
[10:29:49.151]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.151]                                 "release", "version")], collapse = " "), 
[10:29:49.151]                               hostname = base::Sys.info()[["nodename"]])
[10:29:49.151]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.151]                               info)
[10:29:49.151]                             info <- base::paste(info, collapse = "; ")
[10:29:49.151]                             if (!has_future) {
[10:29:49.151]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.151]                                 info)
[10:29:49.151]                             }
[10:29:49.151]                             else {
[10:29:49.151]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.151]                                 info, version)
[10:29:49.151]                             }
[10:29:49.151]                             base::stop(msg)
[10:29:49.151]                           }
[10:29:49.151]                         })
[10:29:49.151]                       }
[10:29:49.151]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.151]                       base::options(mc.cores = 1L)
[10:29:49.151]                     }
[10:29:49.151]                     base::local({
[10:29:49.151]                       for (pkg in "stats") {
[10:29:49.151]                         base::loadNamespace(pkg)
[10:29:49.151]                         base::library(pkg, character.only = TRUE)
[10:29:49.151]                       }
[10:29:49.151]                     })
[10:29:49.151]                   }
[10:29:49.151]                   ...future.strategy.old <- future::plan("list")
[10:29:49.151]                   options(future.plan = NULL)
[10:29:49.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.151]                 }
[10:29:49.151]                 ...future.workdir <- getwd()
[10:29:49.151]             }
[10:29:49.151]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.151]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.151]         }
[10:29:49.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.151]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.151]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.151]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.151]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.151]             base::names(...future.oldOptions))
[10:29:49.151]     }
[10:29:49.151]     if (FALSE) {
[10:29:49.151]     }
[10:29:49.151]     else {
[10:29:49.151]         if (TRUE) {
[10:29:49.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.151]                 open = "w")
[10:29:49.151]         }
[10:29:49.151]         else {
[10:29:49.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.151]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.151]         }
[10:29:49.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.151]             base::sink(type = "output", split = FALSE)
[10:29:49.151]             base::close(...future.stdout)
[10:29:49.151]         }, add = TRUE)
[10:29:49.151]     }
[10:29:49.151]     ...future.frame <- base::sys.nframe()
[10:29:49.151]     ...future.conditions <- base::list()
[10:29:49.151]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.151]     if (FALSE) {
[10:29:49.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.151]     }
[10:29:49.151]     ...future.result <- base::tryCatch({
[10:29:49.151]         base::withCallingHandlers({
[10:29:49.151]             ...future.value <- base::withVisible(base::local({
[10:29:49.151]                 withCallingHandlers({
[10:29:49.151]                   {
[10:29:49.151]                     do.call(function(...) {
[10:29:49.151]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.151]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.151]                         ...future.globals.maxSize)) {
[10:29:49.151]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.151]                         on.exit(options(oopts), add = TRUE)
[10:29:49.151]                       }
[10:29:49.151]                       {
[10:29:49.151]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.151]                           FUN = function(jj) {
[10:29:49.151]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.151]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.151]                           })
[10:29:49.151]                       }
[10:29:49.151]                     }, args = future.call.arguments)
[10:29:49.151]                   }
[10:29:49.151]                 }, immediateCondition = function(cond) {
[10:29:49.151]                   save_rds <- function (object, pathname, ...) 
[10:29:49.151]                   {
[10:29:49.151]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.151]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.151]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.151]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.151]                         fi_tmp[["mtime"]])
[10:29:49.151]                     }
[10:29:49.151]                     tryCatch({
[10:29:49.151]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.151]                     }, error = function(ex) {
[10:29:49.151]                       msg <- conditionMessage(ex)
[10:29:49.151]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.151]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.151]                         fi_tmp[["mtime"]], msg)
[10:29:49.151]                       ex$message <- msg
[10:29:49.151]                       stop(ex)
[10:29:49.151]                     })
[10:29:49.151]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.151]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.151]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.151]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.151]                       fi <- file.info(pathname)
[10:29:49.151]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.151]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.151]                         fi[["size"]], fi[["mtime"]])
[10:29:49.151]                       stop(msg)
[10:29:49.151]                     }
[10:29:49.151]                     invisible(pathname)
[10:29:49.151]                   }
[10:29:49.151]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.151]                     rootPath = tempdir()) 
[10:29:49.151]                   {
[10:29:49.151]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.151]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.151]                       tmpdir = path, fileext = ".rds")
[10:29:49.151]                     save_rds(obj, file)
[10:29:49.151]                   }
[10:29:49.151]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.151]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.151]                   {
[10:29:49.151]                     inherits <- base::inherits
[10:29:49.151]                     invokeRestart <- base::invokeRestart
[10:29:49.151]                     is.null <- base::is.null
[10:29:49.151]                     muffled <- FALSE
[10:29:49.151]                     if (inherits(cond, "message")) {
[10:29:49.151]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.151]                       if (muffled) 
[10:29:49.151]                         invokeRestart("muffleMessage")
[10:29:49.151]                     }
[10:29:49.151]                     else if (inherits(cond, "warning")) {
[10:29:49.151]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.151]                       if (muffled) 
[10:29:49.151]                         invokeRestart("muffleWarning")
[10:29:49.151]                     }
[10:29:49.151]                     else if (inherits(cond, "condition")) {
[10:29:49.151]                       if (!is.null(pattern)) {
[10:29:49.151]                         computeRestarts <- base::computeRestarts
[10:29:49.151]                         grepl <- base::grepl
[10:29:49.151]                         restarts <- computeRestarts(cond)
[10:29:49.151]                         for (restart in restarts) {
[10:29:49.151]                           name <- restart$name
[10:29:49.151]                           if (is.null(name)) 
[10:29:49.151]                             next
[10:29:49.151]                           if (!grepl(pattern, name)) 
[10:29:49.151]                             next
[10:29:49.151]                           invokeRestart(restart)
[10:29:49.151]                           muffled <- TRUE
[10:29:49.151]                           break
[10:29:49.151]                         }
[10:29:49.151]                       }
[10:29:49.151]                     }
[10:29:49.151]                     invisible(muffled)
[10:29:49.151]                   }
[10:29:49.151]                   muffleCondition(cond)
[10:29:49.151]                 })
[10:29:49.151]             }))
[10:29:49.151]             future::FutureResult(value = ...future.value$value, 
[10:29:49.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.151]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.151]                     ...future.globalenv.names))
[10:29:49.151]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.151]         }, condition = base::local({
[10:29:49.151]             c <- base::c
[10:29:49.151]             inherits <- base::inherits
[10:29:49.151]             invokeRestart <- base::invokeRestart
[10:29:49.151]             length <- base::length
[10:29:49.151]             list <- base::list
[10:29:49.151]             seq.int <- base::seq.int
[10:29:49.151]             signalCondition <- base::signalCondition
[10:29:49.151]             sys.calls <- base::sys.calls
[10:29:49.151]             `[[` <- base::`[[`
[10:29:49.151]             `+` <- base::`+`
[10:29:49.151]             `<<-` <- base::`<<-`
[10:29:49.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.151]                   3L)]
[10:29:49.151]             }
[10:29:49.151]             function(cond) {
[10:29:49.151]                 is_error <- inherits(cond, "error")
[10:29:49.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.151]                   NULL)
[10:29:49.151]                 if (is_error) {
[10:29:49.151]                   sessionInformation <- function() {
[10:29:49.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.151]                       search = base::search(), system = base::Sys.info())
[10:29:49.151]                   }
[10:29:49.151]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.151]                     cond$call), session = sessionInformation(), 
[10:29:49.151]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.151]                   signalCondition(cond)
[10:29:49.151]                 }
[10:29:49.151]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.151]                 "immediateCondition"))) {
[10:29:49.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.151]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.151]                   if (TRUE && !signal) {
[10:29:49.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.151]                     {
[10:29:49.151]                       inherits <- base::inherits
[10:29:49.151]                       invokeRestart <- base::invokeRestart
[10:29:49.151]                       is.null <- base::is.null
[10:29:49.151]                       muffled <- FALSE
[10:29:49.151]                       if (inherits(cond, "message")) {
[10:29:49.151]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.151]                         if (muffled) 
[10:29:49.151]                           invokeRestart("muffleMessage")
[10:29:49.151]                       }
[10:29:49.151]                       else if (inherits(cond, "warning")) {
[10:29:49.151]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.151]                         if (muffled) 
[10:29:49.151]                           invokeRestart("muffleWarning")
[10:29:49.151]                       }
[10:29:49.151]                       else if (inherits(cond, "condition")) {
[10:29:49.151]                         if (!is.null(pattern)) {
[10:29:49.151]                           computeRestarts <- base::computeRestarts
[10:29:49.151]                           grepl <- base::grepl
[10:29:49.151]                           restarts <- computeRestarts(cond)
[10:29:49.151]                           for (restart in restarts) {
[10:29:49.151]                             name <- restart$name
[10:29:49.151]                             if (is.null(name)) 
[10:29:49.151]                               next
[10:29:49.151]                             if (!grepl(pattern, name)) 
[10:29:49.151]                               next
[10:29:49.151]                             invokeRestart(restart)
[10:29:49.151]                             muffled <- TRUE
[10:29:49.151]                             break
[10:29:49.151]                           }
[10:29:49.151]                         }
[10:29:49.151]                       }
[10:29:49.151]                       invisible(muffled)
[10:29:49.151]                     }
[10:29:49.151]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.151]                   }
[10:29:49.151]                 }
[10:29:49.151]                 else {
[10:29:49.151]                   if (TRUE) {
[10:29:49.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.151]                     {
[10:29:49.151]                       inherits <- base::inherits
[10:29:49.151]                       invokeRestart <- base::invokeRestart
[10:29:49.151]                       is.null <- base::is.null
[10:29:49.151]                       muffled <- FALSE
[10:29:49.151]                       if (inherits(cond, "message")) {
[10:29:49.151]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.151]                         if (muffled) 
[10:29:49.151]                           invokeRestart("muffleMessage")
[10:29:49.151]                       }
[10:29:49.151]                       else if (inherits(cond, "warning")) {
[10:29:49.151]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.151]                         if (muffled) 
[10:29:49.151]                           invokeRestart("muffleWarning")
[10:29:49.151]                       }
[10:29:49.151]                       else if (inherits(cond, "condition")) {
[10:29:49.151]                         if (!is.null(pattern)) {
[10:29:49.151]                           computeRestarts <- base::computeRestarts
[10:29:49.151]                           grepl <- base::grepl
[10:29:49.151]                           restarts <- computeRestarts(cond)
[10:29:49.151]                           for (restart in restarts) {
[10:29:49.151]                             name <- restart$name
[10:29:49.151]                             if (is.null(name)) 
[10:29:49.151]                               next
[10:29:49.151]                             if (!grepl(pattern, name)) 
[10:29:49.151]                               next
[10:29:49.151]                             invokeRestart(restart)
[10:29:49.151]                             muffled <- TRUE
[10:29:49.151]                             break
[10:29:49.151]                           }
[10:29:49.151]                         }
[10:29:49.151]                       }
[10:29:49.151]                       invisible(muffled)
[10:29:49.151]                     }
[10:29:49.151]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.151]                   }
[10:29:49.151]                 }
[10:29:49.151]             }
[10:29:49.151]         }))
[10:29:49.151]     }, error = function(ex) {
[10:29:49.151]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.151]                 ...future.rng), started = ...future.startTime, 
[10:29:49.151]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.151]             version = "1.8"), class = "FutureResult")
[10:29:49.151]     }, finally = {
[10:29:49.151]         if (!identical(...future.workdir, getwd())) 
[10:29:49.151]             setwd(...future.workdir)
[10:29:49.151]         {
[10:29:49.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.151]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.151]             }
[10:29:49.151]             base::options(...future.oldOptions)
[10:29:49.151]             if (.Platform$OS.type == "windows") {
[10:29:49.151]                 old_names <- names(...future.oldEnvVars)
[10:29:49.151]                 envs <- base::Sys.getenv()
[10:29:49.151]                 names <- names(envs)
[10:29:49.151]                 common <- intersect(names, old_names)
[10:29:49.151]                 added <- setdiff(names, old_names)
[10:29:49.151]                 removed <- setdiff(old_names, names)
[10:29:49.151]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.151]                   envs[common]]
[10:29:49.151]                 NAMES <- toupper(changed)
[10:29:49.151]                 args <- list()
[10:29:49.151]                 for (kk in seq_along(NAMES)) {
[10:29:49.151]                   name <- changed[[kk]]
[10:29:49.151]                   NAME <- NAMES[[kk]]
[10:29:49.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.151]                     next
[10:29:49.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.151]                 }
[10:29:49.151]                 NAMES <- toupper(added)
[10:29:49.151]                 for (kk in seq_along(NAMES)) {
[10:29:49.151]                   name <- added[[kk]]
[10:29:49.151]                   NAME <- NAMES[[kk]]
[10:29:49.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.151]                     next
[10:29:49.151]                   args[[name]] <- ""
[10:29:49.151]                 }
[10:29:49.151]                 NAMES <- toupper(removed)
[10:29:49.151]                 for (kk in seq_along(NAMES)) {
[10:29:49.151]                   name <- removed[[kk]]
[10:29:49.151]                   NAME <- NAMES[[kk]]
[10:29:49.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.151]                     next
[10:29:49.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.151]                 }
[10:29:49.151]                 if (length(args) > 0) 
[10:29:49.151]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.151]             }
[10:29:49.151]             else {
[10:29:49.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.151]             }
[10:29:49.151]             {
[10:29:49.151]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.151]                   0L) {
[10:29:49.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.151]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.151]                   base::options(opts)
[10:29:49.151]                 }
[10:29:49.151]                 {
[10:29:49.151]                   {
[10:29:49.151]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.151]                     NULL
[10:29:49.151]                   }
[10:29:49.151]                   options(future.plan = NULL)
[10:29:49.151]                   if (is.na(NA_character_)) 
[10:29:49.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.151]                     .init = FALSE)
[10:29:49.151]                 }
[10:29:49.151]             }
[10:29:49.151]         }
[10:29:49.151]     })
[10:29:49.151]     if (TRUE) {
[10:29:49.151]         base::sink(type = "output", split = FALSE)
[10:29:49.151]         if (TRUE) {
[10:29:49.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.151]         }
[10:29:49.151]         else {
[10:29:49.151]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.151]         }
[10:29:49.151]         base::close(...future.stdout)
[10:29:49.151]         ...future.stdout <- NULL
[10:29:49.151]     }
[10:29:49.151]     ...future.result$conditions <- ...future.conditions
[10:29:49.151]     ...future.result$finished <- base::Sys.time()
[10:29:49.151]     ...future.result
[10:29:49.151] }
[10:29:49.155] assign_globals() ...
[10:29:49.155] List of 5
[10:29:49.155]  $ future.call.arguments    : list()
[10:29:49.155]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.155]  $ ...future.FUN            :function (x, ...)  
[10:29:49.155]  $ ...future.elements_ii    :List of 1
[10:29:49.155]   ..$ : num [1:4] 2 4 6 8
[10:29:49.155]  $ ...future.seeds_ii       : NULL
[10:29:49.155]  $ ...future.globals.maxSize: num Inf
[10:29:49.155]  - attr(*, "resolved")= logi FALSE
[10:29:49.155]  - attr(*, "total_size")= num NA
[10:29:49.155]  - attr(*, "where")=List of 5
[10:29:49.155]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.155]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.155]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.155]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.155]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.155]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.155]  - attr(*, "already-done")= logi TRUE
[10:29:49.162] - copied ‘future.call.arguments’ to environment
[10:29:49.162] - copied ‘...future.FUN’ to environment
[10:29:49.163] - copied ‘...future.elements_ii’ to environment
[10:29:49.163] - copied ‘...future.seeds_ii’ to environment
[10:29:49.163] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.163] assign_globals() ... done
[10:29:49.163] requestCore(): workers = 2
[10:29:49.166] MulticoreFuture started
[10:29:49.166] - Launch lazy future ... done
[10:29:49.166] run() for ‘MulticoreFuture’ ... done
[10:29:49.167] Created future:
[10:29:49.167] plan(): Setting new future strategy stack:
[10:29:49.167] List of future strategies:
[10:29:49.167] 1. sequential:
[10:29:49.167]    - args: function (..., envir = parent.frame())
[10:29:49.167]    - tweaked: FALSE
[10:29:49.167]    - call: NULL
[10:29:49.168] plan(): nbrOfWorkers() = 1
[10:29:49.175] plan(): Setting new future strategy stack:
[10:29:49.175] List of future strategies:
[10:29:49.175] 1. multicore:
[10:29:49.175]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.175]    - tweaked: FALSE
[10:29:49.175]    - call: plan(strategy)
[10:29:49.182] plan(): nbrOfWorkers() = 2
[10:29:49.167] MulticoreFuture:
[10:29:49.167] Label: ‘future_apply-2’
[10:29:49.167] Expression:
[10:29:49.167] {
[10:29:49.167]     do.call(function(...) {
[10:29:49.167]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.167]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.167]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.167]             on.exit(options(oopts), add = TRUE)
[10:29:49.167]         }
[10:29:49.167]         {
[10:29:49.167]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.167]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.167]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.167]             })
[10:29:49.167]         }
[10:29:49.167]     }, args = future.call.arguments)
[10:29:49.167] }
[10:29:49.167] Lazy evaluation: FALSE
[10:29:49.167] Asynchronous evaluation: TRUE
[10:29:49.167] Local evaluation: TRUE
[10:29:49.167] Environment: R_GlobalEnv
[10:29:49.167] Capture standard output: TRUE
[10:29:49.167] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.167] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.167] Packages: 1 packages (‘stats’)
[10:29:49.167] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.167] Resolved: TRUE
[10:29:49.167] Value: <not collected>
[10:29:49.167] Conditions captured: <none>
[10:29:49.167] Early signaling: FALSE
[10:29:49.167] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.167] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.183] Chunk #2 of 2 ... DONE
[10:29:49.184] Launching 2 futures (chunks) ... DONE
[10:29:49.184] Resolving 2 futures (chunks) ...
[10:29:49.184] resolve() on list ...
[10:29:49.185]  recursive: 0
[10:29:49.185]  length: 2
[10:29:49.185] 
[10:29:49.186] Future #1
[10:29:49.186] result() for MulticoreFuture ...
[10:29:49.187] result() for MulticoreFuture ...
[10:29:49.187] result() for MulticoreFuture ... done
[10:29:49.188] result() for MulticoreFuture ... done
[10:29:49.188] result() for MulticoreFuture ...
[10:29:49.188] result() for MulticoreFuture ... done
[10:29:49.189] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:49.189] - nx: 2
[10:29:49.190] - relay: TRUE
[10:29:49.190] - stdout: TRUE
[10:29:49.190] - signal: TRUE
[10:29:49.190] - resignal: FALSE
[10:29:49.191] - force: TRUE
[10:29:49.191] - relayed: [n=2] FALSE, FALSE
[10:29:49.191] - queued futures: [n=2] FALSE, FALSE
[10:29:49.192]  - until=1
[10:29:49.192]  - relaying element #1
[10:29:49.192] result() for MulticoreFuture ...
[10:29:49.192] result() for MulticoreFuture ... done
[10:29:49.192] result() for MulticoreFuture ...
[10:29:49.192] result() for MulticoreFuture ... done
[10:29:49.193] result() for MulticoreFuture ...
[10:29:49.193] result() for MulticoreFuture ... done
[10:29:49.193] result() for MulticoreFuture ...
[10:29:49.193] result() for MulticoreFuture ... done
[10:29:49.193] - relayed: [n=2] TRUE, FALSE
[10:29:49.193] - queued futures: [n=2] TRUE, FALSE
[10:29:49.193] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:49.194]  length: 1 (resolved future 1)
[10:29:49.194] Future #2
[10:29:49.194] result() for MulticoreFuture ...
[10:29:49.195] result() for MulticoreFuture ...
[10:29:49.195] result() for MulticoreFuture ... done
[10:29:49.195] result() for MulticoreFuture ... done
[10:29:49.196] result() for MulticoreFuture ...
[10:29:49.196] result() for MulticoreFuture ... done
[10:29:49.196] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:49.196] - nx: 2
[10:29:49.196] - relay: TRUE
[10:29:49.196] - stdout: TRUE
[10:29:49.196] - signal: TRUE
[10:29:49.197] - resignal: FALSE
[10:29:49.197] - force: TRUE
[10:29:49.197] - relayed: [n=2] TRUE, FALSE
[10:29:49.197] - queued futures: [n=2] TRUE, FALSE
[10:29:49.197]  - until=2
[10:29:49.197]  - relaying element #2
[10:29:49.197] result() for MulticoreFuture ...
[10:29:49.197] result() for MulticoreFuture ... done
[10:29:49.197] result() for MulticoreFuture ...
[10:29:49.198] result() for MulticoreFuture ... done
[10:29:49.198] result() for MulticoreFuture ...
[10:29:49.198] result() for MulticoreFuture ... done
[10:29:49.198] result() for MulticoreFuture ...
[10:29:49.198] result() for MulticoreFuture ... done
[10:29:49.198] - relayed: [n=2] TRUE, TRUE
[10:29:49.198] - queued futures: [n=2] TRUE, TRUE
[10:29:49.198] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:49.199]  length: 0 (resolved future 2)
[10:29:49.199] Relaying remaining futures
[10:29:49.199] signalConditionsASAP(NULL, pos=0) ...
[10:29:49.199] - nx: 2
[10:29:49.199] - relay: TRUE
[10:29:49.199] - stdout: TRUE
[10:29:49.199] - signal: TRUE
[10:29:49.199] - resignal: FALSE
[10:29:49.199] - force: TRUE
[10:29:49.199] - relayed: [n=2] TRUE, TRUE
[10:29:49.200] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:49.200] - relayed: [n=2] TRUE, TRUE
[10:29:49.200] - queued futures: [n=2] TRUE, TRUE
[10:29:49.200] signalConditionsASAP(NULL, pos=0) ... done
[10:29:49.200] resolve() on list ... DONE
[10:29:49.200] result() for MulticoreFuture ...
[10:29:49.200] result() for MulticoreFuture ... done
[10:29:49.200] result() for MulticoreFuture ...
[10:29:49.200] result() for MulticoreFuture ... done
[10:29:49.201] result() for MulticoreFuture ...
[10:29:49.201] result() for MulticoreFuture ... done
[10:29:49.201] result() for MulticoreFuture ...
[10:29:49.201] result() for MulticoreFuture ... done
[10:29:49.201]  - Number of value chunks collected: 2
[10:29:49.201] Resolving 2 futures (chunks) ... DONE
[10:29:49.201] Reducing values from 2 chunks ...
[10:29:49.201]  - Number of values collected after concatenation: 2
[10:29:49.201]  - Number of values expected: 2
[10:29:49.202] Reducing values from 2 chunks ... DONE
[10:29:49.202] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:29:49.202] getGlobalsAndPackagesXApply() ...
[10:29:49.202]  - future.globals: TRUE
[10:29:49.203] getGlobalsAndPackages() ...
[10:29:49.203] Searching for globals...
[10:29:49.204] - globals found: [1] ‘FUN’
[10:29:49.204] Searching for globals ... DONE
[10:29:49.204] Resolving globals: FALSE
[10:29:49.205] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:49.205] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:49.205] - globals: [1] ‘FUN’
[10:29:49.205] 
[10:29:49.205] getGlobalsAndPackages() ... DONE
[10:29:49.205]  - globals found/used: [n=1] ‘FUN’
[10:29:49.206]  - needed namespaces: [n=0] 
[10:29:49.206] Finding globals ... DONE
[10:29:49.206]  - use_args: TRUE
[10:29:49.206]  - Getting '...' globals ...
[10:29:49.206] resolve() on list ...
[10:29:49.206]  recursive: 0
[10:29:49.206]  length: 1
[10:29:49.207]  elements: ‘...’
[10:29:49.207]  length: 0 (resolved future 1)
[10:29:49.207] resolve() on list ... DONE
[10:29:49.207]    - '...' content: [n=0] 
[10:29:49.207] List of 1
[10:29:49.207]  $ ...: list()
[10:29:49.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.207]  - attr(*, "where")=List of 1
[10:29:49.207]   ..$ ...:<environment: 0x5618a07491b0> 
[10:29:49.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.207]  - attr(*, "resolved")= logi TRUE
[10:29:49.207]  - attr(*, "total_size")= num NA
[10:29:49.210]  - Getting '...' globals ... DONE
[10:29:49.210] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:49.210] List of 2
[10:29:49.210]  $ ...future.FUN:function (x)  
[10:29:49.210]  $ ...          : list()
[10:29:49.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.210]  - attr(*, "where")=List of 2
[10:29:49.210]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:49.210]   ..$ ...          :<environment: 0x5618a07491b0> 
[10:29:49.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.210]  - attr(*, "resolved")= logi FALSE
[10:29:49.210]  - attr(*, "total_size")= num 848
[10:29:49.215] Packages to be attached in all futures: [n=0] 
[10:29:49.215] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.219] future_lapply() ...
[10:29:49.223] Number of chunks: 2
[10:29:49.223] getGlobalsAndPackagesXApply() ...
[10:29:49.223]  - future.globals: <name-value list> with names ‘list()’
[10:29:49.224]  - use_args: TRUE
[10:29:49.224] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:49.224] List of 2
[10:29:49.224]  $ ...          : list()
[10:29:49.224]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.224]  $ ...future.FUN:function (x)  
[10:29:49.224]  - attr(*, "where")=List of 2
[10:29:49.224]   ..$ ...          :<environment: 0x5618a07491b0> 
[10:29:49.224]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:49.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.224]  - attr(*, "resolved")= logi FALSE
[10:29:49.224]  - attr(*, "total_size")= num NA
[10:29:49.227] Packages to be attached in all futures: [n=0] 
[10:29:49.227] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.228] Number of futures (= number of chunks): 2
[10:29:49.228] Launching 2 futures (chunks) ...
[10:29:49.228] Chunk #1 of 2 ...
[10:29:49.228]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.228]  - seeds: <none>
[10:29:49.228]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.228] getGlobalsAndPackages() ...
[10:29:49.228] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.229] Resolving globals: FALSE
[10:29:49.229] Tweak future expression to call with '...' arguments ...
[10:29:49.229] {
[10:29:49.229]     do.call(function(...) {
[10:29:49.229]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.229]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.229]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.229]             on.exit(options(oopts), add = TRUE)
[10:29:49.229]         }
[10:29:49.229]         {
[10:29:49.229]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.229]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.229]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.229]             })
[10:29:49.229]         }
[10:29:49.229]     }, args = future.call.arguments)
[10:29:49.229] }
[10:29:49.229] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.229] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.230] 
[10:29:49.230] getGlobalsAndPackages() ... DONE
[10:29:49.230] run() for ‘Future’ ...
[10:29:49.230] - state: ‘created’
[10:29:49.230] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.234] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.234] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.234]   - Field: ‘label’
[10:29:49.234]   - Field: ‘local’
[10:29:49.234]   - Field: ‘owner’
[10:29:49.234]   - Field: ‘envir’
[10:29:49.235]   - Field: ‘workers’
[10:29:49.235]   - Field: ‘packages’
[10:29:49.235]   - Field: ‘gc’
[10:29:49.235]   - Field: ‘job’
[10:29:49.235]   - Field: ‘conditions’
[10:29:49.235]   - Field: ‘expr’
[10:29:49.235]   - Field: ‘uuid’
[10:29:49.235]   - Field: ‘seed’
[10:29:49.235]   - Field: ‘version’
[10:29:49.235]   - Field: ‘result’
[10:29:49.235]   - Field: ‘asynchronous’
[10:29:49.236]   - Field: ‘calls’
[10:29:49.236]   - Field: ‘globals’
[10:29:49.236]   - Field: ‘stdout’
[10:29:49.236]   - Field: ‘earlySignal’
[10:29:49.236]   - Field: ‘lazy’
[10:29:49.236]   - Field: ‘state’
[10:29:49.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.236] - Launch lazy future ...
[10:29:49.237] Packages needed by the future expression (n = 0): <none>
[10:29:49.237] Packages needed by future strategies (n = 0): <none>
[10:29:49.237] {
[10:29:49.237]     {
[10:29:49.237]         {
[10:29:49.237]             ...future.startTime <- base::Sys.time()
[10:29:49.237]             {
[10:29:49.237]                 {
[10:29:49.237]                   {
[10:29:49.237]                     {
[10:29:49.237]                       base::local({
[10:29:49.237]                         has_future <- base::requireNamespace("future", 
[10:29:49.237]                           quietly = TRUE)
[10:29:49.237]                         if (has_future) {
[10:29:49.237]                           ns <- base::getNamespace("future")
[10:29:49.237]                           version <- ns[[".package"]][["version"]]
[10:29:49.237]                           if (is.null(version)) 
[10:29:49.237]                             version <- utils::packageVersion("future")
[10:29:49.237]                         }
[10:29:49.237]                         else {
[10:29:49.237]                           version <- NULL
[10:29:49.237]                         }
[10:29:49.237]                         if (!has_future || version < "1.8.0") {
[10:29:49.237]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.237]                             "", base::R.version$version.string), 
[10:29:49.237]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.237]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.237]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.237]                               "release", "version")], collapse = " "), 
[10:29:49.237]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.237]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.237]                             info)
[10:29:49.237]                           info <- base::paste(info, collapse = "; ")
[10:29:49.237]                           if (!has_future) {
[10:29:49.237]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.237]                               info)
[10:29:49.237]                           }
[10:29:49.237]                           else {
[10:29:49.237]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.237]                               info, version)
[10:29:49.237]                           }
[10:29:49.237]                           base::stop(msg)
[10:29:49.237]                         }
[10:29:49.237]                       })
[10:29:49.237]                     }
[10:29:49.237]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.237]                     base::options(mc.cores = 1L)
[10:29:49.237]                   }
[10:29:49.237]                   ...future.strategy.old <- future::plan("list")
[10:29:49.237]                   options(future.plan = NULL)
[10:29:49.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.237]                 }
[10:29:49.237]                 ...future.workdir <- getwd()
[10:29:49.237]             }
[10:29:49.237]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.237]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.237]         }
[10:29:49.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.237]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.237]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.237]             base::names(...future.oldOptions))
[10:29:49.237]     }
[10:29:49.237]     if (FALSE) {
[10:29:49.237]     }
[10:29:49.237]     else {
[10:29:49.237]         if (TRUE) {
[10:29:49.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.237]                 open = "w")
[10:29:49.237]         }
[10:29:49.237]         else {
[10:29:49.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.237]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.237]         }
[10:29:49.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.237]             base::sink(type = "output", split = FALSE)
[10:29:49.237]             base::close(...future.stdout)
[10:29:49.237]         }, add = TRUE)
[10:29:49.237]     }
[10:29:49.237]     ...future.frame <- base::sys.nframe()
[10:29:49.237]     ...future.conditions <- base::list()
[10:29:49.237]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.237]     if (FALSE) {
[10:29:49.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.237]     }
[10:29:49.237]     ...future.result <- base::tryCatch({
[10:29:49.237]         base::withCallingHandlers({
[10:29:49.237]             ...future.value <- base::withVisible(base::local({
[10:29:49.237]                 withCallingHandlers({
[10:29:49.237]                   {
[10:29:49.237]                     do.call(function(...) {
[10:29:49.237]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.237]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.237]                         ...future.globals.maxSize)) {
[10:29:49.237]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.237]                         on.exit(options(oopts), add = TRUE)
[10:29:49.237]                       }
[10:29:49.237]                       {
[10:29:49.237]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.237]                           FUN = function(jj) {
[10:29:49.237]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.237]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.237]                           })
[10:29:49.237]                       }
[10:29:49.237]                     }, args = future.call.arguments)
[10:29:49.237]                   }
[10:29:49.237]                 }, immediateCondition = function(cond) {
[10:29:49.237]                   save_rds <- function (object, pathname, ...) 
[10:29:49.237]                   {
[10:29:49.237]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.237]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.237]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.237]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.237]                         fi_tmp[["mtime"]])
[10:29:49.237]                     }
[10:29:49.237]                     tryCatch({
[10:29:49.237]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.237]                     }, error = function(ex) {
[10:29:49.237]                       msg <- conditionMessage(ex)
[10:29:49.237]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.237]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.237]                         fi_tmp[["mtime"]], msg)
[10:29:49.237]                       ex$message <- msg
[10:29:49.237]                       stop(ex)
[10:29:49.237]                     })
[10:29:49.237]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.237]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.237]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.237]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.237]                       fi <- file.info(pathname)
[10:29:49.237]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.237]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.237]                         fi[["size"]], fi[["mtime"]])
[10:29:49.237]                       stop(msg)
[10:29:49.237]                     }
[10:29:49.237]                     invisible(pathname)
[10:29:49.237]                   }
[10:29:49.237]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.237]                     rootPath = tempdir()) 
[10:29:49.237]                   {
[10:29:49.237]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.237]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.237]                       tmpdir = path, fileext = ".rds")
[10:29:49.237]                     save_rds(obj, file)
[10:29:49.237]                   }
[10:29:49.237]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.237]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.237]                   {
[10:29:49.237]                     inherits <- base::inherits
[10:29:49.237]                     invokeRestart <- base::invokeRestart
[10:29:49.237]                     is.null <- base::is.null
[10:29:49.237]                     muffled <- FALSE
[10:29:49.237]                     if (inherits(cond, "message")) {
[10:29:49.237]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.237]                       if (muffled) 
[10:29:49.237]                         invokeRestart("muffleMessage")
[10:29:49.237]                     }
[10:29:49.237]                     else if (inherits(cond, "warning")) {
[10:29:49.237]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.237]                       if (muffled) 
[10:29:49.237]                         invokeRestart("muffleWarning")
[10:29:49.237]                     }
[10:29:49.237]                     else if (inherits(cond, "condition")) {
[10:29:49.237]                       if (!is.null(pattern)) {
[10:29:49.237]                         computeRestarts <- base::computeRestarts
[10:29:49.237]                         grepl <- base::grepl
[10:29:49.237]                         restarts <- computeRestarts(cond)
[10:29:49.237]                         for (restart in restarts) {
[10:29:49.237]                           name <- restart$name
[10:29:49.237]                           if (is.null(name)) 
[10:29:49.237]                             next
[10:29:49.237]                           if (!grepl(pattern, name)) 
[10:29:49.237]                             next
[10:29:49.237]                           invokeRestart(restart)
[10:29:49.237]                           muffled <- TRUE
[10:29:49.237]                           break
[10:29:49.237]                         }
[10:29:49.237]                       }
[10:29:49.237]                     }
[10:29:49.237]                     invisible(muffled)
[10:29:49.237]                   }
[10:29:49.237]                   muffleCondition(cond)
[10:29:49.237]                 })
[10:29:49.237]             }))
[10:29:49.237]             future::FutureResult(value = ...future.value$value, 
[10:29:49.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.237]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.237]                     ...future.globalenv.names))
[10:29:49.237]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.237]         }, condition = base::local({
[10:29:49.237]             c <- base::c
[10:29:49.237]             inherits <- base::inherits
[10:29:49.237]             invokeRestart <- base::invokeRestart
[10:29:49.237]             length <- base::length
[10:29:49.237]             list <- base::list
[10:29:49.237]             seq.int <- base::seq.int
[10:29:49.237]             signalCondition <- base::signalCondition
[10:29:49.237]             sys.calls <- base::sys.calls
[10:29:49.237]             `[[` <- base::`[[`
[10:29:49.237]             `+` <- base::`+`
[10:29:49.237]             `<<-` <- base::`<<-`
[10:29:49.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.237]                   3L)]
[10:29:49.237]             }
[10:29:49.237]             function(cond) {
[10:29:49.237]                 is_error <- inherits(cond, "error")
[10:29:49.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.237]                   NULL)
[10:29:49.237]                 if (is_error) {
[10:29:49.237]                   sessionInformation <- function() {
[10:29:49.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.237]                       search = base::search(), system = base::Sys.info())
[10:29:49.237]                   }
[10:29:49.237]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.237]                     cond$call), session = sessionInformation(), 
[10:29:49.237]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.237]                   signalCondition(cond)
[10:29:49.237]                 }
[10:29:49.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.237]                 "immediateCondition"))) {
[10:29:49.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.237]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.237]                   if (TRUE && !signal) {
[10:29:49.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.237]                     {
[10:29:49.237]                       inherits <- base::inherits
[10:29:49.237]                       invokeRestart <- base::invokeRestart
[10:29:49.237]                       is.null <- base::is.null
[10:29:49.237]                       muffled <- FALSE
[10:29:49.237]                       if (inherits(cond, "message")) {
[10:29:49.237]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.237]                         if (muffled) 
[10:29:49.237]                           invokeRestart("muffleMessage")
[10:29:49.237]                       }
[10:29:49.237]                       else if (inherits(cond, "warning")) {
[10:29:49.237]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.237]                         if (muffled) 
[10:29:49.237]                           invokeRestart("muffleWarning")
[10:29:49.237]                       }
[10:29:49.237]                       else if (inherits(cond, "condition")) {
[10:29:49.237]                         if (!is.null(pattern)) {
[10:29:49.237]                           computeRestarts <- base::computeRestarts
[10:29:49.237]                           grepl <- base::grepl
[10:29:49.237]                           restarts <- computeRestarts(cond)
[10:29:49.237]                           for (restart in restarts) {
[10:29:49.237]                             name <- restart$name
[10:29:49.237]                             if (is.null(name)) 
[10:29:49.237]                               next
[10:29:49.237]                             if (!grepl(pattern, name)) 
[10:29:49.237]                               next
[10:29:49.237]                             invokeRestart(restart)
[10:29:49.237]                             muffled <- TRUE
[10:29:49.237]                             break
[10:29:49.237]                           }
[10:29:49.237]                         }
[10:29:49.237]                       }
[10:29:49.237]                       invisible(muffled)
[10:29:49.237]                     }
[10:29:49.237]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.237]                   }
[10:29:49.237]                 }
[10:29:49.237]                 else {
[10:29:49.237]                   if (TRUE) {
[10:29:49.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.237]                     {
[10:29:49.237]                       inherits <- base::inherits
[10:29:49.237]                       invokeRestart <- base::invokeRestart
[10:29:49.237]                       is.null <- base::is.null
[10:29:49.237]                       muffled <- FALSE
[10:29:49.237]                       if (inherits(cond, "message")) {
[10:29:49.237]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.237]                         if (muffled) 
[10:29:49.237]                           invokeRestart("muffleMessage")
[10:29:49.237]                       }
[10:29:49.237]                       else if (inherits(cond, "warning")) {
[10:29:49.237]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.237]                         if (muffled) 
[10:29:49.237]                           invokeRestart("muffleWarning")
[10:29:49.237]                       }
[10:29:49.237]                       else if (inherits(cond, "condition")) {
[10:29:49.237]                         if (!is.null(pattern)) {
[10:29:49.237]                           computeRestarts <- base::computeRestarts
[10:29:49.237]                           grepl <- base::grepl
[10:29:49.237]                           restarts <- computeRestarts(cond)
[10:29:49.237]                           for (restart in restarts) {
[10:29:49.237]                             name <- restart$name
[10:29:49.237]                             if (is.null(name)) 
[10:29:49.237]                               next
[10:29:49.237]                             if (!grepl(pattern, name)) 
[10:29:49.237]                               next
[10:29:49.237]                             invokeRestart(restart)
[10:29:49.237]                             muffled <- TRUE
[10:29:49.237]                             break
[10:29:49.237]                           }
[10:29:49.237]                         }
[10:29:49.237]                       }
[10:29:49.237]                       invisible(muffled)
[10:29:49.237]                     }
[10:29:49.237]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.237]                   }
[10:29:49.237]                 }
[10:29:49.237]             }
[10:29:49.237]         }))
[10:29:49.237]     }, error = function(ex) {
[10:29:49.237]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.237]                 ...future.rng), started = ...future.startTime, 
[10:29:49.237]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.237]             version = "1.8"), class = "FutureResult")
[10:29:49.237]     }, finally = {
[10:29:49.237]         if (!identical(...future.workdir, getwd())) 
[10:29:49.237]             setwd(...future.workdir)
[10:29:49.237]         {
[10:29:49.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.237]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.237]             }
[10:29:49.237]             base::options(...future.oldOptions)
[10:29:49.237]             if (.Platform$OS.type == "windows") {
[10:29:49.237]                 old_names <- names(...future.oldEnvVars)
[10:29:49.237]                 envs <- base::Sys.getenv()
[10:29:49.237]                 names <- names(envs)
[10:29:49.237]                 common <- intersect(names, old_names)
[10:29:49.237]                 added <- setdiff(names, old_names)
[10:29:49.237]                 removed <- setdiff(old_names, names)
[10:29:49.237]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.237]                   envs[common]]
[10:29:49.237]                 NAMES <- toupper(changed)
[10:29:49.237]                 args <- list()
[10:29:49.237]                 for (kk in seq_along(NAMES)) {
[10:29:49.237]                   name <- changed[[kk]]
[10:29:49.237]                   NAME <- NAMES[[kk]]
[10:29:49.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.237]                     next
[10:29:49.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.237]                 }
[10:29:49.237]                 NAMES <- toupper(added)
[10:29:49.237]                 for (kk in seq_along(NAMES)) {
[10:29:49.237]                   name <- added[[kk]]
[10:29:49.237]                   NAME <- NAMES[[kk]]
[10:29:49.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.237]                     next
[10:29:49.237]                   args[[name]] <- ""
[10:29:49.237]                 }
[10:29:49.237]                 NAMES <- toupper(removed)
[10:29:49.237]                 for (kk in seq_along(NAMES)) {
[10:29:49.237]                   name <- removed[[kk]]
[10:29:49.237]                   NAME <- NAMES[[kk]]
[10:29:49.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.237]                     next
[10:29:49.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.237]                 }
[10:29:49.237]                 if (length(args) > 0) 
[10:29:49.237]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.237]             }
[10:29:49.237]             else {
[10:29:49.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.237]             }
[10:29:49.237]             {
[10:29:49.237]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.237]                   0L) {
[10:29:49.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.237]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.237]                   base::options(opts)
[10:29:49.237]                 }
[10:29:49.237]                 {
[10:29:49.237]                   {
[10:29:49.237]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.237]                     NULL
[10:29:49.237]                   }
[10:29:49.237]                   options(future.plan = NULL)
[10:29:49.237]                   if (is.na(NA_character_)) 
[10:29:49.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.237]                     .init = FALSE)
[10:29:49.237]                 }
[10:29:49.237]             }
[10:29:49.237]         }
[10:29:49.237]     })
[10:29:49.237]     if (TRUE) {
[10:29:49.237]         base::sink(type = "output", split = FALSE)
[10:29:49.237]         if (TRUE) {
[10:29:49.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.237]         }
[10:29:49.237]         else {
[10:29:49.237]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.237]         }
[10:29:49.237]         base::close(...future.stdout)
[10:29:49.237]         ...future.stdout <- NULL
[10:29:49.237]     }
[10:29:49.237]     ...future.result$conditions <- ...future.conditions
[10:29:49.237]     ...future.result$finished <- base::Sys.time()
[10:29:49.237]     ...future.result
[10:29:49.237] }
[10:29:49.240] assign_globals() ...
[10:29:49.240] List of 5
[10:29:49.240]  $ future.call.arguments    : list()
[10:29:49.240]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.240]  $ ...future.FUN            :function (x)  
[10:29:49.240]  $ ...future.elements_ii    :List of 1
[10:29:49.240]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:29:49.240]  $ ...future.seeds_ii       : NULL
[10:29:49.240]  $ ...future.globals.maxSize: num Inf
[10:29:49.240]  - attr(*, "resolved")= logi FALSE
[10:29:49.240]  - attr(*, "total_size")= num NA
[10:29:49.240]  - attr(*, "where")=List of 5
[10:29:49.240]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.240]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.240]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.240]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.240]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.240]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.240]  - attr(*, "already-done")= logi TRUE
[10:29:49.245] - copied ‘future.call.arguments’ to environment
[10:29:49.245] - copied ‘...future.FUN’ to environment
[10:29:49.245] - copied ‘...future.elements_ii’ to environment
[10:29:49.245] - copied ‘...future.seeds_ii’ to environment
[10:29:49.245] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.245] assign_globals() ... done
[10:29:49.245] requestCore(): workers = 2
[10:29:49.248] MulticoreFuture started
[10:29:49.252] - Launch lazy future ... done
[10:29:49.253] plan(): Setting new future strategy stack:
[10:29:49.253] run() for ‘MulticoreFuture’ ... done
[10:29:49.254] Created future:
[10:29:49.253] List of future strategies:
[10:29:49.253] 1. sequential:
[10:29:49.253]    - args: function (..., envir = parent.frame())
[10:29:49.253]    - tweaked: FALSE
[10:29:49.253]    - call: NULL
[10:29:49.255] plan(): nbrOfWorkers() = 1
[10:29:49.257] plan(): Setting new future strategy stack:
[10:29:49.258] List of future strategies:
[10:29:49.258] 1. multicore:
[10:29:49.258]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.258]    - tweaked: FALSE
[10:29:49.258]    - call: plan(strategy)
[10:29:49.265] plan(): nbrOfWorkers() = 2
[10:29:49.254] MulticoreFuture:
[10:29:49.254] Label: ‘future_apply-1’
[10:29:49.254] Expression:
[10:29:49.254] {
[10:29:49.254]     do.call(function(...) {
[10:29:49.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.254]             on.exit(options(oopts), add = TRUE)
[10:29:49.254]         }
[10:29:49.254]         {
[10:29:49.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.254]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.254]             })
[10:29:49.254]         }
[10:29:49.254]     }, args = future.call.arguments)
[10:29:49.254] }
[10:29:49.254] Lazy evaluation: FALSE
[10:29:49.254] Asynchronous evaluation: TRUE
[10:29:49.254] Local evaluation: TRUE
[10:29:49.254] Environment: R_GlobalEnv
[10:29:49.254] Capture standard output: TRUE
[10:29:49.254] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.254] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.254] Packages: <none>
[10:29:49.254] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.254] Resolved: TRUE
[10:29:49.254] Value: <not collected>
[10:29:49.254] Conditions captured: <none>
[10:29:49.254] Early signaling: FALSE
[10:29:49.254] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.254] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.266] Chunk #1 of 2 ... DONE
[10:29:49.266] Chunk #2 of 2 ...
[10:29:49.266]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.267]  - seeds: <none>
[10:29:49.267]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.267] getGlobalsAndPackages() ...
[10:29:49.267] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.268] Resolving globals: FALSE
[10:29:49.268] Tweak future expression to call with '...' arguments ...
[10:29:49.268] {
[10:29:49.268]     do.call(function(...) {
[10:29:49.268]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.268]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.268]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.268]             on.exit(options(oopts), add = TRUE)
[10:29:49.268]         }
[10:29:49.268]         {
[10:29:49.268]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.268]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.268]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.268]             })
[10:29:49.268]         }
[10:29:49.268]     }, args = future.call.arguments)
[10:29:49.268] }
[10:29:49.269] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.269] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.270] 
[10:29:49.270] getGlobalsAndPackages() ... DONE
[10:29:49.270] run() for ‘Future’ ...
[10:29:49.271] - state: ‘created’
[10:29:49.271] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.276] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.276]   - Field: ‘label’
[10:29:49.277]   - Field: ‘local’
[10:29:49.277]   - Field: ‘owner’
[10:29:49.277]   - Field: ‘envir’
[10:29:49.277]   - Field: ‘workers’
[10:29:49.277]   - Field: ‘packages’
[10:29:49.277]   - Field: ‘gc’
[10:29:49.278]   - Field: ‘job’
[10:29:49.278]   - Field: ‘conditions’
[10:29:49.278]   - Field: ‘expr’
[10:29:49.278]   - Field: ‘uuid’
[10:29:49.278]   - Field: ‘seed’
[10:29:49.278]   - Field: ‘version’
[10:29:49.278]   - Field: ‘result’
[10:29:49.279]   - Field: ‘asynchronous’
[10:29:49.279]   - Field: ‘calls’
[10:29:49.279]   - Field: ‘globals’
[10:29:49.279]   - Field: ‘stdout’
[10:29:49.279]   - Field: ‘earlySignal’
[10:29:49.279]   - Field: ‘lazy’
[10:29:49.280]   - Field: ‘state’
[10:29:49.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.280] - Launch lazy future ...
[10:29:49.280] Packages needed by the future expression (n = 0): <none>
[10:29:49.280] Packages needed by future strategies (n = 0): <none>
[10:29:49.281] {
[10:29:49.281]     {
[10:29:49.281]         {
[10:29:49.281]             ...future.startTime <- base::Sys.time()
[10:29:49.281]             {
[10:29:49.281]                 {
[10:29:49.281]                   {
[10:29:49.281]                     {
[10:29:49.281]                       base::local({
[10:29:49.281]                         has_future <- base::requireNamespace("future", 
[10:29:49.281]                           quietly = TRUE)
[10:29:49.281]                         if (has_future) {
[10:29:49.281]                           ns <- base::getNamespace("future")
[10:29:49.281]                           version <- ns[[".package"]][["version"]]
[10:29:49.281]                           if (is.null(version)) 
[10:29:49.281]                             version <- utils::packageVersion("future")
[10:29:49.281]                         }
[10:29:49.281]                         else {
[10:29:49.281]                           version <- NULL
[10:29:49.281]                         }
[10:29:49.281]                         if (!has_future || version < "1.8.0") {
[10:29:49.281]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.281]                             "", base::R.version$version.string), 
[10:29:49.281]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.281]                               "release", "version")], collapse = " "), 
[10:29:49.281]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.281]                             info)
[10:29:49.281]                           info <- base::paste(info, collapse = "; ")
[10:29:49.281]                           if (!has_future) {
[10:29:49.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.281]                               info)
[10:29:49.281]                           }
[10:29:49.281]                           else {
[10:29:49.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.281]                               info, version)
[10:29:49.281]                           }
[10:29:49.281]                           base::stop(msg)
[10:29:49.281]                         }
[10:29:49.281]                       })
[10:29:49.281]                     }
[10:29:49.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.281]                     base::options(mc.cores = 1L)
[10:29:49.281]                   }
[10:29:49.281]                   ...future.strategy.old <- future::plan("list")
[10:29:49.281]                   options(future.plan = NULL)
[10:29:49.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.281]                 }
[10:29:49.281]                 ...future.workdir <- getwd()
[10:29:49.281]             }
[10:29:49.281]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.281]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.281]         }
[10:29:49.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.281]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.281]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.281]             base::names(...future.oldOptions))
[10:29:49.281]     }
[10:29:49.281]     if (FALSE) {
[10:29:49.281]     }
[10:29:49.281]     else {
[10:29:49.281]         if (TRUE) {
[10:29:49.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.281]                 open = "w")
[10:29:49.281]         }
[10:29:49.281]         else {
[10:29:49.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.281]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.281]         }
[10:29:49.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.281]             base::sink(type = "output", split = FALSE)
[10:29:49.281]             base::close(...future.stdout)
[10:29:49.281]         }, add = TRUE)
[10:29:49.281]     }
[10:29:49.281]     ...future.frame <- base::sys.nframe()
[10:29:49.281]     ...future.conditions <- base::list()
[10:29:49.281]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.281]     if (FALSE) {
[10:29:49.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.281]     }
[10:29:49.281]     ...future.result <- base::tryCatch({
[10:29:49.281]         base::withCallingHandlers({
[10:29:49.281]             ...future.value <- base::withVisible(base::local({
[10:29:49.281]                 withCallingHandlers({
[10:29:49.281]                   {
[10:29:49.281]                     do.call(function(...) {
[10:29:49.281]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.281]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.281]                         ...future.globals.maxSize)) {
[10:29:49.281]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.281]                         on.exit(options(oopts), add = TRUE)
[10:29:49.281]                       }
[10:29:49.281]                       {
[10:29:49.281]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.281]                           FUN = function(jj) {
[10:29:49.281]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.281]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.281]                           })
[10:29:49.281]                       }
[10:29:49.281]                     }, args = future.call.arguments)
[10:29:49.281]                   }
[10:29:49.281]                 }, immediateCondition = function(cond) {
[10:29:49.281]                   save_rds <- function (object, pathname, ...) 
[10:29:49.281]                   {
[10:29:49.281]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.281]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.281]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.281]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.281]                         fi_tmp[["mtime"]])
[10:29:49.281]                     }
[10:29:49.281]                     tryCatch({
[10:29:49.281]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.281]                     }, error = function(ex) {
[10:29:49.281]                       msg <- conditionMessage(ex)
[10:29:49.281]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.281]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.281]                         fi_tmp[["mtime"]], msg)
[10:29:49.281]                       ex$message <- msg
[10:29:49.281]                       stop(ex)
[10:29:49.281]                     })
[10:29:49.281]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.281]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.281]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.281]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.281]                       fi <- file.info(pathname)
[10:29:49.281]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.281]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.281]                         fi[["size"]], fi[["mtime"]])
[10:29:49.281]                       stop(msg)
[10:29:49.281]                     }
[10:29:49.281]                     invisible(pathname)
[10:29:49.281]                   }
[10:29:49.281]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.281]                     rootPath = tempdir()) 
[10:29:49.281]                   {
[10:29:49.281]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.281]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.281]                       tmpdir = path, fileext = ".rds")
[10:29:49.281]                     save_rds(obj, file)
[10:29:49.281]                   }
[10:29:49.281]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.281]                   {
[10:29:49.281]                     inherits <- base::inherits
[10:29:49.281]                     invokeRestart <- base::invokeRestart
[10:29:49.281]                     is.null <- base::is.null
[10:29:49.281]                     muffled <- FALSE
[10:29:49.281]                     if (inherits(cond, "message")) {
[10:29:49.281]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.281]                       if (muffled) 
[10:29:49.281]                         invokeRestart("muffleMessage")
[10:29:49.281]                     }
[10:29:49.281]                     else if (inherits(cond, "warning")) {
[10:29:49.281]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.281]                       if (muffled) 
[10:29:49.281]                         invokeRestart("muffleWarning")
[10:29:49.281]                     }
[10:29:49.281]                     else if (inherits(cond, "condition")) {
[10:29:49.281]                       if (!is.null(pattern)) {
[10:29:49.281]                         computeRestarts <- base::computeRestarts
[10:29:49.281]                         grepl <- base::grepl
[10:29:49.281]                         restarts <- computeRestarts(cond)
[10:29:49.281]                         for (restart in restarts) {
[10:29:49.281]                           name <- restart$name
[10:29:49.281]                           if (is.null(name)) 
[10:29:49.281]                             next
[10:29:49.281]                           if (!grepl(pattern, name)) 
[10:29:49.281]                             next
[10:29:49.281]                           invokeRestart(restart)
[10:29:49.281]                           muffled <- TRUE
[10:29:49.281]                           break
[10:29:49.281]                         }
[10:29:49.281]                       }
[10:29:49.281]                     }
[10:29:49.281]                     invisible(muffled)
[10:29:49.281]                   }
[10:29:49.281]                   muffleCondition(cond)
[10:29:49.281]                 })
[10:29:49.281]             }))
[10:29:49.281]             future::FutureResult(value = ...future.value$value, 
[10:29:49.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.281]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.281]                     ...future.globalenv.names))
[10:29:49.281]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.281]         }, condition = base::local({
[10:29:49.281]             c <- base::c
[10:29:49.281]             inherits <- base::inherits
[10:29:49.281]             invokeRestart <- base::invokeRestart
[10:29:49.281]             length <- base::length
[10:29:49.281]             list <- base::list
[10:29:49.281]             seq.int <- base::seq.int
[10:29:49.281]             signalCondition <- base::signalCondition
[10:29:49.281]             sys.calls <- base::sys.calls
[10:29:49.281]             `[[` <- base::`[[`
[10:29:49.281]             `+` <- base::`+`
[10:29:49.281]             `<<-` <- base::`<<-`
[10:29:49.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.281]                   3L)]
[10:29:49.281]             }
[10:29:49.281]             function(cond) {
[10:29:49.281]                 is_error <- inherits(cond, "error")
[10:29:49.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.281]                   NULL)
[10:29:49.281]                 if (is_error) {
[10:29:49.281]                   sessionInformation <- function() {
[10:29:49.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.281]                       search = base::search(), system = base::Sys.info())
[10:29:49.281]                   }
[10:29:49.281]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.281]                     cond$call), session = sessionInformation(), 
[10:29:49.281]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.281]                   signalCondition(cond)
[10:29:49.281]                 }
[10:29:49.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.281]                 "immediateCondition"))) {
[10:29:49.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.281]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.281]                   if (TRUE && !signal) {
[10:29:49.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.281]                     {
[10:29:49.281]                       inherits <- base::inherits
[10:29:49.281]                       invokeRestart <- base::invokeRestart
[10:29:49.281]                       is.null <- base::is.null
[10:29:49.281]                       muffled <- FALSE
[10:29:49.281]                       if (inherits(cond, "message")) {
[10:29:49.281]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.281]                         if (muffled) 
[10:29:49.281]                           invokeRestart("muffleMessage")
[10:29:49.281]                       }
[10:29:49.281]                       else if (inherits(cond, "warning")) {
[10:29:49.281]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.281]                         if (muffled) 
[10:29:49.281]                           invokeRestart("muffleWarning")
[10:29:49.281]                       }
[10:29:49.281]                       else if (inherits(cond, "condition")) {
[10:29:49.281]                         if (!is.null(pattern)) {
[10:29:49.281]                           computeRestarts <- base::computeRestarts
[10:29:49.281]                           grepl <- base::grepl
[10:29:49.281]                           restarts <- computeRestarts(cond)
[10:29:49.281]                           for (restart in restarts) {
[10:29:49.281]                             name <- restart$name
[10:29:49.281]                             if (is.null(name)) 
[10:29:49.281]                               next
[10:29:49.281]                             if (!grepl(pattern, name)) 
[10:29:49.281]                               next
[10:29:49.281]                             invokeRestart(restart)
[10:29:49.281]                             muffled <- TRUE
[10:29:49.281]                             break
[10:29:49.281]                           }
[10:29:49.281]                         }
[10:29:49.281]                       }
[10:29:49.281]                       invisible(muffled)
[10:29:49.281]                     }
[10:29:49.281]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.281]                   }
[10:29:49.281]                 }
[10:29:49.281]                 else {
[10:29:49.281]                   if (TRUE) {
[10:29:49.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.281]                     {
[10:29:49.281]                       inherits <- base::inherits
[10:29:49.281]                       invokeRestart <- base::invokeRestart
[10:29:49.281]                       is.null <- base::is.null
[10:29:49.281]                       muffled <- FALSE
[10:29:49.281]                       if (inherits(cond, "message")) {
[10:29:49.281]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.281]                         if (muffled) 
[10:29:49.281]                           invokeRestart("muffleMessage")
[10:29:49.281]                       }
[10:29:49.281]                       else if (inherits(cond, "warning")) {
[10:29:49.281]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.281]                         if (muffled) 
[10:29:49.281]                           invokeRestart("muffleWarning")
[10:29:49.281]                       }
[10:29:49.281]                       else if (inherits(cond, "condition")) {
[10:29:49.281]                         if (!is.null(pattern)) {
[10:29:49.281]                           computeRestarts <- base::computeRestarts
[10:29:49.281]                           grepl <- base::grepl
[10:29:49.281]                           restarts <- computeRestarts(cond)
[10:29:49.281]                           for (restart in restarts) {
[10:29:49.281]                             name <- restart$name
[10:29:49.281]                             if (is.null(name)) 
[10:29:49.281]                               next
[10:29:49.281]                             if (!grepl(pattern, name)) 
[10:29:49.281]                               next
[10:29:49.281]                             invokeRestart(restart)
[10:29:49.281]                             muffled <- TRUE
[10:29:49.281]                             break
[10:29:49.281]                           }
[10:29:49.281]                         }
[10:29:49.281]                       }
[10:29:49.281]                       invisible(muffled)
[10:29:49.281]                     }
[10:29:49.281]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.281]                   }
[10:29:49.281]                 }
[10:29:49.281]             }
[10:29:49.281]         }))
[10:29:49.281]     }, error = function(ex) {
[10:29:49.281]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.281]                 ...future.rng), started = ...future.startTime, 
[10:29:49.281]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.281]             version = "1.8"), class = "FutureResult")
[10:29:49.281]     }, finally = {
[10:29:49.281]         if (!identical(...future.workdir, getwd())) 
[10:29:49.281]             setwd(...future.workdir)
[10:29:49.281]         {
[10:29:49.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.281]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.281]             }
[10:29:49.281]             base::options(...future.oldOptions)
[10:29:49.281]             if (.Platform$OS.type == "windows") {
[10:29:49.281]                 old_names <- names(...future.oldEnvVars)
[10:29:49.281]                 envs <- base::Sys.getenv()
[10:29:49.281]                 names <- names(envs)
[10:29:49.281]                 common <- intersect(names, old_names)
[10:29:49.281]                 added <- setdiff(names, old_names)
[10:29:49.281]                 removed <- setdiff(old_names, names)
[10:29:49.281]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.281]                   envs[common]]
[10:29:49.281]                 NAMES <- toupper(changed)
[10:29:49.281]                 args <- list()
[10:29:49.281]                 for (kk in seq_along(NAMES)) {
[10:29:49.281]                   name <- changed[[kk]]
[10:29:49.281]                   NAME <- NAMES[[kk]]
[10:29:49.281]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.281]                     next
[10:29:49.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.281]                 }
[10:29:49.281]                 NAMES <- toupper(added)
[10:29:49.281]                 for (kk in seq_along(NAMES)) {
[10:29:49.281]                   name <- added[[kk]]
[10:29:49.281]                   NAME <- NAMES[[kk]]
[10:29:49.281]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.281]                     next
[10:29:49.281]                   args[[name]] <- ""
[10:29:49.281]                 }
[10:29:49.281]                 NAMES <- toupper(removed)
[10:29:49.281]                 for (kk in seq_along(NAMES)) {
[10:29:49.281]                   name <- removed[[kk]]
[10:29:49.281]                   NAME <- NAMES[[kk]]
[10:29:49.281]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.281]                     next
[10:29:49.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.281]                 }
[10:29:49.281]                 if (length(args) > 0) 
[10:29:49.281]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.281]             }
[10:29:49.281]             else {
[10:29:49.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.281]             }
[10:29:49.281]             {
[10:29:49.281]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.281]                   0L) {
[10:29:49.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.281]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.281]                   base::options(opts)
[10:29:49.281]                 }
[10:29:49.281]                 {
[10:29:49.281]                   {
[10:29:49.281]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.281]                     NULL
[10:29:49.281]                   }
[10:29:49.281]                   options(future.plan = NULL)
[10:29:49.281]                   if (is.na(NA_character_)) 
[10:29:49.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.281]                     .init = FALSE)
[10:29:49.281]                 }
[10:29:49.281]             }
[10:29:49.281]         }
[10:29:49.281]     })
[10:29:49.281]     if (TRUE) {
[10:29:49.281]         base::sink(type = "output", split = FALSE)
[10:29:49.281]         if (TRUE) {
[10:29:49.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.281]         }
[10:29:49.281]         else {
[10:29:49.281]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.281]         }
[10:29:49.281]         base::close(...future.stdout)
[10:29:49.281]         ...future.stdout <- NULL
[10:29:49.281]     }
[10:29:49.281]     ...future.result$conditions <- ...future.conditions
[10:29:49.281]     ...future.result$finished <- base::Sys.time()
[10:29:49.281]     ...future.result
[10:29:49.281] }
[10:29:49.284] assign_globals() ...
[10:29:49.284] List of 5
[10:29:49.284]  $ future.call.arguments    : list()
[10:29:49.284]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.284]  $ ...future.FUN            :function (x)  
[10:29:49.284]  $ ...future.elements_ii    :List of 1
[10:29:49.284]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:29:49.284]  $ ...future.seeds_ii       : NULL
[10:29:49.284]  $ ...future.globals.maxSize: num Inf
[10:29:49.284]  - attr(*, "resolved")= logi FALSE
[10:29:49.284]  - attr(*, "total_size")= num NA
[10:29:49.284]  - attr(*, "where")=List of 5
[10:29:49.284]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.284]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.284]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.284]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.284]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.284]  - attr(*, "already-done")= logi TRUE
[10:29:49.290] - copied ‘future.call.arguments’ to environment
[10:29:49.291] - copied ‘...future.FUN’ to environment
[10:29:49.291] - copied ‘...future.elements_ii’ to environment
[10:29:49.291] - copied ‘...future.seeds_ii’ to environment
[10:29:49.291] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.291] assign_globals() ... done
[10:29:49.291] requestCore(): workers = 2
[10:29:49.294] MulticoreFuture started
[10:29:49.294] - Launch lazy future ... done
[10:29:49.294] run() for ‘MulticoreFuture’ ... done
[10:29:49.295] Created future:
[10:29:49.295] plan(): Setting new future strategy stack:
[10:29:49.295] List of future strategies:
[10:29:49.295] 1. sequential:
[10:29:49.295]    - args: function (..., envir = parent.frame())
[10:29:49.295]    - tweaked: FALSE
[10:29:49.295]    - call: NULL
[10:29:49.296] plan(): nbrOfWorkers() = 1
[10:29:49.298] plan(): Setting new future strategy stack:
[10:29:49.298] List of future strategies:
[10:29:49.298] 1. multicore:
[10:29:49.298]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.298]    - tweaked: FALSE
[10:29:49.298]    - call: plan(strategy)
[10:29:49.303] plan(): nbrOfWorkers() = 2
[10:29:49.295] MulticoreFuture:
[10:29:49.295] Label: ‘future_apply-2’
[10:29:49.295] Expression:
[10:29:49.295] {
[10:29:49.295]     do.call(function(...) {
[10:29:49.295]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.295]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.295]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.295]             on.exit(options(oopts), add = TRUE)
[10:29:49.295]         }
[10:29:49.295]         {
[10:29:49.295]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.295]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.295]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.295]             })
[10:29:49.295]         }
[10:29:49.295]     }, args = future.call.arguments)
[10:29:49.295] }
[10:29:49.295] Lazy evaluation: FALSE
[10:29:49.295] Asynchronous evaluation: TRUE
[10:29:49.295] Local evaluation: TRUE
[10:29:49.295] Environment: R_GlobalEnv
[10:29:49.295] Capture standard output: TRUE
[10:29:49.295] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.295] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.295] Packages: <none>
[10:29:49.295] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.295] Resolved: TRUE
[10:29:49.295] Value: <not collected>
[10:29:49.295] Conditions captured: <none>
[10:29:49.295] Early signaling: FALSE
[10:29:49.295] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.295] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.304] Chunk #2 of 2 ... DONE
[10:29:49.304] Launching 2 futures (chunks) ... DONE
[10:29:49.304] Resolving 2 futures (chunks) ...
[10:29:49.305] resolve() on list ...
[10:29:49.305]  recursive: 0
[10:29:49.305]  length: 2
[10:29:49.305] 
[10:29:49.305] Future #1
[10:29:49.305] result() for MulticoreFuture ...
[10:29:49.306] result() for MulticoreFuture ...
[10:29:49.307] result() for MulticoreFuture ... done
[10:29:49.307] result() for MulticoreFuture ... done
[10:29:49.307] result() for MulticoreFuture ...
[10:29:49.307] result() for MulticoreFuture ... done
[10:29:49.307] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:49.307] - nx: 2
[10:29:49.307] - relay: TRUE
[10:29:49.308] - stdout: TRUE
[10:29:49.308] - signal: TRUE
[10:29:49.308] - resignal: FALSE
[10:29:49.308] - force: TRUE
[10:29:49.308] - relayed: [n=2] FALSE, FALSE
[10:29:49.308] - queued futures: [n=2] FALSE, FALSE
[10:29:49.308]  - until=1
[10:29:49.309]  - relaying element #1
[10:29:49.309] result() for MulticoreFuture ...
[10:29:49.309] result() for MulticoreFuture ... done
[10:29:49.309] result() for MulticoreFuture ...
[10:29:49.309] result() for MulticoreFuture ... done
[10:29:49.309] result() for MulticoreFuture ...
[10:29:49.310] result() for MulticoreFuture ... done
[10:29:49.310] result() for MulticoreFuture ...
[10:29:49.310] result() for MulticoreFuture ... done
[10:29:49.310] - relayed: [n=2] TRUE, FALSE
[10:29:49.310] - queued futures: [n=2] TRUE, FALSE
[10:29:49.310] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:49.310]  length: 1 (resolved future 1)
[10:29:49.311] Future #2
[10:29:49.311] result() for MulticoreFuture ...
[10:29:49.316] result() for MulticoreFuture ...
[10:29:49.316] result() for MulticoreFuture ... done
[10:29:49.316] result() for MulticoreFuture ... done
[10:29:49.317] result() for MulticoreFuture ...
[10:29:49.317] result() for MulticoreFuture ... done
[10:29:49.318] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:49.318] - nx: 2
[10:29:49.318] - relay: TRUE
[10:29:49.318] - stdout: TRUE
[10:29:49.319] - signal: TRUE
[10:29:49.319] - resignal: FALSE
[10:29:49.319] - force: TRUE
[10:29:49.319] - relayed: [n=2] TRUE, FALSE
[10:29:49.319] - queued futures: [n=2] TRUE, FALSE
[10:29:49.319]  - until=2
[10:29:49.320]  - relaying element #2
[10:29:49.320] result() for MulticoreFuture ...
[10:29:49.320] result() for MulticoreFuture ... done
[10:29:49.320] result() for MulticoreFuture ...
[10:29:49.320] result() for MulticoreFuture ... done
[10:29:49.321] result() for MulticoreFuture ...
[10:29:49.321] result() for MulticoreFuture ... done
[10:29:49.321] result() for MulticoreFuture ...
[10:29:49.321] result() for MulticoreFuture ... done
[10:29:49.321] - relayed: [n=2] TRUE, TRUE
[10:29:49.321] - queued futures: [n=2] TRUE, TRUE
[10:29:49.322] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:49.322]  length: 0 (resolved future 2)
[10:29:49.322] Relaying remaining futures
[10:29:49.322] signalConditionsASAP(NULL, pos=0) ...
[10:29:49.322] - nx: 2
[10:29:49.322] - relay: TRUE
[10:29:49.322] - stdout: TRUE
[10:29:49.322] - signal: TRUE
[10:29:49.323] - resignal: FALSE
[10:29:49.323] - force: TRUE
[10:29:49.323] - relayed: [n=2] TRUE, TRUE
[10:29:49.323] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:49.323] - relayed: [n=2] TRUE, TRUE
[10:29:49.323] - queued futures: [n=2] TRUE, TRUE
[10:29:49.323] signalConditionsASAP(NULL, pos=0) ... done
[10:29:49.323] resolve() on list ... DONE
[10:29:49.324] result() for MulticoreFuture ...
[10:29:49.324] result() for MulticoreFuture ... done
[10:29:49.324] result() for MulticoreFuture ...
[10:29:49.324] result() for MulticoreFuture ... done
[10:29:49.324] result() for MulticoreFuture ...
[10:29:49.324] result() for MulticoreFuture ... done
[10:29:49.324] result() for MulticoreFuture ...
[10:29:49.324] result() for MulticoreFuture ... done
[10:29:49.325]  - Number of value chunks collected: 2
[10:29:49.325] Resolving 2 futures (chunks) ... DONE
[10:29:49.325] Reducing values from 2 chunks ...
[10:29:49.325]  - Number of values collected after concatenation: 2
[10:29:49.325]  - Number of values expected: 2
[10:29:49.325] Reducing values from 2 chunks ... DONE
[10:29:49.325] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:29:49.326] getGlobalsAndPackagesXApply() ...
[10:29:49.326]  - future.globals: TRUE
[10:29:49.326] getGlobalsAndPackages() ...
[10:29:49.326] Searching for globals...
[10:29:49.328] - globals found: [1] ‘FUN’
[10:29:49.328] Searching for globals ... DONE
[10:29:49.328] Resolving globals: FALSE
[10:29:49.328] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:49.329] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:49.329] - globals: [1] ‘FUN’
[10:29:49.329] 
[10:29:49.329] getGlobalsAndPackages() ... DONE
[10:29:49.329]  - globals found/used: [n=1] ‘FUN’
[10:29:49.329]  - needed namespaces: [n=0] 
[10:29:49.329] Finding globals ... DONE
[10:29:49.330]  - use_args: TRUE
[10:29:49.330]  - Getting '...' globals ...
[10:29:49.330] resolve() on list ...
[10:29:49.330]  recursive: 0
[10:29:49.330]  length: 1
[10:29:49.330]  elements: ‘...’
[10:29:49.330]  length: 0 (resolved future 1)
[10:29:49.331] resolve() on list ... DONE
[10:29:49.331]    - '...' content: [n=0] 
[10:29:49.331] List of 1
[10:29:49.331]  $ ...: list()
[10:29:49.331]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.331]  - attr(*, "where")=List of 1
[10:29:49.331]   ..$ ...:<environment: 0x5618a069ef48> 
[10:29:49.331]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.331]  - attr(*, "resolved")= logi TRUE
[10:29:49.331]  - attr(*, "total_size")= num NA
[10:29:49.334]  - Getting '...' globals ... DONE
[10:29:49.334] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:49.334] List of 2
[10:29:49.334]  $ ...future.FUN:function (x)  
[10:29:49.334]  $ ...          : list()
[10:29:49.334]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.334]  - attr(*, "where")=List of 2
[10:29:49.334]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:49.334]   ..$ ...          :<environment: 0x5618a069ef48> 
[10:29:49.334]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.334]  - attr(*, "resolved")= logi FALSE
[10:29:49.334]  - attr(*, "total_size")= num 848
[10:29:49.337] Packages to be attached in all futures: [n=0] 
[10:29:49.337] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.341] future_lapply() ...
[10:29:49.345] Number of chunks: 2
[10:29:49.345] getGlobalsAndPackagesXApply() ...
[10:29:49.345]  - future.globals: <name-value list> with names ‘list()’
[10:29:49.345]  - use_args: TRUE
[10:29:49.346] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:49.346] List of 2
[10:29:49.346]  $ ...          : list()
[10:29:49.346]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.346]  $ ...future.FUN:function (x)  
[10:29:49.346]  - attr(*, "where")=List of 2
[10:29:49.346]   ..$ ...          :<environment: 0x5618a069ef48> 
[10:29:49.346]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:49.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.346]  - attr(*, "resolved")= logi FALSE
[10:29:49.346]  - attr(*, "total_size")= num NA
[10:29:49.351] Packages to be attached in all futures: [n=0] 
[10:29:49.351] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.352] Number of futures (= number of chunks): 2
[10:29:49.352] Launching 2 futures (chunks) ...
[10:29:49.352] Chunk #1 of 2 ...
[10:29:49.352]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.352]  - seeds: <none>
[10:29:49.352]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.352] getGlobalsAndPackages() ...
[10:29:49.352] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.353] Resolving globals: FALSE
[10:29:49.353] Tweak future expression to call with '...' arguments ...
[10:29:49.353] {
[10:29:49.353]     do.call(function(...) {
[10:29:49.353]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.353]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.353]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.353]             on.exit(options(oopts), add = TRUE)
[10:29:49.353]         }
[10:29:49.353]         {
[10:29:49.353]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.353]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.353]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.353]             })
[10:29:49.353]         }
[10:29:49.353]     }, args = future.call.arguments)
[10:29:49.353] }
[10:29:49.353] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.353] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.354] 
[10:29:49.354] getGlobalsAndPackages() ... DONE
[10:29:49.354] run() for ‘Future’ ...
[10:29:49.354] - state: ‘created’
[10:29:49.354] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.358] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.358] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.358]   - Field: ‘label’
[10:29:49.358]   - Field: ‘local’
[10:29:49.358]   - Field: ‘owner’
[10:29:49.359]   - Field: ‘envir’
[10:29:49.359]   - Field: ‘workers’
[10:29:49.359]   - Field: ‘packages’
[10:29:49.359]   - Field: ‘gc’
[10:29:49.359]   - Field: ‘job’
[10:29:49.359]   - Field: ‘conditions’
[10:29:49.359]   - Field: ‘expr’
[10:29:49.359]   - Field: ‘uuid’
[10:29:49.359]   - Field: ‘seed’
[10:29:49.359]   - Field: ‘version’
[10:29:49.359]   - Field: ‘result’
[10:29:49.360]   - Field: ‘asynchronous’
[10:29:49.360]   - Field: ‘calls’
[10:29:49.360]   - Field: ‘globals’
[10:29:49.360]   - Field: ‘stdout’
[10:29:49.360]   - Field: ‘earlySignal’
[10:29:49.360]   - Field: ‘lazy’
[10:29:49.360]   - Field: ‘state’
[10:29:49.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.360] - Launch lazy future ...
[10:29:49.361] Packages needed by the future expression (n = 0): <none>
[10:29:49.361] Packages needed by future strategies (n = 0): <none>
[10:29:49.361] {
[10:29:49.361]     {
[10:29:49.361]         {
[10:29:49.361]             ...future.startTime <- base::Sys.time()
[10:29:49.361]             {
[10:29:49.361]                 {
[10:29:49.361]                   {
[10:29:49.361]                     {
[10:29:49.361]                       base::local({
[10:29:49.361]                         has_future <- base::requireNamespace("future", 
[10:29:49.361]                           quietly = TRUE)
[10:29:49.361]                         if (has_future) {
[10:29:49.361]                           ns <- base::getNamespace("future")
[10:29:49.361]                           version <- ns[[".package"]][["version"]]
[10:29:49.361]                           if (is.null(version)) 
[10:29:49.361]                             version <- utils::packageVersion("future")
[10:29:49.361]                         }
[10:29:49.361]                         else {
[10:29:49.361]                           version <- NULL
[10:29:49.361]                         }
[10:29:49.361]                         if (!has_future || version < "1.8.0") {
[10:29:49.361]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.361]                             "", base::R.version$version.string), 
[10:29:49.361]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.361]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.361]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.361]                               "release", "version")], collapse = " "), 
[10:29:49.361]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.361]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.361]                             info)
[10:29:49.361]                           info <- base::paste(info, collapse = "; ")
[10:29:49.361]                           if (!has_future) {
[10:29:49.361]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.361]                               info)
[10:29:49.361]                           }
[10:29:49.361]                           else {
[10:29:49.361]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.361]                               info, version)
[10:29:49.361]                           }
[10:29:49.361]                           base::stop(msg)
[10:29:49.361]                         }
[10:29:49.361]                       })
[10:29:49.361]                     }
[10:29:49.361]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.361]                     base::options(mc.cores = 1L)
[10:29:49.361]                   }
[10:29:49.361]                   ...future.strategy.old <- future::plan("list")
[10:29:49.361]                   options(future.plan = NULL)
[10:29:49.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.361]                 }
[10:29:49.361]                 ...future.workdir <- getwd()
[10:29:49.361]             }
[10:29:49.361]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.361]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.361]         }
[10:29:49.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.361]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.361]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.361]             base::names(...future.oldOptions))
[10:29:49.361]     }
[10:29:49.361]     if (FALSE) {
[10:29:49.361]     }
[10:29:49.361]     else {
[10:29:49.361]         if (TRUE) {
[10:29:49.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.361]                 open = "w")
[10:29:49.361]         }
[10:29:49.361]         else {
[10:29:49.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.361]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.361]         }
[10:29:49.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.361]             base::sink(type = "output", split = FALSE)
[10:29:49.361]             base::close(...future.stdout)
[10:29:49.361]         }, add = TRUE)
[10:29:49.361]     }
[10:29:49.361]     ...future.frame <- base::sys.nframe()
[10:29:49.361]     ...future.conditions <- base::list()
[10:29:49.361]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.361]     if (FALSE) {
[10:29:49.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.361]     }
[10:29:49.361]     ...future.result <- base::tryCatch({
[10:29:49.361]         base::withCallingHandlers({
[10:29:49.361]             ...future.value <- base::withVisible(base::local({
[10:29:49.361]                 withCallingHandlers({
[10:29:49.361]                   {
[10:29:49.361]                     do.call(function(...) {
[10:29:49.361]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.361]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.361]                         ...future.globals.maxSize)) {
[10:29:49.361]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.361]                         on.exit(options(oopts), add = TRUE)
[10:29:49.361]                       }
[10:29:49.361]                       {
[10:29:49.361]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.361]                           FUN = function(jj) {
[10:29:49.361]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.361]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.361]                           })
[10:29:49.361]                       }
[10:29:49.361]                     }, args = future.call.arguments)
[10:29:49.361]                   }
[10:29:49.361]                 }, immediateCondition = function(cond) {
[10:29:49.361]                   save_rds <- function (object, pathname, ...) 
[10:29:49.361]                   {
[10:29:49.361]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.361]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.361]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.361]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.361]                         fi_tmp[["mtime"]])
[10:29:49.361]                     }
[10:29:49.361]                     tryCatch({
[10:29:49.361]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.361]                     }, error = function(ex) {
[10:29:49.361]                       msg <- conditionMessage(ex)
[10:29:49.361]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.361]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.361]                         fi_tmp[["mtime"]], msg)
[10:29:49.361]                       ex$message <- msg
[10:29:49.361]                       stop(ex)
[10:29:49.361]                     })
[10:29:49.361]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.361]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.361]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.361]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.361]                       fi <- file.info(pathname)
[10:29:49.361]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.361]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.361]                         fi[["size"]], fi[["mtime"]])
[10:29:49.361]                       stop(msg)
[10:29:49.361]                     }
[10:29:49.361]                     invisible(pathname)
[10:29:49.361]                   }
[10:29:49.361]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.361]                     rootPath = tempdir()) 
[10:29:49.361]                   {
[10:29:49.361]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.361]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.361]                       tmpdir = path, fileext = ".rds")
[10:29:49.361]                     save_rds(obj, file)
[10:29:49.361]                   }
[10:29:49.361]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.361]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.361]                   {
[10:29:49.361]                     inherits <- base::inherits
[10:29:49.361]                     invokeRestart <- base::invokeRestart
[10:29:49.361]                     is.null <- base::is.null
[10:29:49.361]                     muffled <- FALSE
[10:29:49.361]                     if (inherits(cond, "message")) {
[10:29:49.361]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.361]                       if (muffled) 
[10:29:49.361]                         invokeRestart("muffleMessage")
[10:29:49.361]                     }
[10:29:49.361]                     else if (inherits(cond, "warning")) {
[10:29:49.361]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.361]                       if (muffled) 
[10:29:49.361]                         invokeRestart("muffleWarning")
[10:29:49.361]                     }
[10:29:49.361]                     else if (inherits(cond, "condition")) {
[10:29:49.361]                       if (!is.null(pattern)) {
[10:29:49.361]                         computeRestarts <- base::computeRestarts
[10:29:49.361]                         grepl <- base::grepl
[10:29:49.361]                         restarts <- computeRestarts(cond)
[10:29:49.361]                         for (restart in restarts) {
[10:29:49.361]                           name <- restart$name
[10:29:49.361]                           if (is.null(name)) 
[10:29:49.361]                             next
[10:29:49.361]                           if (!grepl(pattern, name)) 
[10:29:49.361]                             next
[10:29:49.361]                           invokeRestart(restart)
[10:29:49.361]                           muffled <- TRUE
[10:29:49.361]                           break
[10:29:49.361]                         }
[10:29:49.361]                       }
[10:29:49.361]                     }
[10:29:49.361]                     invisible(muffled)
[10:29:49.361]                   }
[10:29:49.361]                   muffleCondition(cond)
[10:29:49.361]                 })
[10:29:49.361]             }))
[10:29:49.361]             future::FutureResult(value = ...future.value$value, 
[10:29:49.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.361]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.361]                     ...future.globalenv.names))
[10:29:49.361]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.361]         }, condition = base::local({
[10:29:49.361]             c <- base::c
[10:29:49.361]             inherits <- base::inherits
[10:29:49.361]             invokeRestart <- base::invokeRestart
[10:29:49.361]             length <- base::length
[10:29:49.361]             list <- base::list
[10:29:49.361]             seq.int <- base::seq.int
[10:29:49.361]             signalCondition <- base::signalCondition
[10:29:49.361]             sys.calls <- base::sys.calls
[10:29:49.361]             `[[` <- base::`[[`
[10:29:49.361]             `+` <- base::`+`
[10:29:49.361]             `<<-` <- base::`<<-`
[10:29:49.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.361]                   3L)]
[10:29:49.361]             }
[10:29:49.361]             function(cond) {
[10:29:49.361]                 is_error <- inherits(cond, "error")
[10:29:49.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.361]                   NULL)
[10:29:49.361]                 if (is_error) {
[10:29:49.361]                   sessionInformation <- function() {
[10:29:49.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.361]                       search = base::search(), system = base::Sys.info())
[10:29:49.361]                   }
[10:29:49.361]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.361]                     cond$call), session = sessionInformation(), 
[10:29:49.361]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.361]                   signalCondition(cond)
[10:29:49.361]                 }
[10:29:49.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.361]                 "immediateCondition"))) {
[10:29:49.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.361]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.361]                   if (TRUE && !signal) {
[10:29:49.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.361]                     {
[10:29:49.361]                       inherits <- base::inherits
[10:29:49.361]                       invokeRestart <- base::invokeRestart
[10:29:49.361]                       is.null <- base::is.null
[10:29:49.361]                       muffled <- FALSE
[10:29:49.361]                       if (inherits(cond, "message")) {
[10:29:49.361]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.361]                         if (muffled) 
[10:29:49.361]                           invokeRestart("muffleMessage")
[10:29:49.361]                       }
[10:29:49.361]                       else if (inherits(cond, "warning")) {
[10:29:49.361]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.361]                         if (muffled) 
[10:29:49.361]                           invokeRestart("muffleWarning")
[10:29:49.361]                       }
[10:29:49.361]                       else if (inherits(cond, "condition")) {
[10:29:49.361]                         if (!is.null(pattern)) {
[10:29:49.361]                           computeRestarts <- base::computeRestarts
[10:29:49.361]                           grepl <- base::grepl
[10:29:49.361]                           restarts <- computeRestarts(cond)
[10:29:49.361]                           for (restart in restarts) {
[10:29:49.361]                             name <- restart$name
[10:29:49.361]                             if (is.null(name)) 
[10:29:49.361]                               next
[10:29:49.361]                             if (!grepl(pattern, name)) 
[10:29:49.361]                               next
[10:29:49.361]                             invokeRestart(restart)
[10:29:49.361]                             muffled <- TRUE
[10:29:49.361]                             break
[10:29:49.361]                           }
[10:29:49.361]                         }
[10:29:49.361]                       }
[10:29:49.361]                       invisible(muffled)
[10:29:49.361]                     }
[10:29:49.361]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.361]                   }
[10:29:49.361]                 }
[10:29:49.361]                 else {
[10:29:49.361]                   if (TRUE) {
[10:29:49.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.361]                     {
[10:29:49.361]                       inherits <- base::inherits
[10:29:49.361]                       invokeRestart <- base::invokeRestart
[10:29:49.361]                       is.null <- base::is.null
[10:29:49.361]                       muffled <- FALSE
[10:29:49.361]                       if (inherits(cond, "message")) {
[10:29:49.361]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.361]                         if (muffled) 
[10:29:49.361]                           invokeRestart("muffleMessage")
[10:29:49.361]                       }
[10:29:49.361]                       else if (inherits(cond, "warning")) {
[10:29:49.361]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.361]                         if (muffled) 
[10:29:49.361]                           invokeRestart("muffleWarning")
[10:29:49.361]                       }
[10:29:49.361]                       else if (inherits(cond, "condition")) {
[10:29:49.361]                         if (!is.null(pattern)) {
[10:29:49.361]                           computeRestarts <- base::computeRestarts
[10:29:49.361]                           grepl <- base::grepl
[10:29:49.361]                           restarts <- computeRestarts(cond)
[10:29:49.361]                           for (restart in restarts) {
[10:29:49.361]                             name <- restart$name
[10:29:49.361]                             if (is.null(name)) 
[10:29:49.361]                               next
[10:29:49.361]                             if (!grepl(pattern, name)) 
[10:29:49.361]                               next
[10:29:49.361]                             invokeRestart(restart)
[10:29:49.361]                             muffled <- TRUE
[10:29:49.361]                             break
[10:29:49.361]                           }
[10:29:49.361]                         }
[10:29:49.361]                       }
[10:29:49.361]                       invisible(muffled)
[10:29:49.361]                     }
[10:29:49.361]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.361]                   }
[10:29:49.361]                 }
[10:29:49.361]             }
[10:29:49.361]         }))
[10:29:49.361]     }, error = function(ex) {
[10:29:49.361]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.361]                 ...future.rng), started = ...future.startTime, 
[10:29:49.361]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.361]             version = "1.8"), class = "FutureResult")
[10:29:49.361]     }, finally = {
[10:29:49.361]         if (!identical(...future.workdir, getwd())) 
[10:29:49.361]             setwd(...future.workdir)
[10:29:49.361]         {
[10:29:49.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.361]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.361]             }
[10:29:49.361]             base::options(...future.oldOptions)
[10:29:49.361]             if (.Platform$OS.type == "windows") {
[10:29:49.361]                 old_names <- names(...future.oldEnvVars)
[10:29:49.361]                 envs <- base::Sys.getenv()
[10:29:49.361]                 names <- names(envs)
[10:29:49.361]                 common <- intersect(names, old_names)
[10:29:49.361]                 added <- setdiff(names, old_names)
[10:29:49.361]                 removed <- setdiff(old_names, names)
[10:29:49.361]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.361]                   envs[common]]
[10:29:49.361]                 NAMES <- toupper(changed)
[10:29:49.361]                 args <- list()
[10:29:49.361]                 for (kk in seq_along(NAMES)) {
[10:29:49.361]                   name <- changed[[kk]]
[10:29:49.361]                   NAME <- NAMES[[kk]]
[10:29:49.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.361]                     next
[10:29:49.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.361]                 }
[10:29:49.361]                 NAMES <- toupper(added)
[10:29:49.361]                 for (kk in seq_along(NAMES)) {
[10:29:49.361]                   name <- added[[kk]]
[10:29:49.361]                   NAME <- NAMES[[kk]]
[10:29:49.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.361]                     next
[10:29:49.361]                   args[[name]] <- ""
[10:29:49.361]                 }
[10:29:49.361]                 NAMES <- toupper(removed)
[10:29:49.361]                 for (kk in seq_along(NAMES)) {
[10:29:49.361]                   name <- removed[[kk]]
[10:29:49.361]                   NAME <- NAMES[[kk]]
[10:29:49.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.361]                     next
[10:29:49.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.361]                 }
[10:29:49.361]                 if (length(args) > 0) 
[10:29:49.361]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.361]             }
[10:29:49.361]             else {
[10:29:49.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.361]             }
[10:29:49.361]             {
[10:29:49.361]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.361]                   0L) {
[10:29:49.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.361]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.361]                   base::options(opts)
[10:29:49.361]                 }
[10:29:49.361]                 {
[10:29:49.361]                   {
[10:29:49.361]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.361]                     NULL
[10:29:49.361]                   }
[10:29:49.361]                   options(future.plan = NULL)
[10:29:49.361]                   if (is.na(NA_character_)) 
[10:29:49.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.361]                     .init = FALSE)
[10:29:49.361]                 }
[10:29:49.361]             }
[10:29:49.361]         }
[10:29:49.361]     })
[10:29:49.361]     if (TRUE) {
[10:29:49.361]         base::sink(type = "output", split = FALSE)
[10:29:49.361]         if (TRUE) {
[10:29:49.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.361]         }
[10:29:49.361]         else {
[10:29:49.361]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.361]         }
[10:29:49.361]         base::close(...future.stdout)
[10:29:49.361]         ...future.stdout <- NULL
[10:29:49.361]     }
[10:29:49.361]     ...future.result$conditions <- ...future.conditions
[10:29:49.361]     ...future.result$finished <- base::Sys.time()
[10:29:49.361]     ...future.result
[10:29:49.361] }
[10:29:49.364] assign_globals() ...
[10:29:49.364] List of 5
[10:29:49.364]  $ future.call.arguments    : list()
[10:29:49.364]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.364]  $ ...future.FUN            :function (x)  
[10:29:49.364]  $ ...future.elements_ii    :List of 3
[10:29:49.364]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:29:49.364]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:29:49.364]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:29:49.364]  $ ...future.seeds_ii       : NULL
[10:29:49.364]  $ ...future.globals.maxSize: num Inf
[10:29:49.364]  - attr(*, "resolved")= logi FALSE
[10:29:49.364]  - attr(*, "total_size")= num NA
[10:29:49.364]  - attr(*, "where")=List of 5
[10:29:49.364]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.364]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.364]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.364]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.364]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.364]  - attr(*, "already-done")= logi TRUE
[10:29:49.369] - copied ‘future.call.arguments’ to environment
[10:29:49.369] - copied ‘...future.FUN’ to environment
[10:29:49.370] - copied ‘...future.elements_ii’ to environment
[10:29:49.370] - copied ‘...future.seeds_ii’ to environment
[10:29:49.370] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.370] assign_globals() ... done
[10:29:49.370] requestCore(): workers = 2
[10:29:49.372] MulticoreFuture started
[10:29:49.373] - Launch lazy future ... done
[10:29:49.373] run() for ‘MulticoreFuture’ ... done
[10:29:49.373] Created future:
[10:29:49.373] plan(): Setting new future strategy stack:
[10:29:49.374] List of future strategies:
[10:29:49.374] 1. sequential:
[10:29:49.374]    - args: function (..., envir = parent.frame())
[10:29:49.374]    - tweaked: FALSE
[10:29:49.374]    - call: NULL
[10:29:49.374] plan(): nbrOfWorkers() = 1
[10:29:49.377] plan(): Setting new future strategy stack:
[10:29:49.377] List of future strategies:
[10:29:49.377] 1. multicore:
[10:29:49.377]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.377]    - tweaked: FALSE
[10:29:49.377]    - call: plan(strategy)
[10:29:49.382] plan(): nbrOfWorkers() = 2
[10:29:49.373] MulticoreFuture:
[10:29:49.373] Label: ‘future_apply-1’
[10:29:49.373] Expression:
[10:29:49.373] {
[10:29:49.373]     do.call(function(...) {
[10:29:49.373]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.373]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.373]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.373]             on.exit(options(oopts), add = TRUE)
[10:29:49.373]         }
[10:29:49.373]         {
[10:29:49.373]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.373]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.373]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.373]             })
[10:29:49.373]         }
[10:29:49.373]     }, args = future.call.arguments)
[10:29:49.373] }
[10:29:49.373] Lazy evaluation: FALSE
[10:29:49.373] Asynchronous evaluation: TRUE
[10:29:49.373] Local evaluation: TRUE
[10:29:49.373] Environment: R_GlobalEnv
[10:29:49.373] Capture standard output: TRUE
[10:29:49.373] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.373] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.373] Packages: <none>
[10:29:49.373] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.373] Resolved: TRUE
[10:29:49.373] Value: <not collected>
[10:29:49.373] Conditions captured: <none>
[10:29:49.373] Early signaling: FALSE
[10:29:49.373] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.373] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.383] Chunk #1 of 2 ... DONE
[10:29:49.383] Chunk #2 of 2 ...
[10:29:49.383]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.383]  - seeds: <none>
[10:29:49.383]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.384] getGlobalsAndPackages() ...
[10:29:49.384] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.384] Resolving globals: FALSE
[10:29:49.384] Tweak future expression to call with '...' arguments ...
[10:29:49.384] {
[10:29:49.384]     do.call(function(...) {
[10:29:49.384]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.384]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.384]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.384]             on.exit(options(oopts), add = TRUE)
[10:29:49.384]         }
[10:29:49.384]         {
[10:29:49.384]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.384]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.384]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.384]             })
[10:29:49.384]         }
[10:29:49.384]     }, args = future.call.arguments)
[10:29:49.384] }
[10:29:49.385] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.385] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.385] 
[10:29:49.386] getGlobalsAndPackages() ... DONE
[10:29:49.386] run() for ‘Future’ ...
[10:29:49.386] - state: ‘created’
[10:29:49.390] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.396] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.397] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.397]   - Field: ‘label’
[10:29:49.398]   - Field: ‘local’
[10:29:49.398]   - Field: ‘owner’
[10:29:49.398]   - Field: ‘envir’
[10:29:49.398]   - Field: ‘workers’
[10:29:49.398]   - Field: ‘packages’
[10:29:49.399]   - Field: ‘gc’
[10:29:49.399]   - Field: ‘job’
[10:29:49.399]   - Field: ‘conditions’
[10:29:49.399]   - Field: ‘expr’
[10:29:49.400]   - Field: ‘uuid’
[10:29:49.400]   - Field: ‘seed’
[10:29:49.400]   - Field: ‘version’
[10:29:49.400]   - Field: ‘result’
[10:29:49.400]   - Field: ‘asynchronous’
[10:29:49.401]   - Field: ‘calls’
[10:29:49.401]   - Field: ‘globals’
[10:29:49.401]   - Field: ‘stdout’
[10:29:49.401]   - Field: ‘earlySignal’
[10:29:49.401]   - Field: ‘lazy’
[10:29:49.401]   - Field: ‘state’
[10:29:49.401] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.402] - Launch lazy future ...
[10:29:49.402] Packages needed by the future expression (n = 0): <none>
[10:29:49.402] Packages needed by future strategies (n = 0): <none>
[10:29:49.403] {
[10:29:49.403]     {
[10:29:49.403]         {
[10:29:49.403]             ...future.startTime <- base::Sys.time()
[10:29:49.403]             {
[10:29:49.403]                 {
[10:29:49.403]                   {
[10:29:49.403]                     {
[10:29:49.403]                       base::local({
[10:29:49.403]                         has_future <- base::requireNamespace("future", 
[10:29:49.403]                           quietly = TRUE)
[10:29:49.403]                         if (has_future) {
[10:29:49.403]                           ns <- base::getNamespace("future")
[10:29:49.403]                           version <- ns[[".package"]][["version"]]
[10:29:49.403]                           if (is.null(version)) 
[10:29:49.403]                             version <- utils::packageVersion("future")
[10:29:49.403]                         }
[10:29:49.403]                         else {
[10:29:49.403]                           version <- NULL
[10:29:49.403]                         }
[10:29:49.403]                         if (!has_future || version < "1.8.0") {
[10:29:49.403]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.403]                             "", base::R.version$version.string), 
[10:29:49.403]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.403]                               "release", "version")], collapse = " "), 
[10:29:49.403]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.403]                             info)
[10:29:49.403]                           info <- base::paste(info, collapse = "; ")
[10:29:49.403]                           if (!has_future) {
[10:29:49.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.403]                               info)
[10:29:49.403]                           }
[10:29:49.403]                           else {
[10:29:49.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.403]                               info, version)
[10:29:49.403]                           }
[10:29:49.403]                           base::stop(msg)
[10:29:49.403]                         }
[10:29:49.403]                       })
[10:29:49.403]                     }
[10:29:49.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.403]                     base::options(mc.cores = 1L)
[10:29:49.403]                   }
[10:29:49.403]                   ...future.strategy.old <- future::plan("list")
[10:29:49.403]                   options(future.plan = NULL)
[10:29:49.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.403]                 }
[10:29:49.403]                 ...future.workdir <- getwd()
[10:29:49.403]             }
[10:29:49.403]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.403]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.403]         }
[10:29:49.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.403]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.403]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.403]             base::names(...future.oldOptions))
[10:29:49.403]     }
[10:29:49.403]     if (FALSE) {
[10:29:49.403]     }
[10:29:49.403]     else {
[10:29:49.403]         if (TRUE) {
[10:29:49.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.403]                 open = "w")
[10:29:49.403]         }
[10:29:49.403]         else {
[10:29:49.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.403]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.403]         }
[10:29:49.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.403]             base::sink(type = "output", split = FALSE)
[10:29:49.403]             base::close(...future.stdout)
[10:29:49.403]         }, add = TRUE)
[10:29:49.403]     }
[10:29:49.403]     ...future.frame <- base::sys.nframe()
[10:29:49.403]     ...future.conditions <- base::list()
[10:29:49.403]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.403]     if (FALSE) {
[10:29:49.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.403]     }
[10:29:49.403]     ...future.result <- base::tryCatch({
[10:29:49.403]         base::withCallingHandlers({
[10:29:49.403]             ...future.value <- base::withVisible(base::local({
[10:29:49.403]                 withCallingHandlers({
[10:29:49.403]                   {
[10:29:49.403]                     do.call(function(...) {
[10:29:49.403]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.403]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.403]                         ...future.globals.maxSize)) {
[10:29:49.403]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.403]                         on.exit(options(oopts), add = TRUE)
[10:29:49.403]                       }
[10:29:49.403]                       {
[10:29:49.403]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.403]                           FUN = function(jj) {
[10:29:49.403]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.403]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.403]                           })
[10:29:49.403]                       }
[10:29:49.403]                     }, args = future.call.arguments)
[10:29:49.403]                   }
[10:29:49.403]                 }, immediateCondition = function(cond) {
[10:29:49.403]                   save_rds <- function (object, pathname, ...) 
[10:29:49.403]                   {
[10:29:49.403]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.403]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.403]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.403]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.403]                         fi_tmp[["mtime"]])
[10:29:49.403]                     }
[10:29:49.403]                     tryCatch({
[10:29:49.403]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.403]                     }, error = function(ex) {
[10:29:49.403]                       msg <- conditionMessage(ex)
[10:29:49.403]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.403]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.403]                         fi_tmp[["mtime"]], msg)
[10:29:49.403]                       ex$message <- msg
[10:29:49.403]                       stop(ex)
[10:29:49.403]                     })
[10:29:49.403]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.403]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.403]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.403]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.403]                       fi <- file.info(pathname)
[10:29:49.403]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.403]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.403]                         fi[["size"]], fi[["mtime"]])
[10:29:49.403]                       stop(msg)
[10:29:49.403]                     }
[10:29:49.403]                     invisible(pathname)
[10:29:49.403]                   }
[10:29:49.403]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.403]                     rootPath = tempdir()) 
[10:29:49.403]                   {
[10:29:49.403]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.403]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.403]                       tmpdir = path, fileext = ".rds")
[10:29:49.403]                     save_rds(obj, file)
[10:29:49.403]                   }
[10:29:49.403]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.403]                   {
[10:29:49.403]                     inherits <- base::inherits
[10:29:49.403]                     invokeRestart <- base::invokeRestart
[10:29:49.403]                     is.null <- base::is.null
[10:29:49.403]                     muffled <- FALSE
[10:29:49.403]                     if (inherits(cond, "message")) {
[10:29:49.403]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.403]                       if (muffled) 
[10:29:49.403]                         invokeRestart("muffleMessage")
[10:29:49.403]                     }
[10:29:49.403]                     else if (inherits(cond, "warning")) {
[10:29:49.403]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.403]                       if (muffled) 
[10:29:49.403]                         invokeRestart("muffleWarning")
[10:29:49.403]                     }
[10:29:49.403]                     else if (inherits(cond, "condition")) {
[10:29:49.403]                       if (!is.null(pattern)) {
[10:29:49.403]                         computeRestarts <- base::computeRestarts
[10:29:49.403]                         grepl <- base::grepl
[10:29:49.403]                         restarts <- computeRestarts(cond)
[10:29:49.403]                         for (restart in restarts) {
[10:29:49.403]                           name <- restart$name
[10:29:49.403]                           if (is.null(name)) 
[10:29:49.403]                             next
[10:29:49.403]                           if (!grepl(pattern, name)) 
[10:29:49.403]                             next
[10:29:49.403]                           invokeRestart(restart)
[10:29:49.403]                           muffled <- TRUE
[10:29:49.403]                           break
[10:29:49.403]                         }
[10:29:49.403]                       }
[10:29:49.403]                     }
[10:29:49.403]                     invisible(muffled)
[10:29:49.403]                   }
[10:29:49.403]                   muffleCondition(cond)
[10:29:49.403]                 })
[10:29:49.403]             }))
[10:29:49.403]             future::FutureResult(value = ...future.value$value, 
[10:29:49.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.403]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.403]                     ...future.globalenv.names))
[10:29:49.403]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.403]         }, condition = base::local({
[10:29:49.403]             c <- base::c
[10:29:49.403]             inherits <- base::inherits
[10:29:49.403]             invokeRestart <- base::invokeRestart
[10:29:49.403]             length <- base::length
[10:29:49.403]             list <- base::list
[10:29:49.403]             seq.int <- base::seq.int
[10:29:49.403]             signalCondition <- base::signalCondition
[10:29:49.403]             sys.calls <- base::sys.calls
[10:29:49.403]             `[[` <- base::`[[`
[10:29:49.403]             `+` <- base::`+`
[10:29:49.403]             `<<-` <- base::`<<-`
[10:29:49.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.403]                   3L)]
[10:29:49.403]             }
[10:29:49.403]             function(cond) {
[10:29:49.403]                 is_error <- inherits(cond, "error")
[10:29:49.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.403]                   NULL)
[10:29:49.403]                 if (is_error) {
[10:29:49.403]                   sessionInformation <- function() {
[10:29:49.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.403]                       search = base::search(), system = base::Sys.info())
[10:29:49.403]                   }
[10:29:49.403]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.403]                     cond$call), session = sessionInformation(), 
[10:29:49.403]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.403]                   signalCondition(cond)
[10:29:49.403]                 }
[10:29:49.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.403]                 "immediateCondition"))) {
[10:29:49.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.403]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.403]                   if (TRUE && !signal) {
[10:29:49.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.403]                     {
[10:29:49.403]                       inherits <- base::inherits
[10:29:49.403]                       invokeRestart <- base::invokeRestart
[10:29:49.403]                       is.null <- base::is.null
[10:29:49.403]                       muffled <- FALSE
[10:29:49.403]                       if (inherits(cond, "message")) {
[10:29:49.403]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.403]                         if (muffled) 
[10:29:49.403]                           invokeRestart("muffleMessage")
[10:29:49.403]                       }
[10:29:49.403]                       else if (inherits(cond, "warning")) {
[10:29:49.403]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.403]                         if (muffled) 
[10:29:49.403]                           invokeRestart("muffleWarning")
[10:29:49.403]                       }
[10:29:49.403]                       else if (inherits(cond, "condition")) {
[10:29:49.403]                         if (!is.null(pattern)) {
[10:29:49.403]                           computeRestarts <- base::computeRestarts
[10:29:49.403]                           grepl <- base::grepl
[10:29:49.403]                           restarts <- computeRestarts(cond)
[10:29:49.403]                           for (restart in restarts) {
[10:29:49.403]                             name <- restart$name
[10:29:49.403]                             if (is.null(name)) 
[10:29:49.403]                               next
[10:29:49.403]                             if (!grepl(pattern, name)) 
[10:29:49.403]                               next
[10:29:49.403]                             invokeRestart(restart)
[10:29:49.403]                             muffled <- TRUE
[10:29:49.403]                             break
[10:29:49.403]                           }
[10:29:49.403]                         }
[10:29:49.403]                       }
[10:29:49.403]                       invisible(muffled)
[10:29:49.403]                     }
[10:29:49.403]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.403]                   }
[10:29:49.403]                 }
[10:29:49.403]                 else {
[10:29:49.403]                   if (TRUE) {
[10:29:49.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.403]                     {
[10:29:49.403]                       inherits <- base::inherits
[10:29:49.403]                       invokeRestart <- base::invokeRestart
[10:29:49.403]                       is.null <- base::is.null
[10:29:49.403]                       muffled <- FALSE
[10:29:49.403]                       if (inherits(cond, "message")) {
[10:29:49.403]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.403]                         if (muffled) 
[10:29:49.403]                           invokeRestart("muffleMessage")
[10:29:49.403]                       }
[10:29:49.403]                       else if (inherits(cond, "warning")) {
[10:29:49.403]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.403]                         if (muffled) 
[10:29:49.403]                           invokeRestart("muffleWarning")
[10:29:49.403]                       }
[10:29:49.403]                       else if (inherits(cond, "condition")) {
[10:29:49.403]                         if (!is.null(pattern)) {
[10:29:49.403]                           computeRestarts <- base::computeRestarts
[10:29:49.403]                           grepl <- base::grepl
[10:29:49.403]                           restarts <- computeRestarts(cond)
[10:29:49.403]                           for (restart in restarts) {
[10:29:49.403]                             name <- restart$name
[10:29:49.403]                             if (is.null(name)) 
[10:29:49.403]                               next
[10:29:49.403]                             if (!grepl(pattern, name)) 
[10:29:49.403]                               next
[10:29:49.403]                             invokeRestart(restart)
[10:29:49.403]                             muffled <- TRUE
[10:29:49.403]                             break
[10:29:49.403]                           }
[10:29:49.403]                         }
[10:29:49.403]                       }
[10:29:49.403]                       invisible(muffled)
[10:29:49.403]                     }
[10:29:49.403]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.403]                   }
[10:29:49.403]                 }
[10:29:49.403]             }
[10:29:49.403]         }))
[10:29:49.403]     }, error = function(ex) {
[10:29:49.403]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.403]                 ...future.rng), started = ...future.startTime, 
[10:29:49.403]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.403]             version = "1.8"), class = "FutureResult")
[10:29:49.403]     }, finally = {
[10:29:49.403]         if (!identical(...future.workdir, getwd())) 
[10:29:49.403]             setwd(...future.workdir)
[10:29:49.403]         {
[10:29:49.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.403]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.403]             }
[10:29:49.403]             base::options(...future.oldOptions)
[10:29:49.403]             if (.Platform$OS.type == "windows") {
[10:29:49.403]                 old_names <- names(...future.oldEnvVars)
[10:29:49.403]                 envs <- base::Sys.getenv()
[10:29:49.403]                 names <- names(envs)
[10:29:49.403]                 common <- intersect(names, old_names)
[10:29:49.403]                 added <- setdiff(names, old_names)
[10:29:49.403]                 removed <- setdiff(old_names, names)
[10:29:49.403]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.403]                   envs[common]]
[10:29:49.403]                 NAMES <- toupper(changed)
[10:29:49.403]                 args <- list()
[10:29:49.403]                 for (kk in seq_along(NAMES)) {
[10:29:49.403]                   name <- changed[[kk]]
[10:29:49.403]                   NAME <- NAMES[[kk]]
[10:29:49.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.403]                     next
[10:29:49.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.403]                 }
[10:29:49.403]                 NAMES <- toupper(added)
[10:29:49.403]                 for (kk in seq_along(NAMES)) {
[10:29:49.403]                   name <- added[[kk]]
[10:29:49.403]                   NAME <- NAMES[[kk]]
[10:29:49.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.403]                     next
[10:29:49.403]                   args[[name]] <- ""
[10:29:49.403]                 }
[10:29:49.403]                 NAMES <- toupper(removed)
[10:29:49.403]                 for (kk in seq_along(NAMES)) {
[10:29:49.403]                   name <- removed[[kk]]
[10:29:49.403]                   NAME <- NAMES[[kk]]
[10:29:49.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.403]                     next
[10:29:49.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.403]                 }
[10:29:49.403]                 if (length(args) > 0) 
[10:29:49.403]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.403]             }
[10:29:49.403]             else {
[10:29:49.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.403]             }
[10:29:49.403]             {
[10:29:49.403]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.403]                   0L) {
[10:29:49.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.403]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.403]                   base::options(opts)
[10:29:49.403]                 }
[10:29:49.403]                 {
[10:29:49.403]                   {
[10:29:49.403]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.403]                     NULL
[10:29:49.403]                   }
[10:29:49.403]                   options(future.plan = NULL)
[10:29:49.403]                   if (is.na(NA_character_)) 
[10:29:49.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.403]                     .init = FALSE)
[10:29:49.403]                 }
[10:29:49.403]             }
[10:29:49.403]         }
[10:29:49.403]     })
[10:29:49.403]     if (TRUE) {
[10:29:49.403]         base::sink(type = "output", split = FALSE)
[10:29:49.403]         if (TRUE) {
[10:29:49.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.403]         }
[10:29:49.403]         else {
[10:29:49.403]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.403]         }
[10:29:49.403]         base::close(...future.stdout)
[10:29:49.403]         ...future.stdout <- NULL
[10:29:49.403]     }
[10:29:49.403]     ...future.result$conditions <- ...future.conditions
[10:29:49.403]     ...future.result$finished <- base::Sys.time()
[10:29:49.403]     ...future.result
[10:29:49.403] }
[10:29:49.406] assign_globals() ...
[10:29:49.406] List of 5
[10:29:49.406]  $ future.call.arguments    : list()
[10:29:49.406]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.406]  $ ...future.FUN            :function (x)  
[10:29:49.406]  $ ...future.elements_ii    :List of 3
[10:29:49.406]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:29:49.406]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:29:49.406]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:29:49.406]  $ ...future.seeds_ii       : NULL
[10:29:49.406]  $ ...future.globals.maxSize: num Inf
[10:29:49.406]  - attr(*, "resolved")= logi FALSE
[10:29:49.406]  - attr(*, "total_size")= num NA
[10:29:49.406]  - attr(*, "where")=List of 5
[10:29:49.406]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.406]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.406]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.406]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.406]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.406]  - attr(*, "already-done")= logi TRUE
[10:29:49.414] - copied ‘future.call.arguments’ to environment
[10:29:49.414] - copied ‘...future.FUN’ to environment
[10:29:49.414] - copied ‘...future.elements_ii’ to environment
[10:29:49.414] - copied ‘...future.seeds_ii’ to environment
[10:29:49.414] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.414] assign_globals() ... done
[10:29:49.414] requestCore(): workers = 2
[10:29:49.417] MulticoreFuture started
[10:29:49.417] - Launch lazy future ... done
[10:29:49.417] run() for ‘MulticoreFuture’ ... done
[10:29:49.417] Created future:
[10:29:49.418] plan(): Setting new future strategy stack:
[10:29:49.418] List of future strategies:
[10:29:49.418] 1. sequential:
[10:29:49.418]    - args: function (..., envir = parent.frame())
[10:29:49.418]    - tweaked: FALSE
[10:29:49.418]    - call: NULL
[10:29:49.419] plan(): nbrOfWorkers() = 1
[10:29:49.421] plan(): Setting new future strategy stack:
[10:29:49.421] List of future strategies:
[10:29:49.421] 1. multicore:
[10:29:49.421]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.421]    - tweaked: FALSE
[10:29:49.421]    - call: plan(strategy)
[10:29:49.427] plan(): nbrOfWorkers() = 2
[10:29:49.418] MulticoreFuture:
[10:29:49.418] Label: ‘future_apply-2’
[10:29:49.418] Expression:
[10:29:49.418] {
[10:29:49.418]     do.call(function(...) {
[10:29:49.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.418]             on.exit(options(oopts), add = TRUE)
[10:29:49.418]         }
[10:29:49.418]         {
[10:29:49.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.418]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.418]             })
[10:29:49.418]         }
[10:29:49.418]     }, args = future.call.arguments)
[10:29:49.418] }
[10:29:49.418] Lazy evaluation: FALSE
[10:29:49.418] Asynchronous evaluation: TRUE
[10:29:49.418] Local evaluation: TRUE
[10:29:49.418] Environment: R_GlobalEnv
[10:29:49.418] Capture standard output: TRUE
[10:29:49.418] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.418] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.418] Packages: <none>
[10:29:49.418] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.418] Resolved: TRUE
[10:29:49.418] Value: <not collected>
[10:29:49.418] Conditions captured: <none>
[10:29:49.418] Early signaling: FALSE
[10:29:49.418] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.418] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.428] Chunk #2 of 2 ... DONE
[10:29:49.428] Launching 2 futures (chunks) ... DONE
[10:29:49.428] Resolving 2 futures (chunks) ...
[10:29:49.428] resolve() on list ...
[10:29:49.428]  recursive: 0
[10:29:49.429]  length: 2
[10:29:49.429] 
[10:29:49.429] Future #1
[10:29:49.429] result() for MulticoreFuture ...
[10:29:49.430] result() for MulticoreFuture ...
[10:29:49.430] result() for MulticoreFuture ... done
[10:29:49.430] result() for MulticoreFuture ... done
[10:29:49.431] result() for MulticoreFuture ...
[10:29:49.431] result() for MulticoreFuture ... done
[10:29:49.431] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:49.431] - nx: 2
[10:29:49.431] - relay: TRUE
[10:29:49.431] - stdout: TRUE
[10:29:49.431] - signal: TRUE
[10:29:49.432] - resignal: FALSE
[10:29:49.432] - force: TRUE
[10:29:49.432] - relayed: [n=2] FALSE, FALSE
[10:29:49.432] - queued futures: [n=2] FALSE, FALSE
[10:29:49.432]  - until=1
[10:29:49.432]  - relaying element #1
[10:29:49.432] result() for MulticoreFuture ...
[10:29:49.432] result() for MulticoreFuture ... done
[10:29:49.433] result() for MulticoreFuture ...
[10:29:49.433] result() for MulticoreFuture ... done
[10:29:49.433] result() for MulticoreFuture ...
[10:29:49.433] result() for MulticoreFuture ... done
[10:29:49.433] result() for MulticoreFuture ...
[10:29:49.433] result() for MulticoreFuture ... done
[10:29:49.434] - relayed: [n=2] TRUE, FALSE
[10:29:49.434] - queued futures: [n=2] TRUE, FALSE
[10:29:49.434] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:49.434]  length: 1 (resolved future 1)
[10:29:49.434] Future #2
[10:29:49.435] result() for MulticoreFuture ...
[10:29:49.435] result() for MulticoreFuture ...
[10:29:49.435] result() for MulticoreFuture ... done
[10:29:49.436] result() for MulticoreFuture ... done
[10:29:49.436] result() for MulticoreFuture ...
[10:29:49.436] result() for MulticoreFuture ... done
[10:29:49.436] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:49.436] - nx: 2
[10:29:49.437] - relay: TRUE
[10:29:49.437] - stdout: TRUE
[10:29:49.437] - signal: TRUE
[10:29:49.437] - resignal: FALSE
[10:29:49.437] - force: TRUE
[10:29:49.437] - relayed: [n=2] TRUE, FALSE
[10:29:49.438] - queued futures: [n=2] TRUE, FALSE
[10:29:49.438]  - until=2
[10:29:49.438]  - relaying element #2
[10:29:49.438] result() for MulticoreFuture ...
[10:29:49.438] result() for MulticoreFuture ... done
[10:29:49.438] result() for MulticoreFuture ...
[10:29:49.438] result() for MulticoreFuture ... done
[10:29:49.439] result() for MulticoreFuture ...
[10:29:49.441] result() for MulticoreFuture ... done
[10:29:49.441] result() for MulticoreFuture ...
[10:29:49.442] result() for MulticoreFuture ... done
[10:29:49.442] - relayed: [n=2] TRUE, TRUE
[10:29:49.442] - queued futures: [n=2] TRUE, TRUE
[10:29:49.442] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:49.442]  length: 0 (resolved future 2)
[10:29:49.443] Relaying remaining futures
[10:29:49.443] signalConditionsASAP(NULL, pos=0) ...
[10:29:49.443] - nx: 2
[10:29:49.443] - relay: TRUE
[10:29:49.443] - stdout: TRUE
[10:29:49.443] - signal: TRUE
[10:29:49.443] - resignal: FALSE
[10:29:49.444] - force: TRUE
[10:29:49.444] - relayed: [n=2] TRUE, TRUE
[10:29:49.444] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:49.444] - relayed: [n=2] TRUE, TRUE
[10:29:49.444] - queued futures: [n=2] TRUE, TRUE
[10:29:49.445] signalConditionsASAP(NULL, pos=0) ... done
[10:29:49.445] resolve() on list ... DONE
[10:29:49.445] result() for MulticoreFuture ...
[10:29:49.445] result() for MulticoreFuture ... done
[10:29:49.445] result() for MulticoreFuture ...
[10:29:49.445] result() for MulticoreFuture ... done
[10:29:49.446] result() for MulticoreFuture ...
[10:29:49.446] result() for MulticoreFuture ... done
[10:29:49.446] result() for MulticoreFuture ...
[10:29:49.446] result() for MulticoreFuture ... done
[10:29:49.446]  - Number of value chunks collected: 2
[10:29:49.446] Resolving 2 futures (chunks) ... DONE
[10:29:49.446] Reducing values from 2 chunks ...
[10:29:49.446]  - Number of values collected after concatenation: 6
[10:29:49.447]  - Number of values expected: 6
[10:29:49.447] Reducing values from 2 chunks ... DONE
[10:29:49.447] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:29:49.447] getGlobalsAndPackagesXApply() ...
[10:29:49.448]  - future.globals: TRUE
[10:29:49.448] getGlobalsAndPackages() ...
[10:29:49.448] Searching for globals...
[10:29:49.450] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:29:49.450] Searching for globals ... DONE
[10:29:49.450] Resolving globals: FALSE
[10:29:49.450] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[10:29:49.451] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[10:29:49.451] - globals: [1] ‘FUN’
[10:29:49.451] 
[10:29:49.451] getGlobalsAndPackages() ... DONE
[10:29:49.451]  - globals found/used: [n=1] ‘FUN’
[10:29:49.452]  - needed namespaces: [n=0] 
[10:29:49.452] Finding globals ... DONE
[10:29:49.452]  - use_args: TRUE
[10:29:49.452]  - Getting '...' globals ...
[10:29:49.452] resolve() on list ...
[10:29:49.452]  recursive: 0
[10:29:49.452]  length: 1
[10:29:49.453]  elements: ‘...’
[10:29:49.453]  length: 0 (resolved future 1)
[10:29:49.453] resolve() on list ... DONE
[10:29:49.453]    - '...' content: [n=0] 
[10:29:49.453] List of 1
[10:29:49.453]  $ ...: list()
[10:29:49.453]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.453]  - attr(*, "where")=List of 1
[10:29:49.453]   ..$ ...:<environment: 0x5618a12bebe8> 
[10:29:49.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.453]  - attr(*, "resolved")= logi TRUE
[10:29:49.453]  - attr(*, "total_size")= num NA
[10:29:49.456]  - Getting '...' globals ... DONE
[10:29:49.456] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:49.456] List of 2
[10:29:49.456]  $ ...future.FUN:function (x)  
[10:29:49.456]  $ ...          : list()
[10:29:49.456]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.456]  - attr(*, "where")=List of 2
[10:29:49.456]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:49.456]   ..$ ...          :<environment: 0x5618a12bebe8> 
[10:29:49.456]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.456]  - attr(*, "resolved")= logi FALSE
[10:29:49.456]  - attr(*, "total_size")= num 1768
[10:29:49.459] Packages to be attached in all futures: [n=0] 
[10:29:49.459] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.463] future_lapply() ...
[10:29:49.467] Number of chunks: 2
[10:29:49.467] getGlobalsAndPackagesXApply() ...
[10:29:49.467]  - future.globals: <name-value list> with names ‘list()’
[10:29:49.468]  - use_args: TRUE
[10:29:49.468] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:49.468] List of 2
[10:29:49.468]  $ ...          : list()
[10:29:49.468]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.468]  $ ...future.FUN:function (x)  
[10:29:49.468]  - attr(*, "where")=List of 2
[10:29:49.468]   ..$ ...          :<environment: 0x5618a12bebe8> 
[10:29:49.468]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:29:49.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.468]  - attr(*, "resolved")= logi FALSE
[10:29:49.468]  - attr(*, "total_size")= num NA
[10:29:49.473] Packages to be attached in all futures: [n=0] 
[10:29:49.473] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.473] Number of futures (= number of chunks): 2
[10:29:49.473] Launching 2 futures (chunks) ...
[10:29:49.473] Chunk #1 of 2 ...
[10:29:49.474]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.474]  - seeds: <none>
[10:29:49.474]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.474] getGlobalsAndPackages() ...
[10:29:49.474] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.474] Resolving globals: FALSE
[10:29:49.474] Tweak future expression to call with '...' arguments ...
[10:29:49.475] {
[10:29:49.475]     do.call(function(...) {
[10:29:49.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.475]             on.exit(options(oopts), add = TRUE)
[10:29:49.475]         }
[10:29:49.475]         {
[10:29:49.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.475]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.475]             })
[10:29:49.475]         }
[10:29:49.475]     }, args = future.call.arguments)
[10:29:49.475] }
[10:29:49.475] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.475] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.475] 
[10:29:49.476] getGlobalsAndPackages() ... DONE
[10:29:49.476] run() for ‘Future’ ...
[10:29:49.476] - state: ‘created’
[10:29:49.476] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.480] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.480]   - Field: ‘label’
[10:29:49.480]   - Field: ‘local’
[10:29:49.480]   - Field: ‘owner’
[10:29:49.480]   - Field: ‘envir’
[10:29:49.480]   - Field: ‘workers’
[10:29:49.481]   - Field: ‘packages’
[10:29:49.481]   - Field: ‘gc’
[10:29:49.481]   - Field: ‘job’
[10:29:49.481]   - Field: ‘conditions’
[10:29:49.481]   - Field: ‘expr’
[10:29:49.481]   - Field: ‘uuid’
[10:29:49.481]   - Field: ‘seed’
[10:29:49.481]   - Field: ‘version’
[10:29:49.481]   - Field: ‘result’
[10:29:49.481]   - Field: ‘asynchronous’
[10:29:49.482]   - Field: ‘calls’
[10:29:49.482]   - Field: ‘globals’
[10:29:49.482]   - Field: ‘stdout’
[10:29:49.482]   - Field: ‘earlySignal’
[10:29:49.482]   - Field: ‘lazy’
[10:29:49.482]   - Field: ‘state’
[10:29:49.482] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.482] - Launch lazy future ...
[10:29:49.482] Packages needed by the future expression (n = 0): <none>
[10:29:49.483] Packages needed by future strategies (n = 0): <none>
[10:29:49.483] {
[10:29:49.483]     {
[10:29:49.483]         {
[10:29:49.483]             ...future.startTime <- base::Sys.time()
[10:29:49.483]             {
[10:29:49.483]                 {
[10:29:49.483]                   {
[10:29:49.483]                     {
[10:29:49.483]                       base::local({
[10:29:49.483]                         has_future <- base::requireNamespace("future", 
[10:29:49.483]                           quietly = TRUE)
[10:29:49.483]                         if (has_future) {
[10:29:49.483]                           ns <- base::getNamespace("future")
[10:29:49.483]                           version <- ns[[".package"]][["version"]]
[10:29:49.483]                           if (is.null(version)) 
[10:29:49.483]                             version <- utils::packageVersion("future")
[10:29:49.483]                         }
[10:29:49.483]                         else {
[10:29:49.483]                           version <- NULL
[10:29:49.483]                         }
[10:29:49.483]                         if (!has_future || version < "1.8.0") {
[10:29:49.483]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.483]                             "", base::R.version$version.string), 
[10:29:49.483]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.483]                               "release", "version")], collapse = " "), 
[10:29:49.483]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.483]                             info)
[10:29:49.483]                           info <- base::paste(info, collapse = "; ")
[10:29:49.483]                           if (!has_future) {
[10:29:49.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.483]                               info)
[10:29:49.483]                           }
[10:29:49.483]                           else {
[10:29:49.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.483]                               info, version)
[10:29:49.483]                           }
[10:29:49.483]                           base::stop(msg)
[10:29:49.483]                         }
[10:29:49.483]                       })
[10:29:49.483]                     }
[10:29:49.483]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.483]                     base::options(mc.cores = 1L)
[10:29:49.483]                   }
[10:29:49.483]                   ...future.strategy.old <- future::plan("list")
[10:29:49.483]                   options(future.plan = NULL)
[10:29:49.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.483]                 }
[10:29:49.483]                 ...future.workdir <- getwd()
[10:29:49.483]             }
[10:29:49.483]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.483]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.483]         }
[10:29:49.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.483]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.483]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.483]             base::names(...future.oldOptions))
[10:29:49.483]     }
[10:29:49.483]     if (FALSE) {
[10:29:49.483]     }
[10:29:49.483]     else {
[10:29:49.483]         if (TRUE) {
[10:29:49.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.483]                 open = "w")
[10:29:49.483]         }
[10:29:49.483]         else {
[10:29:49.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.483]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.483]         }
[10:29:49.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.483]             base::sink(type = "output", split = FALSE)
[10:29:49.483]             base::close(...future.stdout)
[10:29:49.483]         }, add = TRUE)
[10:29:49.483]     }
[10:29:49.483]     ...future.frame <- base::sys.nframe()
[10:29:49.483]     ...future.conditions <- base::list()
[10:29:49.483]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.483]     if (FALSE) {
[10:29:49.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.483]     }
[10:29:49.483]     ...future.result <- base::tryCatch({
[10:29:49.483]         base::withCallingHandlers({
[10:29:49.483]             ...future.value <- base::withVisible(base::local({
[10:29:49.483]                 withCallingHandlers({
[10:29:49.483]                   {
[10:29:49.483]                     do.call(function(...) {
[10:29:49.483]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.483]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.483]                         ...future.globals.maxSize)) {
[10:29:49.483]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.483]                         on.exit(options(oopts), add = TRUE)
[10:29:49.483]                       }
[10:29:49.483]                       {
[10:29:49.483]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.483]                           FUN = function(jj) {
[10:29:49.483]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.483]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.483]                           })
[10:29:49.483]                       }
[10:29:49.483]                     }, args = future.call.arguments)
[10:29:49.483]                   }
[10:29:49.483]                 }, immediateCondition = function(cond) {
[10:29:49.483]                   save_rds <- function (object, pathname, ...) 
[10:29:49.483]                   {
[10:29:49.483]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.483]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.483]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.483]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.483]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.483]                         fi_tmp[["mtime"]])
[10:29:49.483]                     }
[10:29:49.483]                     tryCatch({
[10:29:49.483]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.483]                     }, error = function(ex) {
[10:29:49.483]                       msg <- conditionMessage(ex)
[10:29:49.483]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.483]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.483]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.483]                         fi_tmp[["mtime"]], msg)
[10:29:49.483]                       ex$message <- msg
[10:29:49.483]                       stop(ex)
[10:29:49.483]                     })
[10:29:49.483]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.483]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.483]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.483]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.483]                       fi <- file.info(pathname)
[10:29:49.483]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.483]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.483]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.483]                         fi[["size"]], fi[["mtime"]])
[10:29:49.483]                       stop(msg)
[10:29:49.483]                     }
[10:29:49.483]                     invisible(pathname)
[10:29:49.483]                   }
[10:29:49.483]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.483]                     rootPath = tempdir()) 
[10:29:49.483]                   {
[10:29:49.483]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.483]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.483]                       tmpdir = path, fileext = ".rds")
[10:29:49.483]                     save_rds(obj, file)
[10:29:49.483]                   }
[10:29:49.483]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.483]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.483]                   {
[10:29:49.483]                     inherits <- base::inherits
[10:29:49.483]                     invokeRestart <- base::invokeRestart
[10:29:49.483]                     is.null <- base::is.null
[10:29:49.483]                     muffled <- FALSE
[10:29:49.483]                     if (inherits(cond, "message")) {
[10:29:49.483]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.483]                       if (muffled) 
[10:29:49.483]                         invokeRestart("muffleMessage")
[10:29:49.483]                     }
[10:29:49.483]                     else if (inherits(cond, "warning")) {
[10:29:49.483]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.483]                       if (muffled) 
[10:29:49.483]                         invokeRestart("muffleWarning")
[10:29:49.483]                     }
[10:29:49.483]                     else if (inherits(cond, "condition")) {
[10:29:49.483]                       if (!is.null(pattern)) {
[10:29:49.483]                         computeRestarts <- base::computeRestarts
[10:29:49.483]                         grepl <- base::grepl
[10:29:49.483]                         restarts <- computeRestarts(cond)
[10:29:49.483]                         for (restart in restarts) {
[10:29:49.483]                           name <- restart$name
[10:29:49.483]                           if (is.null(name)) 
[10:29:49.483]                             next
[10:29:49.483]                           if (!grepl(pattern, name)) 
[10:29:49.483]                             next
[10:29:49.483]                           invokeRestart(restart)
[10:29:49.483]                           muffled <- TRUE
[10:29:49.483]                           break
[10:29:49.483]                         }
[10:29:49.483]                       }
[10:29:49.483]                     }
[10:29:49.483]                     invisible(muffled)
[10:29:49.483]                   }
[10:29:49.483]                   muffleCondition(cond)
[10:29:49.483]                 })
[10:29:49.483]             }))
[10:29:49.483]             future::FutureResult(value = ...future.value$value, 
[10:29:49.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.483]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.483]                     ...future.globalenv.names))
[10:29:49.483]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.483]         }, condition = base::local({
[10:29:49.483]             c <- base::c
[10:29:49.483]             inherits <- base::inherits
[10:29:49.483]             invokeRestart <- base::invokeRestart
[10:29:49.483]             length <- base::length
[10:29:49.483]             list <- base::list
[10:29:49.483]             seq.int <- base::seq.int
[10:29:49.483]             signalCondition <- base::signalCondition
[10:29:49.483]             sys.calls <- base::sys.calls
[10:29:49.483]             `[[` <- base::`[[`
[10:29:49.483]             `+` <- base::`+`
[10:29:49.483]             `<<-` <- base::`<<-`
[10:29:49.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.483]                   3L)]
[10:29:49.483]             }
[10:29:49.483]             function(cond) {
[10:29:49.483]                 is_error <- inherits(cond, "error")
[10:29:49.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.483]                   NULL)
[10:29:49.483]                 if (is_error) {
[10:29:49.483]                   sessionInformation <- function() {
[10:29:49.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.483]                       search = base::search(), system = base::Sys.info())
[10:29:49.483]                   }
[10:29:49.483]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.483]                     cond$call), session = sessionInformation(), 
[10:29:49.483]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.483]                   signalCondition(cond)
[10:29:49.483]                 }
[10:29:49.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.483]                 "immediateCondition"))) {
[10:29:49.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.483]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.483]                   if (TRUE && !signal) {
[10:29:49.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.483]                     {
[10:29:49.483]                       inherits <- base::inherits
[10:29:49.483]                       invokeRestart <- base::invokeRestart
[10:29:49.483]                       is.null <- base::is.null
[10:29:49.483]                       muffled <- FALSE
[10:29:49.483]                       if (inherits(cond, "message")) {
[10:29:49.483]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.483]                         if (muffled) 
[10:29:49.483]                           invokeRestart("muffleMessage")
[10:29:49.483]                       }
[10:29:49.483]                       else if (inherits(cond, "warning")) {
[10:29:49.483]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.483]                         if (muffled) 
[10:29:49.483]                           invokeRestart("muffleWarning")
[10:29:49.483]                       }
[10:29:49.483]                       else if (inherits(cond, "condition")) {
[10:29:49.483]                         if (!is.null(pattern)) {
[10:29:49.483]                           computeRestarts <- base::computeRestarts
[10:29:49.483]                           grepl <- base::grepl
[10:29:49.483]                           restarts <- computeRestarts(cond)
[10:29:49.483]                           for (restart in restarts) {
[10:29:49.483]                             name <- restart$name
[10:29:49.483]                             if (is.null(name)) 
[10:29:49.483]                               next
[10:29:49.483]                             if (!grepl(pattern, name)) 
[10:29:49.483]                               next
[10:29:49.483]                             invokeRestart(restart)
[10:29:49.483]                             muffled <- TRUE
[10:29:49.483]                             break
[10:29:49.483]                           }
[10:29:49.483]                         }
[10:29:49.483]                       }
[10:29:49.483]                       invisible(muffled)
[10:29:49.483]                     }
[10:29:49.483]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.483]                   }
[10:29:49.483]                 }
[10:29:49.483]                 else {
[10:29:49.483]                   if (TRUE) {
[10:29:49.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.483]                     {
[10:29:49.483]                       inherits <- base::inherits
[10:29:49.483]                       invokeRestart <- base::invokeRestart
[10:29:49.483]                       is.null <- base::is.null
[10:29:49.483]                       muffled <- FALSE
[10:29:49.483]                       if (inherits(cond, "message")) {
[10:29:49.483]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.483]                         if (muffled) 
[10:29:49.483]                           invokeRestart("muffleMessage")
[10:29:49.483]                       }
[10:29:49.483]                       else if (inherits(cond, "warning")) {
[10:29:49.483]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.483]                         if (muffled) 
[10:29:49.483]                           invokeRestart("muffleWarning")
[10:29:49.483]                       }
[10:29:49.483]                       else if (inherits(cond, "condition")) {
[10:29:49.483]                         if (!is.null(pattern)) {
[10:29:49.483]                           computeRestarts <- base::computeRestarts
[10:29:49.483]                           grepl <- base::grepl
[10:29:49.483]                           restarts <- computeRestarts(cond)
[10:29:49.483]                           for (restart in restarts) {
[10:29:49.483]                             name <- restart$name
[10:29:49.483]                             if (is.null(name)) 
[10:29:49.483]                               next
[10:29:49.483]                             if (!grepl(pattern, name)) 
[10:29:49.483]                               next
[10:29:49.483]                             invokeRestart(restart)
[10:29:49.483]                             muffled <- TRUE
[10:29:49.483]                             break
[10:29:49.483]                           }
[10:29:49.483]                         }
[10:29:49.483]                       }
[10:29:49.483]                       invisible(muffled)
[10:29:49.483]                     }
[10:29:49.483]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.483]                   }
[10:29:49.483]                 }
[10:29:49.483]             }
[10:29:49.483]         }))
[10:29:49.483]     }, error = function(ex) {
[10:29:49.483]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.483]                 ...future.rng), started = ...future.startTime, 
[10:29:49.483]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.483]             version = "1.8"), class = "FutureResult")
[10:29:49.483]     }, finally = {
[10:29:49.483]         if (!identical(...future.workdir, getwd())) 
[10:29:49.483]             setwd(...future.workdir)
[10:29:49.483]         {
[10:29:49.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.483]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.483]             }
[10:29:49.483]             base::options(...future.oldOptions)
[10:29:49.483]             if (.Platform$OS.type == "windows") {
[10:29:49.483]                 old_names <- names(...future.oldEnvVars)
[10:29:49.483]                 envs <- base::Sys.getenv()
[10:29:49.483]                 names <- names(envs)
[10:29:49.483]                 common <- intersect(names, old_names)
[10:29:49.483]                 added <- setdiff(names, old_names)
[10:29:49.483]                 removed <- setdiff(old_names, names)
[10:29:49.483]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.483]                   envs[common]]
[10:29:49.483]                 NAMES <- toupper(changed)
[10:29:49.483]                 args <- list()
[10:29:49.483]                 for (kk in seq_along(NAMES)) {
[10:29:49.483]                   name <- changed[[kk]]
[10:29:49.483]                   NAME <- NAMES[[kk]]
[10:29:49.483]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.483]                     next
[10:29:49.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.483]                 }
[10:29:49.483]                 NAMES <- toupper(added)
[10:29:49.483]                 for (kk in seq_along(NAMES)) {
[10:29:49.483]                   name <- added[[kk]]
[10:29:49.483]                   NAME <- NAMES[[kk]]
[10:29:49.483]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.483]                     next
[10:29:49.483]                   args[[name]] <- ""
[10:29:49.483]                 }
[10:29:49.483]                 NAMES <- toupper(removed)
[10:29:49.483]                 for (kk in seq_along(NAMES)) {
[10:29:49.483]                   name <- removed[[kk]]
[10:29:49.483]                   NAME <- NAMES[[kk]]
[10:29:49.483]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.483]                     next
[10:29:49.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.483]                 }
[10:29:49.483]                 if (length(args) > 0) 
[10:29:49.483]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.483]             }
[10:29:49.483]             else {
[10:29:49.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.483]             }
[10:29:49.483]             {
[10:29:49.483]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.483]                   0L) {
[10:29:49.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.483]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.483]                   base::options(opts)
[10:29:49.483]                 }
[10:29:49.483]                 {
[10:29:49.483]                   {
[10:29:49.483]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.483]                     NULL
[10:29:49.483]                   }
[10:29:49.483]                   options(future.plan = NULL)
[10:29:49.483]                   if (is.na(NA_character_)) 
[10:29:49.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.483]                     .init = FALSE)
[10:29:49.483]                 }
[10:29:49.483]             }
[10:29:49.483]         }
[10:29:49.483]     })
[10:29:49.483]     if (TRUE) {
[10:29:49.483]         base::sink(type = "output", split = FALSE)
[10:29:49.483]         if (TRUE) {
[10:29:49.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.483]         }
[10:29:49.483]         else {
[10:29:49.483]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.483]         }
[10:29:49.483]         base::close(...future.stdout)
[10:29:49.483]         ...future.stdout <- NULL
[10:29:49.483]     }
[10:29:49.483]     ...future.result$conditions <- ...future.conditions
[10:29:49.483]     ...future.result$finished <- base::Sys.time()
[10:29:49.483]     ...future.result
[10:29:49.483] }
[10:29:49.485] assign_globals() ...
[10:29:49.486] List of 5
[10:29:49.486]  $ future.call.arguments    : list()
[10:29:49.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.486]  $ ...future.FUN            :function (x)  
[10:29:49.486]  $ ...future.elements_ii    :List of 3
[10:29:49.486]   ..$ : int [1:4] 1 7 13 19
[10:29:49.486]   ..$ : int [1:4] 2 8 14 20
[10:29:49.486]   ..$ : int [1:4] 3 9 15 21
[10:29:49.486]  $ ...future.seeds_ii       : NULL
[10:29:49.486]  $ ...future.globals.maxSize: num Inf
[10:29:49.486]  - attr(*, "resolved")= logi FALSE
[10:29:49.486]  - attr(*, "total_size")= num NA
[10:29:49.486]  - attr(*, "where")=List of 5
[10:29:49.486]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.486]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.486]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.486]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.486]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.486]  - attr(*, "already-done")= logi TRUE
[10:29:49.491] - copied ‘future.call.arguments’ to environment
[10:29:49.491] - reassign environment for ‘...future.FUN’
[10:29:49.491] - copied ‘...future.FUN’ to environment
[10:29:49.491] - copied ‘...future.elements_ii’ to environment
[10:29:49.491] - copied ‘...future.seeds_ii’ to environment
[10:29:49.491] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.491] assign_globals() ... done
[10:29:49.492] requestCore(): workers = 2
[10:29:49.494] MulticoreFuture started
[10:29:49.494] - Launch lazy future ... done
[10:29:49.494] run() for ‘MulticoreFuture’ ... done
[10:29:49.495] Created future:
[10:29:49.495] plan(): Setting new future strategy stack:
[10:29:49.495] List of future strategies:
[10:29:49.495] 1. sequential:
[10:29:49.495]    - args: function (..., envir = parent.frame())
[10:29:49.495]    - tweaked: FALSE
[10:29:49.495]    - call: NULL
[10:29:49.496] plan(): nbrOfWorkers() = 1
[10:29:49.498] plan(): Setting new future strategy stack:
[10:29:49.498] List of future strategies:
[10:29:49.498] 1. multicore:
[10:29:49.498]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.498]    - tweaked: FALSE
[10:29:49.498]    - call: plan(strategy)
[10:29:49.503] plan(): nbrOfWorkers() = 2
[10:29:49.495] MulticoreFuture:
[10:29:49.495] Label: ‘future_apply-1’
[10:29:49.495] Expression:
[10:29:49.495] {
[10:29:49.495]     do.call(function(...) {
[10:29:49.495]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.495]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.495]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.495]             on.exit(options(oopts), add = TRUE)
[10:29:49.495]         }
[10:29:49.495]         {
[10:29:49.495]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.495]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.495]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.495]             })
[10:29:49.495]         }
[10:29:49.495]     }, args = future.call.arguments)
[10:29:49.495] }
[10:29:49.495] Lazy evaluation: FALSE
[10:29:49.495] Asynchronous evaluation: TRUE
[10:29:49.495] Local evaluation: TRUE
[10:29:49.495] Environment: R_GlobalEnv
[10:29:49.495] Capture standard output: TRUE
[10:29:49.495] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.495] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.495] Packages: <none>
[10:29:49.495] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.495] Resolved: TRUE
[10:29:49.495] Value: <not collected>
[10:29:49.495] Conditions captured: <none>
[10:29:49.495] Early signaling: FALSE
[10:29:49.495] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.495] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.504] Chunk #1 of 2 ... DONE
[10:29:49.504] Chunk #2 of 2 ...
[10:29:49.505]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.505]  - seeds: <none>
[10:29:49.505]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.505] getGlobalsAndPackages() ...
[10:29:49.505] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.506] Resolving globals: FALSE
[10:29:49.506] Tweak future expression to call with '...' arguments ...
[10:29:49.506] {
[10:29:49.506]     do.call(function(...) {
[10:29:49.506]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.506]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.506]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.506]             on.exit(options(oopts), add = TRUE)
[10:29:49.506]         }
[10:29:49.506]         {
[10:29:49.506]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.506]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.506]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.506]             })
[10:29:49.506]         }
[10:29:49.506]     }, args = future.call.arguments)
[10:29:49.506] }
[10:29:49.506] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.507] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.507] 
[10:29:49.507] getGlobalsAndPackages() ... DONE
[10:29:49.508] run() for ‘Future’ ...
[10:29:49.508] - state: ‘created’
[10:29:49.508] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.517] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.517]   - Field: ‘label’
[10:29:49.518]   - Field: ‘local’
[10:29:49.518]   - Field: ‘owner’
[10:29:49.518]   - Field: ‘envir’
[10:29:49.519]   - Field: ‘workers’
[10:29:49.519]   - Field: ‘packages’
[10:29:49.519]   - Field: ‘gc’
[10:29:49.519]   - Field: ‘job’
[10:29:49.519]   - Field: ‘conditions’
[10:29:49.520]   - Field: ‘expr’
[10:29:49.520]   - Field: ‘uuid’
[10:29:49.520]   - Field: ‘seed’
[10:29:49.521]   - Field: ‘version’
[10:29:49.521]   - Field: ‘result’
[10:29:49.521]   - Field: ‘asynchronous’
[10:29:49.521]   - Field: ‘calls’
[10:29:49.522]   - Field: ‘globals’
[10:29:49.522]   - Field: ‘stdout’
[10:29:49.522]   - Field: ‘earlySignal’
[10:29:49.522]   - Field: ‘lazy’
[10:29:49.523]   - Field: ‘state’
[10:29:49.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.523] - Launch lazy future ...
[10:29:49.523] Packages needed by the future expression (n = 0): <none>
[10:29:49.524] Packages needed by future strategies (n = 0): <none>
[10:29:49.524] {
[10:29:49.524]     {
[10:29:49.524]         {
[10:29:49.524]             ...future.startTime <- base::Sys.time()
[10:29:49.524]             {
[10:29:49.524]                 {
[10:29:49.524]                   {
[10:29:49.524]                     {
[10:29:49.524]                       base::local({
[10:29:49.524]                         has_future <- base::requireNamespace("future", 
[10:29:49.524]                           quietly = TRUE)
[10:29:49.524]                         if (has_future) {
[10:29:49.524]                           ns <- base::getNamespace("future")
[10:29:49.524]                           version <- ns[[".package"]][["version"]]
[10:29:49.524]                           if (is.null(version)) 
[10:29:49.524]                             version <- utils::packageVersion("future")
[10:29:49.524]                         }
[10:29:49.524]                         else {
[10:29:49.524]                           version <- NULL
[10:29:49.524]                         }
[10:29:49.524]                         if (!has_future || version < "1.8.0") {
[10:29:49.524]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.524]                             "", base::R.version$version.string), 
[10:29:49.524]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.524]                               "release", "version")], collapse = " "), 
[10:29:49.524]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.524]                             info)
[10:29:49.524]                           info <- base::paste(info, collapse = "; ")
[10:29:49.524]                           if (!has_future) {
[10:29:49.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.524]                               info)
[10:29:49.524]                           }
[10:29:49.524]                           else {
[10:29:49.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.524]                               info, version)
[10:29:49.524]                           }
[10:29:49.524]                           base::stop(msg)
[10:29:49.524]                         }
[10:29:49.524]                       })
[10:29:49.524]                     }
[10:29:49.524]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.524]                     base::options(mc.cores = 1L)
[10:29:49.524]                   }
[10:29:49.524]                   ...future.strategy.old <- future::plan("list")
[10:29:49.524]                   options(future.plan = NULL)
[10:29:49.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.524]                 }
[10:29:49.524]                 ...future.workdir <- getwd()
[10:29:49.524]             }
[10:29:49.524]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.524]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.524]         }
[10:29:49.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.524]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.524]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.524]             base::names(...future.oldOptions))
[10:29:49.524]     }
[10:29:49.524]     if (FALSE) {
[10:29:49.524]     }
[10:29:49.524]     else {
[10:29:49.524]         if (TRUE) {
[10:29:49.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.524]                 open = "w")
[10:29:49.524]         }
[10:29:49.524]         else {
[10:29:49.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.524]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.524]         }
[10:29:49.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.524]             base::sink(type = "output", split = FALSE)
[10:29:49.524]             base::close(...future.stdout)
[10:29:49.524]         }, add = TRUE)
[10:29:49.524]     }
[10:29:49.524]     ...future.frame <- base::sys.nframe()
[10:29:49.524]     ...future.conditions <- base::list()
[10:29:49.524]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.524]     if (FALSE) {
[10:29:49.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.524]     }
[10:29:49.524]     ...future.result <- base::tryCatch({
[10:29:49.524]         base::withCallingHandlers({
[10:29:49.524]             ...future.value <- base::withVisible(base::local({
[10:29:49.524]                 withCallingHandlers({
[10:29:49.524]                   {
[10:29:49.524]                     do.call(function(...) {
[10:29:49.524]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.524]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.524]                         ...future.globals.maxSize)) {
[10:29:49.524]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.524]                         on.exit(options(oopts), add = TRUE)
[10:29:49.524]                       }
[10:29:49.524]                       {
[10:29:49.524]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.524]                           FUN = function(jj) {
[10:29:49.524]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.524]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.524]                           })
[10:29:49.524]                       }
[10:29:49.524]                     }, args = future.call.arguments)
[10:29:49.524]                   }
[10:29:49.524]                 }, immediateCondition = function(cond) {
[10:29:49.524]                   save_rds <- function (object, pathname, ...) 
[10:29:49.524]                   {
[10:29:49.524]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.524]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.524]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.524]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.524]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.524]                         fi_tmp[["mtime"]])
[10:29:49.524]                     }
[10:29:49.524]                     tryCatch({
[10:29:49.524]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.524]                     }, error = function(ex) {
[10:29:49.524]                       msg <- conditionMessage(ex)
[10:29:49.524]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.524]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.524]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.524]                         fi_tmp[["mtime"]], msg)
[10:29:49.524]                       ex$message <- msg
[10:29:49.524]                       stop(ex)
[10:29:49.524]                     })
[10:29:49.524]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.524]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.524]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.524]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.524]                       fi <- file.info(pathname)
[10:29:49.524]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.524]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.524]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.524]                         fi[["size"]], fi[["mtime"]])
[10:29:49.524]                       stop(msg)
[10:29:49.524]                     }
[10:29:49.524]                     invisible(pathname)
[10:29:49.524]                   }
[10:29:49.524]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.524]                     rootPath = tempdir()) 
[10:29:49.524]                   {
[10:29:49.524]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.524]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.524]                       tmpdir = path, fileext = ".rds")
[10:29:49.524]                     save_rds(obj, file)
[10:29:49.524]                   }
[10:29:49.524]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.524]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.524]                   {
[10:29:49.524]                     inherits <- base::inherits
[10:29:49.524]                     invokeRestart <- base::invokeRestart
[10:29:49.524]                     is.null <- base::is.null
[10:29:49.524]                     muffled <- FALSE
[10:29:49.524]                     if (inherits(cond, "message")) {
[10:29:49.524]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.524]                       if (muffled) 
[10:29:49.524]                         invokeRestart("muffleMessage")
[10:29:49.524]                     }
[10:29:49.524]                     else if (inherits(cond, "warning")) {
[10:29:49.524]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.524]                       if (muffled) 
[10:29:49.524]                         invokeRestart("muffleWarning")
[10:29:49.524]                     }
[10:29:49.524]                     else if (inherits(cond, "condition")) {
[10:29:49.524]                       if (!is.null(pattern)) {
[10:29:49.524]                         computeRestarts <- base::computeRestarts
[10:29:49.524]                         grepl <- base::grepl
[10:29:49.524]                         restarts <- computeRestarts(cond)
[10:29:49.524]                         for (restart in restarts) {
[10:29:49.524]                           name <- restart$name
[10:29:49.524]                           if (is.null(name)) 
[10:29:49.524]                             next
[10:29:49.524]                           if (!grepl(pattern, name)) 
[10:29:49.524]                             next
[10:29:49.524]                           invokeRestart(restart)
[10:29:49.524]                           muffled <- TRUE
[10:29:49.524]                           break
[10:29:49.524]                         }
[10:29:49.524]                       }
[10:29:49.524]                     }
[10:29:49.524]                     invisible(muffled)
[10:29:49.524]                   }
[10:29:49.524]                   muffleCondition(cond)
[10:29:49.524]                 })
[10:29:49.524]             }))
[10:29:49.524]             future::FutureResult(value = ...future.value$value, 
[10:29:49.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.524]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.524]                     ...future.globalenv.names))
[10:29:49.524]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.524]         }, condition = base::local({
[10:29:49.524]             c <- base::c
[10:29:49.524]             inherits <- base::inherits
[10:29:49.524]             invokeRestart <- base::invokeRestart
[10:29:49.524]             length <- base::length
[10:29:49.524]             list <- base::list
[10:29:49.524]             seq.int <- base::seq.int
[10:29:49.524]             signalCondition <- base::signalCondition
[10:29:49.524]             sys.calls <- base::sys.calls
[10:29:49.524]             `[[` <- base::`[[`
[10:29:49.524]             `+` <- base::`+`
[10:29:49.524]             `<<-` <- base::`<<-`
[10:29:49.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.524]                   3L)]
[10:29:49.524]             }
[10:29:49.524]             function(cond) {
[10:29:49.524]                 is_error <- inherits(cond, "error")
[10:29:49.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.524]                   NULL)
[10:29:49.524]                 if (is_error) {
[10:29:49.524]                   sessionInformation <- function() {
[10:29:49.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.524]                       search = base::search(), system = base::Sys.info())
[10:29:49.524]                   }
[10:29:49.524]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.524]                     cond$call), session = sessionInformation(), 
[10:29:49.524]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.524]                   signalCondition(cond)
[10:29:49.524]                 }
[10:29:49.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.524]                 "immediateCondition"))) {
[10:29:49.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.524]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.524]                   if (TRUE && !signal) {
[10:29:49.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.524]                     {
[10:29:49.524]                       inherits <- base::inherits
[10:29:49.524]                       invokeRestart <- base::invokeRestart
[10:29:49.524]                       is.null <- base::is.null
[10:29:49.524]                       muffled <- FALSE
[10:29:49.524]                       if (inherits(cond, "message")) {
[10:29:49.524]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.524]                         if (muffled) 
[10:29:49.524]                           invokeRestart("muffleMessage")
[10:29:49.524]                       }
[10:29:49.524]                       else if (inherits(cond, "warning")) {
[10:29:49.524]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.524]                         if (muffled) 
[10:29:49.524]                           invokeRestart("muffleWarning")
[10:29:49.524]                       }
[10:29:49.524]                       else if (inherits(cond, "condition")) {
[10:29:49.524]                         if (!is.null(pattern)) {
[10:29:49.524]                           computeRestarts <- base::computeRestarts
[10:29:49.524]                           grepl <- base::grepl
[10:29:49.524]                           restarts <- computeRestarts(cond)
[10:29:49.524]                           for (restart in restarts) {
[10:29:49.524]                             name <- restart$name
[10:29:49.524]                             if (is.null(name)) 
[10:29:49.524]                               next
[10:29:49.524]                             if (!grepl(pattern, name)) 
[10:29:49.524]                               next
[10:29:49.524]                             invokeRestart(restart)
[10:29:49.524]                             muffled <- TRUE
[10:29:49.524]                             break
[10:29:49.524]                           }
[10:29:49.524]                         }
[10:29:49.524]                       }
[10:29:49.524]                       invisible(muffled)
[10:29:49.524]                     }
[10:29:49.524]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.524]                   }
[10:29:49.524]                 }
[10:29:49.524]                 else {
[10:29:49.524]                   if (TRUE) {
[10:29:49.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.524]                     {
[10:29:49.524]                       inherits <- base::inherits
[10:29:49.524]                       invokeRestart <- base::invokeRestart
[10:29:49.524]                       is.null <- base::is.null
[10:29:49.524]                       muffled <- FALSE
[10:29:49.524]                       if (inherits(cond, "message")) {
[10:29:49.524]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.524]                         if (muffled) 
[10:29:49.524]                           invokeRestart("muffleMessage")
[10:29:49.524]                       }
[10:29:49.524]                       else if (inherits(cond, "warning")) {
[10:29:49.524]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.524]                         if (muffled) 
[10:29:49.524]                           invokeRestart("muffleWarning")
[10:29:49.524]                       }
[10:29:49.524]                       else if (inherits(cond, "condition")) {
[10:29:49.524]                         if (!is.null(pattern)) {
[10:29:49.524]                           computeRestarts <- base::computeRestarts
[10:29:49.524]                           grepl <- base::grepl
[10:29:49.524]                           restarts <- computeRestarts(cond)
[10:29:49.524]                           for (restart in restarts) {
[10:29:49.524]                             name <- restart$name
[10:29:49.524]                             if (is.null(name)) 
[10:29:49.524]                               next
[10:29:49.524]                             if (!grepl(pattern, name)) 
[10:29:49.524]                               next
[10:29:49.524]                             invokeRestart(restart)
[10:29:49.524]                             muffled <- TRUE
[10:29:49.524]                             break
[10:29:49.524]                           }
[10:29:49.524]                         }
[10:29:49.524]                       }
[10:29:49.524]                       invisible(muffled)
[10:29:49.524]                     }
[10:29:49.524]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.524]                   }
[10:29:49.524]                 }
[10:29:49.524]             }
[10:29:49.524]         }))
[10:29:49.524]     }, error = function(ex) {
[10:29:49.524]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.524]                 ...future.rng), started = ...future.startTime, 
[10:29:49.524]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.524]             version = "1.8"), class = "FutureResult")
[10:29:49.524]     }, finally = {
[10:29:49.524]         if (!identical(...future.workdir, getwd())) 
[10:29:49.524]             setwd(...future.workdir)
[10:29:49.524]         {
[10:29:49.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.524]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.524]             }
[10:29:49.524]             base::options(...future.oldOptions)
[10:29:49.524]             if (.Platform$OS.type == "windows") {
[10:29:49.524]                 old_names <- names(...future.oldEnvVars)
[10:29:49.524]                 envs <- base::Sys.getenv()
[10:29:49.524]                 names <- names(envs)
[10:29:49.524]                 common <- intersect(names, old_names)
[10:29:49.524]                 added <- setdiff(names, old_names)
[10:29:49.524]                 removed <- setdiff(old_names, names)
[10:29:49.524]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.524]                   envs[common]]
[10:29:49.524]                 NAMES <- toupper(changed)
[10:29:49.524]                 args <- list()
[10:29:49.524]                 for (kk in seq_along(NAMES)) {
[10:29:49.524]                   name <- changed[[kk]]
[10:29:49.524]                   NAME <- NAMES[[kk]]
[10:29:49.524]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.524]                     next
[10:29:49.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.524]                 }
[10:29:49.524]                 NAMES <- toupper(added)
[10:29:49.524]                 for (kk in seq_along(NAMES)) {
[10:29:49.524]                   name <- added[[kk]]
[10:29:49.524]                   NAME <- NAMES[[kk]]
[10:29:49.524]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.524]                     next
[10:29:49.524]                   args[[name]] <- ""
[10:29:49.524]                 }
[10:29:49.524]                 NAMES <- toupper(removed)
[10:29:49.524]                 for (kk in seq_along(NAMES)) {
[10:29:49.524]                   name <- removed[[kk]]
[10:29:49.524]                   NAME <- NAMES[[kk]]
[10:29:49.524]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.524]                     next
[10:29:49.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.524]                 }
[10:29:49.524]                 if (length(args) > 0) 
[10:29:49.524]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.524]             }
[10:29:49.524]             else {
[10:29:49.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.524]             }
[10:29:49.524]             {
[10:29:49.524]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.524]                   0L) {
[10:29:49.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.524]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.524]                   base::options(opts)
[10:29:49.524]                 }
[10:29:49.524]                 {
[10:29:49.524]                   {
[10:29:49.524]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.524]                     NULL
[10:29:49.524]                   }
[10:29:49.524]                   options(future.plan = NULL)
[10:29:49.524]                   if (is.na(NA_character_)) 
[10:29:49.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.524]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.524]                     .init = FALSE)
[10:29:49.524]                 }
[10:29:49.524]             }
[10:29:49.524]         }
[10:29:49.524]     })
[10:29:49.524]     if (TRUE) {
[10:29:49.524]         base::sink(type = "output", split = FALSE)
[10:29:49.524]         if (TRUE) {
[10:29:49.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.524]         }
[10:29:49.524]         else {
[10:29:49.524]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.524]         }
[10:29:49.524]         base::close(...future.stdout)
[10:29:49.524]         ...future.stdout <- NULL
[10:29:49.524]     }
[10:29:49.524]     ...future.result$conditions <- ...future.conditions
[10:29:49.524]     ...future.result$finished <- base::Sys.time()
[10:29:49.524]     ...future.result
[10:29:49.524] }
[10:29:49.527] assign_globals() ...
[10:29:49.527] List of 5
[10:29:49.527]  $ future.call.arguments    : list()
[10:29:49.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.527]  $ ...future.FUN            :function (x)  
[10:29:49.527]  $ ...future.elements_ii    :List of 3
[10:29:49.527]   ..$ : int [1:4] 4 10 16 22
[10:29:49.527]   ..$ : int [1:4] 5 11 17 23
[10:29:49.527]   ..$ : int [1:4] 6 12 18 24
[10:29:49.527]  $ ...future.seeds_ii       : NULL
[10:29:49.527]  $ ...future.globals.maxSize: num Inf
[10:29:49.527]  - attr(*, "resolved")= logi FALSE
[10:29:49.527]  - attr(*, "total_size")= num NA
[10:29:49.527]  - attr(*, "where")=List of 5
[10:29:49.527]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.527]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.527]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.527]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.527]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.527]  - attr(*, "already-done")= logi TRUE
[10:29:49.536] - copied ‘future.call.arguments’ to environment
[10:29:49.536] - reassign environment for ‘...future.FUN’
[10:29:49.536] - copied ‘...future.FUN’ to environment
[10:29:49.536] - copied ‘...future.elements_ii’ to environment
[10:29:49.536] - copied ‘...future.seeds_ii’ to environment
[10:29:49.536] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.537] assign_globals() ... done
[10:29:49.537] requestCore(): workers = 2
[10:29:49.539] MulticoreFuture started
[10:29:49.539] - Launch lazy future ... done
[10:29:49.540] run() for ‘MulticoreFuture’ ... done
[10:29:49.540] Created future:
[10:29:49.540] plan(): Setting new future strategy stack:
[10:29:49.541] List of future strategies:
[10:29:49.541] 1. sequential:
[10:29:49.541]    - args: function (..., envir = parent.frame())
[10:29:49.541]    - tweaked: FALSE
[10:29:49.541]    - call: NULL
[10:29:49.541] plan(): nbrOfWorkers() = 1
[10:29:49.544] plan(): Setting new future strategy stack:
[10:29:49.544] List of future strategies:
[10:29:49.544] 1. multicore:
[10:29:49.544]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.544]    - tweaked: FALSE
[10:29:49.544]    - call: plan(strategy)
[10:29:49.549] plan(): nbrOfWorkers() = 2
[10:29:49.540] MulticoreFuture:
[10:29:49.540] Label: ‘future_apply-2’
[10:29:49.540] Expression:
[10:29:49.540] {
[10:29:49.540]     do.call(function(...) {
[10:29:49.540]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.540]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.540]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.540]             on.exit(options(oopts), add = TRUE)
[10:29:49.540]         }
[10:29:49.540]         {
[10:29:49.540]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.540]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.540]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.540]             })
[10:29:49.540]         }
[10:29:49.540]     }, args = future.call.arguments)
[10:29:49.540] }
[10:29:49.540] Lazy evaluation: FALSE
[10:29:49.540] Asynchronous evaluation: TRUE
[10:29:49.540] Local evaluation: TRUE
[10:29:49.540] Environment: R_GlobalEnv
[10:29:49.540] Capture standard output: TRUE
[10:29:49.540] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.540] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.540] Packages: <none>
[10:29:49.540] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.540] Resolved: TRUE
[10:29:49.540] Value: <not collected>
[10:29:49.540] Conditions captured: <none>
[10:29:49.540] Early signaling: FALSE
[10:29:49.540] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.540] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.550] Chunk #2 of 2 ... DONE
[10:29:49.551] Launching 2 futures (chunks) ... DONE
[10:29:49.551] Resolving 2 futures (chunks) ...
[10:29:49.551] resolve() on list ...
[10:29:49.551]  recursive: 0
[10:29:49.551]  length: 2
[10:29:49.551] 
[10:29:49.552] Future #1
[10:29:49.552] result() for MulticoreFuture ...
[10:29:49.553] result() for MulticoreFuture ...
[10:29:49.553] result() for MulticoreFuture ... done
[10:29:49.553] result() for MulticoreFuture ... done
[10:29:49.553] result() for MulticoreFuture ...
[10:29:49.554] result() for MulticoreFuture ... done
[10:29:49.554] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:49.554] - nx: 2
[10:29:49.554] - relay: TRUE
[10:29:49.554] - stdout: TRUE
[10:29:49.554] - signal: TRUE
[10:29:49.554] - resignal: FALSE
[10:29:49.555] - force: TRUE
[10:29:49.555] - relayed: [n=2] FALSE, FALSE
[10:29:49.555] - queued futures: [n=2] FALSE, FALSE
[10:29:49.555]  - until=1
[10:29:49.555]  - relaying element #1
[10:29:49.555] result() for MulticoreFuture ...
[10:29:49.555] result() for MulticoreFuture ... done
[10:29:49.556] result() for MulticoreFuture ...
[10:29:49.556] result() for MulticoreFuture ... done
[10:29:49.556] result() for MulticoreFuture ...
[10:29:49.556] result() for MulticoreFuture ... done
[10:29:49.556] result() for MulticoreFuture ...
[10:29:49.556] result() for MulticoreFuture ... done
[10:29:49.556] - relayed: [n=2] TRUE, FALSE
[10:29:49.557] - queued futures: [n=2] TRUE, FALSE
[10:29:49.557] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:49.557]  length: 1 (resolved future 1)
[10:29:49.557] Future #2
[10:29:49.557] result() for MulticoreFuture ...
[10:29:49.558] result() for MulticoreFuture ...
[10:29:49.558] result() for MulticoreFuture ... done
[10:29:49.559] result() for MulticoreFuture ... done
[10:29:49.559] result() for MulticoreFuture ...
[10:29:49.559] result() for MulticoreFuture ... done
[10:29:49.559] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:49.559] - nx: 2
[10:29:49.559] - relay: TRUE
[10:29:49.559] - stdout: TRUE
[10:29:49.560] - signal: TRUE
[10:29:49.560] - resignal: FALSE
[10:29:49.560] - force: TRUE
[10:29:49.560] - relayed: [n=2] TRUE, FALSE
[10:29:49.560] - queued futures: [n=2] TRUE, FALSE
[10:29:49.560]  - until=2
[10:29:49.560]  - relaying element #2
[10:29:49.560] result() for MulticoreFuture ...
[10:29:49.560] result() for MulticoreFuture ... done
[10:29:49.561] result() for MulticoreFuture ...
[10:29:49.561] result() for MulticoreFuture ... done
[10:29:49.561] result() for MulticoreFuture ...
[10:29:49.561] result() for MulticoreFuture ... done
[10:29:49.561] result() for MulticoreFuture ...
[10:29:49.561] result() for MulticoreFuture ... done
[10:29:49.561] - relayed: [n=2] TRUE, TRUE
[10:29:49.564] - queued futures: [n=2] TRUE, TRUE
[10:29:49.564] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:49.564]  length: 0 (resolved future 2)
[10:29:49.564] Relaying remaining futures
[10:29:49.565] signalConditionsASAP(NULL, pos=0) ...
[10:29:49.565] - nx: 2
[10:29:49.565] - relay: TRUE
[10:29:49.565] - stdout: TRUE
[10:29:49.565] - signal: TRUE
[10:29:49.566] - resignal: FALSE
[10:29:49.566] - force: TRUE
[10:29:49.566] - relayed: [n=2] TRUE, TRUE
[10:29:49.566] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:49.566] - relayed: [n=2] TRUE, TRUE
[10:29:49.566] - queued futures: [n=2] TRUE, TRUE
[10:29:49.567] signalConditionsASAP(NULL, pos=0) ... done
[10:29:49.567] resolve() on list ... DONE
[10:29:49.567] result() for MulticoreFuture ...
[10:29:49.567] result() for MulticoreFuture ... done
[10:29:49.567] result() for MulticoreFuture ...
[10:29:49.567] result() for MulticoreFuture ... done
[10:29:49.568] result() for MulticoreFuture ...
[10:29:49.568] result() for MulticoreFuture ... done
[10:29:49.568] result() for MulticoreFuture ...
[10:29:49.568] result() for MulticoreFuture ... done
[10:29:49.568]  - Number of value chunks collected: 2
[10:29:49.568] Resolving 2 futures (chunks) ... DONE
[10:29:49.568] Reducing values from 2 chunks ...
[10:29:49.569]  - Number of values collected after concatenation: 6
[10:29:49.569]  - Number of values expected: 6
[10:29:49.569] Reducing values from 2 chunks ... DONE
[10:29:49.569] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:29:49.569] getGlobalsAndPackagesXApply() ...
[10:29:49.570]  - future.globals: TRUE
[10:29:49.570] getGlobalsAndPackages() ...
[10:29:49.570] Searching for globals...
[10:29:49.571] - globals found: [1] ‘FUN’
[10:29:49.571] Searching for globals ... DONE
[10:29:49.572] Resolving globals: FALSE
[10:29:49.572] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:49.572] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:49.573] - globals: [1] ‘FUN’
[10:29:49.573] 
[10:29:49.573] getGlobalsAndPackages() ... DONE
[10:29:49.573]  - globals found/used: [n=1] ‘FUN’
[10:29:49.573]  - needed namespaces: [n=0] 
[10:29:49.573] Finding globals ... DONE
[10:29:49.573]  - use_args: TRUE
[10:29:49.573]  - Getting '...' globals ...
[10:29:49.574] resolve() on list ...
[10:29:49.574]  recursive: 0
[10:29:49.574]  length: 1
[10:29:49.574]  elements: ‘...’
[10:29:49.574]  length: 0 (resolved future 1)
[10:29:49.574] resolve() on list ... DONE
[10:29:49.574]    - '...' content: [n=0] 
[10:29:49.575] List of 1
[10:29:49.575]  $ ...: list()
[10:29:49.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.575]  - attr(*, "where")=List of 1
[10:29:49.575]   ..$ ...:<environment: 0x5618a13532b8> 
[10:29:49.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.575]  - attr(*, "resolved")= logi TRUE
[10:29:49.575]  - attr(*, "total_size")= num NA
[10:29:49.578]  - Getting '...' globals ... DONE
[10:29:49.578] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:49.578] List of 2
[10:29:49.578]  $ ...future.FUN:function (x)  
[10:29:49.578]  $ ...          : list()
[10:29:49.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.578]  - attr(*, "where")=List of 2
[10:29:49.578]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:49.578]   ..$ ...          :<environment: 0x5618a13532b8> 
[10:29:49.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.578]  - attr(*, "resolved")= logi FALSE
[10:29:49.578]  - attr(*, "total_size")= num 848
[10:29:49.581] Packages to be attached in all futures: [n=0] 
[10:29:49.581] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.585] future_lapply() ...
[10:29:49.588] Number of chunks: 2
[10:29:49.588] getGlobalsAndPackagesXApply() ...
[10:29:49.589]  - future.globals: <name-value list> with names ‘list()’
[10:29:49.589]  - use_args: TRUE
[10:29:49.589] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:49.589] List of 2
[10:29:49.589]  $ ...          : list()
[10:29:49.589]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.589]  $ ...future.FUN:function (x)  
[10:29:49.589]  - attr(*, "where")=List of 2
[10:29:49.589]   ..$ ...          :<environment: 0x5618a13532b8> 
[10:29:49.589]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:49.589]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.589]  - attr(*, "resolved")= logi FALSE
[10:29:49.589]  - attr(*, "total_size")= num NA
[10:29:49.594] Packages to be attached in all futures: [n=0] 
[10:29:49.594] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.594] Number of futures (= number of chunks): 2
[10:29:49.594] Launching 2 futures (chunks) ...
[10:29:49.595] Chunk #1 of 2 ...
[10:29:49.595]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.595]  - seeds: <none>
[10:29:49.595]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.595] getGlobalsAndPackages() ...
[10:29:49.595] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.595] Resolving globals: FALSE
[10:29:49.595] Tweak future expression to call with '...' arguments ...
[10:29:49.596] {
[10:29:49.596]     do.call(function(...) {
[10:29:49.596]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.596]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.596]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.596]             on.exit(options(oopts), add = TRUE)
[10:29:49.596]         }
[10:29:49.596]         {
[10:29:49.596]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.596]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.596]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.596]             })
[10:29:49.596]         }
[10:29:49.596]     }, args = future.call.arguments)
[10:29:49.596] }
[10:29:49.596] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.596] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.596] 
[10:29:49.597] getGlobalsAndPackages() ... DONE
[10:29:49.597] run() for ‘Future’ ...
[10:29:49.597] - state: ‘created’
[10:29:49.597] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.601] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.601] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.601]   - Field: ‘label’
[10:29:49.601]   - Field: ‘local’
[10:29:49.601]   - Field: ‘owner’
[10:29:49.601]   - Field: ‘envir’
[10:29:49.602]   - Field: ‘workers’
[10:29:49.602]   - Field: ‘packages’
[10:29:49.602]   - Field: ‘gc’
[10:29:49.602]   - Field: ‘job’
[10:29:49.602]   - Field: ‘conditions’
[10:29:49.602]   - Field: ‘expr’
[10:29:49.602]   - Field: ‘uuid’
[10:29:49.602]   - Field: ‘seed’
[10:29:49.602]   - Field: ‘version’
[10:29:49.602]   - Field: ‘result’
[10:29:49.602]   - Field: ‘asynchronous’
[10:29:49.603]   - Field: ‘calls’
[10:29:49.603]   - Field: ‘globals’
[10:29:49.603]   - Field: ‘stdout’
[10:29:49.603]   - Field: ‘earlySignal’
[10:29:49.603]   - Field: ‘lazy’
[10:29:49.603]   - Field: ‘state’
[10:29:49.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.603] - Launch lazy future ...
[10:29:49.603] Packages needed by the future expression (n = 0): <none>
[10:29:49.604] Packages needed by future strategies (n = 0): <none>
[10:29:49.604] {
[10:29:49.604]     {
[10:29:49.604]         {
[10:29:49.604]             ...future.startTime <- base::Sys.time()
[10:29:49.604]             {
[10:29:49.604]                 {
[10:29:49.604]                   {
[10:29:49.604]                     {
[10:29:49.604]                       base::local({
[10:29:49.604]                         has_future <- base::requireNamespace("future", 
[10:29:49.604]                           quietly = TRUE)
[10:29:49.604]                         if (has_future) {
[10:29:49.604]                           ns <- base::getNamespace("future")
[10:29:49.604]                           version <- ns[[".package"]][["version"]]
[10:29:49.604]                           if (is.null(version)) 
[10:29:49.604]                             version <- utils::packageVersion("future")
[10:29:49.604]                         }
[10:29:49.604]                         else {
[10:29:49.604]                           version <- NULL
[10:29:49.604]                         }
[10:29:49.604]                         if (!has_future || version < "1.8.0") {
[10:29:49.604]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.604]                             "", base::R.version$version.string), 
[10:29:49.604]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.604]                               "release", "version")], collapse = " "), 
[10:29:49.604]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.604]                             info)
[10:29:49.604]                           info <- base::paste(info, collapse = "; ")
[10:29:49.604]                           if (!has_future) {
[10:29:49.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.604]                               info)
[10:29:49.604]                           }
[10:29:49.604]                           else {
[10:29:49.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.604]                               info, version)
[10:29:49.604]                           }
[10:29:49.604]                           base::stop(msg)
[10:29:49.604]                         }
[10:29:49.604]                       })
[10:29:49.604]                     }
[10:29:49.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.604]                     base::options(mc.cores = 1L)
[10:29:49.604]                   }
[10:29:49.604]                   ...future.strategy.old <- future::plan("list")
[10:29:49.604]                   options(future.plan = NULL)
[10:29:49.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.604]                 }
[10:29:49.604]                 ...future.workdir <- getwd()
[10:29:49.604]             }
[10:29:49.604]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.604]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.604]         }
[10:29:49.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.604]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.604]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.604]             base::names(...future.oldOptions))
[10:29:49.604]     }
[10:29:49.604]     if (FALSE) {
[10:29:49.604]     }
[10:29:49.604]     else {
[10:29:49.604]         if (TRUE) {
[10:29:49.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.604]                 open = "w")
[10:29:49.604]         }
[10:29:49.604]         else {
[10:29:49.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.604]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.604]         }
[10:29:49.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.604]             base::sink(type = "output", split = FALSE)
[10:29:49.604]             base::close(...future.stdout)
[10:29:49.604]         }, add = TRUE)
[10:29:49.604]     }
[10:29:49.604]     ...future.frame <- base::sys.nframe()
[10:29:49.604]     ...future.conditions <- base::list()
[10:29:49.604]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.604]     if (FALSE) {
[10:29:49.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.604]     }
[10:29:49.604]     ...future.result <- base::tryCatch({
[10:29:49.604]         base::withCallingHandlers({
[10:29:49.604]             ...future.value <- base::withVisible(base::local({
[10:29:49.604]                 withCallingHandlers({
[10:29:49.604]                   {
[10:29:49.604]                     do.call(function(...) {
[10:29:49.604]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.604]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.604]                         ...future.globals.maxSize)) {
[10:29:49.604]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.604]                         on.exit(options(oopts), add = TRUE)
[10:29:49.604]                       }
[10:29:49.604]                       {
[10:29:49.604]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.604]                           FUN = function(jj) {
[10:29:49.604]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.604]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.604]                           })
[10:29:49.604]                       }
[10:29:49.604]                     }, args = future.call.arguments)
[10:29:49.604]                   }
[10:29:49.604]                 }, immediateCondition = function(cond) {
[10:29:49.604]                   save_rds <- function (object, pathname, ...) 
[10:29:49.604]                   {
[10:29:49.604]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.604]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.604]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.604]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.604]                         fi_tmp[["mtime"]])
[10:29:49.604]                     }
[10:29:49.604]                     tryCatch({
[10:29:49.604]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.604]                     }, error = function(ex) {
[10:29:49.604]                       msg <- conditionMessage(ex)
[10:29:49.604]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.604]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.604]                         fi_tmp[["mtime"]], msg)
[10:29:49.604]                       ex$message <- msg
[10:29:49.604]                       stop(ex)
[10:29:49.604]                     })
[10:29:49.604]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.604]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.604]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.604]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.604]                       fi <- file.info(pathname)
[10:29:49.604]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.604]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.604]                         fi[["size"]], fi[["mtime"]])
[10:29:49.604]                       stop(msg)
[10:29:49.604]                     }
[10:29:49.604]                     invisible(pathname)
[10:29:49.604]                   }
[10:29:49.604]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.604]                     rootPath = tempdir()) 
[10:29:49.604]                   {
[10:29:49.604]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.604]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.604]                       tmpdir = path, fileext = ".rds")
[10:29:49.604]                     save_rds(obj, file)
[10:29:49.604]                   }
[10:29:49.604]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.604]                   {
[10:29:49.604]                     inherits <- base::inherits
[10:29:49.604]                     invokeRestart <- base::invokeRestart
[10:29:49.604]                     is.null <- base::is.null
[10:29:49.604]                     muffled <- FALSE
[10:29:49.604]                     if (inherits(cond, "message")) {
[10:29:49.604]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.604]                       if (muffled) 
[10:29:49.604]                         invokeRestart("muffleMessage")
[10:29:49.604]                     }
[10:29:49.604]                     else if (inherits(cond, "warning")) {
[10:29:49.604]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.604]                       if (muffled) 
[10:29:49.604]                         invokeRestart("muffleWarning")
[10:29:49.604]                     }
[10:29:49.604]                     else if (inherits(cond, "condition")) {
[10:29:49.604]                       if (!is.null(pattern)) {
[10:29:49.604]                         computeRestarts <- base::computeRestarts
[10:29:49.604]                         grepl <- base::grepl
[10:29:49.604]                         restarts <- computeRestarts(cond)
[10:29:49.604]                         for (restart in restarts) {
[10:29:49.604]                           name <- restart$name
[10:29:49.604]                           if (is.null(name)) 
[10:29:49.604]                             next
[10:29:49.604]                           if (!grepl(pattern, name)) 
[10:29:49.604]                             next
[10:29:49.604]                           invokeRestart(restart)
[10:29:49.604]                           muffled <- TRUE
[10:29:49.604]                           break
[10:29:49.604]                         }
[10:29:49.604]                       }
[10:29:49.604]                     }
[10:29:49.604]                     invisible(muffled)
[10:29:49.604]                   }
[10:29:49.604]                   muffleCondition(cond)
[10:29:49.604]                 })
[10:29:49.604]             }))
[10:29:49.604]             future::FutureResult(value = ...future.value$value, 
[10:29:49.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.604]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.604]                     ...future.globalenv.names))
[10:29:49.604]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.604]         }, condition = base::local({
[10:29:49.604]             c <- base::c
[10:29:49.604]             inherits <- base::inherits
[10:29:49.604]             invokeRestart <- base::invokeRestart
[10:29:49.604]             length <- base::length
[10:29:49.604]             list <- base::list
[10:29:49.604]             seq.int <- base::seq.int
[10:29:49.604]             signalCondition <- base::signalCondition
[10:29:49.604]             sys.calls <- base::sys.calls
[10:29:49.604]             `[[` <- base::`[[`
[10:29:49.604]             `+` <- base::`+`
[10:29:49.604]             `<<-` <- base::`<<-`
[10:29:49.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.604]                   3L)]
[10:29:49.604]             }
[10:29:49.604]             function(cond) {
[10:29:49.604]                 is_error <- inherits(cond, "error")
[10:29:49.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.604]                   NULL)
[10:29:49.604]                 if (is_error) {
[10:29:49.604]                   sessionInformation <- function() {
[10:29:49.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.604]                       search = base::search(), system = base::Sys.info())
[10:29:49.604]                   }
[10:29:49.604]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.604]                     cond$call), session = sessionInformation(), 
[10:29:49.604]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.604]                   signalCondition(cond)
[10:29:49.604]                 }
[10:29:49.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.604]                 "immediateCondition"))) {
[10:29:49.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.604]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.604]                   if (TRUE && !signal) {
[10:29:49.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.604]                     {
[10:29:49.604]                       inherits <- base::inherits
[10:29:49.604]                       invokeRestart <- base::invokeRestart
[10:29:49.604]                       is.null <- base::is.null
[10:29:49.604]                       muffled <- FALSE
[10:29:49.604]                       if (inherits(cond, "message")) {
[10:29:49.604]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.604]                         if (muffled) 
[10:29:49.604]                           invokeRestart("muffleMessage")
[10:29:49.604]                       }
[10:29:49.604]                       else if (inherits(cond, "warning")) {
[10:29:49.604]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.604]                         if (muffled) 
[10:29:49.604]                           invokeRestart("muffleWarning")
[10:29:49.604]                       }
[10:29:49.604]                       else if (inherits(cond, "condition")) {
[10:29:49.604]                         if (!is.null(pattern)) {
[10:29:49.604]                           computeRestarts <- base::computeRestarts
[10:29:49.604]                           grepl <- base::grepl
[10:29:49.604]                           restarts <- computeRestarts(cond)
[10:29:49.604]                           for (restart in restarts) {
[10:29:49.604]                             name <- restart$name
[10:29:49.604]                             if (is.null(name)) 
[10:29:49.604]                               next
[10:29:49.604]                             if (!grepl(pattern, name)) 
[10:29:49.604]                               next
[10:29:49.604]                             invokeRestart(restart)
[10:29:49.604]                             muffled <- TRUE
[10:29:49.604]                             break
[10:29:49.604]                           }
[10:29:49.604]                         }
[10:29:49.604]                       }
[10:29:49.604]                       invisible(muffled)
[10:29:49.604]                     }
[10:29:49.604]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.604]                   }
[10:29:49.604]                 }
[10:29:49.604]                 else {
[10:29:49.604]                   if (TRUE) {
[10:29:49.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.604]                     {
[10:29:49.604]                       inherits <- base::inherits
[10:29:49.604]                       invokeRestart <- base::invokeRestart
[10:29:49.604]                       is.null <- base::is.null
[10:29:49.604]                       muffled <- FALSE
[10:29:49.604]                       if (inherits(cond, "message")) {
[10:29:49.604]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.604]                         if (muffled) 
[10:29:49.604]                           invokeRestart("muffleMessage")
[10:29:49.604]                       }
[10:29:49.604]                       else if (inherits(cond, "warning")) {
[10:29:49.604]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.604]                         if (muffled) 
[10:29:49.604]                           invokeRestart("muffleWarning")
[10:29:49.604]                       }
[10:29:49.604]                       else if (inherits(cond, "condition")) {
[10:29:49.604]                         if (!is.null(pattern)) {
[10:29:49.604]                           computeRestarts <- base::computeRestarts
[10:29:49.604]                           grepl <- base::grepl
[10:29:49.604]                           restarts <- computeRestarts(cond)
[10:29:49.604]                           for (restart in restarts) {
[10:29:49.604]                             name <- restart$name
[10:29:49.604]                             if (is.null(name)) 
[10:29:49.604]                               next
[10:29:49.604]                             if (!grepl(pattern, name)) 
[10:29:49.604]                               next
[10:29:49.604]                             invokeRestart(restart)
[10:29:49.604]                             muffled <- TRUE
[10:29:49.604]                             break
[10:29:49.604]                           }
[10:29:49.604]                         }
[10:29:49.604]                       }
[10:29:49.604]                       invisible(muffled)
[10:29:49.604]                     }
[10:29:49.604]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.604]                   }
[10:29:49.604]                 }
[10:29:49.604]             }
[10:29:49.604]         }))
[10:29:49.604]     }, error = function(ex) {
[10:29:49.604]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.604]                 ...future.rng), started = ...future.startTime, 
[10:29:49.604]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.604]             version = "1.8"), class = "FutureResult")
[10:29:49.604]     }, finally = {
[10:29:49.604]         if (!identical(...future.workdir, getwd())) 
[10:29:49.604]             setwd(...future.workdir)
[10:29:49.604]         {
[10:29:49.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.604]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.604]             }
[10:29:49.604]             base::options(...future.oldOptions)
[10:29:49.604]             if (.Platform$OS.type == "windows") {
[10:29:49.604]                 old_names <- names(...future.oldEnvVars)
[10:29:49.604]                 envs <- base::Sys.getenv()
[10:29:49.604]                 names <- names(envs)
[10:29:49.604]                 common <- intersect(names, old_names)
[10:29:49.604]                 added <- setdiff(names, old_names)
[10:29:49.604]                 removed <- setdiff(old_names, names)
[10:29:49.604]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.604]                   envs[common]]
[10:29:49.604]                 NAMES <- toupper(changed)
[10:29:49.604]                 args <- list()
[10:29:49.604]                 for (kk in seq_along(NAMES)) {
[10:29:49.604]                   name <- changed[[kk]]
[10:29:49.604]                   NAME <- NAMES[[kk]]
[10:29:49.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.604]                     next
[10:29:49.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.604]                 }
[10:29:49.604]                 NAMES <- toupper(added)
[10:29:49.604]                 for (kk in seq_along(NAMES)) {
[10:29:49.604]                   name <- added[[kk]]
[10:29:49.604]                   NAME <- NAMES[[kk]]
[10:29:49.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.604]                     next
[10:29:49.604]                   args[[name]] <- ""
[10:29:49.604]                 }
[10:29:49.604]                 NAMES <- toupper(removed)
[10:29:49.604]                 for (kk in seq_along(NAMES)) {
[10:29:49.604]                   name <- removed[[kk]]
[10:29:49.604]                   NAME <- NAMES[[kk]]
[10:29:49.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.604]                     next
[10:29:49.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.604]                 }
[10:29:49.604]                 if (length(args) > 0) 
[10:29:49.604]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.604]             }
[10:29:49.604]             else {
[10:29:49.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.604]             }
[10:29:49.604]             {
[10:29:49.604]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.604]                   0L) {
[10:29:49.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.604]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.604]                   base::options(opts)
[10:29:49.604]                 }
[10:29:49.604]                 {
[10:29:49.604]                   {
[10:29:49.604]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.604]                     NULL
[10:29:49.604]                   }
[10:29:49.604]                   options(future.plan = NULL)
[10:29:49.604]                   if (is.na(NA_character_)) 
[10:29:49.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.604]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.604]                     .init = FALSE)
[10:29:49.604]                 }
[10:29:49.604]             }
[10:29:49.604]         }
[10:29:49.604]     })
[10:29:49.604]     if (TRUE) {
[10:29:49.604]         base::sink(type = "output", split = FALSE)
[10:29:49.604]         if (TRUE) {
[10:29:49.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.604]         }
[10:29:49.604]         else {
[10:29:49.604]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.604]         }
[10:29:49.604]         base::close(...future.stdout)
[10:29:49.604]         ...future.stdout <- NULL
[10:29:49.604]     }
[10:29:49.604]     ...future.result$conditions <- ...future.conditions
[10:29:49.604]     ...future.result$finished <- base::Sys.time()
[10:29:49.604]     ...future.result
[10:29:49.604] }
[10:29:49.607] assign_globals() ...
[10:29:49.607] List of 5
[10:29:49.607]  $ future.call.arguments    : list()
[10:29:49.607]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.607]  $ ...future.FUN            :function (x)  
[10:29:49.607]  $ ...future.elements_ii    :List of 1
[10:29:49.607]   ..$ : int 1
[10:29:49.607]  $ ...future.seeds_ii       : NULL
[10:29:49.607]  $ ...future.globals.maxSize: num Inf
[10:29:49.607]  - attr(*, "resolved")= logi FALSE
[10:29:49.607]  - attr(*, "total_size")= num NA
[10:29:49.607]  - attr(*, "where")=List of 5
[10:29:49.607]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.607]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.607]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.607]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.607]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.607]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.607]  - attr(*, "already-done")= logi TRUE
[10:29:49.611] - copied ‘future.call.arguments’ to environment
[10:29:49.611] - copied ‘...future.FUN’ to environment
[10:29:49.612] - copied ‘...future.elements_ii’ to environment
[10:29:49.612] - copied ‘...future.seeds_ii’ to environment
[10:29:49.612] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.612] assign_globals() ... done
[10:29:49.612] requestCore(): workers = 2
[10:29:49.614] MulticoreFuture started
[10:29:49.615] - Launch lazy future ... done
[10:29:49.615] run() for ‘MulticoreFuture’ ... done
[10:29:49.615] Created future:
[10:29:49.615] plan(): Setting new future strategy stack:
[10:29:49.616] List of future strategies:
[10:29:49.616] 1. sequential:
[10:29:49.616]    - args: function (..., envir = parent.frame())
[10:29:49.616]    - tweaked: FALSE
[10:29:49.616]    - call: NULL
[10:29:49.616] plan(): nbrOfWorkers() = 1
[10:29:49.618] plan(): Setting new future strategy stack:
[10:29:49.619] List of future strategies:
[10:29:49.619] 1. multicore:
[10:29:49.619]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.619]    - tweaked: FALSE
[10:29:49.619]    - call: plan(strategy)
[10:29:49.624] plan(): nbrOfWorkers() = 2
[10:29:49.615] MulticoreFuture:
[10:29:49.615] Label: ‘future_apply-1’
[10:29:49.615] Expression:
[10:29:49.615] {
[10:29:49.615]     do.call(function(...) {
[10:29:49.615]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.615]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.615]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.615]             on.exit(options(oopts), add = TRUE)
[10:29:49.615]         }
[10:29:49.615]         {
[10:29:49.615]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.615]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.615]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.615]             })
[10:29:49.615]         }
[10:29:49.615]     }, args = future.call.arguments)
[10:29:49.615] }
[10:29:49.615] Lazy evaluation: FALSE
[10:29:49.615] Asynchronous evaluation: TRUE
[10:29:49.615] Local evaluation: TRUE
[10:29:49.615] Environment: R_GlobalEnv
[10:29:49.615] Capture standard output: TRUE
[10:29:49.615] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.615] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.615] Packages: <none>
[10:29:49.615] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.615] Resolved: TRUE
[10:29:49.615] Value: <not collected>
[10:29:49.615] Conditions captured: <none>
[10:29:49.615] Early signaling: FALSE
[10:29:49.615] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.615] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.625] Chunk #1 of 2 ... DONE
[10:29:49.625] Chunk #2 of 2 ...
[10:29:49.625]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.625]  - seeds: <none>
[10:29:49.626]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.626] getGlobalsAndPackages() ...
[10:29:49.626] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.626] Resolving globals: FALSE
[10:29:49.626] Tweak future expression to call with '...' arguments ...
[10:29:49.626] {
[10:29:49.626]     do.call(function(...) {
[10:29:49.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.626]             on.exit(options(oopts), add = TRUE)
[10:29:49.626]         }
[10:29:49.626]         {
[10:29:49.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.626]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.626]             })
[10:29:49.626]         }
[10:29:49.626]     }, args = future.call.arguments)
[10:29:49.626] }
[10:29:49.627] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.628] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.628] 
[10:29:49.628] getGlobalsAndPackages() ... DONE
[10:29:49.628] run() for ‘Future’ ...
[10:29:49.629] - state: ‘created’
[10:29:49.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.634]   - Field: ‘label’
[10:29:49.634]   - Field: ‘local’
[10:29:49.634]   - Field: ‘owner’
[10:29:49.637]   - Field: ‘envir’
[10:29:49.638]   - Field: ‘workers’
[10:29:49.638]   - Field: ‘packages’
[10:29:49.639]   - Field: ‘gc’
[10:29:49.639]   - Field: ‘job’
[10:29:49.639]   - Field: ‘conditions’
[10:29:49.640]   - Field: ‘expr’
[10:29:49.640]   - Field: ‘uuid’
[10:29:49.640]   - Field: ‘seed’
[10:29:49.640]   - Field: ‘version’
[10:29:49.641]   - Field: ‘result’
[10:29:49.641]   - Field: ‘asynchronous’
[10:29:49.641]   - Field: ‘calls’
[10:29:49.641]   - Field: ‘globals’
[10:29:49.642]   - Field: ‘stdout’
[10:29:49.642]   - Field: ‘earlySignal’
[10:29:49.642]   - Field: ‘lazy’
[10:29:49.642]   - Field: ‘state’
[10:29:49.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.643] - Launch lazy future ...
[10:29:49.644] Packages needed by the future expression (n = 0): <none>
[10:29:49.644] Packages needed by future strategies (n = 0): <none>
[10:29:49.645] {
[10:29:49.645]     {
[10:29:49.645]         {
[10:29:49.645]             ...future.startTime <- base::Sys.time()
[10:29:49.645]             {
[10:29:49.645]                 {
[10:29:49.645]                   {
[10:29:49.645]                     {
[10:29:49.645]                       base::local({
[10:29:49.645]                         has_future <- base::requireNamespace("future", 
[10:29:49.645]                           quietly = TRUE)
[10:29:49.645]                         if (has_future) {
[10:29:49.645]                           ns <- base::getNamespace("future")
[10:29:49.645]                           version <- ns[[".package"]][["version"]]
[10:29:49.645]                           if (is.null(version)) 
[10:29:49.645]                             version <- utils::packageVersion("future")
[10:29:49.645]                         }
[10:29:49.645]                         else {
[10:29:49.645]                           version <- NULL
[10:29:49.645]                         }
[10:29:49.645]                         if (!has_future || version < "1.8.0") {
[10:29:49.645]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.645]                             "", base::R.version$version.string), 
[10:29:49.645]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.645]                               "release", "version")], collapse = " "), 
[10:29:49.645]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.645]                             info)
[10:29:49.645]                           info <- base::paste(info, collapse = "; ")
[10:29:49.645]                           if (!has_future) {
[10:29:49.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.645]                               info)
[10:29:49.645]                           }
[10:29:49.645]                           else {
[10:29:49.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.645]                               info, version)
[10:29:49.645]                           }
[10:29:49.645]                           base::stop(msg)
[10:29:49.645]                         }
[10:29:49.645]                       })
[10:29:49.645]                     }
[10:29:49.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.645]                     base::options(mc.cores = 1L)
[10:29:49.645]                   }
[10:29:49.645]                   ...future.strategy.old <- future::plan("list")
[10:29:49.645]                   options(future.plan = NULL)
[10:29:49.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.645]                 }
[10:29:49.645]                 ...future.workdir <- getwd()
[10:29:49.645]             }
[10:29:49.645]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.645]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.645]         }
[10:29:49.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.645]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.645]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.645]             base::names(...future.oldOptions))
[10:29:49.645]     }
[10:29:49.645]     if (FALSE) {
[10:29:49.645]     }
[10:29:49.645]     else {
[10:29:49.645]         if (TRUE) {
[10:29:49.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.645]                 open = "w")
[10:29:49.645]         }
[10:29:49.645]         else {
[10:29:49.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.645]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.645]         }
[10:29:49.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.645]             base::sink(type = "output", split = FALSE)
[10:29:49.645]             base::close(...future.stdout)
[10:29:49.645]         }, add = TRUE)
[10:29:49.645]     }
[10:29:49.645]     ...future.frame <- base::sys.nframe()
[10:29:49.645]     ...future.conditions <- base::list()
[10:29:49.645]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.645]     if (FALSE) {
[10:29:49.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.645]     }
[10:29:49.645]     ...future.result <- base::tryCatch({
[10:29:49.645]         base::withCallingHandlers({
[10:29:49.645]             ...future.value <- base::withVisible(base::local({
[10:29:49.645]                 withCallingHandlers({
[10:29:49.645]                   {
[10:29:49.645]                     do.call(function(...) {
[10:29:49.645]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.645]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.645]                         ...future.globals.maxSize)) {
[10:29:49.645]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.645]                         on.exit(options(oopts), add = TRUE)
[10:29:49.645]                       }
[10:29:49.645]                       {
[10:29:49.645]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.645]                           FUN = function(jj) {
[10:29:49.645]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.645]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.645]                           })
[10:29:49.645]                       }
[10:29:49.645]                     }, args = future.call.arguments)
[10:29:49.645]                   }
[10:29:49.645]                 }, immediateCondition = function(cond) {
[10:29:49.645]                   save_rds <- function (object, pathname, ...) 
[10:29:49.645]                   {
[10:29:49.645]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.645]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.645]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.645]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.645]                         fi_tmp[["mtime"]])
[10:29:49.645]                     }
[10:29:49.645]                     tryCatch({
[10:29:49.645]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.645]                     }, error = function(ex) {
[10:29:49.645]                       msg <- conditionMessage(ex)
[10:29:49.645]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.645]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.645]                         fi_tmp[["mtime"]], msg)
[10:29:49.645]                       ex$message <- msg
[10:29:49.645]                       stop(ex)
[10:29:49.645]                     })
[10:29:49.645]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.645]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.645]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.645]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.645]                       fi <- file.info(pathname)
[10:29:49.645]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.645]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.645]                         fi[["size"]], fi[["mtime"]])
[10:29:49.645]                       stop(msg)
[10:29:49.645]                     }
[10:29:49.645]                     invisible(pathname)
[10:29:49.645]                   }
[10:29:49.645]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.645]                     rootPath = tempdir()) 
[10:29:49.645]                   {
[10:29:49.645]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.645]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.645]                       tmpdir = path, fileext = ".rds")
[10:29:49.645]                     save_rds(obj, file)
[10:29:49.645]                   }
[10:29:49.645]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.645]                   {
[10:29:49.645]                     inherits <- base::inherits
[10:29:49.645]                     invokeRestart <- base::invokeRestart
[10:29:49.645]                     is.null <- base::is.null
[10:29:49.645]                     muffled <- FALSE
[10:29:49.645]                     if (inherits(cond, "message")) {
[10:29:49.645]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.645]                       if (muffled) 
[10:29:49.645]                         invokeRestart("muffleMessage")
[10:29:49.645]                     }
[10:29:49.645]                     else if (inherits(cond, "warning")) {
[10:29:49.645]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.645]                       if (muffled) 
[10:29:49.645]                         invokeRestart("muffleWarning")
[10:29:49.645]                     }
[10:29:49.645]                     else if (inherits(cond, "condition")) {
[10:29:49.645]                       if (!is.null(pattern)) {
[10:29:49.645]                         computeRestarts <- base::computeRestarts
[10:29:49.645]                         grepl <- base::grepl
[10:29:49.645]                         restarts <- computeRestarts(cond)
[10:29:49.645]                         for (restart in restarts) {
[10:29:49.645]                           name <- restart$name
[10:29:49.645]                           if (is.null(name)) 
[10:29:49.645]                             next
[10:29:49.645]                           if (!grepl(pattern, name)) 
[10:29:49.645]                             next
[10:29:49.645]                           invokeRestart(restart)
[10:29:49.645]                           muffled <- TRUE
[10:29:49.645]                           break
[10:29:49.645]                         }
[10:29:49.645]                       }
[10:29:49.645]                     }
[10:29:49.645]                     invisible(muffled)
[10:29:49.645]                   }
[10:29:49.645]                   muffleCondition(cond)
[10:29:49.645]                 })
[10:29:49.645]             }))
[10:29:49.645]             future::FutureResult(value = ...future.value$value, 
[10:29:49.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.645]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.645]                     ...future.globalenv.names))
[10:29:49.645]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.645]         }, condition = base::local({
[10:29:49.645]             c <- base::c
[10:29:49.645]             inherits <- base::inherits
[10:29:49.645]             invokeRestart <- base::invokeRestart
[10:29:49.645]             length <- base::length
[10:29:49.645]             list <- base::list
[10:29:49.645]             seq.int <- base::seq.int
[10:29:49.645]             signalCondition <- base::signalCondition
[10:29:49.645]             sys.calls <- base::sys.calls
[10:29:49.645]             `[[` <- base::`[[`
[10:29:49.645]             `+` <- base::`+`
[10:29:49.645]             `<<-` <- base::`<<-`
[10:29:49.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.645]                   3L)]
[10:29:49.645]             }
[10:29:49.645]             function(cond) {
[10:29:49.645]                 is_error <- inherits(cond, "error")
[10:29:49.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.645]                   NULL)
[10:29:49.645]                 if (is_error) {
[10:29:49.645]                   sessionInformation <- function() {
[10:29:49.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.645]                       search = base::search(), system = base::Sys.info())
[10:29:49.645]                   }
[10:29:49.645]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.645]                     cond$call), session = sessionInformation(), 
[10:29:49.645]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.645]                   signalCondition(cond)
[10:29:49.645]                 }
[10:29:49.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.645]                 "immediateCondition"))) {
[10:29:49.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.645]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.645]                   if (TRUE && !signal) {
[10:29:49.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.645]                     {
[10:29:49.645]                       inherits <- base::inherits
[10:29:49.645]                       invokeRestart <- base::invokeRestart
[10:29:49.645]                       is.null <- base::is.null
[10:29:49.645]                       muffled <- FALSE
[10:29:49.645]                       if (inherits(cond, "message")) {
[10:29:49.645]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.645]                         if (muffled) 
[10:29:49.645]                           invokeRestart("muffleMessage")
[10:29:49.645]                       }
[10:29:49.645]                       else if (inherits(cond, "warning")) {
[10:29:49.645]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.645]                         if (muffled) 
[10:29:49.645]                           invokeRestart("muffleWarning")
[10:29:49.645]                       }
[10:29:49.645]                       else if (inherits(cond, "condition")) {
[10:29:49.645]                         if (!is.null(pattern)) {
[10:29:49.645]                           computeRestarts <- base::computeRestarts
[10:29:49.645]                           grepl <- base::grepl
[10:29:49.645]                           restarts <- computeRestarts(cond)
[10:29:49.645]                           for (restart in restarts) {
[10:29:49.645]                             name <- restart$name
[10:29:49.645]                             if (is.null(name)) 
[10:29:49.645]                               next
[10:29:49.645]                             if (!grepl(pattern, name)) 
[10:29:49.645]                               next
[10:29:49.645]                             invokeRestart(restart)
[10:29:49.645]                             muffled <- TRUE
[10:29:49.645]                             break
[10:29:49.645]                           }
[10:29:49.645]                         }
[10:29:49.645]                       }
[10:29:49.645]                       invisible(muffled)
[10:29:49.645]                     }
[10:29:49.645]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.645]                   }
[10:29:49.645]                 }
[10:29:49.645]                 else {
[10:29:49.645]                   if (TRUE) {
[10:29:49.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.645]                     {
[10:29:49.645]                       inherits <- base::inherits
[10:29:49.645]                       invokeRestart <- base::invokeRestart
[10:29:49.645]                       is.null <- base::is.null
[10:29:49.645]                       muffled <- FALSE
[10:29:49.645]                       if (inherits(cond, "message")) {
[10:29:49.645]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.645]                         if (muffled) 
[10:29:49.645]                           invokeRestart("muffleMessage")
[10:29:49.645]                       }
[10:29:49.645]                       else if (inherits(cond, "warning")) {
[10:29:49.645]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.645]                         if (muffled) 
[10:29:49.645]                           invokeRestart("muffleWarning")
[10:29:49.645]                       }
[10:29:49.645]                       else if (inherits(cond, "condition")) {
[10:29:49.645]                         if (!is.null(pattern)) {
[10:29:49.645]                           computeRestarts <- base::computeRestarts
[10:29:49.645]                           grepl <- base::grepl
[10:29:49.645]                           restarts <- computeRestarts(cond)
[10:29:49.645]                           for (restart in restarts) {
[10:29:49.645]                             name <- restart$name
[10:29:49.645]                             if (is.null(name)) 
[10:29:49.645]                               next
[10:29:49.645]                             if (!grepl(pattern, name)) 
[10:29:49.645]                               next
[10:29:49.645]                             invokeRestart(restart)
[10:29:49.645]                             muffled <- TRUE
[10:29:49.645]                             break
[10:29:49.645]                           }
[10:29:49.645]                         }
[10:29:49.645]                       }
[10:29:49.645]                       invisible(muffled)
[10:29:49.645]                     }
[10:29:49.645]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.645]                   }
[10:29:49.645]                 }
[10:29:49.645]             }
[10:29:49.645]         }))
[10:29:49.645]     }, error = function(ex) {
[10:29:49.645]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.645]                 ...future.rng), started = ...future.startTime, 
[10:29:49.645]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.645]             version = "1.8"), class = "FutureResult")
[10:29:49.645]     }, finally = {
[10:29:49.645]         if (!identical(...future.workdir, getwd())) 
[10:29:49.645]             setwd(...future.workdir)
[10:29:49.645]         {
[10:29:49.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.645]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.645]             }
[10:29:49.645]             base::options(...future.oldOptions)
[10:29:49.645]             if (.Platform$OS.type == "windows") {
[10:29:49.645]                 old_names <- names(...future.oldEnvVars)
[10:29:49.645]                 envs <- base::Sys.getenv()
[10:29:49.645]                 names <- names(envs)
[10:29:49.645]                 common <- intersect(names, old_names)
[10:29:49.645]                 added <- setdiff(names, old_names)
[10:29:49.645]                 removed <- setdiff(old_names, names)
[10:29:49.645]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.645]                   envs[common]]
[10:29:49.645]                 NAMES <- toupper(changed)
[10:29:49.645]                 args <- list()
[10:29:49.645]                 for (kk in seq_along(NAMES)) {
[10:29:49.645]                   name <- changed[[kk]]
[10:29:49.645]                   NAME <- NAMES[[kk]]
[10:29:49.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.645]                     next
[10:29:49.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.645]                 }
[10:29:49.645]                 NAMES <- toupper(added)
[10:29:49.645]                 for (kk in seq_along(NAMES)) {
[10:29:49.645]                   name <- added[[kk]]
[10:29:49.645]                   NAME <- NAMES[[kk]]
[10:29:49.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.645]                     next
[10:29:49.645]                   args[[name]] <- ""
[10:29:49.645]                 }
[10:29:49.645]                 NAMES <- toupper(removed)
[10:29:49.645]                 for (kk in seq_along(NAMES)) {
[10:29:49.645]                   name <- removed[[kk]]
[10:29:49.645]                   NAME <- NAMES[[kk]]
[10:29:49.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.645]                     next
[10:29:49.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.645]                 }
[10:29:49.645]                 if (length(args) > 0) 
[10:29:49.645]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.645]             }
[10:29:49.645]             else {
[10:29:49.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.645]             }
[10:29:49.645]             {
[10:29:49.645]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.645]                   0L) {
[10:29:49.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.645]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.645]                   base::options(opts)
[10:29:49.645]                 }
[10:29:49.645]                 {
[10:29:49.645]                   {
[10:29:49.645]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.645]                     NULL
[10:29:49.645]                   }
[10:29:49.645]                   options(future.plan = NULL)
[10:29:49.645]                   if (is.na(NA_character_)) 
[10:29:49.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.645]                     .init = FALSE)
[10:29:49.645]                 }
[10:29:49.645]             }
[10:29:49.645]         }
[10:29:49.645]     })
[10:29:49.645]     if (TRUE) {
[10:29:49.645]         base::sink(type = "output", split = FALSE)
[10:29:49.645]         if (TRUE) {
[10:29:49.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.645]         }
[10:29:49.645]         else {
[10:29:49.645]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.645]         }
[10:29:49.645]         base::close(...future.stdout)
[10:29:49.645]         ...future.stdout <- NULL
[10:29:49.645]     }
[10:29:49.645]     ...future.result$conditions <- ...future.conditions
[10:29:49.645]     ...future.result$finished <- base::Sys.time()
[10:29:49.645]     ...future.result
[10:29:49.645] }
[10:29:49.648] assign_globals() ...
[10:29:49.648] List of 5
[10:29:49.648]  $ future.call.arguments    : list()
[10:29:49.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.648]  $ ...future.FUN            :function (x)  
[10:29:49.648]  $ ...future.elements_ii    :List of 1
[10:29:49.648]   ..$ : int 2
[10:29:49.648]  $ ...future.seeds_ii       : NULL
[10:29:49.648]  $ ...future.globals.maxSize: num Inf
[10:29:49.648]  - attr(*, "resolved")= logi FALSE
[10:29:49.648]  - attr(*, "total_size")= num NA
[10:29:49.648]  - attr(*, "where")=List of 5
[10:29:49.648]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.648]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.648]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.648]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.648]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.648]  - attr(*, "already-done")= logi TRUE
[10:29:49.655] - copied ‘future.call.arguments’ to environment
[10:29:49.656] - copied ‘...future.FUN’ to environment
[10:29:49.656] - copied ‘...future.elements_ii’ to environment
[10:29:49.656] - copied ‘...future.seeds_ii’ to environment
[10:29:49.656] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.656] assign_globals() ... done
[10:29:49.656] requestCore(): workers = 2
[10:29:49.659] MulticoreFuture started
[10:29:49.659] - Launch lazy future ... done
[10:29:49.659] run() for ‘MulticoreFuture’ ... done
[10:29:49.659] Created future:
[10:29:49.660] plan(): Setting new future strategy stack:
[10:29:49.660] List of future strategies:
[10:29:49.660] 1. sequential:
[10:29:49.660]    - args: function (..., envir = parent.frame())
[10:29:49.660]    - tweaked: FALSE
[10:29:49.660]    - call: NULL
[10:29:49.661] plan(): nbrOfWorkers() = 1
[10:29:49.663] plan(): Setting new future strategy stack:
[10:29:49.663] List of future strategies:
[10:29:49.663] 1. multicore:
[10:29:49.663]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.663]    - tweaked: FALSE
[10:29:49.663]    - call: plan(strategy)
[10:29:49.668] plan(): nbrOfWorkers() = 2
[10:29:49.660] MulticoreFuture:
[10:29:49.660] Label: ‘future_apply-2’
[10:29:49.660] Expression:
[10:29:49.660] {
[10:29:49.660]     do.call(function(...) {
[10:29:49.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.660]             on.exit(options(oopts), add = TRUE)
[10:29:49.660]         }
[10:29:49.660]         {
[10:29:49.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.660]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.660]             })
[10:29:49.660]         }
[10:29:49.660]     }, args = future.call.arguments)
[10:29:49.660] }
[10:29:49.660] Lazy evaluation: FALSE
[10:29:49.660] Asynchronous evaluation: TRUE
[10:29:49.660] Local evaluation: TRUE
[10:29:49.660] Environment: R_GlobalEnv
[10:29:49.660] Capture standard output: TRUE
[10:29:49.660] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.660] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.660] Packages: <none>
[10:29:49.660] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.660] Resolved: TRUE
[10:29:49.660] Value: <not collected>
[10:29:49.660] Conditions captured: <none>
[10:29:49.660] Early signaling: FALSE
[10:29:49.660] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.660] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.669] Chunk #2 of 2 ... DONE
[10:29:49.670] Launching 2 futures (chunks) ... DONE
[10:29:49.670] Resolving 2 futures (chunks) ...
[10:29:49.670] resolve() on list ...
[10:29:49.670]  recursive: 0
[10:29:49.670]  length: 2
[10:29:49.670] 
[10:29:49.671] Future #1
[10:29:49.671] result() for MulticoreFuture ...
[10:29:49.672] result() for MulticoreFuture ...
[10:29:49.672] result() for MulticoreFuture ... done
[10:29:49.672] result() for MulticoreFuture ... done
[10:29:49.672] result() for MulticoreFuture ...
[10:29:49.672] result() for MulticoreFuture ... done
[10:29:49.673] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:49.673] - nx: 2
[10:29:49.673] - relay: TRUE
[10:29:49.673] - stdout: TRUE
[10:29:49.673] - signal: TRUE
[10:29:49.673] - resignal: FALSE
[10:29:49.673] - force: TRUE
[10:29:49.674] - relayed: [n=2] FALSE, FALSE
[10:29:49.674] - queued futures: [n=2] FALSE, FALSE
[10:29:49.674]  - until=1
[10:29:49.674]  - relaying element #1
[10:29:49.674] result() for MulticoreFuture ...
[10:29:49.674] result() for MulticoreFuture ... done
[10:29:49.675] result() for MulticoreFuture ...
[10:29:49.675] result() for MulticoreFuture ... done
[10:29:49.675] result() for MulticoreFuture ...
[10:29:49.675] result() for MulticoreFuture ... done
[10:29:49.675] result() for MulticoreFuture ...
[10:29:49.675] result() for MulticoreFuture ... done
[10:29:49.676] - relayed: [n=2] TRUE, FALSE
[10:29:49.676] - queued futures: [n=2] TRUE, FALSE
[10:29:49.676] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:49.676]  length: 1 (resolved future 1)
[10:29:49.676] Future #2
[10:29:49.676] result() for MulticoreFuture ...
[10:29:49.677] result() for MulticoreFuture ...
[10:29:49.677] result() for MulticoreFuture ... done
[10:29:49.677] result() for MulticoreFuture ... done
[10:29:49.678] result() for MulticoreFuture ...
[10:29:49.678] result() for MulticoreFuture ... done
[10:29:49.678] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:49.678] - nx: 2
[10:29:49.678] - relay: TRUE
[10:29:49.678] - stdout: TRUE
[10:29:49.678] - signal: TRUE
[10:29:49.678] - resignal: FALSE
[10:29:49.679] - force: TRUE
[10:29:49.679] - relayed: [n=2] TRUE, FALSE
[10:29:49.679] - queued futures: [n=2] TRUE, FALSE
[10:29:49.679]  - until=2
[10:29:49.679]  - relaying element #2
[10:29:49.679] result() for MulticoreFuture ...
[10:29:49.679] result() for MulticoreFuture ... done
[10:29:49.679] result() for MulticoreFuture ...
[10:29:49.680] result() for MulticoreFuture ... done
[10:29:49.680] result() for MulticoreFuture ...
[10:29:49.680] result() for MulticoreFuture ... done
[10:29:49.680] result() for MulticoreFuture ...
[10:29:49.680] result() for MulticoreFuture ... done
[10:29:49.680] - relayed: [n=2] TRUE, TRUE
[10:29:49.680] - queued futures: [n=2] TRUE, TRUE
[10:29:49.680] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:49.680]  length: 0 (resolved future 2)
[10:29:49.681] Relaying remaining futures
[10:29:49.681] signalConditionsASAP(NULL, pos=0) ...
[10:29:49.681] - nx: 2
[10:29:49.681] - relay: TRUE
[10:29:49.681] - stdout: TRUE
[10:29:49.681] - signal: TRUE
[10:29:49.681] - resignal: FALSE
[10:29:49.681] - force: TRUE
[10:29:49.681] - relayed: [n=2] TRUE, TRUE
[10:29:49.682] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:49.684] - relayed: [n=2] TRUE, TRUE
[10:29:49.684] - queued futures: [n=2] TRUE, TRUE
[10:29:49.684] signalConditionsASAP(NULL, pos=0) ... done
[10:29:49.685] resolve() on list ... DONE
[10:29:49.685] result() for MulticoreFuture ...
[10:29:49.685] result() for MulticoreFuture ... done
[10:29:49.685] result() for MulticoreFuture ...
[10:29:49.685] result() for MulticoreFuture ... done
[10:29:49.686] result() for MulticoreFuture ...
[10:29:49.686] result() for MulticoreFuture ... done
[10:29:49.686] result() for MulticoreFuture ...
[10:29:49.686] result() for MulticoreFuture ... done
[10:29:49.686]  - Number of value chunks collected: 2
[10:29:49.686] Resolving 2 futures (chunks) ... DONE
[10:29:49.686] Reducing values from 2 chunks ...
[10:29:49.687]  - Number of values collected after concatenation: 2
[10:29:49.687]  - Number of values expected: 2
[10:29:49.687] Reducing values from 2 chunks ... DONE
[10:29:49.687] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:29:49.688] getGlobalsAndPackagesXApply() ...
[10:29:49.688]  - future.globals: TRUE
[10:29:49.688] getGlobalsAndPackages() ...
[10:29:49.688] Searching for globals...
[10:29:49.689] - globals found: [1] ‘FUN’
[10:29:49.690] Searching for globals ... DONE
[10:29:49.690] Resolving globals: FALSE
[10:29:49.690] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:49.691] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:49.691] - globals: [1] ‘FUN’
[10:29:49.691] 
[10:29:49.691] getGlobalsAndPackages() ... DONE
[10:29:49.691]  - globals found/used: [n=1] ‘FUN’
[10:29:49.691]  - needed namespaces: [n=0] 
[10:29:49.691] Finding globals ... DONE
[10:29:49.692]  - use_args: TRUE
[10:29:49.692]  - Getting '...' globals ...
[10:29:49.692] resolve() on list ...
[10:29:49.692]  recursive: 0
[10:29:49.692]  length: 1
[10:29:49.692]  elements: ‘...’
[10:29:49.693]  length: 0 (resolved future 1)
[10:29:49.693] resolve() on list ... DONE
[10:29:49.693]    - '...' content: [n=0] 
[10:29:49.693] List of 1
[10:29:49.693]  $ ...: list()
[10:29:49.693]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.693]  - attr(*, "where")=List of 1
[10:29:49.693]   ..$ ...:<environment: 0x5618a1e21fb0> 
[10:29:49.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.693]  - attr(*, "resolved")= logi TRUE
[10:29:49.693]  - attr(*, "total_size")= num NA
[10:29:49.696]  - Getting '...' globals ... DONE
[10:29:49.696] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:49.696] List of 2
[10:29:49.696]  $ ...future.FUN:function (x)  
[10:29:49.696]  $ ...          : list()
[10:29:49.696]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.696]  - attr(*, "where")=List of 2
[10:29:49.696]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:49.696]   ..$ ...          :<environment: 0x5618a1e21fb0> 
[10:29:49.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.696]  - attr(*, "resolved")= logi FALSE
[10:29:49.696]  - attr(*, "total_size")= num 848
[10:29:49.699] Packages to be attached in all futures: [n=0] 
[10:29:49.699] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.704] future_lapply() ...
[10:29:49.707] Number of chunks: 2
[10:29:49.708] getGlobalsAndPackagesXApply() ...
[10:29:49.708]  - future.globals: <name-value list> with names ‘list()’
[10:29:49.708]  - use_args: TRUE
[10:29:49.708] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:49.708] List of 2
[10:29:49.708]  $ ...          : list()
[10:29:49.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.708]  $ ...future.FUN:function (x)  
[10:29:49.708]  - attr(*, "where")=List of 2
[10:29:49.708]   ..$ ...          :<environment: 0x5618a1e21fb0> 
[10:29:49.708]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:49.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.708]  - attr(*, "resolved")= logi FALSE
[10:29:49.708]  - attr(*, "total_size")= num NA
[10:29:49.711] Packages to be attached in all futures: [n=0] 
[10:29:49.711] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.712] Number of futures (= number of chunks): 2
[10:29:49.712] Launching 2 futures (chunks) ...
[10:29:49.712] Chunk #1 of 2 ...
[10:29:49.713]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.714]  - seeds: <none>
[10:29:49.714]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.714] getGlobalsAndPackages() ...
[10:29:49.714] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.714] Resolving globals: FALSE
[10:29:49.714] Tweak future expression to call with '...' arguments ...
[10:29:49.714] {
[10:29:49.714]     do.call(function(...) {
[10:29:49.714]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.714]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.714]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.714]             on.exit(options(oopts), add = TRUE)
[10:29:49.714]         }
[10:29:49.714]         {
[10:29:49.714]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.714]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.714]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.714]             })
[10:29:49.714]         }
[10:29:49.714]     }, args = future.call.arguments)
[10:29:49.714] }
[10:29:49.715] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.715] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.715] 
[10:29:49.715] getGlobalsAndPackages() ... DONE
[10:29:49.716] run() for ‘Future’ ...
[10:29:49.716] - state: ‘created’
[10:29:49.716] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.719] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.720]   - Field: ‘label’
[10:29:49.720]   - Field: ‘local’
[10:29:49.720]   - Field: ‘owner’
[10:29:49.720]   - Field: ‘envir’
[10:29:49.720]   - Field: ‘workers’
[10:29:49.720]   - Field: ‘packages’
[10:29:49.720]   - Field: ‘gc’
[10:29:49.720]   - Field: ‘job’
[10:29:49.720]   - Field: ‘conditions’
[10:29:49.721]   - Field: ‘expr’
[10:29:49.721]   - Field: ‘uuid’
[10:29:49.721]   - Field: ‘seed’
[10:29:49.721]   - Field: ‘version’
[10:29:49.721]   - Field: ‘result’
[10:29:49.721]   - Field: ‘asynchronous’
[10:29:49.721]   - Field: ‘calls’
[10:29:49.721]   - Field: ‘globals’
[10:29:49.721]   - Field: ‘stdout’
[10:29:49.721]   - Field: ‘earlySignal’
[10:29:49.722]   - Field: ‘lazy’
[10:29:49.722]   - Field: ‘state’
[10:29:49.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.722] - Launch lazy future ...
[10:29:49.722] Packages needed by the future expression (n = 0): <none>
[10:29:49.722] Packages needed by future strategies (n = 0): <none>
[10:29:49.723] {
[10:29:49.723]     {
[10:29:49.723]         {
[10:29:49.723]             ...future.startTime <- base::Sys.time()
[10:29:49.723]             {
[10:29:49.723]                 {
[10:29:49.723]                   {
[10:29:49.723]                     {
[10:29:49.723]                       base::local({
[10:29:49.723]                         has_future <- base::requireNamespace("future", 
[10:29:49.723]                           quietly = TRUE)
[10:29:49.723]                         if (has_future) {
[10:29:49.723]                           ns <- base::getNamespace("future")
[10:29:49.723]                           version <- ns[[".package"]][["version"]]
[10:29:49.723]                           if (is.null(version)) 
[10:29:49.723]                             version <- utils::packageVersion("future")
[10:29:49.723]                         }
[10:29:49.723]                         else {
[10:29:49.723]                           version <- NULL
[10:29:49.723]                         }
[10:29:49.723]                         if (!has_future || version < "1.8.0") {
[10:29:49.723]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.723]                             "", base::R.version$version.string), 
[10:29:49.723]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.723]                               "release", "version")], collapse = " "), 
[10:29:49.723]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.723]                             info)
[10:29:49.723]                           info <- base::paste(info, collapse = "; ")
[10:29:49.723]                           if (!has_future) {
[10:29:49.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.723]                               info)
[10:29:49.723]                           }
[10:29:49.723]                           else {
[10:29:49.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.723]                               info, version)
[10:29:49.723]                           }
[10:29:49.723]                           base::stop(msg)
[10:29:49.723]                         }
[10:29:49.723]                       })
[10:29:49.723]                     }
[10:29:49.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.723]                     base::options(mc.cores = 1L)
[10:29:49.723]                   }
[10:29:49.723]                   ...future.strategy.old <- future::plan("list")
[10:29:49.723]                   options(future.plan = NULL)
[10:29:49.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.723]                 }
[10:29:49.723]                 ...future.workdir <- getwd()
[10:29:49.723]             }
[10:29:49.723]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.723]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.723]         }
[10:29:49.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.723]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.723]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.723]             base::names(...future.oldOptions))
[10:29:49.723]     }
[10:29:49.723]     if (FALSE) {
[10:29:49.723]     }
[10:29:49.723]     else {
[10:29:49.723]         if (TRUE) {
[10:29:49.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.723]                 open = "w")
[10:29:49.723]         }
[10:29:49.723]         else {
[10:29:49.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.723]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.723]         }
[10:29:49.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.723]             base::sink(type = "output", split = FALSE)
[10:29:49.723]             base::close(...future.stdout)
[10:29:49.723]         }, add = TRUE)
[10:29:49.723]     }
[10:29:49.723]     ...future.frame <- base::sys.nframe()
[10:29:49.723]     ...future.conditions <- base::list()
[10:29:49.723]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.723]     if (FALSE) {
[10:29:49.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.723]     }
[10:29:49.723]     ...future.result <- base::tryCatch({
[10:29:49.723]         base::withCallingHandlers({
[10:29:49.723]             ...future.value <- base::withVisible(base::local({
[10:29:49.723]                 withCallingHandlers({
[10:29:49.723]                   {
[10:29:49.723]                     do.call(function(...) {
[10:29:49.723]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.723]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.723]                         ...future.globals.maxSize)) {
[10:29:49.723]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.723]                         on.exit(options(oopts), add = TRUE)
[10:29:49.723]                       }
[10:29:49.723]                       {
[10:29:49.723]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.723]                           FUN = function(jj) {
[10:29:49.723]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.723]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.723]                           })
[10:29:49.723]                       }
[10:29:49.723]                     }, args = future.call.arguments)
[10:29:49.723]                   }
[10:29:49.723]                 }, immediateCondition = function(cond) {
[10:29:49.723]                   save_rds <- function (object, pathname, ...) 
[10:29:49.723]                   {
[10:29:49.723]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.723]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.723]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.723]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.723]                         fi_tmp[["mtime"]])
[10:29:49.723]                     }
[10:29:49.723]                     tryCatch({
[10:29:49.723]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.723]                     }, error = function(ex) {
[10:29:49.723]                       msg <- conditionMessage(ex)
[10:29:49.723]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.723]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.723]                         fi_tmp[["mtime"]], msg)
[10:29:49.723]                       ex$message <- msg
[10:29:49.723]                       stop(ex)
[10:29:49.723]                     })
[10:29:49.723]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.723]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.723]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.723]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.723]                       fi <- file.info(pathname)
[10:29:49.723]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.723]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.723]                         fi[["size"]], fi[["mtime"]])
[10:29:49.723]                       stop(msg)
[10:29:49.723]                     }
[10:29:49.723]                     invisible(pathname)
[10:29:49.723]                   }
[10:29:49.723]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.723]                     rootPath = tempdir()) 
[10:29:49.723]                   {
[10:29:49.723]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.723]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.723]                       tmpdir = path, fileext = ".rds")
[10:29:49.723]                     save_rds(obj, file)
[10:29:49.723]                   }
[10:29:49.723]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.723]                   {
[10:29:49.723]                     inherits <- base::inherits
[10:29:49.723]                     invokeRestart <- base::invokeRestart
[10:29:49.723]                     is.null <- base::is.null
[10:29:49.723]                     muffled <- FALSE
[10:29:49.723]                     if (inherits(cond, "message")) {
[10:29:49.723]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.723]                       if (muffled) 
[10:29:49.723]                         invokeRestart("muffleMessage")
[10:29:49.723]                     }
[10:29:49.723]                     else if (inherits(cond, "warning")) {
[10:29:49.723]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.723]                       if (muffled) 
[10:29:49.723]                         invokeRestart("muffleWarning")
[10:29:49.723]                     }
[10:29:49.723]                     else if (inherits(cond, "condition")) {
[10:29:49.723]                       if (!is.null(pattern)) {
[10:29:49.723]                         computeRestarts <- base::computeRestarts
[10:29:49.723]                         grepl <- base::grepl
[10:29:49.723]                         restarts <- computeRestarts(cond)
[10:29:49.723]                         for (restart in restarts) {
[10:29:49.723]                           name <- restart$name
[10:29:49.723]                           if (is.null(name)) 
[10:29:49.723]                             next
[10:29:49.723]                           if (!grepl(pattern, name)) 
[10:29:49.723]                             next
[10:29:49.723]                           invokeRestart(restart)
[10:29:49.723]                           muffled <- TRUE
[10:29:49.723]                           break
[10:29:49.723]                         }
[10:29:49.723]                       }
[10:29:49.723]                     }
[10:29:49.723]                     invisible(muffled)
[10:29:49.723]                   }
[10:29:49.723]                   muffleCondition(cond)
[10:29:49.723]                 })
[10:29:49.723]             }))
[10:29:49.723]             future::FutureResult(value = ...future.value$value, 
[10:29:49.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.723]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.723]                     ...future.globalenv.names))
[10:29:49.723]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.723]         }, condition = base::local({
[10:29:49.723]             c <- base::c
[10:29:49.723]             inherits <- base::inherits
[10:29:49.723]             invokeRestart <- base::invokeRestart
[10:29:49.723]             length <- base::length
[10:29:49.723]             list <- base::list
[10:29:49.723]             seq.int <- base::seq.int
[10:29:49.723]             signalCondition <- base::signalCondition
[10:29:49.723]             sys.calls <- base::sys.calls
[10:29:49.723]             `[[` <- base::`[[`
[10:29:49.723]             `+` <- base::`+`
[10:29:49.723]             `<<-` <- base::`<<-`
[10:29:49.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.723]                   3L)]
[10:29:49.723]             }
[10:29:49.723]             function(cond) {
[10:29:49.723]                 is_error <- inherits(cond, "error")
[10:29:49.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.723]                   NULL)
[10:29:49.723]                 if (is_error) {
[10:29:49.723]                   sessionInformation <- function() {
[10:29:49.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.723]                       search = base::search(), system = base::Sys.info())
[10:29:49.723]                   }
[10:29:49.723]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.723]                     cond$call), session = sessionInformation(), 
[10:29:49.723]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.723]                   signalCondition(cond)
[10:29:49.723]                 }
[10:29:49.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.723]                 "immediateCondition"))) {
[10:29:49.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.723]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.723]                   if (TRUE && !signal) {
[10:29:49.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.723]                     {
[10:29:49.723]                       inherits <- base::inherits
[10:29:49.723]                       invokeRestart <- base::invokeRestart
[10:29:49.723]                       is.null <- base::is.null
[10:29:49.723]                       muffled <- FALSE
[10:29:49.723]                       if (inherits(cond, "message")) {
[10:29:49.723]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.723]                         if (muffled) 
[10:29:49.723]                           invokeRestart("muffleMessage")
[10:29:49.723]                       }
[10:29:49.723]                       else if (inherits(cond, "warning")) {
[10:29:49.723]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.723]                         if (muffled) 
[10:29:49.723]                           invokeRestart("muffleWarning")
[10:29:49.723]                       }
[10:29:49.723]                       else if (inherits(cond, "condition")) {
[10:29:49.723]                         if (!is.null(pattern)) {
[10:29:49.723]                           computeRestarts <- base::computeRestarts
[10:29:49.723]                           grepl <- base::grepl
[10:29:49.723]                           restarts <- computeRestarts(cond)
[10:29:49.723]                           for (restart in restarts) {
[10:29:49.723]                             name <- restart$name
[10:29:49.723]                             if (is.null(name)) 
[10:29:49.723]                               next
[10:29:49.723]                             if (!grepl(pattern, name)) 
[10:29:49.723]                               next
[10:29:49.723]                             invokeRestart(restart)
[10:29:49.723]                             muffled <- TRUE
[10:29:49.723]                             break
[10:29:49.723]                           }
[10:29:49.723]                         }
[10:29:49.723]                       }
[10:29:49.723]                       invisible(muffled)
[10:29:49.723]                     }
[10:29:49.723]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.723]                   }
[10:29:49.723]                 }
[10:29:49.723]                 else {
[10:29:49.723]                   if (TRUE) {
[10:29:49.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.723]                     {
[10:29:49.723]                       inherits <- base::inherits
[10:29:49.723]                       invokeRestart <- base::invokeRestart
[10:29:49.723]                       is.null <- base::is.null
[10:29:49.723]                       muffled <- FALSE
[10:29:49.723]                       if (inherits(cond, "message")) {
[10:29:49.723]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.723]                         if (muffled) 
[10:29:49.723]                           invokeRestart("muffleMessage")
[10:29:49.723]                       }
[10:29:49.723]                       else if (inherits(cond, "warning")) {
[10:29:49.723]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.723]                         if (muffled) 
[10:29:49.723]                           invokeRestart("muffleWarning")
[10:29:49.723]                       }
[10:29:49.723]                       else if (inherits(cond, "condition")) {
[10:29:49.723]                         if (!is.null(pattern)) {
[10:29:49.723]                           computeRestarts <- base::computeRestarts
[10:29:49.723]                           grepl <- base::grepl
[10:29:49.723]                           restarts <- computeRestarts(cond)
[10:29:49.723]                           for (restart in restarts) {
[10:29:49.723]                             name <- restart$name
[10:29:49.723]                             if (is.null(name)) 
[10:29:49.723]                               next
[10:29:49.723]                             if (!grepl(pattern, name)) 
[10:29:49.723]                               next
[10:29:49.723]                             invokeRestart(restart)
[10:29:49.723]                             muffled <- TRUE
[10:29:49.723]                             break
[10:29:49.723]                           }
[10:29:49.723]                         }
[10:29:49.723]                       }
[10:29:49.723]                       invisible(muffled)
[10:29:49.723]                     }
[10:29:49.723]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.723]                   }
[10:29:49.723]                 }
[10:29:49.723]             }
[10:29:49.723]         }))
[10:29:49.723]     }, error = function(ex) {
[10:29:49.723]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.723]                 ...future.rng), started = ...future.startTime, 
[10:29:49.723]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.723]             version = "1.8"), class = "FutureResult")
[10:29:49.723]     }, finally = {
[10:29:49.723]         if (!identical(...future.workdir, getwd())) 
[10:29:49.723]             setwd(...future.workdir)
[10:29:49.723]         {
[10:29:49.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.723]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.723]             }
[10:29:49.723]             base::options(...future.oldOptions)
[10:29:49.723]             if (.Platform$OS.type == "windows") {
[10:29:49.723]                 old_names <- names(...future.oldEnvVars)
[10:29:49.723]                 envs <- base::Sys.getenv()
[10:29:49.723]                 names <- names(envs)
[10:29:49.723]                 common <- intersect(names, old_names)
[10:29:49.723]                 added <- setdiff(names, old_names)
[10:29:49.723]                 removed <- setdiff(old_names, names)
[10:29:49.723]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.723]                   envs[common]]
[10:29:49.723]                 NAMES <- toupper(changed)
[10:29:49.723]                 args <- list()
[10:29:49.723]                 for (kk in seq_along(NAMES)) {
[10:29:49.723]                   name <- changed[[kk]]
[10:29:49.723]                   NAME <- NAMES[[kk]]
[10:29:49.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.723]                     next
[10:29:49.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.723]                 }
[10:29:49.723]                 NAMES <- toupper(added)
[10:29:49.723]                 for (kk in seq_along(NAMES)) {
[10:29:49.723]                   name <- added[[kk]]
[10:29:49.723]                   NAME <- NAMES[[kk]]
[10:29:49.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.723]                     next
[10:29:49.723]                   args[[name]] <- ""
[10:29:49.723]                 }
[10:29:49.723]                 NAMES <- toupper(removed)
[10:29:49.723]                 for (kk in seq_along(NAMES)) {
[10:29:49.723]                   name <- removed[[kk]]
[10:29:49.723]                   NAME <- NAMES[[kk]]
[10:29:49.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.723]                     next
[10:29:49.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.723]                 }
[10:29:49.723]                 if (length(args) > 0) 
[10:29:49.723]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.723]             }
[10:29:49.723]             else {
[10:29:49.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.723]             }
[10:29:49.723]             {
[10:29:49.723]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.723]                   0L) {
[10:29:49.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.723]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.723]                   base::options(opts)
[10:29:49.723]                 }
[10:29:49.723]                 {
[10:29:49.723]                   {
[10:29:49.723]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.723]                     NULL
[10:29:49.723]                   }
[10:29:49.723]                   options(future.plan = NULL)
[10:29:49.723]                   if (is.na(NA_character_)) 
[10:29:49.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.723]                     .init = FALSE)
[10:29:49.723]                 }
[10:29:49.723]             }
[10:29:49.723]         }
[10:29:49.723]     })
[10:29:49.723]     if (TRUE) {
[10:29:49.723]         base::sink(type = "output", split = FALSE)
[10:29:49.723]         if (TRUE) {
[10:29:49.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.723]         }
[10:29:49.723]         else {
[10:29:49.723]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.723]         }
[10:29:49.723]         base::close(...future.stdout)
[10:29:49.723]         ...future.stdout <- NULL
[10:29:49.723]     }
[10:29:49.723]     ...future.result$conditions <- ...future.conditions
[10:29:49.723]     ...future.result$finished <- base::Sys.time()
[10:29:49.723]     ...future.result
[10:29:49.723] }
[10:29:49.725] assign_globals() ...
[10:29:49.725] List of 5
[10:29:49.725]  $ future.call.arguments    : list()
[10:29:49.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.725]  $ ...future.FUN            :function (x)  
[10:29:49.725]  $ ...future.elements_ii    :List of 1
[10:29:49.725]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[10:29:49.725]  $ ...future.seeds_ii       : NULL
[10:29:49.725]  $ ...future.globals.maxSize: num Inf
[10:29:49.725]  - attr(*, "resolved")= logi FALSE
[10:29:49.725]  - attr(*, "total_size")= num NA
[10:29:49.725]  - attr(*, "where")=List of 5
[10:29:49.725]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.725]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.725]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.725]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.725]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.725]  - attr(*, "already-done")= logi TRUE
[10:29:49.730] - copied ‘future.call.arguments’ to environment
[10:29:49.730] - copied ‘...future.FUN’ to environment
[10:29:49.730] - copied ‘...future.elements_ii’ to environment
[10:29:49.730] - copied ‘...future.seeds_ii’ to environment
[10:29:49.730] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.730] assign_globals() ... done
[10:29:49.730] requestCore(): workers = 2
[10:29:49.733] MulticoreFuture started
[10:29:49.733] - Launch lazy future ... done
[10:29:49.733] run() for ‘MulticoreFuture’ ... done
[10:29:49.734] Created future:
[10:29:49.734] plan(): Setting new future strategy stack:
[10:29:49.734] List of future strategies:
[10:29:49.734] 1. sequential:
[10:29:49.734]    - args: function (..., envir = parent.frame())
[10:29:49.734]    - tweaked: FALSE
[10:29:49.734]    - call: NULL
[10:29:49.735] plan(): nbrOfWorkers() = 1
[10:29:49.737] plan(): Setting new future strategy stack:
[10:29:49.737] List of future strategies:
[10:29:49.737] 1. multicore:
[10:29:49.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.737]    - tweaked: FALSE
[10:29:49.737]    - call: plan(strategy)
[10:29:49.742] plan(): nbrOfWorkers() = 2
[10:29:49.734] MulticoreFuture:
[10:29:49.734] Label: ‘future_apply-1’
[10:29:49.734] Expression:
[10:29:49.734] {
[10:29:49.734]     do.call(function(...) {
[10:29:49.734]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.734]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.734]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.734]             on.exit(options(oopts), add = TRUE)
[10:29:49.734]         }
[10:29:49.734]         {
[10:29:49.734]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.734]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.734]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.734]             })
[10:29:49.734]         }
[10:29:49.734]     }, args = future.call.arguments)
[10:29:49.734] }
[10:29:49.734] Lazy evaluation: FALSE
[10:29:49.734] Asynchronous evaluation: TRUE
[10:29:49.734] Local evaluation: TRUE
[10:29:49.734] Environment: R_GlobalEnv
[10:29:49.734] Capture standard output: TRUE
[10:29:49.734] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.734] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.734] Packages: <none>
[10:29:49.734] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.734] Resolved: TRUE
[10:29:49.734] Value: <not collected>
[10:29:49.734] Conditions captured: <none>
[10:29:49.734] Early signaling: FALSE
[10:29:49.734] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.734] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.743] Chunk #1 of 2 ... DONE
[10:29:49.743] Chunk #2 of 2 ...
[10:29:49.744]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.744]  - seeds: <none>
[10:29:49.744]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.744] getGlobalsAndPackages() ...
[10:29:49.744] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.744] Resolving globals: FALSE
[10:29:49.745] Tweak future expression to call with '...' arguments ...
[10:29:49.745] {
[10:29:49.745]     do.call(function(...) {
[10:29:49.745]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.745]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.745]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.745]             on.exit(options(oopts), add = TRUE)
[10:29:49.745]         }
[10:29:49.745]         {
[10:29:49.745]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.745]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.745]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.745]             })
[10:29:49.745]         }
[10:29:49.745]     }, args = future.call.arguments)
[10:29:49.745] }
[10:29:49.745] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.746] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.746] 
[10:29:49.746] getGlobalsAndPackages() ... DONE
[10:29:49.747] run() for ‘Future’ ...
[10:29:49.747] - state: ‘created’
[10:29:49.747] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.752] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.752]   - Field: ‘label’
[10:29:49.752]   - Field: ‘local’
[10:29:49.752]   - Field: ‘owner’
[10:29:49.753]   - Field: ‘envir’
[10:29:49.753]   - Field: ‘workers’
[10:29:49.753]   - Field: ‘packages’
[10:29:49.753]   - Field: ‘gc’
[10:29:49.753]   - Field: ‘job’
[10:29:49.756]   - Field: ‘conditions’
[10:29:49.757]   - Field: ‘expr’
[10:29:49.757]   - Field: ‘uuid’
[10:29:49.758]   - Field: ‘seed’
[10:29:49.758]   - Field: ‘version’
[10:29:49.758]   - Field: ‘result’
[10:29:49.759]   - Field: ‘asynchronous’
[10:29:49.759]   - Field: ‘calls’
[10:29:49.759]   - Field: ‘globals’
[10:29:49.759]   - Field: ‘stdout’
[10:29:49.760]   - Field: ‘earlySignal’
[10:29:49.760]   - Field: ‘lazy’
[10:29:49.760]   - Field: ‘state’
[10:29:49.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.761] - Launch lazy future ...
[10:29:49.761] Packages needed by the future expression (n = 0): <none>
[10:29:49.762] Packages needed by future strategies (n = 0): <none>
[10:29:49.763] {
[10:29:49.763]     {
[10:29:49.763]         {
[10:29:49.763]             ...future.startTime <- base::Sys.time()
[10:29:49.763]             {
[10:29:49.763]                 {
[10:29:49.763]                   {
[10:29:49.763]                     {
[10:29:49.763]                       base::local({
[10:29:49.763]                         has_future <- base::requireNamespace("future", 
[10:29:49.763]                           quietly = TRUE)
[10:29:49.763]                         if (has_future) {
[10:29:49.763]                           ns <- base::getNamespace("future")
[10:29:49.763]                           version <- ns[[".package"]][["version"]]
[10:29:49.763]                           if (is.null(version)) 
[10:29:49.763]                             version <- utils::packageVersion("future")
[10:29:49.763]                         }
[10:29:49.763]                         else {
[10:29:49.763]                           version <- NULL
[10:29:49.763]                         }
[10:29:49.763]                         if (!has_future || version < "1.8.0") {
[10:29:49.763]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.763]                             "", base::R.version$version.string), 
[10:29:49.763]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.763]                               "release", "version")], collapse = " "), 
[10:29:49.763]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.763]                             info)
[10:29:49.763]                           info <- base::paste(info, collapse = "; ")
[10:29:49.763]                           if (!has_future) {
[10:29:49.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.763]                               info)
[10:29:49.763]                           }
[10:29:49.763]                           else {
[10:29:49.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.763]                               info, version)
[10:29:49.763]                           }
[10:29:49.763]                           base::stop(msg)
[10:29:49.763]                         }
[10:29:49.763]                       })
[10:29:49.763]                     }
[10:29:49.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.763]                     base::options(mc.cores = 1L)
[10:29:49.763]                   }
[10:29:49.763]                   ...future.strategy.old <- future::plan("list")
[10:29:49.763]                   options(future.plan = NULL)
[10:29:49.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.763]                 }
[10:29:49.763]                 ...future.workdir <- getwd()
[10:29:49.763]             }
[10:29:49.763]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.763]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.763]         }
[10:29:49.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.763]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.763]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.763]             base::names(...future.oldOptions))
[10:29:49.763]     }
[10:29:49.763]     if (FALSE) {
[10:29:49.763]     }
[10:29:49.763]     else {
[10:29:49.763]         if (TRUE) {
[10:29:49.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.763]                 open = "w")
[10:29:49.763]         }
[10:29:49.763]         else {
[10:29:49.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.763]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.763]         }
[10:29:49.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.763]             base::sink(type = "output", split = FALSE)
[10:29:49.763]             base::close(...future.stdout)
[10:29:49.763]         }, add = TRUE)
[10:29:49.763]     }
[10:29:49.763]     ...future.frame <- base::sys.nframe()
[10:29:49.763]     ...future.conditions <- base::list()
[10:29:49.763]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.763]     if (FALSE) {
[10:29:49.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.763]     }
[10:29:49.763]     ...future.result <- base::tryCatch({
[10:29:49.763]         base::withCallingHandlers({
[10:29:49.763]             ...future.value <- base::withVisible(base::local({
[10:29:49.763]                 withCallingHandlers({
[10:29:49.763]                   {
[10:29:49.763]                     do.call(function(...) {
[10:29:49.763]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.763]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.763]                         ...future.globals.maxSize)) {
[10:29:49.763]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.763]                         on.exit(options(oopts), add = TRUE)
[10:29:49.763]                       }
[10:29:49.763]                       {
[10:29:49.763]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.763]                           FUN = function(jj) {
[10:29:49.763]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.763]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.763]                           })
[10:29:49.763]                       }
[10:29:49.763]                     }, args = future.call.arguments)
[10:29:49.763]                   }
[10:29:49.763]                 }, immediateCondition = function(cond) {
[10:29:49.763]                   save_rds <- function (object, pathname, ...) 
[10:29:49.763]                   {
[10:29:49.763]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.763]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.763]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.763]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.763]                         fi_tmp[["mtime"]])
[10:29:49.763]                     }
[10:29:49.763]                     tryCatch({
[10:29:49.763]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.763]                     }, error = function(ex) {
[10:29:49.763]                       msg <- conditionMessage(ex)
[10:29:49.763]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.763]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.763]                         fi_tmp[["mtime"]], msg)
[10:29:49.763]                       ex$message <- msg
[10:29:49.763]                       stop(ex)
[10:29:49.763]                     })
[10:29:49.763]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.763]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.763]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.763]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.763]                       fi <- file.info(pathname)
[10:29:49.763]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.763]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.763]                         fi[["size"]], fi[["mtime"]])
[10:29:49.763]                       stop(msg)
[10:29:49.763]                     }
[10:29:49.763]                     invisible(pathname)
[10:29:49.763]                   }
[10:29:49.763]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.763]                     rootPath = tempdir()) 
[10:29:49.763]                   {
[10:29:49.763]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.763]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.763]                       tmpdir = path, fileext = ".rds")
[10:29:49.763]                     save_rds(obj, file)
[10:29:49.763]                   }
[10:29:49.763]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.763]                   {
[10:29:49.763]                     inherits <- base::inherits
[10:29:49.763]                     invokeRestart <- base::invokeRestart
[10:29:49.763]                     is.null <- base::is.null
[10:29:49.763]                     muffled <- FALSE
[10:29:49.763]                     if (inherits(cond, "message")) {
[10:29:49.763]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.763]                       if (muffled) 
[10:29:49.763]                         invokeRestart("muffleMessage")
[10:29:49.763]                     }
[10:29:49.763]                     else if (inherits(cond, "warning")) {
[10:29:49.763]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.763]                       if (muffled) 
[10:29:49.763]                         invokeRestart("muffleWarning")
[10:29:49.763]                     }
[10:29:49.763]                     else if (inherits(cond, "condition")) {
[10:29:49.763]                       if (!is.null(pattern)) {
[10:29:49.763]                         computeRestarts <- base::computeRestarts
[10:29:49.763]                         grepl <- base::grepl
[10:29:49.763]                         restarts <- computeRestarts(cond)
[10:29:49.763]                         for (restart in restarts) {
[10:29:49.763]                           name <- restart$name
[10:29:49.763]                           if (is.null(name)) 
[10:29:49.763]                             next
[10:29:49.763]                           if (!grepl(pattern, name)) 
[10:29:49.763]                             next
[10:29:49.763]                           invokeRestart(restart)
[10:29:49.763]                           muffled <- TRUE
[10:29:49.763]                           break
[10:29:49.763]                         }
[10:29:49.763]                       }
[10:29:49.763]                     }
[10:29:49.763]                     invisible(muffled)
[10:29:49.763]                   }
[10:29:49.763]                   muffleCondition(cond)
[10:29:49.763]                 })
[10:29:49.763]             }))
[10:29:49.763]             future::FutureResult(value = ...future.value$value, 
[10:29:49.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.763]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.763]                     ...future.globalenv.names))
[10:29:49.763]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.763]         }, condition = base::local({
[10:29:49.763]             c <- base::c
[10:29:49.763]             inherits <- base::inherits
[10:29:49.763]             invokeRestart <- base::invokeRestart
[10:29:49.763]             length <- base::length
[10:29:49.763]             list <- base::list
[10:29:49.763]             seq.int <- base::seq.int
[10:29:49.763]             signalCondition <- base::signalCondition
[10:29:49.763]             sys.calls <- base::sys.calls
[10:29:49.763]             `[[` <- base::`[[`
[10:29:49.763]             `+` <- base::`+`
[10:29:49.763]             `<<-` <- base::`<<-`
[10:29:49.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.763]                   3L)]
[10:29:49.763]             }
[10:29:49.763]             function(cond) {
[10:29:49.763]                 is_error <- inherits(cond, "error")
[10:29:49.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.763]                   NULL)
[10:29:49.763]                 if (is_error) {
[10:29:49.763]                   sessionInformation <- function() {
[10:29:49.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.763]                       search = base::search(), system = base::Sys.info())
[10:29:49.763]                   }
[10:29:49.763]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.763]                     cond$call), session = sessionInformation(), 
[10:29:49.763]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.763]                   signalCondition(cond)
[10:29:49.763]                 }
[10:29:49.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.763]                 "immediateCondition"))) {
[10:29:49.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.763]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.763]                   if (TRUE && !signal) {
[10:29:49.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.763]                     {
[10:29:49.763]                       inherits <- base::inherits
[10:29:49.763]                       invokeRestart <- base::invokeRestart
[10:29:49.763]                       is.null <- base::is.null
[10:29:49.763]                       muffled <- FALSE
[10:29:49.763]                       if (inherits(cond, "message")) {
[10:29:49.763]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.763]                         if (muffled) 
[10:29:49.763]                           invokeRestart("muffleMessage")
[10:29:49.763]                       }
[10:29:49.763]                       else if (inherits(cond, "warning")) {
[10:29:49.763]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.763]                         if (muffled) 
[10:29:49.763]                           invokeRestart("muffleWarning")
[10:29:49.763]                       }
[10:29:49.763]                       else if (inherits(cond, "condition")) {
[10:29:49.763]                         if (!is.null(pattern)) {
[10:29:49.763]                           computeRestarts <- base::computeRestarts
[10:29:49.763]                           grepl <- base::grepl
[10:29:49.763]                           restarts <- computeRestarts(cond)
[10:29:49.763]                           for (restart in restarts) {
[10:29:49.763]                             name <- restart$name
[10:29:49.763]                             if (is.null(name)) 
[10:29:49.763]                               next
[10:29:49.763]                             if (!grepl(pattern, name)) 
[10:29:49.763]                               next
[10:29:49.763]                             invokeRestart(restart)
[10:29:49.763]                             muffled <- TRUE
[10:29:49.763]                             break
[10:29:49.763]                           }
[10:29:49.763]                         }
[10:29:49.763]                       }
[10:29:49.763]                       invisible(muffled)
[10:29:49.763]                     }
[10:29:49.763]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.763]                   }
[10:29:49.763]                 }
[10:29:49.763]                 else {
[10:29:49.763]                   if (TRUE) {
[10:29:49.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.763]                     {
[10:29:49.763]                       inherits <- base::inherits
[10:29:49.763]                       invokeRestart <- base::invokeRestart
[10:29:49.763]                       is.null <- base::is.null
[10:29:49.763]                       muffled <- FALSE
[10:29:49.763]                       if (inherits(cond, "message")) {
[10:29:49.763]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.763]                         if (muffled) 
[10:29:49.763]                           invokeRestart("muffleMessage")
[10:29:49.763]                       }
[10:29:49.763]                       else if (inherits(cond, "warning")) {
[10:29:49.763]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.763]                         if (muffled) 
[10:29:49.763]                           invokeRestart("muffleWarning")
[10:29:49.763]                       }
[10:29:49.763]                       else if (inherits(cond, "condition")) {
[10:29:49.763]                         if (!is.null(pattern)) {
[10:29:49.763]                           computeRestarts <- base::computeRestarts
[10:29:49.763]                           grepl <- base::grepl
[10:29:49.763]                           restarts <- computeRestarts(cond)
[10:29:49.763]                           for (restart in restarts) {
[10:29:49.763]                             name <- restart$name
[10:29:49.763]                             if (is.null(name)) 
[10:29:49.763]                               next
[10:29:49.763]                             if (!grepl(pattern, name)) 
[10:29:49.763]                               next
[10:29:49.763]                             invokeRestart(restart)
[10:29:49.763]                             muffled <- TRUE
[10:29:49.763]                             break
[10:29:49.763]                           }
[10:29:49.763]                         }
[10:29:49.763]                       }
[10:29:49.763]                       invisible(muffled)
[10:29:49.763]                     }
[10:29:49.763]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.763]                   }
[10:29:49.763]                 }
[10:29:49.763]             }
[10:29:49.763]         }))
[10:29:49.763]     }, error = function(ex) {
[10:29:49.763]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.763]                 ...future.rng), started = ...future.startTime, 
[10:29:49.763]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.763]             version = "1.8"), class = "FutureResult")
[10:29:49.763]     }, finally = {
[10:29:49.763]         if (!identical(...future.workdir, getwd())) 
[10:29:49.763]             setwd(...future.workdir)
[10:29:49.763]         {
[10:29:49.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.763]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.763]             }
[10:29:49.763]             base::options(...future.oldOptions)
[10:29:49.763]             if (.Platform$OS.type == "windows") {
[10:29:49.763]                 old_names <- names(...future.oldEnvVars)
[10:29:49.763]                 envs <- base::Sys.getenv()
[10:29:49.763]                 names <- names(envs)
[10:29:49.763]                 common <- intersect(names, old_names)
[10:29:49.763]                 added <- setdiff(names, old_names)
[10:29:49.763]                 removed <- setdiff(old_names, names)
[10:29:49.763]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.763]                   envs[common]]
[10:29:49.763]                 NAMES <- toupper(changed)
[10:29:49.763]                 args <- list()
[10:29:49.763]                 for (kk in seq_along(NAMES)) {
[10:29:49.763]                   name <- changed[[kk]]
[10:29:49.763]                   NAME <- NAMES[[kk]]
[10:29:49.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.763]                     next
[10:29:49.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.763]                 }
[10:29:49.763]                 NAMES <- toupper(added)
[10:29:49.763]                 for (kk in seq_along(NAMES)) {
[10:29:49.763]                   name <- added[[kk]]
[10:29:49.763]                   NAME <- NAMES[[kk]]
[10:29:49.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.763]                     next
[10:29:49.763]                   args[[name]] <- ""
[10:29:49.763]                 }
[10:29:49.763]                 NAMES <- toupper(removed)
[10:29:49.763]                 for (kk in seq_along(NAMES)) {
[10:29:49.763]                   name <- removed[[kk]]
[10:29:49.763]                   NAME <- NAMES[[kk]]
[10:29:49.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.763]                     next
[10:29:49.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.763]                 }
[10:29:49.763]                 if (length(args) > 0) 
[10:29:49.763]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.763]             }
[10:29:49.763]             else {
[10:29:49.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.763]             }
[10:29:49.763]             {
[10:29:49.763]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.763]                   0L) {
[10:29:49.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.763]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.763]                   base::options(opts)
[10:29:49.763]                 }
[10:29:49.763]                 {
[10:29:49.763]                   {
[10:29:49.763]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.763]                     NULL
[10:29:49.763]                   }
[10:29:49.763]                   options(future.plan = NULL)
[10:29:49.763]                   if (is.na(NA_character_)) 
[10:29:49.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.763]                     .init = FALSE)
[10:29:49.763]                 }
[10:29:49.763]             }
[10:29:49.763]         }
[10:29:49.763]     })
[10:29:49.763]     if (TRUE) {
[10:29:49.763]         base::sink(type = "output", split = FALSE)
[10:29:49.763]         if (TRUE) {
[10:29:49.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.763]         }
[10:29:49.763]         else {
[10:29:49.763]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.763]         }
[10:29:49.763]         base::close(...future.stdout)
[10:29:49.763]         ...future.stdout <- NULL
[10:29:49.763]     }
[10:29:49.763]     ...future.result$conditions <- ...future.conditions
[10:29:49.763]     ...future.result$finished <- base::Sys.time()
[10:29:49.763]     ...future.result
[10:29:49.763] }
[10:29:49.766] assign_globals() ...
[10:29:49.766] List of 5
[10:29:49.766]  $ future.call.arguments    : list()
[10:29:49.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.766]  $ ...future.FUN            :function (x)  
[10:29:49.766]  $ ...future.elements_ii    :List of 1
[10:29:49.766]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[10:29:49.766]  $ ...future.seeds_ii       : NULL
[10:29:49.766]  $ ...future.globals.maxSize: num Inf
[10:29:49.766]  - attr(*, "resolved")= logi FALSE
[10:29:49.766]  - attr(*, "total_size")= num NA
[10:29:49.766]  - attr(*, "where")=List of 5
[10:29:49.766]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.766]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.766]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.766]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.766]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.766]  - attr(*, "already-done")= logi TRUE
[10:29:49.774] - copied ‘future.call.arguments’ to environment
[10:29:49.774] - copied ‘...future.FUN’ to environment
[10:29:49.774] - copied ‘...future.elements_ii’ to environment
[10:29:49.774] - copied ‘...future.seeds_ii’ to environment
[10:29:49.774] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.775] assign_globals() ... done
[10:29:49.775] requestCore(): workers = 2
[10:29:49.777] MulticoreFuture started
[10:29:49.777] - Launch lazy future ... done
[10:29:49.778] run() for ‘MulticoreFuture’ ... done
[10:29:49.778] Created future:
[10:29:49.778] plan(): Setting new future strategy stack:
[10:29:49.779] List of future strategies:
[10:29:49.779] 1. sequential:
[10:29:49.779]    - args: function (..., envir = parent.frame())
[10:29:49.779]    - tweaked: FALSE
[10:29:49.779]    - call: NULL
[10:29:49.779] plan(): nbrOfWorkers() = 1
[10:29:49.781] plan(): Setting new future strategy stack:
[10:29:49.782] List of future strategies:
[10:29:49.782] 1. multicore:
[10:29:49.782]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.782]    - tweaked: FALSE
[10:29:49.782]    - call: plan(strategy)
[10:29:49.787] plan(): nbrOfWorkers() = 2
[10:29:49.778] MulticoreFuture:
[10:29:49.778] Label: ‘future_apply-2’
[10:29:49.778] Expression:
[10:29:49.778] {
[10:29:49.778]     do.call(function(...) {
[10:29:49.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.778]             on.exit(options(oopts), add = TRUE)
[10:29:49.778]         }
[10:29:49.778]         {
[10:29:49.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.778]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.778]             })
[10:29:49.778]         }
[10:29:49.778]     }, args = future.call.arguments)
[10:29:49.778] }
[10:29:49.778] Lazy evaluation: FALSE
[10:29:49.778] Asynchronous evaluation: TRUE
[10:29:49.778] Local evaluation: TRUE
[10:29:49.778] Environment: R_GlobalEnv
[10:29:49.778] Capture standard output: TRUE
[10:29:49.778] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.778] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.778] Packages: <none>
[10:29:49.778] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.778] Resolved: TRUE
[10:29:49.778] Value: <not collected>
[10:29:49.778] Conditions captured: <none>
[10:29:49.778] Early signaling: FALSE
[10:29:49.778] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.778] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.788] Chunk #2 of 2 ... DONE
[10:29:49.788] Launching 2 futures (chunks) ... DONE
[10:29:49.788] Resolving 2 futures (chunks) ...
[10:29:49.789] resolve() on list ...
[10:29:49.789]  recursive: 0
[10:29:49.789]  length: 2
[10:29:49.789] 
[10:29:49.790] Future #1
[10:29:49.790] result() for MulticoreFuture ...
[10:29:49.791] result() for MulticoreFuture ...
[10:29:49.791] result() for MulticoreFuture ... done
[10:29:49.791] result() for MulticoreFuture ... done
[10:29:49.791] result() for MulticoreFuture ...
[10:29:49.791] result() for MulticoreFuture ... done
[10:29:49.791] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:49.792] - nx: 2
[10:29:49.792] - relay: TRUE
[10:29:49.792] - stdout: TRUE
[10:29:49.792] - signal: TRUE
[10:29:49.792] - resignal: FALSE
[10:29:49.792] - force: TRUE
[10:29:49.792] - relayed: [n=2] FALSE, FALSE
[10:29:49.793] - queued futures: [n=2] FALSE, FALSE
[10:29:49.793]  - until=1
[10:29:49.793]  - relaying element #1
[10:29:49.793] result() for MulticoreFuture ...
[10:29:49.793] result() for MulticoreFuture ... done
[10:29:49.793] result() for MulticoreFuture ...
[10:29:49.794] result() for MulticoreFuture ... done
[10:29:49.794] result() for MulticoreFuture ...
[10:29:49.794] result() for MulticoreFuture ... done
[10:29:49.794] result() for MulticoreFuture ...
[10:29:49.794] result() for MulticoreFuture ... done
[10:29:49.794] - relayed: [n=2] TRUE, FALSE
[10:29:49.795] - queued futures: [n=2] TRUE, FALSE
[10:29:49.795] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:49.795]  length: 1 (resolved future 1)
[10:29:49.795] Future #2
[10:29:49.795] result() for MulticoreFuture ...
[10:29:49.796] result() for MulticoreFuture ...
[10:29:49.796] result() for MulticoreFuture ... done
[10:29:49.796] result() for MulticoreFuture ... done
[10:29:49.797] result() for MulticoreFuture ...
[10:29:49.797] result() for MulticoreFuture ... done
[10:29:49.797] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:49.797] - nx: 2
[10:29:49.797] - relay: TRUE
[10:29:49.797] - stdout: TRUE
[10:29:49.797] - signal: TRUE
[10:29:49.797] - resignal: FALSE
[10:29:49.798] - force: TRUE
[10:29:49.798] - relayed: [n=2] TRUE, FALSE
[10:29:49.798] - queued futures: [n=2] TRUE, FALSE
[10:29:49.798]  - until=2
[10:29:49.798]  - relaying element #2
[10:29:49.798] result() for MulticoreFuture ...
[10:29:49.798] result() for MulticoreFuture ... done
[10:29:49.798] result() for MulticoreFuture ...
[10:29:49.799] result() for MulticoreFuture ... done
[10:29:49.799] result() for MulticoreFuture ...
[10:29:49.799] result() for MulticoreFuture ... done
[10:29:49.799] result() for MulticoreFuture ...
[10:29:49.799] result() for MulticoreFuture ... done
[10:29:49.799] - relayed: [n=2] TRUE, TRUE
[10:29:49.799] - queued futures: [n=2] TRUE, TRUE
[10:29:49.799] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:49.800]  length: 0 (resolved future 2)
[10:29:49.800] Relaying remaining futures
[10:29:49.800] signalConditionsASAP(NULL, pos=0) ...
[10:29:49.800] - nx: 2
[10:29:49.800] - relay: TRUE
[10:29:49.800] - stdout: TRUE
[10:29:49.800] - signal: TRUE
[10:29:49.800] - resignal: FALSE
[10:29:49.800] - force: TRUE
[10:29:49.800] - relayed: [n=2] TRUE, TRUE
[10:29:49.801] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:49.801] - relayed: [n=2] TRUE, TRUE
[10:29:49.801] - queued futures: [n=2] TRUE, TRUE
[10:29:49.801] signalConditionsASAP(NULL, pos=0) ... done
[10:29:49.804] resolve() on list ... DONE
[10:29:49.804] result() for MulticoreFuture ...
[10:29:49.804] result() for MulticoreFuture ... done
[10:29:49.804] result() for MulticoreFuture ...
[10:29:49.804] result() for MulticoreFuture ... done
[10:29:49.805] result() for MulticoreFuture ...
[10:29:49.805] result() for MulticoreFuture ... done
[10:29:49.805] result() for MulticoreFuture ...
[10:29:49.805] result() for MulticoreFuture ... done
[10:29:49.805]  - Number of value chunks collected: 2
[10:29:49.806] Resolving 2 futures (chunks) ... DONE
[10:29:49.806] Reducing values from 2 chunks ...
[10:29:49.806]  - Number of values collected after concatenation: 2
[10:29:49.806]  - Number of values expected: 2
[10:29:49.806] Reducing values from 2 chunks ... DONE
[10:29:49.806] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:29:49.807] getGlobalsAndPackagesXApply() ...
[10:29:49.807]  - future.globals: TRUE
[10:29:49.807] getGlobalsAndPackages() ...
[10:29:49.807] Searching for globals...
[10:29:49.811] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:29:49.811] Searching for globals ... DONE
[10:29:49.811] Resolving globals: FALSE
[10:29:49.812] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[10:29:49.812] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[10:29:49.812] - globals: [1] ‘FUN’
[10:29:49.813] 
[10:29:49.813] getGlobalsAndPackages() ... DONE
[10:29:49.813]  - globals found/used: [n=1] ‘FUN’
[10:29:49.813]  - needed namespaces: [n=0] 
[10:29:49.813] Finding globals ... DONE
[10:29:49.813]  - use_args: TRUE
[10:29:49.813]  - Getting '...' globals ...
[10:29:49.814] resolve() on list ...
[10:29:49.814]  recursive: 0
[10:29:49.814]  length: 1
[10:29:49.814]  elements: ‘...’
[10:29:49.814]  length: 0 (resolved future 1)
[10:29:49.814] resolve() on list ... DONE
[10:29:49.814]    - '...' content: [n=0] 
[10:29:49.814] List of 1
[10:29:49.814]  $ ...: list()
[10:29:49.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.814]  - attr(*, "where")=List of 1
[10:29:49.814]   ..$ ...:<environment: 0x5618a1cf35c8> 
[10:29:49.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.814]  - attr(*, "resolved")= logi TRUE
[10:29:49.814]  - attr(*, "total_size")= num NA
[10:29:49.817]  - Getting '...' globals ... DONE
[10:29:49.817] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:49.818] List of 2
[10:29:49.818]  $ ...future.FUN:function (x)  
[10:29:49.818]  $ ...          : list()
[10:29:49.818]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.818]  - attr(*, "where")=List of 2
[10:29:49.818]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:49.818]   ..$ ...          :<environment: 0x5618a1cf35c8> 
[10:29:49.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.818]  - attr(*, "resolved")= logi FALSE
[10:29:49.818]  - attr(*, "total_size")= num 9888
[10:29:49.820] Packages to be attached in all futures: [n=0] 
[10:29:49.820] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.824] future_lapply() ...
[10:29:49.828] Number of chunks: 2
[10:29:49.829] getGlobalsAndPackagesXApply() ...
[10:29:49.829]  - future.globals: <name-value list> with names ‘list()’
[10:29:49.829]  - use_args: TRUE
[10:29:49.829] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:49.829] List of 2
[10:29:49.829]  $ ...          : list()
[10:29:49.829]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.829]  $ ...future.FUN:function (x)  
[10:29:49.829]  - attr(*, "where")=List of 2
[10:29:49.829]   ..$ ...          :<environment: 0x5618a1cf35c8> 
[10:29:49.829]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:29:49.829]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.829]  - attr(*, "resolved")= logi FALSE
[10:29:49.829]  - attr(*, "total_size")= num NA
[10:29:49.834] Packages to be attached in all futures: [n=0] 
[10:29:49.834] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.834] Number of futures (= number of chunks): 2
[10:29:49.834] Launching 2 futures (chunks) ...
[10:29:49.834] Chunk #1 of 2 ...
[10:29:49.835]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.835]  - seeds: <none>
[10:29:49.835]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.835] getGlobalsAndPackages() ...
[10:29:49.835] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.835] Resolving globals: FALSE
[10:29:49.835] Tweak future expression to call with '...' arguments ...
[10:29:49.835] {
[10:29:49.835]     do.call(function(...) {
[10:29:49.835]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.835]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.835]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.835]             on.exit(options(oopts), add = TRUE)
[10:29:49.835]         }
[10:29:49.835]         {
[10:29:49.835]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.835]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.835]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.835]             })
[10:29:49.835]         }
[10:29:49.835]     }, args = future.call.arguments)
[10:29:49.835] }
[10:29:49.836] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.836] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.836] 
[10:29:49.836] getGlobalsAndPackages() ... DONE
[10:29:49.836] run() for ‘Future’ ...
[10:29:49.837] - state: ‘created’
[10:29:49.837] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.840] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.840] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.840]   - Field: ‘label’
[10:29:49.841]   - Field: ‘local’
[10:29:49.841]   - Field: ‘owner’
[10:29:49.841]   - Field: ‘envir’
[10:29:49.841]   - Field: ‘workers’
[10:29:49.841]   - Field: ‘packages’
[10:29:49.841]   - Field: ‘gc’
[10:29:49.841]   - Field: ‘job’
[10:29:49.841]   - Field: ‘conditions’
[10:29:49.841]   - Field: ‘expr’
[10:29:49.841]   - Field: ‘uuid’
[10:29:49.842]   - Field: ‘seed’
[10:29:49.842]   - Field: ‘version’
[10:29:49.842]   - Field: ‘result’
[10:29:49.842]   - Field: ‘asynchronous’
[10:29:49.842]   - Field: ‘calls’
[10:29:49.842]   - Field: ‘globals’
[10:29:49.842]   - Field: ‘stdout’
[10:29:49.842]   - Field: ‘earlySignal’
[10:29:49.842]   - Field: ‘lazy’
[10:29:49.842]   - Field: ‘state’
[10:29:49.842] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.843] - Launch lazy future ...
[10:29:49.843] Packages needed by the future expression (n = 0): <none>
[10:29:49.843] Packages needed by future strategies (n = 0): <none>
[10:29:49.843] {
[10:29:49.843]     {
[10:29:49.843]         {
[10:29:49.843]             ...future.startTime <- base::Sys.time()
[10:29:49.843]             {
[10:29:49.843]                 {
[10:29:49.843]                   {
[10:29:49.843]                     {
[10:29:49.843]                       base::local({
[10:29:49.843]                         has_future <- base::requireNamespace("future", 
[10:29:49.843]                           quietly = TRUE)
[10:29:49.843]                         if (has_future) {
[10:29:49.843]                           ns <- base::getNamespace("future")
[10:29:49.843]                           version <- ns[[".package"]][["version"]]
[10:29:49.843]                           if (is.null(version)) 
[10:29:49.843]                             version <- utils::packageVersion("future")
[10:29:49.843]                         }
[10:29:49.843]                         else {
[10:29:49.843]                           version <- NULL
[10:29:49.843]                         }
[10:29:49.843]                         if (!has_future || version < "1.8.0") {
[10:29:49.843]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.843]                             "", base::R.version$version.string), 
[10:29:49.843]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.843]                               "release", "version")], collapse = " "), 
[10:29:49.843]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.843]                             info)
[10:29:49.843]                           info <- base::paste(info, collapse = "; ")
[10:29:49.843]                           if (!has_future) {
[10:29:49.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.843]                               info)
[10:29:49.843]                           }
[10:29:49.843]                           else {
[10:29:49.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.843]                               info, version)
[10:29:49.843]                           }
[10:29:49.843]                           base::stop(msg)
[10:29:49.843]                         }
[10:29:49.843]                       })
[10:29:49.843]                     }
[10:29:49.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.843]                     base::options(mc.cores = 1L)
[10:29:49.843]                   }
[10:29:49.843]                   ...future.strategy.old <- future::plan("list")
[10:29:49.843]                   options(future.plan = NULL)
[10:29:49.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.843]                 }
[10:29:49.843]                 ...future.workdir <- getwd()
[10:29:49.843]             }
[10:29:49.843]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.843]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.843]         }
[10:29:49.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.843]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.843]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.843]             base::names(...future.oldOptions))
[10:29:49.843]     }
[10:29:49.843]     if (FALSE) {
[10:29:49.843]     }
[10:29:49.843]     else {
[10:29:49.843]         if (TRUE) {
[10:29:49.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.843]                 open = "w")
[10:29:49.843]         }
[10:29:49.843]         else {
[10:29:49.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.843]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.843]         }
[10:29:49.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.843]             base::sink(type = "output", split = FALSE)
[10:29:49.843]             base::close(...future.stdout)
[10:29:49.843]         }, add = TRUE)
[10:29:49.843]     }
[10:29:49.843]     ...future.frame <- base::sys.nframe()
[10:29:49.843]     ...future.conditions <- base::list()
[10:29:49.843]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.843]     if (FALSE) {
[10:29:49.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.843]     }
[10:29:49.843]     ...future.result <- base::tryCatch({
[10:29:49.843]         base::withCallingHandlers({
[10:29:49.843]             ...future.value <- base::withVisible(base::local({
[10:29:49.843]                 withCallingHandlers({
[10:29:49.843]                   {
[10:29:49.843]                     do.call(function(...) {
[10:29:49.843]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.843]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.843]                         ...future.globals.maxSize)) {
[10:29:49.843]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.843]                         on.exit(options(oopts), add = TRUE)
[10:29:49.843]                       }
[10:29:49.843]                       {
[10:29:49.843]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.843]                           FUN = function(jj) {
[10:29:49.843]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.843]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.843]                           })
[10:29:49.843]                       }
[10:29:49.843]                     }, args = future.call.arguments)
[10:29:49.843]                   }
[10:29:49.843]                 }, immediateCondition = function(cond) {
[10:29:49.843]                   save_rds <- function (object, pathname, ...) 
[10:29:49.843]                   {
[10:29:49.843]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.843]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.843]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.843]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.843]                         fi_tmp[["mtime"]])
[10:29:49.843]                     }
[10:29:49.843]                     tryCatch({
[10:29:49.843]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.843]                     }, error = function(ex) {
[10:29:49.843]                       msg <- conditionMessage(ex)
[10:29:49.843]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.843]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.843]                         fi_tmp[["mtime"]], msg)
[10:29:49.843]                       ex$message <- msg
[10:29:49.843]                       stop(ex)
[10:29:49.843]                     })
[10:29:49.843]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.843]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.843]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.843]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.843]                       fi <- file.info(pathname)
[10:29:49.843]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.843]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.843]                         fi[["size"]], fi[["mtime"]])
[10:29:49.843]                       stop(msg)
[10:29:49.843]                     }
[10:29:49.843]                     invisible(pathname)
[10:29:49.843]                   }
[10:29:49.843]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.843]                     rootPath = tempdir()) 
[10:29:49.843]                   {
[10:29:49.843]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.843]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.843]                       tmpdir = path, fileext = ".rds")
[10:29:49.843]                     save_rds(obj, file)
[10:29:49.843]                   }
[10:29:49.843]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.843]                   {
[10:29:49.843]                     inherits <- base::inherits
[10:29:49.843]                     invokeRestart <- base::invokeRestart
[10:29:49.843]                     is.null <- base::is.null
[10:29:49.843]                     muffled <- FALSE
[10:29:49.843]                     if (inherits(cond, "message")) {
[10:29:49.843]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.843]                       if (muffled) 
[10:29:49.843]                         invokeRestart("muffleMessage")
[10:29:49.843]                     }
[10:29:49.843]                     else if (inherits(cond, "warning")) {
[10:29:49.843]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.843]                       if (muffled) 
[10:29:49.843]                         invokeRestart("muffleWarning")
[10:29:49.843]                     }
[10:29:49.843]                     else if (inherits(cond, "condition")) {
[10:29:49.843]                       if (!is.null(pattern)) {
[10:29:49.843]                         computeRestarts <- base::computeRestarts
[10:29:49.843]                         grepl <- base::grepl
[10:29:49.843]                         restarts <- computeRestarts(cond)
[10:29:49.843]                         for (restart in restarts) {
[10:29:49.843]                           name <- restart$name
[10:29:49.843]                           if (is.null(name)) 
[10:29:49.843]                             next
[10:29:49.843]                           if (!grepl(pattern, name)) 
[10:29:49.843]                             next
[10:29:49.843]                           invokeRestart(restart)
[10:29:49.843]                           muffled <- TRUE
[10:29:49.843]                           break
[10:29:49.843]                         }
[10:29:49.843]                       }
[10:29:49.843]                     }
[10:29:49.843]                     invisible(muffled)
[10:29:49.843]                   }
[10:29:49.843]                   muffleCondition(cond)
[10:29:49.843]                 })
[10:29:49.843]             }))
[10:29:49.843]             future::FutureResult(value = ...future.value$value, 
[10:29:49.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.843]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.843]                     ...future.globalenv.names))
[10:29:49.843]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.843]         }, condition = base::local({
[10:29:49.843]             c <- base::c
[10:29:49.843]             inherits <- base::inherits
[10:29:49.843]             invokeRestart <- base::invokeRestart
[10:29:49.843]             length <- base::length
[10:29:49.843]             list <- base::list
[10:29:49.843]             seq.int <- base::seq.int
[10:29:49.843]             signalCondition <- base::signalCondition
[10:29:49.843]             sys.calls <- base::sys.calls
[10:29:49.843]             `[[` <- base::`[[`
[10:29:49.843]             `+` <- base::`+`
[10:29:49.843]             `<<-` <- base::`<<-`
[10:29:49.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.843]                   3L)]
[10:29:49.843]             }
[10:29:49.843]             function(cond) {
[10:29:49.843]                 is_error <- inherits(cond, "error")
[10:29:49.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.843]                   NULL)
[10:29:49.843]                 if (is_error) {
[10:29:49.843]                   sessionInformation <- function() {
[10:29:49.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.843]                       search = base::search(), system = base::Sys.info())
[10:29:49.843]                   }
[10:29:49.843]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.843]                     cond$call), session = sessionInformation(), 
[10:29:49.843]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.843]                   signalCondition(cond)
[10:29:49.843]                 }
[10:29:49.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.843]                 "immediateCondition"))) {
[10:29:49.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.843]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.843]                   if (TRUE && !signal) {
[10:29:49.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.843]                     {
[10:29:49.843]                       inherits <- base::inherits
[10:29:49.843]                       invokeRestart <- base::invokeRestart
[10:29:49.843]                       is.null <- base::is.null
[10:29:49.843]                       muffled <- FALSE
[10:29:49.843]                       if (inherits(cond, "message")) {
[10:29:49.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.843]                         if (muffled) 
[10:29:49.843]                           invokeRestart("muffleMessage")
[10:29:49.843]                       }
[10:29:49.843]                       else if (inherits(cond, "warning")) {
[10:29:49.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.843]                         if (muffled) 
[10:29:49.843]                           invokeRestart("muffleWarning")
[10:29:49.843]                       }
[10:29:49.843]                       else if (inherits(cond, "condition")) {
[10:29:49.843]                         if (!is.null(pattern)) {
[10:29:49.843]                           computeRestarts <- base::computeRestarts
[10:29:49.843]                           grepl <- base::grepl
[10:29:49.843]                           restarts <- computeRestarts(cond)
[10:29:49.843]                           for (restart in restarts) {
[10:29:49.843]                             name <- restart$name
[10:29:49.843]                             if (is.null(name)) 
[10:29:49.843]                               next
[10:29:49.843]                             if (!grepl(pattern, name)) 
[10:29:49.843]                               next
[10:29:49.843]                             invokeRestart(restart)
[10:29:49.843]                             muffled <- TRUE
[10:29:49.843]                             break
[10:29:49.843]                           }
[10:29:49.843]                         }
[10:29:49.843]                       }
[10:29:49.843]                       invisible(muffled)
[10:29:49.843]                     }
[10:29:49.843]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.843]                   }
[10:29:49.843]                 }
[10:29:49.843]                 else {
[10:29:49.843]                   if (TRUE) {
[10:29:49.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.843]                     {
[10:29:49.843]                       inherits <- base::inherits
[10:29:49.843]                       invokeRestart <- base::invokeRestart
[10:29:49.843]                       is.null <- base::is.null
[10:29:49.843]                       muffled <- FALSE
[10:29:49.843]                       if (inherits(cond, "message")) {
[10:29:49.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.843]                         if (muffled) 
[10:29:49.843]                           invokeRestart("muffleMessage")
[10:29:49.843]                       }
[10:29:49.843]                       else if (inherits(cond, "warning")) {
[10:29:49.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.843]                         if (muffled) 
[10:29:49.843]                           invokeRestart("muffleWarning")
[10:29:49.843]                       }
[10:29:49.843]                       else if (inherits(cond, "condition")) {
[10:29:49.843]                         if (!is.null(pattern)) {
[10:29:49.843]                           computeRestarts <- base::computeRestarts
[10:29:49.843]                           grepl <- base::grepl
[10:29:49.843]                           restarts <- computeRestarts(cond)
[10:29:49.843]                           for (restart in restarts) {
[10:29:49.843]                             name <- restart$name
[10:29:49.843]                             if (is.null(name)) 
[10:29:49.843]                               next
[10:29:49.843]                             if (!grepl(pattern, name)) 
[10:29:49.843]                               next
[10:29:49.843]                             invokeRestart(restart)
[10:29:49.843]                             muffled <- TRUE
[10:29:49.843]                             break
[10:29:49.843]                           }
[10:29:49.843]                         }
[10:29:49.843]                       }
[10:29:49.843]                       invisible(muffled)
[10:29:49.843]                     }
[10:29:49.843]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.843]                   }
[10:29:49.843]                 }
[10:29:49.843]             }
[10:29:49.843]         }))
[10:29:49.843]     }, error = function(ex) {
[10:29:49.843]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.843]                 ...future.rng), started = ...future.startTime, 
[10:29:49.843]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.843]             version = "1.8"), class = "FutureResult")
[10:29:49.843]     }, finally = {
[10:29:49.843]         if (!identical(...future.workdir, getwd())) 
[10:29:49.843]             setwd(...future.workdir)
[10:29:49.843]         {
[10:29:49.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.843]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.843]             }
[10:29:49.843]             base::options(...future.oldOptions)
[10:29:49.843]             if (.Platform$OS.type == "windows") {
[10:29:49.843]                 old_names <- names(...future.oldEnvVars)
[10:29:49.843]                 envs <- base::Sys.getenv()
[10:29:49.843]                 names <- names(envs)
[10:29:49.843]                 common <- intersect(names, old_names)
[10:29:49.843]                 added <- setdiff(names, old_names)
[10:29:49.843]                 removed <- setdiff(old_names, names)
[10:29:49.843]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.843]                   envs[common]]
[10:29:49.843]                 NAMES <- toupper(changed)
[10:29:49.843]                 args <- list()
[10:29:49.843]                 for (kk in seq_along(NAMES)) {
[10:29:49.843]                   name <- changed[[kk]]
[10:29:49.843]                   NAME <- NAMES[[kk]]
[10:29:49.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.843]                     next
[10:29:49.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.843]                 }
[10:29:49.843]                 NAMES <- toupper(added)
[10:29:49.843]                 for (kk in seq_along(NAMES)) {
[10:29:49.843]                   name <- added[[kk]]
[10:29:49.843]                   NAME <- NAMES[[kk]]
[10:29:49.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.843]                     next
[10:29:49.843]                   args[[name]] <- ""
[10:29:49.843]                 }
[10:29:49.843]                 NAMES <- toupper(removed)
[10:29:49.843]                 for (kk in seq_along(NAMES)) {
[10:29:49.843]                   name <- removed[[kk]]
[10:29:49.843]                   NAME <- NAMES[[kk]]
[10:29:49.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.843]                     next
[10:29:49.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.843]                 }
[10:29:49.843]                 if (length(args) > 0) 
[10:29:49.843]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.843]             }
[10:29:49.843]             else {
[10:29:49.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.843]             }
[10:29:49.843]             {
[10:29:49.843]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.843]                   0L) {
[10:29:49.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.843]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.843]                   base::options(opts)
[10:29:49.843]                 }
[10:29:49.843]                 {
[10:29:49.843]                   {
[10:29:49.843]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.843]                     NULL
[10:29:49.843]                   }
[10:29:49.843]                   options(future.plan = NULL)
[10:29:49.843]                   if (is.na(NA_character_)) 
[10:29:49.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.843]                     .init = FALSE)
[10:29:49.843]                 }
[10:29:49.843]             }
[10:29:49.843]         }
[10:29:49.843]     })
[10:29:49.843]     if (TRUE) {
[10:29:49.843]         base::sink(type = "output", split = FALSE)
[10:29:49.843]         if (TRUE) {
[10:29:49.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.843]         }
[10:29:49.843]         else {
[10:29:49.843]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.843]         }
[10:29:49.843]         base::close(...future.stdout)
[10:29:49.843]         ...future.stdout <- NULL
[10:29:49.843]     }
[10:29:49.843]     ...future.result$conditions <- ...future.conditions
[10:29:49.843]     ...future.result$finished <- base::Sys.time()
[10:29:49.843]     ...future.result
[10:29:49.843] }
[10:29:49.846] assign_globals() ...
[10:29:49.846] List of 5
[10:29:49.846]  $ future.call.arguments    : list()
[10:29:49.846]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.846]  $ ...future.FUN            :function (x)  
[10:29:49.846]  $ ...future.elements_ii    :List of 1
[10:29:49.846]   ..$ : int [1:2] 1 3
[10:29:49.846]  $ ...future.seeds_ii       : NULL
[10:29:49.846]  $ ...future.globals.maxSize: num Inf
[10:29:49.846]  - attr(*, "resolved")= logi FALSE
[10:29:49.846]  - attr(*, "total_size")= num NA
[10:29:49.846]  - attr(*, "where")=List of 5
[10:29:49.846]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.846]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.846]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.846]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.846]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.846]  - attr(*, "already-done")= logi TRUE
[10:29:49.851] - copied ‘future.call.arguments’ to environment
[10:29:49.851] - reassign environment for ‘...future.FUN’
[10:29:49.851] - copied ‘...future.FUN’ to environment
[10:29:49.851] - copied ‘...future.elements_ii’ to environment
[10:29:49.851] - copied ‘...future.seeds_ii’ to environment
[10:29:49.851] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.851] assign_globals() ... done
[10:29:49.852] requestCore(): workers = 2
[10:29:49.854] MulticoreFuture started
[10:29:49.854] - Launch lazy future ... done
[10:29:49.854] run() for ‘MulticoreFuture’ ... done
[10:29:49.855] Created future:
[10:29:49.855] plan(): Setting new future strategy stack:
[10:29:49.855] List of future strategies:
[10:29:49.855] 1. sequential:
[10:29:49.855]    - args: function (..., envir = parent.frame())
[10:29:49.855]    - tweaked: FALSE
[10:29:49.855]    - call: NULL
[10:29:49.856] plan(): nbrOfWorkers() = 1
[10:29:49.858] plan(): Setting new future strategy stack:
[10:29:49.858] List of future strategies:
[10:29:49.858] 1. multicore:
[10:29:49.858]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.858]    - tweaked: FALSE
[10:29:49.858]    - call: plan(strategy)
[10:29:49.855] MulticoreFuture:
[10:29:49.855] Label: ‘future_apply-1’
[10:29:49.855] Expression:
[10:29:49.855] {
[10:29:49.855]     do.call(function(...) {
[10:29:49.855]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.855]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.855]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.855]             on.exit(options(oopts), add = TRUE)
[10:29:49.855]         }
[10:29:49.855]         {
[10:29:49.855]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.855]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.855]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.855]             })
[10:29:49.855]         }
[10:29:49.855]     }, args = future.call.arguments)
[10:29:49.855] }
[10:29:49.855] Lazy evaluation: FALSE
[10:29:49.855] Asynchronous evaluation: TRUE
[10:29:49.855] Local evaluation: TRUE
[10:29:49.855] Environment: R_GlobalEnv
[10:29:49.855] Capture standard output: TRUE
[10:29:49.855] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.855] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.855] Packages: <none>
[10:29:49.855] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.855] Resolved: FALSE
[10:29:49.855] Value: <not collected>
[10:29:49.855] Conditions captured: <none>
[10:29:49.855] Early signaling: FALSE
[10:29:49.855] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.855] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.867] Chunk #1 of 2 ... DONE
[10:29:49.868] Chunk #2 of 2 ...
[10:29:49.868]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.868]  - seeds: <none>
[10:29:49.868] plan(): nbrOfWorkers() = 2
[10:29:49.868]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.871] getGlobalsAndPackages() ...
[10:29:49.871] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.872] Resolving globals: FALSE
[10:29:49.872] Tweak future expression to call with '...' arguments ...
[10:29:49.872] {
[10:29:49.872]     do.call(function(...) {
[10:29:49.872]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.872]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.872]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.872]             on.exit(options(oopts), add = TRUE)
[10:29:49.872]         }
[10:29:49.872]         {
[10:29:49.872]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.872]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.872]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.872]             })
[10:29:49.872]         }
[10:29:49.872]     }, args = future.call.arguments)
[10:29:49.872] }
[10:29:49.873] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.874] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.874] 
[10:29:49.874] getGlobalsAndPackages() ... DONE
[10:29:49.875] run() for ‘Future’ ...
[10:29:49.876] - state: ‘created’
[10:29:49.876] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.882] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.882]   - Field: ‘label’
[10:29:49.882]   - Field: ‘local’
[10:29:49.883]   - Field: ‘owner’
[10:29:49.883]   - Field: ‘envir’
[10:29:49.883]   - Field: ‘workers’
[10:29:49.883]   - Field: ‘packages’
[10:29:49.883]   - Field: ‘gc’
[10:29:49.883]   - Field: ‘job’
[10:29:49.884]   - Field: ‘conditions’
[10:29:49.884]   - Field: ‘expr’
[10:29:49.884]   - Field: ‘uuid’
[10:29:49.884]   - Field: ‘seed’
[10:29:49.884]   - Field: ‘version’
[10:29:49.885]   - Field: ‘result’
[10:29:49.885]   - Field: ‘asynchronous’
[10:29:49.885]   - Field: ‘calls’
[10:29:49.885]   - Field: ‘globals’
[10:29:49.885]   - Field: ‘stdout’
[10:29:49.886]   - Field: ‘earlySignal’
[10:29:49.886]   - Field: ‘lazy’
[10:29:49.886]   - Field: ‘state’
[10:29:49.886] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.886] - Launch lazy future ...
[10:29:49.887] Packages needed by the future expression (n = 0): <none>
[10:29:49.887] Packages needed by future strategies (n = 0): <none>
[10:29:49.887] {
[10:29:49.887]     {
[10:29:49.887]         {
[10:29:49.887]             ...future.startTime <- base::Sys.time()
[10:29:49.887]             {
[10:29:49.887]                 {
[10:29:49.887]                   {
[10:29:49.887]                     {
[10:29:49.887]                       base::local({
[10:29:49.887]                         has_future <- base::requireNamespace("future", 
[10:29:49.887]                           quietly = TRUE)
[10:29:49.887]                         if (has_future) {
[10:29:49.887]                           ns <- base::getNamespace("future")
[10:29:49.887]                           version <- ns[[".package"]][["version"]]
[10:29:49.887]                           if (is.null(version)) 
[10:29:49.887]                             version <- utils::packageVersion("future")
[10:29:49.887]                         }
[10:29:49.887]                         else {
[10:29:49.887]                           version <- NULL
[10:29:49.887]                         }
[10:29:49.887]                         if (!has_future || version < "1.8.0") {
[10:29:49.887]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.887]                             "", base::R.version$version.string), 
[10:29:49.887]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.887]                               "release", "version")], collapse = " "), 
[10:29:49.887]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.887]                             info)
[10:29:49.887]                           info <- base::paste(info, collapse = "; ")
[10:29:49.887]                           if (!has_future) {
[10:29:49.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.887]                               info)
[10:29:49.887]                           }
[10:29:49.887]                           else {
[10:29:49.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.887]                               info, version)
[10:29:49.887]                           }
[10:29:49.887]                           base::stop(msg)
[10:29:49.887]                         }
[10:29:49.887]                       })
[10:29:49.887]                     }
[10:29:49.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.887]                     base::options(mc.cores = 1L)
[10:29:49.887]                   }
[10:29:49.887]                   ...future.strategy.old <- future::plan("list")
[10:29:49.887]                   options(future.plan = NULL)
[10:29:49.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.887]                 }
[10:29:49.887]                 ...future.workdir <- getwd()
[10:29:49.887]             }
[10:29:49.887]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.887]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.887]         }
[10:29:49.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.887]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.887]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.887]             base::names(...future.oldOptions))
[10:29:49.887]     }
[10:29:49.887]     if (FALSE) {
[10:29:49.887]     }
[10:29:49.887]     else {
[10:29:49.887]         if (TRUE) {
[10:29:49.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.887]                 open = "w")
[10:29:49.887]         }
[10:29:49.887]         else {
[10:29:49.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.887]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.887]         }
[10:29:49.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.887]             base::sink(type = "output", split = FALSE)
[10:29:49.887]             base::close(...future.stdout)
[10:29:49.887]         }, add = TRUE)
[10:29:49.887]     }
[10:29:49.887]     ...future.frame <- base::sys.nframe()
[10:29:49.887]     ...future.conditions <- base::list()
[10:29:49.887]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.887]     if (FALSE) {
[10:29:49.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.887]     }
[10:29:49.887]     ...future.result <- base::tryCatch({
[10:29:49.887]         base::withCallingHandlers({
[10:29:49.887]             ...future.value <- base::withVisible(base::local({
[10:29:49.887]                 withCallingHandlers({
[10:29:49.887]                   {
[10:29:49.887]                     do.call(function(...) {
[10:29:49.887]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.887]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.887]                         ...future.globals.maxSize)) {
[10:29:49.887]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.887]                         on.exit(options(oopts), add = TRUE)
[10:29:49.887]                       }
[10:29:49.887]                       {
[10:29:49.887]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.887]                           FUN = function(jj) {
[10:29:49.887]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.887]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.887]                           })
[10:29:49.887]                       }
[10:29:49.887]                     }, args = future.call.arguments)
[10:29:49.887]                   }
[10:29:49.887]                 }, immediateCondition = function(cond) {
[10:29:49.887]                   save_rds <- function (object, pathname, ...) 
[10:29:49.887]                   {
[10:29:49.887]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.887]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.887]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.887]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.887]                         fi_tmp[["mtime"]])
[10:29:49.887]                     }
[10:29:49.887]                     tryCatch({
[10:29:49.887]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.887]                     }, error = function(ex) {
[10:29:49.887]                       msg <- conditionMessage(ex)
[10:29:49.887]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.887]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.887]                         fi_tmp[["mtime"]], msg)
[10:29:49.887]                       ex$message <- msg
[10:29:49.887]                       stop(ex)
[10:29:49.887]                     })
[10:29:49.887]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.887]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.887]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.887]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.887]                       fi <- file.info(pathname)
[10:29:49.887]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.887]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.887]                         fi[["size"]], fi[["mtime"]])
[10:29:49.887]                       stop(msg)
[10:29:49.887]                     }
[10:29:49.887]                     invisible(pathname)
[10:29:49.887]                   }
[10:29:49.887]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.887]                     rootPath = tempdir()) 
[10:29:49.887]                   {
[10:29:49.887]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.887]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.887]                       tmpdir = path, fileext = ".rds")
[10:29:49.887]                     save_rds(obj, file)
[10:29:49.887]                   }
[10:29:49.887]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.887]                   {
[10:29:49.887]                     inherits <- base::inherits
[10:29:49.887]                     invokeRestart <- base::invokeRestart
[10:29:49.887]                     is.null <- base::is.null
[10:29:49.887]                     muffled <- FALSE
[10:29:49.887]                     if (inherits(cond, "message")) {
[10:29:49.887]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.887]                       if (muffled) 
[10:29:49.887]                         invokeRestart("muffleMessage")
[10:29:49.887]                     }
[10:29:49.887]                     else if (inherits(cond, "warning")) {
[10:29:49.887]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.887]                       if (muffled) 
[10:29:49.887]                         invokeRestart("muffleWarning")
[10:29:49.887]                     }
[10:29:49.887]                     else if (inherits(cond, "condition")) {
[10:29:49.887]                       if (!is.null(pattern)) {
[10:29:49.887]                         computeRestarts <- base::computeRestarts
[10:29:49.887]                         grepl <- base::grepl
[10:29:49.887]                         restarts <- computeRestarts(cond)
[10:29:49.887]                         for (restart in restarts) {
[10:29:49.887]                           name <- restart$name
[10:29:49.887]                           if (is.null(name)) 
[10:29:49.887]                             next
[10:29:49.887]                           if (!grepl(pattern, name)) 
[10:29:49.887]                             next
[10:29:49.887]                           invokeRestart(restart)
[10:29:49.887]                           muffled <- TRUE
[10:29:49.887]                           break
[10:29:49.887]                         }
[10:29:49.887]                       }
[10:29:49.887]                     }
[10:29:49.887]                     invisible(muffled)
[10:29:49.887]                   }
[10:29:49.887]                   muffleCondition(cond)
[10:29:49.887]                 })
[10:29:49.887]             }))
[10:29:49.887]             future::FutureResult(value = ...future.value$value, 
[10:29:49.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.887]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.887]                     ...future.globalenv.names))
[10:29:49.887]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.887]         }, condition = base::local({
[10:29:49.887]             c <- base::c
[10:29:49.887]             inherits <- base::inherits
[10:29:49.887]             invokeRestart <- base::invokeRestart
[10:29:49.887]             length <- base::length
[10:29:49.887]             list <- base::list
[10:29:49.887]             seq.int <- base::seq.int
[10:29:49.887]             signalCondition <- base::signalCondition
[10:29:49.887]             sys.calls <- base::sys.calls
[10:29:49.887]             `[[` <- base::`[[`
[10:29:49.887]             `+` <- base::`+`
[10:29:49.887]             `<<-` <- base::`<<-`
[10:29:49.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.887]                   3L)]
[10:29:49.887]             }
[10:29:49.887]             function(cond) {
[10:29:49.887]                 is_error <- inherits(cond, "error")
[10:29:49.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.887]                   NULL)
[10:29:49.887]                 if (is_error) {
[10:29:49.887]                   sessionInformation <- function() {
[10:29:49.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.887]                       search = base::search(), system = base::Sys.info())
[10:29:49.887]                   }
[10:29:49.887]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.887]                     cond$call), session = sessionInformation(), 
[10:29:49.887]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.887]                   signalCondition(cond)
[10:29:49.887]                 }
[10:29:49.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:49.887]                 "immediateCondition"))) {
[10:29:49.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.887]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.887]                   if (TRUE && !signal) {
[10:29:49.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.887]                     {
[10:29:49.887]                       inherits <- base::inherits
[10:29:49.887]                       invokeRestart <- base::invokeRestart
[10:29:49.887]                       is.null <- base::is.null
[10:29:49.887]                       muffled <- FALSE
[10:29:49.887]                       if (inherits(cond, "message")) {
[10:29:49.887]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.887]                         if (muffled) 
[10:29:49.887]                           invokeRestart("muffleMessage")
[10:29:49.887]                       }
[10:29:49.887]                       else if (inherits(cond, "warning")) {
[10:29:49.887]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.887]                         if (muffled) 
[10:29:49.887]                           invokeRestart("muffleWarning")
[10:29:49.887]                       }
[10:29:49.887]                       else if (inherits(cond, "condition")) {
[10:29:49.887]                         if (!is.null(pattern)) {
[10:29:49.887]                           computeRestarts <- base::computeRestarts
[10:29:49.887]                           grepl <- base::grepl
[10:29:49.887]                           restarts <- computeRestarts(cond)
[10:29:49.887]                           for (restart in restarts) {
[10:29:49.887]                             name <- restart$name
[10:29:49.887]                             if (is.null(name)) 
[10:29:49.887]                               next
[10:29:49.887]                             if (!grepl(pattern, name)) 
[10:29:49.887]                               next
[10:29:49.887]                             invokeRestart(restart)
[10:29:49.887]                             muffled <- TRUE
[10:29:49.887]                             break
[10:29:49.887]                           }
[10:29:49.887]                         }
[10:29:49.887]                       }
[10:29:49.887]                       invisible(muffled)
[10:29:49.887]                     }
[10:29:49.887]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.887]                   }
[10:29:49.887]                 }
[10:29:49.887]                 else {
[10:29:49.887]                   if (TRUE) {
[10:29:49.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.887]                     {
[10:29:49.887]                       inherits <- base::inherits
[10:29:49.887]                       invokeRestart <- base::invokeRestart
[10:29:49.887]                       is.null <- base::is.null
[10:29:49.887]                       muffled <- FALSE
[10:29:49.887]                       if (inherits(cond, "message")) {
[10:29:49.887]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.887]                         if (muffled) 
[10:29:49.887]                           invokeRestart("muffleMessage")
[10:29:49.887]                       }
[10:29:49.887]                       else if (inherits(cond, "warning")) {
[10:29:49.887]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.887]                         if (muffled) 
[10:29:49.887]                           invokeRestart("muffleWarning")
[10:29:49.887]                       }
[10:29:49.887]                       else if (inherits(cond, "condition")) {
[10:29:49.887]                         if (!is.null(pattern)) {
[10:29:49.887]                           computeRestarts <- base::computeRestarts
[10:29:49.887]                           grepl <- base::grepl
[10:29:49.887]                           restarts <- computeRestarts(cond)
[10:29:49.887]                           for (restart in restarts) {
[10:29:49.887]                             name <- restart$name
[10:29:49.887]                             if (is.null(name)) 
[10:29:49.887]                               next
[10:29:49.887]                             if (!grepl(pattern, name)) 
[10:29:49.887]                               next
[10:29:49.887]                             invokeRestart(restart)
[10:29:49.887]                             muffled <- TRUE
[10:29:49.887]                             break
[10:29:49.887]                           }
[10:29:49.887]                         }
[10:29:49.887]                       }
[10:29:49.887]                       invisible(muffled)
[10:29:49.887]                     }
[10:29:49.887]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.887]                   }
[10:29:49.887]                 }
[10:29:49.887]             }
[10:29:49.887]         }))
[10:29:49.887]     }, error = function(ex) {
[10:29:49.887]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.887]                 ...future.rng), started = ...future.startTime, 
[10:29:49.887]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.887]             version = "1.8"), class = "FutureResult")
[10:29:49.887]     }, finally = {
[10:29:49.887]         if (!identical(...future.workdir, getwd())) 
[10:29:49.887]             setwd(...future.workdir)
[10:29:49.887]         {
[10:29:49.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.887]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.887]             }
[10:29:49.887]             base::options(...future.oldOptions)
[10:29:49.887]             if (.Platform$OS.type == "windows") {
[10:29:49.887]                 old_names <- names(...future.oldEnvVars)
[10:29:49.887]                 envs <- base::Sys.getenv()
[10:29:49.887]                 names <- names(envs)
[10:29:49.887]                 common <- intersect(names, old_names)
[10:29:49.887]                 added <- setdiff(names, old_names)
[10:29:49.887]                 removed <- setdiff(old_names, names)
[10:29:49.887]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.887]                   envs[common]]
[10:29:49.887]                 NAMES <- toupper(changed)
[10:29:49.887]                 args <- list()
[10:29:49.887]                 for (kk in seq_along(NAMES)) {
[10:29:49.887]                   name <- changed[[kk]]
[10:29:49.887]                   NAME <- NAMES[[kk]]
[10:29:49.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.887]                     next
[10:29:49.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.887]                 }
[10:29:49.887]                 NAMES <- toupper(added)
[10:29:49.887]                 for (kk in seq_along(NAMES)) {
[10:29:49.887]                   name <- added[[kk]]
[10:29:49.887]                   NAME <- NAMES[[kk]]
[10:29:49.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.887]                     next
[10:29:49.887]                   args[[name]] <- ""
[10:29:49.887]                 }
[10:29:49.887]                 NAMES <- toupper(removed)
[10:29:49.887]                 for (kk in seq_along(NAMES)) {
[10:29:49.887]                   name <- removed[[kk]]
[10:29:49.887]                   NAME <- NAMES[[kk]]
[10:29:49.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.887]                     next
[10:29:49.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.887]                 }
[10:29:49.887]                 if (length(args) > 0) 
[10:29:49.887]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.887]             }
[10:29:49.887]             else {
[10:29:49.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.887]             }
[10:29:49.887]             {
[10:29:49.887]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.887]                   0L) {
[10:29:49.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.887]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.887]                   base::options(opts)
[10:29:49.887]                 }
[10:29:49.887]                 {
[10:29:49.887]                   {
[10:29:49.887]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.887]                     NULL
[10:29:49.887]                   }
[10:29:49.887]                   options(future.plan = NULL)
[10:29:49.887]                   if (is.na(NA_character_)) 
[10:29:49.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.887]                     .init = FALSE)
[10:29:49.887]                 }
[10:29:49.887]             }
[10:29:49.887]         }
[10:29:49.887]     })
[10:29:49.887]     if (TRUE) {
[10:29:49.887]         base::sink(type = "output", split = FALSE)
[10:29:49.887]         if (TRUE) {
[10:29:49.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.887]         }
[10:29:49.887]         else {
[10:29:49.887]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.887]         }
[10:29:49.887]         base::close(...future.stdout)
[10:29:49.887]         ...future.stdout <- NULL
[10:29:49.887]     }
[10:29:49.887]     ...future.result$conditions <- ...future.conditions
[10:29:49.887]     ...future.result$finished <- base::Sys.time()
[10:29:49.887]     ...future.result
[10:29:49.887] }
[10:29:49.890] assign_globals() ...
[10:29:49.890] List of 5
[10:29:49.890]  $ future.call.arguments    : list()
[10:29:49.890]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.890]  $ ...future.FUN            :function (x)  
[10:29:49.890]  $ ...future.elements_ii    :List of 1
[10:29:49.890]   ..$ : int [1:2] 2 4
[10:29:49.890]  $ ...future.seeds_ii       : NULL
[10:29:49.890]  $ ...future.globals.maxSize: num Inf
[10:29:49.890]  - attr(*, "resolved")= logi FALSE
[10:29:49.890]  - attr(*, "total_size")= num NA
[10:29:49.890]  - attr(*, "where")=List of 5
[10:29:49.890]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.890]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.890]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.890]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.890]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.890]  - attr(*, "already-done")= logi TRUE
[10:29:49.897] - copied ‘future.call.arguments’ to environment
[10:29:49.897] - reassign environment for ‘...future.FUN’
[10:29:49.897] - copied ‘...future.FUN’ to environment
[10:29:49.897] - copied ‘...future.elements_ii’ to environment
[10:29:49.897] - copied ‘...future.seeds_ii’ to environment
[10:29:49.897] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.898] assign_globals() ... done
[10:29:49.898] requestCore(): workers = 2
[10:29:49.900] MulticoreFuture started
[10:29:49.900] - Launch lazy future ... done
[10:29:49.901] run() for ‘MulticoreFuture’ ... done
[10:29:49.901] Created future:
[10:29:49.901] plan(): Setting new future strategy stack:
[10:29:49.902] List of future strategies:
[10:29:49.902] 1. sequential:
[10:29:49.902]    - args: function (..., envir = parent.frame())
[10:29:49.902]    - tweaked: FALSE
[10:29:49.902]    - call: NULL
[10:29:49.902] plan(): nbrOfWorkers() = 1
[10:29:49.904] plan(): Setting new future strategy stack:
[10:29:49.905] List of future strategies:
[10:29:49.905] 1. multicore:
[10:29:49.905]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.905]    - tweaked: FALSE
[10:29:49.905]    - call: plan(strategy)
[10:29:49.910] plan(): nbrOfWorkers() = 2
[10:29:49.901] MulticoreFuture:
[10:29:49.901] Label: ‘future_apply-2’
[10:29:49.901] Expression:
[10:29:49.901] {
[10:29:49.901]     do.call(function(...) {
[10:29:49.901]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.901]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.901]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.901]             on.exit(options(oopts), add = TRUE)
[10:29:49.901]         }
[10:29:49.901]         {
[10:29:49.901]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.901]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.901]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.901]             })
[10:29:49.901]         }
[10:29:49.901]     }, args = future.call.arguments)
[10:29:49.901] }
[10:29:49.901] Lazy evaluation: FALSE
[10:29:49.901] Asynchronous evaluation: TRUE
[10:29:49.901] Local evaluation: TRUE
[10:29:49.901] Environment: R_GlobalEnv
[10:29:49.901] Capture standard output: TRUE
[10:29:49.901] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:49.901] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.901] Packages: <none>
[10:29:49.901] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:49.901] Resolved: TRUE
[10:29:49.901] Value: <not collected>
[10:29:49.901] Conditions captured: <none>
[10:29:49.901] Early signaling: FALSE
[10:29:49.901] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.901] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.911] Chunk #2 of 2 ... DONE
[10:29:49.911] Launching 2 futures (chunks) ... DONE
[10:29:49.911] Resolving 2 futures (chunks) ...
[10:29:49.911] resolve() on list ...
[10:29:49.911]  recursive: 0
[10:29:49.911]  length: 2
[10:29:49.911] 
[10:29:49.912] Future #1
[10:29:49.912] result() for MulticoreFuture ...
[10:29:49.913] result() for MulticoreFuture ...
[10:29:49.913] result() for MulticoreFuture ... done
[10:29:49.913] result() for MulticoreFuture ... done
[10:29:49.913] result() for MulticoreFuture ...
[10:29:49.913] result() for MulticoreFuture ... done
[10:29:49.914] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:49.914] - nx: 2
[10:29:49.914] - relay: TRUE
[10:29:49.914] - stdout: TRUE
[10:29:49.914] - signal: TRUE
[10:29:49.914] - resignal: FALSE
[10:29:49.914] - force: TRUE
[10:29:49.915] - relayed: [n=2] FALSE, FALSE
[10:29:49.915] - queued futures: [n=2] FALSE, FALSE
[10:29:49.915]  - until=1
[10:29:49.915]  - relaying element #1
[10:29:49.915] result() for MulticoreFuture ...
[10:29:49.915] result() for MulticoreFuture ... done
[10:29:49.915] result() for MulticoreFuture ...
[10:29:49.916] result() for MulticoreFuture ... done
[10:29:49.916] result() for MulticoreFuture ...
[10:29:49.916] result() for MulticoreFuture ... done
[10:29:49.916] result() for MulticoreFuture ...
[10:29:49.916] result() for MulticoreFuture ... done
[10:29:49.916] - relayed: [n=2] TRUE, FALSE
[10:29:49.916] - queued futures: [n=2] TRUE, FALSE
[10:29:49.917] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:49.917]  length: 1 (resolved future 1)
[10:29:49.917] Future #2
[10:29:49.917] result() for MulticoreFuture ...
[10:29:49.922] result() for MulticoreFuture ...
[10:29:49.922] result() for MulticoreFuture ... done
[10:29:49.923] result() for MulticoreFuture ... done
[10:29:49.923] result() for MulticoreFuture ...
[10:29:49.923] result() for MulticoreFuture ... done
[10:29:49.923] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:49.924] - nx: 2
[10:29:49.924] - relay: TRUE
[10:29:49.924] - stdout: TRUE
[10:29:49.924] - signal: TRUE
[10:29:49.924] - resignal: FALSE
[10:29:49.924] - force: TRUE
[10:29:49.924] - relayed: [n=2] TRUE, FALSE
[10:29:49.925] - queued futures: [n=2] TRUE, FALSE
[10:29:49.925]  - until=2
[10:29:49.925]  - relaying element #2
[10:29:49.925] result() for MulticoreFuture ...
[10:29:49.925] result() for MulticoreFuture ... done
[10:29:49.925] result() for MulticoreFuture ...
[10:29:49.926] result() for MulticoreFuture ... done
[10:29:49.926] result() for MulticoreFuture ...
[10:29:49.926] result() for MulticoreFuture ... done
[10:29:49.926] result() for MulticoreFuture ...
[10:29:49.926] result() for MulticoreFuture ... done
[10:29:49.926] - relayed: [n=2] TRUE, TRUE
[10:29:49.927] - queued futures: [n=2] TRUE, TRUE
[10:29:49.927] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:49.927]  length: 0 (resolved future 2)
[10:29:49.927] Relaying remaining futures
[10:29:49.927] signalConditionsASAP(NULL, pos=0) ...
[10:29:49.927] - nx: 2
[10:29:49.927] - relay: TRUE
[10:29:49.927] - stdout: TRUE
[10:29:49.927] - signal: TRUE
[10:29:49.928] - resignal: FALSE
[10:29:49.928] - force: TRUE
[10:29:49.928] - relayed: [n=2] TRUE, TRUE
[10:29:49.928] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:49.928] - relayed: [n=2] TRUE, TRUE
[10:29:49.928] - queued futures: [n=2] TRUE, TRUE
[10:29:49.928] signalConditionsASAP(NULL, pos=0) ... done
[10:29:49.928] resolve() on list ... DONE
[10:29:49.929] result() for MulticoreFuture ...
[10:29:49.929] result() for MulticoreFuture ... done
[10:29:49.929] result() for MulticoreFuture ...
[10:29:49.929] result() for MulticoreFuture ... done
[10:29:49.929] result() for MulticoreFuture ...
[10:29:49.929] result() for MulticoreFuture ... done
[10:29:49.929] result() for MulticoreFuture ...
[10:29:49.930] result() for MulticoreFuture ... done
[10:29:49.930]  - Number of value chunks collected: 2
[10:29:49.930] Resolving 2 futures (chunks) ... DONE
[10:29:49.930] Reducing values from 2 chunks ...
[10:29:49.930]  - Number of values collected after concatenation: 2
[10:29:49.930]  - Number of values expected: 2
[10:29:49.930] Reducing values from 2 chunks ... DONE
[10:29:49.930] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:29:49.931] getGlobalsAndPackagesXApply() ...
[10:29:49.931]  - future.globals: TRUE
[10:29:49.931] getGlobalsAndPackages() ...
[10:29:49.931] Searching for globals...
[10:29:49.935] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:29:49.935] Searching for globals ... DONE
[10:29:49.935] Resolving globals: FALSE
[10:29:49.936] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[10:29:49.936] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[10:29:49.936] - globals: [1] ‘FUN’
[10:29:49.936] 
[10:29:49.936] getGlobalsAndPackages() ... DONE
[10:29:49.936]  - globals found/used: [n=1] ‘FUN’
[10:29:49.936]  - needed namespaces: [n=0] 
[10:29:49.937] Finding globals ... DONE
[10:29:49.937]  - use_args: TRUE
[10:29:49.937]  - Getting '...' globals ...
[10:29:49.937] resolve() on list ...
[10:29:49.937]  recursive: 0
[10:29:49.937]  length: 1
[10:29:49.937]  elements: ‘...’
[10:29:49.938]  length: 0 (resolved future 1)
[10:29:49.938] resolve() on list ... DONE
[10:29:49.938]    - '...' content: [n=0] 
[10:29:49.938] List of 1
[10:29:49.938]  $ ...: list()
[10:29:49.938]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.938]  - attr(*, "where")=List of 1
[10:29:49.938]   ..$ ...:<environment: 0x5618a056a3f8> 
[10:29:49.938]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.938]  - attr(*, "resolved")= logi TRUE
[10:29:49.938]  - attr(*, "total_size")= num NA
[10:29:49.940]  - Getting '...' globals ... DONE
[10:29:49.941] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:49.941] List of 2
[10:29:49.941]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:29:49.941]  $ ...          : list()
[10:29:49.941]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.941]  - attr(*, "where")=List of 2
[10:29:49.941]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:49.941]   ..$ ...          :<environment: 0x5618a056a3f8> 
[10:29:49.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.941]  - attr(*, "resolved")= logi FALSE
[10:29:49.941]  - attr(*, "total_size")= num 36296
[10:29:49.946] Packages to be attached in all futures: [n=0] 
[10:29:49.946] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.950] future_lapply() ...
[10:29:49.952] Generating random seeds ...
[10:29:49.952] Generating random seed streams for 2 elements ...
[10:29:49.952] Generating random seed streams for 2 elements ... DONE
[10:29:49.952] Generating random seeds ... DONE
[10:29:49.952] Will set RNG state on exit: 10407, 1572730823, 1053690761, -1527881283, 2134421823, -878350246, 1792857073
[10:29:49.956] Number of chunks: 2
[10:29:49.956] getGlobalsAndPackagesXApply() ...
[10:29:49.956]  - future.globals: <name-value list> with names ‘list()’
[10:29:49.956]  - use_args: TRUE
[10:29:49.956] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:49.957] List of 2
[10:29:49.957]  $ ...          : list()
[10:29:49.957]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.957]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:29:49.957]  - attr(*, "where")=List of 2
[10:29:49.957]   ..$ ...          :<environment: 0x5618a056a3f8> 
[10:29:49.957]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:49.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.957]  - attr(*, "resolved")= logi FALSE
[10:29:49.957]  - attr(*, "total_size")= num NA
[10:29:49.960] Packages to be attached in all futures: [n=0] 
[10:29:49.960] getGlobalsAndPackagesXApply() ... DONE
[10:29:49.960] Number of futures (= number of chunks): 2
[10:29:49.960] Launching 2 futures (chunks) ...
[10:29:49.960] Chunk #1 of 2 ...
[10:29:49.960]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.960]  - seeds: [1] <seeds>
[10:29:49.961]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.961] getGlobalsAndPackages() ...
[10:29:49.961] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.961] Resolving globals: FALSE
[10:29:49.961] Tweak future expression to call with '...' arguments ...
[10:29:49.961] {
[10:29:49.961]     do.call(function(...) {
[10:29:49.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.961]             on.exit(options(oopts), add = TRUE)
[10:29:49.961]         }
[10:29:49.961]         {
[10:29:49.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.961]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:49.961]                   envir = globalenv(), inherits = FALSE)
[10:29:49.961]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.961]             })
[10:29:49.961]         }
[10:29:49.961]     }, args = future.call.arguments)
[10:29:49.961] }
[10:29:49.961] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.962] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.962] 
[10:29:49.962] getGlobalsAndPackages() ... DONE
[10:29:49.962] run() for ‘Future’ ...
[10:29:49.962] - state: ‘created’
[10:29:49.963] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:49.966] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.966] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:49.966]   - Field: ‘label’
[10:29:49.966]   - Field: ‘local’
[10:29:49.967]   - Field: ‘owner’
[10:29:49.967]   - Field: ‘envir’
[10:29:49.967]   - Field: ‘workers’
[10:29:49.967]   - Field: ‘packages’
[10:29:49.967]   - Field: ‘gc’
[10:29:49.967]   - Field: ‘job’
[10:29:49.967]   - Field: ‘conditions’
[10:29:49.967]   - Field: ‘expr’
[10:29:49.967]   - Field: ‘uuid’
[10:29:49.967]   - Field: ‘seed’
[10:29:49.967]   - Field: ‘version’
[10:29:49.968]   - Field: ‘result’
[10:29:49.968]   - Field: ‘asynchronous’
[10:29:49.968]   - Field: ‘calls’
[10:29:49.968]   - Field: ‘globals’
[10:29:49.968]   - Field: ‘stdout’
[10:29:49.968]   - Field: ‘earlySignal’
[10:29:49.968]   - Field: ‘lazy’
[10:29:49.968]   - Field: ‘state’
[10:29:49.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:49.968] - Launch lazy future ...
[10:29:49.969] Packages needed by the future expression (n = 0): <none>
[10:29:49.969] Packages needed by future strategies (n = 0): <none>
[10:29:49.969] {
[10:29:49.969]     {
[10:29:49.969]         {
[10:29:49.969]             ...future.startTime <- base::Sys.time()
[10:29:49.969]             {
[10:29:49.969]                 {
[10:29:49.969]                   {
[10:29:49.969]                     {
[10:29:49.969]                       base::local({
[10:29:49.969]                         has_future <- base::requireNamespace("future", 
[10:29:49.969]                           quietly = TRUE)
[10:29:49.969]                         if (has_future) {
[10:29:49.969]                           ns <- base::getNamespace("future")
[10:29:49.969]                           version <- ns[[".package"]][["version"]]
[10:29:49.969]                           if (is.null(version)) 
[10:29:49.969]                             version <- utils::packageVersion("future")
[10:29:49.969]                         }
[10:29:49.969]                         else {
[10:29:49.969]                           version <- NULL
[10:29:49.969]                         }
[10:29:49.969]                         if (!has_future || version < "1.8.0") {
[10:29:49.969]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:49.969]                             "", base::R.version$version.string), 
[10:29:49.969]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:49.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:49.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:49.969]                               "release", "version")], collapse = " "), 
[10:29:49.969]                             hostname = base::Sys.info()[["nodename"]])
[10:29:49.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:49.969]                             info)
[10:29:49.969]                           info <- base::paste(info, collapse = "; ")
[10:29:49.969]                           if (!has_future) {
[10:29:49.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:49.969]                               info)
[10:29:49.969]                           }
[10:29:49.969]                           else {
[10:29:49.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:49.969]                               info, version)
[10:29:49.969]                           }
[10:29:49.969]                           base::stop(msg)
[10:29:49.969]                         }
[10:29:49.969]                       })
[10:29:49.969]                     }
[10:29:49.969]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:49.969]                     base::options(mc.cores = 1L)
[10:29:49.969]                   }
[10:29:49.969]                   ...future.strategy.old <- future::plan("list")
[10:29:49.969]                   options(future.plan = NULL)
[10:29:49.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:49.969]                 }
[10:29:49.969]                 ...future.workdir <- getwd()
[10:29:49.969]             }
[10:29:49.969]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:49.969]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:49.969]         }
[10:29:49.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:49.969]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:49.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:49.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:49.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:49.969]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:49.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:49.969]             base::names(...future.oldOptions))
[10:29:49.969]     }
[10:29:49.969]     if (FALSE) {
[10:29:49.969]     }
[10:29:49.969]     else {
[10:29:49.969]         if (TRUE) {
[10:29:49.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:49.969]                 open = "w")
[10:29:49.969]         }
[10:29:49.969]         else {
[10:29:49.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:49.969]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:49.969]         }
[10:29:49.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:49.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:49.969]             base::sink(type = "output", split = FALSE)
[10:29:49.969]             base::close(...future.stdout)
[10:29:49.969]         }, add = TRUE)
[10:29:49.969]     }
[10:29:49.969]     ...future.frame <- base::sys.nframe()
[10:29:49.969]     ...future.conditions <- base::list()
[10:29:49.969]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:49.969]     if (FALSE) {
[10:29:49.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:49.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:49.969]     }
[10:29:49.969]     ...future.result <- base::tryCatch({
[10:29:49.969]         base::withCallingHandlers({
[10:29:49.969]             ...future.value <- base::withVisible(base::local({
[10:29:49.969]                 withCallingHandlers({
[10:29:49.969]                   {
[10:29:49.969]                     do.call(function(...) {
[10:29:49.969]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.969]                       if (!identical(...future.globals.maxSize.org, 
[10:29:49.969]                         ...future.globals.maxSize)) {
[10:29:49.969]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.969]                         on.exit(options(oopts), add = TRUE)
[10:29:49.969]                       }
[10:29:49.969]                       {
[10:29:49.969]                         lapply(seq_along(...future.elements_ii), 
[10:29:49.969]                           FUN = function(jj) {
[10:29:49.969]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.969]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:49.969]                               envir = globalenv(), inherits = FALSE)
[10:29:49.969]                             ...future.FUN(...future.X_jj, ...)
[10:29:49.969]                           })
[10:29:49.969]                       }
[10:29:49.969]                     }, args = future.call.arguments)
[10:29:49.969]                   }
[10:29:49.969]                 }, immediateCondition = function(cond) {
[10:29:49.969]                   save_rds <- function (object, pathname, ...) 
[10:29:49.969]                   {
[10:29:49.969]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:49.969]                     if (file_test("-f", pathname_tmp)) {
[10:29:49.969]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.969]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:49.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.969]                         fi_tmp[["mtime"]])
[10:29:49.969]                     }
[10:29:49.969]                     tryCatch({
[10:29:49.969]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:49.969]                     }, error = function(ex) {
[10:29:49.969]                       msg <- conditionMessage(ex)
[10:29:49.969]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.969]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:49.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.969]                         fi_tmp[["mtime"]], msg)
[10:29:49.969]                       ex$message <- msg
[10:29:49.969]                       stop(ex)
[10:29:49.969]                     })
[10:29:49.969]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:49.969]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:49.969]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:49.969]                       fi_tmp <- file.info(pathname_tmp)
[10:29:49.969]                       fi <- file.info(pathname)
[10:29:49.969]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:49.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:49.969]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:49.969]                         fi[["size"]], fi[["mtime"]])
[10:29:49.969]                       stop(msg)
[10:29:49.969]                     }
[10:29:49.969]                     invisible(pathname)
[10:29:49.969]                   }
[10:29:49.969]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:49.969]                     rootPath = tempdir()) 
[10:29:49.969]                   {
[10:29:49.969]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:49.969]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:49.969]                       tmpdir = path, fileext = ".rds")
[10:29:49.969]                     save_rds(obj, file)
[10:29:49.969]                   }
[10:29:49.969]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:49.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.969]                   {
[10:29:49.969]                     inherits <- base::inherits
[10:29:49.969]                     invokeRestart <- base::invokeRestart
[10:29:49.969]                     is.null <- base::is.null
[10:29:49.969]                     muffled <- FALSE
[10:29:49.969]                     if (inherits(cond, "message")) {
[10:29:49.969]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:49.969]                       if (muffled) 
[10:29:49.969]                         invokeRestart("muffleMessage")
[10:29:49.969]                     }
[10:29:49.969]                     else if (inherits(cond, "warning")) {
[10:29:49.969]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:49.969]                       if (muffled) 
[10:29:49.969]                         invokeRestart("muffleWarning")
[10:29:49.969]                     }
[10:29:49.969]                     else if (inherits(cond, "condition")) {
[10:29:49.969]                       if (!is.null(pattern)) {
[10:29:49.969]                         computeRestarts <- base::computeRestarts
[10:29:49.969]                         grepl <- base::grepl
[10:29:49.969]                         restarts <- computeRestarts(cond)
[10:29:49.969]                         for (restart in restarts) {
[10:29:49.969]                           name <- restart$name
[10:29:49.969]                           if (is.null(name)) 
[10:29:49.969]                             next
[10:29:49.969]                           if (!grepl(pattern, name)) 
[10:29:49.969]                             next
[10:29:49.969]                           invokeRestart(restart)
[10:29:49.969]                           muffled <- TRUE
[10:29:49.969]                           break
[10:29:49.969]                         }
[10:29:49.969]                       }
[10:29:49.969]                     }
[10:29:49.969]                     invisible(muffled)
[10:29:49.969]                   }
[10:29:49.969]                   muffleCondition(cond)
[10:29:49.969]                 })
[10:29:49.969]             }))
[10:29:49.969]             future::FutureResult(value = ...future.value$value, 
[10:29:49.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.969]                   ...future.rng), globalenv = if (FALSE) 
[10:29:49.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:49.969]                     ...future.globalenv.names))
[10:29:49.969]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:49.969]         }, condition = base::local({
[10:29:49.969]             c <- base::c
[10:29:49.969]             inherits <- base::inherits
[10:29:49.969]             invokeRestart <- base::invokeRestart
[10:29:49.969]             length <- base::length
[10:29:49.969]             list <- base::list
[10:29:49.969]             seq.int <- base::seq.int
[10:29:49.969]             signalCondition <- base::signalCondition
[10:29:49.969]             sys.calls <- base::sys.calls
[10:29:49.969]             `[[` <- base::`[[`
[10:29:49.969]             `+` <- base::`+`
[10:29:49.969]             `<<-` <- base::`<<-`
[10:29:49.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:49.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:49.969]                   3L)]
[10:29:49.969]             }
[10:29:49.969]             function(cond) {
[10:29:49.969]                 is_error <- inherits(cond, "error")
[10:29:49.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:49.969]                   NULL)
[10:29:49.969]                 if (is_error) {
[10:29:49.969]                   sessionInformation <- function() {
[10:29:49.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:49.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:49.969]                       search = base::search(), system = base::Sys.info())
[10:29:49.969]                   }
[10:29:49.969]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:49.969]                     cond$call), session = sessionInformation(), 
[10:29:49.969]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:49.969]                   signalCondition(cond)
[10:29:49.969]                 }
[10:29:49.969]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:29:49.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:49.969]                   ...future.conditions[[length(...future.conditions) + 
[10:29:49.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:49.969]                   if (TRUE && !signal) {
[10:29:49.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.969]                     {
[10:29:49.969]                       inherits <- base::inherits
[10:29:49.969]                       invokeRestart <- base::invokeRestart
[10:29:49.969]                       is.null <- base::is.null
[10:29:49.969]                       muffled <- FALSE
[10:29:49.969]                       if (inherits(cond, "message")) {
[10:29:49.969]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.969]                         if (muffled) 
[10:29:49.969]                           invokeRestart("muffleMessage")
[10:29:49.969]                       }
[10:29:49.969]                       else if (inherits(cond, "warning")) {
[10:29:49.969]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.969]                         if (muffled) 
[10:29:49.969]                           invokeRestart("muffleWarning")
[10:29:49.969]                       }
[10:29:49.969]                       else if (inherits(cond, "condition")) {
[10:29:49.969]                         if (!is.null(pattern)) {
[10:29:49.969]                           computeRestarts <- base::computeRestarts
[10:29:49.969]                           grepl <- base::grepl
[10:29:49.969]                           restarts <- computeRestarts(cond)
[10:29:49.969]                           for (restart in restarts) {
[10:29:49.969]                             name <- restart$name
[10:29:49.969]                             if (is.null(name)) 
[10:29:49.969]                               next
[10:29:49.969]                             if (!grepl(pattern, name)) 
[10:29:49.969]                               next
[10:29:49.969]                             invokeRestart(restart)
[10:29:49.969]                             muffled <- TRUE
[10:29:49.969]                             break
[10:29:49.969]                           }
[10:29:49.969]                         }
[10:29:49.969]                       }
[10:29:49.969]                       invisible(muffled)
[10:29:49.969]                     }
[10:29:49.969]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.969]                   }
[10:29:49.969]                 }
[10:29:49.969]                 else {
[10:29:49.969]                   if (TRUE) {
[10:29:49.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:49.969]                     {
[10:29:49.969]                       inherits <- base::inherits
[10:29:49.969]                       invokeRestart <- base::invokeRestart
[10:29:49.969]                       is.null <- base::is.null
[10:29:49.969]                       muffled <- FALSE
[10:29:49.969]                       if (inherits(cond, "message")) {
[10:29:49.969]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:49.969]                         if (muffled) 
[10:29:49.969]                           invokeRestart("muffleMessage")
[10:29:49.969]                       }
[10:29:49.969]                       else if (inherits(cond, "warning")) {
[10:29:49.969]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:49.969]                         if (muffled) 
[10:29:49.969]                           invokeRestart("muffleWarning")
[10:29:49.969]                       }
[10:29:49.969]                       else if (inherits(cond, "condition")) {
[10:29:49.969]                         if (!is.null(pattern)) {
[10:29:49.969]                           computeRestarts <- base::computeRestarts
[10:29:49.969]                           grepl <- base::grepl
[10:29:49.969]                           restarts <- computeRestarts(cond)
[10:29:49.969]                           for (restart in restarts) {
[10:29:49.969]                             name <- restart$name
[10:29:49.969]                             if (is.null(name)) 
[10:29:49.969]                               next
[10:29:49.969]                             if (!grepl(pattern, name)) 
[10:29:49.969]                               next
[10:29:49.969]                             invokeRestart(restart)
[10:29:49.969]                             muffled <- TRUE
[10:29:49.969]                             break
[10:29:49.969]                           }
[10:29:49.969]                         }
[10:29:49.969]                       }
[10:29:49.969]                       invisible(muffled)
[10:29:49.969]                     }
[10:29:49.969]                     muffleCondition(cond, pattern = "^muffle")
[10:29:49.969]                   }
[10:29:49.969]                 }
[10:29:49.969]             }
[10:29:49.969]         }))
[10:29:49.969]     }, error = function(ex) {
[10:29:49.969]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:49.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:49.969]                 ...future.rng), started = ...future.startTime, 
[10:29:49.969]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:49.969]             version = "1.8"), class = "FutureResult")
[10:29:49.969]     }, finally = {
[10:29:49.969]         if (!identical(...future.workdir, getwd())) 
[10:29:49.969]             setwd(...future.workdir)
[10:29:49.969]         {
[10:29:49.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:49.969]                 ...future.oldOptions$nwarnings <- NULL
[10:29:49.969]             }
[10:29:49.969]             base::options(...future.oldOptions)
[10:29:49.969]             if (.Platform$OS.type == "windows") {
[10:29:49.969]                 old_names <- names(...future.oldEnvVars)
[10:29:49.969]                 envs <- base::Sys.getenv()
[10:29:49.969]                 names <- names(envs)
[10:29:49.969]                 common <- intersect(names, old_names)
[10:29:49.969]                 added <- setdiff(names, old_names)
[10:29:49.969]                 removed <- setdiff(old_names, names)
[10:29:49.969]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:49.969]                   envs[common]]
[10:29:49.969]                 NAMES <- toupper(changed)
[10:29:49.969]                 args <- list()
[10:29:49.969]                 for (kk in seq_along(NAMES)) {
[10:29:49.969]                   name <- changed[[kk]]
[10:29:49.969]                   NAME <- NAMES[[kk]]
[10:29:49.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.969]                     next
[10:29:49.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.969]                 }
[10:29:49.969]                 NAMES <- toupper(added)
[10:29:49.969]                 for (kk in seq_along(NAMES)) {
[10:29:49.969]                   name <- added[[kk]]
[10:29:49.969]                   NAME <- NAMES[[kk]]
[10:29:49.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.969]                     next
[10:29:49.969]                   args[[name]] <- ""
[10:29:49.969]                 }
[10:29:49.969]                 NAMES <- toupper(removed)
[10:29:49.969]                 for (kk in seq_along(NAMES)) {
[10:29:49.969]                   name <- removed[[kk]]
[10:29:49.969]                   NAME <- NAMES[[kk]]
[10:29:49.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:49.969]                     next
[10:29:49.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:49.969]                 }
[10:29:49.969]                 if (length(args) > 0) 
[10:29:49.969]                   base::do.call(base::Sys.setenv, args = args)
[10:29:49.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:49.969]             }
[10:29:49.969]             else {
[10:29:49.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:49.969]             }
[10:29:49.969]             {
[10:29:49.969]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:49.969]                   0L) {
[10:29:49.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:49.969]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:49.969]                   base::options(opts)
[10:29:49.969]                 }
[10:29:49.969]                 {
[10:29:49.969]                   {
[10:29:49.969]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:49.969]                     NULL
[10:29:49.969]                   }
[10:29:49.969]                   options(future.plan = NULL)
[10:29:49.969]                   if (is.na(NA_character_)) 
[10:29:49.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:49.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:49.969]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:49.969]                     .init = FALSE)
[10:29:49.969]                 }
[10:29:49.969]             }
[10:29:49.969]         }
[10:29:49.969]     })
[10:29:49.969]     if (TRUE) {
[10:29:49.969]         base::sink(type = "output", split = FALSE)
[10:29:49.969]         if (TRUE) {
[10:29:49.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:49.969]         }
[10:29:49.969]         else {
[10:29:49.969]             ...future.result["stdout"] <- base::list(NULL)
[10:29:49.969]         }
[10:29:49.969]         base::close(...future.stdout)
[10:29:49.969]         ...future.stdout <- NULL
[10:29:49.969]     }
[10:29:49.969]     ...future.result$conditions <- ...future.conditions
[10:29:49.969]     ...future.result$finished <- base::Sys.time()
[10:29:49.969]     ...future.result
[10:29:49.969] }
[10:29:49.972] assign_globals() ...
[10:29:49.972] List of 5
[10:29:49.972]  $ future.call.arguments    : list()
[10:29:49.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:49.972]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:29:49.972]  $ ...future.elements_ii    :List of 1
[10:29:49.972]   ..$ : int [1:2] 1 3
[10:29:49.972]  $ ...future.seeds_ii       :List of 1
[10:29:49.972]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:29:49.972]  $ ...future.globals.maxSize: num Inf
[10:29:49.972]  - attr(*, "resolved")= logi FALSE
[10:29:49.972]  - attr(*, "total_size")= num NA
[10:29:49.972]  - attr(*, "where")=List of 5
[10:29:49.972]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:49.972]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:49.972]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:49.972]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:49.972]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:49.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:49.972]  - attr(*, "already-done")= logi TRUE
[10:29:49.979] - copied ‘future.call.arguments’ to environment
[10:29:49.979] - copied ‘...future.FUN’ to environment
[10:29:49.979] - copied ‘...future.elements_ii’ to environment
[10:29:49.980] - copied ‘...future.seeds_ii’ to environment
[10:29:49.980] - copied ‘...future.globals.maxSize’ to environment
[10:29:49.980] assign_globals() ... done
[10:29:49.980] requestCore(): workers = 2
[10:29:49.982] MulticoreFuture started
[10:29:49.983] - Launch lazy future ... done
[10:29:49.984] plan(): Setting new future strategy stack:
[10:29:49.984] run() for ‘MulticoreFuture’ ... done
[10:29:49.984] Created future:
[10:29:49.984] List of future strategies:
[10:29:49.984] 1. sequential:
[10:29:49.984]    - args: function (..., envir = parent.frame())
[10:29:49.984]    - tweaked: FALSE
[10:29:49.984]    - call: NULL
[10:29:49.985] plan(): nbrOfWorkers() = 1
[10:29:49.988] plan(): Setting new future strategy stack:
[10:29:49.988] List of future strategies:
[10:29:49.988] 1. multicore:
[10:29:49.988]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:49.988]    - tweaked: FALSE
[10:29:49.988]    - call: plan(strategy)
[10:29:49.994] plan(): nbrOfWorkers() = 2
[10:29:49.985] MulticoreFuture:
[10:29:49.985] Label: ‘future_apply-1’
[10:29:49.985] Expression:
[10:29:49.985] {
[10:29:49.985]     do.call(function(...) {
[10:29:49.985]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.985]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.985]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.985]             on.exit(options(oopts), add = TRUE)
[10:29:49.985]         }
[10:29:49.985]         {
[10:29:49.985]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.985]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.985]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:49.985]                   envir = globalenv(), inherits = FALSE)
[10:29:49.985]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.985]             })
[10:29:49.985]         }
[10:29:49.985]     }, args = future.call.arguments)
[10:29:49.985] }
[10:29:49.985] Lazy evaluation: FALSE
[10:29:49.985] Asynchronous evaluation: TRUE
[10:29:49.985] Local evaluation: TRUE
[10:29:49.985] Environment: R_GlobalEnv
[10:29:49.985] Capture standard output: TRUE
[10:29:49.985] Capture condition classes: <none>
[10:29:49.985] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:49.985] Packages: <none>
[10:29:49.985] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:29:49.985] Resolved: TRUE
[10:29:49.985] Value: <not collected>
[10:29:49.985] Conditions captured: <none>
[10:29:49.985] Early signaling: FALSE
[10:29:49.985] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:49.985] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:49.995] Chunk #1 of 2 ... DONE
[10:29:49.995] Chunk #2 of 2 ...
[10:29:49.995]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:49.995]  - seeds: [1] <seeds>
[10:29:49.996]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.996] getGlobalsAndPackages() ...
[10:29:49.996] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.996] Resolving globals: FALSE
[10:29:49.996] Tweak future expression to call with '...' arguments ...
[10:29:49.997] {
[10:29:49.997]     do.call(function(...) {
[10:29:49.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:49.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:49.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:49.997]             on.exit(options(oopts), add = TRUE)
[10:29:49.997]         }
[10:29:49.997]         {
[10:29:49.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:49.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:49.997]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:49.997]                   envir = globalenv(), inherits = FALSE)
[10:29:49.997]                 ...future.FUN(...future.X_jj, ...)
[10:29:49.997]             })
[10:29:49.997]         }
[10:29:49.997]     }, args = future.call.arguments)
[10:29:49.997] }
[10:29:49.997] Tweak future expression to call with '...' arguments ... DONE
[10:29:49.998] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:49.998] 
[10:29:49.998] getGlobalsAndPackages() ... DONE
[10:29:49.999] run() for ‘Future’ ...
[10:29:49.999] - state: ‘created’
[10:29:50.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:50.004] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:50.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:50.005]   - Field: ‘label’
[10:29:50.005]   - Field: ‘local’
[10:29:50.005]   - Field: ‘owner’
[10:29:50.006]   - Field: ‘envir’
[10:29:50.006]   - Field: ‘workers’
[10:29:50.006]   - Field: ‘packages’
[10:29:50.006]   - Field: ‘gc’
[10:29:50.006]   - Field: ‘job’
[10:29:50.006]   - Field: ‘conditions’
[10:29:50.006]   - Field: ‘expr’
[10:29:50.006]   - Field: ‘uuid’
[10:29:50.007]   - Field: ‘seed’
[10:29:50.007]   - Field: ‘version’
[10:29:50.007]   - Field: ‘result’
[10:29:50.007]   - Field: ‘asynchronous’
[10:29:50.007]   - Field: ‘calls’
[10:29:50.007]   - Field: ‘globals’
[10:29:50.007]   - Field: ‘stdout’
[10:29:50.008]   - Field: ‘earlySignal’
[10:29:50.008]   - Field: ‘lazy’
[10:29:50.008]   - Field: ‘state’
[10:29:50.008] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:50.008] - Launch lazy future ...
[10:29:50.008] Packages needed by the future expression (n = 0): <none>
[10:29:50.009] Packages needed by future strategies (n = 0): <none>
[10:29:50.009] {
[10:29:50.009]     {
[10:29:50.009]         {
[10:29:50.009]             ...future.startTime <- base::Sys.time()
[10:29:50.009]             {
[10:29:50.009]                 {
[10:29:50.009]                   {
[10:29:50.009]                     {
[10:29:50.009]                       base::local({
[10:29:50.009]                         has_future <- base::requireNamespace("future", 
[10:29:50.009]                           quietly = TRUE)
[10:29:50.009]                         if (has_future) {
[10:29:50.009]                           ns <- base::getNamespace("future")
[10:29:50.009]                           version <- ns[[".package"]][["version"]]
[10:29:50.009]                           if (is.null(version)) 
[10:29:50.009]                             version <- utils::packageVersion("future")
[10:29:50.009]                         }
[10:29:50.009]                         else {
[10:29:50.009]                           version <- NULL
[10:29:50.009]                         }
[10:29:50.009]                         if (!has_future || version < "1.8.0") {
[10:29:50.009]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:50.009]                             "", base::R.version$version.string), 
[10:29:50.009]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:50.009]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:50.009]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:50.009]                               "release", "version")], collapse = " "), 
[10:29:50.009]                             hostname = base::Sys.info()[["nodename"]])
[10:29:50.009]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:50.009]                             info)
[10:29:50.009]                           info <- base::paste(info, collapse = "; ")
[10:29:50.009]                           if (!has_future) {
[10:29:50.009]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:50.009]                               info)
[10:29:50.009]                           }
[10:29:50.009]                           else {
[10:29:50.009]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:50.009]                               info, version)
[10:29:50.009]                           }
[10:29:50.009]                           base::stop(msg)
[10:29:50.009]                         }
[10:29:50.009]                       })
[10:29:50.009]                     }
[10:29:50.009]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:50.009]                     base::options(mc.cores = 1L)
[10:29:50.009]                   }
[10:29:50.009]                   ...future.strategy.old <- future::plan("list")
[10:29:50.009]                   options(future.plan = NULL)
[10:29:50.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:50.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:50.009]                 }
[10:29:50.009]                 ...future.workdir <- getwd()
[10:29:50.009]             }
[10:29:50.009]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:50.009]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:50.009]         }
[10:29:50.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:50.009]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:50.009]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:50.009]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:50.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:50.009]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:50.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:50.009]             base::names(...future.oldOptions))
[10:29:50.009]     }
[10:29:50.009]     if (FALSE) {
[10:29:50.009]     }
[10:29:50.009]     else {
[10:29:50.009]         if (TRUE) {
[10:29:50.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:50.009]                 open = "w")
[10:29:50.009]         }
[10:29:50.009]         else {
[10:29:50.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:50.009]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:50.009]         }
[10:29:50.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:50.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:50.009]             base::sink(type = "output", split = FALSE)
[10:29:50.009]             base::close(...future.stdout)
[10:29:50.009]         }, add = TRUE)
[10:29:50.009]     }
[10:29:50.009]     ...future.frame <- base::sys.nframe()
[10:29:50.009]     ...future.conditions <- base::list()
[10:29:50.009]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:50.009]     if (FALSE) {
[10:29:50.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:50.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:50.009]     }
[10:29:50.009]     ...future.result <- base::tryCatch({
[10:29:50.009]         base::withCallingHandlers({
[10:29:50.009]             ...future.value <- base::withVisible(base::local({
[10:29:50.009]                 withCallingHandlers({
[10:29:50.009]                   {
[10:29:50.009]                     do.call(function(...) {
[10:29:50.009]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:50.009]                       if (!identical(...future.globals.maxSize.org, 
[10:29:50.009]                         ...future.globals.maxSize)) {
[10:29:50.009]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:50.009]                         on.exit(options(oopts), add = TRUE)
[10:29:50.009]                       }
[10:29:50.009]                       {
[10:29:50.009]                         lapply(seq_along(...future.elements_ii), 
[10:29:50.009]                           FUN = function(jj) {
[10:29:50.009]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:50.009]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:50.009]                               envir = globalenv(), inherits = FALSE)
[10:29:50.009]                             ...future.FUN(...future.X_jj, ...)
[10:29:50.009]                           })
[10:29:50.009]                       }
[10:29:50.009]                     }, args = future.call.arguments)
[10:29:50.009]                   }
[10:29:50.009]                 }, immediateCondition = function(cond) {
[10:29:50.009]                   save_rds <- function (object, pathname, ...) 
[10:29:50.009]                   {
[10:29:50.009]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:50.009]                     if (file_test("-f", pathname_tmp)) {
[10:29:50.009]                       fi_tmp <- file.info(pathname_tmp)
[10:29:50.009]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:50.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:50.009]                         fi_tmp[["mtime"]])
[10:29:50.009]                     }
[10:29:50.009]                     tryCatch({
[10:29:50.009]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:50.009]                     }, error = function(ex) {
[10:29:50.009]                       msg <- conditionMessage(ex)
[10:29:50.009]                       fi_tmp <- file.info(pathname_tmp)
[10:29:50.009]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:50.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:50.009]                         fi_tmp[["mtime"]], msg)
[10:29:50.009]                       ex$message <- msg
[10:29:50.009]                       stop(ex)
[10:29:50.009]                     })
[10:29:50.009]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:50.009]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:50.009]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:50.009]                       fi_tmp <- file.info(pathname_tmp)
[10:29:50.009]                       fi <- file.info(pathname)
[10:29:50.009]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:50.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:50.009]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:50.009]                         fi[["size"]], fi[["mtime"]])
[10:29:50.009]                       stop(msg)
[10:29:50.009]                     }
[10:29:50.009]                     invisible(pathname)
[10:29:50.009]                   }
[10:29:50.009]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:50.009]                     rootPath = tempdir()) 
[10:29:50.009]                   {
[10:29:50.009]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:50.009]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:50.009]                       tmpdir = path, fileext = ".rds")
[10:29:50.009]                     save_rds(obj, file)
[10:29:50.009]                   }
[10:29:50.009]                   saveImmediateCondition(cond, path = "/tmp/RtmphAianP/.future/immediateConditions")
[10:29:50.009]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.009]                   {
[10:29:50.009]                     inherits <- base::inherits
[10:29:50.009]                     invokeRestart <- base::invokeRestart
[10:29:50.009]                     is.null <- base::is.null
[10:29:50.009]                     muffled <- FALSE
[10:29:50.009]                     if (inherits(cond, "message")) {
[10:29:50.009]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:50.009]                       if (muffled) 
[10:29:50.009]                         invokeRestart("muffleMessage")
[10:29:50.009]                     }
[10:29:50.009]                     else if (inherits(cond, "warning")) {
[10:29:50.009]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:50.009]                       if (muffled) 
[10:29:50.009]                         invokeRestart("muffleWarning")
[10:29:50.009]                     }
[10:29:50.009]                     else if (inherits(cond, "condition")) {
[10:29:50.009]                       if (!is.null(pattern)) {
[10:29:50.009]                         computeRestarts <- base::computeRestarts
[10:29:50.009]                         grepl <- base::grepl
[10:29:50.009]                         restarts <- computeRestarts(cond)
[10:29:50.009]                         for (restart in restarts) {
[10:29:50.009]                           name <- restart$name
[10:29:50.009]                           if (is.null(name)) 
[10:29:50.009]                             next
[10:29:50.009]                           if (!grepl(pattern, name)) 
[10:29:50.009]                             next
[10:29:50.009]                           invokeRestart(restart)
[10:29:50.009]                           muffled <- TRUE
[10:29:50.009]                           break
[10:29:50.009]                         }
[10:29:50.009]                       }
[10:29:50.009]                     }
[10:29:50.009]                     invisible(muffled)
[10:29:50.009]                   }
[10:29:50.009]                   muffleCondition(cond)
[10:29:50.009]                 })
[10:29:50.009]             }))
[10:29:50.009]             future::FutureResult(value = ...future.value$value, 
[10:29:50.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:50.009]                   ...future.rng), globalenv = if (FALSE) 
[10:29:50.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:50.009]                     ...future.globalenv.names))
[10:29:50.009]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:50.009]         }, condition = base::local({
[10:29:50.009]             c <- base::c
[10:29:50.009]             inherits <- base::inherits
[10:29:50.009]             invokeRestart <- base::invokeRestart
[10:29:50.009]             length <- base::length
[10:29:50.009]             list <- base::list
[10:29:50.009]             seq.int <- base::seq.int
[10:29:50.009]             signalCondition <- base::signalCondition
[10:29:50.009]             sys.calls <- base::sys.calls
[10:29:50.009]             `[[` <- base::`[[`
[10:29:50.009]             `+` <- base::`+`
[10:29:50.009]             `<<-` <- base::`<<-`
[10:29:50.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:50.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:50.009]                   3L)]
[10:29:50.009]             }
[10:29:50.009]             function(cond) {
[10:29:50.009]                 is_error <- inherits(cond, "error")
[10:29:50.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:50.009]                   NULL)
[10:29:50.009]                 if (is_error) {
[10:29:50.009]                   sessionInformation <- function() {
[10:29:50.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:50.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:50.009]                       search = base::search(), system = base::Sys.info())
[10:29:50.009]                   }
[10:29:50.009]                   ...future.conditions[[length(...future.conditions) + 
[10:29:50.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:50.009]                     cond$call), session = sessionInformation(), 
[10:29:50.009]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:50.009]                   signalCondition(cond)
[10:29:50.009]                 }
[10:29:50.009]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:29:50.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:50.009]                   ...future.conditions[[length(...future.conditions) + 
[10:29:50.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:50.009]                   if (TRUE && !signal) {
[10:29:50.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.009]                     {
[10:29:50.009]                       inherits <- base::inherits
[10:29:50.009]                       invokeRestart <- base::invokeRestart
[10:29:50.009]                       is.null <- base::is.null
[10:29:50.009]                       muffled <- FALSE
[10:29:50.009]                       if (inherits(cond, "message")) {
[10:29:50.009]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:50.009]                         if (muffled) 
[10:29:50.009]                           invokeRestart("muffleMessage")
[10:29:50.009]                       }
[10:29:50.009]                       else if (inherits(cond, "warning")) {
[10:29:50.009]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:50.009]                         if (muffled) 
[10:29:50.009]                           invokeRestart("muffleWarning")
[10:29:50.009]                       }
[10:29:50.009]                       else if (inherits(cond, "condition")) {
[10:29:50.009]                         if (!is.null(pattern)) {
[10:29:50.009]                           computeRestarts <- base::computeRestarts
[10:29:50.009]                           grepl <- base::grepl
[10:29:50.009]                           restarts <- computeRestarts(cond)
[10:29:50.009]                           for (restart in restarts) {
[10:29:50.009]                             name <- restart$name
[10:29:50.009]                             if (is.null(name)) 
[10:29:50.009]                               next
[10:29:50.009]                             if (!grepl(pattern, name)) 
[10:29:50.009]                               next
[10:29:50.009]                             invokeRestart(restart)
[10:29:50.009]                             muffled <- TRUE
[10:29:50.009]                             break
[10:29:50.009]                           }
[10:29:50.009]                         }
[10:29:50.009]                       }
[10:29:50.009]                       invisible(muffled)
[10:29:50.009]                     }
[10:29:50.009]                     muffleCondition(cond, pattern = "^muffle")
[10:29:50.009]                   }
[10:29:50.009]                 }
[10:29:50.009]                 else {
[10:29:50.009]                   if (TRUE) {
[10:29:50.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.009]                     {
[10:29:50.009]                       inherits <- base::inherits
[10:29:50.009]                       invokeRestart <- base::invokeRestart
[10:29:50.009]                       is.null <- base::is.null
[10:29:50.009]                       muffled <- FALSE
[10:29:50.009]                       if (inherits(cond, "message")) {
[10:29:50.009]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:50.009]                         if (muffled) 
[10:29:50.009]                           invokeRestart("muffleMessage")
[10:29:50.009]                       }
[10:29:50.009]                       else if (inherits(cond, "warning")) {
[10:29:50.009]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:50.009]                         if (muffled) 
[10:29:50.009]                           invokeRestart("muffleWarning")
[10:29:50.009]                       }
[10:29:50.009]                       else if (inherits(cond, "condition")) {
[10:29:50.009]                         if (!is.null(pattern)) {
[10:29:50.009]                           computeRestarts <- base::computeRestarts
[10:29:50.009]                           grepl <- base::grepl
[10:29:50.009]                           restarts <- computeRestarts(cond)
[10:29:50.009]                           for (restart in restarts) {
[10:29:50.009]                             name <- restart$name
[10:29:50.009]                             if (is.null(name)) 
[10:29:50.009]                               next
[10:29:50.009]                             if (!grepl(pattern, name)) 
[10:29:50.009]                               next
[10:29:50.009]                             invokeRestart(restart)
[10:29:50.009]                             muffled <- TRUE
[10:29:50.009]                             break
[10:29:50.009]                           }
[10:29:50.009]                         }
[10:29:50.009]                       }
[10:29:50.009]                       invisible(muffled)
[10:29:50.009]                     }
[10:29:50.009]                     muffleCondition(cond, pattern = "^muffle")
[10:29:50.009]                   }
[10:29:50.009]                 }
[10:29:50.009]             }
[10:29:50.009]         }))
[10:29:50.009]     }, error = function(ex) {
[10:29:50.009]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:50.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:50.009]                 ...future.rng), started = ...future.startTime, 
[10:29:50.009]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:50.009]             version = "1.8"), class = "FutureResult")
[10:29:50.009]     }, finally = {
[10:29:50.009]         if (!identical(...future.workdir, getwd())) 
[10:29:50.009]             setwd(...future.workdir)
[10:29:50.009]         {
[10:29:50.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:50.009]                 ...future.oldOptions$nwarnings <- NULL
[10:29:50.009]             }
[10:29:50.009]             base::options(...future.oldOptions)
[10:29:50.009]             if (.Platform$OS.type == "windows") {
[10:29:50.009]                 old_names <- names(...future.oldEnvVars)
[10:29:50.009]                 envs <- base::Sys.getenv()
[10:29:50.009]                 names <- names(envs)
[10:29:50.009]                 common <- intersect(names, old_names)
[10:29:50.009]                 added <- setdiff(names, old_names)
[10:29:50.009]                 removed <- setdiff(old_names, names)
[10:29:50.009]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:50.009]                   envs[common]]
[10:29:50.009]                 NAMES <- toupper(changed)
[10:29:50.009]                 args <- list()
[10:29:50.009]                 for (kk in seq_along(NAMES)) {
[10:29:50.009]                   name <- changed[[kk]]
[10:29:50.009]                   NAME <- NAMES[[kk]]
[10:29:50.009]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.009]                     next
[10:29:50.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:50.009]                 }
[10:29:50.009]                 NAMES <- toupper(added)
[10:29:50.009]                 for (kk in seq_along(NAMES)) {
[10:29:50.009]                   name <- added[[kk]]
[10:29:50.009]                   NAME <- NAMES[[kk]]
[10:29:50.009]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.009]                     next
[10:29:50.009]                   args[[name]] <- ""
[10:29:50.009]                 }
[10:29:50.009]                 NAMES <- toupper(removed)
[10:29:50.009]                 for (kk in seq_along(NAMES)) {
[10:29:50.009]                   name <- removed[[kk]]
[10:29:50.009]                   NAME <- NAMES[[kk]]
[10:29:50.009]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.009]                     next
[10:29:50.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:50.009]                 }
[10:29:50.009]                 if (length(args) > 0) 
[10:29:50.009]                   base::do.call(base::Sys.setenv, args = args)
[10:29:50.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:50.009]             }
[10:29:50.009]             else {
[10:29:50.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:50.009]             }
[10:29:50.009]             {
[10:29:50.009]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:50.009]                   0L) {
[10:29:50.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:50.009]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:50.009]                   base::options(opts)
[10:29:50.009]                 }
[10:29:50.009]                 {
[10:29:50.009]                   {
[10:29:50.009]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:50.009]                     NULL
[10:29:50.009]                   }
[10:29:50.009]                   options(future.plan = NULL)
[10:29:50.009]                   if (is.na(NA_character_)) 
[10:29:50.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:50.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:50.009]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:50.009]                     .init = FALSE)
[10:29:50.009]                 }
[10:29:50.009]             }
[10:29:50.009]         }
[10:29:50.009]     })
[10:29:50.009]     if (TRUE) {
[10:29:50.009]         base::sink(type = "output", split = FALSE)
[10:29:50.009]         if (TRUE) {
[10:29:50.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:50.009]         }
[10:29:50.009]         else {
[10:29:50.009]             ...future.result["stdout"] <- base::list(NULL)
[10:29:50.009]         }
[10:29:50.009]         base::close(...future.stdout)
[10:29:50.009]         ...future.stdout <- NULL
[10:29:50.009]     }
[10:29:50.009]     ...future.result$conditions <- ...future.conditions
[10:29:50.009]     ...future.result$finished <- base::Sys.time()
[10:29:50.009]     ...future.result
[10:29:50.009] }
[10:29:50.013] assign_globals() ...
[10:29:50.013] List of 5
[10:29:50.013]  $ future.call.arguments    : list()
[10:29:50.013]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:50.013]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:29:50.013]  $ ...future.elements_ii    :List of 1
[10:29:50.013]   ..$ : int [1:2] 2 4
[10:29:50.013]  $ ...future.seeds_ii       :List of 1
[10:29:50.013]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:29:50.013]  $ ...future.globals.maxSize: num Inf
[10:29:50.013]  - attr(*, "resolved")= logi FALSE
[10:29:50.013]  - attr(*, "total_size")= num NA
[10:29:50.013]  - attr(*, "where")=List of 5
[10:29:50.013]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:50.013]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:50.013]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:50.013]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:50.013]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:50.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:50.013]  - attr(*, "already-done")= logi TRUE
[10:29:50.020] - copied ‘future.call.arguments’ to environment
[10:29:50.020] - copied ‘...future.FUN’ to environment
[10:29:50.020] - copied ‘...future.elements_ii’ to environment
[10:29:50.021] - copied ‘...future.seeds_ii’ to environment
[10:29:50.021] - copied ‘...future.globals.maxSize’ to environment
[10:29:50.021] assign_globals() ... done
[10:29:50.021] requestCore(): workers = 2
[10:29:50.023] MulticoreFuture started
[10:29:50.024] - Launch lazy future ... done
[10:29:50.024] run() for ‘MulticoreFuture’ ... done
[10:29:50.024] Created future:
[10:29:50.024] plan(): Setting new future strategy stack:
[10:29:50.025] List of future strategies:
[10:29:50.025] 1. sequential:
[10:29:50.025]    - args: function (..., envir = parent.frame())
[10:29:50.025]    - tweaked: FALSE
[10:29:50.025]    - call: NULL
[10:29:50.025] plan(): nbrOfWorkers() = 1
[10:29:50.032] plan(): Setting new future strategy stack:
[10:29:50.032] List of future strategies:
[10:29:50.032] 1. multicore:
[10:29:50.032]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:50.032]    - tweaked: FALSE
[10:29:50.032]    - call: plan(strategy)
[10:29:50.040] plan(): nbrOfWorkers() = 2
[10:29:50.024] MulticoreFuture:
[10:29:50.024] Label: ‘future_apply-2’
[10:29:50.024] Expression:
[10:29:50.024] {
[10:29:50.024]     do.call(function(...) {
[10:29:50.024]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:50.024]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:50.024]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:50.024]             on.exit(options(oopts), add = TRUE)
[10:29:50.024]         }
[10:29:50.024]         {
[10:29:50.024]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:50.024]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:50.024]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:50.024]                   envir = globalenv(), inherits = FALSE)
[10:29:50.024]                 ...future.FUN(...future.X_jj, ...)
[10:29:50.024]             })
[10:29:50.024]         }
[10:29:50.024]     }, args = future.call.arguments)
[10:29:50.024] }
[10:29:50.024] Lazy evaluation: FALSE
[10:29:50.024] Asynchronous evaluation: TRUE
[10:29:50.024] Local evaluation: TRUE
[10:29:50.024] Environment: R_GlobalEnv
[10:29:50.024] Capture standard output: TRUE
[10:29:50.024] Capture condition classes: <none>
[10:29:50.024] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:50.024] Packages: <none>
[10:29:50.024] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:29:50.024] Resolved: FALSE
[10:29:50.024] Value: <not collected>
[10:29:50.024] Conditions captured: <none>
[10:29:50.024] Early signaling: FALSE
[10:29:50.024] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:50.024] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:50.041] Chunk #2 of 2 ... DONE
[10:29:50.041] Launching 2 futures (chunks) ... DONE
[10:29:50.042] Resolving 2 futures (chunks) ...
[10:29:50.042] resolve() on list ...
[10:29:50.042]  recursive: 0
[10:29:50.043]  length: 2
[10:29:50.043] 
[10:29:50.043] Future #1
[10:29:50.043] result() for MulticoreFuture ...
[10:29:50.045] result() for MulticoreFuture ...
[10:29:50.045] result() for MulticoreFuture ... done
[10:29:50.045] result() for MulticoreFuture ... done
[10:29:50.045] result() for MulticoreFuture ...
[10:29:50.046] result() for MulticoreFuture ... done
[10:29:50.046] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:50.046] - nx: 2
[10:29:50.047] - relay: TRUE
[10:29:50.047] - stdout: TRUE
[10:29:50.047] - signal: TRUE
[10:29:50.047] - resignal: FALSE
[10:29:50.047] - force: TRUE
[10:29:50.048] - relayed: [n=2] FALSE, FALSE
[10:29:50.048] - queued futures: [n=2] FALSE, FALSE
[10:29:50.048]  - until=1
[10:29:50.048]  - relaying element #1
[10:29:50.049] result() for MulticoreFuture ...
[10:29:50.049] result() for MulticoreFuture ... done
[10:29:50.049] result() for MulticoreFuture ...
[10:29:50.049] result() for MulticoreFuture ... done
[10:29:50.050] result() for MulticoreFuture ...
[10:29:50.050] result() for MulticoreFuture ... done
[10:29:50.050] result() for MulticoreFuture ...
[10:29:50.051] result() for MulticoreFuture ... done
[10:29:50.051] - relayed: [n=2] TRUE, FALSE
[10:29:50.051] - queued futures: [n=2] TRUE, FALSE
[10:29:50.051] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:50.051]  length: 1 (resolved future 1)
[10:29:50.052] Future #2
[10:29:50.052] result() for MulticoreFuture ...
[10:29:50.053] result() for MulticoreFuture ...
[10:29:50.053] result() for MulticoreFuture ... done
[10:29:50.053] result() for MulticoreFuture ... done
[10:29:50.053] result() for MulticoreFuture ...
[10:29:50.053] result() for MulticoreFuture ... done
[10:29:50.053] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:50.053] - nx: 2
[10:29:50.053] - relay: TRUE
[10:29:50.054] - stdout: TRUE
[10:29:50.054] - signal: TRUE
[10:29:50.054] - resignal: FALSE
[10:29:50.054] - force: TRUE
[10:29:50.054] - relayed: [n=2] TRUE, FALSE
[10:29:50.054] - queued futures: [n=2] TRUE, FALSE
[10:29:50.055]  - until=2
[10:29:50.055]  - relaying element #2
[10:29:50.055] result() for MulticoreFuture ...
[10:29:50.055] result() for MulticoreFuture ... done
[10:29:50.055] result() for MulticoreFuture ...
[10:29:50.055] result() for MulticoreFuture ... done
[10:29:50.055] result() for MulticoreFuture ...
[10:29:50.055] result() for MulticoreFuture ... done
[10:29:50.056] result() for MulticoreFuture ...
[10:29:50.056] result() for MulticoreFuture ... done
[10:29:50.056] - relayed: [n=2] TRUE, TRUE
[10:29:50.056] - queued futures: [n=2] TRUE, TRUE
[10:29:50.056] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:50.056]  length: 0 (resolved future 2)
[10:29:50.056] Relaying remaining futures
[10:29:50.056] signalConditionsASAP(NULL, pos=0) ...
[10:29:50.056] - nx: 2
[10:29:50.057] - relay: TRUE
[10:29:50.057] - stdout: TRUE
[10:29:50.057] - signal: TRUE
[10:29:50.057] - resignal: FALSE
[10:29:50.057] - force: TRUE
[10:29:50.057] - relayed: [n=2] TRUE, TRUE
[10:29:50.057] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:50.057] - relayed: [n=2] TRUE, TRUE
[10:29:50.057] - queued futures: [n=2] TRUE, TRUE
[10:29:50.058] signalConditionsASAP(NULL, pos=0) ... done
[10:29:50.058] resolve() on list ... DONE
[10:29:50.058] result() for MulticoreFuture ...
[10:29:50.058] result() for MulticoreFuture ... done
[10:29:50.058] result() for MulticoreFuture ...
[10:29:50.058] result() for MulticoreFuture ... done
[10:29:50.058] result() for MulticoreFuture ...
[10:29:50.058] result() for MulticoreFuture ... done
[10:29:50.058] result() for MulticoreFuture ...
[10:29:50.059] result() for MulticoreFuture ... done
[10:29:50.059]  - Number of value chunks collected: 2
[10:29:50.059] Resolving 2 futures (chunks) ... DONE
[10:29:50.059] Reducing values from 2 chunks ...
[10:29:50.059]  - Number of values collected after concatenation: 2
[10:29:50.059]  - Number of values expected: 2
[10:29:50.059] Reducing values from 2 chunks ... DONE
[10:29:50.059] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:29:50.060] plan(): Setting new future strategy stack:
[10:29:50.060] List of future strategies:
[10:29:50.060] 1. sequential:
[10:29:50.060]    - args: function (..., envir = parent.frame())
[10:29:50.060]    - tweaked: FALSE
[10:29:50.060]    - call: plan(sequential)
[10:29:50.060] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:29:50.061] plan(): Setting new future strategy stack:
[10:29:50.061] List of future strategies:
[10:29:50.061] 1. multisession:
[10:29:50.061]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:50.061]    - tweaked: FALSE
[10:29:50.061]    - call: plan(strategy)
[10:29:50.061] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:29:50.061] multisession:
[10:29:50.061] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:50.061] - tweaked: FALSE
[10:29:50.061] - call: plan(strategy)
[10:29:50.068] getGlobalsAndPackages() ...
[10:29:50.068] Not searching for globals
[10:29:50.068] - globals: [0] <none>
[10:29:50.068] getGlobalsAndPackages() ... DONE
[10:29:50.069] [local output] makeClusterPSOCK() ...
[10:29:50.114] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:29:50.115] [local output] Base port: 11359
[10:29:50.116] [local output] Getting setup options for 2 cluster nodes ...
[10:29:50.116] [local output]  - Node 1 of 2 ...
[10:29:50.116] [local output] localMachine=TRUE => revtunnel=FALSE

[10:29:50.117] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmphAianP/worker.rank=1.parallelly.parent=68040.109c815ce7bdf.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmphAianP/worker.rank=1.parallelly.parent=68040.109c815ce7bdf.pid")'’
[10:29:50.308] - Possible to infer worker's PID: TRUE
[10:29:50.308] [local output] Rscript port: 11359

[10:29:50.308] [local output]  - Node 2 of 2 ...
[10:29:50.309] [local output] localMachine=TRUE => revtunnel=FALSE

[10:29:50.309] [local output] Rscript port: 11359

[10:29:50.310] [local output] Getting setup options for 2 cluster nodes ... done
[10:29:50.310] [local output]  - Parallel setup requested for some PSOCK nodes
[10:29:50.310] [local output] Setting up PSOCK nodes in parallel
[10:29:50.310] List of 36
[10:29:50.310]  $ worker          : chr "localhost"
[10:29:50.310]   ..- attr(*, "localhost")= logi TRUE
[10:29:50.310]  $ master          : chr "localhost"
[10:29:50.310]  $ port            : int 11359
[10:29:50.310]  $ connectTimeout  : num 120
[10:29:50.310]  $ timeout         : num 2592000
[10:29:50.310]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:29:50.310]  $ homogeneous     : logi TRUE
[10:29:50.310]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:29:50.310]  $ rscript_envs    : NULL
[10:29:50.310]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:29:50.310]  $ rscript_startup : NULL
[10:29:50.310]  $ rscript_sh      : chr "sh"
[10:29:50.310]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:29:50.310]  $ methods         : logi TRUE
[10:29:50.310]  $ socketOptions   : chr "no-delay"
[10:29:50.310]  $ useXDR          : logi FALSE
[10:29:50.310]  $ outfile         : chr "/dev/null"
[10:29:50.310]  $ renice          : int NA
[10:29:50.310]  $ rshcmd          : NULL
[10:29:50.310]  $ user            : chr(0) 
[10:29:50.310]  $ revtunnel       : logi FALSE
[10:29:50.310]  $ rshlogfile      : NULL
[10:29:50.310]  $ rshopts         : chr(0) 
[10:29:50.310]  $ rank            : int 1
[10:29:50.310]  $ manual          : logi FALSE
[10:29:50.310]  $ dryrun          : logi FALSE
[10:29:50.310]  $ quiet           : logi FALSE
[10:29:50.310]  $ setup_strategy  : chr "parallel"
[10:29:50.310]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:29:50.310]  $ pidfile         : chr "/tmp/RtmphAianP/worker.rank=1.parallelly.parent=68040.109c815ce7bdf.pid"
[10:29:50.310]  $ rshcmd_label    : NULL
[10:29:50.310]  $ rsh_call        : NULL
[10:29:50.310]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:29:50.310]  $ localMachine    : logi TRUE
[10:29:50.310]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:29:50.310]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:29:50.310]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:29:50.310]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:29:50.310]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:29:50.310]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:29:50.310]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:29:50.310]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:29:50.310]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:29:50.310]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:29:50.310]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:29:50.310]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:29:50.310]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:29:50.310]  $ arguments       :List of 28
[10:29:50.310]   ..$ worker          : chr "localhost"
[10:29:50.310]   ..$ master          : NULL
[10:29:50.310]   ..$ port            : int 11359
[10:29:50.310]   ..$ connectTimeout  : num 120
[10:29:50.310]   ..$ timeout         : num 2592000
[10:29:50.310]   ..$ rscript         : NULL
[10:29:50.310]   ..$ homogeneous     : NULL
[10:29:50.310]   ..$ rscript_args    : NULL
[10:29:50.310]   ..$ rscript_envs    : NULL
[10:29:50.310]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:29:50.310]   ..$ rscript_startup : NULL
[10:29:50.310]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:29:50.310]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:29:50.310]   ..$ methods         : logi TRUE
[10:29:50.310]   ..$ socketOptions   : chr "no-delay"
[10:29:50.310]   ..$ useXDR          : logi FALSE
[10:29:50.310]   ..$ outfile         : chr "/dev/null"
[10:29:50.310]   ..$ renice          : int NA
[10:29:50.310]   ..$ rshcmd          : NULL
[10:29:50.310]   ..$ user            : NULL
[10:29:50.310]   ..$ revtunnel       : logi NA
[10:29:50.310]   ..$ rshlogfile      : NULL
[10:29:50.310]   ..$ rshopts         : NULL
[10:29:50.310]   ..$ rank            : int 1
[10:29:50.310]   ..$ manual          : logi FALSE
[10:29:50.310]   ..$ dryrun          : logi FALSE
[10:29:50.310]   ..$ quiet           : logi FALSE
[10:29:50.310]   ..$ setup_strategy  : chr "parallel"
[10:29:50.310]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:29:50.328] [local output] System call to launch all workers:
[10:29:50.328] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmphAianP/worker.rank=1.parallelly.parent=68040.109c815ce7bdf.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11359 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:29:50.328] [local output] Starting PSOCK main server
[10:29:50.333] [local output] Workers launched
[10:29:50.334] [local output] Waiting for workers to connect back
[10:29:50.334]  - [local output] 0 workers out of 2 ready
[10:29:50.577]  - [local output] 0 workers out of 2 ready
[10:29:50.577]  - [local output] 1 workers out of 2 ready
[10:29:50.587]  - [local output] 1 workers out of 2 ready
[10:29:50.588]  - [local output] 2 workers out of 2 ready
[10:29:50.588] [local output] Launching of workers completed
[10:29:50.588] [local output] Collecting session information from workers
[10:29:50.589] [local output]  - Worker #1 of 2
[10:29:50.590] [local output]  - Worker #2 of 2
[10:29:50.590] [local output] makeClusterPSOCK() ... done
[10:29:50.601] Packages needed by the future expression (n = 0): <none>
[10:29:50.601] Packages needed by future strategies (n = 0): <none>
[10:29:50.602] {
[10:29:50.602]     {
[10:29:50.602]         {
[10:29:50.602]             ...future.startTime <- base::Sys.time()
[10:29:50.602]             {
[10:29:50.602]                 {
[10:29:50.602]                   {
[10:29:50.602]                     {
[10:29:50.602]                       base::local({
[10:29:50.602]                         has_future <- base::requireNamespace("future", 
[10:29:50.602]                           quietly = TRUE)
[10:29:50.602]                         if (has_future) {
[10:29:50.602]                           ns <- base::getNamespace("future")
[10:29:50.602]                           version <- ns[[".package"]][["version"]]
[10:29:50.602]                           if (is.null(version)) 
[10:29:50.602]                             version <- utils::packageVersion("future")
[10:29:50.602]                         }
[10:29:50.602]                         else {
[10:29:50.602]                           version <- NULL
[10:29:50.602]                         }
[10:29:50.602]                         if (!has_future || version < "1.8.0") {
[10:29:50.602]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:50.602]                             "", base::R.version$version.string), 
[10:29:50.602]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:50.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:50.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:50.602]                               "release", "version")], collapse = " "), 
[10:29:50.602]                             hostname = base::Sys.info()[["nodename"]])
[10:29:50.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:50.602]                             info)
[10:29:50.602]                           info <- base::paste(info, collapse = "; ")
[10:29:50.602]                           if (!has_future) {
[10:29:50.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:50.602]                               info)
[10:29:50.602]                           }
[10:29:50.602]                           else {
[10:29:50.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:50.602]                               info, version)
[10:29:50.602]                           }
[10:29:50.602]                           base::stop(msg)
[10:29:50.602]                         }
[10:29:50.602]                       })
[10:29:50.602]                     }
[10:29:50.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:50.602]                     base::options(mc.cores = 1L)
[10:29:50.602]                   }
[10:29:50.602]                   ...future.strategy.old <- future::plan("list")
[10:29:50.602]                   options(future.plan = NULL)
[10:29:50.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:50.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:50.602]                 }
[10:29:50.602]                 ...future.workdir <- getwd()
[10:29:50.602]             }
[10:29:50.602]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:50.602]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:50.602]         }
[10:29:50.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:50.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:50.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:50.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:50.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:50.602]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:50.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:50.602]             base::names(...future.oldOptions))
[10:29:50.602]     }
[10:29:50.602]     if (FALSE) {
[10:29:50.602]     }
[10:29:50.602]     else {
[10:29:50.602]         if (TRUE) {
[10:29:50.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:50.602]                 open = "w")
[10:29:50.602]         }
[10:29:50.602]         else {
[10:29:50.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:50.602]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:50.602]         }
[10:29:50.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:50.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:50.602]             base::sink(type = "output", split = FALSE)
[10:29:50.602]             base::close(...future.stdout)
[10:29:50.602]         }, add = TRUE)
[10:29:50.602]     }
[10:29:50.602]     ...future.frame <- base::sys.nframe()
[10:29:50.602]     ...future.conditions <- base::list()
[10:29:50.602]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:50.602]     if (FALSE) {
[10:29:50.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:50.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:50.602]     }
[10:29:50.602]     ...future.result <- base::tryCatch({
[10:29:50.602]         base::withCallingHandlers({
[10:29:50.602]             ...future.value <- base::withVisible(base::local({
[10:29:50.602]                 ...future.makeSendCondition <- base::local({
[10:29:50.602]                   sendCondition <- NULL
[10:29:50.602]                   function(frame = 1L) {
[10:29:50.602]                     if (is.function(sendCondition)) 
[10:29:50.602]                       return(sendCondition)
[10:29:50.602]                     ns <- getNamespace("parallel")
[10:29:50.602]                     if (exists("sendData", mode = "function", 
[10:29:50.602]                       envir = ns)) {
[10:29:50.602]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:50.602]                         envir = ns)
[10:29:50.602]                       envir <- sys.frame(frame)
[10:29:50.602]                       master <- NULL
[10:29:50.602]                       while (!identical(envir, .GlobalEnv) && 
[10:29:50.602]                         !identical(envir, emptyenv())) {
[10:29:50.602]                         if (exists("master", mode = "list", envir = envir, 
[10:29:50.602]                           inherits = FALSE)) {
[10:29:50.602]                           master <- get("master", mode = "list", 
[10:29:50.602]                             envir = envir, inherits = FALSE)
[10:29:50.602]                           if (inherits(master, c("SOCKnode", 
[10:29:50.602]                             "SOCK0node"))) {
[10:29:50.602]                             sendCondition <<- function(cond) {
[10:29:50.602]                               data <- list(type = "VALUE", value = cond, 
[10:29:50.602]                                 success = TRUE)
[10:29:50.602]                               parallel_sendData(master, data)
[10:29:50.602]                             }
[10:29:50.602]                             return(sendCondition)
[10:29:50.602]                           }
[10:29:50.602]                         }
[10:29:50.602]                         frame <- frame + 1L
[10:29:50.602]                         envir <- sys.frame(frame)
[10:29:50.602]                       }
[10:29:50.602]                     }
[10:29:50.602]                     sendCondition <<- function(cond) NULL
[10:29:50.602]                   }
[10:29:50.602]                 })
[10:29:50.602]                 withCallingHandlers({
[10:29:50.602]                   NA
[10:29:50.602]                 }, immediateCondition = function(cond) {
[10:29:50.602]                   sendCondition <- ...future.makeSendCondition()
[10:29:50.602]                   sendCondition(cond)
[10:29:50.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.602]                   {
[10:29:50.602]                     inherits <- base::inherits
[10:29:50.602]                     invokeRestart <- base::invokeRestart
[10:29:50.602]                     is.null <- base::is.null
[10:29:50.602]                     muffled <- FALSE
[10:29:50.602]                     if (inherits(cond, "message")) {
[10:29:50.602]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:50.602]                       if (muffled) 
[10:29:50.602]                         invokeRestart("muffleMessage")
[10:29:50.602]                     }
[10:29:50.602]                     else if (inherits(cond, "warning")) {
[10:29:50.602]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:50.602]                       if (muffled) 
[10:29:50.602]                         invokeRestart("muffleWarning")
[10:29:50.602]                     }
[10:29:50.602]                     else if (inherits(cond, "condition")) {
[10:29:50.602]                       if (!is.null(pattern)) {
[10:29:50.602]                         computeRestarts <- base::computeRestarts
[10:29:50.602]                         grepl <- base::grepl
[10:29:50.602]                         restarts <- computeRestarts(cond)
[10:29:50.602]                         for (restart in restarts) {
[10:29:50.602]                           name <- restart$name
[10:29:50.602]                           if (is.null(name)) 
[10:29:50.602]                             next
[10:29:50.602]                           if (!grepl(pattern, name)) 
[10:29:50.602]                             next
[10:29:50.602]                           invokeRestart(restart)
[10:29:50.602]                           muffled <- TRUE
[10:29:50.602]                           break
[10:29:50.602]                         }
[10:29:50.602]                       }
[10:29:50.602]                     }
[10:29:50.602]                     invisible(muffled)
[10:29:50.602]                   }
[10:29:50.602]                   muffleCondition(cond)
[10:29:50.602]                 })
[10:29:50.602]             }))
[10:29:50.602]             future::FutureResult(value = ...future.value$value, 
[10:29:50.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:50.602]                   ...future.rng), globalenv = if (FALSE) 
[10:29:50.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:50.602]                     ...future.globalenv.names))
[10:29:50.602]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:50.602]         }, condition = base::local({
[10:29:50.602]             c <- base::c
[10:29:50.602]             inherits <- base::inherits
[10:29:50.602]             invokeRestart <- base::invokeRestart
[10:29:50.602]             length <- base::length
[10:29:50.602]             list <- base::list
[10:29:50.602]             seq.int <- base::seq.int
[10:29:50.602]             signalCondition <- base::signalCondition
[10:29:50.602]             sys.calls <- base::sys.calls
[10:29:50.602]             `[[` <- base::`[[`
[10:29:50.602]             `+` <- base::`+`
[10:29:50.602]             `<<-` <- base::`<<-`
[10:29:50.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:50.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:50.602]                   3L)]
[10:29:50.602]             }
[10:29:50.602]             function(cond) {
[10:29:50.602]                 is_error <- inherits(cond, "error")
[10:29:50.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:50.602]                   NULL)
[10:29:50.602]                 if (is_error) {
[10:29:50.602]                   sessionInformation <- function() {
[10:29:50.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:50.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:50.602]                       search = base::search(), system = base::Sys.info())
[10:29:50.602]                   }
[10:29:50.602]                   ...future.conditions[[length(...future.conditions) + 
[10:29:50.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:50.602]                     cond$call), session = sessionInformation(), 
[10:29:50.602]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:50.602]                   signalCondition(cond)
[10:29:50.602]                 }
[10:29:50.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:50.602]                 "immediateCondition"))) {
[10:29:50.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:50.602]                   ...future.conditions[[length(...future.conditions) + 
[10:29:50.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:50.602]                   if (TRUE && !signal) {
[10:29:50.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.602]                     {
[10:29:50.602]                       inherits <- base::inherits
[10:29:50.602]                       invokeRestart <- base::invokeRestart
[10:29:50.602]                       is.null <- base::is.null
[10:29:50.602]                       muffled <- FALSE
[10:29:50.602]                       if (inherits(cond, "message")) {
[10:29:50.602]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:50.602]                         if (muffled) 
[10:29:50.602]                           invokeRestart("muffleMessage")
[10:29:50.602]                       }
[10:29:50.602]                       else if (inherits(cond, "warning")) {
[10:29:50.602]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:50.602]                         if (muffled) 
[10:29:50.602]                           invokeRestart("muffleWarning")
[10:29:50.602]                       }
[10:29:50.602]                       else if (inherits(cond, "condition")) {
[10:29:50.602]                         if (!is.null(pattern)) {
[10:29:50.602]                           computeRestarts <- base::computeRestarts
[10:29:50.602]                           grepl <- base::grepl
[10:29:50.602]                           restarts <- computeRestarts(cond)
[10:29:50.602]                           for (restart in restarts) {
[10:29:50.602]                             name <- restart$name
[10:29:50.602]                             if (is.null(name)) 
[10:29:50.602]                               next
[10:29:50.602]                             if (!grepl(pattern, name)) 
[10:29:50.602]                               next
[10:29:50.602]                             invokeRestart(restart)
[10:29:50.602]                             muffled <- TRUE
[10:29:50.602]                             break
[10:29:50.602]                           }
[10:29:50.602]                         }
[10:29:50.602]                       }
[10:29:50.602]                       invisible(muffled)
[10:29:50.602]                     }
[10:29:50.602]                     muffleCondition(cond, pattern = "^muffle")
[10:29:50.602]                   }
[10:29:50.602]                 }
[10:29:50.602]                 else {
[10:29:50.602]                   if (TRUE) {
[10:29:50.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.602]                     {
[10:29:50.602]                       inherits <- base::inherits
[10:29:50.602]                       invokeRestart <- base::invokeRestart
[10:29:50.602]                       is.null <- base::is.null
[10:29:50.602]                       muffled <- FALSE
[10:29:50.602]                       if (inherits(cond, "message")) {
[10:29:50.602]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:50.602]                         if (muffled) 
[10:29:50.602]                           invokeRestart("muffleMessage")
[10:29:50.602]                       }
[10:29:50.602]                       else if (inherits(cond, "warning")) {
[10:29:50.602]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:50.602]                         if (muffled) 
[10:29:50.602]                           invokeRestart("muffleWarning")
[10:29:50.602]                       }
[10:29:50.602]                       else if (inherits(cond, "condition")) {
[10:29:50.602]                         if (!is.null(pattern)) {
[10:29:50.602]                           computeRestarts <- base::computeRestarts
[10:29:50.602]                           grepl <- base::grepl
[10:29:50.602]                           restarts <- computeRestarts(cond)
[10:29:50.602]                           for (restart in restarts) {
[10:29:50.602]                             name <- restart$name
[10:29:50.602]                             if (is.null(name)) 
[10:29:50.602]                               next
[10:29:50.602]                             if (!grepl(pattern, name)) 
[10:29:50.602]                               next
[10:29:50.602]                             invokeRestart(restart)
[10:29:50.602]                             muffled <- TRUE
[10:29:50.602]                             break
[10:29:50.602]                           }
[10:29:50.602]                         }
[10:29:50.602]                       }
[10:29:50.602]                       invisible(muffled)
[10:29:50.602]                     }
[10:29:50.602]                     muffleCondition(cond, pattern = "^muffle")
[10:29:50.602]                   }
[10:29:50.602]                 }
[10:29:50.602]             }
[10:29:50.602]         }))
[10:29:50.602]     }, error = function(ex) {
[10:29:50.602]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:50.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:50.602]                 ...future.rng), started = ...future.startTime, 
[10:29:50.602]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:50.602]             version = "1.8"), class = "FutureResult")
[10:29:50.602]     }, finally = {
[10:29:50.602]         if (!identical(...future.workdir, getwd())) 
[10:29:50.602]             setwd(...future.workdir)
[10:29:50.602]         {
[10:29:50.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:50.602]                 ...future.oldOptions$nwarnings <- NULL
[10:29:50.602]             }
[10:29:50.602]             base::options(...future.oldOptions)
[10:29:50.602]             if (.Platform$OS.type == "windows") {
[10:29:50.602]                 old_names <- names(...future.oldEnvVars)
[10:29:50.602]                 envs <- base::Sys.getenv()
[10:29:50.602]                 names <- names(envs)
[10:29:50.602]                 common <- intersect(names, old_names)
[10:29:50.602]                 added <- setdiff(names, old_names)
[10:29:50.602]                 removed <- setdiff(old_names, names)
[10:29:50.602]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:50.602]                   envs[common]]
[10:29:50.602]                 NAMES <- toupper(changed)
[10:29:50.602]                 args <- list()
[10:29:50.602]                 for (kk in seq_along(NAMES)) {
[10:29:50.602]                   name <- changed[[kk]]
[10:29:50.602]                   NAME <- NAMES[[kk]]
[10:29:50.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.602]                     next
[10:29:50.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:50.602]                 }
[10:29:50.602]                 NAMES <- toupper(added)
[10:29:50.602]                 for (kk in seq_along(NAMES)) {
[10:29:50.602]                   name <- added[[kk]]
[10:29:50.602]                   NAME <- NAMES[[kk]]
[10:29:50.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.602]                     next
[10:29:50.602]                   args[[name]] <- ""
[10:29:50.602]                 }
[10:29:50.602]                 NAMES <- toupper(removed)
[10:29:50.602]                 for (kk in seq_along(NAMES)) {
[10:29:50.602]                   name <- removed[[kk]]
[10:29:50.602]                   NAME <- NAMES[[kk]]
[10:29:50.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.602]                     next
[10:29:50.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:50.602]                 }
[10:29:50.602]                 if (length(args) > 0) 
[10:29:50.602]                   base::do.call(base::Sys.setenv, args = args)
[10:29:50.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:50.602]             }
[10:29:50.602]             else {
[10:29:50.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:50.602]             }
[10:29:50.602]             {
[10:29:50.602]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:50.602]                   0L) {
[10:29:50.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:50.602]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:50.602]                   base::options(opts)
[10:29:50.602]                 }
[10:29:50.602]                 {
[10:29:50.602]                   {
[10:29:50.602]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:50.602]                     NULL
[10:29:50.602]                   }
[10:29:50.602]                   options(future.plan = NULL)
[10:29:50.602]                   if (is.na(NA_character_)) 
[10:29:50.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:50.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:50.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:50.602]                     .init = FALSE)
[10:29:50.602]                 }
[10:29:50.602]             }
[10:29:50.602]         }
[10:29:50.602]     })
[10:29:50.602]     if (TRUE) {
[10:29:50.602]         base::sink(type = "output", split = FALSE)
[10:29:50.602]         if (TRUE) {
[10:29:50.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:50.602]         }
[10:29:50.602]         else {
[10:29:50.602]             ...future.result["stdout"] <- base::list(NULL)
[10:29:50.602]         }
[10:29:50.602]         base::close(...future.stdout)
[10:29:50.602]         ...future.stdout <- NULL
[10:29:50.602]     }
[10:29:50.602]     ...future.result$conditions <- ...future.conditions
[10:29:50.602]     ...future.result$finished <- base::Sys.time()
[10:29:50.602]     ...future.result
[10:29:50.602] }
[10:29:50.655] MultisessionFuture started
[10:29:50.656] result() for ClusterFuture ...
[10:29:50.657] receiveMessageFromWorker() for ClusterFuture ...
[10:29:50.657] - Validating connection of MultisessionFuture
[10:29:50.690] - received message: FutureResult
[10:29:50.690] - Received FutureResult
[10:29:50.690] - Erased future from FutureRegistry
[10:29:50.690] result() for ClusterFuture ...
[10:29:50.691] - result already collected: FutureResult
[10:29:50.691] result() for ClusterFuture ... done
[10:29:50.691] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:50.691] result() for ClusterFuture ... done
[10:29:50.691] result() for ClusterFuture ...
[10:29:50.691] - result already collected: FutureResult
[10:29:50.691] result() for ClusterFuture ... done
[10:29:50.691] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:29:50.695] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[10:29:50.696] getGlobalsAndPackagesXApply() ...
[10:29:50.696]  - future.globals: TRUE
[10:29:50.696] getGlobalsAndPackages() ...
[10:29:50.696] Searching for globals...
[10:29:50.740] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:29:50.741] Searching for globals ... DONE
[10:29:50.741] Resolving globals: FALSE
[10:29:50.742] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:29:50.743] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:29:50.743] - globals: [1] ‘FUN’
[10:29:50.743] 
[10:29:50.743] getGlobalsAndPackages() ... DONE
[10:29:50.743]  - globals found/used: [n=1] ‘FUN’
[10:29:50.743]  - needed namespaces: [n=0] 
[10:29:50.743] Finding globals ... DONE
[10:29:50.744]  - use_args: TRUE
[10:29:50.744]  - Getting '...' globals ...
[10:29:50.744] resolve() on list ...
[10:29:50.744]  recursive: 0
[10:29:50.744]  length: 1
[10:29:50.744]  elements: ‘...’
[10:29:50.744]  length: 0 (resolved future 1)
[10:29:50.744] resolve() on list ... DONE
[10:29:50.744]    - '...' content: [n=0] 
[10:29:50.745] List of 1
[10:29:50.745]  $ ...: list()
[10:29:50.745]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:50.745]  - attr(*, "where")=List of 1
[10:29:50.745]   ..$ ...:<environment: 0x5618a2f6e1c8> 
[10:29:50.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:50.745]  - attr(*, "resolved")= logi TRUE
[10:29:50.745]  - attr(*, "total_size")= num NA
[10:29:50.747]  - Getting '...' globals ... DONE
[10:29:50.747] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:50.747] List of 2
[10:29:50.747]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:50.747]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:50.747]  $ ...          : list()
[10:29:50.747]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:50.747]  - attr(*, "where")=List of 2
[10:29:50.747]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:50.747]   ..$ ...          :<environment: 0x5618a2f6e1c8> 
[10:29:50.747]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:50.747]  - attr(*, "resolved")= logi FALSE
[10:29:50.747]  - attr(*, "total_size")= num 354224
[10:29:50.750] Packages to be attached in all futures: [n=0] 
[10:29:50.750] getGlobalsAndPackagesXApply() ... DONE
[10:29:50.754] future_lapply() ...
[10:29:50.788] Number of chunks: 2
[10:29:50.788] getGlobalsAndPackagesXApply() ...
[10:29:50.788]  - future.globals: <name-value list> with names ‘list()’
[10:29:50.788]  - use_args: TRUE
[10:29:50.788] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:50.788] List of 2
[10:29:50.788]  $ ...          : list()
[10:29:50.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:50.788]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:50.788]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:50.788]  - attr(*, "where")=List of 2
[10:29:50.788]   ..$ ...          :<environment: 0x5618a2f6e1c8> 
[10:29:50.788]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:50.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:50.788]  - attr(*, "resolved")= logi FALSE
[10:29:50.788]  - attr(*, "total_size")= num NA
[10:29:50.792] Packages to be attached in all futures: [n=0] 
[10:29:50.792] getGlobalsAndPackagesXApply() ... DONE
[10:29:50.792] Number of futures (= number of chunks): 2
[10:29:50.792] Launching 2 futures (chunks) ...
[10:29:50.792] Chunk #1 of 2 ...
[10:29:50.793]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:50.793]  - seeds: <none>
[10:29:50.793]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:50.793] getGlobalsAndPackages() ...
[10:29:50.793] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:50.793] Resolving globals: FALSE
[10:29:50.793] Tweak future expression to call with '...' arguments ...
[10:29:50.793] {
[10:29:50.793]     do.call(function(...) {
[10:29:50.793]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:50.793]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:50.793]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:50.793]             on.exit(options(oopts), add = TRUE)
[10:29:50.793]         }
[10:29:50.793]         {
[10:29:50.793]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:50.793]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:50.793]                 ...future.FUN(...future.X_jj, ...)
[10:29:50.793]             })
[10:29:50.793]         }
[10:29:50.793]     }, args = future.call.arguments)
[10:29:50.793] }
[10:29:50.794] Tweak future expression to call with '...' arguments ... DONE
[10:29:50.794] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:50.794] 
[10:29:50.794] getGlobalsAndPackages() ... DONE
[10:29:50.795] run() for ‘Future’ ...
[10:29:50.795] - state: ‘created’
[10:29:50.795] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:50.809] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:50.809] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:50.809]   - Field: ‘node’
[10:29:50.809]   - Field: ‘label’
[10:29:50.809]   - Field: ‘local’
[10:29:50.809]   - Field: ‘owner’
[10:29:50.810]   - Field: ‘envir’
[10:29:50.810]   - Field: ‘workers’
[10:29:50.810]   - Field: ‘packages’
[10:29:50.810]   - Field: ‘gc’
[10:29:50.810]   - Field: ‘conditions’
[10:29:50.810]   - Field: ‘persistent’
[10:29:50.810]   - Field: ‘expr’
[10:29:50.810]   - Field: ‘uuid’
[10:29:50.810]   - Field: ‘seed’
[10:29:50.810]   - Field: ‘version’
[10:29:50.811]   - Field: ‘result’
[10:29:50.811]   - Field: ‘asynchronous’
[10:29:50.811]   - Field: ‘calls’
[10:29:50.811]   - Field: ‘globals’
[10:29:50.811]   - Field: ‘stdout’
[10:29:50.811]   - Field: ‘earlySignal’
[10:29:50.811]   - Field: ‘lazy’
[10:29:50.811]   - Field: ‘state’
[10:29:50.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:50.811] - Launch lazy future ...
[10:29:50.812] Packages needed by the future expression (n = 0): <none>
[10:29:50.812] Packages needed by future strategies (n = 0): <none>
[10:29:50.812] {
[10:29:50.812]     {
[10:29:50.812]         {
[10:29:50.812]             ...future.startTime <- base::Sys.time()
[10:29:50.812]             {
[10:29:50.812]                 {
[10:29:50.812]                   {
[10:29:50.812]                     {
[10:29:50.812]                       base::local({
[10:29:50.812]                         has_future <- base::requireNamespace("future", 
[10:29:50.812]                           quietly = TRUE)
[10:29:50.812]                         if (has_future) {
[10:29:50.812]                           ns <- base::getNamespace("future")
[10:29:50.812]                           version <- ns[[".package"]][["version"]]
[10:29:50.812]                           if (is.null(version)) 
[10:29:50.812]                             version <- utils::packageVersion("future")
[10:29:50.812]                         }
[10:29:50.812]                         else {
[10:29:50.812]                           version <- NULL
[10:29:50.812]                         }
[10:29:50.812]                         if (!has_future || version < "1.8.0") {
[10:29:50.812]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:50.812]                             "", base::R.version$version.string), 
[10:29:50.812]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:50.812]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:50.812]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:50.812]                               "release", "version")], collapse = " "), 
[10:29:50.812]                             hostname = base::Sys.info()[["nodename"]])
[10:29:50.812]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:50.812]                             info)
[10:29:50.812]                           info <- base::paste(info, collapse = "; ")
[10:29:50.812]                           if (!has_future) {
[10:29:50.812]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:50.812]                               info)
[10:29:50.812]                           }
[10:29:50.812]                           else {
[10:29:50.812]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:50.812]                               info, version)
[10:29:50.812]                           }
[10:29:50.812]                           base::stop(msg)
[10:29:50.812]                         }
[10:29:50.812]                       })
[10:29:50.812]                     }
[10:29:50.812]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:50.812]                     base::options(mc.cores = 1L)
[10:29:50.812]                   }
[10:29:50.812]                   ...future.strategy.old <- future::plan("list")
[10:29:50.812]                   options(future.plan = NULL)
[10:29:50.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:50.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:50.812]                 }
[10:29:50.812]                 ...future.workdir <- getwd()
[10:29:50.812]             }
[10:29:50.812]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:50.812]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:50.812]         }
[10:29:50.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:50.812]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:50.812]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:50.812]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:50.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:50.812]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:50.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:50.812]             base::names(...future.oldOptions))
[10:29:50.812]     }
[10:29:50.812]     if (FALSE) {
[10:29:50.812]     }
[10:29:50.812]     else {
[10:29:50.812]         if (TRUE) {
[10:29:50.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:50.812]                 open = "w")
[10:29:50.812]         }
[10:29:50.812]         else {
[10:29:50.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:50.812]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:50.812]         }
[10:29:50.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:50.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:50.812]             base::sink(type = "output", split = FALSE)
[10:29:50.812]             base::close(...future.stdout)
[10:29:50.812]         }, add = TRUE)
[10:29:50.812]     }
[10:29:50.812]     ...future.frame <- base::sys.nframe()
[10:29:50.812]     ...future.conditions <- base::list()
[10:29:50.812]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:50.812]     if (FALSE) {
[10:29:50.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:50.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:50.812]     }
[10:29:50.812]     ...future.result <- base::tryCatch({
[10:29:50.812]         base::withCallingHandlers({
[10:29:50.812]             ...future.value <- base::withVisible(base::local({
[10:29:50.812]                 ...future.makeSendCondition <- base::local({
[10:29:50.812]                   sendCondition <- NULL
[10:29:50.812]                   function(frame = 1L) {
[10:29:50.812]                     if (is.function(sendCondition)) 
[10:29:50.812]                       return(sendCondition)
[10:29:50.812]                     ns <- getNamespace("parallel")
[10:29:50.812]                     if (exists("sendData", mode = "function", 
[10:29:50.812]                       envir = ns)) {
[10:29:50.812]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:50.812]                         envir = ns)
[10:29:50.812]                       envir <- sys.frame(frame)
[10:29:50.812]                       master <- NULL
[10:29:50.812]                       while (!identical(envir, .GlobalEnv) && 
[10:29:50.812]                         !identical(envir, emptyenv())) {
[10:29:50.812]                         if (exists("master", mode = "list", envir = envir, 
[10:29:50.812]                           inherits = FALSE)) {
[10:29:50.812]                           master <- get("master", mode = "list", 
[10:29:50.812]                             envir = envir, inherits = FALSE)
[10:29:50.812]                           if (inherits(master, c("SOCKnode", 
[10:29:50.812]                             "SOCK0node"))) {
[10:29:50.812]                             sendCondition <<- function(cond) {
[10:29:50.812]                               data <- list(type = "VALUE", value = cond, 
[10:29:50.812]                                 success = TRUE)
[10:29:50.812]                               parallel_sendData(master, data)
[10:29:50.812]                             }
[10:29:50.812]                             return(sendCondition)
[10:29:50.812]                           }
[10:29:50.812]                         }
[10:29:50.812]                         frame <- frame + 1L
[10:29:50.812]                         envir <- sys.frame(frame)
[10:29:50.812]                       }
[10:29:50.812]                     }
[10:29:50.812]                     sendCondition <<- function(cond) NULL
[10:29:50.812]                   }
[10:29:50.812]                 })
[10:29:50.812]                 withCallingHandlers({
[10:29:50.812]                   {
[10:29:50.812]                     do.call(function(...) {
[10:29:50.812]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:50.812]                       if (!identical(...future.globals.maxSize.org, 
[10:29:50.812]                         ...future.globals.maxSize)) {
[10:29:50.812]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:50.812]                         on.exit(options(oopts), add = TRUE)
[10:29:50.812]                       }
[10:29:50.812]                       {
[10:29:50.812]                         lapply(seq_along(...future.elements_ii), 
[10:29:50.812]                           FUN = function(jj) {
[10:29:50.812]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:50.812]                             ...future.FUN(...future.X_jj, ...)
[10:29:50.812]                           })
[10:29:50.812]                       }
[10:29:50.812]                     }, args = future.call.arguments)
[10:29:50.812]                   }
[10:29:50.812]                 }, immediateCondition = function(cond) {
[10:29:50.812]                   sendCondition <- ...future.makeSendCondition()
[10:29:50.812]                   sendCondition(cond)
[10:29:50.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.812]                   {
[10:29:50.812]                     inherits <- base::inherits
[10:29:50.812]                     invokeRestart <- base::invokeRestart
[10:29:50.812]                     is.null <- base::is.null
[10:29:50.812]                     muffled <- FALSE
[10:29:50.812]                     if (inherits(cond, "message")) {
[10:29:50.812]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:50.812]                       if (muffled) 
[10:29:50.812]                         invokeRestart("muffleMessage")
[10:29:50.812]                     }
[10:29:50.812]                     else if (inherits(cond, "warning")) {
[10:29:50.812]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:50.812]                       if (muffled) 
[10:29:50.812]                         invokeRestart("muffleWarning")
[10:29:50.812]                     }
[10:29:50.812]                     else if (inherits(cond, "condition")) {
[10:29:50.812]                       if (!is.null(pattern)) {
[10:29:50.812]                         computeRestarts <- base::computeRestarts
[10:29:50.812]                         grepl <- base::grepl
[10:29:50.812]                         restarts <- computeRestarts(cond)
[10:29:50.812]                         for (restart in restarts) {
[10:29:50.812]                           name <- restart$name
[10:29:50.812]                           if (is.null(name)) 
[10:29:50.812]                             next
[10:29:50.812]                           if (!grepl(pattern, name)) 
[10:29:50.812]                             next
[10:29:50.812]                           invokeRestart(restart)
[10:29:50.812]                           muffled <- TRUE
[10:29:50.812]                           break
[10:29:50.812]                         }
[10:29:50.812]                       }
[10:29:50.812]                     }
[10:29:50.812]                     invisible(muffled)
[10:29:50.812]                   }
[10:29:50.812]                   muffleCondition(cond)
[10:29:50.812]                 })
[10:29:50.812]             }))
[10:29:50.812]             future::FutureResult(value = ...future.value$value, 
[10:29:50.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:50.812]                   ...future.rng), globalenv = if (FALSE) 
[10:29:50.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:50.812]                     ...future.globalenv.names))
[10:29:50.812]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:50.812]         }, condition = base::local({
[10:29:50.812]             c <- base::c
[10:29:50.812]             inherits <- base::inherits
[10:29:50.812]             invokeRestart <- base::invokeRestart
[10:29:50.812]             length <- base::length
[10:29:50.812]             list <- base::list
[10:29:50.812]             seq.int <- base::seq.int
[10:29:50.812]             signalCondition <- base::signalCondition
[10:29:50.812]             sys.calls <- base::sys.calls
[10:29:50.812]             `[[` <- base::`[[`
[10:29:50.812]             `+` <- base::`+`
[10:29:50.812]             `<<-` <- base::`<<-`
[10:29:50.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:50.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:50.812]                   3L)]
[10:29:50.812]             }
[10:29:50.812]             function(cond) {
[10:29:50.812]                 is_error <- inherits(cond, "error")
[10:29:50.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:50.812]                   NULL)
[10:29:50.812]                 if (is_error) {
[10:29:50.812]                   sessionInformation <- function() {
[10:29:50.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:50.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:50.812]                       search = base::search(), system = base::Sys.info())
[10:29:50.812]                   }
[10:29:50.812]                   ...future.conditions[[length(...future.conditions) + 
[10:29:50.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:50.812]                     cond$call), session = sessionInformation(), 
[10:29:50.812]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:50.812]                   signalCondition(cond)
[10:29:50.812]                 }
[10:29:50.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:50.812]                 "immediateCondition"))) {
[10:29:50.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:50.812]                   ...future.conditions[[length(...future.conditions) + 
[10:29:50.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:50.812]                   if (TRUE && !signal) {
[10:29:50.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.812]                     {
[10:29:50.812]                       inherits <- base::inherits
[10:29:50.812]                       invokeRestart <- base::invokeRestart
[10:29:50.812]                       is.null <- base::is.null
[10:29:50.812]                       muffled <- FALSE
[10:29:50.812]                       if (inherits(cond, "message")) {
[10:29:50.812]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:50.812]                         if (muffled) 
[10:29:50.812]                           invokeRestart("muffleMessage")
[10:29:50.812]                       }
[10:29:50.812]                       else if (inherits(cond, "warning")) {
[10:29:50.812]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:50.812]                         if (muffled) 
[10:29:50.812]                           invokeRestart("muffleWarning")
[10:29:50.812]                       }
[10:29:50.812]                       else if (inherits(cond, "condition")) {
[10:29:50.812]                         if (!is.null(pattern)) {
[10:29:50.812]                           computeRestarts <- base::computeRestarts
[10:29:50.812]                           grepl <- base::grepl
[10:29:50.812]                           restarts <- computeRestarts(cond)
[10:29:50.812]                           for (restart in restarts) {
[10:29:50.812]                             name <- restart$name
[10:29:50.812]                             if (is.null(name)) 
[10:29:50.812]                               next
[10:29:50.812]                             if (!grepl(pattern, name)) 
[10:29:50.812]                               next
[10:29:50.812]                             invokeRestart(restart)
[10:29:50.812]                             muffled <- TRUE
[10:29:50.812]                             break
[10:29:50.812]                           }
[10:29:50.812]                         }
[10:29:50.812]                       }
[10:29:50.812]                       invisible(muffled)
[10:29:50.812]                     }
[10:29:50.812]                     muffleCondition(cond, pattern = "^muffle")
[10:29:50.812]                   }
[10:29:50.812]                 }
[10:29:50.812]                 else {
[10:29:50.812]                   if (TRUE) {
[10:29:50.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.812]                     {
[10:29:50.812]                       inherits <- base::inherits
[10:29:50.812]                       invokeRestart <- base::invokeRestart
[10:29:50.812]                       is.null <- base::is.null
[10:29:50.812]                       muffled <- FALSE
[10:29:50.812]                       if (inherits(cond, "message")) {
[10:29:50.812]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:50.812]                         if (muffled) 
[10:29:50.812]                           invokeRestart("muffleMessage")
[10:29:50.812]                       }
[10:29:50.812]                       else if (inherits(cond, "warning")) {
[10:29:50.812]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:50.812]                         if (muffled) 
[10:29:50.812]                           invokeRestart("muffleWarning")
[10:29:50.812]                       }
[10:29:50.812]                       else if (inherits(cond, "condition")) {
[10:29:50.812]                         if (!is.null(pattern)) {
[10:29:50.812]                           computeRestarts <- base::computeRestarts
[10:29:50.812]                           grepl <- base::grepl
[10:29:50.812]                           restarts <- computeRestarts(cond)
[10:29:50.812]                           for (restart in restarts) {
[10:29:50.812]                             name <- restart$name
[10:29:50.812]                             if (is.null(name)) 
[10:29:50.812]                               next
[10:29:50.812]                             if (!grepl(pattern, name)) 
[10:29:50.812]                               next
[10:29:50.812]                             invokeRestart(restart)
[10:29:50.812]                             muffled <- TRUE
[10:29:50.812]                             break
[10:29:50.812]                           }
[10:29:50.812]                         }
[10:29:50.812]                       }
[10:29:50.812]                       invisible(muffled)
[10:29:50.812]                     }
[10:29:50.812]                     muffleCondition(cond, pattern = "^muffle")
[10:29:50.812]                   }
[10:29:50.812]                 }
[10:29:50.812]             }
[10:29:50.812]         }))
[10:29:50.812]     }, error = function(ex) {
[10:29:50.812]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:50.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:50.812]                 ...future.rng), started = ...future.startTime, 
[10:29:50.812]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:50.812]             version = "1.8"), class = "FutureResult")
[10:29:50.812]     }, finally = {
[10:29:50.812]         if (!identical(...future.workdir, getwd())) 
[10:29:50.812]             setwd(...future.workdir)
[10:29:50.812]         {
[10:29:50.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:50.812]                 ...future.oldOptions$nwarnings <- NULL
[10:29:50.812]             }
[10:29:50.812]             base::options(...future.oldOptions)
[10:29:50.812]             if (.Platform$OS.type == "windows") {
[10:29:50.812]                 old_names <- names(...future.oldEnvVars)
[10:29:50.812]                 envs <- base::Sys.getenv()
[10:29:50.812]                 names <- names(envs)
[10:29:50.812]                 common <- intersect(names, old_names)
[10:29:50.812]                 added <- setdiff(names, old_names)
[10:29:50.812]                 removed <- setdiff(old_names, names)
[10:29:50.812]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:50.812]                   envs[common]]
[10:29:50.812]                 NAMES <- toupper(changed)
[10:29:50.812]                 args <- list()
[10:29:50.812]                 for (kk in seq_along(NAMES)) {
[10:29:50.812]                   name <- changed[[kk]]
[10:29:50.812]                   NAME <- NAMES[[kk]]
[10:29:50.812]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.812]                     next
[10:29:50.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:50.812]                 }
[10:29:50.812]                 NAMES <- toupper(added)
[10:29:50.812]                 for (kk in seq_along(NAMES)) {
[10:29:50.812]                   name <- added[[kk]]
[10:29:50.812]                   NAME <- NAMES[[kk]]
[10:29:50.812]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.812]                     next
[10:29:50.812]                   args[[name]] <- ""
[10:29:50.812]                 }
[10:29:50.812]                 NAMES <- toupper(removed)
[10:29:50.812]                 for (kk in seq_along(NAMES)) {
[10:29:50.812]                   name <- removed[[kk]]
[10:29:50.812]                   NAME <- NAMES[[kk]]
[10:29:50.812]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.812]                     next
[10:29:50.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:50.812]                 }
[10:29:50.812]                 if (length(args) > 0) 
[10:29:50.812]                   base::do.call(base::Sys.setenv, args = args)
[10:29:50.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:50.812]             }
[10:29:50.812]             else {
[10:29:50.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:50.812]             }
[10:29:50.812]             {
[10:29:50.812]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:50.812]                   0L) {
[10:29:50.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:50.812]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:50.812]                   base::options(opts)
[10:29:50.812]                 }
[10:29:50.812]                 {
[10:29:50.812]                   {
[10:29:50.812]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:50.812]                     NULL
[10:29:50.812]                   }
[10:29:50.812]                   options(future.plan = NULL)
[10:29:50.812]                   if (is.na(NA_character_)) 
[10:29:50.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:50.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:50.812]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:50.812]                     .init = FALSE)
[10:29:50.812]                 }
[10:29:50.812]             }
[10:29:50.812]         }
[10:29:50.812]     })
[10:29:50.812]     if (TRUE) {
[10:29:50.812]         base::sink(type = "output", split = FALSE)
[10:29:50.812]         if (TRUE) {
[10:29:50.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:50.812]         }
[10:29:50.812]         else {
[10:29:50.812]             ...future.result["stdout"] <- base::list(NULL)
[10:29:50.812]         }
[10:29:50.812]         base::close(...future.stdout)
[10:29:50.812]         ...future.stdout <- NULL
[10:29:50.812]     }
[10:29:50.812]     ...future.result$conditions <- ...future.conditions
[10:29:50.812]     ...future.result$finished <- base::Sys.time()
[10:29:50.812]     ...future.result
[10:29:50.812] }
[10:29:50.816] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[10:29:50.816] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:50.816] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:50.816] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[10:29:50.857] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[10:29:50.858] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[10:29:50.858] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[10:29:50.858] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:50.859] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:50.859] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:50.859] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:50.859] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[10:29:50.860] MultisessionFuture started
[10:29:50.860] - Launch lazy future ... done
[10:29:50.860] run() for ‘MultisessionFuture’ ... done
[10:29:50.860] Created future:
[10:29:50.860] MultisessionFuture:
[10:29:50.860] Label: ‘future_apply-1’
[10:29:50.860] Expression:
[10:29:50.860] {
[10:29:50.860]     do.call(function(...) {
[10:29:50.860]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:50.860]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:50.860]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:50.860]             on.exit(options(oopts), add = TRUE)
[10:29:50.860]         }
[10:29:50.860]         {
[10:29:50.860]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:50.860]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:50.860]                 ...future.FUN(...future.X_jj, ...)
[10:29:50.860]             })
[10:29:50.860]         }
[10:29:50.860]     }, args = future.call.arguments)
[10:29:50.860] }
[10:29:50.860] Lazy evaluation: FALSE
[10:29:50.860] Asynchronous evaluation: TRUE
[10:29:50.860] Local evaluation: TRUE
[10:29:50.860] Environment: R_GlobalEnv
[10:29:50.860] Capture standard output: TRUE
[10:29:50.860] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:50.860] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:50.860] Packages: <none>
[10:29:50.860] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:50.860] Resolved: FALSE
[10:29:50.860] Value: <not collected>
[10:29:50.860] Conditions captured: <none>
[10:29:50.860] Early signaling: FALSE
[10:29:50.860] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:50.860] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:50.872] Chunk #1 of 2 ... DONE
[10:29:50.872] Chunk #2 of 2 ...
[10:29:50.873]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:50.873]  - seeds: <none>
[10:29:50.873]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:50.873] getGlobalsAndPackages() ...
[10:29:50.873] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:50.873] Resolving globals: FALSE
[10:29:50.873] Tweak future expression to call with '...' arguments ...
[10:29:50.873] {
[10:29:50.873]     do.call(function(...) {
[10:29:50.873]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:50.873]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:50.873]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:50.873]             on.exit(options(oopts), add = TRUE)
[10:29:50.873]         }
[10:29:50.873]         {
[10:29:50.873]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:50.873]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:50.873]                 ...future.FUN(...future.X_jj, ...)
[10:29:50.873]             })
[10:29:50.873]         }
[10:29:50.873]     }, args = future.call.arguments)
[10:29:50.873] }
[10:29:50.874] Tweak future expression to call with '...' arguments ... DONE
[10:29:50.874] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:50.874] 
[10:29:50.874] getGlobalsAndPackages() ... DONE
[10:29:50.875] run() for ‘Future’ ...
[10:29:50.875] - state: ‘created’
[10:29:50.875] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:50.889] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:50.889] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:50.889]   - Field: ‘node’
[10:29:50.890]   - Field: ‘label’
[10:29:50.890]   - Field: ‘local’
[10:29:50.890]   - Field: ‘owner’
[10:29:50.890]   - Field: ‘envir’
[10:29:50.890]   - Field: ‘workers’
[10:29:50.890]   - Field: ‘packages’
[10:29:50.890]   - Field: ‘gc’
[10:29:50.890]   - Field: ‘conditions’
[10:29:50.892]   - Field: ‘persistent’
[10:29:50.892]   - Field: ‘expr’
[10:29:50.892]   - Field: ‘uuid’
[10:29:50.892]   - Field: ‘seed’
[10:29:50.893]   - Field: ‘version’
[10:29:50.893]   - Field: ‘result’
[10:29:50.893]   - Field: ‘asynchronous’
[10:29:50.893]   - Field: ‘calls’
[10:29:50.893]   - Field: ‘globals’
[10:29:50.893]   - Field: ‘stdout’
[10:29:50.893]   - Field: ‘earlySignal’
[10:29:50.893]   - Field: ‘lazy’
[10:29:50.893]   - Field: ‘state’
[10:29:50.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:50.893] - Launch lazy future ...
[10:29:50.894] Packages needed by the future expression (n = 0): <none>
[10:29:50.894] Packages needed by future strategies (n = 0): <none>
[10:29:50.894] {
[10:29:50.894]     {
[10:29:50.894]         {
[10:29:50.894]             ...future.startTime <- base::Sys.time()
[10:29:50.894]             {
[10:29:50.894]                 {
[10:29:50.894]                   {
[10:29:50.894]                     {
[10:29:50.894]                       base::local({
[10:29:50.894]                         has_future <- base::requireNamespace("future", 
[10:29:50.894]                           quietly = TRUE)
[10:29:50.894]                         if (has_future) {
[10:29:50.894]                           ns <- base::getNamespace("future")
[10:29:50.894]                           version <- ns[[".package"]][["version"]]
[10:29:50.894]                           if (is.null(version)) 
[10:29:50.894]                             version <- utils::packageVersion("future")
[10:29:50.894]                         }
[10:29:50.894]                         else {
[10:29:50.894]                           version <- NULL
[10:29:50.894]                         }
[10:29:50.894]                         if (!has_future || version < "1.8.0") {
[10:29:50.894]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:50.894]                             "", base::R.version$version.string), 
[10:29:50.894]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:50.894]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:50.894]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:50.894]                               "release", "version")], collapse = " "), 
[10:29:50.894]                             hostname = base::Sys.info()[["nodename"]])
[10:29:50.894]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:50.894]                             info)
[10:29:50.894]                           info <- base::paste(info, collapse = "; ")
[10:29:50.894]                           if (!has_future) {
[10:29:50.894]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:50.894]                               info)
[10:29:50.894]                           }
[10:29:50.894]                           else {
[10:29:50.894]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:50.894]                               info, version)
[10:29:50.894]                           }
[10:29:50.894]                           base::stop(msg)
[10:29:50.894]                         }
[10:29:50.894]                       })
[10:29:50.894]                     }
[10:29:50.894]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:50.894]                     base::options(mc.cores = 1L)
[10:29:50.894]                   }
[10:29:50.894]                   ...future.strategy.old <- future::plan("list")
[10:29:50.894]                   options(future.plan = NULL)
[10:29:50.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:50.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:50.894]                 }
[10:29:50.894]                 ...future.workdir <- getwd()
[10:29:50.894]             }
[10:29:50.894]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:50.894]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:50.894]         }
[10:29:50.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:50.894]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:50.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:50.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:50.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:50.894]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:50.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:50.894]             base::names(...future.oldOptions))
[10:29:50.894]     }
[10:29:50.894]     if (FALSE) {
[10:29:50.894]     }
[10:29:50.894]     else {
[10:29:50.894]         if (TRUE) {
[10:29:50.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:50.894]                 open = "w")
[10:29:50.894]         }
[10:29:50.894]         else {
[10:29:50.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:50.894]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:50.894]         }
[10:29:50.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:50.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:50.894]             base::sink(type = "output", split = FALSE)
[10:29:50.894]             base::close(...future.stdout)
[10:29:50.894]         }, add = TRUE)
[10:29:50.894]     }
[10:29:50.894]     ...future.frame <- base::sys.nframe()
[10:29:50.894]     ...future.conditions <- base::list()
[10:29:50.894]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:50.894]     if (FALSE) {
[10:29:50.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:50.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:50.894]     }
[10:29:50.894]     ...future.result <- base::tryCatch({
[10:29:50.894]         base::withCallingHandlers({
[10:29:50.894]             ...future.value <- base::withVisible(base::local({
[10:29:50.894]                 ...future.makeSendCondition <- base::local({
[10:29:50.894]                   sendCondition <- NULL
[10:29:50.894]                   function(frame = 1L) {
[10:29:50.894]                     if (is.function(sendCondition)) 
[10:29:50.894]                       return(sendCondition)
[10:29:50.894]                     ns <- getNamespace("parallel")
[10:29:50.894]                     if (exists("sendData", mode = "function", 
[10:29:50.894]                       envir = ns)) {
[10:29:50.894]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:50.894]                         envir = ns)
[10:29:50.894]                       envir <- sys.frame(frame)
[10:29:50.894]                       master <- NULL
[10:29:50.894]                       while (!identical(envir, .GlobalEnv) && 
[10:29:50.894]                         !identical(envir, emptyenv())) {
[10:29:50.894]                         if (exists("master", mode = "list", envir = envir, 
[10:29:50.894]                           inherits = FALSE)) {
[10:29:50.894]                           master <- get("master", mode = "list", 
[10:29:50.894]                             envir = envir, inherits = FALSE)
[10:29:50.894]                           if (inherits(master, c("SOCKnode", 
[10:29:50.894]                             "SOCK0node"))) {
[10:29:50.894]                             sendCondition <<- function(cond) {
[10:29:50.894]                               data <- list(type = "VALUE", value = cond, 
[10:29:50.894]                                 success = TRUE)
[10:29:50.894]                               parallel_sendData(master, data)
[10:29:50.894]                             }
[10:29:50.894]                             return(sendCondition)
[10:29:50.894]                           }
[10:29:50.894]                         }
[10:29:50.894]                         frame <- frame + 1L
[10:29:50.894]                         envir <- sys.frame(frame)
[10:29:50.894]                       }
[10:29:50.894]                     }
[10:29:50.894]                     sendCondition <<- function(cond) NULL
[10:29:50.894]                   }
[10:29:50.894]                 })
[10:29:50.894]                 withCallingHandlers({
[10:29:50.894]                   {
[10:29:50.894]                     do.call(function(...) {
[10:29:50.894]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:50.894]                       if (!identical(...future.globals.maxSize.org, 
[10:29:50.894]                         ...future.globals.maxSize)) {
[10:29:50.894]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:50.894]                         on.exit(options(oopts), add = TRUE)
[10:29:50.894]                       }
[10:29:50.894]                       {
[10:29:50.894]                         lapply(seq_along(...future.elements_ii), 
[10:29:50.894]                           FUN = function(jj) {
[10:29:50.894]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:50.894]                             ...future.FUN(...future.X_jj, ...)
[10:29:50.894]                           })
[10:29:50.894]                       }
[10:29:50.894]                     }, args = future.call.arguments)
[10:29:50.894]                   }
[10:29:50.894]                 }, immediateCondition = function(cond) {
[10:29:50.894]                   sendCondition <- ...future.makeSendCondition()
[10:29:50.894]                   sendCondition(cond)
[10:29:50.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.894]                   {
[10:29:50.894]                     inherits <- base::inherits
[10:29:50.894]                     invokeRestart <- base::invokeRestart
[10:29:50.894]                     is.null <- base::is.null
[10:29:50.894]                     muffled <- FALSE
[10:29:50.894]                     if (inherits(cond, "message")) {
[10:29:50.894]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:50.894]                       if (muffled) 
[10:29:50.894]                         invokeRestart("muffleMessage")
[10:29:50.894]                     }
[10:29:50.894]                     else if (inherits(cond, "warning")) {
[10:29:50.894]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:50.894]                       if (muffled) 
[10:29:50.894]                         invokeRestart("muffleWarning")
[10:29:50.894]                     }
[10:29:50.894]                     else if (inherits(cond, "condition")) {
[10:29:50.894]                       if (!is.null(pattern)) {
[10:29:50.894]                         computeRestarts <- base::computeRestarts
[10:29:50.894]                         grepl <- base::grepl
[10:29:50.894]                         restarts <- computeRestarts(cond)
[10:29:50.894]                         for (restart in restarts) {
[10:29:50.894]                           name <- restart$name
[10:29:50.894]                           if (is.null(name)) 
[10:29:50.894]                             next
[10:29:50.894]                           if (!grepl(pattern, name)) 
[10:29:50.894]                             next
[10:29:50.894]                           invokeRestart(restart)
[10:29:50.894]                           muffled <- TRUE
[10:29:50.894]                           break
[10:29:50.894]                         }
[10:29:50.894]                       }
[10:29:50.894]                     }
[10:29:50.894]                     invisible(muffled)
[10:29:50.894]                   }
[10:29:50.894]                   muffleCondition(cond)
[10:29:50.894]                 })
[10:29:50.894]             }))
[10:29:50.894]             future::FutureResult(value = ...future.value$value, 
[10:29:50.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:50.894]                   ...future.rng), globalenv = if (FALSE) 
[10:29:50.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:50.894]                     ...future.globalenv.names))
[10:29:50.894]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:50.894]         }, condition = base::local({
[10:29:50.894]             c <- base::c
[10:29:50.894]             inherits <- base::inherits
[10:29:50.894]             invokeRestart <- base::invokeRestart
[10:29:50.894]             length <- base::length
[10:29:50.894]             list <- base::list
[10:29:50.894]             seq.int <- base::seq.int
[10:29:50.894]             signalCondition <- base::signalCondition
[10:29:50.894]             sys.calls <- base::sys.calls
[10:29:50.894]             `[[` <- base::`[[`
[10:29:50.894]             `+` <- base::`+`
[10:29:50.894]             `<<-` <- base::`<<-`
[10:29:50.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:50.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:50.894]                   3L)]
[10:29:50.894]             }
[10:29:50.894]             function(cond) {
[10:29:50.894]                 is_error <- inherits(cond, "error")
[10:29:50.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:50.894]                   NULL)
[10:29:50.894]                 if (is_error) {
[10:29:50.894]                   sessionInformation <- function() {
[10:29:50.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:50.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:50.894]                       search = base::search(), system = base::Sys.info())
[10:29:50.894]                   }
[10:29:50.894]                   ...future.conditions[[length(...future.conditions) + 
[10:29:50.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:50.894]                     cond$call), session = sessionInformation(), 
[10:29:50.894]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:50.894]                   signalCondition(cond)
[10:29:50.894]                 }
[10:29:50.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:50.894]                 "immediateCondition"))) {
[10:29:50.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:50.894]                   ...future.conditions[[length(...future.conditions) + 
[10:29:50.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:50.894]                   if (TRUE && !signal) {
[10:29:50.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.894]                     {
[10:29:50.894]                       inherits <- base::inherits
[10:29:50.894]                       invokeRestart <- base::invokeRestart
[10:29:50.894]                       is.null <- base::is.null
[10:29:50.894]                       muffled <- FALSE
[10:29:50.894]                       if (inherits(cond, "message")) {
[10:29:50.894]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:50.894]                         if (muffled) 
[10:29:50.894]                           invokeRestart("muffleMessage")
[10:29:50.894]                       }
[10:29:50.894]                       else if (inherits(cond, "warning")) {
[10:29:50.894]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:50.894]                         if (muffled) 
[10:29:50.894]                           invokeRestart("muffleWarning")
[10:29:50.894]                       }
[10:29:50.894]                       else if (inherits(cond, "condition")) {
[10:29:50.894]                         if (!is.null(pattern)) {
[10:29:50.894]                           computeRestarts <- base::computeRestarts
[10:29:50.894]                           grepl <- base::grepl
[10:29:50.894]                           restarts <- computeRestarts(cond)
[10:29:50.894]                           for (restart in restarts) {
[10:29:50.894]                             name <- restart$name
[10:29:50.894]                             if (is.null(name)) 
[10:29:50.894]                               next
[10:29:50.894]                             if (!grepl(pattern, name)) 
[10:29:50.894]                               next
[10:29:50.894]                             invokeRestart(restart)
[10:29:50.894]                             muffled <- TRUE
[10:29:50.894]                             break
[10:29:50.894]                           }
[10:29:50.894]                         }
[10:29:50.894]                       }
[10:29:50.894]                       invisible(muffled)
[10:29:50.894]                     }
[10:29:50.894]                     muffleCondition(cond, pattern = "^muffle")
[10:29:50.894]                   }
[10:29:50.894]                 }
[10:29:50.894]                 else {
[10:29:50.894]                   if (TRUE) {
[10:29:50.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:50.894]                     {
[10:29:50.894]                       inherits <- base::inherits
[10:29:50.894]                       invokeRestart <- base::invokeRestart
[10:29:50.894]                       is.null <- base::is.null
[10:29:50.894]                       muffled <- FALSE
[10:29:50.894]                       if (inherits(cond, "message")) {
[10:29:50.894]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:50.894]                         if (muffled) 
[10:29:50.894]                           invokeRestart("muffleMessage")
[10:29:50.894]                       }
[10:29:50.894]                       else if (inherits(cond, "warning")) {
[10:29:50.894]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:50.894]                         if (muffled) 
[10:29:50.894]                           invokeRestart("muffleWarning")
[10:29:50.894]                       }
[10:29:50.894]                       else if (inherits(cond, "condition")) {
[10:29:50.894]                         if (!is.null(pattern)) {
[10:29:50.894]                           computeRestarts <- base::computeRestarts
[10:29:50.894]                           grepl <- base::grepl
[10:29:50.894]                           restarts <- computeRestarts(cond)
[10:29:50.894]                           for (restart in restarts) {
[10:29:50.894]                             name <- restart$name
[10:29:50.894]                             if (is.null(name)) 
[10:29:50.894]                               next
[10:29:50.894]                             if (!grepl(pattern, name)) 
[10:29:50.894]                               next
[10:29:50.894]                             invokeRestart(restart)
[10:29:50.894]                             muffled <- TRUE
[10:29:50.894]                             break
[10:29:50.894]                           }
[10:29:50.894]                         }
[10:29:50.894]                       }
[10:29:50.894]                       invisible(muffled)
[10:29:50.894]                     }
[10:29:50.894]                     muffleCondition(cond, pattern = "^muffle")
[10:29:50.894]                   }
[10:29:50.894]                 }
[10:29:50.894]             }
[10:29:50.894]         }))
[10:29:50.894]     }, error = function(ex) {
[10:29:50.894]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:50.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:50.894]                 ...future.rng), started = ...future.startTime, 
[10:29:50.894]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:50.894]             version = "1.8"), class = "FutureResult")
[10:29:50.894]     }, finally = {
[10:29:50.894]         if (!identical(...future.workdir, getwd())) 
[10:29:50.894]             setwd(...future.workdir)
[10:29:50.894]         {
[10:29:50.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:50.894]                 ...future.oldOptions$nwarnings <- NULL
[10:29:50.894]             }
[10:29:50.894]             base::options(...future.oldOptions)
[10:29:50.894]             if (.Platform$OS.type == "windows") {
[10:29:50.894]                 old_names <- names(...future.oldEnvVars)
[10:29:50.894]                 envs <- base::Sys.getenv()
[10:29:50.894]                 names <- names(envs)
[10:29:50.894]                 common <- intersect(names, old_names)
[10:29:50.894]                 added <- setdiff(names, old_names)
[10:29:50.894]                 removed <- setdiff(old_names, names)
[10:29:50.894]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:50.894]                   envs[common]]
[10:29:50.894]                 NAMES <- toupper(changed)
[10:29:50.894]                 args <- list()
[10:29:50.894]                 for (kk in seq_along(NAMES)) {
[10:29:50.894]                   name <- changed[[kk]]
[10:29:50.894]                   NAME <- NAMES[[kk]]
[10:29:50.894]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.894]                     next
[10:29:50.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:50.894]                 }
[10:29:50.894]                 NAMES <- toupper(added)
[10:29:50.894]                 for (kk in seq_along(NAMES)) {
[10:29:50.894]                   name <- added[[kk]]
[10:29:50.894]                   NAME <- NAMES[[kk]]
[10:29:50.894]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.894]                     next
[10:29:50.894]                   args[[name]] <- ""
[10:29:50.894]                 }
[10:29:50.894]                 NAMES <- toupper(removed)
[10:29:50.894]                 for (kk in seq_along(NAMES)) {
[10:29:50.894]                   name <- removed[[kk]]
[10:29:50.894]                   NAME <- NAMES[[kk]]
[10:29:50.894]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:50.894]                     next
[10:29:50.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:50.894]                 }
[10:29:50.894]                 if (length(args) > 0) 
[10:29:50.894]                   base::do.call(base::Sys.setenv, args = args)
[10:29:50.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:50.894]             }
[10:29:50.894]             else {
[10:29:50.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:50.894]             }
[10:29:50.894]             {
[10:29:50.894]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:50.894]                   0L) {
[10:29:50.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:50.894]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:50.894]                   base::options(opts)
[10:29:50.894]                 }
[10:29:50.894]                 {
[10:29:50.894]                   {
[10:29:50.894]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:50.894]                     NULL
[10:29:50.894]                   }
[10:29:50.894]                   options(future.plan = NULL)
[10:29:50.894]                   if (is.na(NA_character_)) 
[10:29:50.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:50.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:50.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:50.894]                     .init = FALSE)
[10:29:50.894]                 }
[10:29:50.894]             }
[10:29:50.894]         }
[10:29:50.894]     })
[10:29:50.894]     if (TRUE) {
[10:29:50.894]         base::sink(type = "output", split = FALSE)
[10:29:50.894]         if (TRUE) {
[10:29:50.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:50.894]         }
[10:29:50.894]         else {
[10:29:50.894]             ...future.result["stdout"] <- base::list(NULL)
[10:29:50.894]         }
[10:29:50.894]         base::close(...future.stdout)
[10:29:50.894]         ...future.stdout <- NULL
[10:29:50.894]     }
[10:29:50.894]     ...future.result$conditions <- ...future.conditions
[10:29:50.894]     ...future.result$finished <- base::Sys.time()
[10:29:50.894]     ...future.result
[10:29:50.894] }
[10:29:50.948] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[10:29:50.948] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:50.949] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:50.949] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[10:29:50.993] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[10:29:50.993] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[10:29:50.994] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[10:29:50.994] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:50.994] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:50.995] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:29:50.995] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:29:50.995] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[10:29:50.996] MultisessionFuture started
[10:29:50.996] - Launch lazy future ... done
[10:29:50.996] run() for ‘MultisessionFuture’ ... done
[10:29:50.996] Created future:
[10:29:50.996] MultisessionFuture:
[10:29:50.996] Label: ‘future_apply-2’
[10:29:50.996] Expression:
[10:29:50.996] {
[10:29:50.996]     do.call(function(...) {
[10:29:50.996]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:50.996]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:50.996]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:50.996]             on.exit(options(oopts), add = TRUE)
[10:29:50.996]         }
[10:29:50.996]         {
[10:29:50.996]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:50.996]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:50.996]                 ...future.FUN(...future.X_jj, ...)
[10:29:50.996]             })
[10:29:50.996]         }
[10:29:50.996]     }, args = future.call.arguments)
[10:29:50.996] }
[10:29:50.996] Lazy evaluation: FALSE
[10:29:50.996] Asynchronous evaluation: TRUE
[10:29:50.996] Local evaluation: TRUE
[10:29:50.996] Environment: R_GlobalEnv
[10:29:50.996] Capture standard output: TRUE
[10:29:50.996] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:50.996] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:50.996] Packages: <none>
[10:29:50.996] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:50.996] Resolved: FALSE
[10:29:50.996] Value: <not collected>
[10:29:50.996] Conditions captured: <none>
[10:29:50.996] Early signaling: FALSE
[10:29:50.996] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:50.996] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.008] Chunk #2 of 2 ... DONE
[10:29:51.008] Launching 2 futures (chunks) ... DONE
[10:29:51.008] Resolving 2 futures (chunks) ...
[10:29:51.008] resolve() on list ...
[10:29:51.009]  recursive: 0
[10:29:51.009]  length: 2
[10:29:51.009] 
[10:29:51.009] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.009] - Validating connection of MultisessionFuture
[10:29:51.010] - received message: FutureResult
[10:29:51.010] - Received FutureResult
[10:29:51.010] - Erased future from FutureRegistry
[10:29:51.010] result() for ClusterFuture ...
[10:29:51.010] - result already collected: FutureResult
[10:29:51.010] result() for ClusterFuture ... done
[10:29:51.010] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.010] Future #1
[10:29:51.010] result() for ClusterFuture ...
[10:29:51.010] - result already collected: FutureResult
[10:29:51.011] result() for ClusterFuture ... done
[10:29:51.011] result() for ClusterFuture ...
[10:29:51.011] - result already collected: FutureResult
[10:29:51.011] result() for ClusterFuture ... done
[10:29:51.011] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:51.011] - nx: 2
[10:29:51.011] - relay: TRUE
[10:29:51.011] - stdout: TRUE
[10:29:51.011] - signal: TRUE
[10:29:51.011] - resignal: FALSE
[10:29:51.011] - force: TRUE
[10:29:51.011] - relayed: [n=2] FALSE, FALSE
[10:29:51.012] - queued futures: [n=2] FALSE, FALSE
[10:29:51.012]  - until=1
[10:29:51.012]  - relaying element #1
[10:29:51.012] result() for ClusterFuture ...
[10:29:51.012] - result already collected: FutureResult
[10:29:51.012] result() for ClusterFuture ... done
[10:29:51.012] result() for ClusterFuture ...
[10:29:51.012] - result already collected: FutureResult
[10:29:51.012] result() for ClusterFuture ... done
[10:29:51.012] result() for ClusterFuture ...
[10:29:51.012] - result already collected: FutureResult
[10:29:51.013] result() for ClusterFuture ... done
[10:29:51.013] result() for ClusterFuture ...
[10:29:51.013] - result already collected: FutureResult
[10:29:51.013] result() for ClusterFuture ... done
[10:29:51.013] - relayed: [n=2] TRUE, FALSE
[10:29:51.013] - queued futures: [n=2] TRUE, FALSE
[10:29:51.013] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:51.013]  length: 1 (resolved future 1)
[10:29:51.077] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.077] - Validating connection of MultisessionFuture
[10:29:51.077] - received message: FutureResult
[10:29:51.077] - Received FutureResult
[10:29:51.077] - Erased future from FutureRegistry
[10:29:51.078] result() for ClusterFuture ...
[10:29:51.078] - result already collected: FutureResult
[10:29:51.078] result() for ClusterFuture ... done
[10:29:51.078] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.078] Future #2
[10:29:51.078] result() for ClusterFuture ...
[10:29:51.078] - result already collected: FutureResult
[10:29:51.078] result() for ClusterFuture ... done
[10:29:51.078] result() for ClusterFuture ...
[10:29:51.078] - result already collected: FutureResult
[10:29:51.078] result() for ClusterFuture ... done
[10:29:51.079] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:51.079] - nx: 2
[10:29:51.079] - relay: TRUE
[10:29:51.079] - stdout: TRUE
[10:29:51.079] - signal: TRUE
[10:29:51.079] - resignal: FALSE
[10:29:51.079] - force: TRUE
[10:29:51.079] - relayed: [n=2] TRUE, FALSE
[10:29:51.079] - queued futures: [n=2] TRUE, FALSE
[10:29:51.079]  - until=2
[10:29:51.080]  - relaying element #2
[10:29:51.080] result() for ClusterFuture ...
[10:29:51.080] - result already collected: FutureResult
[10:29:51.080] result() for ClusterFuture ... done
[10:29:51.080] result() for ClusterFuture ...
[10:29:51.080] - result already collected: FutureResult
[10:29:51.080] result() for ClusterFuture ... done
[10:29:51.080] result() for ClusterFuture ...
[10:29:51.080] - result already collected: FutureResult
[10:29:51.080] result() for ClusterFuture ... done
[10:29:51.080] result() for ClusterFuture ...
[10:29:51.081] - result already collected: FutureResult
[10:29:51.081] result() for ClusterFuture ... done
[10:29:51.081] - relayed: [n=2] TRUE, TRUE
[10:29:51.081] - queued futures: [n=2] TRUE, TRUE
[10:29:51.081] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:51.081]  length: 0 (resolved future 2)
[10:29:51.081] Relaying remaining futures
[10:29:51.081] signalConditionsASAP(NULL, pos=0) ...
[10:29:51.081] - nx: 2
[10:29:51.081] - relay: TRUE
[10:29:51.082] - stdout: TRUE
[10:29:51.082] - signal: TRUE
[10:29:51.082] - resignal: FALSE
[10:29:51.082] - force: TRUE
[10:29:51.082] - relayed: [n=2] TRUE, TRUE
[10:29:51.082] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:51.082] - relayed: [n=2] TRUE, TRUE
[10:29:51.082] - queued futures: [n=2] TRUE, TRUE
[10:29:51.082] signalConditionsASAP(NULL, pos=0) ... done
[10:29:51.082] resolve() on list ... DONE
[10:29:51.082] result() for ClusterFuture ...
[10:29:51.082] - result already collected: FutureResult
[10:29:51.083] result() for ClusterFuture ... done
[10:29:51.083] result() for ClusterFuture ...
[10:29:51.083] - result already collected: FutureResult
[10:29:51.083] result() for ClusterFuture ... done
[10:29:51.083] result() for ClusterFuture ...
[10:29:51.083] - result already collected: FutureResult
[10:29:51.083] result() for ClusterFuture ... done
[10:29:51.083] result() for ClusterFuture ...
[10:29:51.083] - result already collected: FutureResult
[10:29:51.083] result() for ClusterFuture ... done
[10:29:51.083]  - Number of value chunks collected: 2
[10:29:51.084] Resolving 2 futures (chunks) ... DONE
[10:29:51.084] Reducing values from 2 chunks ...
[10:29:51.084]  - Number of values collected after concatenation: 2
[10:29:51.084]  - Number of values expected: 2
[10:29:51.084] Reducing values from 2 chunks ... DONE
[10:29:51.084] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:29:51.084] getGlobalsAndPackagesXApply() ...
[10:29:51.085]  - future.globals: TRUE
[10:29:51.085] getGlobalsAndPackages() ...
[10:29:51.085] Searching for globals...
[10:29:51.116] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:29:51.116] Searching for globals ... DONE
[10:29:51.117] Resolving globals: FALSE
[10:29:51.118] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:29:51.119] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:29:51.119] - globals: [1] ‘FUN’
[10:29:51.119] 
[10:29:51.119] getGlobalsAndPackages() ... DONE
[10:29:51.119]  - globals found/used: [n=1] ‘FUN’
[10:29:51.119]  - needed namespaces: [n=0] 
[10:29:51.119] Finding globals ... DONE
[10:29:51.119]  - use_args: TRUE
[10:29:51.120]  - Getting '...' globals ...
[10:29:51.120] resolve() on list ...
[10:29:51.120]  recursive: 0
[10:29:51.120]  length: 1
[10:29:51.120]  elements: ‘...’
[10:29:51.120]  length: 0 (resolved future 1)
[10:29:51.121] resolve() on list ... DONE
[10:29:51.121]    - '...' content: [n=0] 
[10:29:51.121] List of 1
[10:29:51.121]  $ ...: list()
[10:29:51.121]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.121]  - attr(*, "where")=List of 1
[10:29:51.121]   ..$ ...:<environment: 0x5618a10ed1b0> 
[10:29:51.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.121]  - attr(*, "resolved")= logi TRUE
[10:29:51.121]  - attr(*, "total_size")= num NA
[10:29:51.126]  - Getting '...' globals ... DONE
[10:29:51.126] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:51.126] List of 2
[10:29:51.126]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:51.126]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:51.126]  $ ...          : list()
[10:29:51.126]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.126]  - attr(*, "where")=List of 2
[10:29:51.126]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:51.126]   ..$ ...          :<environment: 0x5618a10ed1b0> 
[10:29:51.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.126]  - attr(*, "resolved")= logi FALSE
[10:29:51.126]  - attr(*, "total_size")= num 354224
[10:29:51.130] Packages to be attached in all futures: [n=0] 
[10:29:51.131] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.135] future_lapply() ...
[10:29:51.186] Number of chunks: 2
[10:29:51.186] getGlobalsAndPackagesXApply() ...
[10:29:51.186]  - future.globals: <name-value list> with names ‘list()’
[10:29:51.186]  - use_args: TRUE
[10:29:51.186] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:51.186] List of 2
[10:29:51.186]  $ ...          : list()
[10:29:51.186]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.186]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:29:51.186]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:29:51.186]  - attr(*, "where")=List of 2
[10:29:51.186]   ..$ ...          :<environment: 0x5618a10ed1b0> 
[10:29:51.186]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:51.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.186]  - attr(*, "resolved")= logi FALSE
[10:29:51.186]  - attr(*, "total_size")= num NA
[10:29:51.190] Packages to be attached in all futures: [n=0] 
[10:29:51.190] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.190] Number of futures (= number of chunks): 2
[10:29:51.191] Launching 2 futures (chunks) ...
[10:29:51.191] Chunk #1 of 2 ...
[10:29:51.191]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.191]  - seeds: <none>
[10:29:51.191]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.191] getGlobalsAndPackages() ...
[10:29:51.191] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.191] Resolving globals: FALSE
[10:29:51.191] Tweak future expression to call with '...' arguments ...
[10:29:51.192] {
[10:29:51.192]     do.call(function(...) {
[10:29:51.192]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.192]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.192]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.192]             on.exit(options(oopts), add = TRUE)
[10:29:51.192]         }
[10:29:51.192]         {
[10:29:51.192]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.192]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.192]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.192]             })
[10:29:51.192]         }
[10:29:51.192]     }, args = future.call.arguments)
[10:29:51.192] }
[10:29:51.192] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.192] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.192] 
[10:29:51.192] getGlobalsAndPackages() ... DONE
[10:29:51.193] run() for ‘Future’ ...
[10:29:51.193] - state: ‘created’
[10:29:51.193] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.206] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.207]   - Field: ‘node’
[10:29:51.207]   - Field: ‘label’
[10:29:51.207]   - Field: ‘local’
[10:29:51.207]   - Field: ‘owner’
[10:29:51.207]   - Field: ‘envir’
[10:29:51.207]   - Field: ‘workers’
[10:29:51.207]   - Field: ‘packages’
[10:29:51.207]   - Field: ‘gc’
[10:29:51.207]   - Field: ‘conditions’
[10:29:51.208]   - Field: ‘persistent’
[10:29:51.208]   - Field: ‘expr’
[10:29:51.208]   - Field: ‘uuid’
[10:29:51.208]   - Field: ‘seed’
[10:29:51.208]   - Field: ‘version’
[10:29:51.208]   - Field: ‘result’
[10:29:51.208]   - Field: ‘asynchronous’
[10:29:51.208]   - Field: ‘calls’
[10:29:51.208]   - Field: ‘globals’
[10:29:51.208]   - Field: ‘stdout’
[10:29:51.208]   - Field: ‘earlySignal’
[10:29:51.209]   - Field: ‘lazy’
[10:29:51.209]   - Field: ‘state’
[10:29:51.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.209] - Launch lazy future ...
[10:29:51.209] Packages needed by the future expression (n = 0): <none>
[10:29:51.209] Packages needed by future strategies (n = 0): <none>
[10:29:51.210] {
[10:29:51.210]     {
[10:29:51.210]         {
[10:29:51.210]             ...future.startTime <- base::Sys.time()
[10:29:51.210]             {
[10:29:51.210]                 {
[10:29:51.210]                   {
[10:29:51.210]                     {
[10:29:51.210]                       base::local({
[10:29:51.210]                         has_future <- base::requireNamespace("future", 
[10:29:51.210]                           quietly = TRUE)
[10:29:51.210]                         if (has_future) {
[10:29:51.210]                           ns <- base::getNamespace("future")
[10:29:51.210]                           version <- ns[[".package"]][["version"]]
[10:29:51.210]                           if (is.null(version)) 
[10:29:51.210]                             version <- utils::packageVersion("future")
[10:29:51.210]                         }
[10:29:51.210]                         else {
[10:29:51.210]                           version <- NULL
[10:29:51.210]                         }
[10:29:51.210]                         if (!has_future || version < "1.8.0") {
[10:29:51.210]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.210]                             "", base::R.version$version.string), 
[10:29:51.210]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:51.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:51.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.210]                               "release", "version")], collapse = " "), 
[10:29:51.210]                             hostname = base::Sys.info()[["nodename"]])
[10:29:51.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.210]                             info)
[10:29:51.210]                           info <- base::paste(info, collapse = "; ")
[10:29:51.210]                           if (!has_future) {
[10:29:51.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.210]                               info)
[10:29:51.210]                           }
[10:29:51.210]                           else {
[10:29:51.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.210]                               info, version)
[10:29:51.210]                           }
[10:29:51.210]                           base::stop(msg)
[10:29:51.210]                         }
[10:29:51.210]                       })
[10:29:51.210]                     }
[10:29:51.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.210]                     base::options(mc.cores = 1L)
[10:29:51.210]                   }
[10:29:51.210]                   ...future.strategy.old <- future::plan("list")
[10:29:51.210]                   options(future.plan = NULL)
[10:29:51.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.210]                 }
[10:29:51.210]                 ...future.workdir <- getwd()
[10:29:51.210]             }
[10:29:51.210]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.210]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.210]         }
[10:29:51.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.210]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.210]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.210]             base::names(...future.oldOptions))
[10:29:51.210]     }
[10:29:51.210]     if (FALSE) {
[10:29:51.210]     }
[10:29:51.210]     else {
[10:29:51.210]         if (TRUE) {
[10:29:51.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.210]                 open = "w")
[10:29:51.210]         }
[10:29:51.210]         else {
[10:29:51.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.210]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.210]         }
[10:29:51.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.210]             base::sink(type = "output", split = FALSE)
[10:29:51.210]             base::close(...future.stdout)
[10:29:51.210]         }, add = TRUE)
[10:29:51.210]     }
[10:29:51.210]     ...future.frame <- base::sys.nframe()
[10:29:51.210]     ...future.conditions <- base::list()
[10:29:51.210]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.210]     if (FALSE) {
[10:29:51.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.210]     }
[10:29:51.210]     ...future.result <- base::tryCatch({
[10:29:51.210]         base::withCallingHandlers({
[10:29:51.210]             ...future.value <- base::withVisible(base::local({
[10:29:51.210]                 ...future.makeSendCondition <- base::local({
[10:29:51.210]                   sendCondition <- NULL
[10:29:51.210]                   function(frame = 1L) {
[10:29:51.210]                     if (is.function(sendCondition)) 
[10:29:51.210]                       return(sendCondition)
[10:29:51.210]                     ns <- getNamespace("parallel")
[10:29:51.210]                     if (exists("sendData", mode = "function", 
[10:29:51.210]                       envir = ns)) {
[10:29:51.210]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.210]                         envir = ns)
[10:29:51.210]                       envir <- sys.frame(frame)
[10:29:51.210]                       master <- NULL
[10:29:51.210]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.210]                         !identical(envir, emptyenv())) {
[10:29:51.210]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.210]                           inherits = FALSE)) {
[10:29:51.210]                           master <- get("master", mode = "list", 
[10:29:51.210]                             envir = envir, inherits = FALSE)
[10:29:51.210]                           if (inherits(master, c("SOCKnode", 
[10:29:51.210]                             "SOCK0node"))) {
[10:29:51.210]                             sendCondition <<- function(cond) {
[10:29:51.210]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.210]                                 success = TRUE)
[10:29:51.210]                               parallel_sendData(master, data)
[10:29:51.210]                             }
[10:29:51.210]                             return(sendCondition)
[10:29:51.210]                           }
[10:29:51.210]                         }
[10:29:51.210]                         frame <- frame + 1L
[10:29:51.210]                         envir <- sys.frame(frame)
[10:29:51.210]                       }
[10:29:51.210]                     }
[10:29:51.210]                     sendCondition <<- function(cond) NULL
[10:29:51.210]                   }
[10:29:51.210]                 })
[10:29:51.210]                 withCallingHandlers({
[10:29:51.210]                   {
[10:29:51.210]                     do.call(function(...) {
[10:29:51.210]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.210]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.210]                         ...future.globals.maxSize)) {
[10:29:51.210]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.210]                         on.exit(options(oopts), add = TRUE)
[10:29:51.210]                       }
[10:29:51.210]                       {
[10:29:51.210]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.210]                           FUN = function(jj) {
[10:29:51.210]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.210]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.210]                           })
[10:29:51.210]                       }
[10:29:51.210]                     }, args = future.call.arguments)
[10:29:51.210]                   }
[10:29:51.210]                 }, immediateCondition = function(cond) {
[10:29:51.210]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.210]                   sendCondition(cond)
[10:29:51.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.210]                   {
[10:29:51.210]                     inherits <- base::inherits
[10:29:51.210]                     invokeRestart <- base::invokeRestart
[10:29:51.210]                     is.null <- base::is.null
[10:29:51.210]                     muffled <- FALSE
[10:29:51.210]                     if (inherits(cond, "message")) {
[10:29:51.210]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.210]                       if (muffled) 
[10:29:51.210]                         invokeRestart("muffleMessage")
[10:29:51.210]                     }
[10:29:51.210]                     else if (inherits(cond, "warning")) {
[10:29:51.210]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.210]                       if (muffled) 
[10:29:51.210]                         invokeRestart("muffleWarning")
[10:29:51.210]                     }
[10:29:51.210]                     else if (inherits(cond, "condition")) {
[10:29:51.210]                       if (!is.null(pattern)) {
[10:29:51.210]                         computeRestarts <- base::computeRestarts
[10:29:51.210]                         grepl <- base::grepl
[10:29:51.210]                         restarts <- computeRestarts(cond)
[10:29:51.210]                         for (restart in restarts) {
[10:29:51.210]                           name <- restart$name
[10:29:51.210]                           if (is.null(name)) 
[10:29:51.210]                             next
[10:29:51.210]                           if (!grepl(pattern, name)) 
[10:29:51.210]                             next
[10:29:51.210]                           invokeRestart(restart)
[10:29:51.210]                           muffled <- TRUE
[10:29:51.210]                           break
[10:29:51.210]                         }
[10:29:51.210]                       }
[10:29:51.210]                     }
[10:29:51.210]                     invisible(muffled)
[10:29:51.210]                   }
[10:29:51.210]                   muffleCondition(cond)
[10:29:51.210]                 })
[10:29:51.210]             }))
[10:29:51.210]             future::FutureResult(value = ...future.value$value, 
[10:29:51.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.210]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.210]                     ...future.globalenv.names))
[10:29:51.210]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.210]         }, condition = base::local({
[10:29:51.210]             c <- base::c
[10:29:51.210]             inherits <- base::inherits
[10:29:51.210]             invokeRestart <- base::invokeRestart
[10:29:51.210]             length <- base::length
[10:29:51.210]             list <- base::list
[10:29:51.210]             seq.int <- base::seq.int
[10:29:51.210]             signalCondition <- base::signalCondition
[10:29:51.210]             sys.calls <- base::sys.calls
[10:29:51.210]             `[[` <- base::`[[`
[10:29:51.210]             `+` <- base::`+`
[10:29:51.210]             `<<-` <- base::`<<-`
[10:29:51.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.210]                   3L)]
[10:29:51.210]             }
[10:29:51.210]             function(cond) {
[10:29:51.210]                 is_error <- inherits(cond, "error")
[10:29:51.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.210]                   NULL)
[10:29:51.210]                 if (is_error) {
[10:29:51.210]                   sessionInformation <- function() {
[10:29:51.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.210]                       search = base::search(), system = base::Sys.info())
[10:29:51.210]                   }
[10:29:51.210]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.210]                     cond$call), session = sessionInformation(), 
[10:29:51.210]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.210]                   signalCondition(cond)
[10:29:51.210]                 }
[10:29:51.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.210]                 "immediateCondition"))) {
[10:29:51.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.210]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.210]                   if (TRUE && !signal) {
[10:29:51.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.210]                     {
[10:29:51.210]                       inherits <- base::inherits
[10:29:51.210]                       invokeRestart <- base::invokeRestart
[10:29:51.210]                       is.null <- base::is.null
[10:29:51.210]                       muffled <- FALSE
[10:29:51.210]                       if (inherits(cond, "message")) {
[10:29:51.210]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.210]                         if (muffled) 
[10:29:51.210]                           invokeRestart("muffleMessage")
[10:29:51.210]                       }
[10:29:51.210]                       else if (inherits(cond, "warning")) {
[10:29:51.210]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.210]                         if (muffled) 
[10:29:51.210]                           invokeRestart("muffleWarning")
[10:29:51.210]                       }
[10:29:51.210]                       else if (inherits(cond, "condition")) {
[10:29:51.210]                         if (!is.null(pattern)) {
[10:29:51.210]                           computeRestarts <- base::computeRestarts
[10:29:51.210]                           grepl <- base::grepl
[10:29:51.210]                           restarts <- computeRestarts(cond)
[10:29:51.210]                           for (restart in restarts) {
[10:29:51.210]                             name <- restart$name
[10:29:51.210]                             if (is.null(name)) 
[10:29:51.210]                               next
[10:29:51.210]                             if (!grepl(pattern, name)) 
[10:29:51.210]                               next
[10:29:51.210]                             invokeRestart(restart)
[10:29:51.210]                             muffled <- TRUE
[10:29:51.210]                             break
[10:29:51.210]                           }
[10:29:51.210]                         }
[10:29:51.210]                       }
[10:29:51.210]                       invisible(muffled)
[10:29:51.210]                     }
[10:29:51.210]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.210]                   }
[10:29:51.210]                 }
[10:29:51.210]                 else {
[10:29:51.210]                   if (TRUE) {
[10:29:51.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.210]                     {
[10:29:51.210]                       inherits <- base::inherits
[10:29:51.210]                       invokeRestart <- base::invokeRestart
[10:29:51.210]                       is.null <- base::is.null
[10:29:51.210]                       muffled <- FALSE
[10:29:51.210]                       if (inherits(cond, "message")) {
[10:29:51.210]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.210]                         if (muffled) 
[10:29:51.210]                           invokeRestart("muffleMessage")
[10:29:51.210]                       }
[10:29:51.210]                       else if (inherits(cond, "warning")) {
[10:29:51.210]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.210]                         if (muffled) 
[10:29:51.210]                           invokeRestart("muffleWarning")
[10:29:51.210]                       }
[10:29:51.210]                       else if (inherits(cond, "condition")) {
[10:29:51.210]                         if (!is.null(pattern)) {
[10:29:51.210]                           computeRestarts <- base::computeRestarts
[10:29:51.210]                           grepl <- base::grepl
[10:29:51.210]                           restarts <- computeRestarts(cond)
[10:29:51.210]                           for (restart in restarts) {
[10:29:51.210]                             name <- restart$name
[10:29:51.210]                             if (is.null(name)) 
[10:29:51.210]                               next
[10:29:51.210]                             if (!grepl(pattern, name)) 
[10:29:51.210]                               next
[10:29:51.210]                             invokeRestart(restart)
[10:29:51.210]                             muffled <- TRUE
[10:29:51.210]                             break
[10:29:51.210]                           }
[10:29:51.210]                         }
[10:29:51.210]                       }
[10:29:51.210]                       invisible(muffled)
[10:29:51.210]                     }
[10:29:51.210]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.210]                   }
[10:29:51.210]                 }
[10:29:51.210]             }
[10:29:51.210]         }))
[10:29:51.210]     }, error = function(ex) {
[10:29:51.210]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.210]                 ...future.rng), started = ...future.startTime, 
[10:29:51.210]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.210]             version = "1.8"), class = "FutureResult")
[10:29:51.210]     }, finally = {
[10:29:51.210]         if (!identical(...future.workdir, getwd())) 
[10:29:51.210]             setwd(...future.workdir)
[10:29:51.210]         {
[10:29:51.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.210]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.210]             }
[10:29:51.210]             base::options(...future.oldOptions)
[10:29:51.210]             if (.Platform$OS.type == "windows") {
[10:29:51.210]                 old_names <- names(...future.oldEnvVars)
[10:29:51.210]                 envs <- base::Sys.getenv()
[10:29:51.210]                 names <- names(envs)
[10:29:51.210]                 common <- intersect(names, old_names)
[10:29:51.210]                 added <- setdiff(names, old_names)
[10:29:51.210]                 removed <- setdiff(old_names, names)
[10:29:51.210]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.210]                   envs[common]]
[10:29:51.210]                 NAMES <- toupper(changed)
[10:29:51.210]                 args <- list()
[10:29:51.210]                 for (kk in seq_along(NAMES)) {
[10:29:51.210]                   name <- changed[[kk]]
[10:29:51.210]                   NAME <- NAMES[[kk]]
[10:29:51.210]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.210]                     next
[10:29:51.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.210]                 }
[10:29:51.210]                 NAMES <- toupper(added)
[10:29:51.210]                 for (kk in seq_along(NAMES)) {
[10:29:51.210]                   name <- added[[kk]]
[10:29:51.210]                   NAME <- NAMES[[kk]]
[10:29:51.210]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.210]                     next
[10:29:51.210]                   args[[name]] <- ""
[10:29:51.210]                 }
[10:29:51.210]                 NAMES <- toupper(removed)
[10:29:51.210]                 for (kk in seq_along(NAMES)) {
[10:29:51.210]                   name <- removed[[kk]]
[10:29:51.210]                   NAME <- NAMES[[kk]]
[10:29:51.210]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.210]                     next
[10:29:51.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.210]                 }
[10:29:51.210]                 if (length(args) > 0) 
[10:29:51.210]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.210]             }
[10:29:51.210]             else {
[10:29:51.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.210]             }
[10:29:51.210]             {
[10:29:51.210]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.210]                   0L) {
[10:29:51.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.210]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.210]                   base::options(opts)
[10:29:51.210]                 }
[10:29:51.210]                 {
[10:29:51.210]                   {
[10:29:51.210]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.210]                     NULL
[10:29:51.210]                   }
[10:29:51.210]                   options(future.plan = NULL)
[10:29:51.210]                   if (is.na(NA_character_)) 
[10:29:51.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.210]                     .init = FALSE)
[10:29:51.210]                 }
[10:29:51.210]             }
[10:29:51.210]         }
[10:29:51.210]     })
[10:29:51.210]     if (TRUE) {
[10:29:51.210]         base::sink(type = "output", split = FALSE)
[10:29:51.210]         if (TRUE) {
[10:29:51.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.210]         }
[10:29:51.210]         else {
[10:29:51.210]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.210]         }
[10:29:51.210]         base::close(...future.stdout)
[10:29:51.210]         ...future.stdout <- NULL
[10:29:51.210]     }
[10:29:51.210]     ...future.result$conditions <- ...future.conditions
[10:29:51.210]     ...future.result$finished <- base::Sys.time()
[10:29:51.210]     ...future.result
[10:29:51.210] }
[10:29:51.213] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[10:29:51.213] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:51.213] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.214] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[10:29:51.257] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[10:29:51.258] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[10:29:51.258] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[10:29:51.258] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:51.259] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.259] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:51.259] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:51.259] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[10:29:51.260] MultisessionFuture started
[10:29:51.260] - Launch lazy future ... done
[10:29:51.260] run() for ‘MultisessionFuture’ ... done
[10:29:51.260] Created future:
[10:29:51.261] MultisessionFuture:
[10:29:51.261] Label: ‘future_apply-1’
[10:29:51.261] Expression:
[10:29:51.261] {
[10:29:51.261]     do.call(function(...) {
[10:29:51.261]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.261]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.261]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.261]             on.exit(options(oopts), add = TRUE)
[10:29:51.261]         }
[10:29:51.261]         {
[10:29:51.261]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.261]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.261]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.261]             })
[10:29:51.261]         }
[10:29:51.261]     }, args = future.call.arguments)
[10:29:51.261] }
[10:29:51.261] Lazy evaluation: FALSE
[10:29:51.261] Asynchronous evaluation: TRUE
[10:29:51.261] Local evaluation: TRUE
[10:29:51.261] Environment: R_GlobalEnv
[10:29:51.261] Capture standard output: TRUE
[10:29:51.261] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.261] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.261] Packages: <none>
[10:29:51.261] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.261] Resolved: FALSE
[10:29:51.261] Value: <not collected>
[10:29:51.261] Conditions captured: <none>
[10:29:51.261] Early signaling: FALSE
[10:29:51.261] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.261] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.272] Chunk #1 of 2 ... DONE
[10:29:51.272] Chunk #2 of 2 ...
[10:29:51.273]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.273]  - seeds: <none>
[10:29:51.273]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.273] getGlobalsAndPackages() ...
[10:29:51.273] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.273] Resolving globals: FALSE
[10:29:51.273] Tweak future expression to call with '...' arguments ...
[10:29:51.274] {
[10:29:51.274]     do.call(function(...) {
[10:29:51.274]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.274]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.274]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.274]             on.exit(options(oopts), add = TRUE)
[10:29:51.274]         }
[10:29:51.274]         {
[10:29:51.274]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.274]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.274]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.274]             })
[10:29:51.274]         }
[10:29:51.274]     }, args = future.call.arguments)
[10:29:51.274] }
[10:29:51.274] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.274] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.274] 
[10:29:51.274] getGlobalsAndPackages() ... DONE
[10:29:51.275] run() for ‘Future’ ...
[10:29:51.275] - state: ‘created’
[10:29:51.275] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.289] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.289]   - Field: ‘node’
[10:29:51.289]   - Field: ‘label’
[10:29:51.289]   - Field: ‘local’
[10:29:51.289]   - Field: ‘owner’
[10:29:51.289]   - Field: ‘envir’
[10:29:51.289]   - Field: ‘workers’
[10:29:51.289]   - Field: ‘packages’
[10:29:51.290]   - Field: ‘gc’
[10:29:51.290]   - Field: ‘conditions’
[10:29:51.290]   - Field: ‘persistent’
[10:29:51.290]   - Field: ‘expr’
[10:29:51.290]   - Field: ‘uuid’
[10:29:51.290]   - Field: ‘seed’
[10:29:51.290]   - Field: ‘version’
[10:29:51.290]   - Field: ‘result’
[10:29:51.290]   - Field: ‘asynchronous’
[10:29:51.290]   - Field: ‘calls’
[10:29:51.290]   - Field: ‘globals’
[10:29:51.291]   - Field: ‘stdout’
[10:29:51.291]   - Field: ‘earlySignal’
[10:29:51.291]   - Field: ‘lazy’
[10:29:51.291]   - Field: ‘state’
[10:29:51.291] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.291] - Launch lazy future ...
[10:29:51.291] Packages needed by the future expression (n = 0): <none>
[10:29:51.291] Packages needed by future strategies (n = 0): <none>
[10:29:51.292] {
[10:29:51.292]     {
[10:29:51.292]         {
[10:29:51.292]             ...future.startTime <- base::Sys.time()
[10:29:51.292]             {
[10:29:51.292]                 {
[10:29:51.292]                   {
[10:29:51.292]                     {
[10:29:51.292]                       base::local({
[10:29:51.292]                         has_future <- base::requireNamespace("future", 
[10:29:51.292]                           quietly = TRUE)
[10:29:51.292]                         if (has_future) {
[10:29:51.292]                           ns <- base::getNamespace("future")
[10:29:51.292]                           version <- ns[[".package"]][["version"]]
[10:29:51.292]                           if (is.null(version)) 
[10:29:51.292]                             version <- utils::packageVersion("future")
[10:29:51.292]                         }
[10:29:51.292]                         else {
[10:29:51.292]                           version <- NULL
[10:29:51.292]                         }
[10:29:51.292]                         if (!has_future || version < "1.8.0") {
[10:29:51.292]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.292]                             "", base::R.version$version.string), 
[10:29:51.292]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:51.292]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:51.292]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.292]                               "release", "version")], collapse = " "), 
[10:29:51.292]                             hostname = base::Sys.info()[["nodename"]])
[10:29:51.292]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.292]                             info)
[10:29:51.292]                           info <- base::paste(info, collapse = "; ")
[10:29:51.292]                           if (!has_future) {
[10:29:51.292]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.292]                               info)
[10:29:51.292]                           }
[10:29:51.292]                           else {
[10:29:51.292]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.292]                               info, version)
[10:29:51.292]                           }
[10:29:51.292]                           base::stop(msg)
[10:29:51.292]                         }
[10:29:51.292]                       })
[10:29:51.292]                     }
[10:29:51.292]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.292]                     base::options(mc.cores = 1L)
[10:29:51.292]                   }
[10:29:51.292]                   ...future.strategy.old <- future::plan("list")
[10:29:51.292]                   options(future.plan = NULL)
[10:29:51.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.292]                 }
[10:29:51.292]                 ...future.workdir <- getwd()
[10:29:51.292]             }
[10:29:51.292]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.292]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.292]         }
[10:29:51.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.292]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.292]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.292]             base::names(...future.oldOptions))
[10:29:51.292]     }
[10:29:51.292]     if (FALSE) {
[10:29:51.292]     }
[10:29:51.292]     else {
[10:29:51.292]         if (TRUE) {
[10:29:51.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.292]                 open = "w")
[10:29:51.292]         }
[10:29:51.292]         else {
[10:29:51.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.292]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.292]         }
[10:29:51.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.292]             base::sink(type = "output", split = FALSE)
[10:29:51.292]             base::close(...future.stdout)
[10:29:51.292]         }, add = TRUE)
[10:29:51.292]     }
[10:29:51.292]     ...future.frame <- base::sys.nframe()
[10:29:51.292]     ...future.conditions <- base::list()
[10:29:51.292]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.292]     if (FALSE) {
[10:29:51.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.292]     }
[10:29:51.292]     ...future.result <- base::tryCatch({
[10:29:51.292]         base::withCallingHandlers({
[10:29:51.292]             ...future.value <- base::withVisible(base::local({
[10:29:51.292]                 ...future.makeSendCondition <- base::local({
[10:29:51.292]                   sendCondition <- NULL
[10:29:51.292]                   function(frame = 1L) {
[10:29:51.292]                     if (is.function(sendCondition)) 
[10:29:51.292]                       return(sendCondition)
[10:29:51.292]                     ns <- getNamespace("parallel")
[10:29:51.292]                     if (exists("sendData", mode = "function", 
[10:29:51.292]                       envir = ns)) {
[10:29:51.292]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.292]                         envir = ns)
[10:29:51.292]                       envir <- sys.frame(frame)
[10:29:51.292]                       master <- NULL
[10:29:51.292]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.292]                         !identical(envir, emptyenv())) {
[10:29:51.292]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.292]                           inherits = FALSE)) {
[10:29:51.292]                           master <- get("master", mode = "list", 
[10:29:51.292]                             envir = envir, inherits = FALSE)
[10:29:51.292]                           if (inherits(master, c("SOCKnode", 
[10:29:51.292]                             "SOCK0node"))) {
[10:29:51.292]                             sendCondition <<- function(cond) {
[10:29:51.292]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.292]                                 success = TRUE)
[10:29:51.292]                               parallel_sendData(master, data)
[10:29:51.292]                             }
[10:29:51.292]                             return(sendCondition)
[10:29:51.292]                           }
[10:29:51.292]                         }
[10:29:51.292]                         frame <- frame + 1L
[10:29:51.292]                         envir <- sys.frame(frame)
[10:29:51.292]                       }
[10:29:51.292]                     }
[10:29:51.292]                     sendCondition <<- function(cond) NULL
[10:29:51.292]                   }
[10:29:51.292]                 })
[10:29:51.292]                 withCallingHandlers({
[10:29:51.292]                   {
[10:29:51.292]                     do.call(function(...) {
[10:29:51.292]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.292]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.292]                         ...future.globals.maxSize)) {
[10:29:51.292]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.292]                         on.exit(options(oopts), add = TRUE)
[10:29:51.292]                       }
[10:29:51.292]                       {
[10:29:51.292]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.292]                           FUN = function(jj) {
[10:29:51.292]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.292]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.292]                           })
[10:29:51.292]                       }
[10:29:51.292]                     }, args = future.call.arguments)
[10:29:51.292]                   }
[10:29:51.292]                 }, immediateCondition = function(cond) {
[10:29:51.292]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.292]                   sendCondition(cond)
[10:29:51.292]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.292]                   {
[10:29:51.292]                     inherits <- base::inherits
[10:29:51.292]                     invokeRestart <- base::invokeRestart
[10:29:51.292]                     is.null <- base::is.null
[10:29:51.292]                     muffled <- FALSE
[10:29:51.292]                     if (inherits(cond, "message")) {
[10:29:51.292]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.292]                       if (muffled) 
[10:29:51.292]                         invokeRestart("muffleMessage")
[10:29:51.292]                     }
[10:29:51.292]                     else if (inherits(cond, "warning")) {
[10:29:51.292]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.292]                       if (muffled) 
[10:29:51.292]                         invokeRestart("muffleWarning")
[10:29:51.292]                     }
[10:29:51.292]                     else if (inherits(cond, "condition")) {
[10:29:51.292]                       if (!is.null(pattern)) {
[10:29:51.292]                         computeRestarts <- base::computeRestarts
[10:29:51.292]                         grepl <- base::grepl
[10:29:51.292]                         restarts <- computeRestarts(cond)
[10:29:51.292]                         for (restart in restarts) {
[10:29:51.292]                           name <- restart$name
[10:29:51.292]                           if (is.null(name)) 
[10:29:51.292]                             next
[10:29:51.292]                           if (!grepl(pattern, name)) 
[10:29:51.292]                             next
[10:29:51.292]                           invokeRestart(restart)
[10:29:51.292]                           muffled <- TRUE
[10:29:51.292]                           break
[10:29:51.292]                         }
[10:29:51.292]                       }
[10:29:51.292]                     }
[10:29:51.292]                     invisible(muffled)
[10:29:51.292]                   }
[10:29:51.292]                   muffleCondition(cond)
[10:29:51.292]                 })
[10:29:51.292]             }))
[10:29:51.292]             future::FutureResult(value = ...future.value$value, 
[10:29:51.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.292]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.292]                     ...future.globalenv.names))
[10:29:51.292]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.292]         }, condition = base::local({
[10:29:51.292]             c <- base::c
[10:29:51.292]             inherits <- base::inherits
[10:29:51.292]             invokeRestart <- base::invokeRestart
[10:29:51.292]             length <- base::length
[10:29:51.292]             list <- base::list
[10:29:51.292]             seq.int <- base::seq.int
[10:29:51.292]             signalCondition <- base::signalCondition
[10:29:51.292]             sys.calls <- base::sys.calls
[10:29:51.292]             `[[` <- base::`[[`
[10:29:51.292]             `+` <- base::`+`
[10:29:51.292]             `<<-` <- base::`<<-`
[10:29:51.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.292]                   3L)]
[10:29:51.292]             }
[10:29:51.292]             function(cond) {
[10:29:51.292]                 is_error <- inherits(cond, "error")
[10:29:51.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.292]                   NULL)
[10:29:51.292]                 if (is_error) {
[10:29:51.292]                   sessionInformation <- function() {
[10:29:51.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.292]                       search = base::search(), system = base::Sys.info())
[10:29:51.292]                   }
[10:29:51.292]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.292]                     cond$call), session = sessionInformation(), 
[10:29:51.292]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.292]                   signalCondition(cond)
[10:29:51.292]                 }
[10:29:51.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.292]                 "immediateCondition"))) {
[10:29:51.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.292]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.292]                   if (TRUE && !signal) {
[10:29:51.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.292]                     {
[10:29:51.292]                       inherits <- base::inherits
[10:29:51.292]                       invokeRestart <- base::invokeRestart
[10:29:51.292]                       is.null <- base::is.null
[10:29:51.292]                       muffled <- FALSE
[10:29:51.292]                       if (inherits(cond, "message")) {
[10:29:51.292]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.292]                         if (muffled) 
[10:29:51.292]                           invokeRestart("muffleMessage")
[10:29:51.292]                       }
[10:29:51.292]                       else if (inherits(cond, "warning")) {
[10:29:51.292]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.292]                         if (muffled) 
[10:29:51.292]                           invokeRestart("muffleWarning")
[10:29:51.292]                       }
[10:29:51.292]                       else if (inherits(cond, "condition")) {
[10:29:51.292]                         if (!is.null(pattern)) {
[10:29:51.292]                           computeRestarts <- base::computeRestarts
[10:29:51.292]                           grepl <- base::grepl
[10:29:51.292]                           restarts <- computeRestarts(cond)
[10:29:51.292]                           for (restart in restarts) {
[10:29:51.292]                             name <- restart$name
[10:29:51.292]                             if (is.null(name)) 
[10:29:51.292]                               next
[10:29:51.292]                             if (!grepl(pattern, name)) 
[10:29:51.292]                               next
[10:29:51.292]                             invokeRestart(restart)
[10:29:51.292]                             muffled <- TRUE
[10:29:51.292]                             break
[10:29:51.292]                           }
[10:29:51.292]                         }
[10:29:51.292]                       }
[10:29:51.292]                       invisible(muffled)
[10:29:51.292]                     }
[10:29:51.292]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.292]                   }
[10:29:51.292]                 }
[10:29:51.292]                 else {
[10:29:51.292]                   if (TRUE) {
[10:29:51.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.292]                     {
[10:29:51.292]                       inherits <- base::inherits
[10:29:51.292]                       invokeRestart <- base::invokeRestart
[10:29:51.292]                       is.null <- base::is.null
[10:29:51.292]                       muffled <- FALSE
[10:29:51.292]                       if (inherits(cond, "message")) {
[10:29:51.292]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.292]                         if (muffled) 
[10:29:51.292]                           invokeRestart("muffleMessage")
[10:29:51.292]                       }
[10:29:51.292]                       else if (inherits(cond, "warning")) {
[10:29:51.292]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.292]                         if (muffled) 
[10:29:51.292]                           invokeRestart("muffleWarning")
[10:29:51.292]                       }
[10:29:51.292]                       else if (inherits(cond, "condition")) {
[10:29:51.292]                         if (!is.null(pattern)) {
[10:29:51.292]                           computeRestarts <- base::computeRestarts
[10:29:51.292]                           grepl <- base::grepl
[10:29:51.292]                           restarts <- computeRestarts(cond)
[10:29:51.292]                           for (restart in restarts) {
[10:29:51.292]                             name <- restart$name
[10:29:51.292]                             if (is.null(name)) 
[10:29:51.292]                               next
[10:29:51.292]                             if (!grepl(pattern, name)) 
[10:29:51.292]                               next
[10:29:51.292]                             invokeRestart(restart)
[10:29:51.292]                             muffled <- TRUE
[10:29:51.292]                             break
[10:29:51.292]                           }
[10:29:51.292]                         }
[10:29:51.292]                       }
[10:29:51.292]                       invisible(muffled)
[10:29:51.292]                     }
[10:29:51.292]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.292]                   }
[10:29:51.292]                 }
[10:29:51.292]             }
[10:29:51.292]         }))
[10:29:51.292]     }, error = function(ex) {
[10:29:51.292]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.292]                 ...future.rng), started = ...future.startTime, 
[10:29:51.292]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.292]             version = "1.8"), class = "FutureResult")
[10:29:51.292]     }, finally = {
[10:29:51.292]         if (!identical(...future.workdir, getwd())) 
[10:29:51.292]             setwd(...future.workdir)
[10:29:51.292]         {
[10:29:51.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.292]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.292]             }
[10:29:51.292]             base::options(...future.oldOptions)
[10:29:51.292]             if (.Platform$OS.type == "windows") {
[10:29:51.292]                 old_names <- names(...future.oldEnvVars)
[10:29:51.292]                 envs <- base::Sys.getenv()
[10:29:51.292]                 names <- names(envs)
[10:29:51.292]                 common <- intersect(names, old_names)
[10:29:51.292]                 added <- setdiff(names, old_names)
[10:29:51.292]                 removed <- setdiff(old_names, names)
[10:29:51.292]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.292]                   envs[common]]
[10:29:51.292]                 NAMES <- toupper(changed)
[10:29:51.292]                 args <- list()
[10:29:51.292]                 for (kk in seq_along(NAMES)) {
[10:29:51.292]                   name <- changed[[kk]]
[10:29:51.292]                   NAME <- NAMES[[kk]]
[10:29:51.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.292]                     next
[10:29:51.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.292]                 }
[10:29:51.292]                 NAMES <- toupper(added)
[10:29:51.292]                 for (kk in seq_along(NAMES)) {
[10:29:51.292]                   name <- added[[kk]]
[10:29:51.292]                   NAME <- NAMES[[kk]]
[10:29:51.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.292]                     next
[10:29:51.292]                   args[[name]] <- ""
[10:29:51.292]                 }
[10:29:51.292]                 NAMES <- toupper(removed)
[10:29:51.292]                 for (kk in seq_along(NAMES)) {
[10:29:51.292]                   name <- removed[[kk]]
[10:29:51.292]                   NAME <- NAMES[[kk]]
[10:29:51.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.292]                     next
[10:29:51.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.292]                 }
[10:29:51.292]                 if (length(args) > 0) 
[10:29:51.292]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.292]             }
[10:29:51.292]             else {
[10:29:51.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.292]             }
[10:29:51.292]             {
[10:29:51.292]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.292]                   0L) {
[10:29:51.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.292]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.292]                   base::options(opts)
[10:29:51.292]                 }
[10:29:51.292]                 {
[10:29:51.292]                   {
[10:29:51.292]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.292]                     NULL
[10:29:51.292]                   }
[10:29:51.292]                   options(future.plan = NULL)
[10:29:51.292]                   if (is.na(NA_character_)) 
[10:29:51.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.292]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.292]                     .init = FALSE)
[10:29:51.292]                 }
[10:29:51.292]             }
[10:29:51.292]         }
[10:29:51.292]     })
[10:29:51.292]     if (TRUE) {
[10:29:51.292]         base::sink(type = "output", split = FALSE)
[10:29:51.292]         if (TRUE) {
[10:29:51.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.292]         }
[10:29:51.292]         else {
[10:29:51.292]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.292]         }
[10:29:51.292]         base::close(...future.stdout)
[10:29:51.292]         ...future.stdout <- NULL
[10:29:51.292]     }
[10:29:51.292]     ...future.result$conditions <- ...future.conditions
[10:29:51.292]     ...future.result$finished <- base::Sys.time()
[10:29:51.292]     ...future.result
[10:29:51.292] }
[10:29:51.295] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[10:29:51.295] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:51.299] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:51.299] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[10:29:51.345] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[10:29:51.346] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[10:29:51.346] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[10:29:51.346] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:51.346] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:51.346] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:29:51.347] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:29:51.347] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[10:29:51.347] MultisessionFuture started
[10:29:51.348] - Launch lazy future ... done
[10:29:51.348] run() for ‘MultisessionFuture’ ... done
[10:29:51.348] Created future:
[10:29:51.348] MultisessionFuture:
[10:29:51.348] Label: ‘future_apply-2’
[10:29:51.348] Expression:
[10:29:51.348] {
[10:29:51.348]     do.call(function(...) {
[10:29:51.348]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.348]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.348]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.348]             on.exit(options(oopts), add = TRUE)
[10:29:51.348]         }
[10:29:51.348]         {
[10:29:51.348]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.348]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.348]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.348]             })
[10:29:51.348]         }
[10:29:51.348]     }, args = future.call.arguments)
[10:29:51.348] }
[10:29:51.348] Lazy evaluation: FALSE
[10:29:51.348] Asynchronous evaluation: TRUE
[10:29:51.348] Local evaluation: TRUE
[10:29:51.348] Environment: R_GlobalEnv
[10:29:51.348] Capture standard output: TRUE
[10:29:51.348] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.348] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.348] Packages: <none>
[10:29:51.348] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.348] Resolved: FALSE
[10:29:51.348] Value: <not collected>
[10:29:51.348] Conditions captured: <none>
[10:29:51.348] Early signaling: FALSE
[10:29:51.348] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.348] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.360] Chunk #2 of 2 ... DONE
[10:29:51.360] Launching 2 futures (chunks) ... DONE
[10:29:51.360] Resolving 2 futures (chunks) ...
[10:29:51.360] resolve() on list ...
[10:29:51.360]  recursive: 0
[10:29:51.360]  length: 2
[10:29:51.360] 
[10:29:51.361] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.361] - Validating connection of MultisessionFuture
[10:29:51.361] - received message: FutureResult
[10:29:51.361] - Received FutureResult
[10:29:51.361] - Erased future from FutureRegistry
[10:29:51.361] result() for ClusterFuture ...
[10:29:51.362] - result already collected: FutureResult
[10:29:51.362] result() for ClusterFuture ... done
[10:29:51.362] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.362] Future #1
[10:29:51.362] result() for ClusterFuture ...
[10:29:51.362] - result already collected: FutureResult
[10:29:51.362] result() for ClusterFuture ... done
[10:29:51.362] result() for ClusterFuture ...
[10:29:51.362] - result already collected: FutureResult
[10:29:51.362] result() for ClusterFuture ... done
[10:29:51.362] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:51.363] - nx: 2
[10:29:51.363] - relay: TRUE
[10:29:51.363] - stdout: TRUE
[10:29:51.363] - signal: TRUE
[10:29:51.363] - resignal: FALSE
[10:29:51.363] - force: TRUE
[10:29:51.363] - relayed: [n=2] FALSE, FALSE
[10:29:51.363] - queued futures: [n=2] FALSE, FALSE
[10:29:51.363]  - until=1
[10:29:51.363]  - relaying element #1
[10:29:51.363] result() for ClusterFuture ...
[10:29:51.364] - result already collected: FutureResult
[10:29:51.364] result() for ClusterFuture ... done
[10:29:51.364] result() for ClusterFuture ...
[10:29:51.364] - result already collected: FutureResult
[10:29:51.364] result() for ClusterFuture ... done
[10:29:51.364] result() for ClusterFuture ...
[10:29:51.364] - result already collected: FutureResult
[10:29:51.364] result() for ClusterFuture ... done
[10:29:51.364] result() for ClusterFuture ...
[10:29:51.364] - result already collected: FutureResult
[10:29:51.364] result() for ClusterFuture ... done
[10:29:51.367] - relayed: [n=2] TRUE, FALSE
[10:29:51.367] - queued futures: [n=2] TRUE, FALSE
[10:29:51.367] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:51.367]  length: 1 (resolved future 1)
[10:29:51.391] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.391] - Validating connection of MultisessionFuture
[10:29:51.391] - received message: FutureResult
[10:29:51.391] - Received FutureResult
[10:29:51.391] - Erased future from FutureRegistry
[10:29:51.391] result() for ClusterFuture ...
[10:29:51.391] - result already collected: FutureResult
[10:29:51.391] result() for ClusterFuture ... done
[10:29:51.392] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.392] Future #2
[10:29:51.392] result() for ClusterFuture ...
[10:29:51.392] - result already collected: FutureResult
[10:29:51.392] result() for ClusterFuture ... done
[10:29:51.392] result() for ClusterFuture ...
[10:29:51.392] - result already collected: FutureResult
[10:29:51.392] result() for ClusterFuture ... done
[10:29:51.392] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:51.392] - nx: 2
[10:29:51.392] - relay: TRUE
[10:29:51.392] - stdout: TRUE
[10:29:51.393] - signal: TRUE
[10:29:51.393] - resignal: FALSE
[10:29:51.393] - force: TRUE
[10:29:51.393] - relayed: [n=2] TRUE, FALSE
[10:29:51.393] - queued futures: [n=2] TRUE, FALSE
[10:29:51.393]  - until=2
[10:29:51.393]  - relaying element #2
[10:29:51.393] result() for ClusterFuture ...
[10:29:51.393] - result already collected: FutureResult
[10:29:51.393] result() for ClusterFuture ... done
[10:29:51.393] result() for ClusterFuture ...
[10:29:51.394] - result already collected: FutureResult
[10:29:51.394] result() for ClusterFuture ... done
[10:29:51.394] result() for ClusterFuture ...
[10:29:51.394] - result already collected: FutureResult
[10:29:51.394] result() for ClusterFuture ... done
[10:29:51.394] result() for ClusterFuture ...
[10:29:51.394] - result already collected: FutureResult
[10:29:51.394] result() for ClusterFuture ... done
[10:29:51.394] - relayed: [n=2] TRUE, TRUE
[10:29:51.394] - queued futures: [n=2] TRUE, TRUE
[10:29:51.394] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:51.395]  length: 0 (resolved future 2)
[10:29:51.395] Relaying remaining futures
[10:29:51.395] signalConditionsASAP(NULL, pos=0) ...
[10:29:51.395] - nx: 2
[10:29:51.395] - relay: TRUE
[10:29:51.395] - stdout: TRUE
[10:29:51.395] - signal: TRUE
[10:29:51.395] - resignal: FALSE
[10:29:51.395] - force: TRUE
[10:29:51.395] - relayed: [n=2] TRUE, TRUE
[10:29:51.395] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:51.395] - relayed: [n=2] TRUE, TRUE
[10:29:51.396] - queued futures: [n=2] TRUE, TRUE
[10:29:51.396] signalConditionsASAP(NULL, pos=0) ... done
[10:29:51.396] resolve() on list ... DONE
[10:29:51.396] result() for ClusterFuture ...
[10:29:51.396] - result already collected: FutureResult
[10:29:51.396] result() for ClusterFuture ... done
[10:29:51.396] result() for ClusterFuture ...
[10:29:51.396] - result already collected: FutureResult
[10:29:51.396] result() for ClusterFuture ... done
[10:29:51.396] result() for ClusterFuture ...
[10:29:51.396] - result already collected: FutureResult
[10:29:51.396] result() for ClusterFuture ... done
[10:29:51.397] result() for ClusterFuture ...
[10:29:51.397] - result already collected: FutureResult
[10:29:51.397] result() for ClusterFuture ... done
[10:29:51.397]  - Number of value chunks collected: 2
[10:29:51.397] Resolving 2 futures (chunks) ... DONE
[10:29:51.397] Reducing values from 2 chunks ...
[10:29:51.397]  - Number of values collected after concatenation: 2
[10:29:51.397]  - Number of values expected: 2
[10:29:51.397] Reducing values from 2 chunks ... DONE
[10:29:51.397] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:29:51.398] getGlobalsAndPackagesXApply() ...
[10:29:51.398]  - future.globals: TRUE
[10:29:51.398] getGlobalsAndPackages() ...
[10:29:51.398] Searching for globals...
[10:29:51.400] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:51.400] Searching for globals ... DONE
[10:29:51.400] Resolving globals: FALSE
[10:29:51.400] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:51.401] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:51.401] - globals: [1] ‘FUN’
[10:29:51.401] - packages: [1] ‘stats’
[10:29:51.401] getGlobalsAndPackages() ... DONE
[10:29:51.401]  - globals found/used: [n=1] ‘FUN’
[10:29:51.401]  - needed namespaces: [n=1] ‘stats’
[10:29:51.401] Finding globals ... DONE
[10:29:51.401]  - use_args: TRUE
[10:29:51.401]  - Getting '...' globals ...
[10:29:51.402] resolve() on list ...
[10:29:51.402]  recursive: 0
[10:29:51.402]  length: 1
[10:29:51.402]  elements: ‘...’
[10:29:51.402]  length: 0 (resolved future 1)
[10:29:51.402] resolve() on list ... DONE
[10:29:51.402]    - '...' content: [n=0] 
[10:29:51.402] List of 1
[10:29:51.402]  $ ...: list()
[10:29:51.402]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.402]  - attr(*, "where")=List of 1
[10:29:51.402]   ..$ ...:<environment: 0x5618a20b53e0> 
[10:29:51.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.402]  - attr(*, "resolved")= logi TRUE
[10:29:51.402]  - attr(*, "total_size")= num NA
[10:29:51.405]  - Getting '...' globals ... DONE
[10:29:51.405] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:51.405] List of 2
[10:29:51.405]  $ ...future.FUN:function (x, ...)  
[10:29:51.405]  $ ...          : list()
[10:29:51.405]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.405]  - attr(*, "where")=List of 2
[10:29:51.405]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:51.405]   ..$ ...          :<environment: 0x5618a20b53e0> 
[10:29:51.405]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.405]  - attr(*, "resolved")= logi FALSE
[10:29:51.405]  - attr(*, "total_size")= num 1248
[10:29:51.408] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:51.408] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.411] future_lapply() ...
[10:29:51.415] Number of chunks: 2
[10:29:51.415] getGlobalsAndPackagesXApply() ...
[10:29:51.415]  - future.globals: <name-value list> with names ‘list()’
[10:29:51.415]  - use_args: TRUE
[10:29:51.416] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:51.416] List of 2
[10:29:51.416]  $ ...          : list()
[10:29:51.416]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.416]  $ ...future.FUN:function (x, ...)  
[10:29:51.416]  - attr(*, "where")=List of 2
[10:29:51.416]   ..$ ...          :<environment: 0x5618a20b53e0> 
[10:29:51.416]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:29:51.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.416]  - attr(*, "resolved")= logi FALSE
[10:29:51.416]  - attr(*, "total_size")= num NA
[10:29:51.418] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:51.419] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.419] Number of futures (= number of chunks): 2
[10:29:51.419] Launching 2 futures (chunks) ...
[10:29:51.419] Chunk #1 of 2 ...
[10:29:51.419]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.419]  - seeds: <none>
[10:29:51.419]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.419] getGlobalsAndPackages() ...
[10:29:51.420] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.420] Resolving globals: FALSE
[10:29:51.420] Tweak future expression to call with '...' arguments ...
[10:29:51.420] {
[10:29:51.420]     do.call(function(...) {
[10:29:51.420]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.420]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.420]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.420]             on.exit(options(oopts), add = TRUE)
[10:29:51.420]         }
[10:29:51.420]         {
[10:29:51.420]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.420]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.420]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.420]             })
[10:29:51.420]         }
[10:29:51.420]     }, args = future.call.arguments)
[10:29:51.420] }
[10:29:51.420] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.421] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.421] - packages: [1] ‘stats’
[10:29:51.421] getGlobalsAndPackages() ... DONE
[10:29:51.421] run() for ‘Future’ ...
[10:29:51.421] - state: ‘created’
[10:29:51.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.435] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.435]   - Field: ‘node’
[10:29:51.435]   - Field: ‘label’
[10:29:51.435]   - Field: ‘local’
[10:29:51.435]   - Field: ‘owner’
[10:29:51.436]   - Field: ‘envir’
[10:29:51.436]   - Field: ‘workers’
[10:29:51.436]   - Field: ‘packages’
[10:29:51.436]   - Field: ‘gc’
[10:29:51.436]   - Field: ‘conditions’
[10:29:51.436]   - Field: ‘persistent’
[10:29:51.436]   - Field: ‘expr’
[10:29:51.436]   - Field: ‘uuid’
[10:29:51.436]   - Field: ‘seed’
[10:29:51.436]   - Field: ‘version’
[10:29:51.436]   - Field: ‘result’
[10:29:51.437]   - Field: ‘asynchronous’
[10:29:51.437]   - Field: ‘calls’
[10:29:51.437]   - Field: ‘globals’
[10:29:51.437]   - Field: ‘stdout’
[10:29:51.437]   - Field: ‘earlySignal’
[10:29:51.437]   - Field: ‘lazy’
[10:29:51.437]   - Field: ‘state’
[10:29:51.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.437] - Launch lazy future ...
[10:29:51.438] Packages needed by the future expression (n = 1): ‘stats’
[10:29:51.438] Packages needed by future strategies (n = 0): <none>
[10:29:51.438] {
[10:29:51.438]     {
[10:29:51.438]         {
[10:29:51.438]             ...future.startTime <- base::Sys.time()
[10:29:51.438]             {
[10:29:51.438]                 {
[10:29:51.438]                   {
[10:29:51.438]                     {
[10:29:51.438]                       {
[10:29:51.438]                         base::local({
[10:29:51.438]                           has_future <- base::requireNamespace("future", 
[10:29:51.438]                             quietly = TRUE)
[10:29:51.438]                           if (has_future) {
[10:29:51.438]                             ns <- base::getNamespace("future")
[10:29:51.438]                             version <- ns[[".package"]][["version"]]
[10:29:51.438]                             if (is.null(version)) 
[10:29:51.438]                               version <- utils::packageVersion("future")
[10:29:51.438]                           }
[10:29:51.438]                           else {
[10:29:51.438]                             version <- NULL
[10:29:51.438]                           }
[10:29:51.438]                           if (!has_future || version < "1.8.0") {
[10:29:51.438]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.438]                               "", base::R.version$version.string), 
[10:29:51.438]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:51.438]                                 base::R.version$platform, 8 * 
[10:29:51.438]                                   base::.Machine$sizeof.pointer), 
[10:29:51.438]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.438]                                 "release", "version")], collapse = " "), 
[10:29:51.438]                               hostname = base::Sys.info()[["nodename"]])
[10:29:51.438]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.438]                               info)
[10:29:51.438]                             info <- base::paste(info, collapse = "; ")
[10:29:51.438]                             if (!has_future) {
[10:29:51.438]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.438]                                 info)
[10:29:51.438]                             }
[10:29:51.438]                             else {
[10:29:51.438]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.438]                                 info, version)
[10:29:51.438]                             }
[10:29:51.438]                             base::stop(msg)
[10:29:51.438]                           }
[10:29:51.438]                         })
[10:29:51.438]                       }
[10:29:51.438]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.438]                       base::options(mc.cores = 1L)
[10:29:51.438]                     }
[10:29:51.438]                     base::local({
[10:29:51.438]                       for (pkg in "stats") {
[10:29:51.438]                         base::loadNamespace(pkg)
[10:29:51.438]                         base::library(pkg, character.only = TRUE)
[10:29:51.438]                       }
[10:29:51.438]                     })
[10:29:51.438]                   }
[10:29:51.438]                   ...future.strategy.old <- future::plan("list")
[10:29:51.438]                   options(future.plan = NULL)
[10:29:51.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.438]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.438]                 }
[10:29:51.438]                 ...future.workdir <- getwd()
[10:29:51.438]             }
[10:29:51.438]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.438]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.438]         }
[10:29:51.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.438]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.438]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.438]             base::names(...future.oldOptions))
[10:29:51.438]     }
[10:29:51.438]     if (FALSE) {
[10:29:51.438]     }
[10:29:51.438]     else {
[10:29:51.438]         if (TRUE) {
[10:29:51.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.438]                 open = "w")
[10:29:51.438]         }
[10:29:51.438]         else {
[10:29:51.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.438]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.438]         }
[10:29:51.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.438]             base::sink(type = "output", split = FALSE)
[10:29:51.438]             base::close(...future.stdout)
[10:29:51.438]         }, add = TRUE)
[10:29:51.438]     }
[10:29:51.438]     ...future.frame <- base::sys.nframe()
[10:29:51.438]     ...future.conditions <- base::list()
[10:29:51.438]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.438]     if (FALSE) {
[10:29:51.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.438]     }
[10:29:51.438]     ...future.result <- base::tryCatch({
[10:29:51.438]         base::withCallingHandlers({
[10:29:51.438]             ...future.value <- base::withVisible(base::local({
[10:29:51.438]                 ...future.makeSendCondition <- base::local({
[10:29:51.438]                   sendCondition <- NULL
[10:29:51.438]                   function(frame = 1L) {
[10:29:51.438]                     if (is.function(sendCondition)) 
[10:29:51.438]                       return(sendCondition)
[10:29:51.438]                     ns <- getNamespace("parallel")
[10:29:51.438]                     if (exists("sendData", mode = "function", 
[10:29:51.438]                       envir = ns)) {
[10:29:51.438]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.438]                         envir = ns)
[10:29:51.438]                       envir <- sys.frame(frame)
[10:29:51.438]                       master <- NULL
[10:29:51.438]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.438]                         !identical(envir, emptyenv())) {
[10:29:51.438]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.438]                           inherits = FALSE)) {
[10:29:51.438]                           master <- get("master", mode = "list", 
[10:29:51.438]                             envir = envir, inherits = FALSE)
[10:29:51.438]                           if (inherits(master, c("SOCKnode", 
[10:29:51.438]                             "SOCK0node"))) {
[10:29:51.438]                             sendCondition <<- function(cond) {
[10:29:51.438]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.438]                                 success = TRUE)
[10:29:51.438]                               parallel_sendData(master, data)
[10:29:51.438]                             }
[10:29:51.438]                             return(sendCondition)
[10:29:51.438]                           }
[10:29:51.438]                         }
[10:29:51.438]                         frame <- frame + 1L
[10:29:51.438]                         envir <- sys.frame(frame)
[10:29:51.438]                       }
[10:29:51.438]                     }
[10:29:51.438]                     sendCondition <<- function(cond) NULL
[10:29:51.438]                   }
[10:29:51.438]                 })
[10:29:51.438]                 withCallingHandlers({
[10:29:51.438]                   {
[10:29:51.438]                     do.call(function(...) {
[10:29:51.438]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.438]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.438]                         ...future.globals.maxSize)) {
[10:29:51.438]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.438]                         on.exit(options(oopts), add = TRUE)
[10:29:51.438]                       }
[10:29:51.438]                       {
[10:29:51.438]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.438]                           FUN = function(jj) {
[10:29:51.438]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.438]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.438]                           })
[10:29:51.438]                       }
[10:29:51.438]                     }, args = future.call.arguments)
[10:29:51.438]                   }
[10:29:51.438]                 }, immediateCondition = function(cond) {
[10:29:51.438]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.438]                   sendCondition(cond)
[10:29:51.438]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.438]                   {
[10:29:51.438]                     inherits <- base::inherits
[10:29:51.438]                     invokeRestart <- base::invokeRestart
[10:29:51.438]                     is.null <- base::is.null
[10:29:51.438]                     muffled <- FALSE
[10:29:51.438]                     if (inherits(cond, "message")) {
[10:29:51.438]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.438]                       if (muffled) 
[10:29:51.438]                         invokeRestart("muffleMessage")
[10:29:51.438]                     }
[10:29:51.438]                     else if (inherits(cond, "warning")) {
[10:29:51.438]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.438]                       if (muffled) 
[10:29:51.438]                         invokeRestart("muffleWarning")
[10:29:51.438]                     }
[10:29:51.438]                     else if (inherits(cond, "condition")) {
[10:29:51.438]                       if (!is.null(pattern)) {
[10:29:51.438]                         computeRestarts <- base::computeRestarts
[10:29:51.438]                         grepl <- base::grepl
[10:29:51.438]                         restarts <- computeRestarts(cond)
[10:29:51.438]                         for (restart in restarts) {
[10:29:51.438]                           name <- restart$name
[10:29:51.438]                           if (is.null(name)) 
[10:29:51.438]                             next
[10:29:51.438]                           if (!grepl(pattern, name)) 
[10:29:51.438]                             next
[10:29:51.438]                           invokeRestart(restart)
[10:29:51.438]                           muffled <- TRUE
[10:29:51.438]                           break
[10:29:51.438]                         }
[10:29:51.438]                       }
[10:29:51.438]                     }
[10:29:51.438]                     invisible(muffled)
[10:29:51.438]                   }
[10:29:51.438]                   muffleCondition(cond)
[10:29:51.438]                 })
[10:29:51.438]             }))
[10:29:51.438]             future::FutureResult(value = ...future.value$value, 
[10:29:51.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.438]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.438]                     ...future.globalenv.names))
[10:29:51.438]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.438]         }, condition = base::local({
[10:29:51.438]             c <- base::c
[10:29:51.438]             inherits <- base::inherits
[10:29:51.438]             invokeRestart <- base::invokeRestart
[10:29:51.438]             length <- base::length
[10:29:51.438]             list <- base::list
[10:29:51.438]             seq.int <- base::seq.int
[10:29:51.438]             signalCondition <- base::signalCondition
[10:29:51.438]             sys.calls <- base::sys.calls
[10:29:51.438]             `[[` <- base::`[[`
[10:29:51.438]             `+` <- base::`+`
[10:29:51.438]             `<<-` <- base::`<<-`
[10:29:51.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.438]                   3L)]
[10:29:51.438]             }
[10:29:51.438]             function(cond) {
[10:29:51.438]                 is_error <- inherits(cond, "error")
[10:29:51.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.438]                   NULL)
[10:29:51.438]                 if (is_error) {
[10:29:51.438]                   sessionInformation <- function() {
[10:29:51.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.438]                       search = base::search(), system = base::Sys.info())
[10:29:51.438]                   }
[10:29:51.438]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.438]                     cond$call), session = sessionInformation(), 
[10:29:51.438]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.438]                   signalCondition(cond)
[10:29:51.438]                 }
[10:29:51.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.438]                 "immediateCondition"))) {
[10:29:51.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.438]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.438]                   if (TRUE && !signal) {
[10:29:51.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.438]                     {
[10:29:51.438]                       inherits <- base::inherits
[10:29:51.438]                       invokeRestart <- base::invokeRestart
[10:29:51.438]                       is.null <- base::is.null
[10:29:51.438]                       muffled <- FALSE
[10:29:51.438]                       if (inherits(cond, "message")) {
[10:29:51.438]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.438]                         if (muffled) 
[10:29:51.438]                           invokeRestart("muffleMessage")
[10:29:51.438]                       }
[10:29:51.438]                       else if (inherits(cond, "warning")) {
[10:29:51.438]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.438]                         if (muffled) 
[10:29:51.438]                           invokeRestart("muffleWarning")
[10:29:51.438]                       }
[10:29:51.438]                       else if (inherits(cond, "condition")) {
[10:29:51.438]                         if (!is.null(pattern)) {
[10:29:51.438]                           computeRestarts <- base::computeRestarts
[10:29:51.438]                           grepl <- base::grepl
[10:29:51.438]                           restarts <- computeRestarts(cond)
[10:29:51.438]                           for (restart in restarts) {
[10:29:51.438]                             name <- restart$name
[10:29:51.438]                             if (is.null(name)) 
[10:29:51.438]                               next
[10:29:51.438]                             if (!grepl(pattern, name)) 
[10:29:51.438]                               next
[10:29:51.438]                             invokeRestart(restart)
[10:29:51.438]                             muffled <- TRUE
[10:29:51.438]                             break
[10:29:51.438]                           }
[10:29:51.438]                         }
[10:29:51.438]                       }
[10:29:51.438]                       invisible(muffled)
[10:29:51.438]                     }
[10:29:51.438]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.438]                   }
[10:29:51.438]                 }
[10:29:51.438]                 else {
[10:29:51.438]                   if (TRUE) {
[10:29:51.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.438]                     {
[10:29:51.438]                       inherits <- base::inherits
[10:29:51.438]                       invokeRestart <- base::invokeRestart
[10:29:51.438]                       is.null <- base::is.null
[10:29:51.438]                       muffled <- FALSE
[10:29:51.438]                       if (inherits(cond, "message")) {
[10:29:51.438]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.438]                         if (muffled) 
[10:29:51.438]                           invokeRestart("muffleMessage")
[10:29:51.438]                       }
[10:29:51.438]                       else if (inherits(cond, "warning")) {
[10:29:51.438]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.438]                         if (muffled) 
[10:29:51.438]                           invokeRestart("muffleWarning")
[10:29:51.438]                       }
[10:29:51.438]                       else if (inherits(cond, "condition")) {
[10:29:51.438]                         if (!is.null(pattern)) {
[10:29:51.438]                           computeRestarts <- base::computeRestarts
[10:29:51.438]                           grepl <- base::grepl
[10:29:51.438]                           restarts <- computeRestarts(cond)
[10:29:51.438]                           for (restart in restarts) {
[10:29:51.438]                             name <- restart$name
[10:29:51.438]                             if (is.null(name)) 
[10:29:51.438]                               next
[10:29:51.438]                             if (!grepl(pattern, name)) 
[10:29:51.438]                               next
[10:29:51.438]                             invokeRestart(restart)
[10:29:51.438]                             muffled <- TRUE
[10:29:51.438]                             break
[10:29:51.438]                           }
[10:29:51.438]                         }
[10:29:51.438]                       }
[10:29:51.438]                       invisible(muffled)
[10:29:51.438]                     }
[10:29:51.438]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.438]                   }
[10:29:51.438]                 }
[10:29:51.438]             }
[10:29:51.438]         }))
[10:29:51.438]     }, error = function(ex) {
[10:29:51.438]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.438]                 ...future.rng), started = ...future.startTime, 
[10:29:51.438]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.438]             version = "1.8"), class = "FutureResult")
[10:29:51.438]     }, finally = {
[10:29:51.438]         if (!identical(...future.workdir, getwd())) 
[10:29:51.438]             setwd(...future.workdir)
[10:29:51.438]         {
[10:29:51.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.438]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.438]             }
[10:29:51.438]             base::options(...future.oldOptions)
[10:29:51.438]             if (.Platform$OS.type == "windows") {
[10:29:51.438]                 old_names <- names(...future.oldEnvVars)
[10:29:51.438]                 envs <- base::Sys.getenv()
[10:29:51.438]                 names <- names(envs)
[10:29:51.438]                 common <- intersect(names, old_names)
[10:29:51.438]                 added <- setdiff(names, old_names)
[10:29:51.438]                 removed <- setdiff(old_names, names)
[10:29:51.438]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.438]                   envs[common]]
[10:29:51.438]                 NAMES <- toupper(changed)
[10:29:51.438]                 args <- list()
[10:29:51.438]                 for (kk in seq_along(NAMES)) {
[10:29:51.438]                   name <- changed[[kk]]
[10:29:51.438]                   NAME <- NAMES[[kk]]
[10:29:51.438]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.438]                     next
[10:29:51.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.438]                 }
[10:29:51.438]                 NAMES <- toupper(added)
[10:29:51.438]                 for (kk in seq_along(NAMES)) {
[10:29:51.438]                   name <- added[[kk]]
[10:29:51.438]                   NAME <- NAMES[[kk]]
[10:29:51.438]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.438]                     next
[10:29:51.438]                   args[[name]] <- ""
[10:29:51.438]                 }
[10:29:51.438]                 NAMES <- toupper(removed)
[10:29:51.438]                 for (kk in seq_along(NAMES)) {
[10:29:51.438]                   name <- removed[[kk]]
[10:29:51.438]                   NAME <- NAMES[[kk]]
[10:29:51.438]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.438]                     next
[10:29:51.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.438]                 }
[10:29:51.438]                 if (length(args) > 0) 
[10:29:51.438]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.438]             }
[10:29:51.438]             else {
[10:29:51.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.438]             }
[10:29:51.438]             {
[10:29:51.438]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.438]                   0L) {
[10:29:51.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.438]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.438]                   base::options(opts)
[10:29:51.438]                 }
[10:29:51.438]                 {
[10:29:51.438]                   {
[10:29:51.438]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.438]                     NULL
[10:29:51.438]                   }
[10:29:51.438]                   options(future.plan = NULL)
[10:29:51.438]                   if (is.na(NA_character_)) 
[10:29:51.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.438]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.438]                     .init = FALSE)
[10:29:51.438]                 }
[10:29:51.438]             }
[10:29:51.438]         }
[10:29:51.438]     })
[10:29:51.438]     if (TRUE) {
[10:29:51.438]         base::sink(type = "output", split = FALSE)
[10:29:51.438]         if (TRUE) {
[10:29:51.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.438]         }
[10:29:51.438]         else {
[10:29:51.438]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.438]         }
[10:29:51.438]         base::close(...future.stdout)
[10:29:51.438]         ...future.stdout <- NULL
[10:29:51.438]     }
[10:29:51.438]     ...future.result$conditions <- ...future.conditions
[10:29:51.438]     ...future.result$finished <- base::Sys.time()
[10:29:51.438]     ...future.result
[10:29:51.438] }
[10:29:51.441] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[10:29:51.442] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:51.442] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.442] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[10:29:51.443] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[10:29:51.443] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[10:29:51.443] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[10:29:51.443] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:51.444] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.444] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:51.444] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:51.444] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[10:29:51.445] MultisessionFuture started
[10:29:51.445] - Launch lazy future ... done
[10:29:51.445] run() for ‘MultisessionFuture’ ... done
[10:29:51.445] Created future:
[10:29:51.445] MultisessionFuture:
[10:29:51.445] Label: ‘future_apply-1’
[10:29:51.445] Expression:
[10:29:51.445] {
[10:29:51.445]     do.call(function(...) {
[10:29:51.445]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.445]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.445]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.445]             on.exit(options(oopts), add = TRUE)
[10:29:51.445]         }
[10:29:51.445]         {
[10:29:51.445]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.445]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.445]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.445]             })
[10:29:51.445]         }
[10:29:51.445]     }, args = future.call.arguments)
[10:29:51.445] }
[10:29:51.445] Lazy evaluation: FALSE
[10:29:51.445] Asynchronous evaluation: TRUE
[10:29:51.445] Local evaluation: TRUE
[10:29:51.445] Environment: R_GlobalEnv
[10:29:51.445] Capture standard output: TRUE
[10:29:51.445] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.445] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.445] Packages: 1 packages (‘stats’)
[10:29:51.445] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.445] Resolved: FALSE
[10:29:51.445] Value: <not collected>
[10:29:51.445] Conditions captured: <none>
[10:29:51.445] Early signaling: FALSE
[10:29:51.445] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.445] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.457] Chunk #1 of 2 ... DONE
[10:29:51.457] Chunk #2 of 2 ...
[10:29:51.457]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.457]  - seeds: <none>
[10:29:51.457]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.457] getGlobalsAndPackages() ...
[10:29:51.458] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.458] Resolving globals: FALSE
[10:29:51.458] Tweak future expression to call with '...' arguments ...
[10:29:51.458] {
[10:29:51.458]     do.call(function(...) {
[10:29:51.458]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.458]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.458]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.458]             on.exit(options(oopts), add = TRUE)
[10:29:51.458]         }
[10:29:51.458]         {
[10:29:51.458]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.458]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.458]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.458]             })
[10:29:51.458]         }
[10:29:51.458]     }, args = future.call.arguments)
[10:29:51.458] }
[10:29:51.458] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.459] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.459] - packages: [1] ‘stats’
[10:29:51.459] getGlobalsAndPackages() ... DONE
[10:29:51.459] run() for ‘Future’ ...
[10:29:51.459] - state: ‘created’
[10:29:51.459] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.473] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.473] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.473]   - Field: ‘node’
[10:29:51.473]   - Field: ‘label’
[10:29:51.473]   - Field: ‘local’
[10:29:51.473]   - Field: ‘owner’
[10:29:51.473]   - Field: ‘envir’
[10:29:51.473]   - Field: ‘workers’
[10:29:51.474]   - Field: ‘packages’
[10:29:51.474]   - Field: ‘gc’
[10:29:51.474]   - Field: ‘conditions’
[10:29:51.474]   - Field: ‘persistent’
[10:29:51.474]   - Field: ‘expr’
[10:29:51.474]   - Field: ‘uuid’
[10:29:51.474]   - Field: ‘seed’
[10:29:51.474]   - Field: ‘version’
[10:29:51.474]   - Field: ‘result’
[10:29:51.474]   - Field: ‘asynchronous’
[10:29:51.474]   - Field: ‘calls’
[10:29:51.475]   - Field: ‘globals’
[10:29:51.475]   - Field: ‘stdout’
[10:29:51.475]   - Field: ‘earlySignal’
[10:29:51.475]   - Field: ‘lazy’
[10:29:51.475]   - Field: ‘state’
[10:29:51.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.475] - Launch lazy future ...
[10:29:51.475] Packages needed by the future expression (n = 1): ‘stats’
[10:29:51.475] Packages needed by future strategies (n = 0): <none>
[10:29:51.476] {
[10:29:51.476]     {
[10:29:51.476]         {
[10:29:51.476]             ...future.startTime <- base::Sys.time()
[10:29:51.476]             {
[10:29:51.476]                 {
[10:29:51.476]                   {
[10:29:51.476]                     {
[10:29:51.476]                       {
[10:29:51.476]                         base::local({
[10:29:51.476]                           has_future <- base::requireNamespace("future", 
[10:29:51.476]                             quietly = TRUE)
[10:29:51.476]                           if (has_future) {
[10:29:51.476]                             ns <- base::getNamespace("future")
[10:29:51.476]                             version <- ns[[".package"]][["version"]]
[10:29:51.476]                             if (is.null(version)) 
[10:29:51.476]                               version <- utils::packageVersion("future")
[10:29:51.476]                           }
[10:29:51.476]                           else {
[10:29:51.476]                             version <- NULL
[10:29:51.476]                           }
[10:29:51.476]                           if (!has_future || version < "1.8.0") {
[10:29:51.476]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.476]                               "", base::R.version$version.string), 
[10:29:51.476]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:51.476]                                 base::R.version$platform, 8 * 
[10:29:51.476]                                   base::.Machine$sizeof.pointer), 
[10:29:51.476]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.476]                                 "release", "version")], collapse = " "), 
[10:29:51.476]                               hostname = base::Sys.info()[["nodename"]])
[10:29:51.476]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.476]                               info)
[10:29:51.476]                             info <- base::paste(info, collapse = "; ")
[10:29:51.476]                             if (!has_future) {
[10:29:51.476]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.476]                                 info)
[10:29:51.476]                             }
[10:29:51.476]                             else {
[10:29:51.476]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.476]                                 info, version)
[10:29:51.476]                             }
[10:29:51.476]                             base::stop(msg)
[10:29:51.476]                           }
[10:29:51.476]                         })
[10:29:51.476]                       }
[10:29:51.476]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.476]                       base::options(mc.cores = 1L)
[10:29:51.476]                     }
[10:29:51.476]                     base::local({
[10:29:51.476]                       for (pkg in "stats") {
[10:29:51.476]                         base::loadNamespace(pkg)
[10:29:51.476]                         base::library(pkg, character.only = TRUE)
[10:29:51.476]                       }
[10:29:51.476]                     })
[10:29:51.476]                   }
[10:29:51.476]                   ...future.strategy.old <- future::plan("list")
[10:29:51.476]                   options(future.plan = NULL)
[10:29:51.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.476]                 }
[10:29:51.476]                 ...future.workdir <- getwd()
[10:29:51.476]             }
[10:29:51.476]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.476]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.476]         }
[10:29:51.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.476]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.476]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.476]             base::names(...future.oldOptions))
[10:29:51.476]     }
[10:29:51.476]     if (FALSE) {
[10:29:51.476]     }
[10:29:51.476]     else {
[10:29:51.476]         if (TRUE) {
[10:29:51.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.476]                 open = "w")
[10:29:51.476]         }
[10:29:51.476]         else {
[10:29:51.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.476]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.476]         }
[10:29:51.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.476]             base::sink(type = "output", split = FALSE)
[10:29:51.476]             base::close(...future.stdout)
[10:29:51.476]         }, add = TRUE)
[10:29:51.476]     }
[10:29:51.476]     ...future.frame <- base::sys.nframe()
[10:29:51.476]     ...future.conditions <- base::list()
[10:29:51.476]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.476]     if (FALSE) {
[10:29:51.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.476]     }
[10:29:51.476]     ...future.result <- base::tryCatch({
[10:29:51.476]         base::withCallingHandlers({
[10:29:51.476]             ...future.value <- base::withVisible(base::local({
[10:29:51.476]                 ...future.makeSendCondition <- base::local({
[10:29:51.476]                   sendCondition <- NULL
[10:29:51.476]                   function(frame = 1L) {
[10:29:51.476]                     if (is.function(sendCondition)) 
[10:29:51.476]                       return(sendCondition)
[10:29:51.476]                     ns <- getNamespace("parallel")
[10:29:51.476]                     if (exists("sendData", mode = "function", 
[10:29:51.476]                       envir = ns)) {
[10:29:51.476]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.476]                         envir = ns)
[10:29:51.476]                       envir <- sys.frame(frame)
[10:29:51.476]                       master <- NULL
[10:29:51.476]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.476]                         !identical(envir, emptyenv())) {
[10:29:51.476]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.476]                           inherits = FALSE)) {
[10:29:51.476]                           master <- get("master", mode = "list", 
[10:29:51.476]                             envir = envir, inherits = FALSE)
[10:29:51.476]                           if (inherits(master, c("SOCKnode", 
[10:29:51.476]                             "SOCK0node"))) {
[10:29:51.476]                             sendCondition <<- function(cond) {
[10:29:51.476]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.476]                                 success = TRUE)
[10:29:51.476]                               parallel_sendData(master, data)
[10:29:51.476]                             }
[10:29:51.476]                             return(sendCondition)
[10:29:51.476]                           }
[10:29:51.476]                         }
[10:29:51.476]                         frame <- frame + 1L
[10:29:51.476]                         envir <- sys.frame(frame)
[10:29:51.476]                       }
[10:29:51.476]                     }
[10:29:51.476]                     sendCondition <<- function(cond) NULL
[10:29:51.476]                   }
[10:29:51.476]                 })
[10:29:51.476]                 withCallingHandlers({
[10:29:51.476]                   {
[10:29:51.476]                     do.call(function(...) {
[10:29:51.476]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.476]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.476]                         ...future.globals.maxSize)) {
[10:29:51.476]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.476]                         on.exit(options(oopts), add = TRUE)
[10:29:51.476]                       }
[10:29:51.476]                       {
[10:29:51.476]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.476]                           FUN = function(jj) {
[10:29:51.476]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.476]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.476]                           })
[10:29:51.476]                       }
[10:29:51.476]                     }, args = future.call.arguments)
[10:29:51.476]                   }
[10:29:51.476]                 }, immediateCondition = function(cond) {
[10:29:51.476]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.476]                   sendCondition(cond)
[10:29:51.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.476]                   {
[10:29:51.476]                     inherits <- base::inherits
[10:29:51.476]                     invokeRestart <- base::invokeRestart
[10:29:51.476]                     is.null <- base::is.null
[10:29:51.476]                     muffled <- FALSE
[10:29:51.476]                     if (inherits(cond, "message")) {
[10:29:51.476]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.476]                       if (muffled) 
[10:29:51.476]                         invokeRestart("muffleMessage")
[10:29:51.476]                     }
[10:29:51.476]                     else if (inherits(cond, "warning")) {
[10:29:51.476]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.476]                       if (muffled) 
[10:29:51.476]                         invokeRestart("muffleWarning")
[10:29:51.476]                     }
[10:29:51.476]                     else if (inherits(cond, "condition")) {
[10:29:51.476]                       if (!is.null(pattern)) {
[10:29:51.476]                         computeRestarts <- base::computeRestarts
[10:29:51.476]                         grepl <- base::grepl
[10:29:51.476]                         restarts <- computeRestarts(cond)
[10:29:51.476]                         for (restart in restarts) {
[10:29:51.476]                           name <- restart$name
[10:29:51.476]                           if (is.null(name)) 
[10:29:51.476]                             next
[10:29:51.476]                           if (!grepl(pattern, name)) 
[10:29:51.476]                             next
[10:29:51.476]                           invokeRestart(restart)
[10:29:51.476]                           muffled <- TRUE
[10:29:51.476]                           break
[10:29:51.476]                         }
[10:29:51.476]                       }
[10:29:51.476]                     }
[10:29:51.476]                     invisible(muffled)
[10:29:51.476]                   }
[10:29:51.476]                   muffleCondition(cond)
[10:29:51.476]                 })
[10:29:51.476]             }))
[10:29:51.476]             future::FutureResult(value = ...future.value$value, 
[10:29:51.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.476]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.476]                     ...future.globalenv.names))
[10:29:51.476]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.476]         }, condition = base::local({
[10:29:51.476]             c <- base::c
[10:29:51.476]             inherits <- base::inherits
[10:29:51.476]             invokeRestart <- base::invokeRestart
[10:29:51.476]             length <- base::length
[10:29:51.476]             list <- base::list
[10:29:51.476]             seq.int <- base::seq.int
[10:29:51.476]             signalCondition <- base::signalCondition
[10:29:51.476]             sys.calls <- base::sys.calls
[10:29:51.476]             `[[` <- base::`[[`
[10:29:51.476]             `+` <- base::`+`
[10:29:51.476]             `<<-` <- base::`<<-`
[10:29:51.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.476]                   3L)]
[10:29:51.476]             }
[10:29:51.476]             function(cond) {
[10:29:51.476]                 is_error <- inherits(cond, "error")
[10:29:51.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.476]                   NULL)
[10:29:51.476]                 if (is_error) {
[10:29:51.476]                   sessionInformation <- function() {
[10:29:51.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.476]                       search = base::search(), system = base::Sys.info())
[10:29:51.476]                   }
[10:29:51.476]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.476]                     cond$call), session = sessionInformation(), 
[10:29:51.476]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.476]                   signalCondition(cond)
[10:29:51.476]                 }
[10:29:51.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.476]                 "immediateCondition"))) {
[10:29:51.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.476]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.476]                   if (TRUE && !signal) {
[10:29:51.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.476]                     {
[10:29:51.476]                       inherits <- base::inherits
[10:29:51.476]                       invokeRestart <- base::invokeRestart
[10:29:51.476]                       is.null <- base::is.null
[10:29:51.476]                       muffled <- FALSE
[10:29:51.476]                       if (inherits(cond, "message")) {
[10:29:51.476]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.476]                         if (muffled) 
[10:29:51.476]                           invokeRestart("muffleMessage")
[10:29:51.476]                       }
[10:29:51.476]                       else if (inherits(cond, "warning")) {
[10:29:51.476]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.476]                         if (muffled) 
[10:29:51.476]                           invokeRestart("muffleWarning")
[10:29:51.476]                       }
[10:29:51.476]                       else if (inherits(cond, "condition")) {
[10:29:51.476]                         if (!is.null(pattern)) {
[10:29:51.476]                           computeRestarts <- base::computeRestarts
[10:29:51.476]                           grepl <- base::grepl
[10:29:51.476]                           restarts <- computeRestarts(cond)
[10:29:51.476]                           for (restart in restarts) {
[10:29:51.476]                             name <- restart$name
[10:29:51.476]                             if (is.null(name)) 
[10:29:51.476]                               next
[10:29:51.476]                             if (!grepl(pattern, name)) 
[10:29:51.476]                               next
[10:29:51.476]                             invokeRestart(restart)
[10:29:51.476]                             muffled <- TRUE
[10:29:51.476]                             break
[10:29:51.476]                           }
[10:29:51.476]                         }
[10:29:51.476]                       }
[10:29:51.476]                       invisible(muffled)
[10:29:51.476]                     }
[10:29:51.476]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.476]                   }
[10:29:51.476]                 }
[10:29:51.476]                 else {
[10:29:51.476]                   if (TRUE) {
[10:29:51.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.476]                     {
[10:29:51.476]                       inherits <- base::inherits
[10:29:51.476]                       invokeRestart <- base::invokeRestart
[10:29:51.476]                       is.null <- base::is.null
[10:29:51.476]                       muffled <- FALSE
[10:29:51.476]                       if (inherits(cond, "message")) {
[10:29:51.476]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.476]                         if (muffled) 
[10:29:51.476]                           invokeRestart("muffleMessage")
[10:29:51.476]                       }
[10:29:51.476]                       else if (inherits(cond, "warning")) {
[10:29:51.476]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.476]                         if (muffled) 
[10:29:51.476]                           invokeRestart("muffleWarning")
[10:29:51.476]                       }
[10:29:51.476]                       else if (inherits(cond, "condition")) {
[10:29:51.476]                         if (!is.null(pattern)) {
[10:29:51.476]                           computeRestarts <- base::computeRestarts
[10:29:51.476]                           grepl <- base::grepl
[10:29:51.476]                           restarts <- computeRestarts(cond)
[10:29:51.476]                           for (restart in restarts) {
[10:29:51.476]                             name <- restart$name
[10:29:51.476]                             if (is.null(name)) 
[10:29:51.476]                               next
[10:29:51.476]                             if (!grepl(pattern, name)) 
[10:29:51.476]                               next
[10:29:51.476]                             invokeRestart(restart)
[10:29:51.476]                             muffled <- TRUE
[10:29:51.476]                             break
[10:29:51.476]                           }
[10:29:51.476]                         }
[10:29:51.476]                       }
[10:29:51.476]                       invisible(muffled)
[10:29:51.476]                     }
[10:29:51.476]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.476]                   }
[10:29:51.476]                 }
[10:29:51.476]             }
[10:29:51.476]         }))
[10:29:51.476]     }, error = function(ex) {
[10:29:51.476]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.476]                 ...future.rng), started = ...future.startTime, 
[10:29:51.476]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.476]             version = "1.8"), class = "FutureResult")
[10:29:51.476]     }, finally = {
[10:29:51.476]         if (!identical(...future.workdir, getwd())) 
[10:29:51.476]             setwd(...future.workdir)
[10:29:51.476]         {
[10:29:51.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.476]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.476]             }
[10:29:51.476]             base::options(...future.oldOptions)
[10:29:51.476]             if (.Platform$OS.type == "windows") {
[10:29:51.476]                 old_names <- names(...future.oldEnvVars)
[10:29:51.476]                 envs <- base::Sys.getenv()
[10:29:51.476]                 names <- names(envs)
[10:29:51.476]                 common <- intersect(names, old_names)
[10:29:51.476]                 added <- setdiff(names, old_names)
[10:29:51.476]                 removed <- setdiff(old_names, names)
[10:29:51.476]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.476]                   envs[common]]
[10:29:51.476]                 NAMES <- toupper(changed)
[10:29:51.476]                 args <- list()
[10:29:51.476]                 for (kk in seq_along(NAMES)) {
[10:29:51.476]                   name <- changed[[kk]]
[10:29:51.476]                   NAME <- NAMES[[kk]]
[10:29:51.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.476]                     next
[10:29:51.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.476]                 }
[10:29:51.476]                 NAMES <- toupper(added)
[10:29:51.476]                 for (kk in seq_along(NAMES)) {
[10:29:51.476]                   name <- added[[kk]]
[10:29:51.476]                   NAME <- NAMES[[kk]]
[10:29:51.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.476]                     next
[10:29:51.476]                   args[[name]] <- ""
[10:29:51.476]                 }
[10:29:51.476]                 NAMES <- toupper(removed)
[10:29:51.476]                 for (kk in seq_along(NAMES)) {
[10:29:51.476]                   name <- removed[[kk]]
[10:29:51.476]                   NAME <- NAMES[[kk]]
[10:29:51.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.476]                     next
[10:29:51.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.476]                 }
[10:29:51.476]                 if (length(args) > 0) 
[10:29:51.476]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.476]             }
[10:29:51.476]             else {
[10:29:51.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.476]             }
[10:29:51.476]             {
[10:29:51.476]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.476]                   0L) {
[10:29:51.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.476]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.476]                   base::options(opts)
[10:29:51.476]                 }
[10:29:51.476]                 {
[10:29:51.476]                   {
[10:29:51.476]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.476]                     NULL
[10:29:51.476]                   }
[10:29:51.476]                   options(future.plan = NULL)
[10:29:51.476]                   if (is.na(NA_character_)) 
[10:29:51.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.476]                     .init = FALSE)
[10:29:51.476]                 }
[10:29:51.476]             }
[10:29:51.476]         }
[10:29:51.476]     })
[10:29:51.476]     if (TRUE) {
[10:29:51.476]         base::sink(type = "output", split = FALSE)
[10:29:51.476]         if (TRUE) {
[10:29:51.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.476]         }
[10:29:51.476]         else {
[10:29:51.476]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.476]         }
[10:29:51.476]         base::close(...future.stdout)
[10:29:51.476]         ...future.stdout <- NULL
[10:29:51.476]     }
[10:29:51.476]     ...future.result$conditions <- ...future.conditions
[10:29:51.476]     ...future.result$finished <- base::Sys.time()
[10:29:51.476]     ...future.result
[10:29:51.476] }
[10:29:51.479] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[10:29:51.479] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:51.479] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:51.479] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[10:29:51.480] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[10:29:51.480] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[10:29:51.480] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[10:29:51.480] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:51.481] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:51.481] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:29:51.481] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:29:51.481] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[10:29:51.482] MultisessionFuture started
[10:29:51.482] - Launch lazy future ... done
[10:29:51.482] run() for ‘MultisessionFuture’ ... done
[10:29:51.482] Created future:
[10:29:51.482] MultisessionFuture:
[10:29:51.482] Label: ‘future_apply-2’
[10:29:51.482] Expression:
[10:29:51.482] {
[10:29:51.482]     do.call(function(...) {
[10:29:51.482]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.482]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.482]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.482]             on.exit(options(oopts), add = TRUE)
[10:29:51.482]         }
[10:29:51.482]         {
[10:29:51.482]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.482]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.482]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.482]             })
[10:29:51.482]         }
[10:29:51.482]     }, args = future.call.arguments)
[10:29:51.482] }
[10:29:51.482] Lazy evaluation: FALSE
[10:29:51.482] Asynchronous evaluation: TRUE
[10:29:51.482] Local evaluation: TRUE
[10:29:51.482] Environment: R_GlobalEnv
[10:29:51.482] Capture standard output: TRUE
[10:29:51.482] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.482] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.482] Packages: 1 packages (‘stats’)
[10:29:51.482] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.482] Resolved: FALSE
[10:29:51.482] Value: <not collected>
[10:29:51.482] Conditions captured: <none>
[10:29:51.482] Early signaling: FALSE
[10:29:51.482] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.482] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.494] Chunk #2 of 2 ... DONE
[10:29:51.494] Launching 2 futures (chunks) ... DONE
[10:29:51.494] Resolving 2 futures (chunks) ...
[10:29:51.494] resolve() on list ...
[10:29:51.494]  recursive: 0
[10:29:51.494]  length: 2
[10:29:51.494] 
[10:29:51.495] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.495] - Validating connection of MultisessionFuture
[10:29:51.495] - received message: FutureResult
[10:29:51.495] - Received FutureResult
[10:29:51.495] - Erased future from FutureRegistry
[10:29:51.495] result() for ClusterFuture ...
[10:29:51.495] - result already collected: FutureResult
[10:29:51.495] result() for ClusterFuture ... done
[10:29:51.495] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.496] Future #1
[10:29:51.496] result() for ClusterFuture ...
[10:29:51.496] - result already collected: FutureResult
[10:29:51.496] result() for ClusterFuture ... done
[10:29:51.496] result() for ClusterFuture ...
[10:29:51.496] - result already collected: FutureResult
[10:29:51.496] result() for ClusterFuture ... done
[10:29:51.496] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:51.496] - nx: 2
[10:29:51.496] - relay: TRUE
[10:29:51.496] - stdout: TRUE
[10:29:51.496] - signal: TRUE
[10:29:51.497] - resignal: FALSE
[10:29:51.497] - force: TRUE
[10:29:51.497] - relayed: [n=2] FALSE, FALSE
[10:29:51.497] - queued futures: [n=2] FALSE, FALSE
[10:29:51.497]  - until=1
[10:29:51.497]  - relaying element #1
[10:29:51.497] result() for ClusterFuture ...
[10:29:51.497] - result already collected: FutureResult
[10:29:51.497] result() for ClusterFuture ... done
[10:29:51.497] result() for ClusterFuture ...
[10:29:51.497] - result already collected: FutureResult
[10:29:51.498] result() for ClusterFuture ... done
[10:29:51.498] result() for ClusterFuture ...
[10:29:51.498] - result already collected: FutureResult
[10:29:51.498] result() for ClusterFuture ... done
[10:29:51.498] result() for ClusterFuture ...
[10:29:51.498] - result already collected: FutureResult
[10:29:51.498] result() for ClusterFuture ... done
[10:29:51.498] - relayed: [n=2] TRUE, FALSE
[10:29:51.498] - queued futures: [n=2] TRUE, FALSE
[10:29:51.498] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:51.498]  length: 1 (resolved future 1)
[10:29:51.528] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.529] - Validating connection of MultisessionFuture
[10:29:51.529] - received message: FutureResult
[10:29:51.529] - Received FutureResult
[10:29:51.529] - Erased future from FutureRegistry
[10:29:51.529] result() for ClusterFuture ...
[10:29:51.529] - result already collected: FutureResult
[10:29:51.529] result() for ClusterFuture ... done
[10:29:51.529] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.530] Future #2
[10:29:51.530] result() for ClusterFuture ...
[10:29:51.530] - result already collected: FutureResult
[10:29:51.530] result() for ClusterFuture ... done
[10:29:51.530] result() for ClusterFuture ...
[10:29:51.530] - result already collected: FutureResult
[10:29:51.530] result() for ClusterFuture ... done
[10:29:51.530] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:51.530] - nx: 2
[10:29:51.530] - relay: TRUE
[10:29:51.530] - stdout: TRUE
[10:29:51.530] - signal: TRUE
[10:29:51.531] - resignal: FALSE
[10:29:51.531] - force: TRUE
[10:29:51.531] - relayed: [n=2] TRUE, FALSE
[10:29:51.531] - queued futures: [n=2] TRUE, FALSE
[10:29:51.531]  - until=2
[10:29:51.531]  - relaying element #2
[10:29:51.531] result() for ClusterFuture ...
[10:29:51.531] - result already collected: FutureResult
[10:29:51.531] result() for ClusterFuture ... done
[10:29:51.531] result() for ClusterFuture ...
[10:29:51.531] - result already collected: FutureResult
[10:29:51.531] result() for ClusterFuture ... done
[10:29:51.532] result() for ClusterFuture ...
[10:29:51.532] - result already collected: FutureResult
[10:29:51.532] result() for ClusterFuture ... done
[10:29:51.532] result() for ClusterFuture ...
[10:29:51.532] - result already collected: FutureResult
[10:29:51.532] result() for ClusterFuture ... done
[10:29:51.532] - relayed: [n=2] TRUE, TRUE
[10:29:51.532] - queued futures: [n=2] TRUE, TRUE
[10:29:51.532] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:51.532]  length: 0 (resolved future 2)
[10:29:51.532] Relaying remaining futures
[10:29:51.533] signalConditionsASAP(NULL, pos=0) ...
[10:29:51.533] - nx: 2
[10:29:51.533] - relay: TRUE
[10:29:51.533] - stdout: TRUE
[10:29:51.533] - signal: TRUE
[10:29:51.533] - resignal: FALSE
[10:29:51.533] - force: TRUE
[10:29:51.533] - relayed: [n=2] TRUE, TRUE
[10:29:51.533] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:51.533] - relayed: [n=2] TRUE, TRUE
[10:29:51.533] - queued futures: [n=2] TRUE, TRUE
[10:29:51.534] signalConditionsASAP(NULL, pos=0) ... done
[10:29:51.534] resolve() on list ... DONE
[10:29:51.534] result() for ClusterFuture ...
[10:29:51.534] - result already collected: FutureResult
[10:29:51.534] result() for ClusterFuture ... done
[10:29:51.534] result() for ClusterFuture ...
[10:29:51.534] - result already collected: FutureResult
[10:29:51.534] result() for ClusterFuture ... done
[10:29:51.534] result() for ClusterFuture ...
[10:29:51.534] - result already collected: FutureResult
[10:29:51.534] result() for ClusterFuture ... done
[10:29:51.535] result() for ClusterFuture ...
[10:29:51.535] - result already collected: FutureResult
[10:29:51.535] result() for ClusterFuture ... done
[10:29:51.535]  - Number of value chunks collected: 2
[10:29:51.535] Resolving 2 futures (chunks) ... DONE
[10:29:51.535] Reducing values from 2 chunks ...
[10:29:51.535]  - Number of values collected after concatenation: 2
[10:29:51.535]  - Number of values expected: 2
[10:29:51.535] Reducing values from 2 chunks ... DONE
[10:29:51.535] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:29:51.536] getGlobalsAndPackagesXApply() ...
[10:29:51.536]  - future.globals: TRUE
[10:29:51.536] getGlobalsAndPackages() ...
[10:29:51.536] Searching for globals...
[10:29:51.537] - globals found: [1] ‘FUN’
[10:29:51.537] Searching for globals ... DONE
[10:29:51.537] Resolving globals: FALSE
[10:29:51.538] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:51.538] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:51.538] - globals: [1] ‘FUN’
[10:29:51.538] 
[10:29:51.538] getGlobalsAndPackages() ... DONE
[10:29:51.538]  - globals found/used: [n=1] ‘FUN’
[10:29:51.539]  - needed namespaces: [n=0] 
[10:29:51.539] Finding globals ... DONE
[10:29:51.539]  - use_args: TRUE
[10:29:51.539]  - Getting '...' globals ...
[10:29:51.539] resolve() on list ...
[10:29:51.539]  recursive: 0
[10:29:51.539]  length: 1
[10:29:51.539]  elements: ‘...’
[10:29:51.539]  length: 0 (resolved future 1)
[10:29:51.540] resolve() on list ... DONE
[10:29:51.540]    - '...' content: [n=0] 
[10:29:51.540] List of 1
[10:29:51.540]  $ ...: list()
[10:29:51.540]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.540]  - attr(*, "where")=List of 1
[10:29:51.540]   ..$ ...:<environment: 0x5618a3c197c8> 
[10:29:51.540]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.540]  - attr(*, "resolved")= logi TRUE
[10:29:51.540]  - attr(*, "total_size")= num NA
[10:29:51.542]  - Getting '...' globals ... DONE
[10:29:51.543] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:51.543] List of 2
[10:29:51.543]  $ ...future.FUN:function (x)  
[10:29:51.543]  $ ...          : list()
[10:29:51.543]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.543]  - attr(*, "where")=List of 2
[10:29:51.543]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:51.543]   ..$ ...          :<environment: 0x5618a3c197c8> 
[10:29:51.543]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.543]  - attr(*, "resolved")= logi FALSE
[10:29:51.543]  - attr(*, "total_size")= num 848
[10:29:51.545] Packages to be attached in all futures: [n=0] 
[10:29:51.545] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.551] future_lapply() ...
[10:29:51.555] Number of chunks: 2
[10:29:51.555] getGlobalsAndPackagesXApply() ...
[10:29:51.555]  - future.globals: <name-value list> with names ‘list()’
[10:29:51.555]  - use_args: TRUE
[10:29:51.555] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:51.555] List of 2
[10:29:51.555]  $ ...          : list()
[10:29:51.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.555]  $ ...future.FUN:function (x)  
[10:29:51.555]  - attr(*, "where")=List of 2
[10:29:51.555]   ..$ ...          :<environment: 0x5618a3c197c8> 
[10:29:51.555]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:51.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.555]  - attr(*, "resolved")= logi FALSE
[10:29:51.555]  - attr(*, "total_size")= num NA
[10:29:51.558] Packages to be attached in all futures: [n=0] 
[10:29:51.558] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.558] Number of futures (= number of chunks): 2
[10:29:51.559] Launching 2 futures (chunks) ...
[10:29:51.559] Chunk #1 of 2 ...
[10:29:51.559]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.559]  - seeds: <none>
[10:29:51.559]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.559] getGlobalsAndPackages() ...
[10:29:51.559] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.559] Resolving globals: FALSE
[10:29:51.559] Tweak future expression to call with '...' arguments ...
[10:29:51.559] {
[10:29:51.559]     do.call(function(...) {
[10:29:51.559]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.559]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.559]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.559]             on.exit(options(oopts), add = TRUE)
[10:29:51.559]         }
[10:29:51.559]         {
[10:29:51.559]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.559]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.559]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.559]             })
[10:29:51.559]         }
[10:29:51.559]     }, args = future.call.arguments)
[10:29:51.559] }
[10:29:51.560] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.560] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.560] 
[10:29:51.560] getGlobalsAndPackages() ... DONE
[10:29:51.561] run() for ‘Future’ ...
[10:29:51.561] - state: ‘created’
[10:29:51.561] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.574] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.575] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.575]   - Field: ‘node’
[10:29:51.575]   - Field: ‘label’
[10:29:51.575]   - Field: ‘local’
[10:29:51.575]   - Field: ‘owner’
[10:29:51.575]   - Field: ‘envir’
[10:29:51.575]   - Field: ‘workers’
[10:29:51.575]   - Field: ‘packages’
[10:29:51.575]   - Field: ‘gc’
[10:29:51.575]   - Field: ‘conditions’
[10:29:51.575]   - Field: ‘persistent’
[10:29:51.576]   - Field: ‘expr’
[10:29:51.576]   - Field: ‘uuid’
[10:29:51.576]   - Field: ‘seed’
[10:29:51.576]   - Field: ‘version’
[10:29:51.576]   - Field: ‘result’
[10:29:51.576]   - Field: ‘asynchronous’
[10:29:51.576]   - Field: ‘calls’
[10:29:51.576]   - Field: ‘globals’
[10:29:51.576]   - Field: ‘stdout’
[10:29:51.576]   - Field: ‘earlySignal’
[10:29:51.576]   - Field: ‘lazy’
[10:29:51.577]   - Field: ‘state’
[10:29:51.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.577] - Launch lazy future ...
[10:29:51.577] Packages needed by the future expression (n = 0): <none>
[10:29:51.577] Packages needed by future strategies (n = 0): <none>
[10:29:51.578] {
[10:29:51.578]     {
[10:29:51.578]         {
[10:29:51.578]             ...future.startTime <- base::Sys.time()
[10:29:51.578]             {
[10:29:51.578]                 {
[10:29:51.578]                   {
[10:29:51.578]                     {
[10:29:51.578]                       base::local({
[10:29:51.578]                         has_future <- base::requireNamespace("future", 
[10:29:51.578]                           quietly = TRUE)
[10:29:51.578]                         if (has_future) {
[10:29:51.578]                           ns <- base::getNamespace("future")
[10:29:51.578]                           version <- ns[[".package"]][["version"]]
[10:29:51.578]                           if (is.null(version)) 
[10:29:51.578]                             version <- utils::packageVersion("future")
[10:29:51.578]                         }
[10:29:51.578]                         else {
[10:29:51.578]                           version <- NULL
[10:29:51.578]                         }
[10:29:51.578]                         if (!has_future || version < "1.8.0") {
[10:29:51.578]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.578]                             "", base::R.version$version.string), 
[10:29:51.578]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:51.578]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:51.578]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.578]                               "release", "version")], collapse = " "), 
[10:29:51.578]                             hostname = base::Sys.info()[["nodename"]])
[10:29:51.578]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.578]                             info)
[10:29:51.578]                           info <- base::paste(info, collapse = "; ")
[10:29:51.578]                           if (!has_future) {
[10:29:51.578]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.578]                               info)
[10:29:51.578]                           }
[10:29:51.578]                           else {
[10:29:51.578]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.578]                               info, version)
[10:29:51.578]                           }
[10:29:51.578]                           base::stop(msg)
[10:29:51.578]                         }
[10:29:51.578]                       })
[10:29:51.578]                     }
[10:29:51.578]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.578]                     base::options(mc.cores = 1L)
[10:29:51.578]                   }
[10:29:51.578]                   ...future.strategy.old <- future::plan("list")
[10:29:51.578]                   options(future.plan = NULL)
[10:29:51.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.578]                 }
[10:29:51.578]                 ...future.workdir <- getwd()
[10:29:51.578]             }
[10:29:51.578]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.578]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.578]         }
[10:29:51.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.578]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.578]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.578]             base::names(...future.oldOptions))
[10:29:51.578]     }
[10:29:51.578]     if (FALSE) {
[10:29:51.578]     }
[10:29:51.578]     else {
[10:29:51.578]         if (TRUE) {
[10:29:51.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.578]                 open = "w")
[10:29:51.578]         }
[10:29:51.578]         else {
[10:29:51.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.578]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.578]         }
[10:29:51.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.578]             base::sink(type = "output", split = FALSE)
[10:29:51.578]             base::close(...future.stdout)
[10:29:51.578]         }, add = TRUE)
[10:29:51.578]     }
[10:29:51.578]     ...future.frame <- base::sys.nframe()
[10:29:51.578]     ...future.conditions <- base::list()
[10:29:51.578]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.578]     if (FALSE) {
[10:29:51.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.578]     }
[10:29:51.578]     ...future.result <- base::tryCatch({
[10:29:51.578]         base::withCallingHandlers({
[10:29:51.578]             ...future.value <- base::withVisible(base::local({
[10:29:51.578]                 ...future.makeSendCondition <- base::local({
[10:29:51.578]                   sendCondition <- NULL
[10:29:51.578]                   function(frame = 1L) {
[10:29:51.578]                     if (is.function(sendCondition)) 
[10:29:51.578]                       return(sendCondition)
[10:29:51.578]                     ns <- getNamespace("parallel")
[10:29:51.578]                     if (exists("sendData", mode = "function", 
[10:29:51.578]                       envir = ns)) {
[10:29:51.578]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.578]                         envir = ns)
[10:29:51.578]                       envir <- sys.frame(frame)
[10:29:51.578]                       master <- NULL
[10:29:51.578]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.578]                         !identical(envir, emptyenv())) {
[10:29:51.578]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.578]                           inherits = FALSE)) {
[10:29:51.578]                           master <- get("master", mode = "list", 
[10:29:51.578]                             envir = envir, inherits = FALSE)
[10:29:51.578]                           if (inherits(master, c("SOCKnode", 
[10:29:51.578]                             "SOCK0node"))) {
[10:29:51.578]                             sendCondition <<- function(cond) {
[10:29:51.578]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.578]                                 success = TRUE)
[10:29:51.578]                               parallel_sendData(master, data)
[10:29:51.578]                             }
[10:29:51.578]                             return(sendCondition)
[10:29:51.578]                           }
[10:29:51.578]                         }
[10:29:51.578]                         frame <- frame + 1L
[10:29:51.578]                         envir <- sys.frame(frame)
[10:29:51.578]                       }
[10:29:51.578]                     }
[10:29:51.578]                     sendCondition <<- function(cond) NULL
[10:29:51.578]                   }
[10:29:51.578]                 })
[10:29:51.578]                 withCallingHandlers({
[10:29:51.578]                   {
[10:29:51.578]                     do.call(function(...) {
[10:29:51.578]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.578]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.578]                         ...future.globals.maxSize)) {
[10:29:51.578]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.578]                         on.exit(options(oopts), add = TRUE)
[10:29:51.578]                       }
[10:29:51.578]                       {
[10:29:51.578]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.578]                           FUN = function(jj) {
[10:29:51.578]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.578]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.578]                           })
[10:29:51.578]                       }
[10:29:51.578]                     }, args = future.call.arguments)
[10:29:51.578]                   }
[10:29:51.578]                 }, immediateCondition = function(cond) {
[10:29:51.578]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.578]                   sendCondition(cond)
[10:29:51.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.578]                   {
[10:29:51.578]                     inherits <- base::inherits
[10:29:51.578]                     invokeRestart <- base::invokeRestart
[10:29:51.578]                     is.null <- base::is.null
[10:29:51.578]                     muffled <- FALSE
[10:29:51.578]                     if (inherits(cond, "message")) {
[10:29:51.578]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.578]                       if (muffled) 
[10:29:51.578]                         invokeRestart("muffleMessage")
[10:29:51.578]                     }
[10:29:51.578]                     else if (inherits(cond, "warning")) {
[10:29:51.578]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.578]                       if (muffled) 
[10:29:51.578]                         invokeRestart("muffleWarning")
[10:29:51.578]                     }
[10:29:51.578]                     else if (inherits(cond, "condition")) {
[10:29:51.578]                       if (!is.null(pattern)) {
[10:29:51.578]                         computeRestarts <- base::computeRestarts
[10:29:51.578]                         grepl <- base::grepl
[10:29:51.578]                         restarts <- computeRestarts(cond)
[10:29:51.578]                         for (restart in restarts) {
[10:29:51.578]                           name <- restart$name
[10:29:51.578]                           if (is.null(name)) 
[10:29:51.578]                             next
[10:29:51.578]                           if (!grepl(pattern, name)) 
[10:29:51.578]                             next
[10:29:51.578]                           invokeRestart(restart)
[10:29:51.578]                           muffled <- TRUE
[10:29:51.578]                           break
[10:29:51.578]                         }
[10:29:51.578]                       }
[10:29:51.578]                     }
[10:29:51.578]                     invisible(muffled)
[10:29:51.578]                   }
[10:29:51.578]                   muffleCondition(cond)
[10:29:51.578]                 })
[10:29:51.578]             }))
[10:29:51.578]             future::FutureResult(value = ...future.value$value, 
[10:29:51.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.578]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.578]                     ...future.globalenv.names))
[10:29:51.578]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.578]         }, condition = base::local({
[10:29:51.578]             c <- base::c
[10:29:51.578]             inherits <- base::inherits
[10:29:51.578]             invokeRestart <- base::invokeRestart
[10:29:51.578]             length <- base::length
[10:29:51.578]             list <- base::list
[10:29:51.578]             seq.int <- base::seq.int
[10:29:51.578]             signalCondition <- base::signalCondition
[10:29:51.578]             sys.calls <- base::sys.calls
[10:29:51.578]             `[[` <- base::`[[`
[10:29:51.578]             `+` <- base::`+`
[10:29:51.578]             `<<-` <- base::`<<-`
[10:29:51.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.578]                   3L)]
[10:29:51.578]             }
[10:29:51.578]             function(cond) {
[10:29:51.578]                 is_error <- inherits(cond, "error")
[10:29:51.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.578]                   NULL)
[10:29:51.578]                 if (is_error) {
[10:29:51.578]                   sessionInformation <- function() {
[10:29:51.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.578]                       search = base::search(), system = base::Sys.info())
[10:29:51.578]                   }
[10:29:51.578]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.578]                     cond$call), session = sessionInformation(), 
[10:29:51.578]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.578]                   signalCondition(cond)
[10:29:51.578]                 }
[10:29:51.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.578]                 "immediateCondition"))) {
[10:29:51.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.578]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.578]                   if (TRUE && !signal) {
[10:29:51.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.578]                     {
[10:29:51.578]                       inherits <- base::inherits
[10:29:51.578]                       invokeRestart <- base::invokeRestart
[10:29:51.578]                       is.null <- base::is.null
[10:29:51.578]                       muffled <- FALSE
[10:29:51.578]                       if (inherits(cond, "message")) {
[10:29:51.578]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.578]                         if (muffled) 
[10:29:51.578]                           invokeRestart("muffleMessage")
[10:29:51.578]                       }
[10:29:51.578]                       else if (inherits(cond, "warning")) {
[10:29:51.578]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.578]                         if (muffled) 
[10:29:51.578]                           invokeRestart("muffleWarning")
[10:29:51.578]                       }
[10:29:51.578]                       else if (inherits(cond, "condition")) {
[10:29:51.578]                         if (!is.null(pattern)) {
[10:29:51.578]                           computeRestarts <- base::computeRestarts
[10:29:51.578]                           grepl <- base::grepl
[10:29:51.578]                           restarts <- computeRestarts(cond)
[10:29:51.578]                           for (restart in restarts) {
[10:29:51.578]                             name <- restart$name
[10:29:51.578]                             if (is.null(name)) 
[10:29:51.578]                               next
[10:29:51.578]                             if (!grepl(pattern, name)) 
[10:29:51.578]                               next
[10:29:51.578]                             invokeRestart(restart)
[10:29:51.578]                             muffled <- TRUE
[10:29:51.578]                             break
[10:29:51.578]                           }
[10:29:51.578]                         }
[10:29:51.578]                       }
[10:29:51.578]                       invisible(muffled)
[10:29:51.578]                     }
[10:29:51.578]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.578]                   }
[10:29:51.578]                 }
[10:29:51.578]                 else {
[10:29:51.578]                   if (TRUE) {
[10:29:51.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.578]                     {
[10:29:51.578]                       inherits <- base::inherits
[10:29:51.578]                       invokeRestart <- base::invokeRestart
[10:29:51.578]                       is.null <- base::is.null
[10:29:51.578]                       muffled <- FALSE
[10:29:51.578]                       if (inherits(cond, "message")) {
[10:29:51.578]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.578]                         if (muffled) 
[10:29:51.578]                           invokeRestart("muffleMessage")
[10:29:51.578]                       }
[10:29:51.578]                       else if (inherits(cond, "warning")) {
[10:29:51.578]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.578]                         if (muffled) 
[10:29:51.578]                           invokeRestart("muffleWarning")
[10:29:51.578]                       }
[10:29:51.578]                       else if (inherits(cond, "condition")) {
[10:29:51.578]                         if (!is.null(pattern)) {
[10:29:51.578]                           computeRestarts <- base::computeRestarts
[10:29:51.578]                           grepl <- base::grepl
[10:29:51.578]                           restarts <- computeRestarts(cond)
[10:29:51.578]                           for (restart in restarts) {
[10:29:51.578]                             name <- restart$name
[10:29:51.578]                             if (is.null(name)) 
[10:29:51.578]                               next
[10:29:51.578]                             if (!grepl(pattern, name)) 
[10:29:51.578]                               next
[10:29:51.578]                             invokeRestart(restart)
[10:29:51.578]                             muffled <- TRUE
[10:29:51.578]                             break
[10:29:51.578]                           }
[10:29:51.578]                         }
[10:29:51.578]                       }
[10:29:51.578]                       invisible(muffled)
[10:29:51.578]                     }
[10:29:51.578]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.578]                   }
[10:29:51.578]                 }
[10:29:51.578]             }
[10:29:51.578]         }))
[10:29:51.578]     }, error = function(ex) {
[10:29:51.578]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.578]                 ...future.rng), started = ...future.startTime, 
[10:29:51.578]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.578]             version = "1.8"), class = "FutureResult")
[10:29:51.578]     }, finally = {
[10:29:51.578]         if (!identical(...future.workdir, getwd())) 
[10:29:51.578]             setwd(...future.workdir)
[10:29:51.578]         {
[10:29:51.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.578]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.578]             }
[10:29:51.578]             base::options(...future.oldOptions)
[10:29:51.578]             if (.Platform$OS.type == "windows") {
[10:29:51.578]                 old_names <- names(...future.oldEnvVars)
[10:29:51.578]                 envs <- base::Sys.getenv()
[10:29:51.578]                 names <- names(envs)
[10:29:51.578]                 common <- intersect(names, old_names)
[10:29:51.578]                 added <- setdiff(names, old_names)
[10:29:51.578]                 removed <- setdiff(old_names, names)
[10:29:51.578]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.578]                   envs[common]]
[10:29:51.578]                 NAMES <- toupper(changed)
[10:29:51.578]                 args <- list()
[10:29:51.578]                 for (kk in seq_along(NAMES)) {
[10:29:51.578]                   name <- changed[[kk]]
[10:29:51.578]                   NAME <- NAMES[[kk]]
[10:29:51.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.578]                     next
[10:29:51.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.578]                 }
[10:29:51.578]                 NAMES <- toupper(added)
[10:29:51.578]                 for (kk in seq_along(NAMES)) {
[10:29:51.578]                   name <- added[[kk]]
[10:29:51.578]                   NAME <- NAMES[[kk]]
[10:29:51.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.578]                     next
[10:29:51.578]                   args[[name]] <- ""
[10:29:51.578]                 }
[10:29:51.578]                 NAMES <- toupper(removed)
[10:29:51.578]                 for (kk in seq_along(NAMES)) {
[10:29:51.578]                   name <- removed[[kk]]
[10:29:51.578]                   NAME <- NAMES[[kk]]
[10:29:51.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.578]                     next
[10:29:51.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.578]                 }
[10:29:51.578]                 if (length(args) > 0) 
[10:29:51.578]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.578]             }
[10:29:51.578]             else {
[10:29:51.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.578]             }
[10:29:51.578]             {
[10:29:51.578]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.578]                   0L) {
[10:29:51.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.578]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.578]                   base::options(opts)
[10:29:51.578]                 }
[10:29:51.578]                 {
[10:29:51.578]                   {
[10:29:51.578]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.578]                     NULL
[10:29:51.578]                   }
[10:29:51.578]                   options(future.plan = NULL)
[10:29:51.578]                   if (is.na(NA_character_)) 
[10:29:51.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.578]                     .init = FALSE)
[10:29:51.578]                 }
[10:29:51.578]             }
[10:29:51.578]         }
[10:29:51.578]     })
[10:29:51.578]     if (TRUE) {
[10:29:51.578]         base::sink(type = "output", split = FALSE)
[10:29:51.578]         if (TRUE) {
[10:29:51.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.578]         }
[10:29:51.578]         else {
[10:29:51.578]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.578]         }
[10:29:51.578]         base::close(...future.stdout)
[10:29:51.578]         ...future.stdout <- NULL
[10:29:51.578]     }
[10:29:51.578]     ...future.result$conditions <- ...future.conditions
[10:29:51.578]     ...future.result$finished <- base::Sys.time()
[10:29:51.578]     ...future.result
[10:29:51.578] }
[10:29:51.580] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[10:29:51.581] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:51.581] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.581] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:29:51.582] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:29:51.582] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:29:51.582] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:29:51.582] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:51.583] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.583] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:51.583] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:51.583] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[10:29:51.584] MultisessionFuture started
[10:29:51.584] - Launch lazy future ... done
[10:29:51.584] run() for ‘MultisessionFuture’ ... done
[10:29:51.584] Created future:
[10:29:51.584] MultisessionFuture:
[10:29:51.584] Label: ‘future_apply-1’
[10:29:51.584] Expression:
[10:29:51.584] {
[10:29:51.584]     do.call(function(...) {
[10:29:51.584]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.584]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.584]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.584]             on.exit(options(oopts), add = TRUE)
[10:29:51.584]         }
[10:29:51.584]         {
[10:29:51.584]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.584]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.584]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.584]             })
[10:29:51.584]         }
[10:29:51.584]     }, args = future.call.arguments)
[10:29:51.584] }
[10:29:51.584] Lazy evaluation: FALSE
[10:29:51.584] Asynchronous evaluation: TRUE
[10:29:51.584] Local evaluation: TRUE
[10:29:51.584] Environment: R_GlobalEnv
[10:29:51.584] Capture standard output: TRUE
[10:29:51.584] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.584] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.584] Packages: <none>
[10:29:51.584] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.584] Resolved: FALSE
[10:29:51.584] Value: <not collected>
[10:29:51.584] Conditions captured: <none>
[10:29:51.584] Early signaling: FALSE
[10:29:51.584] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.584] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.596] Chunk #1 of 2 ... DONE
[10:29:51.596] Chunk #2 of 2 ...
[10:29:51.596]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.596]  - seeds: <none>
[10:29:51.596]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.596] getGlobalsAndPackages() ...
[10:29:51.597] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.597] Resolving globals: FALSE
[10:29:51.597] Tweak future expression to call with '...' arguments ...
[10:29:51.597] {
[10:29:51.597]     do.call(function(...) {
[10:29:51.597]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.597]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.597]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.597]             on.exit(options(oopts), add = TRUE)
[10:29:51.597]         }
[10:29:51.597]         {
[10:29:51.597]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.597]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.597]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.597]             })
[10:29:51.597]         }
[10:29:51.597]     }, args = future.call.arguments)
[10:29:51.597] }
[10:29:51.597] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.598] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.598] 
[10:29:51.598] getGlobalsAndPackages() ... DONE
[10:29:51.598] run() for ‘Future’ ...
[10:29:51.598] - state: ‘created’
[10:29:51.598] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.613] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.613]   - Field: ‘node’
[10:29:51.613]   - Field: ‘label’
[10:29:51.613]   - Field: ‘local’
[10:29:51.613]   - Field: ‘owner’
[10:29:51.613]   - Field: ‘envir’
[10:29:51.614]   - Field: ‘workers’
[10:29:51.614]   - Field: ‘packages’
[10:29:51.614]   - Field: ‘gc’
[10:29:51.614]   - Field: ‘conditions’
[10:29:51.614]   - Field: ‘persistent’
[10:29:51.614]   - Field: ‘expr’
[10:29:51.614]   - Field: ‘uuid’
[10:29:51.614]   - Field: ‘seed’
[10:29:51.614]   - Field: ‘version’
[10:29:51.614]   - Field: ‘result’
[10:29:51.614]   - Field: ‘asynchronous’
[10:29:51.615]   - Field: ‘calls’
[10:29:51.615]   - Field: ‘globals’
[10:29:51.615]   - Field: ‘stdout’
[10:29:51.615]   - Field: ‘earlySignal’
[10:29:51.615]   - Field: ‘lazy’
[10:29:51.615]   - Field: ‘state’
[10:29:51.615] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.615] - Launch lazy future ...
[10:29:51.615] Packages needed by the future expression (n = 0): <none>
[10:29:51.616] Packages needed by future strategies (n = 0): <none>
[10:29:51.616] {
[10:29:51.616]     {
[10:29:51.616]         {
[10:29:51.616]             ...future.startTime <- base::Sys.time()
[10:29:51.616]             {
[10:29:51.616]                 {
[10:29:51.616]                   {
[10:29:51.616]                     {
[10:29:51.616]                       base::local({
[10:29:51.616]                         has_future <- base::requireNamespace("future", 
[10:29:51.616]                           quietly = TRUE)
[10:29:51.616]                         if (has_future) {
[10:29:51.616]                           ns <- base::getNamespace("future")
[10:29:51.616]                           version <- ns[[".package"]][["version"]]
[10:29:51.616]                           if (is.null(version)) 
[10:29:51.616]                             version <- utils::packageVersion("future")
[10:29:51.616]                         }
[10:29:51.616]                         else {
[10:29:51.616]                           version <- NULL
[10:29:51.616]                         }
[10:29:51.616]                         if (!has_future || version < "1.8.0") {
[10:29:51.616]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.616]                             "", base::R.version$version.string), 
[10:29:51.616]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:51.616]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:51.616]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.616]                               "release", "version")], collapse = " "), 
[10:29:51.616]                             hostname = base::Sys.info()[["nodename"]])
[10:29:51.616]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.616]                             info)
[10:29:51.616]                           info <- base::paste(info, collapse = "; ")
[10:29:51.616]                           if (!has_future) {
[10:29:51.616]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.616]                               info)
[10:29:51.616]                           }
[10:29:51.616]                           else {
[10:29:51.616]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.616]                               info, version)
[10:29:51.616]                           }
[10:29:51.616]                           base::stop(msg)
[10:29:51.616]                         }
[10:29:51.616]                       })
[10:29:51.616]                     }
[10:29:51.616]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.616]                     base::options(mc.cores = 1L)
[10:29:51.616]                   }
[10:29:51.616]                   ...future.strategy.old <- future::plan("list")
[10:29:51.616]                   options(future.plan = NULL)
[10:29:51.616]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.616]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.616]                 }
[10:29:51.616]                 ...future.workdir <- getwd()
[10:29:51.616]             }
[10:29:51.616]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.616]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.616]         }
[10:29:51.616]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.616]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.616]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.616]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.616]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.616]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.616]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.616]             base::names(...future.oldOptions))
[10:29:51.616]     }
[10:29:51.616]     if (FALSE) {
[10:29:51.616]     }
[10:29:51.616]     else {
[10:29:51.616]         if (TRUE) {
[10:29:51.616]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.616]                 open = "w")
[10:29:51.616]         }
[10:29:51.616]         else {
[10:29:51.616]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.616]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.616]         }
[10:29:51.616]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.616]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.616]             base::sink(type = "output", split = FALSE)
[10:29:51.616]             base::close(...future.stdout)
[10:29:51.616]         }, add = TRUE)
[10:29:51.616]     }
[10:29:51.616]     ...future.frame <- base::sys.nframe()
[10:29:51.616]     ...future.conditions <- base::list()
[10:29:51.616]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.616]     if (FALSE) {
[10:29:51.616]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.616]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.616]     }
[10:29:51.616]     ...future.result <- base::tryCatch({
[10:29:51.616]         base::withCallingHandlers({
[10:29:51.616]             ...future.value <- base::withVisible(base::local({
[10:29:51.616]                 ...future.makeSendCondition <- base::local({
[10:29:51.616]                   sendCondition <- NULL
[10:29:51.616]                   function(frame = 1L) {
[10:29:51.616]                     if (is.function(sendCondition)) 
[10:29:51.616]                       return(sendCondition)
[10:29:51.616]                     ns <- getNamespace("parallel")
[10:29:51.616]                     if (exists("sendData", mode = "function", 
[10:29:51.616]                       envir = ns)) {
[10:29:51.616]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.616]                         envir = ns)
[10:29:51.616]                       envir <- sys.frame(frame)
[10:29:51.616]                       master <- NULL
[10:29:51.616]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.616]                         !identical(envir, emptyenv())) {
[10:29:51.616]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.616]                           inherits = FALSE)) {
[10:29:51.616]                           master <- get("master", mode = "list", 
[10:29:51.616]                             envir = envir, inherits = FALSE)
[10:29:51.616]                           if (inherits(master, c("SOCKnode", 
[10:29:51.616]                             "SOCK0node"))) {
[10:29:51.616]                             sendCondition <<- function(cond) {
[10:29:51.616]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.616]                                 success = TRUE)
[10:29:51.616]                               parallel_sendData(master, data)
[10:29:51.616]                             }
[10:29:51.616]                             return(sendCondition)
[10:29:51.616]                           }
[10:29:51.616]                         }
[10:29:51.616]                         frame <- frame + 1L
[10:29:51.616]                         envir <- sys.frame(frame)
[10:29:51.616]                       }
[10:29:51.616]                     }
[10:29:51.616]                     sendCondition <<- function(cond) NULL
[10:29:51.616]                   }
[10:29:51.616]                 })
[10:29:51.616]                 withCallingHandlers({
[10:29:51.616]                   {
[10:29:51.616]                     do.call(function(...) {
[10:29:51.616]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.616]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.616]                         ...future.globals.maxSize)) {
[10:29:51.616]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.616]                         on.exit(options(oopts), add = TRUE)
[10:29:51.616]                       }
[10:29:51.616]                       {
[10:29:51.616]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.616]                           FUN = function(jj) {
[10:29:51.616]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.616]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.616]                           })
[10:29:51.616]                       }
[10:29:51.616]                     }, args = future.call.arguments)
[10:29:51.616]                   }
[10:29:51.616]                 }, immediateCondition = function(cond) {
[10:29:51.616]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.616]                   sendCondition(cond)
[10:29:51.616]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.616]                   {
[10:29:51.616]                     inherits <- base::inherits
[10:29:51.616]                     invokeRestart <- base::invokeRestart
[10:29:51.616]                     is.null <- base::is.null
[10:29:51.616]                     muffled <- FALSE
[10:29:51.616]                     if (inherits(cond, "message")) {
[10:29:51.616]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.616]                       if (muffled) 
[10:29:51.616]                         invokeRestart("muffleMessage")
[10:29:51.616]                     }
[10:29:51.616]                     else if (inherits(cond, "warning")) {
[10:29:51.616]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.616]                       if (muffled) 
[10:29:51.616]                         invokeRestart("muffleWarning")
[10:29:51.616]                     }
[10:29:51.616]                     else if (inherits(cond, "condition")) {
[10:29:51.616]                       if (!is.null(pattern)) {
[10:29:51.616]                         computeRestarts <- base::computeRestarts
[10:29:51.616]                         grepl <- base::grepl
[10:29:51.616]                         restarts <- computeRestarts(cond)
[10:29:51.616]                         for (restart in restarts) {
[10:29:51.616]                           name <- restart$name
[10:29:51.616]                           if (is.null(name)) 
[10:29:51.616]                             next
[10:29:51.616]                           if (!grepl(pattern, name)) 
[10:29:51.616]                             next
[10:29:51.616]                           invokeRestart(restart)
[10:29:51.616]                           muffled <- TRUE
[10:29:51.616]                           break
[10:29:51.616]                         }
[10:29:51.616]                       }
[10:29:51.616]                     }
[10:29:51.616]                     invisible(muffled)
[10:29:51.616]                   }
[10:29:51.616]                   muffleCondition(cond)
[10:29:51.616]                 })
[10:29:51.616]             }))
[10:29:51.616]             future::FutureResult(value = ...future.value$value, 
[10:29:51.616]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.616]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.616]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.616]                     ...future.globalenv.names))
[10:29:51.616]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.616]         }, condition = base::local({
[10:29:51.616]             c <- base::c
[10:29:51.616]             inherits <- base::inherits
[10:29:51.616]             invokeRestart <- base::invokeRestart
[10:29:51.616]             length <- base::length
[10:29:51.616]             list <- base::list
[10:29:51.616]             seq.int <- base::seq.int
[10:29:51.616]             signalCondition <- base::signalCondition
[10:29:51.616]             sys.calls <- base::sys.calls
[10:29:51.616]             `[[` <- base::`[[`
[10:29:51.616]             `+` <- base::`+`
[10:29:51.616]             `<<-` <- base::`<<-`
[10:29:51.616]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.616]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.616]                   3L)]
[10:29:51.616]             }
[10:29:51.616]             function(cond) {
[10:29:51.616]                 is_error <- inherits(cond, "error")
[10:29:51.616]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.616]                   NULL)
[10:29:51.616]                 if (is_error) {
[10:29:51.616]                   sessionInformation <- function() {
[10:29:51.616]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.616]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.616]                       search = base::search(), system = base::Sys.info())
[10:29:51.616]                   }
[10:29:51.616]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.616]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.616]                     cond$call), session = sessionInformation(), 
[10:29:51.616]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.616]                   signalCondition(cond)
[10:29:51.616]                 }
[10:29:51.616]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.616]                 "immediateCondition"))) {
[10:29:51.616]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.616]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.616]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.616]                   if (TRUE && !signal) {
[10:29:51.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.616]                     {
[10:29:51.616]                       inherits <- base::inherits
[10:29:51.616]                       invokeRestart <- base::invokeRestart
[10:29:51.616]                       is.null <- base::is.null
[10:29:51.616]                       muffled <- FALSE
[10:29:51.616]                       if (inherits(cond, "message")) {
[10:29:51.616]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.616]                         if (muffled) 
[10:29:51.616]                           invokeRestart("muffleMessage")
[10:29:51.616]                       }
[10:29:51.616]                       else if (inherits(cond, "warning")) {
[10:29:51.616]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.616]                         if (muffled) 
[10:29:51.616]                           invokeRestart("muffleWarning")
[10:29:51.616]                       }
[10:29:51.616]                       else if (inherits(cond, "condition")) {
[10:29:51.616]                         if (!is.null(pattern)) {
[10:29:51.616]                           computeRestarts <- base::computeRestarts
[10:29:51.616]                           grepl <- base::grepl
[10:29:51.616]                           restarts <- computeRestarts(cond)
[10:29:51.616]                           for (restart in restarts) {
[10:29:51.616]                             name <- restart$name
[10:29:51.616]                             if (is.null(name)) 
[10:29:51.616]                               next
[10:29:51.616]                             if (!grepl(pattern, name)) 
[10:29:51.616]                               next
[10:29:51.616]                             invokeRestart(restart)
[10:29:51.616]                             muffled <- TRUE
[10:29:51.616]                             break
[10:29:51.616]                           }
[10:29:51.616]                         }
[10:29:51.616]                       }
[10:29:51.616]                       invisible(muffled)
[10:29:51.616]                     }
[10:29:51.616]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.616]                   }
[10:29:51.616]                 }
[10:29:51.616]                 else {
[10:29:51.616]                   if (TRUE) {
[10:29:51.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.616]                     {
[10:29:51.616]                       inherits <- base::inherits
[10:29:51.616]                       invokeRestart <- base::invokeRestart
[10:29:51.616]                       is.null <- base::is.null
[10:29:51.616]                       muffled <- FALSE
[10:29:51.616]                       if (inherits(cond, "message")) {
[10:29:51.616]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.616]                         if (muffled) 
[10:29:51.616]                           invokeRestart("muffleMessage")
[10:29:51.616]                       }
[10:29:51.616]                       else if (inherits(cond, "warning")) {
[10:29:51.616]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.616]                         if (muffled) 
[10:29:51.616]                           invokeRestart("muffleWarning")
[10:29:51.616]                       }
[10:29:51.616]                       else if (inherits(cond, "condition")) {
[10:29:51.616]                         if (!is.null(pattern)) {
[10:29:51.616]                           computeRestarts <- base::computeRestarts
[10:29:51.616]                           grepl <- base::grepl
[10:29:51.616]                           restarts <- computeRestarts(cond)
[10:29:51.616]                           for (restart in restarts) {
[10:29:51.616]                             name <- restart$name
[10:29:51.616]                             if (is.null(name)) 
[10:29:51.616]                               next
[10:29:51.616]                             if (!grepl(pattern, name)) 
[10:29:51.616]                               next
[10:29:51.616]                             invokeRestart(restart)
[10:29:51.616]                             muffled <- TRUE
[10:29:51.616]                             break
[10:29:51.616]                           }
[10:29:51.616]                         }
[10:29:51.616]                       }
[10:29:51.616]                       invisible(muffled)
[10:29:51.616]                     }
[10:29:51.616]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.616]                   }
[10:29:51.616]                 }
[10:29:51.616]             }
[10:29:51.616]         }))
[10:29:51.616]     }, error = function(ex) {
[10:29:51.616]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.616]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.616]                 ...future.rng), started = ...future.startTime, 
[10:29:51.616]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.616]             version = "1.8"), class = "FutureResult")
[10:29:51.616]     }, finally = {
[10:29:51.616]         if (!identical(...future.workdir, getwd())) 
[10:29:51.616]             setwd(...future.workdir)
[10:29:51.616]         {
[10:29:51.616]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.616]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.616]             }
[10:29:51.616]             base::options(...future.oldOptions)
[10:29:51.616]             if (.Platform$OS.type == "windows") {
[10:29:51.616]                 old_names <- names(...future.oldEnvVars)
[10:29:51.616]                 envs <- base::Sys.getenv()
[10:29:51.616]                 names <- names(envs)
[10:29:51.616]                 common <- intersect(names, old_names)
[10:29:51.616]                 added <- setdiff(names, old_names)
[10:29:51.616]                 removed <- setdiff(old_names, names)
[10:29:51.616]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.616]                   envs[common]]
[10:29:51.616]                 NAMES <- toupper(changed)
[10:29:51.616]                 args <- list()
[10:29:51.616]                 for (kk in seq_along(NAMES)) {
[10:29:51.616]                   name <- changed[[kk]]
[10:29:51.616]                   NAME <- NAMES[[kk]]
[10:29:51.616]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.616]                     next
[10:29:51.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.616]                 }
[10:29:51.616]                 NAMES <- toupper(added)
[10:29:51.616]                 for (kk in seq_along(NAMES)) {
[10:29:51.616]                   name <- added[[kk]]
[10:29:51.616]                   NAME <- NAMES[[kk]]
[10:29:51.616]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.616]                     next
[10:29:51.616]                   args[[name]] <- ""
[10:29:51.616]                 }
[10:29:51.616]                 NAMES <- toupper(removed)
[10:29:51.616]                 for (kk in seq_along(NAMES)) {
[10:29:51.616]                   name <- removed[[kk]]
[10:29:51.616]                   NAME <- NAMES[[kk]]
[10:29:51.616]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.616]                     next
[10:29:51.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.616]                 }
[10:29:51.616]                 if (length(args) > 0) 
[10:29:51.616]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.616]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.616]             }
[10:29:51.616]             else {
[10:29:51.616]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.616]             }
[10:29:51.616]             {
[10:29:51.616]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.616]                   0L) {
[10:29:51.616]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.616]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.616]                   base::options(opts)
[10:29:51.616]                 }
[10:29:51.616]                 {
[10:29:51.616]                   {
[10:29:51.616]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.616]                     NULL
[10:29:51.616]                   }
[10:29:51.616]                   options(future.plan = NULL)
[10:29:51.616]                   if (is.na(NA_character_)) 
[10:29:51.616]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.616]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.616]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.616]                     .init = FALSE)
[10:29:51.616]                 }
[10:29:51.616]             }
[10:29:51.616]         }
[10:29:51.616]     })
[10:29:51.616]     if (TRUE) {
[10:29:51.616]         base::sink(type = "output", split = FALSE)
[10:29:51.616]         if (TRUE) {
[10:29:51.616]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.616]         }
[10:29:51.616]         else {
[10:29:51.616]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.616]         }
[10:29:51.616]         base::close(...future.stdout)
[10:29:51.616]         ...future.stdout <- NULL
[10:29:51.616]     }
[10:29:51.616]     ...future.result$conditions <- ...future.conditions
[10:29:51.616]     ...future.result$finished <- base::Sys.time()
[10:29:51.616]     ...future.result
[10:29:51.616] }
[10:29:51.619] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[10:29:51.619] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:51.619] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:51.619] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[10:29:51.620] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[10:29:51.620] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:29:51.620] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:29:51.620] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:51.621] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:51.621] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:29:51.621] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:29:51.621] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[10:29:51.622] MultisessionFuture started
[10:29:51.622] - Launch lazy future ... done
[10:29:51.622] run() for ‘MultisessionFuture’ ... done
[10:29:51.622] Created future:
[10:29:51.622] MultisessionFuture:
[10:29:51.622] Label: ‘future_apply-2’
[10:29:51.622] Expression:
[10:29:51.622] {
[10:29:51.622]     do.call(function(...) {
[10:29:51.622]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.622]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.622]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.622]             on.exit(options(oopts), add = TRUE)
[10:29:51.622]         }
[10:29:51.622]         {
[10:29:51.622]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.622]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.622]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.622]             })
[10:29:51.622]         }
[10:29:51.622]     }, args = future.call.arguments)
[10:29:51.622] }
[10:29:51.622] Lazy evaluation: FALSE
[10:29:51.622] Asynchronous evaluation: TRUE
[10:29:51.622] Local evaluation: TRUE
[10:29:51.622] Environment: R_GlobalEnv
[10:29:51.622] Capture standard output: TRUE
[10:29:51.622] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.622] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.622] Packages: <none>
[10:29:51.622] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.622] Resolved: FALSE
[10:29:51.622] Value: <not collected>
[10:29:51.622] Conditions captured: <none>
[10:29:51.622] Early signaling: FALSE
[10:29:51.622] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.622] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.633] Chunk #2 of 2 ... DONE
[10:29:51.634] Launching 2 futures (chunks) ... DONE
[10:29:51.634] Resolving 2 futures (chunks) ...
[10:29:51.634] resolve() on list ...
[10:29:51.634]  recursive: 0
[10:29:51.634]  length: 2
[10:29:51.634] 
[10:29:51.635] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.635] - Validating connection of MultisessionFuture
[10:29:51.635] - received message: FutureResult
[10:29:51.635] - Received FutureResult
[10:29:51.635] - Erased future from FutureRegistry
[10:29:51.635] result() for ClusterFuture ...
[10:29:51.635] - result already collected: FutureResult
[10:29:51.635] result() for ClusterFuture ... done
[10:29:51.635] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.635] Future #1
[10:29:51.636] result() for ClusterFuture ...
[10:29:51.636] - result already collected: FutureResult
[10:29:51.636] result() for ClusterFuture ... done
[10:29:51.636] result() for ClusterFuture ...
[10:29:51.636] - result already collected: FutureResult
[10:29:51.636] result() for ClusterFuture ... done
[10:29:51.636] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:51.636] - nx: 2
[10:29:51.636] - relay: TRUE
[10:29:51.636] - stdout: TRUE
[10:29:51.636] - signal: TRUE
[10:29:51.637] - resignal: FALSE
[10:29:51.637] - force: TRUE
[10:29:51.637] - relayed: [n=2] FALSE, FALSE
[10:29:51.637] - queued futures: [n=2] FALSE, FALSE
[10:29:51.637]  - until=1
[10:29:51.637]  - relaying element #1
[10:29:51.637] result() for ClusterFuture ...
[10:29:51.637] - result already collected: FutureResult
[10:29:51.637] result() for ClusterFuture ... done
[10:29:51.637] result() for ClusterFuture ...
[10:29:51.637] - result already collected: FutureResult
[10:29:51.638] result() for ClusterFuture ... done
[10:29:51.638] result() for ClusterFuture ...
[10:29:51.638] - result already collected: FutureResult
[10:29:51.638] result() for ClusterFuture ... done
[10:29:51.638] result() for ClusterFuture ...
[10:29:51.638] - result already collected: FutureResult
[10:29:51.638] result() for ClusterFuture ... done
[10:29:51.638] - relayed: [n=2] TRUE, FALSE
[10:29:51.638] - queued futures: [n=2] TRUE, FALSE
[10:29:51.638] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:51.638]  length: 1 (resolved future 1)
[10:29:51.666] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.667] - Validating connection of MultisessionFuture
[10:29:51.667] - received message: FutureResult
[10:29:51.667] - Received FutureResult
[10:29:51.667] - Erased future from FutureRegistry
[10:29:51.667] result() for ClusterFuture ...
[10:29:51.667] - result already collected: FutureResult
[10:29:51.667] result() for ClusterFuture ... done
[10:29:51.667] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.667] Future #2
[10:29:51.668] result() for ClusterFuture ...
[10:29:51.668] - result already collected: FutureResult
[10:29:51.668] result() for ClusterFuture ... done
[10:29:51.668] result() for ClusterFuture ...
[10:29:51.668] - result already collected: FutureResult
[10:29:51.668] result() for ClusterFuture ... done
[10:29:51.668] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:51.668] - nx: 2
[10:29:51.668] - relay: TRUE
[10:29:51.668] - stdout: TRUE
[10:29:51.668] - signal: TRUE
[10:29:51.668] - resignal: FALSE
[10:29:51.669] - force: TRUE
[10:29:51.669] - relayed: [n=2] TRUE, FALSE
[10:29:51.669] - queued futures: [n=2] TRUE, FALSE
[10:29:51.669]  - until=2
[10:29:51.669]  - relaying element #2
[10:29:51.669] result() for ClusterFuture ...
[10:29:51.669] - result already collected: FutureResult
[10:29:51.669] result() for ClusterFuture ... done
[10:29:51.669] result() for ClusterFuture ...
[10:29:51.669] - result already collected: FutureResult
[10:29:51.670] result() for ClusterFuture ... done
[10:29:51.670] result() for ClusterFuture ...
[10:29:51.670] - result already collected: FutureResult
[10:29:51.670] result() for ClusterFuture ... done
[10:29:51.670] result() for ClusterFuture ...
[10:29:51.670] - result already collected: FutureResult
[10:29:51.670] result() for ClusterFuture ... done
[10:29:51.670] - relayed: [n=2] TRUE, TRUE
[10:29:51.670] - queued futures: [n=2] TRUE, TRUE
[10:29:51.670] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:51.670]  length: 0 (resolved future 2)
[10:29:51.671] Relaying remaining futures
[10:29:51.671] signalConditionsASAP(NULL, pos=0) ...
[10:29:51.671] - nx: 2
[10:29:51.671] - relay: TRUE
[10:29:51.671] - stdout: TRUE
[10:29:51.671] - signal: TRUE
[10:29:51.671] - resignal: FALSE
[10:29:51.671] - force: TRUE
[10:29:51.671] - relayed: [n=2] TRUE, TRUE
[10:29:51.671] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:51.671] - relayed: [n=2] TRUE, TRUE
[10:29:51.672] - queued futures: [n=2] TRUE, TRUE
[10:29:51.672] signalConditionsASAP(NULL, pos=0) ... done
[10:29:51.672] resolve() on list ... DONE
[10:29:51.672] result() for ClusterFuture ...
[10:29:51.672] - result already collected: FutureResult
[10:29:51.672] result() for ClusterFuture ... done
[10:29:51.672] result() for ClusterFuture ...
[10:29:51.672] - result already collected: FutureResult
[10:29:51.672] result() for ClusterFuture ... done
[10:29:51.672] result() for ClusterFuture ...
[10:29:51.672] - result already collected: FutureResult
[10:29:51.672] result() for ClusterFuture ... done
[10:29:51.673] result() for ClusterFuture ...
[10:29:51.673] - result already collected: FutureResult
[10:29:51.673] result() for ClusterFuture ... done
[10:29:51.673]  - Number of value chunks collected: 2
[10:29:51.673] Resolving 2 futures (chunks) ... DONE
[10:29:51.673] Reducing values from 2 chunks ...
[10:29:51.673]  - Number of values collected after concatenation: 2
[10:29:51.673]  - Number of values expected: 2
[10:29:51.673] Reducing values from 2 chunks ... DONE
[10:29:51.673] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:29:51.674] getGlobalsAndPackagesXApply() ...
[10:29:51.674]  - future.globals: TRUE
[10:29:51.674] getGlobalsAndPackages() ...
[10:29:51.674] Searching for globals...
[10:29:51.675] - globals found: [1] ‘FUN’
[10:29:51.675] Searching for globals ... DONE
[10:29:51.675] Resolving globals: FALSE
[10:29:51.676] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:51.676] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:51.676] - globals: [1] ‘FUN’
[10:29:51.676] 
[10:29:51.676] getGlobalsAndPackages() ... DONE
[10:29:51.676]  - globals found/used: [n=1] ‘FUN’
[10:29:51.677]  - needed namespaces: [n=0] 
[10:29:51.677] Finding globals ... DONE
[10:29:51.677]  - use_args: TRUE
[10:29:51.677]  - Getting '...' globals ...
[10:29:51.677] resolve() on list ...
[10:29:51.677]  recursive: 0
[10:29:51.677]  length: 1
[10:29:51.677]  elements: ‘...’
[10:29:51.678]  length: 0 (resolved future 1)
[10:29:51.678] resolve() on list ... DONE
[10:29:51.678]    - '...' content: [n=0] 
[10:29:51.678] List of 1
[10:29:51.678]  $ ...: list()
[10:29:51.678]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.678]  - attr(*, "where")=List of 1
[10:29:51.678]   ..$ ...:<environment: 0x5618a3372360> 
[10:29:51.678]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.678]  - attr(*, "resolved")= logi TRUE
[10:29:51.678]  - attr(*, "total_size")= num NA
[10:29:51.680]  - Getting '...' globals ... DONE
[10:29:51.680] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:51.681] List of 2
[10:29:51.681]  $ ...future.FUN:function (x)  
[10:29:51.681]  $ ...          : list()
[10:29:51.681]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.681]  - attr(*, "where")=List of 2
[10:29:51.681]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:51.681]   ..$ ...          :<environment: 0x5618a3372360> 
[10:29:51.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.681]  - attr(*, "resolved")= logi FALSE
[10:29:51.681]  - attr(*, "total_size")= num 848
[10:29:51.683] Packages to be attached in all futures: [n=0] 
[10:29:51.683] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.687] future_lapply() ...
[10:29:51.691] Number of chunks: 2
[10:29:51.691] getGlobalsAndPackagesXApply() ...
[10:29:51.691]  - future.globals: <name-value list> with names ‘list()’
[10:29:51.691]  - use_args: TRUE
[10:29:51.691] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:51.691] List of 2
[10:29:51.691]  $ ...          : list()
[10:29:51.691]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.691]  $ ...future.FUN:function (x)  
[10:29:51.691]  - attr(*, "where")=List of 2
[10:29:51.691]   ..$ ...          :<environment: 0x5618a3372360> 
[10:29:51.691]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:51.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.691]  - attr(*, "resolved")= logi FALSE
[10:29:51.691]  - attr(*, "total_size")= num NA
[10:29:51.695] Packages to be attached in all futures: [n=0] 
[10:29:51.695] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.695] Number of futures (= number of chunks): 2
[10:29:51.695] Launching 2 futures (chunks) ...
[10:29:51.695] Chunk #1 of 2 ...
[10:29:51.695]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.695]  - seeds: <none>
[10:29:51.695]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.695] getGlobalsAndPackages() ...
[10:29:51.696] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.696] Resolving globals: FALSE
[10:29:51.696] Tweak future expression to call with '...' arguments ...
[10:29:51.696] {
[10:29:51.696]     do.call(function(...) {
[10:29:51.696]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.696]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.696]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.696]             on.exit(options(oopts), add = TRUE)
[10:29:51.696]         }
[10:29:51.696]         {
[10:29:51.696]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.696]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.696]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.696]             })
[10:29:51.696]         }
[10:29:51.696]     }, args = future.call.arguments)
[10:29:51.696] }
[10:29:51.696] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.697] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.697] 
[10:29:51.697] getGlobalsAndPackages() ... DONE
[10:29:51.697] run() for ‘Future’ ...
[10:29:51.697] - state: ‘created’
[10:29:51.697] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.711] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.711]   - Field: ‘node’
[10:29:51.711]   - Field: ‘label’
[10:29:51.711]   - Field: ‘local’
[10:29:51.711]   - Field: ‘owner’
[10:29:51.711]   - Field: ‘envir’
[10:29:51.712]   - Field: ‘workers’
[10:29:51.712]   - Field: ‘packages’
[10:29:51.712]   - Field: ‘gc’
[10:29:51.712]   - Field: ‘conditions’
[10:29:51.712]   - Field: ‘persistent’
[10:29:51.712]   - Field: ‘expr’
[10:29:51.712]   - Field: ‘uuid’
[10:29:51.712]   - Field: ‘seed’
[10:29:51.712]   - Field: ‘version’
[10:29:51.712]   - Field: ‘result’
[10:29:51.712]   - Field: ‘asynchronous’
[10:29:51.713]   - Field: ‘calls’
[10:29:51.713]   - Field: ‘globals’
[10:29:51.713]   - Field: ‘stdout’
[10:29:51.713]   - Field: ‘earlySignal’
[10:29:51.713]   - Field: ‘lazy’
[10:29:51.713]   - Field: ‘state’
[10:29:51.713] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.713] - Launch lazy future ...
[10:29:51.713] Packages needed by the future expression (n = 0): <none>
[10:29:51.714] Packages needed by future strategies (n = 0): <none>
[10:29:51.714] {
[10:29:51.714]     {
[10:29:51.714]         {
[10:29:51.714]             ...future.startTime <- base::Sys.time()
[10:29:51.714]             {
[10:29:51.714]                 {
[10:29:51.714]                   {
[10:29:51.714]                     {
[10:29:51.714]                       base::local({
[10:29:51.714]                         has_future <- base::requireNamespace("future", 
[10:29:51.714]                           quietly = TRUE)
[10:29:51.714]                         if (has_future) {
[10:29:51.714]                           ns <- base::getNamespace("future")
[10:29:51.714]                           version <- ns[[".package"]][["version"]]
[10:29:51.714]                           if (is.null(version)) 
[10:29:51.714]                             version <- utils::packageVersion("future")
[10:29:51.714]                         }
[10:29:51.714]                         else {
[10:29:51.714]                           version <- NULL
[10:29:51.714]                         }
[10:29:51.714]                         if (!has_future || version < "1.8.0") {
[10:29:51.714]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.714]                             "", base::R.version$version.string), 
[10:29:51.714]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:51.714]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:51.714]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.714]                               "release", "version")], collapse = " "), 
[10:29:51.714]                             hostname = base::Sys.info()[["nodename"]])
[10:29:51.714]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.714]                             info)
[10:29:51.714]                           info <- base::paste(info, collapse = "; ")
[10:29:51.714]                           if (!has_future) {
[10:29:51.714]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.714]                               info)
[10:29:51.714]                           }
[10:29:51.714]                           else {
[10:29:51.714]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.714]                               info, version)
[10:29:51.714]                           }
[10:29:51.714]                           base::stop(msg)
[10:29:51.714]                         }
[10:29:51.714]                       })
[10:29:51.714]                     }
[10:29:51.714]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.714]                     base::options(mc.cores = 1L)
[10:29:51.714]                   }
[10:29:51.714]                   ...future.strategy.old <- future::plan("list")
[10:29:51.714]                   options(future.plan = NULL)
[10:29:51.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.714]                 }
[10:29:51.714]                 ...future.workdir <- getwd()
[10:29:51.714]             }
[10:29:51.714]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.714]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.714]         }
[10:29:51.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.714]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.714]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.714]             base::names(...future.oldOptions))
[10:29:51.714]     }
[10:29:51.714]     if (FALSE) {
[10:29:51.714]     }
[10:29:51.714]     else {
[10:29:51.714]         if (TRUE) {
[10:29:51.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.714]                 open = "w")
[10:29:51.714]         }
[10:29:51.714]         else {
[10:29:51.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.714]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.714]         }
[10:29:51.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.714]             base::sink(type = "output", split = FALSE)
[10:29:51.714]             base::close(...future.stdout)
[10:29:51.714]         }, add = TRUE)
[10:29:51.714]     }
[10:29:51.714]     ...future.frame <- base::sys.nframe()
[10:29:51.714]     ...future.conditions <- base::list()
[10:29:51.714]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.714]     if (FALSE) {
[10:29:51.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.714]     }
[10:29:51.714]     ...future.result <- base::tryCatch({
[10:29:51.714]         base::withCallingHandlers({
[10:29:51.714]             ...future.value <- base::withVisible(base::local({
[10:29:51.714]                 ...future.makeSendCondition <- base::local({
[10:29:51.714]                   sendCondition <- NULL
[10:29:51.714]                   function(frame = 1L) {
[10:29:51.714]                     if (is.function(sendCondition)) 
[10:29:51.714]                       return(sendCondition)
[10:29:51.714]                     ns <- getNamespace("parallel")
[10:29:51.714]                     if (exists("sendData", mode = "function", 
[10:29:51.714]                       envir = ns)) {
[10:29:51.714]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.714]                         envir = ns)
[10:29:51.714]                       envir <- sys.frame(frame)
[10:29:51.714]                       master <- NULL
[10:29:51.714]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.714]                         !identical(envir, emptyenv())) {
[10:29:51.714]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.714]                           inherits = FALSE)) {
[10:29:51.714]                           master <- get("master", mode = "list", 
[10:29:51.714]                             envir = envir, inherits = FALSE)
[10:29:51.714]                           if (inherits(master, c("SOCKnode", 
[10:29:51.714]                             "SOCK0node"))) {
[10:29:51.714]                             sendCondition <<- function(cond) {
[10:29:51.714]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.714]                                 success = TRUE)
[10:29:51.714]                               parallel_sendData(master, data)
[10:29:51.714]                             }
[10:29:51.714]                             return(sendCondition)
[10:29:51.714]                           }
[10:29:51.714]                         }
[10:29:51.714]                         frame <- frame + 1L
[10:29:51.714]                         envir <- sys.frame(frame)
[10:29:51.714]                       }
[10:29:51.714]                     }
[10:29:51.714]                     sendCondition <<- function(cond) NULL
[10:29:51.714]                   }
[10:29:51.714]                 })
[10:29:51.714]                 withCallingHandlers({
[10:29:51.714]                   {
[10:29:51.714]                     do.call(function(...) {
[10:29:51.714]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.714]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.714]                         ...future.globals.maxSize)) {
[10:29:51.714]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.714]                         on.exit(options(oopts), add = TRUE)
[10:29:51.714]                       }
[10:29:51.714]                       {
[10:29:51.714]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.714]                           FUN = function(jj) {
[10:29:51.714]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.714]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.714]                           })
[10:29:51.714]                       }
[10:29:51.714]                     }, args = future.call.arguments)
[10:29:51.714]                   }
[10:29:51.714]                 }, immediateCondition = function(cond) {
[10:29:51.714]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.714]                   sendCondition(cond)
[10:29:51.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.714]                   {
[10:29:51.714]                     inherits <- base::inherits
[10:29:51.714]                     invokeRestart <- base::invokeRestart
[10:29:51.714]                     is.null <- base::is.null
[10:29:51.714]                     muffled <- FALSE
[10:29:51.714]                     if (inherits(cond, "message")) {
[10:29:51.714]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.714]                       if (muffled) 
[10:29:51.714]                         invokeRestart("muffleMessage")
[10:29:51.714]                     }
[10:29:51.714]                     else if (inherits(cond, "warning")) {
[10:29:51.714]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.714]                       if (muffled) 
[10:29:51.714]                         invokeRestart("muffleWarning")
[10:29:51.714]                     }
[10:29:51.714]                     else if (inherits(cond, "condition")) {
[10:29:51.714]                       if (!is.null(pattern)) {
[10:29:51.714]                         computeRestarts <- base::computeRestarts
[10:29:51.714]                         grepl <- base::grepl
[10:29:51.714]                         restarts <- computeRestarts(cond)
[10:29:51.714]                         for (restart in restarts) {
[10:29:51.714]                           name <- restart$name
[10:29:51.714]                           if (is.null(name)) 
[10:29:51.714]                             next
[10:29:51.714]                           if (!grepl(pattern, name)) 
[10:29:51.714]                             next
[10:29:51.714]                           invokeRestart(restart)
[10:29:51.714]                           muffled <- TRUE
[10:29:51.714]                           break
[10:29:51.714]                         }
[10:29:51.714]                       }
[10:29:51.714]                     }
[10:29:51.714]                     invisible(muffled)
[10:29:51.714]                   }
[10:29:51.714]                   muffleCondition(cond)
[10:29:51.714]                 })
[10:29:51.714]             }))
[10:29:51.714]             future::FutureResult(value = ...future.value$value, 
[10:29:51.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.714]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.714]                     ...future.globalenv.names))
[10:29:51.714]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.714]         }, condition = base::local({
[10:29:51.714]             c <- base::c
[10:29:51.714]             inherits <- base::inherits
[10:29:51.714]             invokeRestart <- base::invokeRestart
[10:29:51.714]             length <- base::length
[10:29:51.714]             list <- base::list
[10:29:51.714]             seq.int <- base::seq.int
[10:29:51.714]             signalCondition <- base::signalCondition
[10:29:51.714]             sys.calls <- base::sys.calls
[10:29:51.714]             `[[` <- base::`[[`
[10:29:51.714]             `+` <- base::`+`
[10:29:51.714]             `<<-` <- base::`<<-`
[10:29:51.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.714]                   3L)]
[10:29:51.714]             }
[10:29:51.714]             function(cond) {
[10:29:51.714]                 is_error <- inherits(cond, "error")
[10:29:51.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.714]                   NULL)
[10:29:51.714]                 if (is_error) {
[10:29:51.714]                   sessionInformation <- function() {
[10:29:51.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.714]                       search = base::search(), system = base::Sys.info())
[10:29:51.714]                   }
[10:29:51.714]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.714]                     cond$call), session = sessionInformation(), 
[10:29:51.714]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.714]                   signalCondition(cond)
[10:29:51.714]                 }
[10:29:51.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.714]                 "immediateCondition"))) {
[10:29:51.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.714]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.714]                   if (TRUE && !signal) {
[10:29:51.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.714]                     {
[10:29:51.714]                       inherits <- base::inherits
[10:29:51.714]                       invokeRestart <- base::invokeRestart
[10:29:51.714]                       is.null <- base::is.null
[10:29:51.714]                       muffled <- FALSE
[10:29:51.714]                       if (inherits(cond, "message")) {
[10:29:51.714]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.714]                         if (muffled) 
[10:29:51.714]                           invokeRestart("muffleMessage")
[10:29:51.714]                       }
[10:29:51.714]                       else if (inherits(cond, "warning")) {
[10:29:51.714]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.714]                         if (muffled) 
[10:29:51.714]                           invokeRestart("muffleWarning")
[10:29:51.714]                       }
[10:29:51.714]                       else if (inherits(cond, "condition")) {
[10:29:51.714]                         if (!is.null(pattern)) {
[10:29:51.714]                           computeRestarts <- base::computeRestarts
[10:29:51.714]                           grepl <- base::grepl
[10:29:51.714]                           restarts <- computeRestarts(cond)
[10:29:51.714]                           for (restart in restarts) {
[10:29:51.714]                             name <- restart$name
[10:29:51.714]                             if (is.null(name)) 
[10:29:51.714]                               next
[10:29:51.714]                             if (!grepl(pattern, name)) 
[10:29:51.714]                               next
[10:29:51.714]                             invokeRestart(restart)
[10:29:51.714]                             muffled <- TRUE
[10:29:51.714]                             break
[10:29:51.714]                           }
[10:29:51.714]                         }
[10:29:51.714]                       }
[10:29:51.714]                       invisible(muffled)
[10:29:51.714]                     }
[10:29:51.714]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.714]                   }
[10:29:51.714]                 }
[10:29:51.714]                 else {
[10:29:51.714]                   if (TRUE) {
[10:29:51.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.714]                     {
[10:29:51.714]                       inherits <- base::inherits
[10:29:51.714]                       invokeRestart <- base::invokeRestart
[10:29:51.714]                       is.null <- base::is.null
[10:29:51.714]                       muffled <- FALSE
[10:29:51.714]                       if (inherits(cond, "message")) {
[10:29:51.714]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.714]                         if (muffled) 
[10:29:51.714]                           invokeRestart("muffleMessage")
[10:29:51.714]                       }
[10:29:51.714]                       else if (inherits(cond, "warning")) {
[10:29:51.714]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.714]                         if (muffled) 
[10:29:51.714]                           invokeRestart("muffleWarning")
[10:29:51.714]                       }
[10:29:51.714]                       else if (inherits(cond, "condition")) {
[10:29:51.714]                         if (!is.null(pattern)) {
[10:29:51.714]                           computeRestarts <- base::computeRestarts
[10:29:51.714]                           grepl <- base::grepl
[10:29:51.714]                           restarts <- computeRestarts(cond)
[10:29:51.714]                           for (restart in restarts) {
[10:29:51.714]                             name <- restart$name
[10:29:51.714]                             if (is.null(name)) 
[10:29:51.714]                               next
[10:29:51.714]                             if (!grepl(pattern, name)) 
[10:29:51.714]                               next
[10:29:51.714]                             invokeRestart(restart)
[10:29:51.714]                             muffled <- TRUE
[10:29:51.714]                             break
[10:29:51.714]                           }
[10:29:51.714]                         }
[10:29:51.714]                       }
[10:29:51.714]                       invisible(muffled)
[10:29:51.714]                     }
[10:29:51.714]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.714]                   }
[10:29:51.714]                 }
[10:29:51.714]             }
[10:29:51.714]         }))
[10:29:51.714]     }, error = function(ex) {
[10:29:51.714]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.714]                 ...future.rng), started = ...future.startTime, 
[10:29:51.714]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.714]             version = "1.8"), class = "FutureResult")
[10:29:51.714]     }, finally = {
[10:29:51.714]         if (!identical(...future.workdir, getwd())) 
[10:29:51.714]             setwd(...future.workdir)
[10:29:51.714]         {
[10:29:51.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.714]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.714]             }
[10:29:51.714]             base::options(...future.oldOptions)
[10:29:51.714]             if (.Platform$OS.type == "windows") {
[10:29:51.714]                 old_names <- names(...future.oldEnvVars)
[10:29:51.714]                 envs <- base::Sys.getenv()
[10:29:51.714]                 names <- names(envs)
[10:29:51.714]                 common <- intersect(names, old_names)
[10:29:51.714]                 added <- setdiff(names, old_names)
[10:29:51.714]                 removed <- setdiff(old_names, names)
[10:29:51.714]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.714]                   envs[common]]
[10:29:51.714]                 NAMES <- toupper(changed)
[10:29:51.714]                 args <- list()
[10:29:51.714]                 for (kk in seq_along(NAMES)) {
[10:29:51.714]                   name <- changed[[kk]]
[10:29:51.714]                   NAME <- NAMES[[kk]]
[10:29:51.714]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.714]                     next
[10:29:51.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.714]                 }
[10:29:51.714]                 NAMES <- toupper(added)
[10:29:51.714]                 for (kk in seq_along(NAMES)) {
[10:29:51.714]                   name <- added[[kk]]
[10:29:51.714]                   NAME <- NAMES[[kk]]
[10:29:51.714]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.714]                     next
[10:29:51.714]                   args[[name]] <- ""
[10:29:51.714]                 }
[10:29:51.714]                 NAMES <- toupper(removed)
[10:29:51.714]                 for (kk in seq_along(NAMES)) {
[10:29:51.714]                   name <- removed[[kk]]
[10:29:51.714]                   NAME <- NAMES[[kk]]
[10:29:51.714]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.714]                     next
[10:29:51.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.714]                 }
[10:29:51.714]                 if (length(args) > 0) 
[10:29:51.714]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.714]             }
[10:29:51.714]             else {
[10:29:51.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.714]             }
[10:29:51.714]             {
[10:29:51.714]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.714]                   0L) {
[10:29:51.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.714]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.714]                   base::options(opts)
[10:29:51.714]                 }
[10:29:51.714]                 {
[10:29:51.714]                   {
[10:29:51.714]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.714]                     NULL
[10:29:51.714]                   }
[10:29:51.714]                   options(future.plan = NULL)
[10:29:51.714]                   if (is.na(NA_character_)) 
[10:29:51.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.714]                     .init = FALSE)
[10:29:51.714]                 }
[10:29:51.714]             }
[10:29:51.714]         }
[10:29:51.714]     })
[10:29:51.714]     if (TRUE) {
[10:29:51.714]         base::sink(type = "output", split = FALSE)
[10:29:51.714]         if (TRUE) {
[10:29:51.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.714]         }
[10:29:51.714]         else {
[10:29:51.714]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.714]         }
[10:29:51.714]         base::close(...future.stdout)
[10:29:51.714]         ...future.stdout <- NULL
[10:29:51.714]     }
[10:29:51.714]     ...future.result$conditions <- ...future.conditions
[10:29:51.714]     ...future.result$finished <- base::Sys.time()
[10:29:51.714]     ...future.result
[10:29:51.714] }
[10:29:51.717] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[10:29:51.717] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:51.718] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.718] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:29:51.718] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:29:51.718] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[10:29:51.719] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[10:29:51.719] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:51.719] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.719] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:51.720] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:51.720] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[10:29:51.720] MultisessionFuture started
[10:29:51.721] - Launch lazy future ... done
[10:29:51.721] run() for ‘MultisessionFuture’ ... done
[10:29:51.721] Created future:
[10:29:51.721] MultisessionFuture:
[10:29:51.721] Label: ‘future_apply-1’
[10:29:51.721] Expression:
[10:29:51.721] {
[10:29:51.721]     do.call(function(...) {
[10:29:51.721]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.721]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.721]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.721]             on.exit(options(oopts), add = TRUE)
[10:29:51.721]         }
[10:29:51.721]         {
[10:29:51.721]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.721]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.721]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.721]             })
[10:29:51.721]         }
[10:29:51.721]     }, args = future.call.arguments)
[10:29:51.721] }
[10:29:51.721] Lazy evaluation: FALSE
[10:29:51.721] Asynchronous evaluation: TRUE
[10:29:51.721] Local evaluation: TRUE
[10:29:51.721] Environment: R_GlobalEnv
[10:29:51.721] Capture standard output: TRUE
[10:29:51.721] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.721] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.721] Packages: <none>
[10:29:51.721] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.721] Resolved: FALSE
[10:29:51.721] Value: <not collected>
[10:29:51.721] Conditions captured: <none>
[10:29:51.721] Early signaling: FALSE
[10:29:51.721] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.721] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.733] Chunk #1 of 2 ... DONE
[10:29:51.733] Chunk #2 of 2 ...
[10:29:51.733]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.733]  - seeds: <none>
[10:29:51.733]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.733] getGlobalsAndPackages() ...
[10:29:51.733] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.734] Resolving globals: FALSE
[10:29:51.734] Tweak future expression to call with '...' arguments ...
[10:29:51.734] {
[10:29:51.734]     do.call(function(...) {
[10:29:51.734]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.734]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.734]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.734]             on.exit(options(oopts), add = TRUE)
[10:29:51.734]         }
[10:29:51.734]         {
[10:29:51.734]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.734]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.734]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.734]             })
[10:29:51.734]         }
[10:29:51.734]     }, args = future.call.arguments)
[10:29:51.734] }
[10:29:51.734] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.736] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.737] 
[10:29:51.737] getGlobalsAndPackages() ... DONE
[10:29:51.737] run() for ‘Future’ ...
[10:29:51.737] - state: ‘created’
[10:29:51.737] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.751] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.751]   - Field: ‘node’
[10:29:51.751]   - Field: ‘label’
[10:29:51.752]   - Field: ‘local’
[10:29:51.752]   - Field: ‘owner’
[10:29:51.752]   - Field: ‘envir’
[10:29:51.752]   - Field: ‘workers’
[10:29:51.752]   - Field: ‘packages’
[10:29:51.752]   - Field: ‘gc’
[10:29:51.752]   - Field: ‘conditions’
[10:29:51.752]   - Field: ‘persistent’
[10:29:51.752]   - Field: ‘expr’
[10:29:51.752]   - Field: ‘uuid’
[10:29:51.752]   - Field: ‘seed’
[10:29:51.753]   - Field: ‘version’
[10:29:51.753]   - Field: ‘result’
[10:29:51.753]   - Field: ‘asynchronous’
[10:29:51.753]   - Field: ‘calls’
[10:29:51.753]   - Field: ‘globals’
[10:29:51.753]   - Field: ‘stdout’
[10:29:51.753]   - Field: ‘earlySignal’
[10:29:51.753]   - Field: ‘lazy’
[10:29:51.753]   - Field: ‘state’
[10:29:51.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.754] - Launch lazy future ...
[10:29:51.754] Packages needed by the future expression (n = 0): <none>
[10:29:51.754] Packages needed by future strategies (n = 0): <none>
[10:29:51.754] {
[10:29:51.754]     {
[10:29:51.754]         {
[10:29:51.754]             ...future.startTime <- base::Sys.time()
[10:29:51.754]             {
[10:29:51.754]                 {
[10:29:51.754]                   {
[10:29:51.754]                     {
[10:29:51.754]                       base::local({
[10:29:51.754]                         has_future <- base::requireNamespace("future", 
[10:29:51.754]                           quietly = TRUE)
[10:29:51.754]                         if (has_future) {
[10:29:51.754]                           ns <- base::getNamespace("future")
[10:29:51.754]                           version <- ns[[".package"]][["version"]]
[10:29:51.754]                           if (is.null(version)) 
[10:29:51.754]                             version <- utils::packageVersion("future")
[10:29:51.754]                         }
[10:29:51.754]                         else {
[10:29:51.754]                           version <- NULL
[10:29:51.754]                         }
[10:29:51.754]                         if (!has_future || version < "1.8.0") {
[10:29:51.754]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.754]                             "", base::R.version$version.string), 
[10:29:51.754]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:51.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:51.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.754]                               "release", "version")], collapse = " "), 
[10:29:51.754]                             hostname = base::Sys.info()[["nodename"]])
[10:29:51.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.754]                             info)
[10:29:51.754]                           info <- base::paste(info, collapse = "; ")
[10:29:51.754]                           if (!has_future) {
[10:29:51.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.754]                               info)
[10:29:51.754]                           }
[10:29:51.754]                           else {
[10:29:51.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.754]                               info, version)
[10:29:51.754]                           }
[10:29:51.754]                           base::stop(msg)
[10:29:51.754]                         }
[10:29:51.754]                       })
[10:29:51.754]                     }
[10:29:51.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.754]                     base::options(mc.cores = 1L)
[10:29:51.754]                   }
[10:29:51.754]                   ...future.strategy.old <- future::plan("list")
[10:29:51.754]                   options(future.plan = NULL)
[10:29:51.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.754]                 }
[10:29:51.754]                 ...future.workdir <- getwd()
[10:29:51.754]             }
[10:29:51.754]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.754]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.754]         }
[10:29:51.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.754]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.754]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.754]             base::names(...future.oldOptions))
[10:29:51.754]     }
[10:29:51.754]     if (FALSE) {
[10:29:51.754]     }
[10:29:51.754]     else {
[10:29:51.754]         if (TRUE) {
[10:29:51.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.754]                 open = "w")
[10:29:51.754]         }
[10:29:51.754]         else {
[10:29:51.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.754]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.754]         }
[10:29:51.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.754]             base::sink(type = "output", split = FALSE)
[10:29:51.754]             base::close(...future.stdout)
[10:29:51.754]         }, add = TRUE)
[10:29:51.754]     }
[10:29:51.754]     ...future.frame <- base::sys.nframe()
[10:29:51.754]     ...future.conditions <- base::list()
[10:29:51.754]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.754]     if (FALSE) {
[10:29:51.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.754]     }
[10:29:51.754]     ...future.result <- base::tryCatch({
[10:29:51.754]         base::withCallingHandlers({
[10:29:51.754]             ...future.value <- base::withVisible(base::local({
[10:29:51.754]                 ...future.makeSendCondition <- base::local({
[10:29:51.754]                   sendCondition <- NULL
[10:29:51.754]                   function(frame = 1L) {
[10:29:51.754]                     if (is.function(sendCondition)) 
[10:29:51.754]                       return(sendCondition)
[10:29:51.754]                     ns <- getNamespace("parallel")
[10:29:51.754]                     if (exists("sendData", mode = "function", 
[10:29:51.754]                       envir = ns)) {
[10:29:51.754]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.754]                         envir = ns)
[10:29:51.754]                       envir <- sys.frame(frame)
[10:29:51.754]                       master <- NULL
[10:29:51.754]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.754]                         !identical(envir, emptyenv())) {
[10:29:51.754]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.754]                           inherits = FALSE)) {
[10:29:51.754]                           master <- get("master", mode = "list", 
[10:29:51.754]                             envir = envir, inherits = FALSE)
[10:29:51.754]                           if (inherits(master, c("SOCKnode", 
[10:29:51.754]                             "SOCK0node"))) {
[10:29:51.754]                             sendCondition <<- function(cond) {
[10:29:51.754]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.754]                                 success = TRUE)
[10:29:51.754]                               parallel_sendData(master, data)
[10:29:51.754]                             }
[10:29:51.754]                             return(sendCondition)
[10:29:51.754]                           }
[10:29:51.754]                         }
[10:29:51.754]                         frame <- frame + 1L
[10:29:51.754]                         envir <- sys.frame(frame)
[10:29:51.754]                       }
[10:29:51.754]                     }
[10:29:51.754]                     sendCondition <<- function(cond) NULL
[10:29:51.754]                   }
[10:29:51.754]                 })
[10:29:51.754]                 withCallingHandlers({
[10:29:51.754]                   {
[10:29:51.754]                     do.call(function(...) {
[10:29:51.754]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.754]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.754]                         ...future.globals.maxSize)) {
[10:29:51.754]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.754]                         on.exit(options(oopts), add = TRUE)
[10:29:51.754]                       }
[10:29:51.754]                       {
[10:29:51.754]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.754]                           FUN = function(jj) {
[10:29:51.754]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.754]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.754]                           })
[10:29:51.754]                       }
[10:29:51.754]                     }, args = future.call.arguments)
[10:29:51.754]                   }
[10:29:51.754]                 }, immediateCondition = function(cond) {
[10:29:51.754]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.754]                   sendCondition(cond)
[10:29:51.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.754]                   {
[10:29:51.754]                     inherits <- base::inherits
[10:29:51.754]                     invokeRestart <- base::invokeRestart
[10:29:51.754]                     is.null <- base::is.null
[10:29:51.754]                     muffled <- FALSE
[10:29:51.754]                     if (inherits(cond, "message")) {
[10:29:51.754]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.754]                       if (muffled) 
[10:29:51.754]                         invokeRestart("muffleMessage")
[10:29:51.754]                     }
[10:29:51.754]                     else if (inherits(cond, "warning")) {
[10:29:51.754]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.754]                       if (muffled) 
[10:29:51.754]                         invokeRestart("muffleWarning")
[10:29:51.754]                     }
[10:29:51.754]                     else if (inherits(cond, "condition")) {
[10:29:51.754]                       if (!is.null(pattern)) {
[10:29:51.754]                         computeRestarts <- base::computeRestarts
[10:29:51.754]                         grepl <- base::grepl
[10:29:51.754]                         restarts <- computeRestarts(cond)
[10:29:51.754]                         for (restart in restarts) {
[10:29:51.754]                           name <- restart$name
[10:29:51.754]                           if (is.null(name)) 
[10:29:51.754]                             next
[10:29:51.754]                           if (!grepl(pattern, name)) 
[10:29:51.754]                             next
[10:29:51.754]                           invokeRestart(restart)
[10:29:51.754]                           muffled <- TRUE
[10:29:51.754]                           break
[10:29:51.754]                         }
[10:29:51.754]                       }
[10:29:51.754]                     }
[10:29:51.754]                     invisible(muffled)
[10:29:51.754]                   }
[10:29:51.754]                   muffleCondition(cond)
[10:29:51.754]                 })
[10:29:51.754]             }))
[10:29:51.754]             future::FutureResult(value = ...future.value$value, 
[10:29:51.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.754]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.754]                     ...future.globalenv.names))
[10:29:51.754]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.754]         }, condition = base::local({
[10:29:51.754]             c <- base::c
[10:29:51.754]             inherits <- base::inherits
[10:29:51.754]             invokeRestart <- base::invokeRestart
[10:29:51.754]             length <- base::length
[10:29:51.754]             list <- base::list
[10:29:51.754]             seq.int <- base::seq.int
[10:29:51.754]             signalCondition <- base::signalCondition
[10:29:51.754]             sys.calls <- base::sys.calls
[10:29:51.754]             `[[` <- base::`[[`
[10:29:51.754]             `+` <- base::`+`
[10:29:51.754]             `<<-` <- base::`<<-`
[10:29:51.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.754]                   3L)]
[10:29:51.754]             }
[10:29:51.754]             function(cond) {
[10:29:51.754]                 is_error <- inherits(cond, "error")
[10:29:51.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.754]                   NULL)
[10:29:51.754]                 if (is_error) {
[10:29:51.754]                   sessionInformation <- function() {
[10:29:51.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.754]                       search = base::search(), system = base::Sys.info())
[10:29:51.754]                   }
[10:29:51.754]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.754]                     cond$call), session = sessionInformation(), 
[10:29:51.754]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.754]                   signalCondition(cond)
[10:29:51.754]                 }
[10:29:51.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.754]                 "immediateCondition"))) {
[10:29:51.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.754]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.754]                   if (TRUE && !signal) {
[10:29:51.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.754]                     {
[10:29:51.754]                       inherits <- base::inherits
[10:29:51.754]                       invokeRestart <- base::invokeRestart
[10:29:51.754]                       is.null <- base::is.null
[10:29:51.754]                       muffled <- FALSE
[10:29:51.754]                       if (inherits(cond, "message")) {
[10:29:51.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.754]                         if (muffled) 
[10:29:51.754]                           invokeRestart("muffleMessage")
[10:29:51.754]                       }
[10:29:51.754]                       else if (inherits(cond, "warning")) {
[10:29:51.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.754]                         if (muffled) 
[10:29:51.754]                           invokeRestart("muffleWarning")
[10:29:51.754]                       }
[10:29:51.754]                       else if (inherits(cond, "condition")) {
[10:29:51.754]                         if (!is.null(pattern)) {
[10:29:51.754]                           computeRestarts <- base::computeRestarts
[10:29:51.754]                           grepl <- base::grepl
[10:29:51.754]                           restarts <- computeRestarts(cond)
[10:29:51.754]                           for (restart in restarts) {
[10:29:51.754]                             name <- restart$name
[10:29:51.754]                             if (is.null(name)) 
[10:29:51.754]                               next
[10:29:51.754]                             if (!grepl(pattern, name)) 
[10:29:51.754]                               next
[10:29:51.754]                             invokeRestart(restart)
[10:29:51.754]                             muffled <- TRUE
[10:29:51.754]                             break
[10:29:51.754]                           }
[10:29:51.754]                         }
[10:29:51.754]                       }
[10:29:51.754]                       invisible(muffled)
[10:29:51.754]                     }
[10:29:51.754]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.754]                   }
[10:29:51.754]                 }
[10:29:51.754]                 else {
[10:29:51.754]                   if (TRUE) {
[10:29:51.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.754]                     {
[10:29:51.754]                       inherits <- base::inherits
[10:29:51.754]                       invokeRestart <- base::invokeRestart
[10:29:51.754]                       is.null <- base::is.null
[10:29:51.754]                       muffled <- FALSE
[10:29:51.754]                       if (inherits(cond, "message")) {
[10:29:51.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.754]                         if (muffled) 
[10:29:51.754]                           invokeRestart("muffleMessage")
[10:29:51.754]                       }
[10:29:51.754]                       else if (inherits(cond, "warning")) {
[10:29:51.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.754]                         if (muffled) 
[10:29:51.754]                           invokeRestart("muffleWarning")
[10:29:51.754]                       }
[10:29:51.754]                       else if (inherits(cond, "condition")) {
[10:29:51.754]                         if (!is.null(pattern)) {
[10:29:51.754]                           computeRestarts <- base::computeRestarts
[10:29:51.754]                           grepl <- base::grepl
[10:29:51.754]                           restarts <- computeRestarts(cond)
[10:29:51.754]                           for (restart in restarts) {
[10:29:51.754]                             name <- restart$name
[10:29:51.754]                             if (is.null(name)) 
[10:29:51.754]                               next
[10:29:51.754]                             if (!grepl(pattern, name)) 
[10:29:51.754]                               next
[10:29:51.754]                             invokeRestart(restart)
[10:29:51.754]                             muffled <- TRUE
[10:29:51.754]                             break
[10:29:51.754]                           }
[10:29:51.754]                         }
[10:29:51.754]                       }
[10:29:51.754]                       invisible(muffled)
[10:29:51.754]                     }
[10:29:51.754]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.754]                   }
[10:29:51.754]                 }
[10:29:51.754]             }
[10:29:51.754]         }))
[10:29:51.754]     }, error = function(ex) {
[10:29:51.754]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.754]                 ...future.rng), started = ...future.startTime, 
[10:29:51.754]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.754]             version = "1.8"), class = "FutureResult")
[10:29:51.754]     }, finally = {
[10:29:51.754]         if (!identical(...future.workdir, getwd())) 
[10:29:51.754]             setwd(...future.workdir)
[10:29:51.754]         {
[10:29:51.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.754]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.754]             }
[10:29:51.754]             base::options(...future.oldOptions)
[10:29:51.754]             if (.Platform$OS.type == "windows") {
[10:29:51.754]                 old_names <- names(...future.oldEnvVars)
[10:29:51.754]                 envs <- base::Sys.getenv()
[10:29:51.754]                 names <- names(envs)
[10:29:51.754]                 common <- intersect(names, old_names)
[10:29:51.754]                 added <- setdiff(names, old_names)
[10:29:51.754]                 removed <- setdiff(old_names, names)
[10:29:51.754]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.754]                   envs[common]]
[10:29:51.754]                 NAMES <- toupper(changed)
[10:29:51.754]                 args <- list()
[10:29:51.754]                 for (kk in seq_along(NAMES)) {
[10:29:51.754]                   name <- changed[[kk]]
[10:29:51.754]                   NAME <- NAMES[[kk]]
[10:29:51.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.754]                     next
[10:29:51.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.754]                 }
[10:29:51.754]                 NAMES <- toupper(added)
[10:29:51.754]                 for (kk in seq_along(NAMES)) {
[10:29:51.754]                   name <- added[[kk]]
[10:29:51.754]                   NAME <- NAMES[[kk]]
[10:29:51.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.754]                     next
[10:29:51.754]                   args[[name]] <- ""
[10:29:51.754]                 }
[10:29:51.754]                 NAMES <- toupper(removed)
[10:29:51.754]                 for (kk in seq_along(NAMES)) {
[10:29:51.754]                   name <- removed[[kk]]
[10:29:51.754]                   NAME <- NAMES[[kk]]
[10:29:51.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.754]                     next
[10:29:51.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.754]                 }
[10:29:51.754]                 if (length(args) > 0) 
[10:29:51.754]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.754]             }
[10:29:51.754]             else {
[10:29:51.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.754]             }
[10:29:51.754]             {
[10:29:51.754]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.754]                   0L) {
[10:29:51.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.754]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.754]                   base::options(opts)
[10:29:51.754]                 }
[10:29:51.754]                 {
[10:29:51.754]                   {
[10:29:51.754]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.754]                     NULL
[10:29:51.754]                   }
[10:29:51.754]                   options(future.plan = NULL)
[10:29:51.754]                   if (is.na(NA_character_)) 
[10:29:51.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.754]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.754]                     .init = FALSE)
[10:29:51.754]                 }
[10:29:51.754]             }
[10:29:51.754]         }
[10:29:51.754]     })
[10:29:51.754]     if (TRUE) {
[10:29:51.754]         base::sink(type = "output", split = FALSE)
[10:29:51.754]         if (TRUE) {
[10:29:51.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.754]         }
[10:29:51.754]         else {
[10:29:51.754]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.754]         }
[10:29:51.754]         base::close(...future.stdout)
[10:29:51.754]         ...future.stdout <- NULL
[10:29:51.754]     }
[10:29:51.754]     ...future.result$conditions <- ...future.conditions
[10:29:51.754]     ...future.result$finished <- base::Sys.time()
[10:29:51.754]     ...future.result
[10:29:51.754] }
[10:29:51.757] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[10:29:51.758] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:51.758] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:51.758] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[10:29:51.758] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[10:29:51.758] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[10:29:51.759] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[10:29:51.759] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:51.759] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:51.759] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:29:51.760] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:29:51.760] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[10:29:51.760] MultisessionFuture started
[10:29:51.760] - Launch lazy future ... done
[10:29:51.760] run() for ‘MultisessionFuture’ ... done
[10:29:51.760] Created future:
[10:29:51.761] MultisessionFuture:
[10:29:51.761] Label: ‘future_apply-2’
[10:29:51.761] Expression:
[10:29:51.761] {
[10:29:51.761]     do.call(function(...) {
[10:29:51.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.761]             on.exit(options(oopts), add = TRUE)
[10:29:51.761]         }
[10:29:51.761]         {
[10:29:51.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.761]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.761]             })
[10:29:51.761]         }
[10:29:51.761]     }, args = future.call.arguments)
[10:29:51.761] }
[10:29:51.761] Lazy evaluation: FALSE
[10:29:51.761] Asynchronous evaluation: TRUE
[10:29:51.761] Local evaluation: TRUE
[10:29:51.761] Environment: R_GlobalEnv
[10:29:51.761] Capture standard output: TRUE
[10:29:51.761] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.761] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.761] Packages: <none>
[10:29:51.761] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.761] Resolved: FALSE
[10:29:51.761] Value: <not collected>
[10:29:51.761] Conditions captured: <none>
[10:29:51.761] Early signaling: FALSE
[10:29:51.761] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.761] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.773] Chunk #2 of 2 ... DONE
[10:29:51.773] Launching 2 futures (chunks) ... DONE
[10:29:51.773] Resolving 2 futures (chunks) ...
[10:29:51.773] resolve() on list ...
[10:29:51.773]  recursive: 0
[10:29:51.773]  length: 2
[10:29:51.773] 
[10:29:51.774] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.774] - Validating connection of MultisessionFuture
[10:29:51.774] - received message: FutureResult
[10:29:51.774] - Received FutureResult
[10:29:51.774] - Erased future from FutureRegistry
[10:29:51.774] result() for ClusterFuture ...
[10:29:51.775] - result already collected: FutureResult
[10:29:51.775] result() for ClusterFuture ... done
[10:29:51.775] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.775] Future #1
[10:29:51.775] result() for ClusterFuture ...
[10:29:51.775] - result already collected: FutureResult
[10:29:51.775] result() for ClusterFuture ... done
[10:29:51.775] result() for ClusterFuture ...
[10:29:51.775] - result already collected: FutureResult
[10:29:51.775] result() for ClusterFuture ... done
[10:29:51.775] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:51.776] - nx: 2
[10:29:51.776] - relay: TRUE
[10:29:51.776] - stdout: TRUE
[10:29:51.776] - signal: TRUE
[10:29:51.776] - resignal: FALSE
[10:29:51.776] - force: TRUE
[10:29:51.776] - relayed: [n=2] FALSE, FALSE
[10:29:51.776] - queued futures: [n=2] FALSE, FALSE
[10:29:51.776]  - until=1
[10:29:51.776]  - relaying element #1
[10:29:51.776] result() for ClusterFuture ...
[10:29:51.776] - result already collected: FutureResult
[10:29:51.777] result() for ClusterFuture ... done
[10:29:51.777] result() for ClusterFuture ...
[10:29:51.777] - result already collected: FutureResult
[10:29:51.777] result() for ClusterFuture ... done
[10:29:51.777] result() for ClusterFuture ...
[10:29:51.777] - result already collected: FutureResult
[10:29:51.777] result() for ClusterFuture ... done
[10:29:51.777] result() for ClusterFuture ...
[10:29:51.777] - result already collected: FutureResult
[10:29:51.777] result() for ClusterFuture ... done
[10:29:51.778] - relayed: [n=2] TRUE, FALSE
[10:29:51.778] - queued futures: [n=2] TRUE, FALSE
[10:29:51.778] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:51.778]  length: 1 (resolved future 1)
[10:29:51.802] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.803] - Validating connection of MultisessionFuture
[10:29:51.803] - received message: FutureResult
[10:29:51.803] - Received FutureResult
[10:29:51.803] - Erased future from FutureRegistry
[10:29:51.803] result() for ClusterFuture ...
[10:29:51.803] - result already collected: FutureResult
[10:29:51.803] result() for ClusterFuture ... done
[10:29:51.803] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.803] Future #2
[10:29:51.804] result() for ClusterFuture ...
[10:29:51.804] - result already collected: FutureResult
[10:29:51.804] result() for ClusterFuture ... done
[10:29:51.804] result() for ClusterFuture ...
[10:29:51.804] - result already collected: FutureResult
[10:29:51.804] result() for ClusterFuture ... done
[10:29:51.804] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:51.804] - nx: 2
[10:29:51.804] - relay: TRUE
[10:29:51.804] - stdout: TRUE
[10:29:51.804] - signal: TRUE
[10:29:51.804] - resignal: FALSE
[10:29:51.805] - force: TRUE
[10:29:51.805] - relayed: [n=2] TRUE, FALSE
[10:29:51.805] - queued futures: [n=2] TRUE, FALSE
[10:29:51.805]  - until=2
[10:29:51.805]  - relaying element #2
[10:29:51.805] result() for ClusterFuture ...
[10:29:51.805] - result already collected: FutureResult
[10:29:51.805] result() for ClusterFuture ... done
[10:29:51.805] result() for ClusterFuture ...
[10:29:51.805] - result already collected: FutureResult
[10:29:51.806] result() for ClusterFuture ... done
[10:29:51.806] result() for ClusterFuture ...
[10:29:51.806] - result already collected: FutureResult
[10:29:51.806] result() for ClusterFuture ... done
[10:29:51.806] result() for ClusterFuture ...
[10:29:51.806] - result already collected: FutureResult
[10:29:51.806] result() for ClusterFuture ... done
[10:29:51.806] - relayed: [n=2] TRUE, TRUE
[10:29:51.806] - queued futures: [n=2] TRUE, TRUE
[10:29:51.806] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:51.806]  length: 0 (resolved future 2)
[10:29:51.807] Relaying remaining futures
[10:29:51.807] signalConditionsASAP(NULL, pos=0) ...
[10:29:51.807] - nx: 2
[10:29:51.807] - relay: TRUE
[10:29:51.807] - stdout: TRUE
[10:29:51.807] - signal: TRUE
[10:29:51.807] - resignal: FALSE
[10:29:51.807] - force: TRUE
[10:29:51.807] - relayed: [n=2] TRUE, TRUE
[10:29:51.807] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:51.807] - relayed: [n=2] TRUE, TRUE
[10:29:51.808] - queued futures: [n=2] TRUE, TRUE
[10:29:51.808] signalConditionsASAP(NULL, pos=0) ... done
[10:29:51.808] resolve() on list ... DONE
[10:29:51.808] result() for ClusterFuture ...
[10:29:51.808] - result already collected: FutureResult
[10:29:51.808] result() for ClusterFuture ... done
[10:29:51.808] result() for ClusterFuture ...
[10:29:51.808] - result already collected: FutureResult
[10:29:51.808] result() for ClusterFuture ... done
[10:29:51.808] result() for ClusterFuture ...
[10:29:51.808] - result already collected: FutureResult
[10:29:51.809] result() for ClusterFuture ... done
[10:29:51.809] result() for ClusterFuture ...
[10:29:51.809] - result already collected: FutureResult
[10:29:51.809] result() for ClusterFuture ... done
[10:29:51.809]  - Number of value chunks collected: 2
[10:29:51.809] Resolving 2 futures (chunks) ... DONE
[10:29:51.809] Reducing values from 2 chunks ...
[10:29:51.809]  - Number of values collected after concatenation: 6
[10:29:51.809]  - Number of values expected: 6
[10:29:51.809] Reducing values from 2 chunks ... DONE
[10:29:51.810] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:29:51.810] getGlobalsAndPackagesXApply() ...
[10:29:51.810]  - future.globals: TRUE
[10:29:51.810] getGlobalsAndPackages() ...
[10:29:51.810] Searching for globals...
[10:29:51.812] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:29:51.812] Searching for globals ... DONE
[10:29:51.812] Resolving globals: FALSE
[10:29:51.812] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[10:29:51.813] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[10:29:51.813] - globals: [1] ‘FUN’
[10:29:51.813] 
[10:29:51.813] getGlobalsAndPackages() ... DONE
[10:29:51.813]  - globals found/used: [n=1] ‘FUN’
[10:29:51.813]  - needed namespaces: [n=0] 
[10:29:51.813] Finding globals ... DONE
[10:29:51.813]  - use_args: TRUE
[10:29:51.813]  - Getting '...' globals ...
[10:29:51.814] resolve() on list ...
[10:29:51.814]  recursive: 0
[10:29:51.814]  length: 1
[10:29:51.814]  elements: ‘...’
[10:29:51.814]  length: 0 (resolved future 1)
[10:29:51.814] resolve() on list ... DONE
[10:29:51.814]    - '...' content: [n=0] 
[10:29:51.814] List of 1
[10:29:51.814]  $ ...: list()
[10:29:51.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.814]  - attr(*, "where")=List of 1
[10:29:51.814]   ..$ ...:<environment: 0x56189fbc5730> 
[10:29:51.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.814]  - attr(*, "resolved")= logi TRUE
[10:29:51.814]  - attr(*, "total_size")= num NA
[10:29:51.817]  - Getting '...' globals ... DONE
[10:29:51.817] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:51.817] List of 2
[10:29:51.817]  $ ...future.FUN:function (x)  
[10:29:51.817]  $ ...          : list()
[10:29:51.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.817]  - attr(*, "where")=List of 2
[10:29:51.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:51.817]   ..$ ...          :<environment: 0x56189fbc5730> 
[10:29:51.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.817]  - attr(*, "resolved")= logi FALSE
[10:29:51.817]  - attr(*, "total_size")= num 1768
[10:29:51.820] Packages to be attached in all futures: [n=0] 
[10:29:51.820] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.823] future_lapply() ...
[10:29:51.827] Number of chunks: 2
[10:29:51.827] getGlobalsAndPackagesXApply() ...
[10:29:51.827]  - future.globals: <name-value list> with names ‘list()’
[10:29:51.828]  - use_args: TRUE
[10:29:51.828] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:51.828] List of 2
[10:29:51.828]  $ ...          : list()
[10:29:51.828]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.828]  $ ...future.FUN:function (x)  
[10:29:51.828]  - attr(*, "where")=List of 2
[10:29:51.828]   ..$ ...          :<environment: 0x56189fbc5730> 
[10:29:51.828]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:29:51.828]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.828]  - attr(*, "resolved")= logi FALSE
[10:29:51.828]  - attr(*, "total_size")= num NA
[10:29:51.831] Packages to be attached in all futures: [n=0] 
[10:29:51.831] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.831] Number of futures (= number of chunks): 2
[10:29:51.831] Launching 2 futures (chunks) ...
[10:29:51.831] Chunk #1 of 2 ...
[10:29:51.831]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.831]  - seeds: <none>
[10:29:51.831]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.832] getGlobalsAndPackages() ...
[10:29:51.832] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.832] Resolving globals: FALSE
[10:29:51.832] Tweak future expression to call with '...' arguments ...
[10:29:51.832] {
[10:29:51.832]     do.call(function(...) {
[10:29:51.832]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.832]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.832]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.832]             on.exit(options(oopts), add = TRUE)
[10:29:51.832]         }
[10:29:51.832]         {
[10:29:51.832]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.832]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.832]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.832]             })
[10:29:51.832]         }
[10:29:51.832]     }, args = future.call.arguments)
[10:29:51.832] }
[10:29:51.832] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.833] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.833] 
[10:29:51.833] getGlobalsAndPackages() ... DONE
[10:29:51.833] run() for ‘Future’ ...
[10:29:51.833] - state: ‘created’
[10:29:51.833] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.847] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.847]   - Field: ‘node’
[10:29:51.847]   - Field: ‘label’
[10:29:51.847]   - Field: ‘local’
[10:29:51.847]   - Field: ‘owner’
[10:29:51.847]   - Field: ‘envir’
[10:29:51.848]   - Field: ‘workers’
[10:29:51.848]   - Field: ‘packages’
[10:29:51.848]   - Field: ‘gc’
[10:29:51.848]   - Field: ‘conditions’
[10:29:51.848]   - Field: ‘persistent’
[10:29:51.848]   - Field: ‘expr’
[10:29:51.848]   - Field: ‘uuid’
[10:29:51.848]   - Field: ‘seed’
[10:29:51.848]   - Field: ‘version’
[10:29:51.848]   - Field: ‘result’
[10:29:51.848]   - Field: ‘asynchronous’
[10:29:51.849]   - Field: ‘calls’
[10:29:51.849]   - Field: ‘globals’
[10:29:51.849]   - Field: ‘stdout’
[10:29:51.849]   - Field: ‘earlySignal’
[10:29:51.849]   - Field: ‘lazy’
[10:29:51.849]   - Field: ‘state’
[10:29:51.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.849] - Launch lazy future ...
[10:29:51.850] Packages needed by the future expression (n = 0): <none>
[10:29:51.850] Packages needed by future strategies (n = 0): <none>
[10:29:51.850] {
[10:29:51.850]     {
[10:29:51.850]         {
[10:29:51.850]             ...future.startTime <- base::Sys.time()
[10:29:51.850]             {
[10:29:51.850]                 {
[10:29:51.850]                   {
[10:29:51.850]                     {
[10:29:51.850]                       base::local({
[10:29:51.850]                         has_future <- base::requireNamespace("future", 
[10:29:51.850]                           quietly = TRUE)
[10:29:51.850]                         if (has_future) {
[10:29:51.850]                           ns <- base::getNamespace("future")
[10:29:51.850]                           version <- ns[[".package"]][["version"]]
[10:29:51.850]                           if (is.null(version)) 
[10:29:51.850]                             version <- utils::packageVersion("future")
[10:29:51.850]                         }
[10:29:51.850]                         else {
[10:29:51.850]                           version <- NULL
[10:29:51.850]                         }
[10:29:51.850]                         if (!has_future || version < "1.8.0") {
[10:29:51.850]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.850]                             "", base::R.version$version.string), 
[10:29:51.850]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:51.850]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:51.850]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.850]                               "release", "version")], collapse = " "), 
[10:29:51.850]                             hostname = base::Sys.info()[["nodename"]])
[10:29:51.850]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.850]                             info)
[10:29:51.850]                           info <- base::paste(info, collapse = "; ")
[10:29:51.850]                           if (!has_future) {
[10:29:51.850]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.850]                               info)
[10:29:51.850]                           }
[10:29:51.850]                           else {
[10:29:51.850]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.850]                               info, version)
[10:29:51.850]                           }
[10:29:51.850]                           base::stop(msg)
[10:29:51.850]                         }
[10:29:51.850]                       })
[10:29:51.850]                     }
[10:29:51.850]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.850]                     base::options(mc.cores = 1L)
[10:29:51.850]                   }
[10:29:51.850]                   ...future.strategy.old <- future::plan("list")
[10:29:51.850]                   options(future.plan = NULL)
[10:29:51.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.850]                 }
[10:29:51.850]                 ...future.workdir <- getwd()
[10:29:51.850]             }
[10:29:51.850]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.850]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.850]         }
[10:29:51.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.850]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.850]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.850]             base::names(...future.oldOptions))
[10:29:51.850]     }
[10:29:51.850]     if (FALSE) {
[10:29:51.850]     }
[10:29:51.850]     else {
[10:29:51.850]         if (TRUE) {
[10:29:51.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.850]                 open = "w")
[10:29:51.850]         }
[10:29:51.850]         else {
[10:29:51.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.850]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.850]         }
[10:29:51.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.850]             base::sink(type = "output", split = FALSE)
[10:29:51.850]             base::close(...future.stdout)
[10:29:51.850]         }, add = TRUE)
[10:29:51.850]     }
[10:29:51.850]     ...future.frame <- base::sys.nframe()
[10:29:51.850]     ...future.conditions <- base::list()
[10:29:51.850]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.850]     if (FALSE) {
[10:29:51.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.850]     }
[10:29:51.850]     ...future.result <- base::tryCatch({
[10:29:51.850]         base::withCallingHandlers({
[10:29:51.850]             ...future.value <- base::withVisible(base::local({
[10:29:51.850]                 ...future.makeSendCondition <- base::local({
[10:29:51.850]                   sendCondition <- NULL
[10:29:51.850]                   function(frame = 1L) {
[10:29:51.850]                     if (is.function(sendCondition)) 
[10:29:51.850]                       return(sendCondition)
[10:29:51.850]                     ns <- getNamespace("parallel")
[10:29:51.850]                     if (exists("sendData", mode = "function", 
[10:29:51.850]                       envir = ns)) {
[10:29:51.850]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.850]                         envir = ns)
[10:29:51.850]                       envir <- sys.frame(frame)
[10:29:51.850]                       master <- NULL
[10:29:51.850]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.850]                         !identical(envir, emptyenv())) {
[10:29:51.850]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.850]                           inherits = FALSE)) {
[10:29:51.850]                           master <- get("master", mode = "list", 
[10:29:51.850]                             envir = envir, inherits = FALSE)
[10:29:51.850]                           if (inherits(master, c("SOCKnode", 
[10:29:51.850]                             "SOCK0node"))) {
[10:29:51.850]                             sendCondition <<- function(cond) {
[10:29:51.850]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.850]                                 success = TRUE)
[10:29:51.850]                               parallel_sendData(master, data)
[10:29:51.850]                             }
[10:29:51.850]                             return(sendCondition)
[10:29:51.850]                           }
[10:29:51.850]                         }
[10:29:51.850]                         frame <- frame + 1L
[10:29:51.850]                         envir <- sys.frame(frame)
[10:29:51.850]                       }
[10:29:51.850]                     }
[10:29:51.850]                     sendCondition <<- function(cond) NULL
[10:29:51.850]                   }
[10:29:51.850]                 })
[10:29:51.850]                 withCallingHandlers({
[10:29:51.850]                   {
[10:29:51.850]                     do.call(function(...) {
[10:29:51.850]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.850]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.850]                         ...future.globals.maxSize)) {
[10:29:51.850]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.850]                         on.exit(options(oopts), add = TRUE)
[10:29:51.850]                       }
[10:29:51.850]                       {
[10:29:51.850]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.850]                           FUN = function(jj) {
[10:29:51.850]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.850]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.850]                           })
[10:29:51.850]                       }
[10:29:51.850]                     }, args = future.call.arguments)
[10:29:51.850]                   }
[10:29:51.850]                 }, immediateCondition = function(cond) {
[10:29:51.850]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.850]                   sendCondition(cond)
[10:29:51.850]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.850]                   {
[10:29:51.850]                     inherits <- base::inherits
[10:29:51.850]                     invokeRestart <- base::invokeRestart
[10:29:51.850]                     is.null <- base::is.null
[10:29:51.850]                     muffled <- FALSE
[10:29:51.850]                     if (inherits(cond, "message")) {
[10:29:51.850]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.850]                       if (muffled) 
[10:29:51.850]                         invokeRestart("muffleMessage")
[10:29:51.850]                     }
[10:29:51.850]                     else if (inherits(cond, "warning")) {
[10:29:51.850]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.850]                       if (muffled) 
[10:29:51.850]                         invokeRestart("muffleWarning")
[10:29:51.850]                     }
[10:29:51.850]                     else if (inherits(cond, "condition")) {
[10:29:51.850]                       if (!is.null(pattern)) {
[10:29:51.850]                         computeRestarts <- base::computeRestarts
[10:29:51.850]                         grepl <- base::grepl
[10:29:51.850]                         restarts <- computeRestarts(cond)
[10:29:51.850]                         for (restart in restarts) {
[10:29:51.850]                           name <- restart$name
[10:29:51.850]                           if (is.null(name)) 
[10:29:51.850]                             next
[10:29:51.850]                           if (!grepl(pattern, name)) 
[10:29:51.850]                             next
[10:29:51.850]                           invokeRestart(restart)
[10:29:51.850]                           muffled <- TRUE
[10:29:51.850]                           break
[10:29:51.850]                         }
[10:29:51.850]                       }
[10:29:51.850]                     }
[10:29:51.850]                     invisible(muffled)
[10:29:51.850]                   }
[10:29:51.850]                   muffleCondition(cond)
[10:29:51.850]                 })
[10:29:51.850]             }))
[10:29:51.850]             future::FutureResult(value = ...future.value$value, 
[10:29:51.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.850]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.850]                     ...future.globalenv.names))
[10:29:51.850]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.850]         }, condition = base::local({
[10:29:51.850]             c <- base::c
[10:29:51.850]             inherits <- base::inherits
[10:29:51.850]             invokeRestart <- base::invokeRestart
[10:29:51.850]             length <- base::length
[10:29:51.850]             list <- base::list
[10:29:51.850]             seq.int <- base::seq.int
[10:29:51.850]             signalCondition <- base::signalCondition
[10:29:51.850]             sys.calls <- base::sys.calls
[10:29:51.850]             `[[` <- base::`[[`
[10:29:51.850]             `+` <- base::`+`
[10:29:51.850]             `<<-` <- base::`<<-`
[10:29:51.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.850]                   3L)]
[10:29:51.850]             }
[10:29:51.850]             function(cond) {
[10:29:51.850]                 is_error <- inherits(cond, "error")
[10:29:51.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.850]                   NULL)
[10:29:51.850]                 if (is_error) {
[10:29:51.850]                   sessionInformation <- function() {
[10:29:51.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.850]                       search = base::search(), system = base::Sys.info())
[10:29:51.850]                   }
[10:29:51.850]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.850]                     cond$call), session = sessionInformation(), 
[10:29:51.850]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.850]                   signalCondition(cond)
[10:29:51.850]                 }
[10:29:51.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.850]                 "immediateCondition"))) {
[10:29:51.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.850]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.850]                   if (TRUE && !signal) {
[10:29:51.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.850]                     {
[10:29:51.850]                       inherits <- base::inherits
[10:29:51.850]                       invokeRestart <- base::invokeRestart
[10:29:51.850]                       is.null <- base::is.null
[10:29:51.850]                       muffled <- FALSE
[10:29:51.850]                       if (inherits(cond, "message")) {
[10:29:51.850]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.850]                         if (muffled) 
[10:29:51.850]                           invokeRestart("muffleMessage")
[10:29:51.850]                       }
[10:29:51.850]                       else if (inherits(cond, "warning")) {
[10:29:51.850]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.850]                         if (muffled) 
[10:29:51.850]                           invokeRestart("muffleWarning")
[10:29:51.850]                       }
[10:29:51.850]                       else if (inherits(cond, "condition")) {
[10:29:51.850]                         if (!is.null(pattern)) {
[10:29:51.850]                           computeRestarts <- base::computeRestarts
[10:29:51.850]                           grepl <- base::grepl
[10:29:51.850]                           restarts <- computeRestarts(cond)
[10:29:51.850]                           for (restart in restarts) {
[10:29:51.850]                             name <- restart$name
[10:29:51.850]                             if (is.null(name)) 
[10:29:51.850]                               next
[10:29:51.850]                             if (!grepl(pattern, name)) 
[10:29:51.850]                               next
[10:29:51.850]                             invokeRestart(restart)
[10:29:51.850]                             muffled <- TRUE
[10:29:51.850]                             break
[10:29:51.850]                           }
[10:29:51.850]                         }
[10:29:51.850]                       }
[10:29:51.850]                       invisible(muffled)
[10:29:51.850]                     }
[10:29:51.850]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.850]                   }
[10:29:51.850]                 }
[10:29:51.850]                 else {
[10:29:51.850]                   if (TRUE) {
[10:29:51.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.850]                     {
[10:29:51.850]                       inherits <- base::inherits
[10:29:51.850]                       invokeRestart <- base::invokeRestart
[10:29:51.850]                       is.null <- base::is.null
[10:29:51.850]                       muffled <- FALSE
[10:29:51.850]                       if (inherits(cond, "message")) {
[10:29:51.850]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.850]                         if (muffled) 
[10:29:51.850]                           invokeRestart("muffleMessage")
[10:29:51.850]                       }
[10:29:51.850]                       else if (inherits(cond, "warning")) {
[10:29:51.850]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.850]                         if (muffled) 
[10:29:51.850]                           invokeRestart("muffleWarning")
[10:29:51.850]                       }
[10:29:51.850]                       else if (inherits(cond, "condition")) {
[10:29:51.850]                         if (!is.null(pattern)) {
[10:29:51.850]                           computeRestarts <- base::computeRestarts
[10:29:51.850]                           grepl <- base::grepl
[10:29:51.850]                           restarts <- computeRestarts(cond)
[10:29:51.850]                           for (restart in restarts) {
[10:29:51.850]                             name <- restart$name
[10:29:51.850]                             if (is.null(name)) 
[10:29:51.850]                               next
[10:29:51.850]                             if (!grepl(pattern, name)) 
[10:29:51.850]                               next
[10:29:51.850]                             invokeRestart(restart)
[10:29:51.850]                             muffled <- TRUE
[10:29:51.850]                             break
[10:29:51.850]                           }
[10:29:51.850]                         }
[10:29:51.850]                       }
[10:29:51.850]                       invisible(muffled)
[10:29:51.850]                     }
[10:29:51.850]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.850]                   }
[10:29:51.850]                 }
[10:29:51.850]             }
[10:29:51.850]         }))
[10:29:51.850]     }, error = function(ex) {
[10:29:51.850]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.850]                 ...future.rng), started = ...future.startTime, 
[10:29:51.850]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.850]             version = "1.8"), class = "FutureResult")
[10:29:51.850]     }, finally = {
[10:29:51.850]         if (!identical(...future.workdir, getwd())) 
[10:29:51.850]             setwd(...future.workdir)
[10:29:51.850]         {
[10:29:51.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.850]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.850]             }
[10:29:51.850]             base::options(...future.oldOptions)
[10:29:51.850]             if (.Platform$OS.type == "windows") {
[10:29:51.850]                 old_names <- names(...future.oldEnvVars)
[10:29:51.850]                 envs <- base::Sys.getenv()
[10:29:51.850]                 names <- names(envs)
[10:29:51.850]                 common <- intersect(names, old_names)
[10:29:51.850]                 added <- setdiff(names, old_names)
[10:29:51.850]                 removed <- setdiff(old_names, names)
[10:29:51.850]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.850]                   envs[common]]
[10:29:51.850]                 NAMES <- toupper(changed)
[10:29:51.850]                 args <- list()
[10:29:51.850]                 for (kk in seq_along(NAMES)) {
[10:29:51.850]                   name <- changed[[kk]]
[10:29:51.850]                   NAME <- NAMES[[kk]]
[10:29:51.850]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.850]                     next
[10:29:51.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.850]                 }
[10:29:51.850]                 NAMES <- toupper(added)
[10:29:51.850]                 for (kk in seq_along(NAMES)) {
[10:29:51.850]                   name <- added[[kk]]
[10:29:51.850]                   NAME <- NAMES[[kk]]
[10:29:51.850]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.850]                     next
[10:29:51.850]                   args[[name]] <- ""
[10:29:51.850]                 }
[10:29:51.850]                 NAMES <- toupper(removed)
[10:29:51.850]                 for (kk in seq_along(NAMES)) {
[10:29:51.850]                   name <- removed[[kk]]
[10:29:51.850]                   NAME <- NAMES[[kk]]
[10:29:51.850]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.850]                     next
[10:29:51.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.850]                 }
[10:29:51.850]                 if (length(args) > 0) 
[10:29:51.850]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.850]             }
[10:29:51.850]             else {
[10:29:51.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.850]             }
[10:29:51.850]             {
[10:29:51.850]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.850]                   0L) {
[10:29:51.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.850]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.850]                   base::options(opts)
[10:29:51.850]                 }
[10:29:51.850]                 {
[10:29:51.850]                   {
[10:29:51.850]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.850]                     NULL
[10:29:51.850]                   }
[10:29:51.850]                   options(future.plan = NULL)
[10:29:51.850]                   if (is.na(NA_character_)) 
[10:29:51.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.850]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.850]                     .init = FALSE)
[10:29:51.850]                 }
[10:29:51.850]             }
[10:29:51.850]         }
[10:29:51.850]     })
[10:29:51.850]     if (TRUE) {
[10:29:51.850]         base::sink(type = "output", split = FALSE)
[10:29:51.850]         if (TRUE) {
[10:29:51.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.850]         }
[10:29:51.850]         else {
[10:29:51.850]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.850]         }
[10:29:51.850]         base::close(...future.stdout)
[10:29:51.850]         ...future.stdout <- NULL
[10:29:51.850]     }
[10:29:51.850]     ...future.result$conditions <- ...future.conditions
[10:29:51.850]     ...future.result$finished <- base::Sys.time()
[10:29:51.850]     ...future.result
[10:29:51.850] }
[10:29:51.853] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[10:29:51.853] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:51.854] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.854] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[10:29:51.854] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[10:29:51.854] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[10:29:51.855] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[10:29:51.855] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:51.855] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.855] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:51.855] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:51.855] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[10:29:51.856] MultisessionFuture started
[10:29:51.856] - Launch lazy future ... done
[10:29:51.856] run() for ‘MultisessionFuture’ ... done
[10:29:51.856] Created future:
[10:29:51.856] MultisessionFuture:
[10:29:51.856] Label: ‘future_apply-1’
[10:29:51.856] Expression:
[10:29:51.856] {
[10:29:51.856]     do.call(function(...) {
[10:29:51.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.856]             on.exit(options(oopts), add = TRUE)
[10:29:51.856]         }
[10:29:51.856]         {
[10:29:51.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.856]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.856]             })
[10:29:51.856]         }
[10:29:51.856]     }, args = future.call.arguments)
[10:29:51.856] }
[10:29:51.856] Lazy evaluation: FALSE
[10:29:51.856] Asynchronous evaluation: TRUE
[10:29:51.856] Local evaluation: TRUE
[10:29:51.856] Environment: R_GlobalEnv
[10:29:51.856] Capture standard output: TRUE
[10:29:51.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.856] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.856] Packages: <none>
[10:29:51.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.856] Resolved: FALSE
[10:29:51.856] Value: <not collected>
[10:29:51.856] Conditions captured: <none>
[10:29:51.856] Early signaling: FALSE
[10:29:51.856] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.856] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.868] Chunk #1 of 2 ... DONE
[10:29:51.868] Chunk #2 of 2 ...
[10:29:51.868]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.868]  - seeds: <none>
[10:29:51.868]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.868] getGlobalsAndPackages() ...
[10:29:51.869] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.869] Resolving globals: FALSE
[10:29:51.869] Tweak future expression to call with '...' arguments ...
[10:29:51.869] {
[10:29:51.869]     do.call(function(...) {
[10:29:51.869]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.869]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.869]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.869]             on.exit(options(oopts), add = TRUE)
[10:29:51.869]         }
[10:29:51.869]         {
[10:29:51.869]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.869]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.869]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.869]             })
[10:29:51.869]         }
[10:29:51.869]     }, args = future.call.arguments)
[10:29:51.869] }
[10:29:51.869] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.870] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.870] 
[10:29:51.870] getGlobalsAndPackages() ... DONE
[10:29:51.870] run() for ‘Future’ ...
[10:29:51.870] - state: ‘created’
[10:29:51.870] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.884] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.884]   - Field: ‘node’
[10:29:51.884]   - Field: ‘label’
[10:29:51.884]   - Field: ‘local’
[10:29:51.884]   - Field: ‘owner’
[10:29:51.885]   - Field: ‘envir’
[10:29:51.885]   - Field: ‘workers’
[10:29:51.885]   - Field: ‘packages’
[10:29:51.885]   - Field: ‘gc’
[10:29:51.885]   - Field: ‘conditions’
[10:29:51.885]   - Field: ‘persistent’
[10:29:51.885]   - Field: ‘expr’
[10:29:51.885]   - Field: ‘uuid’
[10:29:51.885]   - Field: ‘seed’
[10:29:51.885]   - Field: ‘version’
[10:29:51.886]   - Field: ‘result’
[10:29:51.886]   - Field: ‘asynchronous’
[10:29:51.886]   - Field: ‘calls’
[10:29:51.886]   - Field: ‘globals’
[10:29:51.886]   - Field: ‘stdout’
[10:29:51.886]   - Field: ‘earlySignal’
[10:29:51.886]   - Field: ‘lazy’
[10:29:51.886]   - Field: ‘state’
[10:29:51.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.886] - Launch lazy future ...
[10:29:51.887] Packages needed by the future expression (n = 0): <none>
[10:29:51.887] Packages needed by future strategies (n = 0): <none>
[10:29:51.887] {
[10:29:51.887]     {
[10:29:51.887]         {
[10:29:51.887]             ...future.startTime <- base::Sys.time()
[10:29:51.887]             {
[10:29:51.887]                 {
[10:29:51.887]                   {
[10:29:51.887]                     {
[10:29:51.887]                       base::local({
[10:29:51.887]                         has_future <- base::requireNamespace("future", 
[10:29:51.887]                           quietly = TRUE)
[10:29:51.887]                         if (has_future) {
[10:29:51.887]                           ns <- base::getNamespace("future")
[10:29:51.887]                           version <- ns[[".package"]][["version"]]
[10:29:51.887]                           if (is.null(version)) 
[10:29:51.887]                             version <- utils::packageVersion("future")
[10:29:51.887]                         }
[10:29:51.887]                         else {
[10:29:51.887]                           version <- NULL
[10:29:51.887]                         }
[10:29:51.887]                         if (!has_future || version < "1.8.0") {
[10:29:51.887]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.887]                             "", base::R.version$version.string), 
[10:29:51.887]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:51.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:51.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.887]                               "release", "version")], collapse = " "), 
[10:29:51.887]                             hostname = base::Sys.info()[["nodename"]])
[10:29:51.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.887]                             info)
[10:29:51.887]                           info <- base::paste(info, collapse = "; ")
[10:29:51.887]                           if (!has_future) {
[10:29:51.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.887]                               info)
[10:29:51.887]                           }
[10:29:51.887]                           else {
[10:29:51.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.887]                               info, version)
[10:29:51.887]                           }
[10:29:51.887]                           base::stop(msg)
[10:29:51.887]                         }
[10:29:51.887]                       })
[10:29:51.887]                     }
[10:29:51.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.887]                     base::options(mc.cores = 1L)
[10:29:51.887]                   }
[10:29:51.887]                   ...future.strategy.old <- future::plan("list")
[10:29:51.887]                   options(future.plan = NULL)
[10:29:51.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.887]                 }
[10:29:51.887]                 ...future.workdir <- getwd()
[10:29:51.887]             }
[10:29:51.887]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.887]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.887]         }
[10:29:51.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.887]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.887]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.887]             base::names(...future.oldOptions))
[10:29:51.887]     }
[10:29:51.887]     if (FALSE) {
[10:29:51.887]     }
[10:29:51.887]     else {
[10:29:51.887]         if (TRUE) {
[10:29:51.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.887]                 open = "w")
[10:29:51.887]         }
[10:29:51.887]         else {
[10:29:51.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.887]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.887]         }
[10:29:51.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.887]             base::sink(type = "output", split = FALSE)
[10:29:51.887]             base::close(...future.stdout)
[10:29:51.887]         }, add = TRUE)
[10:29:51.887]     }
[10:29:51.887]     ...future.frame <- base::sys.nframe()
[10:29:51.887]     ...future.conditions <- base::list()
[10:29:51.887]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.887]     if (FALSE) {
[10:29:51.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.887]     }
[10:29:51.887]     ...future.result <- base::tryCatch({
[10:29:51.887]         base::withCallingHandlers({
[10:29:51.887]             ...future.value <- base::withVisible(base::local({
[10:29:51.887]                 ...future.makeSendCondition <- base::local({
[10:29:51.887]                   sendCondition <- NULL
[10:29:51.887]                   function(frame = 1L) {
[10:29:51.887]                     if (is.function(sendCondition)) 
[10:29:51.887]                       return(sendCondition)
[10:29:51.887]                     ns <- getNamespace("parallel")
[10:29:51.887]                     if (exists("sendData", mode = "function", 
[10:29:51.887]                       envir = ns)) {
[10:29:51.887]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.887]                         envir = ns)
[10:29:51.887]                       envir <- sys.frame(frame)
[10:29:51.887]                       master <- NULL
[10:29:51.887]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.887]                         !identical(envir, emptyenv())) {
[10:29:51.887]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.887]                           inherits = FALSE)) {
[10:29:51.887]                           master <- get("master", mode = "list", 
[10:29:51.887]                             envir = envir, inherits = FALSE)
[10:29:51.887]                           if (inherits(master, c("SOCKnode", 
[10:29:51.887]                             "SOCK0node"))) {
[10:29:51.887]                             sendCondition <<- function(cond) {
[10:29:51.887]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.887]                                 success = TRUE)
[10:29:51.887]                               parallel_sendData(master, data)
[10:29:51.887]                             }
[10:29:51.887]                             return(sendCondition)
[10:29:51.887]                           }
[10:29:51.887]                         }
[10:29:51.887]                         frame <- frame + 1L
[10:29:51.887]                         envir <- sys.frame(frame)
[10:29:51.887]                       }
[10:29:51.887]                     }
[10:29:51.887]                     sendCondition <<- function(cond) NULL
[10:29:51.887]                   }
[10:29:51.887]                 })
[10:29:51.887]                 withCallingHandlers({
[10:29:51.887]                   {
[10:29:51.887]                     do.call(function(...) {
[10:29:51.887]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.887]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.887]                         ...future.globals.maxSize)) {
[10:29:51.887]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.887]                         on.exit(options(oopts), add = TRUE)
[10:29:51.887]                       }
[10:29:51.887]                       {
[10:29:51.887]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.887]                           FUN = function(jj) {
[10:29:51.887]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.887]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.887]                           })
[10:29:51.887]                       }
[10:29:51.887]                     }, args = future.call.arguments)
[10:29:51.887]                   }
[10:29:51.887]                 }, immediateCondition = function(cond) {
[10:29:51.887]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.887]                   sendCondition(cond)
[10:29:51.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.887]                   {
[10:29:51.887]                     inherits <- base::inherits
[10:29:51.887]                     invokeRestart <- base::invokeRestart
[10:29:51.887]                     is.null <- base::is.null
[10:29:51.887]                     muffled <- FALSE
[10:29:51.887]                     if (inherits(cond, "message")) {
[10:29:51.887]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.887]                       if (muffled) 
[10:29:51.887]                         invokeRestart("muffleMessage")
[10:29:51.887]                     }
[10:29:51.887]                     else if (inherits(cond, "warning")) {
[10:29:51.887]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.887]                       if (muffled) 
[10:29:51.887]                         invokeRestart("muffleWarning")
[10:29:51.887]                     }
[10:29:51.887]                     else if (inherits(cond, "condition")) {
[10:29:51.887]                       if (!is.null(pattern)) {
[10:29:51.887]                         computeRestarts <- base::computeRestarts
[10:29:51.887]                         grepl <- base::grepl
[10:29:51.887]                         restarts <- computeRestarts(cond)
[10:29:51.887]                         for (restart in restarts) {
[10:29:51.887]                           name <- restart$name
[10:29:51.887]                           if (is.null(name)) 
[10:29:51.887]                             next
[10:29:51.887]                           if (!grepl(pattern, name)) 
[10:29:51.887]                             next
[10:29:51.887]                           invokeRestart(restart)
[10:29:51.887]                           muffled <- TRUE
[10:29:51.887]                           break
[10:29:51.887]                         }
[10:29:51.887]                       }
[10:29:51.887]                     }
[10:29:51.887]                     invisible(muffled)
[10:29:51.887]                   }
[10:29:51.887]                   muffleCondition(cond)
[10:29:51.887]                 })
[10:29:51.887]             }))
[10:29:51.887]             future::FutureResult(value = ...future.value$value, 
[10:29:51.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.887]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.887]                     ...future.globalenv.names))
[10:29:51.887]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.887]         }, condition = base::local({
[10:29:51.887]             c <- base::c
[10:29:51.887]             inherits <- base::inherits
[10:29:51.887]             invokeRestart <- base::invokeRestart
[10:29:51.887]             length <- base::length
[10:29:51.887]             list <- base::list
[10:29:51.887]             seq.int <- base::seq.int
[10:29:51.887]             signalCondition <- base::signalCondition
[10:29:51.887]             sys.calls <- base::sys.calls
[10:29:51.887]             `[[` <- base::`[[`
[10:29:51.887]             `+` <- base::`+`
[10:29:51.887]             `<<-` <- base::`<<-`
[10:29:51.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.887]                   3L)]
[10:29:51.887]             }
[10:29:51.887]             function(cond) {
[10:29:51.887]                 is_error <- inherits(cond, "error")
[10:29:51.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.887]                   NULL)
[10:29:51.887]                 if (is_error) {
[10:29:51.887]                   sessionInformation <- function() {
[10:29:51.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.887]                       search = base::search(), system = base::Sys.info())
[10:29:51.887]                   }
[10:29:51.887]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.887]                     cond$call), session = sessionInformation(), 
[10:29:51.887]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.887]                   signalCondition(cond)
[10:29:51.887]                 }
[10:29:51.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.887]                 "immediateCondition"))) {
[10:29:51.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.887]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.887]                   if (TRUE && !signal) {
[10:29:51.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.887]                     {
[10:29:51.887]                       inherits <- base::inherits
[10:29:51.887]                       invokeRestart <- base::invokeRestart
[10:29:51.887]                       is.null <- base::is.null
[10:29:51.887]                       muffled <- FALSE
[10:29:51.887]                       if (inherits(cond, "message")) {
[10:29:51.887]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.887]                         if (muffled) 
[10:29:51.887]                           invokeRestart("muffleMessage")
[10:29:51.887]                       }
[10:29:51.887]                       else if (inherits(cond, "warning")) {
[10:29:51.887]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.887]                         if (muffled) 
[10:29:51.887]                           invokeRestart("muffleWarning")
[10:29:51.887]                       }
[10:29:51.887]                       else if (inherits(cond, "condition")) {
[10:29:51.887]                         if (!is.null(pattern)) {
[10:29:51.887]                           computeRestarts <- base::computeRestarts
[10:29:51.887]                           grepl <- base::grepl
[10:29:51.887]                           restarts <- computeRestarts(cond)
[10:29:51.887]                           for (restart in restarts) {
[10:29:51.887]                             name <- restart$name
[10:29:51.887]                             if (is.null(name)) 
[10:29:51.887]                               next
[10:29:51.887]                             if (!grepl(pattern, name)) 
[10:29:51.887]                               next
[10:29:51.887]                             invokeRestart(restart)
[10:29:51.887]                             muffled <- TRUE
[10:29:51.887]                             break
[10:29:51.887]                           }
[10:29:51.887]                         }
[10:29:51.887]                       }
[10:29:51.887]                       invisible(muffled)
[10:29:51.887]                     }
[10:29:51.887]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.887]                   }
[10:29:51.887]                 }
[10:29:51.887]                 else {
[10:29:51.887]                   if (TRUE) {
[10:29:51.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.887]                     {
[10:29:51.887]                       inherits <- base::inherits
[10:29:51.887]                       invokeRestart <- base::invokeRestart
[10:29:51.887]                       is.null <- base::is.null
[10:29:51.887]                       muffled <- FALSE
[10:29:51.887]                       if (inherits(cond, "message")) {
[10:29:51.887]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.887]                         if (muffled) 
[10:29:51.887]                           invokeRestart("muffleMessage")
[10:29:51.887]                       }
[10:29:51.887]                       else if (inherits(cond, "warning")) {
[10:29:51.887]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.887]                         if (muffled) 
[10:29:51.887]                           invokeRestart("muffleWarning")
[10:29:51.887]                       }
[10:29:51.887]                       else if (inherits(cond, "condition")) {
[10:29:51.887]                         if (!is.null(pattern)) {
[10:29:51.887]                           computeRestarts <- base::computeRestarts
[10:29:51.887]                           grepl <- base::grepl
[10:29:51.887]                           restarts <- computeRestarts(cond)
[10:29:51.887]                           for (restart in restarts) {
[10:29:51.887]                             name <- restart$name
[10:29:51.887]                             if (is.null(name)) 
[10:29:51.887]                               next
[10:29:51.887]                             if (!grepl(pattern, name)) 
[10:29:51.887]                               next
[10:29:51.887]                             invokeRestart(restart)
[10:29:51.887]                             muffled <- TRUE
[10:29:51.887]                             break
[10:29:51.887]                           }
[10:29:51.887]                         }
[10:29:51.887]                       }
[10:29:51.887]                       invisible(muffled)
[10:29:51.887]                     }
[10:29:51.887]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.887]                   }
[10:29:51.887]                 }
[10:29:51.887]             }
[10:29:51.887]         }))
[10:29:51.887]     }, error = function(ex) {
[10:29:51.887]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.887]                 ...future.rng), started = ...future.startTime, 
[10:29:51.887]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.887]             version = "1.8"), class = "FutureResult")
[10:29:51.887]     }, finally = {
[10:29:51.887]         if (!identical(...future.workdir, getwd())) 
[10:29:51.887]             setwd(...future.workdir)
[10:29:51.887]         {
[10:29:51.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.887]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.887]             }
[10:29:51.887]             base::options(...future.oldOptions)
[10:29:51.887]             if (.Platform$OS.type == "windows") {
[10:29:51.887]                 old_names <- names(...future.oldEnvVars)
[10:29:51.887]                 envs <- base::Sys.getenv()
[10:29:51.887]                 names <- names(envs)
[10:29:51.887]                 common <- intersect(names, old_names)
[10:29:51.887]                 added <- setdiff(names, old_names)
[10:29:51.887]                 removed <- setdiff(old_names, names)
[10:29:51.887]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.887]                   envs[common]]
[10:29:51.887]                 NAMES <- toupper(changed)
[10:29:51.887]                 args <- list()
[10:29:51.887]                 for (kk in seq_along(NAMES)) {
[10:29:51.887]                   name <- changed[[kk]]
[10:29:51.887]                   NAME <- NAMES[[kk]]
[10:29:51.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.887]                     next
[10:29:51.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.887]                 }
[10:29:51.887]                 NAMES <- toupper(added)
[10:29:51.887]                 for (kk in seq_along(NAMES)) {
[10:29:51.887]                   name <- added[[kk]]
[10:29:51.887]                   NAME <- NAMES[[kk]]
[10:29:51.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.887]                     next
[10:29:51.887]                   args[[name]] <- ""
[10:29:51.887]                 }
[10:29:51.887]                 NAMES <- toupper(removed)
[10:29:51.887]                 for (kk in seq_along(NAMES)) {
[10:29:51.887]                   name <- removed[[kk]]
[10:29:51.887]                   NAME <- NAMES[[kk]]
[10:29:51.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.887]                     next
[10:29:51.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.887]                 }
[10:29:51.887]                 if (length(args) > 0) 
[10:29:51.887]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.887]             }
[10:29:51.887]             else {
[10:29:51.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.887]             }
[10:29:51.887]             {
[10:29:51.887]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.887]                   0L) {
[10:29:51.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.887]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.887]                   base::options(opts)
[10:29:51.887]                 }
[10:29:51.887]                 {
[10:29:51.887]                   {
[10:29:51.887]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.887]                     NULL
[10:29:51.887]                   }
[10:29:51.887]                   options(future.plan = NULL)
[10:29:51.887]                   if (is.na(NA_character_)) 
[10:29:51.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.887]                     .init = FALSE)
[10:29:51.887]                 }
[10:29:51.887]             }
[10:29:51.887]         }
[10:29:51.887]     })
[10:29:51.887]     if (TRUE) {
[10:29:51.887]         base::sink(type = "output", split = FALSE)
[10:29:51.887]         if (TRUE) {
[10:29:51.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.887]         }
[10:29:51.887]         else {
[10:29:51.887]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.887]         }
[10:29:51.887]         base::close(...future.stdout)
[10:29:51.887]         ...future.stdout <- NULL
[10:29:51.887]     }
[10:29:51.887]     ...future.result$conditions <- ...future.conditions
[10:29:51.887]     ...future.result$finished <- base::Sys.time()
[10:29:51.887]     ...future.result
[10:29:51.887] }
[10:29:51.890] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[10:29:51.890] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:51.891] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:51.891] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[10:29:51.891] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[10:29:51.891] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[10:29:51.892] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[10:29:51.892] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:51.892] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:51.892] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:29:51.892] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:29:51.892] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[10:29:51.893] MultisessionFuture started
[10:29:51.893] - Launch lazy future ... done
[10:29:51.893] run() for ‘MultisessionFuture’ ... done
[10:29:51.893] Created future:
[10:29:51.893] MultisessionFuture:
[10:29:51.893] Label: ‘future_apply-2’
[10:29:51.893] Expression:
[10:29:51.893] {
[10:29:51.893]     do.call(function(...) {
[10:29:51.893]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.893]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.893]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.893]             on.exit(options(oopts), add = TRUE)
[10:29:51.893]         }
[10:29:51.893]         {
[10:29:51.893]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.893]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.893]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.893]             })
[10:29:51.893]         }
[10:29:51.893]     }, args = future.call.arguments)
[10:29:51.893] }
[10:29:51.893] Lazy evaluation: FALSE
[10:29:51.893] Asynchronous evaluation: TRUE
[10:29:51.893] Local evaluation: TRUE
[10:29:51.893] Environment: R_GlobalEnv
[10:29:51.893] Capture standard output: TRUE
[10:29:51.893] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.893] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.893] Packages: <none>
[10:29:51.893] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.893] Resolved: FALSE
[10:29:51.893] Value: <not collected>
[10:29:51.893] Conditions captured: <none>
[10:29:51.893] Early signaling: FALSE
[10:29:51.893] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.893] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.905] Chunk #2 of 2 ... DONE
[10:29:51.905] Launching 2 futures (chunks) ... DONE
[10:29:51.905] Resolving 2 futures (chunks) ...
[10:29:51.905] resolve() on list ...
[10:29:51.905]  recursive: 0
[10:29:51.905]  length: 2
[10:29:51.906] 
[10:29:51.906] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.906] - Validating connection of MultisessionFuture
[10:29:51.906] - received message: FutureResult
[10:29:51.906] - Received FutureResult
[10:29:51.907] - Erased future from FutureRegistry
[10:29:51.907] result() for ClusterFuture ...
[10:29:51.907] - result already collected: FutureResult
[10:29:51.907] result() for ClusterFuture ... done
[10:29:51.907] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.907] Future #1
[10:29:51.907] result() for ClusterFuture ...
[10:29:51.907] - result already collected: FutureResult
[10:29:51.907] result() for ClusterFuture ... done
[10:29:51.907] result() for ClusterFuture ...
[10:29:51.907] - result already collected: FutureResult
[10:29:51.907] result() for ClusterFuture ... done
[10:29:51.908] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:51.908] - nx: 2
[10:29:51.908] - relay: TRUE
[10:29:51.908] - stdout: TRUE
[10:29:51.908] - signal: TRUE
[10:29:51.908] - resignal: FALSE
[10:29:51.908] - force: TRUE
[10:29:51.908] - relayed: [n=2] FALSE, FALSE
[10:29:51.908] - queued futures: [n=2] FALSE, FALSE
[10:29:51.908]  - until=1
[10:29:51.908]  - relaying element #1
[10:29:51.909] result() for ClusterFuture ...
[10:29:51.909] - result already collected: FutureResult
[10:29:51.909] result() for ClusterFuture ... done
[10:29:51.909] result() for ClusterFuture ...
[10:29:51.909] - result already collected: FutureResult
[10:29:51.909] result() for ClusterFuture ... done
[10:29:51.909] result() for ClusterFuture ...
[10:29:51.909] - result already collected: FutureResult
[10:29:51.909] result() for ClusterFuture ... done
[10:29:51.909] result() for ClusterFuture ...
[10:29:51.909] - result already collected: FutureResult
[10:29:51.910] result() for ClusterFuture ... done
[10:29:51.910] - relayed: [n=2] TRUE, FALSE
[10:29:51.910] - queued futures: [n=2] TRUE, FALSE
[10:29:51.910] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:51.910]  length: 1 (resolved future 1)
[10:29:51.938] receiveMessageFromWorker() for ClusterFuture ...
[10:29:51.938] - Validating connection of MultisessionFuture
[10:29:51.939] - received message: FutureResult
[10:29:51.939] - Received FutureResult
[10:29:51.939] - Erased future from FutureRegistry
[10:29:51.939] result() for ClusterFuture ...
[10:29:51.939] - result already collected: FutureResult
[10:29:51.939] result() for ClusterFuture ... done
[10:29:51.939] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:51.940] Future #2
[10:29:51.940] result() for ClusterFuture ...
[10:29:51.940] - result already collected: FutureResult
[10:29:51.940] result() for ClusterFuture ... done
[10:29:51.940] result() for ClusterFuture ...
[10:29:51.940] - result already collected: FutureResult
[10:29:51.940] result() for ClusterFuture ... done
[10:29:51.940] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:51.940] - nx: 2
[10:29:51.940] - relay: TRUE
[10:29:51.940] - stdout: TRUE
[10:29:51.941] - signal: TRUE
[10:29:51.941] - resignal: FALSE
[10:29:51.943] - force: TRUE
[10:29:51.943] - relayed: [n=2] TRUE, FALSE
[10:29:51.943] - queued futures: [n=2] TRUE, FALSE
[10:29:51.943]  - until=2
[10:29:51.943]  - relaying element #2
[10:29:51.943] result() for ClusterFuture ...
[10:29:51.943] - result already collected: FutureResult
[10:29:51.944] result() for ClusterFuture ... done
[10:29:51.944] result() for ClusterFuture ...
[10:29:51.944] - result already collected: FutureResult
[10:29:51.944] result() for ClusterFuture ... done
[10:29:51.944] result() for ClusterFuture ...
[10:29:51.944] - result already collected: FutureResult
[10:29:51.944] result() for ClusterFuture ... done
[10:29:51.944] result() for ClusterFuture ...
[10:29:51.944] - result already collected: FutureResult
[10:29:51.944] result() for ClusterFuture ... done
[10:29:51.944] - relayed: [n=2] TRUE, TRUE
[10:29:51.945] - queued futures: [n=2] TRUE, TRUE
[10:29:51.945] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:51.945]  length: 0 (resolved future 2)
[10:29:51.945] Relaying remaining futures
[10:29:51.945] signalConditionsASAP(NULL, pos=0) ...
[10:29:51.945] - nx: 2
[10:29:51.945] - relay: TRUE
[10:29:51.945] - stdout: TRUE
[10:29:51.945] - signal: TRUE
[10:29:51.945] - resignal: FALSE
[10:29:51.945] - force: TRUE
[10:29:51.945] - relayed: [n=2] TRUE, TRUE
[10:29:51.946] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:51.946] - relayed: [n=2] TRUE, TRUE
[10:29:51.946] - queued futures: [n=2] TRUE, TRUE
[10:29:51.946] signalConditionsASAP(NULL, pos=0) ... done
[10:29:51.946] resolve() on list ... DONE
[10:29:51.946] result() for ClusterFuture ...
[10:29:51.946] - result already collected: FutureResult
[10:29:51.946] result() for ClusterFuture ... done
[10:29:51.946] result() for ClusterFuture ...
[10:29:51.946] - result already collected: FutureResult
[10:29:51.946] result() for ClusterFuture ... done
[10:29:51.947] result() for ClusterFuture ...
[10:29:51.947] - result already collected: FutureResult
[10:29:51.947] result() for ClusterFuture ... done
[10:29:51.947] result() for ClusterFuture ...
[10:29:51.947] - result already collected: FutureResult
[10:29:51.947] result() for ClusterFuture ... done
[10:29:51.947]  - Number of value chunks collected: 2
[10:29:51.947] Resolving 2 futures (chunks) ... DONE
[10:29:51.947] Reducing values from 2 chunks ...
[10:29:51.947]  - Number of values collected after concatenation: 6
[10:29:51.947]  - Number of values expected: 6
[10:29:51.947] Reducing values from 2 chunks ... DONE
[10:29:51.948] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:29:51.948] getGlobalsAndPackagesXApply() ...
[10:29:51.948]  - future.globals: TRUE
[10:29:51.948] getGlobalsAndPackages() ...
[10:29:51.948] Searching for globals...
[10:29:51.949] - globals found: [1] ‘FUN’
[10:29:51.949] Searching for globals ... DONE
[10:29:51.950] Resolving globals: FALSE
[10:29:51.950] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:51.950] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:51.950] - globals: [1] ‘FUN’
[10:29:51.950] 
[10:29:51.950] getGlobalsAndPackages() ... DONE
[10:29:51.951]  - globals found/used: [n=1] ‘FUN’
[10:29:51.951]  - needed namespaces: [n=0] 
[10:29:51.951] Finding globals ... DONE
[10:29:51.951]  - use_args: TRUE
[10:29:51.951]  - Getting '...' globals ...
[10:29:51.951] resolve() on list ...
[10:29:51.951]  recursive: 0
[10:29:51.951]  length: 1
[10:29:51.951]  elements: ‘...’
[10:29:51.952]  length: 0 (resolved future 1)
[10:29:51.952] resolve() on list ... DONE
[10:29:51.952]    - '...' content: [n=0] 
[10:29:51.952] List of 1
[10:29:51.952]  $ ...: list()
[10:29:51.952]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.952]  - attr(*, "where")=List of 1
[10:29:51.952]   ..$ ...:<environment: 0x5618a236e6c0> 
[10:29:51.952]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.952]  - attr(*, "resolved")= logi TRUE
[10:29:51.952]  - attr(*, "total_size")= num NA
[10:29:51.954]  - Getting '...' globals ... DONE
[10:29:51.955] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:51.955] List of 2
[10:29:51.955]  $ ...future.FUN:function (x)  
[10:29:51.955]  $ ...          : list()
[10:29:51.955]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.955]  - attr(*, "where")=List of 2
[10:29:51.955]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:51.955]   ..$ ...          :<environment: 0x5618a236e6c0> 
[10:29:51.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.955]  - attr(*, "resolved")= logi FALSE
[10:29:51.955]  - attr(*, "total_size")= num 848
[10:29:51.957] Packages to be attached in all futures: [n=0] 
[10:29:51.957] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.961] future_lapply() ...
[10:29:51.965] Number of chunks: 2
[10:29:51.965] getGlobalsAndPackagesXApply() ...
[10:29:51.965]  - future.globals: <name-value list> with names ‘list()’
[10:29:51.965]  - use_args: TRUE
[10:29:51.965] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:51.965] List of 2
[10:29:51.965]  $ ...          : list()
[10:29:51.965]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:51.965]  $ ...future.FUN:function (x)  
[10:29:51.965]  - attr(*, "where")=List of 2
[10:29:51.965]   ..$ ...          :<environment: 0x5618a236e6c0> 
[10:29:51.965]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:51.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:51.965]  - attr(*, "resolved")= logi FALSE
[10:29:51.965]  - attr(*, "total_size")= num NA
[10:29:51.969] Packages to be attached in all futures: [n=0] 
[10:29:51.969] getGlobalsAndPackagesXApply() ... DONE
[10:29:51.969] Number of futures (= number of chunks): 2
[10:29:51.969] Launching 2 futures (chunks) ...
[10:29:51.969] Chunk #1 of 2 ...
[10:29:51.969]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:51.969]  - seeds: <none>
[10:29:51.969]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.970] getGlobalsAndPackages() ...
[10:29:51.970] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.970] Resolving globals: FALSE
[10:29:51.970] Tweak future expression to call with '...' arguments ...
[10:29:51.970] {
[10:29:51.970]     do.call(function(...) {
[10:29:51.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.970]             on.exit(options(oopts), add = TRUE)
[10:29:51.970]         }
[10:29:51.970]         {
[10:29:51.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.970]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.970]             })
[10:29:51.970]         }
[10:29:51.970]     }, args = future.call.arguments)
[10:29:51.970] }
[10:29:51.970] Tweak future expression to call with '...' arguments ... DONE
[10:29:51.971] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:51.971] 
[10:29:51.971] getGlobalsAndPackages() ... DONE
[10:29:51.971] run() for ‘Future’ ...
[10:29:51.971] - state: ‘created’
[10:29:51.971] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:51.985] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:51.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:51.985]   - Field: ‘node’
[10:29:51.985]   - Field: ‘label’
[10:29:51.986]   - Field: ‘local’
[10:29:51.986]   - Field: ‘owner’
[10:29:51.986]   - Field: ‘envir’
[10:29:51.986]   - Field: ‘workers’
[10:29:51.986]   - Field: ‘packages’
[10:29:51.986]   - Field: ‘gc’
[10:29:51.986]   - Field: ‘conditions’
[10:29:51.986]   - Field: ‘persistent’
[10:29:51.986]   - Field: ‘expr’
[10:29:51.986]   - Field: ‘uuid’
[10:29:51.986]   - Field: ‘seed’
[10:29:51.987]   - Field: ‘version’
[10:29:51.987]   - Field: ‘result’
[10:29:51.987]   - Field: ‘asynchronous’
[10:29:51.987]   - Field: ‘calls’
[10:29:51.987]   - Field: ‘globals’
[10:29:51.987]   - Field: ‘stdout’
[10:29:51.987]   - Field: ‘earlySignal’
[10:29:51.987]   - Field: ‘lazy’
[10:29:51.987]   - Field: ‘state’
[10:29:51.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:51.988] - Launch lazy future ...
[10:29:51.988] Packages needed by the future expression (n = 0): <none>
[10:29:51.988] Packages needed by future strategies (n = 0): <none>
[10:29:51.988] {
[10:29:51.988]     {
[10:29:51.988]         {
[10:29:51.988]             ...future.startTime <- base::Sys.time()
[10:29:51.988]             {
[10:29:51.988]                 {
[10:29:51.988]                   {
[10:29:51.988]                     {
[10:29:51.988]                       base::local({
[10:29:51.988]                         has_future <- base::requireNamespace("future", 
[10:29:51.988]                           quietly = TRUE)
[10:29:51.988]                         if (has_future) {
[10:29:51.988]                           ns <- base::getNamespace("future")
[10:29:51.988]                           version <- ns[[".package"]][["version"]]
[10:29:51.988]                           if (is.null(version)) 
[10:29:51.988]                             version <- utils::packageVersion("future")
[10:29:51.988]                         }
[10:29:51.988]                         else {
[10:29:51.988]                           version <- NULL
[10:29:51.988]                         }
[10:29:51.988]                         if (!has_future || version < "1.8.0") {
[10:29:51.988]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:51.988]                             "", base::R.version$version.string), 
[10:29:51.988]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:51.988]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:51.988]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:51.988]                               "release", "version")], collapse = " "), 
[10:29:51.988]                             hostname = base::Sys.info()[["nodename"]])
[10:29:51.988]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:51.988]                             info)
[10:29:51.988]                           info <- base::paste(info, collapse = "; ")
[10:29:51.988]                           if (!has_future) {
[10:29:51.988]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:51.988]                               info)
[10:29:51.988]                           }
[10:29:51.988]                           else {
[10:29:51.988]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:51.988]                               info, version)
[10:29:51.988]                           }
[10:29:51.988]                           base::stop(msg)
[10:29:51.988]                         }
[10:29:51.988]                       })
[10:29:51.988]                     }
[10:29:51.988]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:51.988]                     base::options(mc.cores = 1L)
[10:29:51.988]                   }
[10:29:51.988]                   ...future.strategy.old <- future::plan("list")
[10:29:51.988]                   options(future.plan = NULL)
[10:29:51.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:51.988]                 }
[10:29:51.988]                 ...future.workdir <- getwd()
[10:29:51.988]             }
[10:29:51.988]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:51.988]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:51.988]         }
[10:29:51.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:51.988]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:51.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:51.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:51.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:51.988]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:51.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:51.988]             base::names(...future.oldOptions))
[10:29:51.988]     }
[10:29:51.988]     if (FALSE) {
[10:29:51.988]     }
[10:29:51.988]     else {
[10:29:51.988]         if (TRUE) {
[10:29:51.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:51.988]                 open = "w")
[10:29:51.988]         }
[10:29:51.988]         else {
[10:29:51.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:51.988]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:51.988]         }
[10:29:51.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:51.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:51.988]             base::sink(type = "output", split = FALSE)
[10:29:51.988]             base::close(...future.stdout)
[10:29:51.988]         }, add = TRUE)
[10:29:51.988]     }
[10:29:51.988]     ...future.frame <- base::sys.nframe()
[10:29:51.988]     ...future.conditions <- base::list()
[10:29:51.988]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:51.988]     if (FALSE) {
[10:29:51.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:51.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:51.988]     }
[10:29:51.988]     ...future.result <- base::tryCatch({
[10:29:51.988]         base::withCallingHandlers({
[10:29:51.988]             ...future.value <- base::withVisible(base::local({
[10:29:51.988]                 ...future.makeSendCondition <- base::local({
[10:29:51.988]                   sendCondition <- NULL
[10:29:51.988]                   function(frame = 1L) {
[10:29:51.988]                     if (is.function(sendCondition)) 
[10:29:51.988]                       return(sendCondition)
[10:29:51.988]                     ns <- getNamespace("parallel")
[10:29:51.988]                     if (exists("sendData", mode = "function", 
[10:29:51.988]                       envir = ns)) {
[10:29:51.988]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:51.988]                         envir = ns)
[10:29:51.988]                       envir <- sys.frame(frame)
[10:29:51.988]                       master <- NULL
[10:29:51.988]                       while (!identical(envir, .GlobalEnv) && 
[10:29:51.988]                         !identical(envir, emptyenv())) {
[10:29:51.988]                         if (exists("master", mode = "list", envir = envir, 
[10:29:51.988]                           inherits = FALSE)) {
[10:29:51.988]                           master <- get("master", mode = "list", 
[10:29:51.988]                             envir = envir, inherits = FALSE)
[10:29:51.988]                           if (inherits(master, c("SOCKnode", 
[10:29:51.988]                             "SOCK0node"))) {
[10:29:51.988]                             sendCondition <<- function(cond) {
[10:29:51.988]                               data <- list(type = "VALUE", value = cond, 
[10:29:51.988]                                 success = TRUE)
[10:29:51.988]                               parallel_sendData(master, data)
[10:29:51.988]                             }
[10:29:51.988]                             return(sendCondition)
[10:29:51.988]                           }
[10:29:51.988]                         }
[10:29:51.988]                         frame <- frame + 1L
[10:29:51.988]                         envir <- sys.frame(frame)
[10:29:51.988]                       }
[10:29:51.988]                     }
[10:29:51.988]                     sendCondition <<- function(cond) NULL
[10:29:51.988]                   }
[10:29:51.988]                 })
[10:29:51.988]                 withCallingHandlers({
[10:29:51.988]                   {
[10:29:51.988]                     do.call(function(...) {
[10:29:51.988]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.988]                       if (!identical(...future.globals.maxSize.org, 
[10:29:51.988]                         ...future.globals.maxSize)) {
[10:29:51.988]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.988]                         on.exit(options(oopts), add = TRUE)
[10:29:51.988]                       }
[10:29:51.988]                       {
[10:29:51.988]                         lapply(seq_along(...future.elements_ii), 
[10:29:51.988]                           FUN = function(jj) {
[10:29:51.988]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.988]                             ...future.FUN(...future.X_jj, ...)
[10:29:51.988]                           })
[10:29:51.988]                       }
[10:29:51.988]                     }, args = future.call.arguments)
[10:29:51.988]                   }
[10:29:51.988]                 }, immediateCondition = function(cond) {
[10:29:51.988]                   sendCondition <- ...future.makeSendCondition()
[10:29:51.988]                   sendCondition(cond)
[10:29:51.988]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.988]                   {
[10:29:51.988]                     inherits <- base::inherits
[10:29:51.988]                     invokeRestart <- base::invokeRestart
[10:29:51.988]                     is.null <- base::is.null
[10:29:51.988]                     muffled <- FALSE
[10:29:51.988]                     if (inherits(cond, "message")) {
[10:29:51.988]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:51.988]                       if (muffled) 
[10:29:51.988]                         invokeRestart("muffleMessage")
[10:29:51.988]                     }
[10:29:51.988]                     else if (inherits(cond, "warning")) {
[10:29:51.988]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:51.988]                       if (muffled) 
[10:29:51.988]                         invokeRestart("muffleWarning")
[10:29:51.988]                     }
[10:29:51.988]                     else if (inherits(cond, "condition")) {
[10:29:51.988]                       if (!is.null(pattern)) {
[10:29:51.988]                         computeRestarts <- base::computeRestarts
[10:29:51.988]                         grepl <- base::grepl
[10:29:51.988]                         restarts <- computeRestarts(cond)
[10:29:51.988]                         for (restart in restarts) {
[10:29:51.988]                           name <- restart$name
[10:29:51.988]                           if (is.null(name)) 
[10:29:51.988]                             next
[10:29:51.988]                           if (!grepl(pattern, name)) 
[10:29:51.988]                             next
[10:29:51.988]                           invokeRestart(restart)
[10:29:51.988]                           muffled <- TRUE
[10:29:51.988]                           break
[10:29:51.988]                         }
[10:29:51.988]                       }
[10:29:51.988]                     }
[10:29:51.988]                     invisible(muffled)
[10:29:51.988]                   }
[10:29:51.988]                   muffleCondition(cond)
[10:29:51.988]                 })
[10:29:51.988]             }))
[10:29:51.988]             future::FutureResult(value = ...future.value$value, 
[10:29:51.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.988]                   ...future.rng), globalenv = if (FALSE) 
[10:29:51.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:51.988]                     ...future.globalenv.names))
[10:29:51.988]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:51.988]         }, condition = base::local({
[10:29:51.988]             c <- base::c
[10:29:51.988]             inherits <- base::inherits
[10:29:51.988]             invokeRestart <- base::invokeRestart
[10:29:51.988]             length <- base::length
[10:29:51.988]             list <- base::list
[10:29:51.988]             seq.int <- base::seq.int
[10:29:51.988]             signalCondition <- base::signalCondition
[10:29:51.988]             sys.calls <- base::sys.calls
[10:29:51.988]             `[[` <- base::`[[`
[10:29:51.988]             `+` <- base::`+`
[10:29:51.988]             `<<-` <- base::`<<-`
[10:29:51.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:51.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:51.988]                   3L)]
[10:29:51.988]             }
[10:29:51.988]             function(cond) {
[10:29:51.988]                 is_error <- inherits(cond, "error")
[10:29:51.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:51.988]                   NULL)
[10:29:51.988]                 if (is_error) {
[10:29:51.988]                   sessionInformation <- function() {
[10:29:51.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:51.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:51.988]                       search = base::search(), system = base::Sys.info())
[10:29:51.988]                   }
[10:29:51.988]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:51.988]                     cond$call), session = sessionInformation(), 
[10:29:51.988]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:51.988]                   signalCondition(cond)
[10:29:51.988]                 }
[10:29:51.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:51.988]                 "immediateCondition"))) {
[10:29:51.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:51.988]                   ...future.conditions[[length(...future.conditions) + 
[10:29:51.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:51.988]                   if (TRUE && !signal) {
[10:29:51.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.988]                     {
[10:29:51.988]                       inherits <- base::inherits
[10:29:51.988]                       invokeRestart <- base::invokeRestart
[10:29:51.988]                       is.null <- base::is.null
[10:29:51.988]                       muffled <- FALSE
[10:29:51.988]                       if (inherits(cond, "message")) {
[10:29:51.988]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.988]                         if (muffled) 
[10:29:51.988]                           invokeRestart("muffleMessage")
[10:29:51.988]                       }
[10:29:51.988]                       else if (inherits(cond, "warning")) {
[10:29:51.988]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.988]                         if (muffled) 
[10:29:51.988]                           invokeRestart("muffleWarning")
[10:29:51.988]                       }
[10:29:51.988]                       else if (inherits(cond, "condition")) {
[10:29:51.988]                         if (!is.null(pattern)) {
[10:29:51.988]                           computeRestarts <- base::computeRestarts
[10:29:51.988]                           grepl <- base::grepl
[10:29:51.988]                           restarts <- computeRestarts(cond)
[10:29:51.988]                           for (restart in restarts) {
[10:29:51.988]                             name <- restart$name
[10:29:51.988]                             if (is.null(name)) 
[10:29:51.988]                               next
[10:29:51.988]                             if (!grepl(pattern, name)) 
[10:29:51.988]                               next
[10:29:51.988]                             invokeRestart(restart)
[10:29:51.988]                             muffled <- TRUE
[10:29:51.988]                             break
[10:29:51.988]                           }
[10:29:51.988]                         }
[10:29:51.988]                       }
[10:29:51.988]                       invisible(muffled)
[10:29:51.988]                     }
[10:29:51.988]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.988]                   }
[10:29:51.988]                 }
[10:29:51.988]                 else {
[10:29:51.988]                   if (TRUE) {
[10:29:51.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:51.988]                     {
[10:29:51.988]                       inherits <- base::inherits
[10:29:51.988]                       invokeRestart <- base::invokeRestart
[10:29:51.988]                       is.null <- base::is.null
[10:29:51.988]                       muffled <- FALSE
[10:29:51.988]                       if (inherits(cond, "message")) {
[10:29:51.988]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:51.988]                         if (muffled) 
[10:29:51.988]                           invokeRestart("muffleMessage")
[10:29:51.988]                       }
[10:29:51.988]                       else if (inherits(cond, "warning")) {
[10:29:51.988]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:51.988]                         if (muffled) 
[10:29:51.988]                           invokeRestart("muffleWarning")
[10:29:51.988]                       }
[10:29:51.988]                       else if (inherits(cond, "condition")) {
[10:29:51.988]                         if (!is.null(pattern)) {
[10:29:51.988]                           computeRestarts <- base::computeRestarts
[10:29:51.988]                           grepl <- base::grepl
[10:29:51.988]                           restarts <- computeRestarts(cond)
[10:29:51.988]                           for (restart in restarts) {
[10:29:51.988]                             name <- restart$name
[10:29:51.988]                             if (is.null(name)) 
[10:29:51.988]                               next
[10:29:51.988]                             if (!grepl(pattern, name)) 
[10:29:51.988]                               next
[10:29:51.988]                             invokeRestart(restart)
[10:29:51.988]                             muffled <- TRUE
[10:29:51.988]                             break
[10:29:51.988]                           }
[10:29:51.988]                         }
[10:29:51.988]                       }
[10:29:51.988]                       invisible(muffled)
[10:29:51.988]                     }
[10:29:51.988]                     muffleCondition(cond, pattern = "^muffle")
[10:29:51.988]                   }
[10:29:51.988]                 }
[10:29:51.988]             }
[10:29:51.988]         }))
[10:29:51.988]     }, error = function(ex) {
[10:29:51.988]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:51.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:51.988]                 ...future.rng), started = ...future.startTime, 
[10:29:51.988]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:51.988]             version = "1.8"), class = "FutureResult")
[10:29:51.988]     }, finally = {
[10:29:51.988]         if (!identical(...future.workdir, getwd())) 
[10:29:51.988]             setwd(...future.workdir)
[10:29:51.988]         {
[10:29:51.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:51.988]                 ...future.oldOptions$nwarnings <- NULL
[10:29:51.988]             }
[10:29:51.988]             base::options(...future.oldOptions)
[10:29:51.988]             if (.Platform$OS.type == "windows") {
[10:29:51.988]                 old_names <- names(...future.oldEnvVars)
[10:29:51.988]                 envs <- base::Sys.getenv()
[10:29:51.988]                 names <- names(envs)
[10:29:51.988]                 common <- intersect(names, old_names)
[10:29:51.988]                 added <- setdiff(names, old_names)
[10:29:51.988]                 removed <- setdiff(old_names, names)
[10:29:51.988]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:51.988]                   envs[common]]
[10:29:51.988]                 NAMES <- toupper(changed)
[10:29:51.988]                 args <- list()
[10:29:51.988]                 for (kk in seq_along(NAMES)) {
[10:29:51.988]                   name <- changed[[kk]]
[10:29:51.988]                   NAME <- NAMES[[kk]]
[10:29:51.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.988]                     next
[10:29:51.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.988]                 }
[10:29:51.988]                 NAMES <- toupper(added)
[10:29:51.988]                 for (kk in seq_along(NAMES)) {
[10:29:51.988]                   name <- added[[kk]]
[10:29:51.988]                   NAME <- NAMES[[kk]]
[10:29:51.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.988]                     next
[10:29:51.988]                   args[[name]] <- ""
[10:29:51.988]                 }
[10:29:51.988]                 NAMES <- toupper(removed)
[10:29:51.988]                 for (kk in seq_along(NAMES)) {
[10:29:51.988]                   name <- removed[[kk]]
[10:29:51.988]                   NAME <- NAMES[[kk]]
[10:29:51.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:51.988]                     next
[10:29:51.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:51.988]                 }
[10:29:51.988]                 if (length(args) > 0) 
[10:29:51.988]                   base::do.call(base::Sys.setenv, args = args)
[10:29:51.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:51.988]             }
[10:29:51.988]             else {
[10:29:51.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:51.988]             }
[10:29:51.988]             {
[10:29:51.988]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:51.988]                   0L) {
[10:29:51.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:51.988]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:51.988]                   base::options(opts)
[10:29:51.988]                 }
[10:29:51.988]                 {
[10:29:51.988]                   {
[10:29:51.988]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:51.988]                     NULL
[10:29:51.988]                   }
[10:29:51.988]                   options(future.plan = NULL)
[10:29:51.988]                   if (is.na(NA_character_)) 
[10:29:51.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:51.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:51.988]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:51.988]                     .init = FALSE)
[10:29:51.988]                 }
[10:29:51.988]             }
[10:29:51.988]         }
[10:29:51.988]     })
[10:29:51.988]     if (TRUE) {
[10:29:51.988]         base::sink(type = "output", split = FALSE)
[10:29:51.988]         if (TRUE) {
[10:29:51.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:51.988]         }
[10:29:51.988]         else {
[10:29:51.988]             ...future.result["stdout"] <- base::list(NULL)
[10:29:51.988]         }
[10:29:51.988]         base::close(...future.stdout)
[10:29:51.988]         ...future.stdout <- NULL
[10:29:51.988]     }
[10:29:51.988]     ...future.result$conditions <- ...future.conditions
[10:29:51.988]     ...future.result$finished <- base::Sys.time()
[10:29:51.988]     ...future.result
[10:29:51.988] }
[10:29:51.991] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[10:29:51.992] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:51.992] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.992] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:29:51.992] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:29:51.992] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:29:51.993] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:29:51.993] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:51.993] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:51.993] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:51.994] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:51.994] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[10:29:51.994] MultisessionFuture started
[10:29:51.994] - Launch lazy future ... done
[10:29:51.994] run() for ‘MultisessionFuture’ ... done
[10:29:51.994] Created future:
[10:29:51.995] MultisessionFuture:
[10:29:51.995] Label: ‘future_apply-1’
[10:29:51.995] Expression:
[10:29:51.995] {
[10:29:51.995]     do.call(function(...) {
[10:29:51.995]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:51.995]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:51.995]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:51.995]             on.exit(options(oopts), add = TRUE)
[10:29:51.995]         }
[10:29:51.995]         {
[10:29:51.995]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:51.995]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:51.995]                 ...future.FUN(...future.X_jj, ...)
[10:29:51.995]             })
[10:29:51.995]         }
[10:29:51.995]     }, args = future.call.arguments)
[10:29:51.995] }
[10:29:51.995] Lazy evaluation: FALSE
[10:29:51.995] Asynchronous evaluation: TRUE
[10:29:51.995] Local evaluation: TRUE
[10:29:51.995] Environment: R_GlobalEnv
[10:29:51.995] Capture standard output: TRUE
[10:29:51.995] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:51.995] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:51.995] Packages: <none>
[10:29:51.995] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:51.995] Resolved: FALSE
[10:29:51.995] Value: <not collected>
[10:29:51.995] Conditions captured: <none>
[10:29:51.995] Early signaling: FALSE
[10:29:51.995] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:51.995] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.006] Chunk #1 of 2 ... DONE
[10:29:52.006] Chunk #2 of 2 ...
[10:29:52.006]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:52.006]  - seeds: <none>
[10:29:52.006]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.007] getGlobalsAndPackages() ...
[10:29:52.007] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.007] Resolving globals: FALSE
[10:29:52.007] Tweak future expression to call with '...' arguments ...
[10:29:52.007] {
[10:29:52.007]     do.call(function(...) {
[10:29:52.007]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.007]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.007]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.007]             on.exit(options(oopts), add = TRUE)
[10:29:52.007]         }
[10:29:52.007]         {
[10:29:52.007]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.007]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.007]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.007]             })
[10:29:52.007]         }
[10:29:52.007]     }, args = future.call.arguments)
[10:29:52.007] }
[10:29:52.007] Tweak future expression to call with '...' arguments ... DONE
[10:29:52.008] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.008] 
[10:29:52.008] getGlobalsAndPackages() ... DONE
[10:29:52.008] run() for ‘Future’ ...
[10:29:52.008] - state: ‘created’
[10:29:52.008] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:52.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:52.022]   - Field: ‘node’
[10:29:52.022]   - Field: ‘label’
[10:29:52.022]   - Field: ‘local’
[10:29:52.022]   - Field: ‘owner’
[10:29:52.023]   - Field: ‘envir’
[10:29:52.023]   - Field: ‘workers’
[10:29:52.023]   - Field: ‘packages’
[10:29:52.023]   - Field: ‘gc’
[10:29:52.023]   - Field: ‘conditions’
[10:29:52.023]   - Field: ‘persistent’
[10:29:52.023]   - Field: ‘expr’
[10:29:52.023]   - Field: ‘uuid’
[10:29:52.023]   - Field: ‘seed’
[10:29:52.023]   - Field: ‘version’
[10:29:52.023]   - Field: ‘result’
[10:29:52.024]   - Field: ‘asynchronous’
[10:29:52.024]   - Field: ‘calls’
[10:29:52.024]   - Field: ‘globals’
[10:29:52.024]   - Field: ‘stdout’
[10:29:52.024]   - Field: ‘earlySignal’
[10:29:52.024]   - Field: ‘lazy’
[10:29:52.024]   - Field: ‘state’
[10:29:52.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:52.024] - Launch lazy future ...
[10:29:52.025] Packages needed by the future expression (n = 0): <none>
[10:29:52.025] Packages needed by future strategies (n = 0): <none>
[10:29:52.025] {
[10:29:52.025]     {
[10:29:52.025]         {
[10:29:52.025]             ...future.startTime <- base::Sys.time()
[10:29:52.025]             {
[10:29:52.025]                 {
[10:29:52.025]                   {
[10:29:52.025]                     {
[10:29:52.025]                       base::local({
[10:29:52.025]                         has_future <- base::requireNamespace("future", 
[10:29:52.025]                           quietly = TRUE)
[10:29:52.025]                         if (has_future) {
[10:29:52.025]                           ns <- base::getNamespace("future")
[10:29:52.025]                           version <- ns[[".package"]][["version"]]
[10:29:52.025]                           if (is.null(version)) 
[10:29:52.025]                             version <- utils::packageVersion("future")
[10:29:52.025]                         }
[10:29:52.025]                         else {
[10:29:52.025]                           version <- NULL
[10:29:52.025]                         }
[10:29:52.025]                         if (!has_future || version < "1.8.0") {
[10:29:52.025]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:52.025]                             "", base::R.version$version.string), 
[10:29:52.025]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:52.025]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:52.025]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:52.025]                               "release", "version")], collapse = " "), 
[10:29:52.025]                             hostname = base::Sys.info()[["nodename"]])
[10:29:52.025]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:52.025]                             info)
[10:29:52.025]                           info <- base::paste(info, collapse = "; ")
[10:29:52.025]                           if (!has_future) {
[10:29:52.025]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:52.025]                               info)
[10:29:52.025]                           }
[10:29:52.025]                           else {
[10:29:52.025]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:52.025]                               info, version)
[10:29:52.025]                           }
[10:29:52.025]                           base::stop(msg)
[10:29:52.025]                         }
[10:29:52.025]                       })
[10:29:52.025]                     }
[10:29:52.025]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:52.025]                     base::options(mc.cores = 1L)
[10:29:52.025]                   }
[10:29:52.025]                   ...future.strategy.old <- future::plan("list")
[10:29:52.025]                   options(future.plan = NULL)
[10:29:52.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:52.025]                 }
[10:29:52.025]                 ...future.workdir <- getwd()
[10:29:52.025]             }
[10:29:52.025]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:52.025]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:52.025]         }
[10:29:52.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:52.025]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:52.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:52.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:52.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:52.025]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:52.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:52.025]             base::names(...future.oldOptions))
[10:29:52.025]     }
[10:29:52.025]     if (FALSE) {
[10:29:52.025]     }
[10:29:52.025]     else {
[10:29:52.025]         if (TRUE) {
[10:29:52.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:52.025]                 open = "w")
[10:29:52.025]         }
[10:29:52.025]         else {
[10:29:52.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:52.025]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:52.025]         }
[10:29:52.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:52.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:52.025]             base::sink(type = "output", split = FALSE)
[10:29:52.025]             base::close(...future.stdout)
[10:29:52.025]         }, add = TRUE)
[10:29:52.025]     }
[10:29:52.025]     ...future.frame <- base::sys.nframe()
[10:29:52.025]     ...future.conditions <- base::list()
[10:29:52.025]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:52.025]     if (FALSE) {
[10:29:52.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:52.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:52.025]     }
[10:29:52.025]     ...future.result <- base::tryCatch({
[10:29:52.025]         base::withCallingHandlers({
[10:29:52.025]             ...future.value <- base::withVisible(base::local({
[10:29:52.025]                 ...future.makeSendCondition <- base::local({
[10:29:52.025]                   sendCondition <- NULL
[10:29:52.025]                   function(frame = 1L) {
[10:29:52.025]                     if (is.function(sendCondition)) 
[10:29:52.025]                       return(sendCondition)
[10:29:52.025]                     ns <- getNamespace("parallel")
[10:29:52.025]                     if (exists("sendData", mode = "function", 
[10:29:52.025]                       envir = ns)) {
[10:29:52.025]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:52.025]                         envir = ns)
[10:29:52.025]                       envir <- sys.frame(frame)
[10:29:52.025]                       master <- NULL
[10:29:52.025]                       while (!identical(envir, .GlobalEnv) && 
[10:29:52.025]                         !identical(envir, emptyenv())) {
[10:29:52.025]                         if (exists("master", mode = "list", envir = envir, 
[10:29:52.025]                           inherits = FALSE)) {
[10:29:52.025]                           master <- get("master", mode = "list", 
[10:29:52.025]                             envir = envir, inherits = FALSE)
[10:29:52.025]                           if (inherits(master, c("SOCKnode", 
[10:29:52.025]                             "SOCK0node"))) {
[10:29:52.025]                             sendCondition <<- function(cond) {
[10:29:52.025]                               data <- list(type = "VALUE", value = cond, 
[10:29:52.025]                                 success = TRUE)
[10:29:52.025]                               parallel_sendData(master, data)
[10:29:52.025]                             }
[10:29:52.025]                             return(sendCondition)
[10:29:52.025]                           }
[10:29:52.025]                         }
[10:29:52.025]                         frame <- frame + 1L
[10:29:52.025]                         envir <- sys.frame(frame)
[10:29:52.025]                       }
[10:29:52.025]                     }
[10:29:52.025]                     sendCondition <<- function(cond) NULL
[10:29:52.025]                   }
[10:29:52.025]                 })
[10:29:52.025]                 withCallingHandlers({
[10:29:52.025]                   {
[10:29:52.025]                     do.call(function(...) {
[10:29:52.025]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.025]                       if (!identical(...future.globals.maxSize.org, 
[10:29:52.025]                         ...future.globals.maxSize)) {
[10:29:52.025]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.025]                         on.exit(options(oopts), add = TRUE)
[10:29:52.025]                       }
[10:29:52.025]                       {
[10:29:52.025]                         lapply(seq_along(...future.elements_ii), 
[10:29:52.025]                           FUN = function(jj) {
[10:29:52.025]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.025]                             ...future.FUN(...future.X_jj, ...)
[10:29:52.025]                           })
[10:29:52.025]                       }
[10:29:52.025]                     }, args = future.call.arguments)
[10:29:52.025]                   }
[10:29:52.025]                 }, immediateCondition = function(cond) {
[10:29:52.025]                   sendCondition <- ...future.makeSendCondition()
[10:29:52.025]                   sendCondition(cond)
[10:29:52.025]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.025]                   {
[10:29:52.025]                     inherits <- base::inherits
[10:29:52.025]                     invokeRestart <- base::invokeRestart
[10:29:52.025]                     is.null <- base::is.null
[10:29:52.025]                     muffled <- FALSE
[10:29:52.025]                     if (inherits(cond, "message")) {
[10:29:52.025]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:52.025]                       if (muffled) 
[10:29:52.025]                         invokeRestart("muffleMessage")
[10:29:52.025]                     }
[10:29:52.025]                     else if (inherits(cond, "warning")) {
[10:29:52.025]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:52.025]                       if (muffled) 
[10:29:52.025]                         invokeRestart("muffleWarning")
[10:29:52.025]                     }
[10:29:52.025]                     else if (inherits(cond, "condition")) {
[10:29:52.025]                       if (!is.null(pattern)) {
[10:29:52.025]                         computeRestarts <- base::computeRestarts
[10:29:52.025]                         grepl <- base::grepl
[10:29:52.025]                         restarts <- computeRestarts(cond)
[10:29:52.025]                         for (restart in restarts) {
[10:29:52.025]                           name <- restart$name
[10:29:52.025]                           if (is.null(name)) 
[10:29:52.025]                             next
[10:29:52.025]                           if (!grepl(pattern, name)) 
[10:29:52.025]                             next
[10:29:52.025]                           invokeRestart(restart)
[10:29:52.025]                           muffled <- TRUE
[10:29:52.025]                           break
[10:29:52.025]                         }
[10:29:52.025]                       }
[10:29:52.025]                     }
[10:29:52.025]                     invisible(muffled)
[10:29:52.025]                   }
[10:29:52.025]                   muffleCondition(cond)
[10:29:52.025]                 })
[10:29:52.025]             }))
[10:29:52.025]             future::FutureResult(value = ...future.value$value, 
[10:29:52.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.025]                   ...future.rng), globalenv = if (FALSE) 
[10:29:52.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:52.025]                     ...future.globalenv.names))
[10:29:52.025]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:52.025]         }, condition = base::local({
[10:29:52.025]             c <- base::c
[10:29:52.025]             inherits <- base::inherits
[10:29:52.025]             invokeRestart <- base::invokeRestart
[10:29:52.025]             length <- base::length
[10:29:52.025]             list <- base::list
[10:29:52.025]             seq.int <- base::seq.int
[10:29:52.025]             signalCondition <- base::signalCondition
[10:29:52.025]             sys.calls <- base::sys.calls
[10:29:52.025]             `[[` <- base::`[[`
[10:29:52.025]             `+` <- base::`+`
[10:29:52.025]             `<<-` <- base::`<<-`
[10:29:52.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:52.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:52.025]                   3L)]
[10:29:52.025]             }
[10:29:52.025]             function(cond) {
[10:29:52.025]                 is_error <- inherits(cond, "error")
[10:29:52.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:52.025]                   NULL)
[10:29:52.025]                 if (is_error) {
[10:29:52.025]                   sessionInformation <- function() {
[10:29:52.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:52.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:52.025]                       search = base::search(), system = base::Sys.info())
[10:29:52.025]                   }
[10:29:52.025]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:52.025]                     cond$call), session = sessionInformation(), 
[10:29:52.025]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:52.025]                   signalCondition(cond)
[10:29:52.025]                 }
[10:29:52.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:52.025]                 "immediateCondition"))) {
[10:29:52.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:52.025]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:52.025]                   if (TRUE && !signal) {
[10:29:52.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.025]                     {
[10:29:52.025]                       inherits <- base::inherits
[10:29:52.025]                       invokeRestart <- base::invokeRestart
[10:29:52.025]                       is.null <- base::is.null
[10:29:52.025]                       muffled <- FALSE
[10:29:52.025]                       if (inherits(cond, "message")) {
[10:29:52.025]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.025]                         if (muffled) 
[10:29:52.025]                           invokeRestart("muffleMessage")
[10:29:52.025]                       }
[10:29:52.025]                       else if (inherits(cond, "warning")) {
[10:29:52.025]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.025]                         if (muffled) 
[10:29:52.025]                           invokeRestart("muffleWarning")
[10:29:52.025]                       }
[10:29:52.025]                       else if (inherits(cond, "condition")) {
[10:29:52.025]                         if (!is.null(pattern)) {
[10:29:52.025]                           computeRestarts <- base::computeRestarts
[10:29:52.025]                           grepl <- base::grepl
[10:29:52.025]                           restarts <- computeRestarts(cond)
[10:29:52.025]                           for (restart in restarts) {
[10:29:52.025]                             name <- restart$name
[10:29:52.025]                             if (is.null(name)) 
[10:29:52.025]                               next
[10:29:52.025]                             if (!grepl(pattern, name)) 
[10:29:52.025]                               next
[10:29:52.025]                             invokeRestart(restart)
[10:29:52.025]                             muffled <- TRUE
[10:29:52.025]                             break
[10:29:52.025]                           }
[10:29:52.025]                         }
[10:29:52.025]                       }
[10:29:52.025]                       invisible(muffled)
[10:29:52.025]                     }
[10:29:52.025]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.025]                   }
[10:29:52.025]                 }
[10:29:52.025]                 else {
[10:29:52.025]                   if (TRUE) {
[10:29:52.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.025]                     {
[10:29:52.025]                       inherits <- base::inherits
[10:29:52.025]                       invokeRestart <- base::invokeRestart
[10:29:52.025]                       is.null <- base::is.null
[10:29:52.025]                       muffled <- FALSE
[10:29:52.025]                       if (inherits(cond, "message")) {
[10:29:52.025]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.025]                         if (muffled) 
[10:29:52.025]                           invokeRestart("muffleMessage")
[10:29:52.025]                       }
[10:29:52.025]                       else if (inherits(cond, "warning")) {
[10:29:52.025]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.025]                         if (muffled) 
[10:29:52.025]                           invokeRestart("muffleWarning")
[10:29:52.025]                       }
[10:29:52.025]                       else if (inherits(cond, "condition")) {
[10:29:52.025]                         if (!is.null(pattern)) {
[10:29:52.025]                           computeRestarts <- base::computeRestarts
[10:29:52.025]                           grepl <- base::grepl
[10:29:52.025]                           restarts <- computeRestarts(cond)
[10:29:52.025]                           for (restart in restarts) {
[10:29:52.025]                             name <- restart$name
[10:29:52.025]                             if (is.null(name)) 
[10:29:52.025]                               next
[10:29:52.025]                             if (!grepl(pattern, name)) 
[10:29:52.025]                               next
[10:29:52.025]                             invokeRestart(restart)
[10:29:52.025]                             muffled <- TRUE
[10:29:52.025]                             break
[10:29:52.025]                           }
[10:29:52.025]                         }
[10:29:52.025]                       }
[10:29:52.025]                       invisible(muffled)
[10:29:52.025]                     }
[10:29:52.025]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.025]                   }
[10:29:52.025]                 }
[10:29:52.025]             }
[10:29:52.025]         }))
[10:29:52.025]     }, error = function(ex) {
[10:29:52.025]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:52.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.025]                 ...future.rng), started = ...future.startTime, 
[10:29:52.025]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:52.025]             version = "1.8"), class = "FutureResult")
[10:29:52.025]     }, finally = {
[10:29:52.025]         if (!identical(...future.workdir, getwd())) 
[10:29:52.025]             setwd(...future.workdir)
[10:29:52.025]         {
[10:29:52.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:52.025]                 ...future.oldOptions$nwarnings <- NULL
[10:29:52.025]             }
[10:29:52.025]             base::options(...future.oldOptions)
[10:29:52.025]             if (.Platform$OS.type == "windows") {
[10:29:52.025]                 old_names <- names(...future.oldEnvVars)
[10:29:52.025]                 envs <- base::Sys.getenv()
[10:29:52.025]                 names <- names(envs)
[10:29:52.025]                 common <- intersect(names, old_names)
[10:29:52.025]                 added <- setdiff(names, old_names)
[10:29:52.025]                 removed <- setdiff(old_names, names)
[10:29:52.025]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:52.025]                   envs[common]]
[10:29:52.025]                 NAMES <- toupper(changed)
[10:29:52.025]                 args <- list()
[10:29:52.025]                 for (kk in seq_along(NAMES)) {
[10:29:52.025]                   name <- changed[[kk]]
[10:29:52.025]                   NAME <- NAMES[[kk]]
[10:29:52.025]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.025]                     next
[10:29:52.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.025]                 }
[10:29:52.025]                 NAMES <- toupper(added)
[10:29:52.025]                 for (kk in seq_along(NAMES)) {
[10:29:52.025]                   name <- added[[kk]]
[10:29:52.025]                   NAME <- NAMES[[kk]]
[10:29:52.025]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.025]                     next
[10:29:52.025]                   args[[name]] <- ""
[10:29:52.025]                 }
[10:29:52.025]                 NAMES <- toupper(removed)
[10:29:52.025]                 for (kk in seq_along(NAMES)) {
[10:29:52.025]                   name <- removed[[kk]]
[10:29:52.025]                   NAME <- NAMES[[kk]]
[10:29:52.025]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.025]                     next
[10:29:52.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.025]                 }
[10:29:52.025]                 if (length(args) > 0) 
[10:29:52.025]                   base::do.call(base::Sys.setenv, args = args)
[10:29:52.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:52.025]             }
[10:29:52.025]             else {
[10:29:52.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:52.025]             }
[10:29:52.025]             {
[10:29:52.025]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:52.025]                   0L) {
[10:29:52.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:52.025]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:52.025]                   base::options(opts)
[10:29:52.025]                 }
[10:29:52.025]                 {
[10:29:52.025]                   {
[10:29:52.025]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:52.025]                     NULL
[10:29:52.025]                   }
[10:29:52.025]                   options(future.plan = NULL)
[10:29:52.025]                   if (is.na(NA_character_)) 
[10:29:52.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:52.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:52.025]                     .init = FALSE)
[10:29:52.025]                 }
[10:29:52.025]             }
[10:29:52.025]         }
[10:29:52.025]     })
[10:29:52.025]     if (TRUE) {
[10:29:52.025]         base::sink(type = "output", split = FALSE)
[10:29:52.025]         if (TRUE) {
[10:29:52.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:52.025]         }
[10:29:52.025]         else {
[10:29:52.025]             ...future.result["stdout"] <- base::list(NULL)
[10:29:52.025]         }
[10:29:52.025]         base::close(...future.stdout)
[10:29:52.025]         ...future.stdout <- NULL
[10:29:52.025]     }
[10:29:52.025]     ...future.result$conditions <- ...future.conditions
[10:29:52.025]     ...future.result$finished <- base::Sys.time()
[10:29:52.025]     ...future.result
[10:29:52.025] }
[10:29:52.028] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[10:29:52.028] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:52.029] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:52.029] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[10:29:52.029] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[10:29:52.029] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:29:52.030] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:29:52.030] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:52.030] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:52.030] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:29:52.030] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:29:52.031] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[10:29:52.031] MultisessionFuture started
[10:29:52.031] - Launch lazy future ... done
[10:29:52.031] run() for ‘MultisessionFuture’ ... done
[10:29:52.031] Created future:
[10:29:52.031] MultisessionFuture:
[10:29:52.031] Label: ‘future_apply-2’
[10:29:52.031] Expression:
[10:29:52.031] {
[10:29:52.031]     do.call(function(...) {
[10:29:52.031]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.031]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.031]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.031]             on.exit(options(oopts), add = TRUE)
[10:29:52.031]         }
[10:29:52.031]         {
[10:29:52.031]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.031]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.031]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.031]             })
[10:29:52.031]         }
[10:29:52.031]     }, args = future.call.arguments)
[10:29:52.031] }
[10:29:52.031] Lazy evaluation: FALSE
[10:29:52.031] Asynchronous evaluation: TRUE
[10:29:52.031] Local evaluation: TRUE
[10:29:52.031] Environment: R_GlobalEnv
[10:29:52.031] Capture standard output: TRUE
[10:29:52.031] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:52.031] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:52.031] Packages: <none>
[10:29:52.031] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:52.031] Resolved: FALSE
[10:29:52.031] Value: <not collected>
[10:29:52.031] Conditions captured: <none>
[10:29:52.031] Early signaling: FALSE
[10:29:52.031] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:52.031] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.043] Chunk #2 of 2 ... DONE
[10:29:52.043] Launching 2 futures (chunks) ... DONE
[10:29:52.043] Resolving 2 futures (chunks) ...
[10:29:52.043] resolve() on list ...
[10:29:52.043]  recursive: 0
[10:29:52.043]  length: 2
[10:29:52.044] 
[10:29:52.044] receiveMessageFromWorker() for ClusterFuture ...
[10:29:52.044] - Validating connection of MultisessionFuture
[10:29:52.044] - received message: FutureResult
[10:29:52.044] - Received FutureResult
[10:29:52.044] - Erased future from FutureRegistry
[10:29:52.045] result() for ClusterFuture ...
[10:29:52.045] - result already collected: FutureResult
[10:29:52.045] result() for ClusterFuture ... done
[10:29:52.045] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:52.045] Future #1
[10:29:52.045] result() for ClusterFuture ...
[10:29:52.045] - result already collected: FutureResult
[10:29:52.045] result() for ClusterFuture ... done
[10:29:52.045] result() for ClusterFuture ...
[10:29:52.045] - result already collected: FutureResult
[10:29:52.045] result() for ClusterFuture ... done
[10:29:52.046] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:52.046] - nx: 2
[10:29:52.046] - relay: TRUE
[10:29:52.046] - stdout: TRUE
[10:29:52.046] - signal: TRUE
[10:29:52.046] - resignal: FALSE
[10:29:52.046] - force: TRUE
[10:29:52.046] - relayed: [n=2] FALSE, FALSE
[10:29:52.046] - queued futures: [n=2] FALSE, FALSE
[10:29:52.046]  - until=1
[10:29:52.046]  - relaying element #1
[10:29:52.047] result() for ClusterFuture ...
[10:29:52.047] - result already collected: FutureResult
[10:29:52.047] result() for ClusterFuture ... done
[10:29:52.047] result() for ClusterFuture ...
[10:29:52.047] - result already collected: FutureResult
[10:29:52.047] result() for ClusterFuture ... done
[10:29:52.047] result() for ClusterFuture ...
[10:29:52.047] - result already collected: FutureResult
[10:29:52.047] result() for ClusterFuture ... done
[10:29:52.047] result() for ClusterFuture ...
[10:29:52.047] - result already collected: FutureResult
[10:29:52.048] result() for ClusterFuture ... done
[10:29:52.048] - relayed: [n=2] TRUE, FALSE
[10:29:52.048] - queued futures: [n=2] TRUE, FALSE
[10:29:52.048] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:52.048]  length: 1 (resolved future 1)
[10:29:52.078] receiveMessageFromWorker() for ClusterFuture ...
[10:29:52.079] - Validating connection of MultisessionFuture
[10:29:52.079] - received message: FutureResult
[10:29:52.079] - Received FutureResult
[10:29:52.079] - Erased future from FutureRegistry
[10:29:52.079] result() for ClusterFuture ...
[10:29:52.079] - result already collected: FutureResult
[10:29:52.079] result() for ClusterFuture ... done
[10:29:52.079] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:52.080] Future #2
[10:29:52.080] result() for ClusterFuture ...
[10:29:52.080] - result already collected: FutureResult
[10:29:52.080] result() for ClusterFuture ... done
[10:29:52.080] result() for ClusterFuture ...
[10:29:52.080] - result already collected: FutureResult
[10:29:52.080] result() for ClusterFuture ... done
[10:29:52.080] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:52.080] - nx: 2
[10:29:52.080] - relay: TRUE
[10:29:52.080] - stdout: TRUE
[10:29:52.081] - signal: TRUE
[10:29:52.081] - resignal: FALSE
[10:29:52.081] - force: TRUE
[10:29:52.081] - relayed: [n=2] TRUE, FALSE
[10:29:52.081] - queued futures: [n=2] TRUE, FALSE
[10:29:52.081]  - until=2
[10:29:52.081]  - relaying element #2
[10:29:52.081] result() for ClusterFuture ...
[10:29:52.081] - result already collected: FutureResult
[10:29:52.081] result() for ClusterFuture ... done
[10:29:52.081] result() for ClusterFuture ...
[10:29:52.082] - result already collected: FutureResult
[10:29:52.082] result() for ClusterFuture ... done
[10:29:52.082] result() for ClusterFuture ...
[10:29:52.082] - result already collected: FutureResult
[10:29:52.082] result() for ClusterFuture ... done
[10:29:52.082] result() for ClusterFuture ...
[10:29:52.082] - result already collected: FutureResult
[10:29:52.082] result() for ClusterFuture ... done
[10:29:52.082] - relayed: [n=2] TRUE, TRUE
[10:29:52.082] - queued futures: [n=2] TRUE, TRUE
[10:29:52.082] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:52.083]  length: 0 (resolved future 2)
[10:29:52.083] Relaying remaining futures
[10:29:52.083] signalConditionsASAP(NULL, pos=0) ...
[10:29:52.083] - nx: 2
[10:29:52.083] - relay: TRUE
[10:29:52.083] - stdout: TRUE
[10:29:52.083] - signal: TRUE
[10:29:52.083] - resignal: FALSE
[10:29:52.083] - force: TRUE
[10:29:52.083] - relayed: [n=2] TRUE, TRUE
[10:29:52.083] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:52.084] - relayed: [n=2] TRUE, TRUE
[10:29:52.084] - queued futures: [n=2] TRUE, TRUE
[10:29:52.084] signalConditionsASAP(NULL, pos=0) ... done
[10:29:52.084] resolve() on list ... DONE
[10:29:52.084] result() for ClusterFuture ...
[10:29:52.084] - result already collected: FutureResult
[10:29:52.084] result() for ClusterFuture ... done
[10:29:52.084] result() for ClusterFuture ...
[10:29:52.084] - result already collected: FutureResult
[10:29:52.084] result() for ClusterFuture ... done
[10:29:52.084] result() for ClusterFuture ...
[10:29:52.085] - result already collected: FutureResult
[10:29:52.085] result() for ClusterFuture ... done
[10:29:52.085] result() for ClusterFuture ...
[10:29:52.085] - result already collected: FutureResult
[10:29:52.085] result() for ClusterFuture ... done
[10:29:52.085]  - Number of value chunks collected: 2
[10:29:52.085] Resolving 2 futures (chunks) ... DONE
[10:29:52.085] Reducing values from 2 chunks ...
[10:29:52.085]  - Number of values collected after concatenation: 2
[10:29:52.085]  - Number of values expected: 2
[10:29:52.085] Reducing values from 2 chunks ... DONE
[10:29:52.086] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:29:52.086] getGlobalsAndPackagesXApply() ...
[10:29:52.086]  - future.globals: TRUE
[10:29:52.086] getGlobalsAndPackages() ...
[10:29:52.086] Searching for globals...
[10:29:52.087] - globals found: [1] ‘FUN’
[10:29:52.087] Searching for globals ... DONE
[10:29:52.087] Resolving globals: FALSE
[10:29:52.088] The total size of the 1 globals is 848 bytes (848 bytes)
[10:29:52.088] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:29:52.088] - globals: [1] ‘FUN’
[10:29:52.088] 
[10:29:52.088] getGlobalsAndPackages() ... DONE
[10:29:52.088]  - globals found/used: [n=1] ‘FUN’
[10:29:52.089]  - needed namespaces: [n=0] 
[10:29:52.089] Finding globals ... DONE
[10:29:52.089]  - use_args: TRUE
[10:29:52.089]  - Getting '...' globals ...
[10:29:52.089] resolve() on list ...
[10:29:52.089]  recursive: 0
[10:29:52.089]  length: 1
[10:29:52.090]  elements: ‘...’
[10:29:52.090]  length: 0 (resolved future 1)
[10:29:52.090] resolve() on list ... DONE
[10:29:52.090]    - '...' content: [n=0] 
[10:29:52.090] List of 1
[10:29:52.090]  $ ...: list()
[10:29:52.090]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.090]  - attr(*, "where")=List of 1
[10:29:52.090]   ..$ ...:<environment: 0x5618a3a536c8> 
[10:29:52.090]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.090]  - attr(*, "resolved")= logi TRUE
[10:29:52.090]  - attr(*, "total_size")= num NA
[10:29:52.092]  - Getting '...' globals ... DONE
[10:29:52.093] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:52.093] List of 2
[10:29:52.093]  $ ...future.FUN:function (x)  
[10:29:52.093]  $ ...          : list()
[10:29:52.093]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.093]  - attr(*, "where")=List of 2
[10:29:52.093]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:52.093]   ..$ ...          :<environment: 0x5618a3a536c8> 
[10:29:52.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.093]  - attr(*, "resolved")= logi FALSE
[10:29:52.093]  - attr(*, "total_size")= num 848
[10:29:52.095] Packages to be attached in all futures: [n=0] 
[10:29:52.095] getGlobalsAndPackagesXApply() ... DONE
[10:29:52.099] future_lapply() ...
[10:29:52.103] Number of chunks: 2
[10:29:52.103] getGlobalsAndPackagesXApply() ...
[10:29:52.103]  - future.globals: <name-value list> with names ‘list()’
[10:29:52.103]  - use_args: TRUE
[10:29:52.103] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:52.103] List of 2
[10:29:52.103]  $ ...          : list()
[10:29:52.103]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.103]  $ ...future.FUN:function (x)  
[10:29:52.103]  - attr(*, "where")=List of 2
[10:29:52.103]   ..$ ...          :<environment: 0x5618a3a536c8> 
[10:29:52.103]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:52.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.103]  - attr(*, "resolved")= logi FALSE
[10:29:52.103]  - attr(*, "total_size")= num NA
[10:29:52.108] Packages to be attached in all futures: [n=0] 
[10:29:52.109] getGlobalsAndPackagesXApply() ... DONE
[10:29:52.109] Number of futures (= number of chunks): 2
[10:29:52.109] Launching 2 futures (chunks) ...
[10:29:52.109] Chunk #1 of 2 ...
[10:29:52.109]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:52.109]  - seeds: <none>
[10:29:52.109]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.109] getGlobalsAndPackages() ...
[10:29:52.110] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.110] Resolving globals: FALSE
[10:29:52.110] Tweak future expression to call with '...' arguments ...
[10:29:52.110] {
[10:29:52.110]     do.call(function(...) {
[10:29:52.110]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.110]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.110]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.110]             on.exit(options(oopts), add = TRUE)
[10:29:52.110]         }
[10:29:52.110]         {
[10:29:52.110]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.110]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.110]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.110]             })
[10:29:52.110]         }
[10:29:52.110]     }, args = future.call.arguments)
[10:29:52.110] }
[10:29:52.110] Tweak future expression to call with '...' arguments ... DONE
[10:29:52.111] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.111] 
[10:29:52.111] getGlobalsAndPackages() ... DONE
[10:29:52.111] run() for ‘Future’ ...
[10:29:52.111] - state: ‘created’
[10:29:52.111] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:52.125] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.125] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:52.125]   - Field: ‘node’
[10:29:52.125]   - Field: ‘label’
[10:29:52.125]   - Field: ‘local’
[10:29:52.125]   - Field: ‘owner’
[10:29:52.125]   - Field: ‘envir’
[10:29:52.125]   - Field: ‘workers’
[10:29:52.126]   - Field: ‘packages’
[10:29:52.126]   - Field: ‘gc’
[10:29:52.126]   - Field: ‘conditions’
[10:29:52.126]   - Field: ‘persistent’
[10:29:52.126]   - Field: ‘expr’
[10:29:52.126]   - Field: ‘uuid’
[10:29:52.126]   - Field: ‘seed’
[10:29:52.126]   - Field: ‘version’
[10:29:52.126]   - Field: ‘result’
[10:29:52.126]   - Field: ‘asynchronous’
[10:29:52.126]   - Field: ‘calls’
[10:29:52.127]   - Field: ‘globals’
[10:29:52.127]   - Field: ‘stdout’
[10:29:52.127]   - Field: ‘earlySignal’
[10:29:52.127]   - Field: ‘lazy’
[10:29:52.127]   - Field: ‘state’
[10:29:52.127] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:52.127] - Launch lazy future ...
[10:29:52.127] Packages needed by the future expression (n = 0): <none>
[10:29:52.127] Packages needed by future strategies (n = 0): <none>
[10:29:52.128] {
[10:29:52.128]     {
[10:29:52.128]         {
[10:29:52.128]             ...future.startTime <- base::Sys.time()
[10:29:52.128]             {
[10:29:52.128]                 {
[10:29:52.128]                   {
[10:29:52.128]                     {
[10:29:52.128]                       base::local({
[10:29:52.128]                         has_future <- base::requireNamespace("future", 
[10:29:52.128]                           quietly = TRUE)
[10:29:52.128]                         if (has_future) {
[10:29:52.128]                           ns <- base::getNamespace("future")
[10:29:52.128]                           version <- ns[[".package"]][["version"]]
[10:29:52.128]                           if (is.null(version)) 
[10:29:52.128]                             version <- utils::packageVersion("future")
[10:29:52.128]                         }
[10:29:52.128]                         else {
[10:29:52.128]                           version <- NULL
[10:29:52.128]                         }
[10:29:52.128]                         if (!has_future || version < "1.8.0") {
[10:29:52.128]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:52.128]                             "", base::R.version$version.string), 
[10:29:52.128]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:52.128]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:52.128]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:52.128]                               "release", "version")], collapse = " "), 
[10:29:52.128]                             hostname = base::Sys.info()[["nodename"]])
[10:29:52.128]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:52.128]                             info)
[10:29:52.128]                           info <- base::paste(info, collapse = "; ")
[10:29:52.128]                           if (!has_future) {
[10:29:52.128]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:52.128]                               info)
[10:29:52.128]                           }
[10:29:52.128]                           else {
[10:29:52.128]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:52.128]                               info, version)
[10:29:52.128]                           }
[10:29:52.128]                           base::stop(msg)
[10:29:52.128]                         }
[10:29:52.128]                       })
[10:29:52.128]                     }
[10:29:52.128]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:52.128]                     base::options(mc.cores = 1L)
[10:29:52.128]                   }
[10:29:52.128]                   ...future.strategy.old <- future::plan("list")
[10:29:52.128]                   options(future.plan = NULL)
[10:29:52.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:52.128]                 }
[10:29:52.128]                 ...future.workdir <- getwd()
[10:29:52.128]             }
[10:29:52.128]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:52.128]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:52.128]         }
[10:29:52.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:52.128]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:52.128]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:52.128]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:52.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:52.128]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:52.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:52.128]             base::names(...future.oldOptions))
[10:29:52.128]     }
[10:29:52.128]     if (FALSE) {
[10:29:52.128]     }
[10:29:52.128]     else {
[10:29:52.128]         if (TRUE) {
[10:29:52.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:52.128]                 open = "w")
[10:29:52.128]         }
[10:29:52.128]         else {
[10:29:52.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:52.128]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:52.128]         }
[10:29:52.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:52.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:52.128]             base::sink(type = "output", split = FALSE)
[10:29:52.128]             base::close(...future.stdout)
[10:29:52.128]         }, add = TRUE)
[10:29:52.128]     }
[10:29:52.128]     ...future.frame <- base::sys.nframe()
[10:29:52.128]     ...future.conditions <- base::list()
[10:29:52.128]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:52.128]     if (FALSE) {
[10:29:52.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:52.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:52.128]     }
[10:29:52.128]     ...future.result <- base::tryCatch({
[10:29:52.128]         base::withCallingHandlers({
[10:29:52.128]             ...future.value <- base::withVisible(base::local({
[10:29:52.128]                 ...future.makeSendCondition <- base::local({
[10:29:52.128]                   sendCondition <- NULL
[10:29:52.128]                   function(frame = 1L) {
[10:29:52.128]                     if (is.function(sendCondition)) 
[10:29:52.128]                       return(sendCondition)
[10:29:52.128]                     ns <- getNamespace("parallel")
[10:29:52.128]                     if (exists("sendData", mode = "function", 
[10:29:52.128]                       envir = ns)) {
[10:29:52.128]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:52.128]                         envir = ns)
[10:29:52.128]                       envir <- sys.frame(frame)
[10:29:52.128]                       master <- NULL
[10:29:52.128]                       while (!identical(envir, .GlobalEnv) && 
[10:29:52.128]                         !identical(envir, emptyenv())) {
[10:29:52.128]                         if (exists("master", mode = "list", envir = envir, 
[10:29:52.128]                           inherits = FALSE)) {
[10:29:52.128]                           master <- get("master", mode = "list", 
[10:29:52.128]                             envir = envir, inherits = FALSE)
[10:29:52.128]                           if (inherits(master, c("SOCKnode", 
[10:29:52.128]                             "SOCK0node"))) {
[10:29:52.128]                             sendCondition <<- function(cond) {
[10:29:52.128]                               data <- list(type = "VALUE", value = cond, 
[10:29:52.128]                                 success = TRUE)
[10:29:52.128]                               parallel_sendData(master, data)
[10:29:52.128]                             }
[10:29:52.128]                             return(sendCondition)
[10:29:52.128]                           }
[10:29:52.128]                         }
[10:29:52.128]                         frame <- frame + 1L
[10:29:52.128]                         envir <- sys.frame(frame)
[10:29:52.128]                       }
[10:29:52.128]                     }
[10:29:52.128]                     sendCondition <<- function(cond) NULL
[10:29:52.128]                   }
[10:29:52.128]                 })
[10:29:52.128]                 withCallingHandlers({
[10:29:52.128]                   {
[10:29:52.128]                     do.call(function(...) {
[10:29:52.128]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.128]                       if (!identical(...future.globals.maxSize.org, 
[10:29:52.128]                         ...future.globals.maxSize)) {
[10:29:52.128]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.128]                         on.exit(options(oopts), add = TRUE)
[10:29:52.128]                       }
[10:29:52.128]                       {
[10:29:52.128]                         lapply(seq_along(...future.elements_ii), 
[10:29:52.128]                           FUN = function(jj) {
[10:29:52.128]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.128]                             ...future.FUN(...future.X_jj, ...)
[10:29:52.128]                           })
[10:29:52.128]                       }
[10:29:52.128]                     }, args = future.call.arguments)
[10:29:52.128]                   }
[10:29:52.128]                 }, immediateCondition = function(cond) {
[10:29:52.128]                   sendCondition <- ...future.makeSendCondition()
[10:29:52.128]                   sendCondition(cond)
[10:29:52.128]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.128]                   {
[10:29:52.128]                     inherits <- base::inherits
[10:29:52.128]                     invokeRestart <- base::invokeRestart
[10:29:52.128]                     is.null <- base::is.null
[10:29:52.128]                     muffled <- FALSE
[10:29:52.128]                     if (inherits(cond, "message")) {
[10:29:52.128]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:52.128]                       if (muffled) 
[10:29:52.128]                         invokeRestart("muffleMessage")
[10:29:52.128]                     }
[10:29:52.128]                     else if (inherits(cond, "warning")) {
[10:29:52.128]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:52.128]                       if (muffled) 
[10:29:52.128]                         invokeRestart("muffleWarning")
[10:29:52.128]                     }
[10:29:52.128]                     else if (inherits(cond, "condition")) {
[10:29:52.128]                       if (!is.null(pattern)) {
[10:29:52.128]                         computeRestarts <- base::computeRestarts
[10:29:52.128]                         grepl <- base::grepl
[10:29:52.128]                         restarts <- computeRestarts(cond)
[10:29:52.128]                         for (restart in restarts) {
[10:29:52.128]                           name <- restart$name
[10:29:52.128]                           if (is.null(name)) 
[10:29:52.128]                             next
[10:29:52.128]                           if (!grepl(pattern, name)) 
[10:29:52.128]                             next
[10:29:52.128]                           invokeRestart(restart)
[10:29:52.128]                           muffled <- TRUE
[10:29:52.128]                           break
[10:29:52.128]                         }
[10:29:52.128]                       }
[10:29:52.128]                     }
[10:29:52.128]                     invisible(muffled)
[10:29:52.128]                   }
[10:29:52.128]                   muffleCondition(cond)
[10:29:52.128]                 })
[10:29:52.128]             }))
[10:29:52.128]             future::FutureResult(value = ...future.value$value, 
[10:29:52.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.128]                   ...future.rng), globalenv = if (FALSE) 
[10:29:52.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:52.128]                     ...future.globalenv.names))
[10:29:52.128]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:52.128]         }, condition = base::local({
[10:29:52.128]             c <- base::c
[10:29:52.128]             inherits <- base::inherits
[10:29:52.128]             invokeRestart <- base::invokeRestart
[10:29:52.128]             length <- base::length
[10:29:52.128]             list <- base::list
[10:29:52.128]             seq.int <- base::seq.int
[10:29:52.128]             signalCondition <- base::signalCondition
[10:29:52.128]             sys.calls <- base::sys.calls
[10:29:52.128]             `[[` <- base::`[[`
[10:29:52.128]             `+` <- base::`+`
[10:29:52.128]             `<<-` <- base::`<<-`
[10:29:52.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:52.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:52.128]                   3L)]
[10:29:52.128]             }
[10:29:52.128]             function(cond) {
[10:29:52.128]                 is_error <- inherits(cond, "error")
[10:29:52.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:52.128]                   NULL)
[10:29:52.128]                 if (is_error) {
[10:29:52.128]                   sessionInformation <- function() {
[10:29:52.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:52.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:52.128]                       search = base::search(), system = base::Sys.info())
[10:29:52.128]                   }
[10:29:52.128]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:52.128]                     cond$call), session = sessionInformation(), 
[10:29:52.128]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:52.128]                   signalCondition(cond)
[10:29:52.128]                 }
[10:29:52.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:52.128]                 "immediateCondition"))) {
[10:29:52.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:52.128]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:52.128]                   if (TRUE && !signal) {
[10:29:52.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.128]                     {
[10:29:52.128]                       inherits <- base::inherits
[10:29:52.128]                       invokeRestart <- base::invokeRestart
[10:29:52.128]                       is.null <- base::is.null
[10:29:52.128]                       muffled <- FALSE
[10:29:52.128]                       if (inherits(cond, "message")) {
[10:29:52.128]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.128]                         if (muffled) 
[10:29:52.128]                           invokeRestart("muffleMessage")
[10:29:52.128]                       }
[10:29:52.128]                       else if (inherits(cond, "warning")) {
[10:29:52.128]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.128]                         if (muffled) 
[10:29:52.128]                           invokeRestart("muffleWarning")
[10:29:52.128]                       }
[10:29:52.128]                       else if (inherits(cond, "condition")) {
[10:29:52.128]                         if (!is.null(pattern)) {
[10:29:52.128]                           computeRestarts <- base::computeRestarts
[10:29:52.128]                           grepl <- base::grepl
[10:29:52.128]                           restarts <- computeRestarts(cond)
[10:29:52.128]                           for (restart in restarts) {
[10:29:52.128]                             name <- restart$name
[10:29:52.128]                             if (is.null(name)) 
[10:29:52.128]                               next
[10:29:52.128]                             if (!grepl(pattern, name)) 
[10:29:52.128]                               next
[10:29:52.128]                             invokeRestart(restart)
[10:29:52.128]                             muffled <- TRUE
[10:29:52.128]                             break
[10:29:52.128]                           }
[10:29:52.128]                         }
[10:29:52.128]                       }
[10:29:52.128]                       invisible(muffled)
[10:29:52.128]                     }
[10:29:52.128]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.128]                   }
[10:29:52.128]                 }
[10:29:52.128]                 else {
[10:29:52.128]                   if (TRUE) {
[10:29:52.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.128]                     {
[10:29:52.128]                       inherits <- base::inherits
[10:29:52.128]                       invokeRestart <- base::invokeRestart
[10:29:52.128]                       is.null <- base::is.null
[10:29:52.128]                       muffled <- FALSE
[10:29:52.128]                       if (inherits(cond, "message")) {
[10:29:52.128]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.128]                         if (muffled) 
[10:29:52.128]                           invokeRestart("muffleMessage")
[10:29:52.128]                       }
[10:29:52.128]                       else if (inherits(cond, "warning")) {
[10:29:52.128]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.128]                         if (muffled) 
[10:29:52.128]                           invokeRestart("muffleWarning")
[10:29:52.128]                       }
[10:29:52.128]                       else if (inherits(cond, "condition")) {
[10:29:52.128]                         if (!is.null(pattern)) {
[10:29:52.128]                           computeRestarts <- base::computeRestarts
[10:29:52.128]                           grepl <- base::grepl
[10:29:52.128]                           restarts <- computeRestarts(cond)
[10:29:52.128]                           for (restart in restarts) {
[10:29:52.128]                             name <- restart$name
[10:29:52.128]                             if (is.null(name)) 
[10:29:52.128]                               next
[10:29:52.128]                             if (!grepl(pattern, name)) 
[10:29:52.128]                               next
[10:29:52.128]                             invokeRestart(restart)
[10:29:52.128]                             muffled <- TRUE
[10:29:52.128]                             break
[10:29:52.128]                           }
[10:29:52.128]                         }
[10:29:52.128]                       }
[10:29:52.128]                       invisible(muffled)
[10:29:52.128]                     }
[10:29:52.128]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.128]                   }
[10:29:52.128]                 }
[10:29:52.128]             }
[10:29:52.128]         }))
[10:29:52.128]     }, error = function(ex) {
[10:29:52.128]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:52.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.128]                 ...future.rng), started = ...future.startTime, 
[10:29:52.128]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:52.128]             version = "1.8"), class = "FutureResult")
[10:29:52.128]     }, finally = {
[10:29:52.128]         if (!identical(...future.workdir, getwd())) 
[10:29:52.128]             setwd(...future.workdir)
[10:29:52.128]         {
[10:29:52.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:52.128]                 ...future.oldOptions$nwarnings <- NULL
[10:29:52.128]             }
[10:29:52.128]             base::options(...future.oldOptions)
[10:29:52.128]             if (.Platform$OS.type == "windows") {
[10:29:52.128]                 old_names <- names(...future.oldEnvVars)
[10:29:52.128]                 envs <- base::Sys.getenv()
[10:29:52.128]                 names <- names(envs)
[10:29:52.128]                 common <- intersect(names, old_names)
[10:29:52.128]                 added <- setdiff(names, old_names)
[10:29:52.128]                 removed <- setdiff(old_names, names)
[10:29:52.128]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:52.128]                   envs[common]]
[10:29:52.128]                 NAMES <- toupper(changed)
[10:29:52.128]                 args <- list()
[10:29:52.128]                 for (kk in seq_along(NAMES)) {
[10:29:52.128]                   name <- changed[[kk]]
[10:29:52.128]                   NAME <- NAMES[[kk]]
[10:29:52.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.128]                     next
[10:29:52.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.128]                 }
[10:29:52.128]                 NAMES <- toupper(added)
[10:29:52.128]                 for (kk in seq_along(NAMES)) {
[10:29:52.128]                   name <- added[[kk]]
[10:29:52.128]                   NAME <- NAMES[[kk]]
[10:29:52.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.128]                     next
[10:29:52.128]                   args[[name]] <- ""
[10:29:52.128]                 }
[10:29:52.128]                 NAMES <- toupper(removed)
[10:29:52.128]                 for (kk in seq_along(NAMES)) {
[10:29:52.128]                   name <- removed[[kk]]
[10:29:52.128]                   NAME <- NAMES[[kk]]
[10:29:52.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.128]                     next
[10:29:52.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.128]                 }
[10:29:52.128]                 if (length(args) > 0) 
[10:29:52.128]                   base::do.call(base::Sys.setenv, args = args)
[10:29:52.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:52.128]             }
[10:29:52.128]             else {
[10:29:52.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:52.128]             }
[10:29:52.128]             {
[10:29:52.128]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:52.128]                   0L) {
[10:29:52.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:52.128]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:52.128]                   base::options(opts)
[10:29:52.128]                 }
[10:29:52.128]                 {
[10:29:52.128]                   {
[10:29:52.128]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:52.128]                     NULL
[10:29:52.128]                   }
[10:29:52.128]                   options(future.plan = NULL)
[10:29:52.128]                   if (is.na(NA_character_)) 
[10:29:52.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:52.128]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:52.128]                     .init = FALSE)
[10:29:52.128]                 }
[10:29:52.128]             }
[10:29:52.128]         }
[10:29:52.128]     })
[10:29:52.128]     if (TRUE) {
[10:29:52.128]         base::sink(type = "output", split = FALSE)
[10:29:52.128]         if (TRUE) {
[10:29:52.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:52.128]         }
[10:29:52.128]         else {
[10:29:52.128]             ...future.result["stdout"] <- base::list(NULL)
[10:29:52.128]         }
[10:29:52.128]         base::close(...future.stdout)
[10:29:52.128]         ...future.stdout <- NULL
[10:29:52.128]     }
[10:29:52.128]     ...future.result$conditions <- ...future.conditions
[10:29:52.128]     ...future.result$finished <- base::Sys.time()
[10:29:52.128]     ...future.result
[10:29:52.128] }
[10:29:52.131] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[10:29:52.131] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:52.131] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:52.131] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:29:52.132] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:29:52.132] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[10:29:52.132] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[10:29:52.132] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:52.133] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:52.133] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:52.133] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:52.133] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[10:29:52.134] MultisessionFuture started
[10:29:52.134] - Launch lazy future ... done
[10:29:52.134] run() for ‘MultisessionFuture’ ... done
[10:29:52.134] Created future:
[10:29:52.134] MultisessionFuture:
[10:29:52.134] Label: ‘future_apply-1’
[10:29:52.134] Expression:
[10:29:52.134] {
[10:29:52.134]     do.call(function(...) {
[10:29:52.134]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.134]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.134]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.134]             on.exit(options(oopts), add = TRUE)
[10:29:52.134]         }
[10:29:52.134]         {
[10:29:52.134]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.134]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.134]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.134]             })
[10:29:52.134]         }
[10:29:52.134]     }, args = future.call.arguments)
[10:29:52.134] }
[10:29:52.134] Lazy evaluation: FALSE
[10:29:52.134] Asynchronous evaluation: TRUE
[10:29:52.134] Local evaluation: TRUE
[10:29:52.134] Environment: R_GlobalEnv
[10:29:52.134] Capture standard output: TRUE
[10:29:52.134] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:52.134] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:52.134] Packages: <none>
[10:29:52.134] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:52.134] Resolved: FALSE
[10:29:52.134] Value: <not collected>
[10:29:52.134] Conditions captured: <none>
[10:29:52.134] Early signaling: FALSE
[10:29:52.134] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:52.134] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.146] Chunk #1 of 2 ... DONE
[10:29:52.146] Chunk #2 of 2 ...
[10:29:52.146]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:52.146]  - seeds: <none>
[10:29:52.146]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.146] getGlobalsAndPackages() ...
[10:29:52.146] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.146] Resolving globals: FALSE
[10:29:52.146] Tweak future expression to call with '...' arguments ...
[10:29:52.147] {
[10:29:52.147]     do.call(function(...) {
[10:29:52.147]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.147]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.147]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.147]             on.exit(options(oopts), add = TRUE)
[10:29:52.147]         }
[10:29:52.147]         {
[10:29:52.147]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.147]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.147]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.147]             })
[10:29:52.147]         }
[10:29:52.147]     }, args = future.call.arguments)
[10:29:52.147] }
[10:29:52.147] Tweak future expression to call with '...' arguments ... DONE
[10:29:52.147] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.147] 
[10:29:52.147] getGlobalsAndPackages() ... DONE
[10:29:52.148] run() for ‘Future’ ...
[10:29:52.148] - state: ‘created’
[10:29:52.148] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:52.162] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.162] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:52.163]   - Field: ‘node’
[10:29:52.163]   - Field: ‘label’
[10:29:52.163]   - Field: ‘local’
[10:29:52.163]   - Field: ‘owner’
[10:29:52.163]   - Field: ‘envir’
[10:29:52.163]   - Field: ‘workers’
[10:29:52.163]   - Field: ‘packages’
[10:29:52.163]   - Field: ‘gc’
[10:29:52.163]   - Field: ‘conditions’
[10:29:52.163]   - Field: ‘persistent’
[10:29:52.164]   - Field: ‘expr’
[10:29:52.164]   - Field: ‘uuid’
[10:29:52.164]   - Field: ‘seed’
[10:29:52.164]   - Field: ‘version’
[10:29:52.164]   - Field: ‘result’
[10:29:52.164]   - Field: ‘asynchronous’
[10:29:52.164]   - Field: ‘calls’
[10:29:52.164]   - Field: ‘globals’
[10:29:52.164]   - Field: ‘stdout’
[10:29:52.164]   - Field: ‘earlySignal’
[10:29:52.164]   - Field: ‘lazy’
[10:29:52.165]   - Field: ‘state’
[10:29:52.165] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:52.165] - Launch lazy future ...
[10:29:52.165] Packages needed by the future expression (n = 0): <none>
[10:29:52.165] Packages needed by future strategies (n = 0): <none>
[10:29:52.166] {
[10:29:52.166]     {
[10:29:52.166]         {
[10:29:52.166]             ...future.startTime <- base::Sys.time()
[10:29:52.166]             {
[10:29:52.166]                 {
[10:29:52.166]                   {
[10:29:52.166]                     {
[10:29:52.166]                       base::local({
[10:29:52.166]                         has_future <- base::requireNamespace("future", 
[10:29:52.166]                           quietly = TRUE)
[10:29:52.166]                         if (has_future) {
[10:29:52.166]                           ns <- base::getNamespace("future")
[10:29:52.166]                           version <- ns[[".package"]][["version"]]
[10:29:52.166]                           if (is.null(version)) 
[10:29:52.166]                             version <- utils::packageVersion("future")
[10:29:52.166]                         }
[10:29:52.166]                         else {
[10:29:52.166]                           version <- NULL
[10:29:52.166]                         }
[10:29:52.166]                         if (!has_future || version < "1.8.0") {
[10:29:52.166]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:52.166]                             "", base::R.version$version.string), 
[10:29:52.166]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:52.166]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:52.166]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:52.166]                               "release", "version")], collapse = " "), 
[10:29:52.166]                             hostname = base::Sys.info()[["nodename"]])
[10:29:52.166]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:52.166]                             info)
[10:29:52.166]                           info <- base::paste(info, collapse = "; ")
[10:29:52.166]                           if (!has_future) {
[10:29:52.166]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:52.166]                               info)
[10:29:52.166]                           }
[10:29:52.166]                           else {
[10:29:52.166]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:52.166]                               info, version)
[10:29:52.166]                           }
[10:29:52.166]                           base::stop(msg)
[10:29:52.166]                         }
[10:29:52.166]                       })
[10:29:52.166]                     }
[10:29:52.166]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:52.166]                     base::options(mc.cores = 1L)
[10:29:52.166]                   }
[10:29:52.166]                   ...future.strategy.old <- future::plan("list")
[10:29:52.166]                   options(future.plan = NULL)
[10:29:52.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:52.166]                 }
[10:29:52.166]                 ...future.workdir <- getwd()
[10:29:52.166]             }
[10:29:52.166]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:52.166]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:52.166]         }
[10:29:52.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:52.166]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:52.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:52.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:52.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:52.166]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:52.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:52.166]             base::names(...future.oldOptions))
[10:29:52.166]     }
[10:29:52.166]     if (FALSE) {
[10:29:52.166]     }
[10:29:52.166]     else {
[10:29:52.166]         if (TRUE) {
[10:29:52.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:52.166]                 open = "w")
[10:29:52.166]         }
[10:29:52.166]         else {
[10:29:52.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:52.166]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:52.166]         }
[10:29:52.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:52.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:52.166]             base::sink(type = "output", split = FALSE)
[10:29:52.166]             base::close(...future.stdout)
[10:29:52.166]         }, add = TRUE)
[10:29:52.166]     }
[10:29:52.166]     ...future.frame <- base::sys.nframe()
[10:29:52.166]     ...future.conditions <- base::list()
[10:29:52.166]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:52.166]     if (FALSE) {
[10:29:52.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:52.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:52.166]     }
[10:29:52.166]     ...future.result <- base::tryCatch({
[10:29:52.166]         base::withCallingHandlers({
[10:29:52.166]             ...future.value <- base::withVisible(base::local({
[10:29:52.166]                 ...future.makeSendCondition <- base::local({
[10:29:52.166]                   sendCondition <- NULL
[10:29:52.166]                   function(frame = 1L) {
[10:29:52.166]                     if (is.function(sendCondition)) 
[10:29:52.166]                       return(sendCondition)
[10:29:52.166]                     ns <- getNamespace("parallel")
[10:29:52.166]                     if (exists("sendData", mode = "function", 
[10:29:52.166]                       envir = ns)) {
[10:29:52.166]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:52.166]                         envir = ns)
[10:29:52.166]                       envir <- sys.frame(frame)
[10:29:52.166]                       master <- NULL
[10:29:52.166]                       while (!identical(envir, .GlobalEnv) && 
[10:29:52.166]                         !identical(envir, emptyenv())) {
[10:29:52.166]                         if (exists("master", mode = "list", envir = envir, 
[10:29:52.166]                           inherits = FALSE)) {
[10:29:52.166]                           master <- get("master", mode = "list", 
[10:29:52.166]                             envir = envir, inherits = FALSE)
[10:29:52.166]                           if (inherits(master, c("SOCKnode", 
[10:29:52.166]                             "SOCK0node"))) {
[10:29:52.166]                             sendCondition <<- function(cond) {
[10:29:52.166]                               data <- list(type = "VALUE", value = cond, 
[10:29:52.166]                                 success = TRUE)
[10:29:52.166]                               parallel_sendData(master, data)
[10:29:52.166]                             }
[10:29:52.166]                             return(sendCondition)
[10:29:52.166]                           }
[10:29:52.166]                         }
[10:29:52.166]                         frame <- frame + 1L
[10:29:52.166]                         envir <- sys.frame(frame)
[10:29:52.166]                       }
[10:29:52.166]                     }
[10:29:52.166]                     sendCondition <<- function(cond) NULL
[10:29:52.166]                   }
[10:29:52.166]                 })
[10:29:52.166]                 withCallingHandlers({
[10:29:52.166]                   {
[10:29:52.166]                     do.call(function(...) {
[10:29:52.166]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.166]                       if (!identical(...future.globals.maxSize.org, 
[10:29:52.166]                         ...future.globals.maxSize)) {
[10:29:52.166]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.166]                         on.exit(options(oopts), add = TRUE)
[10:29:52.166]                       }
[10:29:52.166]                       {
[10:29:52.166]                         lapply(seq_along(...future.elements_ii), 
[10:29:52.166]                           FUN = function(jj) {
[10:29:52.166]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.166]                             ...future.FUN(...future.X_jj, ...)
[10:29:52.166]                           })
[10:29:52.166]                       }
[10:29:52.166]                     }, args = future.call.arguments)
[10:29:52.166]                   }
[10:29:52.166]                 }, immediateCondition = function(cond) {
[10:29:52.166]                   sendCondition <- ...future.makeSendCondition()
[10:29:52.166]                   sendCondition(cond)
[10:29:52.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.166]                   {
[10:29:52.166]                     inherits <- base::inherits
[10:29:52.166]                     invokeRestart <- base::invokeRestart
[10:29:52.166]                     is.null <- base::is.null
[10:29:52.166]                     muffled <- FALSE
[10:29:52.166]                     if (inherits(cond, "message")) {
[10:29:52.166]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:52.166]                       if (muffled) 
[10:29:52.166]                         invokeRestart("muffleMessage")
[10:29:52.166]                     }
[10:29:52.166]                     else if (inherits(cond, "warning")) {
[10:29:52.166]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:52.166]                       if (muffled) 
[10:29:52.166]                         invokeRestart("muffleWarning")
[10:29:52.166]                     }
[10:29:52.166]                     else if (inherits(cond, "condition")) {
[10:29:52.166]                       if (!is.null(pattern)) {
[10:29:52.166]                         computeRestarts <- base::computeRestarts
[10:29:52.166]                         grepl <- base::grepl
[10:29:52.166]                         restarts <- computeRestarts(cond)
[10:29:52.166]                         for (restart in restarts) {
[10:29:52.166]                           name <- restart$name
[10:29:52.166]                           if (is.null(name)) 
[10:29:52.166]                             next
[10:29:52.166]                           if (!grepl(pattern, name)) 
[10:29:52.166]                             next
[10:29:52.166]                           invokeRestart(restart)
[10:29:52.166]                           muffled <- TRUE
[10:29:52.166]                           break
[10:29:52.166]                         }
[10:29:52.166]                       }
[10:29:52.166]                     }
[10:29:52.166]                     invisible(muffled)
[10:29:52.166]                   }
[10:29:52.166]                   muffleCondition(cond)
[10:29:52.166]                 })
[10:29:52.166]             }))
[10:29:52.166]             future::FutureResult(value = ...future.value$value, 
[10:29:52.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.166]                   ...future.rng), globalenv = if (FALSE) 
[10:29:52.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:52.166]                     ...future.globalenv.names))
[10:29:52.166]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:52.166]         }, condition = base::local({
[10:29:52.166]             c <- base::c
[10:29:52.166]             inherits <- base::inherits
[10:29:52.166]             invokeRestart <- base::invokeRestart
[10:29:52.166]             length <- base::length
[10:29:52.166]             list <- base::list
[10:29:52.166]             seq.int <- base::seq.int
[10:29:52.166]             signalCondition <- base::signalCondition
[10:29:52.166]             sys.calls <- base::sys.calls
[10:29:52.166]             `[[` <- base::`[[`
[10:29:52.166]             `+` <- base::`+`
[10:29:52.166]             `<<-` <- base::`<<-`
[10:29:52.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:52.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:52.166]                   3L)]
[10:29:52.166]             }
[10:29:52.166]             function(cond) {
[10:29:52.166]                 is_error <- inherits(cond, "error")
[10:29:52.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:52.166]                   NULL)
[10:29:52.166]                 if (is_error) {
[10:29:52.166]                   sessionInformation <- function() {
[10:29:52.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:52.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:52.166]                       search = base::search(), system = base::Sys.info())
[10:29:52.166]                   }
[10:29:52.166]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:52.166]                     cond$call), session = sessionInformation(), 
[10:29:52.166]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:52.166]                   signalCondition(cond)
[10:29:52.166]                 }
[10:29:52.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:52.166]                 "immediateCondition"))) {
[10:29:52.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:52.166]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:52.166]                   if (TRUE && !signal) {
[10:29:52.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.166]                     {
[10:29:52.166]                       inherits <- base::inherits
[10:29:52.166]                       invokeRestart <- base::invokeRestart
[10:29:52.166]                       is.null <- base::is.null
[10:29:52.166]                       muffled <- FALSE
[10:29:52.166]                       if (inherits(cond, "message")) {
[10:29:52.166]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.166]                         if (muffled) 
[10:29:52.166]                           invokeRestart("muffleMessage")
[10:29:52.166]                       }
[10:29:52.166]                       else if (inherits(cond, "warning")) {
[10:29:52.166]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.166]                         if (muffled) 
[10:29:52.166]                           invokeRestart("muffleWarning")
[10:29:52.166]                       }
[10:29:52.166]                       else if (inherits(cond, "condition")) {
[10:29:52.166]                         if (!is.null(pattern)) {
[10:29:52.166]                           computeRestarts <- base::computeRestarts
[10:29:52.166]                           grepl <- base::grepl
[10:29:52.166]                           restarts <- computeRestarts(cond)
[10:29:52.166]                           for (restart in restarts) {
[10:29:52.166]                             name <- restart$name
[10:29:52.166]                             if (is.null(name)) 
[10:29:52.166]                               next
[10:29:52.166]                             if (!grepl(pattern, name)) 
[10:29:52.166]                               next
[10:29:52.166]                             invokeRestart(restart)
[10:29:52.166]                             muffled <- TRUE
[10:29:52.166]                             break
[10:29:52.166]                           }
[10:29:52.166]                         }
[10:29:52.166]                       }
[10:29:52.166]                       invisible(muffled)
[10:29:52.166]                     }
[10:29:52.166]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.166]                   }
[10:29:52.166]                 }
[10:29:52.166]                 else {
[10:29:52.166]                   if (TRUE) {
[10:29:52.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.166]                     {
[10:29:52.166]                       inherits <- base::inherits
[10:29:52.166]                       invokeRestart <- base::invokeRestart
[10:29:52.166]                       is.null <- base::is.null
[10:29:52.166]                       muffled <- FALSE
[10:29:52.166]                       if (inherits(cond, "message")) {
[10:29:52.166]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.166]                         if (muffled) 
[10:29:52.166]                           invokeRestart("muffleMessage")
[10:29:52.166]                       }
[10:29:52.166]                       else if (inherits(cond, "warning")) {
[10:29:52.166]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.166]                         if (muffled) 
[10:29:52.166]                           invokeRestart("muffleWarning")
[10:29:52.166]                       }
[10:29:52.166]                       else if (inherits(cond, "condition")) {
[10:29:52.166]                         if (!is.null(pattern)) {
[10:29:52.166]                           computeRestarts <- base::computeRestarts
[10:29:52.166]                           grepl <- base::grepl
[10:29:52.166]                           restarts <- computeRestarts(cond)
[10:29:52.166]                           for (restart in restarts) {
[10:29:52.166]                             name <- restart$name
[10:29:52.166]                             if (is.null(name)) 
[10:29:52.166]                               next
[10:29:52.166]                             if (!grepl(pattern, name)) 
[10:29:52.166]                               next
[10:29:52.166]                             invokeRestart(restart)
[10:29:52.166]                             muffled <- TRUE
[10:29:52.166]                             break
[10:29:52.166]                           }
[10:29:52.166]                         }
[10:29:52.166]                       }
[10:29:52.166]                       invisible(muffled)
[10:29:52.166]                     }
[10:29:52.166]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.166]                   }
[10:29:52.166]                 }
[10:29:52.166]             }
[10:29:52.166]         }))
[10:29:52.166]     }, error = function(ex) {
[10:29:52.166]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:52.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.166]                 ...future.rng), started = ...future.startTime, 
[10:29:52.166]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:52.166]             version = "1.8"), class = "FutureResult")
[10:29:52.166]     }, finally = {
[10:29:52.166]         if (!identical(...future.workdir, getwd())) 
[10:29:52.166]             setwd(...future.workdir)
[10:29:52.166]         {
[10:29:52.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:52.166]                 ...future.oldOptions$nwarnings <- NULL
[10:29:52.166]             }
[10:29:52.166]             base::options(...future.oldOptions)
[10:29:52.166]             if (.Platform$OS.type == "windows") {
[10:29:52.166]                 old_names <- names(...future.oldEnvVars)
[10:29:52.166]                 envs <- base::Sys.getenv()
[10:29:52.166]                 names <- names(envs)
[10:29:52.166]                 common <- intersect(names, old_names)
[10:29:52.166]                 added <- setdiff(names, old_names)
[10:29:52.166]                 removed <- setdiff(old_names, names)
[10:29:52.166]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:52.166]                   envs[common]]
[10:29:52.166]                 NAMES <- toupper(changed)
[10:29:52.166]                 args <- list()
[10:29:52.166]                 for (kk in seq_along(NAMES)) {
[10:29:52.166]                   name <- changed[[kk]]
[10:29:52.166]                   NAME <- NAMES[[kk]]
[10:29:52.166]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.166]                     next
[10:29:52.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.166]                 }
[10:29:52.166]                 NAMES <- toupper(added)
[10:29:52.166]                 for (kk in seq_along(NAMES)) {
[10:29:52.166]                   name <- added[[kk]]
[10:29:52.166]                   NAME <- NAMES[[kk]]
[10:29:52.166]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.166]                     next
[10:29:52.166]                   args[[name]] <- ""
[10:29:52.166]                 }
[10:29:52.166]                 NAMES <- toupper(removed)
[10:29:52.166]                 for (kk in seq_along(NAMES)) {
[10:29:52.166]                   name <- removed[[kk]]
[10:29:52.166]                   NAME <- NAMES[[kk]]
[10:29:52.166]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.166]                     next
[10:29:52.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.166]                 }
[10:29:52.166]                 if (length(args) > 0) 
[10:29:52.166]                   base::do.call(base::Sys.setenv, args = args)
[10:29:52.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:52.166]             }
[10:29:52.166]             else {
[10:29:52.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:52.166]             }
[10:29:52.166]             {
[10:29:52.166]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:52.166]                   0L) {
[10:29:52.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:52.166]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:52.166]                   base::options(opts)
[10:29:52.166]                 }
[10:29:52.166]                 {
[10:29:52.166]                   {
[10:29:52.166]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:52.166]                     NULL
[10:29:52.166]                   }
[10:29:52.166]                   options(future.plan = NULL)
[10:29:52.166]                   if (is.na(NA_character_)) 
[10:29:52.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:52.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:52.166]                     .init = FALSE)
[10:29:52.166]                 }
[10:29:52.166]             }
[10:29:52.166]         }
[10:29:52.166]     })
[10:29:52.166]     if (TRUE) {
[10:29:52.166]         base::sink(type = "output", split = FALSE)
[10:29:52.166]         if (TRUE) {
[10:29:52.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:52.166]         }
[10:29:52.166]         else {
[10:29:52.166]             ...future.result["stdout"] <- base::list(NULL)
[10:29:52.166]         }
[10:29:52.166]         base::close(...future.stdout)
[10:29:52.166]         ...future.stdout <- NULL
[10:29:52.166]     }
[10:29:52.166]     ...future.result$conditions <- ...future.conditions
[10:29:52.166]     ...future.result$finished <- base::Sys.time()
[10:29:52.166]     ...future.result
[10:29:52.166] }
[10:29:52.169] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[10:29:52.169] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:52.169] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:52.169] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[10:29:52.170] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[10:29:52.170] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[10:29:52.170] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[10:29:52.170] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:52.171] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:52.171] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:29:52.171] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:29:52.171] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[10:29:52.172] MultisessionFuture started
[10:29:52.172] - Launch lazy future ... done
[10:29:52.172] run() for ‘MultisessionFuture’ ... done
[10:29:52.172] Created future:
[10:29:52.172] MultisessionFuture:
[10:29:52.172] Label: ‘future_apply-2’
[10:29:52.172] Expression:
[10:29:52.172] {
[10:29:52.172]     do.call(function(...) {
[10:29:52.172]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.172]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.172]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.172]             on.exit(options(oopts), add = TRUE)
[10:29:52.172]         }
[10:29:52.172]         {
[10:29:52.172]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.172]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.172]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.172]             })
[10:29:52.172]         }
[10:29:52.172]     }, args = future.call.arguments)
[10:29:52.172] }
[10:29:52.172] Lazy evaluation: FALSE
[10:29:52.172] Asynchronous evaluation: TRUE
[10:29:52.172] Local evaluation: TRUE
[10:29:52.172] Environment: R_GlobalEnv
[10:29:52.172] Capture standard output: TRUE
[10:29:52.172] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:52.172] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:52.172] Packages: <none>
[10:29:52.172] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:52.172] Resolved: FALSE
[10:29:52.172] Value: <not collected>
[10:29:52.172] Conditions captured: <none>
[10:29:52.172] Early signaling: FALSE
[10:29:52.172] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:52.172] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.184] Chunk #2 of 2 ... DONE
[10:29:52.184] Launching 2 futures (chunks) ... DONE
[10:29:52.184] Resolving 2 futures (chunks) ...
[10:29:52.184] resolve() on list ...
[10:29:52.184]  recursive: 0
[10:29:52.184]  length: 2
[10:29:52.184] 
[10:29:52.185] receiveMessageFromWorker() for ClusterFuture ...
[10:29:52.185] - Validating connection of MultisessionFuture
[10:29:52.185] - received message: FutureResult
[10:29:52.185] - Received FutureResult
[10:29:52.185] - Erased future from FutureRegistry
[10:29:52.185] result() for ClusterFuture ...
[10:29:52.185] - result already collected: FutureResult
[10:29:52.185] result() for ClusterFuture ... done
[10:29:52.186] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:52.186] Future #1
[10:29:52.186] result() for ClusterFuture ...
[10:29:52.186] - result already collected: FutureResult
[10:29:52.186] result() for ClusterFuture ... done
[10:29:52.186] result() for ClusterFuture ...
[10:29:52.186] - result already collected: FutureResult
[10:29:52.186] result() for ClusterFuture ... done
[10:29:52.186] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:52.186] - nx: 2
[10:29:52.186] - relay: TRUE
[10:29:52.187] - stdout: TRUE
[10:29:52.187] - signal: TRUE
[10:29:52.187] - resignal: FALSE
[10:29:52.187] - force: TRUE
[10:29:52.187] - relayed: [n=2] FALSE, FALSE
[10:29:52.187] - queued futures: [n=2] FALSE, FALSE
[10:29:52.187]  - until=1
[10:29:52.187]  - relaying element #1
[10:29:52.187] result() for ClusterFuture ...
[10:29:52.187] - result already collected: FutureResult
[10:29:52.187] result() for ClusterFuture ... done
[10:29:52.187] result() for ClusterFuture ...
[10:29:52.188] - result already collected: FutureResult
[10:29:52.188] result() for ClusterFuture ... done
[10:29:52.188] result() for ClusterFuture ...
[10:29:52.188] - result already collected: FutureResult
[10:29:52.188] result() for ClusterFuture ... done
[10:29:52.188] result() for ClusterFuture ...
[10:29:52.188] - result already collected: FutureResult
[10:29:52.188] result() for ClusterFuture ... done
[10:29:52.188] - relayed: [n=2] TRUE, FALSE
[10:29:52.188] - queued futures: [n=2] TRUE, FALSE
[10:29:52.188] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:52.189]  length: 1 (resolved future 1)
[10:29:52.214] receiveMessageFromWorker() for ClusterFuture ...
[10:29:52.214] - Validating connection of MultisessionFuture
[10:29:52.215] - received message: FutureResult
[10:29:52.215] - Received FutureResult
[10:29:52.215] - Erased future from FutureRegistry
[10:29:52.215] result() for ClusterFuture ...
[10:29:52.215] - result already collected: FutureResult
[10:29:52.215] result() for ClusterFuture ... done
[10:29:52.215] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:52.215] Future #2
[10:29:52.215] result() for ClusterFuture ...
[10:29:52.215] - result already collected: FutureResult
[10:29:52.216] result() for ClusterFuture ... done
[10:29:52.216] result() for ClusterFuture ...
[10:29:52.216] - result already collected: FutureResult
[10:29:52.216] result() for ClusterFuture ... done
[10:29:52.216] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:52.216] - nx: 2
[10:29:52.216] - relay: TRUE
[10:29:52.216] - stdout: TRUE
[10:29:52.216] - signal: TRUE
[10:29:52.216] - resignal: FALSE
[10:29:52.216] - force: TRUE
[10:29:52.216] - relayed: [n=2] TRUE, FALSE
[10:29:52.217] - queued futures: [n=2] TRUE, FALSE
[10:29:52.217]  - until=2
[10:29:52.217]  - relaying element #2
[10:29:52.217] result() for ClusterFuture ...
[10:29:52.217] - result already collected: FutureResult
[10:29:52.217] result() for ClusterFuture ... done
[10:29:52.217] result() for ClusterFuture ...
[10:29:52.217] - result already collected: FutureResult
[10:29:52.217] result() for ClusterFuture ... done
[10:29:52.217] result() for ClusterFuture ...
[10:29:52.217] - result already collected: FutureResult
[10:29:52.218] result() for ClusterFuture ... done
[10:29:52.218] result() for ClusterFuture ...
[10:29:52.218] - result already collected: FutureResult
[10:29:52.218] result() for ClusterFuture ... done
[10:29:52.218] - relayed: [n=2] TRUE, TRUE
[10:29:52.218] - queued futures: [n=2] TRUE, TRUE
[10:29:52.218] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:52.218]  length: 0 (resolved future 2)
[10:29:52.218] Relaying remaining futures
[10:29:52.218] signalConditionsASAP(NULL, pos=0) ...
[10:29:52.218] - nx: 2
[10:29:52.219] - relay: TRUE
[10:29:52.219] - stdout: TRUE
[10:29:52.219] - signal: TRUE
[10:29:52.219] - resignal: FALSE
[10:29:52.219] - force: TRUE
[10:29:52.219] - relayed: [n=2] TRUE, TRUE
[10:29:52.219] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:52.219] - relayed: [n=2] TRUE, TRUE
[10:29:52.219] - queued futures: [n=2] TRUE, TRUE
[10:29:52.219] signalConditionsASAP(NULL, pos=0) ... done
[10:29:52.219] resolve() on list ... DONE
[10:29:52.219] result() for ClusterFuture ...
[10:29:52.220] - result already collected: FutureResult
[10:29:52.220] result() for ClusterFuture ... done
[10:29:52.220] result() for ClusterFuture ...
[10:29:52.220] - result already collected: FutureResult
[10:29:52.220] result() for ClusterFuture ... done
[10:29:52.220] result() for ClusterFuture ...
[10:29:52.220] - result already collected: FutureResult
[10:29:52.220] result() for ClusterFuture ... done
[10:29:52.220] result() for ClusterFuture ...
[10:29:52.220] - result already collected: FutureResult
[10:29:52.220] result() for ClusterFuture ... done
[10:29:52.221]  - Number of value chunks collected: 2
[10:29:52.221] Resolving 2 futures (chunks) ... DONE
[10:29:52.221] Reducing values from 2 chunks ...
[10:29:52.221]  - Number of values collected after concatenation: 2
[10:29:52.221]  - Number of values expected: 2
[10:29:52.221] Reducing values from 2 chunks ... DONE
[10:29:52.221] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:29:52.221] getGlobalsAndPackagesXApply() ...
[10:29:52.222]  - future.globals: TRUE
[10:29:52.222] getGlobalsAndPackages() ...
[10:29:52.222] Searching for globals...
[10:29:52.224] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:29:52.224] Searching for globals ... DONE
[10:29:52.224] Resolving globals: FALSE
[10:29:52.225] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[10:29:52.225] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[10:29:52.225] - globals: [1] ‘FUN’
[10:29:52.225] 
[10:29:52.226] getGlobalsAndPackages() ... DONE
[10:29:52.226]  - globals found/used: [n=1] ‘FUN’
[10:29:52.226]  - needed namespaces: [n=0] 
[10:29:52.226] Finding globals ... DONE
[10:29:52.226]  - use_args: TRUE
[10:29:52.226]  - Getting '...' globals ...
[10:29:52.226] resolve() on list ...
[10:29:52.226]  recursive: 0
[10:29:52.227]  length: 1
[10:29:52.227]  elements: ‘...’
[10:29:52.227]  length: 0 (resolved future 1)
[10:29:52.227] resolve() on list ... DONE
[10:29:52.227]    - '...' content: [n=0] 
[10:29:52.227] List of 1
[10:29:52.227]  $ ...: list()
[10:29:52.227]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.227]  - attr(*, "where")=List of 1
[10:29:52.227]   ..$ ...:<environment: 0x5618a322d058> 
[10:29:52.227]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.227]  - attr(*, "resolved")= logi TRUE
[10:29:52.227]  - attr(*, "total_size")= num NA
[10:29:52.229]  - Getting '...' globals ... DONE
[10:29:52.230] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:52.230] List of 2
[10:29:52.230]  $ ...future.FUN:function (x)  
[10:29:52.230]  $ ...          : list()
[10:29:52.230]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.230]  - attr(*, "where")=List of 2
[10:29:52.230]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:52.230]   ..$ ...          :<environment: 0x5618a322d058> 
[10:29:52.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.230]  - attr(*, "resolved")= logi FALSE
[10:29:52.230]  - attr(*, "total_size")= num 9888
[10:29:52.232] Packages to be attached in all futures: [n=0] 
[10:29:52.232] getGlobalsAndPackagesXApply() ... DONE
[10:29:52.236] future_lapply() ...
[10:29:52.241] Number of chunks: 2
[10:29:52.241] getGlobalsAndPackagesXApply() ...
[10:29:52.241]  - future.globals: <name-value list> with names ‘list()’
[10:29:52.241]  - use_args: TRUE
[10:29:52.241] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:52.241] List of 2
[10:29:52.241]  $ ...          : list()
[10:29:52.241]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.241]  $ ...future.FUN:function (x)  
[10:29:52.241]  - attr(*, "where")=List of 2
[10:29:52.241]   ..$ ...          :<environment: 0x5618a322d058> 
[10:29:52.241]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:29:52.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.241]  - attr(*, "resolved")= logi FALSE
[10:29:52.241]  - attr(*, "total_size")= num NA
[10:29:52.244] Packages to be attached in all futures: [n=0] 
[10:29:52.244] getGlobalsAndPackagesXApply() ... DONE
[10:29:52.244] Number of futures (= number of chunks): 2
[10:29:52.244] Launching 2 futures (chunks) ...
[10:29:52.244] Chunk #1 of 2 ...
[10:29:52.245]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:52.245]  - seeds: <none>
[10:29:52.245]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.245] getGlobalsAndPackages() ...
[10:29:52.245] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.245] Resolving globals: FALSE
[10:29:52.245] Tweak future expression to call with '...' arguments ...
[10:29:52.245] {
[10:29:52.245]     do.call(function(...) {
[10:29:52.245]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.245]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.245]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.245]             on.exit(options(oopts), add = TRUE)
[10:29:52.245]         }
[10:29:52.245]         {
[10:29:52.245]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.245]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.245]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.245]             })
[10:29:52.245]         }
[10:29:52.245]     }, args = future.call.arguments)
[10:29:52.245] }
[10:29:52.246] Tweak future expression to call with '...' arguments ... DONE
[10:29:52.246] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.246] 
[10:29:52.246] getGlobalsAndPackages() ... DONE
[10:29:52.246] run() for ‘Future’ ...
[10:29:52.246] - state: ‘created’
[10:29:52.247] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:52.260] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:52.260]   - Field: ‘node’
[10:29:52.261]   - Field: ‘label’
[10:29:52.261]   - Field: ‘local’
[10:29:52.261]   - Field: ‘owner’
[10:29:52.261]   - Field: ‘envir’
[10:29:52.261]   - Field: ‘workers’
[10:29:52.261]   - Field: ‘packages’
[10:29:52.261]   - Field: ‘gc’
[10:29:52.261]   - Field: ‘conditions’
[10:29:52.261]   - Field: ‘persistent’
[10:29:52.261]   - Field: ‘expr’
[10:29:52.262]   - Field: ‘uuid’
[10:29:52.262]   - Field: ‘seed’
[10:29:52.262]   - Field: ‘version’
[10:29:52.262]   - Field: ‘result’
[10:29:52.262]   - Field: ‘asynchronous’
[10:29:52.262]   - Field: ‘calls’
[10:29:52.262]   - Field: ‘globals’
[10:29:52.262]   - Field: ‘stdout’
[10:29:52.262]   - Field: ‘earlySignal’
[10:29:52.262]   - Field: ‘lazy’
[10:29:52.262]   - Field: ‘state’
[10:29:52.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:52.263] - Launch lazy future ...
[10:29:52.263] Packages needed by the future expression (n = 0): <none>
[10:29:52.263] Packages needed by future strategies (n = 0): <none>
[10:29:52.263] {
[10:29:52.263]     {
[10:29:52.263]         {
[10:29:52.263]             ...future.startTime <- base::Sys.time()
[10:29:52.263]             {
[10:29:52.263]                 {
[10:29:52.263]                   {
[10:29:52.263]                     {
[10:29:52.263]                       base::local({
[10:29:52.263]                         has_future <- base::requireNamespace("future", 
[10:29:52.263]                           quietly = TRUE)
[10:29:52.263]                         if (has_future) {
[10:29:52.263]                           ns <- base::getNamespace("future")
[10:29:52.263]                           version <- ns[[".package"]][["version"]]
[10:29:52.263]                           if (is.null(version)) 
[10:29:52.263]                             version <- utils::packageVersion("future")
[10:29:52.263]                         }
[10:29:52.263]                         else {
[10:29:52.263]                           version <- NULL
[10:29:52.263]                         }
[10:29:52.263]                         if (!has_future || version < "1.8.0") {
[10:29:52.263]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:52.263]                             "", base::R.version$version.string), 
[10:29:52.263]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:52.263]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:52.263]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:52.263]                               "release", "version")], collapse = " "), 
[10:29:52.263]                             hostname = base::Sys.info()[["nodename"]])
[10:29:52.263]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:52.263]                             info)
[10:29:52.263]                           info <- base::paste(info, collapse = "; ")
[10:29:52.263]                           if (!has_future) {
[10:29:52.263]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:52.263]                               info)
[10:29:52.263]                           }
[10:29:52.263]                           else {
[10:29:52.263]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:52.263]                               info, version)
[10:29:52.263]                           }
[10:29:52.263]                           base::stop(msg)
[10:29:52.263]                         }
[10:29:52.263]                       })
[10:29:52.263]                     }
[10:29:52.263]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:52.263]                     base::options(mc.cores = 1L)
[10:29:52.263]                   }
[10:29:52.263]                   ...future.strategy.old <- future::plan("list")
[10:29:52.263]                   options(future.plan = NULL)
[10:29:52.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:52.263]                 }
[10:29:52.263]                 ...future.workdir <- getwd()
[10:29:52.263]             }
[10:29:52.263]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:52.263]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:52.263]         }
[10:29:52.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:52.263]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:52.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:52.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:52.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:52.263]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:52.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:52.263]             base::names(...future.oldOptions))
[10:29:52.263]     }
[10:29:52.263]     if (FALSE) {
[10:29:52.263]     }
[10:29:52.263]     else {
[10:29:52.263]         if (TRUE) {
[10:29:52.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:52.263]                 open = "w")
[10:29:52.263]         }
[10:29:52.263]         else {
[10:29:52.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:52.263]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:52.263]         }
[10:29:52.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:52.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:52.263]             base::sink(type = "output", split = FALSE)
[10:29:52.263]             base::close(...future.stdout)
[10:29:52.263]         }, add = TRUE)
[10:29:52.263]     }
[10:29:52.263]     ...future.frame <- base::sys.nframe()
[10:29:52.263]     ...future.conditions <- base::list()
[10:29:52.263]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:52.263]     if (FALSE) {
[10:29:52.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:52.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:52.263]     }
[10:29:52.263]     ...future.result <- base::tryCatch({
[10:29:52.263]         base::withCallingHandlers({
[10:29:52.263]             ...future.value <- base::withVisible(base::local({
[10:29:52.263]                 ...future.makeSendCondition <- base::local({
[10:29:52.263]                   sendCondition <- NULL
[10:29:52.263]                   function(frame = 1L) {
[10:29:52.263]                     if (is.function(sendCondition)) 
[10:29:52.263]                       return(sendCondition)
[10:29:52.263]                     ns <- getNamespace("parallel")
[10:29:52.263]                     if (exists("sendData", mode = "function", 
[10:29:52.263]                       envir = ns)) {
[10:29:52.263]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:52.263]                         envir = ns)
[10:29:52.263]                       envir <- sys.frame(frame)
[10:29:52.263]                       master <- NULL
[10:29:52.263]                       while (!identical(envir, .GlobalEnv) && 
[10:29:52.263]                         !identical(envir, emptyenv())) {
[10:29:52.263]                         if (exists("master", mode = "list", envir = envir, 
[10:29:52.263]                           inherits = FALSE)) {
[10:29:52.263]                           master <- get("master", mode = "list", 
[10:29:52.263]                             envir = envir, inherits = FALSE)
[10:29:52.263]                           if (inherits(master, c("SOCKnode", 
[10:29:52.263]                             "SOCK0node"))) {
[10:29:52.263]                             sendCondition <<- function(cond) {
[10:29:52.263]                               data <- list(type = "VALUE", value = cond, 
[10:29:52.263]                                 success = TRUE)
[10:29:52.263]                               parallel_sendData(master, data)
[10:29:52.263]                             }
[10:29:52.263]                             return(sendCondition)
[10:29:52.263]                           }
[10:29:52.263]                         }
[10:29:52.263]                         frame <- frame + 1L
[10:29:52.263]                         envir <- sys.frame(frame)
[10:29:52.263]                       }
[10:29:52.263]                     }
[10:29:52.263]                     sendCondition <<- function(cond) NULL
[10:29:52.263]                   }
[10:29:52.263]                 })
[10:29:52.263]                 withCallingHandlers({
[10:29:52.263]                   {
[10:29:52.263]                     do.call(function(...) {
[10:29:52.263]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.263]                       if (!identical(...future.globals.maxSize.org, 
[10:29:52.263]                         ...future.globals.maxSize)) {
[10:29:52.263]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.263]                         on.exit(options(oopts), add = TRUE)
[10:29:52.263]                       }
[10:29:52.263]                       {
[10:29:52.263]                         lapply(seq_along(...future.elements_ii), 
[10:29:52.263]                           FUN = function(jj) {
[10:29:52.263]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.263]                             ...future.FUN(...future.X_jj, ...)
[10:29:52.263]                           })
[10:29:52.263]                       }
[10:29:52.263]                     }, args = future.call.arguments)
[10:29:52.263]                   }
[10:29:52.263]                 }, immediateCondition = function(cond) {
[10:29:52.263]                   sendCondition <- ...future.makeSendCondition()
[10:29:52.263]                   sendCondition(cond)
[10:29:52.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.263]                   {
[10:29:52.263]                     inherits <- base::inherits
[10:29:52.263]                     invokeRestart <- base::invokeRestart
[10:29:52.263]                     is.null <- base::is.null
[10:29:52.263]                     muffled <- FALSE
[10:29:52.263]                     if (inherits(cond, "message")) {
[10:29:52.263]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:52.263]                       if (muffled) 
[10:29:52.263]                         invokeRestart("muffleMessage")
[10:29:52.263]                     }
[10:29:52.263]                     else if (inherits(cond, "warning")) {
[10:29:52.263]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:52.263]                       if (muffled) 
[10:29:52.263]                         invokeRestart("muffleWarning")
[10:29:52.263]                     }
[10:29:52.263]                     else if (inherits(cond, "condition")) {
[10:29:52.263]                       if (!is.null(pattern)) {
[10:29:52.263]                         computeRestarts <- base::computeRestarts
[10:29:52.263]                         grepl <- base::grepl
[10:29:52.263]                         restarts <- computeRestarts(cond)
[10:29:52.263]                         for (restart in restarts) {
[10:29:52.263]                           name <- restart$name
[10:29:52.263]                           if (is.null(name)) 
[10:29:52.263]                             next
[10:29:52.263]                           if (!grepl(pattern, name)) 
[10:29:52.263]                             next
[10:29:52.263]                           invokeRestart(restart)
[10:29:52.263]                           muffled <- TRUE
[10:29:52.263]                           break
[10:29:52.263]                         }
[10:29:52.263]                       }
[10:29:52.263]                     }
[10:29:52.263]                     invisible(muffled)
[10:29:52.263]                   }
[10:29:52.263]                   muffleCondition(cond)
[10:29:52.263]                 })
[10:29:52.263]             }))
[10:29:52.263]             future::FutureResult(value = ...future.value$value, 
[10:29:52.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.263]                   ...future.rng), globalenv = if (FALSE) 
[10:29:52.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:52.263]                     ...future.globalenv.names))
[10:29:52.263]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:52.263]         }, condition = base::local({
[10:29:52.263]             c <- base::c
[10:29:52.263]             inherits <- base::inherits
[10:29:52.263]             invokeRestart <- base::invokeRestart
[10:29:52.263]             length <- base::length
[10:29:52.263]             list <- base::list
[10:29:52.263]             seq.int <- base::seq.int
[10:29:52.263]             signalCondition <- base::signalCondition
[10:29:52.263]             sys.calls <- base::sys.calls
[10:29:52.263]             `[[` <- base::`[[`
[10:29:52.263]             `+` <- base::`+`
[10:29:52.263]             `<<-` <- base::`<<-`
[10:29:52.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:52.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:52.263]                   3L)]
[10:29:52.263]             }
[10:29:52.263]             function(cond) {
[10:29:52.263]                 is_error <- inherits(cond, "error")
[10:29:52.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:52.263]                   NULL)
[10:29:52.263]                 if (is_error) {
[10:29:52.263]                   sessionInformation <- function() {
[10:29:52.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:52.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:52.263]                       search = base::search(), system = base::Sys.info())
[10:29:52.263]                   }
[10:29:52.263]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:52.263]                     cond$call), session = sessionInformation(), 
[10:29:52.263]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:52.263]                   signalCondition(cond)
[10:29:52.263]                 }
[10:29:52.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:52.263]                 "immediateCondition"))) {
[10:29:52.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:52.263]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:52.263]                   if (TRUE && !signal) {
[10:29:52.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.263]                     {
[10:29:52.263]                       inherits <- base::inherits
[10:29:52.263]                       invokeRestart <- base::invokeRestart
[10:29:52.263]                       is.null <- base::is.null
[10:29:52.263]                       muffled <- FALSE
[10:29:52.263]                       if (inherits(cond, "message")) {
[10:29:52.263]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.263]                         if (muffled) 
[10:29:52.263]                           invokeRestart("muffleMessage")
[10:29:52.263]                       }
[10:29:52.263]                       else if (inherits(cond, "warning")) {
[10:29:52.263]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.263]                         if (muffled) 
[10:29:52.263]                           invokeRestart("muffleWarning")
[10:29:52.263]                       }
[10:29:52.263]                       else if (inherits(cond, "condition")) {
[10:29:52.263]                         if (!is.null(pattern)) {
[10:29:52.263]                           computeRestarts <- base::computeRestarts
[10:29:52.263]                           grepl <- base::grepl
[10:29:52.263]                           restarts <- computeRestarts(cond)
[10:29:52.263]                           for (restart in restarts) {
[10:29:52.263]                             name <- restart$name
[10:29:52.263]                             if (is.null(name)) 
[10:29:52.263]                               next
[10:29:52.263]                             if (!grepl(pattern, name)) 
[10:29:52.263]                               next
[10:29:52.263]                             invokeRestart(restart)
[10:29:52.263]                             muffled <- TRUE
[10:29:52.263]                             break
[10:29:52.263]                           }
[10:29:52.263]                         }
[10:29:52.263]                       }
[10:29:52.263]                       invisible(muffled)
[10:29:52.263]                     }
[10:29:52.263]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.263]                   }
[10:29:52.263]                 }
[10:29:52.263]                 else {
[10:29:52.263]                   if (TRUE) {
[10:29:52.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.263]                     {
[10:29:52.263]                       inherits <- base::inherits
[10:29:52.263]                       invokeRestart <- base::invokeRestart
[10:29:52.263]                       is.null <- base::is.null
[10:29:52.263]                       muffled <- FALSE
[10:29:52.263]                       if (inherits(cond, "message")) {
[10:29:52.263]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.263]                         if (muffled) 
[10:29:52.263]                           invokeRestart("muffleMessage")
[10:29:52.263]                       }
[10:29:52.263]                       else if (inherits(cond, "warning")) {
[10:29:52.263]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.263]                         if (muffled) 
[10:29:52.263]                           invokeRestart("muffleWarning")
[10:29:52.263]                       }
[10:29:52.263]                       else if (inherits(cond, "condition")) {
[10:29:52.263]                         if (!is.null(pattern)) {
[10:29:52.263]                           computeRestarts <- base::computeRestarts
[10:29:52.263]                           grepl <- base::grepl
[10:29:52.263]                           restarts <- computeRestarts(cond)
[10:29:52.263]                           for (restart in restarts) {
[10:29:52.263]                             name <- restart$name
[10:29:52.263]                             if (is.null(name)) 
[10:29:52.263]                               next
[10:29:52.263]                             if (!grepl(pattern, name)) 
[10:29:52.263]                               next
[10:29:52.263]                             invokeRestart(restart)
[10:29:52.263]                             muffled <- TRUE
[10:29:52.263]                             break
[10:29:52.263]                           }
[10:29:52.263]                         }
[10:29:52.263]                       }
[10:29:52.263]                       invisible(muffled)
[10:29:52.263]                     }
[10:29:52.263]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.263]                   }
[10:29:52.263]                 }
[10:29:52.263]             }
[10:29:52.263]         }))
[10:29:52.263]     }, error = function(ex) {
[10:29:52.263]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:52.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.263]                 ...future.rng), started = ...future.startTime, 
[10:29:52.263]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:52.263]             version = "1.8"), class = "FutureResult")
[10:29:52.263]     }, finally = {
[10:29:52.263]         if (!identical(...future.workdir, getwd())) 
[10:29:52.263]             setwd(...future.workdir)
[10:29:52.263]         {
[10:29:52.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:52.263]                 ...future.oldOptions$nwarnings <- NULL
[10:29:52.263]             }
[10:29:52.263]             base::options(...future.oldOptions)
[10:29:52.263]             if (.Platform$OS.type == "windows") {
[10:29:52.263]                 old_names <- names(...future.oldEnvVars)
[10:29:52.263]                 envs <- base::Sys.getenv()
[10:29:52.263]                 names <- names(envs)
[10:29:52.263]                 common <- intersect(names, old_names)
[10:29:52.263]                 added <- setdiff(names, old_names)
[10:29:52.263]                 removed <- setdiff(old_names, names)
[10:29:52.263]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:52.263]                   envs[common]]
[10:29:52.263]                 NAMES <- toupper(changed)
[10:29:52.263]                 args <- list()
[10:29:52.263]                 for (kk in seq_along(NAMES)) {
[10:29:52.263]                   name <- changed[[kk]]
[10:29:52.263]                   NAME <- NAMES[[kk]]
[10:29:52.263]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.263]                     next
[10:29:52.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.263]                 }
[10:29:52.263]                 NAMES <- toupper(added)
[10:29:52.263]                 for (kk in seq_along(NAMES)) {
[10:29:52.263]                   name <- added[[kk]]
[10:29:52.263]                   NAME <- NAMES[[kk]]
[10:29:52.263]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.263]                     next
[10:29:52.263]                   args[[name]] <- ""
[10:29:52.263]                 }
[10:29:52.263]                 NAMES <- toupper(removed)
[10:29:52.263]                 for (kk in seq_along(NAMES)) {
[10:29:52.263]                   name <- removed[[kk]]
[10:29:52.263]                   NAME <- NAMES[[kk]]
[10:29:52.263]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.263]                     next
[10:29:52.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.263]                 }
[10:29:52.263]                 if (length(args) > 0) 
[10:29:52.263]                   base::do.call(base::Sys.setenv, args = args)
[10:29:52.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:52.263]             }
[10:29:52.263]             else {
[10:29:52.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:52.263]             }
[10:29:52.263]             {
[10:29:52.263]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:52.263]                   0L) {
[10:29:52.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:52.263]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:52.263]                   base::options(opts)
[10:29:52.263]                 }
[10:29:52.263]                 {
[10:29:52.263]                   {
[10:29:52.263]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:52.263]                     NULL
[10:29:52.263]                   }
[10:29:52.263]                   options(future.plan = NULL)
[10:29:52.263]                   if (is.na(NA_character_)) 
[10:29:52.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:52.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:52.263]                     .init = FALSE)
[10:29:52.263]                 }
[10:29:52.263]             }
[10:29:52.263]         }
[10:29:52.263]     })
[10:29:52.263]     if (TRUE) {
[10:29:52.263]         base::sink(type = "output", split = FALSE)
[10:29:52.263]         if (TRUE) {
[10:29:52.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:52.263]         }
[10:29:52.263]         else {
[10:29:52.263]             ...future.result["stdout"] <- base::list(NULL)
[10:29:52.263]         }
[10:29:52.263]         base::close(...future.stdout)
[10:29:52.263]         ...future.stdout <- NULL
[10:29:52.263]     }
[10:29:52.263]     ...future.result$conditions <- ...future.conditions
[10:29:52.263]     ...future.result$finished <- base::Sys.time()
[10:29:52.263]     ...future.result
[10:29:52.263] }
[10:29:52.267] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[10:29:52.267] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:52.267] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:52.267] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[10:29:52.268] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[10:29:52.268] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:29:52.268] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:29:52.268] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:52.268] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:52.268] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:52.269] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:52.269] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[10:29:52.269] MultisessionFuture started
[10:29:52.269] - Launch lazy future ... done
[10:29:52.270] run() for ‘MultisessionFuture’ ... done
[10:29:52.270] Created future:
[10:29:52.270] MultisessionFuture:
[10:29:52.270] Label: ‘future_apply-1’
[10:29:52.270] Expression:
[10:29:52.270] {
[10:29:52.270]     do.call(function(...) {
[10:29:52.270]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.270]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.270]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.270]             on.exit(options(oopts), add = TRUE)
[10:29:52.270]         }
[10:29:52.270]         {
[10:29:52.270]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.270]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.270]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.270]             })
[10:29:52.270]         }
[10:29:52.270]     }, args = future.call.arguments)
[10:29:52.270] }
[10:29:52.270] Lazy evaluation: FALSE
[10:29:52.270] Asynchronous evaluation: TRUE
[10:29:52.270] Local evaluation: TRUE
[10:29:52.270] Environment: R_GlobalEnv
[10:29:52.270] Capture standard output: TRUE
[10:29:52.270] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:52.270] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:52.270] Packages: <none>
[10:29:52.270] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:52.270] Resolved: FALSE
[10:29:52.270] Value: <not collected>
[10:29:52.270] Conditions captured: <none>
[10:29:52.270] Early signaling: FALSE
[10:29:52.270] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:52.270] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.281] Chunk #1 of 2 ... DONE
[10:29:52.284] Chunk #2 of 2 ...
[10:29:52.284]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:52.284]  - seeds: <none>
[10:29:52.284]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.284] getGlobalsAndPackages() ...
[10:29:52.284] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.284] Resolving globals: FALSE
[10:29:52.284] Tweak future expression to call with '...' arguments ...
[10:29:52.285] {
[10:29:52.285]     do.call(function(...) {
[10:29:52.285]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.285]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.285]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.285]             on.exit(options(oopts), add = TRUE)
[10:29:52.285]         }
[10:29:52.285]         {
[10:29:52.285]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.285]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.285]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.285]             })
[10:29:52.285]         }
[10:29:52.285]     }, args = future.call.arguments)
[10:29:52.285] }
[10:29:52.285] Tweak future expression to call with '...' arguments ... DONE
[10:29:52.285] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.285] 
[10:29:52.285] getGlobalsAndPackages() ... DONE
[10:29:52.286] run() for ‘Future’ ...
[10:29:52.286] - state: ‘created’
[10:29:52.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:52.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:52.300]   - Field: ‘node’
[10:29:52.300]   - Field: ‘label’
[10:29:52.300]   - Field: ‘local’
[10:29:52.300]   - Field: ‘owner’
[10:29:52.300]   - Field: ‘envir’
[10:29:52.301]   - Field: ‘workers’
[10:29:52.301]   - Field: ‘packages’
[10:29:52.301]   - Field: ‘gc’
[10:29:52.301]   - Field: ‘conditions’
[10:29:52.301]   - Field: ‘persistent’
[10:29:52.301]   - Field: ‘expr’
[10:29:52.301]   - Field: ‘uuid’
[10:29:52.301]   - Field: ‘seed’
[10:29:52.301]   - Field: ‘version’
[10:29:52.301]   - Field: ‘result’
[10:29:52.302]   - Field: ‘asynchronous’
[10:29:52.302]   - Field: ‘calls’
[10:29:52.302]   - Field: ‘globals’
[10:29:52.302]   - Field: ‘stdout’
[10:29:52.302]   - Field: ‘earlySignal’
[10:29:52.302]   - Field: ‘lazy’
[10:29:52.302]   - Field: ‘state’
[10:29:52.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:52.302] - Launch lazy future ...
[10:29:52.303] Packages needed by the future expression (n = 0): <none>
[10:29:52.303] Packages needed by future strategies (n = 0): <none>
[10:29:52.303] {
[10:29:52.303]     {
[10:29:52.303]         {
[10:29:52.303]             ...future.startTime <- base::Sys.time()
[10:29:52.303]             {
[10:29:52.303]                 {
[10:29:52.303]                   {
[10:29:52.303]                     {
[10:29:52.303]                       base::local({
[10:29:52.303]                         has_future <- base::requireNamespace("future", 
[10:29:52.303]                           quietly = TRUE)
[10:29:52.303]                         if (has_future) {
[10:29:52.303]                           ns <- base::getNamespace("future")
[10:29:52.303]                           version <- ns[[".package"]][["version"]]
[10:29:52.303]                           if (is.null(version)) 
[10:29:52.303]                             version <- utils::packageVersion("future")
[10:29:52.303]                         }
[10:29:52.303]                         else {
[10:29:52.303]                           version <- NULL
[10:29:52.303]                         }
[10:29:52.303]                         if (!has_future || version < "1.8.0") {
[10:29:52.303]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:52.303]                             "", base::R.version$version.string), 
[10:29:52.303]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:52.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:52.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:52.303]                               "release", "version")], collapse = " "), 
[10:29:52.303]                             hostname = base::Sys.info()[["nodename"]])
[10:29:52.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:52.303]                             info)
[10:29:52.303]                           info <- base::paste(info, collapse = "; ")
[10:29:52.303]                           if (!has_future) {
[10:29:52.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:52.303]                               info)
[10:29:52.303]                           }
[10:29:52.303]                           else {
[10:29:52.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:52.303]                               info, version)
[10:29:52.303]                           }
[10:29:52.303]                           base::stop(msg)
[10:29:52.303]                         }
[10:29:52.303]                       })
[10:29:52.303]                     }
[10:29:52.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:52.303]                     base::options(mc.cores = 1L)
[10:29:52.303]                   }
[10:29:52.303]                   ...future.strategy.old <- future::plan("list")
[10:29:52.303]                   options(future.plan = NULL)
[10:29:52.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:52.303]                 }
[10:29:52.303]                 ...future.workdir <- getwd()
[10:29:52.303]             }
[10:29:52.303]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:52.303]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:52.303]         }
[10:29:52.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:52.303]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:52.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:52.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:52.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:52.303]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:52.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:52.303]             base::names(...future.oldOptions))
[10:29:52.303]     }
[10:29:52.303]     if (FALSE) {
[10:29:52.303]     }
[10:29:52.303]     else {
[10:29:52.303]         if (TRUE) {
[10:29:52.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:52.303]                 open = "w")
[10:29:52.303]         }
[10:29:52.303]         else {
[10:29:52.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:52.303]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:52.303]         }
[10:29:52.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:52.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:52.303]             base::sink(type = "output", split = FALSE)
[10:29:52.303]             base::close(...future.stdout)
[10:29:52.303]         }, add = TRUE)
[10:29:52.303]     }
[10:29:52.303]     ...future.frame <- base::sys.nframe()
[10:29:52.303]     ...future.conditions <- base::list()
[10:29:52.303]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:52.303]     if (FALSE) {
[10:29:52.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:52.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:52.303]     }
[10:29:52.303]     ...future.result <- base::tryCatch({
[10:29:52.303]         base::withCallingHandlers({
[10:29:52.303]             ...future.value <- base::withVisible(base::local({
[10:29:52.303]                 ...future.makeSendCondition <- base::local({
[10:29:52.303]                   sendCondition <- NULL
[10:29:52.303]                   function(frame = 1L) {
[10:29:52.303]                     if (is.function(sendCondition)) 
[10:29:52.303]                       return(sendCondition)
[10:29:52.303]                     ns <- getNamespace("parallel")
[10:29:52.303]                     if (exists("sendData", mode = "function", 
[10:29:52.303]                       envir = ns)) {
[10:29:52.303]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:52.303]                         envir = ns)
[10:29:52.303]                       envir <- sys.frame(frame)
[10:29:52.303]                       master <- NULL
[10:29:52.303]                       while (!identical(envir, .GlobalEnv) && 
[10:29:52.303]                         !identical(envir, emptyenv())) {
[10:29:52.303]                         if (exists("master", mode = "list", envir = envir, 
[10:29:52.303]                           inherits = FALSE)) {
[10:29:52.303]                           master <- get("master", mode = "list", 
[10:29:52.303]                             envir = envir, inherits = FALSE)
[10:29:52.303]                           if (inherits(master, c("SOCKnode", 
[10:29:52.303]                             "SOCK0node"))) {
[10:29:52.303]                             sendCondition <<- function(cond) {
[10:29:52.303]                               data <- list(type = "VALUE", value = cond, 
[10:29:52.303]                                 success = TRUE)
[10:29:52.303]                               parallel_sendData(master, data)
[10:29:52.303]                             }
[10:29:52.303]                             return(sendCondition)
[10:29:52.303]                           }
[10:29:52.303]                         }
[10:29:52.303]                         frame <- frame + 1L
[10:29:52.303]                         envir <- sys.frame(frame)
[10:29:52.303]                       }
[10:29:52.303]                     }
[10:29:52.303]                     sendCondition <<- function(cond) NULL
[10:29:52.303]                   }
[10:29:52.303]                 })
[10:29:52.303]                 withCallingHandlers({
[10:29:52.303]                   {
[10:29:52.303]                     do.call(function(...) {
[10:29:52.303]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.303]                       if (!identical(...future.globals.maxSize.org, 
[10:29:52.303]                         ...future.globals.maxSize)) {
[10:29:52.303]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.303]                         on.exit(options(oopts), add = TRUE)
[10:29:52.303]                       }
[10:29:52.303]                       {
[10:29:52.303]                         lapply(seq_along(...future.elements_ii), 
[10:29:52.303]                           FUN = function(jj) {
[10:29:52.303]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.303]                             ...future.FUN(...future.X_jj, ...)
[10:29:52.303]                           })
[10:29:52.303]                       }
[10:29:52.303]                     }, args = future.call.arguments)
[10:29:52.303]                   }
[10:29:52.303]                 }, immediateCondition = function(cond) {
[10:29:52.303]                   sendCondition <- ...future.makeSendCondition()
[10:29:52.303]                   sendCondition(cond)
[10:29:52.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.303]                   {
[10:29:52.303]                     inherits <- base::inherits
[10:29:52.303]                     invokeRestart <- base::invokeRestart
[10:29:52.303]                     is.null <- base::is.null
[10:29:52.303]                     muffled <- FALSE
[10:29:52.303]                     if (inherits(cond, "message")) {
[10:29:52.303]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:52.303]                       if (muffled) 
[10:29:52.303]                         invokeRestart("muffleMessage")
[10:29:52.303]                     }
[10:29:52.303]                     else if (inherits(cond, "warning")) {
[10:29:52.303]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:52.303]                       if (muffled) 
[10:29:52.303]                         invokeRestart("muffleWarning")
[10:29:52.303]                     }
[10:29:52.303]                     else if (inherits(cond, "condition")) {
[10:29:52.303]                       if (!is.null(pattern)) {
[10:29:52.303]                         computeRestarts <- base::computeRestarts
[10:29:52.303]                         grepl <- base::grepl
[10:29:52.303]                         restarts <- computeRestarts(cond)
[10:29:52.303]                         for (restart in restarts) {
[10:29:52.303]                           name <- restart$name
[10:29:52.303]                           if (is.null(name)) 
[10:29:52.303]                             next
[10:29:52.303]                           if (!grepl(pattern, name)) 
[10:29:52.303]                             next
[10:29:52.303]                           invokeRestart(restart)
[10:29:52.303]                           muffled <- TRUE
[10:29:52.303]                           break
[10:29:52.303]                         }
[10:29:52.303]                       }
[10:29:52.303]                     }
[10:29:52.303]                     invisible(muffled)
[10:29:52.303]                   }
[10:29:52.303]                   muffleCondition(cond)
[10:29:52.303]                 })
[10:29:52.303]             }))
[10:29:52.303]             future::FutureResult(value = ...future.value$value, 
[10:29:52.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.303]                   ...future.rng), globalenv = if (FALSE) 
[10:29:52.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:52.303]                     ...future.globalenv.names))
[10:29:52.303]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:52.303]         }, condition = base::local({
[10:29:52.303]             c <- base::c
[10:29:52.303]             inherits <- base::inherits
[10:29:52.303]             invokeRestart <- base::invokeRestart
[10:29:52.303]             length <- base::length
[10:29:52.303]             list <- base::list
[10:29:52.303]             seq.int <- base::seq.int
[10:29:52.303]             signalCondition <- base::signalCondition
[10:29:52.303]             sys.calls <- base::sys.calls
[10:29:52.303]             `[[` <- base::`[[`
[10:29:52.303]             `+` <- base::`+`
[10:29:52.303]             `<<-` <- base::`<<-`
[10:29:52.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:52.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:52.303]                   3L)]
[10:29:52.303]             }
[10:29:52.303]             function(cond) {
[10:29:52.303]                 is_error <- inherits(cond, "error")
[10:29:52.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:52.303]                   NULL)
[10:29:52.303]                 if (is_error) {
[10:29:52.303]                   sessionInformation <- function() {
[10:29:52.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:52.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:52.303]                       search = base::search(), system = base::Sys.info())
[10:29:52.303]                   }
[10:29:52.303]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:52.303]                     cond$call), session = sessionInformation(), 
[10:29:52.303]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:52.303]                   signalCondition(cond)
[10:29:52.303]                 }
[10:29:52.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:52.303]                 "immediateCondition"))) {
[10:29:52.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:52.303]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:52.303]                   if (TRUE && !signal) {
[10:29:52.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.303]                     {
[10:29:52.303]                       inherits <- base::inherits
[10:29:52.303]                       invokeRestart <- base::invokeRestart
[10:29:52.303]                       is.null <- base::is.null
[10:29:52.303]                       muffled <- FALSE
[10:29:52.303]                       if (inherits(cond, "message")) {
[10:29:52.303]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.303]                         if (muffled) 
[10:29:52.303]                           invokeRestart("muffleMessage")
[10:29:52.303]                       }
[10:29:52.303]                       else if (inherits(cond, "warning")) {
[10:29:52.303]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.303]                         if (muffled) 
[10:29:52.303]                           invokeRestart("muffleWarning")
[10:29:52.303]                       }
[10:29:52.303]                       else if (inherits(cond, "condition")) {
[10:29:52.303]                         if (!is.null(pattern)) {
[10:29:52.303]                           computeRestarts <- base::computeRestarts
[10:29:52.303]                           grepl <- base::grepl
[10:29:52.303]                           restarts <- computeRestarts(cond)
[10:29:52.303]                           for (restart in restarts) {
[10:29:52.303]                             name <- restart$name
[10:29:52.303]                             if (is.null(name)) 
[10:29:52.303]                               next
[10:29:52.303]                             if (!grepl(pattern, name)) 
[10:29:52.303]                               next
[10:29:52.303]                             invokeRestart(restart)
[10:29:52.303]                             muffled <- TRUE
[10:29:52.303]                             break
[10:29:52.303]                           }
[10:29:52.303]                         }
[10:29:52.303]                       }
[10:29:52.303]                       invisible(muffled)
[10:29:52.303]                     }
[10:29:52.303]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.303]                   }
[10:29:52.303]                 }
[10:29:52.303]                 else {
[10:29:52.303]                   if (TRUE) {
[10:29:52.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.303]                     {
[10:29:52.303]                       inherits <- base::inherits
[10:29:52.303]                       invokeRestart <- base::invokeRestart
[10:29:52.303]                       is.null <- base::is.null
[10:29:52.303]                       muffled <- FALSE
[10:29:52.303]                       if (inherits(cond, "message")) {
[10:29:52.303]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.303]                         if (muffled) 
[10:29:52.303]                           invokeRestart("muffleMessage")
[10:29:52.303]                       }
[10:29:52.303]                       else if (inherits(cond, "warning")) {
[10:29:52.303]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.303]                         if (muffled) 
[10:29:52.303]                           invokeRestart("muffleWarning")
[10:29:52.303]                       }
[10:29:52.303]                       else if (inherits(cond, "condition")) {
[10:29:52.303]                         if (!is.null(pattern)) {
[10:29:52.303]                           computeRestarts <- base::computeRestarts
[10:29:52.303]                           grepl <- base::grepl
[10:29:52.303]                           restarts <- computeRestarts(cond)
[10:29:52.303]                           for (restart in restarts) {
[10:29:52.303]                             name <- restart$name
[10:29:52.303]                             if (is.null(name)) 
[10:29:52.303]                               next
[10:29:52.303]                             if (!grepl(pattern, name)) 
[10:29:52.303]                               next
[10:29:52.303]                             invokeRestart(restart)
[10:29:52.303]                             muffled <- TRUE
[10:29:52.303]                             break
[10:29:52.303]                           }
[10:29:52.303]                         }
[10:29:52.303]                       }
[10:29:52.303]                       invisible(muffled)
[10:29:52.303]                     }
[10:29:52.303]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.303]                   }
[10:29:52.303]                 }
[10:29:52.303]             }
[10:29:52.303]         }))
[10:29:52.303]     }, error = function(ex) {
[10:29:52.303]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:52.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.303]                 ...future.rng), started = ...future.startTime, 
[10:29:52.303]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:52.303]             version = "1.8"), class = "FutureResult")
[10:29:52.303]     }, finally = {
[10:29:52.303]         if (!identical(...future.workdir, getwd())) 
[10:29:52.303]             setwd(...future.workdir)
[10:29:52.303]         {
[10:29:52.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:52.303]                 ...future.oldOptions$nwarnings <- NULL
[10:29:52.303]             }
[10:29:52.303]             base::options(...future.oldOptions)
[10:29:52.303]             if (.Platform$OS.type == "windows") {
[10:29:52.303]                 old_names <- names(...future.oldEnvVars)
[10:29:52.303]                 envs <- base::Sys.getenv()
[10:29:52.303]                 names <- names(envs)
[10:29:52.303]                 common <- intersect(names, old_names)
[10:29:52.303]                 added <- setdiff(names, old_names)
[10:29:52.303]                 removed <- setdiff(old_names, names)
[10:29:52.303]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:52.303]                   envs[common]]
[10:29:52.303]                 NAMES <- toupper(changed)
[10:29:52.303]                 args <- list()
[10:29:52.303]                 for (kk in seq_along(NAMES)) {
[10:29:52.303]                   name <- changed[[kk]]
[10:29:52.303]                   NAME <- NAMES[[kk]]
[10:29:52.303]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.303]                     next
[10:29:52.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.303]                 }
[10:29:52.303]                 NAMES <- toupper(added)
[10:29:52.303]                 for (kk in seq_along(NAMES)) {
[10:29:52.303]                   name <- added[[kk]]
[10:29:52.303]                   NAME <- NAMES[[kk]]
[10:29:52.303]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.303]                     next
[10:29:52.303]                   args[[name]] <- ""
[10:29:52.303]                 }
[10:29:52.303]                 NAMES <- toupper(removed)
[10:29:52.303]                 for (kk in seq_along(NAMES)) {
[10:29:52.303]                   name <- removed[[kk]]
[10:29:52.303]                   NAME <- NAMES[[kk]]
[10:29:52.303]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.303]                     next
[10:29:52.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.303]                 }
[10:29:52.303]                 if (length(args) > 0) 
[10:29:52.303]                   base::do.call(base::Sys.setenv, args = args)
[10:29:52.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:52.303]             }
[10:29:52.303]             else {
[10:29:52.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:52.303]             }
[10:29:52.303]             {
[10:29:52.303]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:52.303]                   0L) {
[10:29:52.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:52.303]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:52.303]                   base::options(opts)
[10:29:52.303]                 }
[10:29:52.303]                 {
[10:29:52.303]                   {
[10:29:52.303]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:52.303]                     NULL
[10:29:52.303]                   }
[10:29:52.303]                   options(future.plan = NULL)
[10:29:52.303]                   if (is.na(NA_character_)) 
[10:29:52.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:52.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:52.303]                     .init = FALSE)
[10:29:52.303]                 }
[10:29:52.303]             }
[10:29:52.303]         }
[10:29:52.303]     })
[10:29:52.303]     if (TRUE) {
[10:29:52.303]         base::sink(type = "output", split = FALSE)
[10:29:52.303]         if (TRUE) {
[10:29:52.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:52.303]         }
[10:29:52.303]         else {
[10:29:52.303]             ...future.result["stdout"] <- base::list(NULL)
[10:29:52.303]         }
[10:29:52.303]         base::close(...future.stdout)
[10:29:52.303]         ...future.stdout <- NULL
[10:29:52.303]     }
[10:29:52.303]     ...future.result$conditions <- ...future.conditions
[10:29:52.303]     ...future.result$finished <- base::Sys.time()
[10:29:52.303]     ...future.result
[10:29:52.303] }
[10:29:52.306] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[10:29:52.306] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:52.306] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:52.307] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[10:29:52.307] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[10:29:52.307] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:29:52.307] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:29:52.308] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:52.308] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:52.308] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:29:52.308] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:29:52.308] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[10:29:52.309] MultisessionFuture started
[10:29:52.309] - Launch lazy future ... done
[10:29:52.309] run() for ‘MultisessionFuture’ ... done
[10:29:52.309] Created future:
[10:29:52.309] MultisessionFuture:
[10:29:52.309] Label: ‘future_apply-2’
[10:29:52.309] Expression:
[10:29:52.309] {
[10:29:52.309]     do.call(function(...) {
[10:29:52.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.309]             on.exit(options(oopts), add = TRUE)
[10:29:52.309]         }
[10:29:52.309]         {
[10:29:52.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.309]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.309]             })
[10:29:52.309]         }
[10:29:52.309]     }, args = future.call.arguments)
[10:29:52.309] }
[10:29:52.309] Lazy evaluation: FALSE
[10:29:52.309] Asynchronous evaluation: TRUE
[10:29:52.309] Local evaluation: TRUE
[10:29:52.309] Environment: R_GlobalEnv
[10:29:52.309] Capture standard output: TRUE
[10:29:52.309] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:52.309] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:52.309] Packages: <none>
[10:29:52.309] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:52.309] Resolved: FALSE
[10:29:52.309] Value: <not collected>
[10:29:52.309] Conditions captured: <none>
[10:29:52.309] Early signaling: FALSE
[10:29:52.309] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:52.309] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.321] Chunk #2 of 2 ... DONE
[10:29:52.321] Launching 2 futures (chunks) ... DONE
[10:29:52.321] Resolving 2 futures (chunks) ...
[10:29:52.321] resolve() on list ...
[10:29:52.321]  recursive: 0
[10:29:52.321]  length: 2
[10:29:52.321] 
[10:29:52.322] receiveMessageFromWorker() for ClusterFuture ...
[10:29:52.322] - Validating connection of MultisessionFuture
[10:29:52.322] - received message: FutureResult
[10:29:52.322] - Received FutureResult
[10:29:52.322] - Erased future from FutureRegistry
[10:29:52.322] result() for ClusterFuture ...
[10:29:52.323] - result already collected: FutureResult
[10:29:52.323] result() for ClusterFuture ... done
[10:29:52.323] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:52.323] Future #1
[10:29:52.323] result() for ClusterFuture ...
[10:29:52.323] - result already collected: FutureResult
[10:29:52.323] result() for ClusterFuture ... done
[10:29:52.323] result() for ClusterFuture ...
[10:29:52.323] - result already collected: FutureResult
[10:29:52.323] result() for ClusterFuture ... done
[10:29:52.323] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:52.324] - nx: 2
[10:29:52.324] - relay: TRUE
[10:29:52.324] - stdout: TRUE
[10:29:52.324] - signal: TRUE
[10:29:52.324] - resignal: FALSE
[10:29:52.324] - force: TRUE
[10:29:52.324] - relayed: [n=2] FALSE, FALSE
[10:29:52.324] - queued futures: [n=2] FALSE, FALSE
[10:29:52.324]  - until=1
[10:29:52.324]  - relaying element #1
[10:29:52.324] result() for ClusterFuture ...
[10:29:52.324] - result already collected: FutureResult
[10:29:52.325] result() for ClusterFuture ... done
[10:29:52.325] result() for ClusterFuture ...
[10:29:52.325] - result already collected: FutureResult
[10:29:52.325] result() for ClusterFuture ... done
[10:29:52.325] result() for ClusterFuture ...
[10:29:52.325] - result already collected: FutureResult
[10:29:52.325] result() for ClusterFuture ... done
[10:29:52.325] result() for ClusterFuture ...
[10:29:52.325] - result already collected: FutureResult
[10:29:52.325] result() for ClusterFuture ... done
[10:29:52.326] - relayed: [n=2] TRUE, FALSE
[10:29:52.326] - queued futures: [n=2] TRUE, FALSE
[10:29:52.326] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:52.326]  length: 1 (resolved future 1)
[10:29:52.350] receiveMessageFromWorker() for ClusterFuture ...
[10:29:52.350] - Validating connection of MultisessionFuture
[10:29:52.350] - received message: FutureResult
[10:29:52.351] - Received FutureResult
[10:29:52.351] - Erased future from FutureRegistry
[10:29:52.351] result() for ClusterFuture ...
[10:29:52.351] - result already collected: FutureResult
[10:29:52.351] result() for ClusterFuture ... done
[10:29:52.351] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:52.351] Future #2
[10:29:52.351] result() for ClusterFuture ...
[10:29:52.351] - result already collected: FutureResult
[10:29:52.351] result() for ClusterFuture ... done
[10:29:52.351] result() for ClusterFuture ...
[10:29:52.352] - result already collected: FutureResult
[10:29:52.352] result() for ClusterFuture ... done
[10:29:52.352] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:52.352] - nx: 2
[10:29:52.352] - relay: TRUE
[10:29:52.352] - stdout: TRUE
[10:29:52.352] - signal: TRUE
[10:29:52.352] - resignal: FALSE
[10:29:52.352] - force: TRUE
[10:29:52.352] - relayed: [n=2] TRUE, FALSE
[10:29:52.352] - queued futures: [n=2] TRUE, FALSE
[10:29:52.353]  - until=2
[10:29:52.353]  - relaying element #2
[10:29:52.353] result() for ClusterFuture ...
[10:29:52.353] - result already collected: FutureResult
[10:29:52.353] result() for ClusterFuture ... done
[10:29:52.353] result() for ClusterFuture ...
[10:29:52.353] - result already collected: FutureResult
[10:29:52.353] result() for ClusterFuture ... done
[10:29:52.353] result() for ClusterFuture ...
[10:29:52.353] - result already collected: FutureResult
[10:29:52.353] result() for ClusterFuture ... done
[10:29:52.354] result() for ClusterFuture ...
[10:29:52.354] - result already collected: FutureResult
[10:29:52.354] result() for ClusterFuture ... done
[10:29:52.354] - relayed: [n=2] TRUE, TRUE
[10:29:52.354] - queued futures: [n=2] TRUE, TRUE
[10:29:52.354] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:52.354]  length: 0 (resolved future 2)
[10:29:52.354] Relaying remaining futures
[10:29:52.354] signalConditionsASAP(NULL, pos=0) ...
[10:29:52.354] - nx: 2
[10:29:52.354] - relay: TRUE
[10:29:52.354] - stdout: TRUE
[10:29:52.355] - signal: TRUE
[10:29:52.355] - resignal: FALSE
[10:29:52.355] - force: TRUE
[10:29:52.355] - relayed: [n=2] TRUE, TRUE
[10:29:52.355] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:52.355] - relayed: [n=2] TRUE, TRUE
[10:29:52.355] - queued futures: [n=2] TRUE, TRUE
[10:29:52.355] signalConditionsASAP(NULL, pos=0) ... done
[10:29:52.355] resolve() on list ... DONE
[10:29:52.355] result() for ClusterFuture ...
[10:29:52.355] - result already collected: FutureResult
[10:29:52.356] result() for ClusterFuture ... done
[10:29:52.356] result() for ClusterFuture ...
[10:29:52.356] - result already collected: FutureResult
[10:29:52.356] result() for ClusterFuture ... done
[10:29:52.356] result() for ClusterFuture ...
[10:29:52.356] - result already collected: FutureResult
[10:29:52.356] result() for ClusterFuture ... done
[10:29:52.356] result() for ClusterFuture ...
[10:29:52.356] - result already collected: FutureResult
[10:29:52.356] result() for ClusterFuture ... done
[10:29:52.356]  - Number of value chunks collected: 2
[10:29:52.357] Resolving 2 futures (chunks) ... DONE
[10:29:52.357] Reducing values from 2 chunks ...
[10:29:52.357]  - Number of values collected after concatenation: 2
[10:29:52.357]  - Number of values expected: 2
[10:29:52.357] Reducing values from 2 chunks ... DONE
[10:29:52.357] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:29:52.357] getGlobalsAndPackagesXApply() ...
[10:29:52.357]  - future.globals: TRUE
[10:29:52.358] getGlobalsAndPackages() ...
[10:29:52.358] Searching for globals...
[10:29:52.360] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:29:52.361] Searching for globals ... DONE
[10:29:52.361] Resolving globals: FALSE
[10:29:52.361] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[10:29:52.362] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[10:29:52.362] - globals: [1] ‘FUN’
[10:29:52.362] 
[10:29:52.362] getGlobalsAndPackages() ... DONE
[10:29:52.362]  - globals found/used: [n=1] ‘FUN’
[10:29:52.362]  - needed namespaces: [n=0] 
[10:29:52.362] Finding globals ... DONE
[10:29:52.362]  - use_args: TRUE
[10:29:52.362]  - Getting '...' globals ...
[10:29:52.363] resolve() on list ...
[10:29:52.363]  recursive: 0
[10:29:52.363]  length: 1
[10:29:52.363]  elements: ‘...’
[10:29:52.363]  length: 0 (resolved future 1)
[10:29:52.363] resolve() on list ... DONE
[10:29:52.363]    - '...' content: [n=0] 
[10:29:52.363] List of 1
[10:29:52.363]  $ ...: list()
[10:29:52.363]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.363]  - attr(*, "where")=List of 1
[10:29:52.363]   ..$ ...:<environment: 0x5618a2b93b60> 
[10:29:52.363]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.363]  - attr(*, "resolved")= logi TRUE
[10:29:52.363]  - attr(*, "total_size")= num NA
[10:29:52.366]  - Getting '...' globals ... DONE
[10:29:52.366] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:52.366] List of 2
[10:29:52.366]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:29:52.366]  $ ...          : list()
[10:29:52.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.366]  - attr(*, "where")=List of 2
[10:29:52.366]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:52.366]   ..$ ...          :<environment: 0x5618a2b93b60> 
[10:29:52.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.366]  - attr(*, "resolved")= logi FALSE
[10:29:52.366]  - attr(*, "total_size")= num 36296
[10:29:52.369] Packages to be attached in all futures: [n=0] 
[10:29:52.369] getGlobalsAndPackagesXApply() ... DONE
[10:29:52.373] future_lapply() ...
[10:29:52.375] Generating random seeds ...
[10:29:52.375] Generating random seed streams for 2 elements ...
[10:29:52.375] Generating random seed streams for 2 elements ... DONE
[10:29:52.375] Generating random seeds ... DONE
[10:29:52.375] Will set RNG state on exit: 10407, -1527881283, 276035346, -1016084476, 1792857073, 1893536870, 1633484217
[10:29:52.379] Number of chunks: 2
[10:29:52.379] getGlobalsAndPackagesXApply() ...
[10:29:52.379]  - future.globals: <name-value list> with names ‘list()’
[10:29:52.379]  - use_args: TRUE
[10:29:52.379] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:29:52.379] List of 2
[10:29:52.379]  $ ...          : list()
[10:29:52.379]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.379]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:29:52.379]  - attr(*, "where")=List of 2
[10:29:52.379]   ..$ ...          :<environment: 0x5618a2b93b60> 
[10:29:52.379]   ..$ ...future.FUN:<environment: namespace:base> 
[10:29:52.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.379]  - attr(*, "resolved")= logi FALSE
[10:29:52.379]  - attr(*, "total_size")= num NA
[10:29:52.383] Packages to be attached in all futures: [n=0] 
[10:29:52.383] getGlobalsAndPackagesXApply() ... DONE
[10:29:52.383] Number of futures (= number of chunks): 2
[10:29:52.383] Launching 2 futures (chunks) ...
[10:29:52.383] Chunk #1 of 2 ...
[10:29:52.383]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:52.384]  - seeds: [1] <seeds>
[10:29:52.384]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.384] getGlobalsAndPackages() ...
[10:29:52.384] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.384] Resolving globals: FALSE
[10:29:52.384] Tweak future expression to call with '...' arguments ...
[10:29:52.384] {
[10:29:52.384]     do.call(function(...) {
[10:29:52.384]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.384]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.384]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.384]             on.exit(options(oopts), add = TRUE)
[10:29:52.384]         }
[10:29:52.384]         {
[10:29:52.384]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.384]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.384]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:52.384]                   envir = globalenv(), inherits = FALSE)
[10:29:52.384]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.384]             })
[10:29:52.384]         }
[10:29:52.384]     }, args = future.call.arguments)
[10:29:52.384] }
[10:29:52.384] Tweak future expression to call with '...' arguments ... DONE
[10:29:52.385] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.385] 
[10:29:52.385] getGlobalsAndPackages() ... DONE
[10:29:52.385] run() for ‘Future’ ...
[10:29:52.386] - state: ‘created’
[10:29:52.386] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:52.399] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.399] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:52.400]   - Field: ‘node’
[10:29:52.400]   - Field: ‘label’
[10:29:52.400]   - Field: ‘local’
[10:29:52.400]   - Field: ‘owner’
[10:29:52.400]   - Field: ‘envir’
[10:29:52.400]   - Field: ‘workers’
[10:29:52.400]   - Field: ‘packages’
[10:29:52.400]   - Field: ‘gc’
[10:29:52.400]   - Field: ‘conditions’
[10:29:52.400]   - Field: ‘persistent’
[10:29:52.400]   - Field: ‘expr’
[10:29:52.401]   - Field: ‘uuid’
[10:29:52.401]   - Field: ‘seed’
[10:29:52.401]   - Field: ‘version’
[10:29:52.401]   - Field: ‘result’
[10:29:52.401]   - Field: ‘asynchronous’
[10:29:52.401]   - Field: ‘calls’
[10:29:52.401]   - Field: ‘globals’
[10:29:52.401]   - Field: ‘stdout’
[10:29:52.401]   - Field: ‘earlySignal’
[10:29:52.401]   - Field: ‘lazy’
[10:29:52.402]   - Field: ‘state’
[10:29:52.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:52.402] - Launch lazy future ...
[10:29:52.402] Packages needed by the future expression (n = 0): <none>
[10:29:52.402] Packages needed by future strategies (n = 0): <none>
[10:29:52.403] {
[10:29:52.403]     {
[10:29:52.403]         {
[10:29:52.403]             ...future.startTime <- base::Sys.time()
[10:29:52.403]             {
[10:29:52.403]                 {
[10:29:52.403]                   {
[10:29:52.403]                     {
[10:29:52.403]                       base::local({
[10:29:52.403]                         has_future <- base::requireNamespace("future", 
[10:29:52.403]                           quietly = TRUE)
[10:29:52.403]                         if (has_future) {
[10:29:52.403]                           ns <- base::getNamespace("future")
[10:29:52.403]                           version <- ns[[".package"]][["version"]]
[10:29:52.403]                           if (is.null(version)) 
[10:29:52.403]                             version <- utils::packageVersion("future")
[10:29:52.403]                         }
[10:29:52.403]                         else {
[10:29:52.403]                           version <- NULL
[10:29:52.403]                         }
[10:29:52.403]                         if (!has_future || version < "1.8.0") {
[10:29:52.403]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:52.403]                             "", base::R.version$version.string), 
[10:29:52.403]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:52.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:52.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:52.403]                               "release", "version")], collapse = " "), 
[10:29:52.403]                             hostname = base::Sys.info()[["nodename"]])
[10:29:52.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:52.403]                             info)
[10:29:52.403]                           info <- base::paste(info, collapse = "; ")
[10:29:52.403]                           if (!has_future) {
[10:29:52.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:52.403]                               info)
[10:29:52.403]                           }
[10:29:52.403]                           else {
[10:29:52.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:52.403]                               info, version)
[10:29:52.403]                           }
[10:29:52.403]                           base::stop(msg)
[10:29:52.403]                         }
[10:29:52.403]                       })
[10:29:52.403]                     }
[10:29:52.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:52.403]                     base::options(mc.cores = 1L)
[10:29:52.403]                   }
[10:29:52.403]                   ...future.strategy.old <- future::plan("list")
[10:29:52.403]                   options(future.plan = NULL)
[10:29:52.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:52.403]                 }
[10:29:52.403]                 ...future.workdir <- getwd()
[10:29:52.403]             }
[10:29:52.403]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:52.403]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:52.403]         }
[10:29:52.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:52.403]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:52.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:52.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:52.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:52.403]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:52.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:52.403]             base::names(...future.oldOptions))
[10:29:52.403]     }
[10:29:52.403]     if (FALSE) {
[10:29:52.403]     }
[10:29:52.403]     else {
[10:29:52.403]         if (TRUE) {
[10:29:52.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:52.403]                 open = "w")
[10:29:52.403]         }
[10:29:52.403]         else {
[10:29:52.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:52.403]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:52.403]         }
[10:29:52.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:52.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:52.403]             base::sink(type = "output", split = FALSE)
[10:29:52.403]             base::close(...future.stdout)
[10:29:52.403]         }, add = TRUE)
[10:29:52.403]     }
[10:29:52.403]     ...future.frame <- base::sys.nframe()
[10:29:52.403]     ...future.conditions <- base::list()
[10:29:52.403]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:52.403]     if (FALSE) {
[10:29:52.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:52.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:52.403]     }
[10:29:52.403]     ...future.result <- base::tryCatch({
[10:29:52.403]         base::withCallingHandlers({
[10:29:52.403]             ...future.value <- base::withVisible(base::local({
[10:29:52.403]                 ...future.makeSendCondition <- base::local({
[10:29:52.403]                   sendCondition <- NULL
[10:29:52.403]                   function(frame = 1L) {
[10:29:52.403]                     if (is.function(sendCondition)) 
[10:29:52.403]                       return(sendCondition)
[10:29:52.403]                     ns <- getNamespace("parallel")
[10:29:52.403]                     if (exists("sendData", mode = "function", 
[10:29:52.403]                       envir = ns)) {
[10:29:52.403]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:52.403]                         envir = ns)
[10:29:52.403]                       envir <- sys.frame(frame)
[10:29:52.403]                       master <- NULL
[10:29:52.403]                       while (!identical(envir, .GlobalEnv) && 
[10:29:52.403]                         !identical(envir, emptyenv())) {
[10:29:52.403]                         if (exists("master", mode = "list", envir = envir, 
[10:29:52.403]                           inherits = FALSE)) {
[10:29:52.403]                           master <- get("master", mode = "list", 
[10:29:52.403]                             envir = envir, inherits = FALSE)
[10:29:52.403]                           if (inherits(master, c("SOCKnode", 
[10:29:52.403]                             "SOCK0node"))) {
[10:29:52.403]                             sendCondition <<- function(cond) {
[10:29:52.403]                               data <- list(type = "VALUE", value = cond, 
[10:29:52.403]                                 success = TRUE)
[10:29:52.403]                               parallel_sendData(master, data)
[10:29:52.403]                             }
[10:29:52.403]                             return(sendCondition)
[10:29:52.403]                           }
[10:29:52.403]                         }
[10:29:52.403]                         frame <- frame + 1L
[10:29:52.403]                         envir <- sys.frame(frame)
[10:29:52.403]                       }
[10:29:52.403]                     }
[10:29:52.403]                     sendCondition <<- function(cond) NULL
[10:29:52.403]                   }
[10:29:52.403]                 })
[10:29:52.403]                 withCallingHandlers({
[10:29:52.403]                   {
[10:29:52.403]                     do.call(function(...) {
[10:29:52.403]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.403]                       if (!identical(...future.globals.maxSize.org, 
[10:29:52.403]                         ...future.globals.maxSize)) {
[10:29:52.403]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.403]                         on.exit(options(oopts), add = TRUE)
[10:29:52.403]                       }
[10:29:52.403]                       {
[10:29:52.403]                         lapply(seq_along(...future.elements_ii), 
[10:29:52.403]                           FUN = function(jj) {
[10:29:52.403]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.403]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:52.403]                               envir = globalenv(), inherits = FALSE)
[10:29:52.403]                             ...future.FUN(...future.X_jj, ...)
[10:29:52.403]                           })
[10:29:52.403]                       }
[10:29:52.403]                     }, args = future.call.arguments)
[10:29:52.403]                   }
[10:29:52.403]                 }, immediateCondition = function(cond) {
[10:29:52.403]                   sendCondition <- ...future.makeSendCondition()
[10:29:52.403]                   sendCondition(cond)
[10:29:52.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.403]                   {
[10:29:52.403]                     inherits <- base::inherits
[10:29:52.403]                     invokeRestart <- base::invokeRestart
[10:29:52.403]                     is.null <- base::is.null
[10:29:52.403]                     muffled <- FALSE
[10:29:52.403]                     if (inherits(cond, "message")) {
[10:29:52.403]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:52.403]                       if (muffled) 
[10:29:52.403]                         invokeRestart("muffleMessage")
[10:29:52.403]                     }
[10:29:52.403]                     else if (inherits(cond, "warning")) {
[10:29:52.403]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:52.403]                       if (muffled) 
[10:29:52.403]                         invokeRestart("muffleWarning")
[10:29:52.403]                     }
[10:29:52.403]                     else if (inherits(cond, "condition")) {
[10:29:52.403]                       if (!is.null(pattern)) {
[10:29:52.403]                         computeRestarts <- base::computeRestarts
[10:29:52.403]                         grepl <- base::grepl
[10:29:52.403]                         restarts <- computeRestarts(cond)
[10:29:52.403]                         for (restart in restarts) {
[10:29:52.403]                           name <- restart$name
[10:29:52.403]                           if (is.null(name)) 
[10:29:52.403]                             next
[10:29:52.403]                           if (!grepl(pattern, name)) 
[10:29:52.403]                             next
[10:29:52.403]                           invokeRestart(restart)
[10:29:52.403]                           muffled <- TRUE
[10:29:52.403]                           break
[10:29:52.403]                         }
[10:29:52.403]                       }
[10:29:52.403]                     }
[10:29:52.403]                     invisible(muffled)
[10:29:52.403]                   }
[10:29:52.403]                   muffleCondition(cond)
[10:29:52.403]                 })
[10:29:52.403]             }))
[10:29:52.403]             future::FutureResult(value = ...future.value$value, 
[10:29:52.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.403]                   ...future.rng), globalenv = if (FALSE) 
[10:29:52.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:52.403]                     ...future.globalenv.names))
[10:29:52.403]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:52.403]         }, condition = base::local({
[10:29:52.403]             c <- base::c
[10:29:52.403]             inherits <- base::inherits
[10:29:52.403]             invokeRestart <- base::invokeRestart
[10:29:52.403]             length <- base::length
[10:29:52.403]             list <- base::list
[10:29:52.403]             seq.int <- base::seq.int
[10:29:52.403]             signalCondition <- base::signalCondition
[10:29:52.403]             sys.calls <- base::sys.calls
[10:29:52.403]             `[[` <- base::`[[`
[10:29:52.403]             `+` <- base::`+`
[10:29:52.403]             `<<-` <- base::`<<-`
[10:29:52.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:52.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:52.403]                   3L)]
[10:29:52.403]             }
[10:29:52.403]             function(cond) {
[10:29:52.403]                 is_error <- inherits(cond, "error")
[10:29:52.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:52.403]                   NULL)
[10:29:52.403]                 if (is_error) {
[10:29:52.403]                   sessionInformation <- function() {
[10:29:52.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:52.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:52.403]                       search = base::search(), system = base::Sys.info())
[10:29:52.403]                   }
[10:29:52.403]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:52.403]                     cond$call), session = sessionInformation(), 
[10:29:52.403]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:52.403]                   signalCondition(cond)
[10:29:52.403]                 }
[10:29:52.403]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:29:52.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:52.403]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:52.403]                   if (TRUE && !signal) {
[10:29:52.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.403]                     {
[10:29:52.403]                       inherits <- base::inherits
[10:29:52.403]                       invokeRestart <- base::invokeRestart
[10:29:52.403]                       is.null <- base::is.null
[10:29:52.403]                       muffled <- FALSE
[10:29:52.403]                       if (inherits(cond, "message")) {
[10:29:52.403]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.403]                         if (muffled) 
[10:29:52.403]                           invokeRestart("muffleMessage")
[10:29:52.403]                       }
[10:29:52.403]                       else if (inherits(cond, "warning")) {
[10:29:52.403]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.403]                         if (muffled) 
[10:29:52.403]                           invokeRestart("muffleWarning")
[10:29:52.403]                       }
[10:29:52.403]                       else if (inherits(cond, "condition")) {
[10:29:52.403]                         if (!is.null(pattern)) {
[10:29:52.403]                           computeRestarts <- base::computeRestarts
[10:29:52.403]                           grepl <- base::grepl
[10:29:52.403]                           restarts <- computeRestarts(cond)
[10:29:52.403]                           for (restart in restarts) {
[10:29:52.403]                             name <- restart$name
[10:29:52.403]                             if (is.null(name)) 
[10:29:52.403]                               next
[10:29:52.403]                             if (!grepl(pattern, name)) 
[10:29:52.403]                               next
[10:29:52.403]                             invokeRestart(restart)
[10:29:52.403]                             muffled <- TRUE
[10:29:52.403]                             break
[10:29:52.403]                           }
[10:29:52.403]                         }
[10:29:52.403]                       }
[10:29:52.403]                       invisible(muffled)
[10:29:52.403]                     }
[10:29:52.403]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.403]                   }
[10:29:52.403]                 }
[10:29:52.403]                 else {
[10:29:52.403]                   if (TRUE) {
[10:29:52.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.403]                     {
[10:29:52.403]                       inherits <- base::inherits
[10:29:52.403]                       invokeRestart <- base::invokeRestart
[10:29:52.403]                       is.null <- base::is.null
[10:29:52.403]                       muffled <- FALSE
[10:29:52.403]                       if (inherits(cond, "message")) {
[10:29:52.403]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.403]                         if (muffled) 
[10:29:52.403]                           invokeRestart("muffleMessage")
[10:29:52.403]                       }
[10:29:52.403]                       else if (inherits(cond, "warning")) {
[10:29:52.403]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.403]                         if (muffled) 
[10:29:52.403]                           invokeRestart("muffleWarning")
[10:29:52.403]                       }
[10:29:52.403]                       else if (inherits(cond, "condition")) {
[10:29:52.403]                         if (!is.null(pattern)) {
[10:29:52.403]                           computeRestarts <- base::computeRestarts
[10:29:52.403]                           grepl <- base::grepl
[10:29:52.403]                           restarts <- computeRestarts(cond)
[10:29:52.403]                           for (restart in restarts) {
[10:29:52.403]                             name <- restart$name
[10:29:52.403]                             if (is.null(name)) 
[10:29:52.403]                               next
[10:29:52.403]                             if (!grepl(pattern, name)) 
[10:29:52.403]                               next
[10:29:52.403]                             invokeRestart(restart)
[10:29:52.403]                             muffled <- TRUE
[10:29:52.403]                             break
[10:29:52.403]                           }
[10:29:52.403]                         }
[10:29:52.403]                       }
[10:29:52.403]                       invisible(muffled)
[10:29:52.403]                     }
[10:29:52.403]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.403]                   }
[10:29:52.403]                 }
[10:29:52.403]             }
[10:29:52.403]         }))
[10:29:52.403]     }, error = function(ex) {
[10:29:52.403]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:52.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.403]                 ...future.rng), started = ...future.startTime, 
[10:29:52.403]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:52.403]             version = "1.8"), class = "FutureResult")
[10:29:52.403]     }, finally = {
[10:29:52.403]         if (!identical(...future.workdir, getwd())) 
[10:29:52.403]             setwd(...future.workdir)
[10:29:52.403]         {
[10:29:52.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:52.403]                 ...future.oldOptions$nwarnings <- NULL
[10:29:52.403]             }
[10:29:52.403]             base::options(...future.oldOptions)
[10:29:52.403]             if (.Platform$OS.type == "windows") {
[10:29:52.403]                 old_names <- names(...future.oldEnvVars)
[10:29:52.403]                 envs <- base::Sys.getenv()
[10:29:52.403]                 names <- names(envs)
[10:29:52.403]                 common <- intersect(names, old_names)
[10:29:52.403]                 added <- setdiff(names, old_names)
[10:29:52.403]                 removed <- setdiff(old_names, names)
[10:29:52.403]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:52.403]                   envs[common]]
[10:29:52.403]                 NAMES <- toupper(changed)
[10:29:52.403]                 args <- list()
[10:29:52.403]                 for (kk in seq_along(NAMES)) {
[10:29:52.403]                   name <- changed[[kk]]
[10:29:52.403]                   NAME <- NAMES[[kk]]
[10:29:52.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.403]                     next
[10:29:52.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.403]                 }
[10:29:52.403]                 NAMES <- toupper(added)
[10:29:52.403]                 for (kk in seq_along(NAMES)) {
[10:29:52.403]                   name <- added[[kk]]
[10:29:52.403]                   NAME <- NAMES[[kk]]
[10:29:52.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.403]                     next
[10:29:52.403]                   args[[name]] <- ""
[10:29:52.403]                 }
[10:29:52.403]                 NAMES <- toupper(removed)
[10:29:52.403]                 for (kk in seq_along(NAMES)) {
[10:29:52.403]                   name <- removed[[kk]]
[10:29:52.403]                   NAME <- NAMES[[kk]]
[10:29:52.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.403]                     next
[10:29:52.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.403]                 }
[10:29:52.403]                 if (length(args) > 0) 
[10:29:52.403]                   base::do.call(base::Sys.setenv, args = args)
[10:29:52.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:52.403]             }
[10:29:52.403]             else {
[10:29:52.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:52.403]             }
[10:29:52.403]             {
[10:29:52.403]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:52.403]                   0L) {
[10:29:52.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:52.403]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:52.403]                   base::options(opts)
[10:29:52.403]                 }
[10:29:52.403]                 {
[10:29:52.403]                   {
[10:29:52.403]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:52.403]                     NULL
[10:29:52.403]                   }
[10:29:52.403]                   options(future.plan = NULL)
[10:29:52.403]                   if (is.na(NA_character_)) 
[10:29:52.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:52.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:52.403]                     .init = FALSE)
[10:29:52.403]                 }
[10:29:52.403]             }
[10:29:52.403]         }
[10:29:52.403]     })
[10:29:52.403]     if (TRUE) {
[10:29:52.403]         base::sink(type = "output", split = FALSE)
[10:29:52.403]         if (TRUE) {
[10:29:52.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:52.403]         }
[10:29:52.403]         else {
[10:29:52.403]             ...future.result["stdout"] <- base::list(NULL)
[10:29:52.403]         }
[10:29:52.403]         base::close(...future.stdout)
[10:29:52.403]         ...future.stdout <- NULL
[10:29:52.403]     }
[10:29:52.403]     ...future.result$conditions <- ...future.conditions
[10:29:52.403]     ...future.result$finished <- base::Sys.time()
[10:29:52.403]     ...future.result
[10:29:52.403] }
[10:29:52.406] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[10:29:52.406] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:52.406] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:52.406] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[10:29:52.449] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[10:29:52.449] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:29:52.450] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:29:52.450] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[10:29:52.450] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[10:29:52.450] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:52.451] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:52.451] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[10:29:52.451] MultisessionFuture started
[10:29:52.451] - Launch lazy future ... done
[10:29:52.451] run() for ‘MultisessionFuture’ ... done
[10:29:52.452] Created future:
[10:29:52.453] receiveMessageFromWorker() for ClusterFuture ...
[10:29:52.453] - Validating connection of MultisessionFuture
[10:29:52.453] - received message: FutureResult
[10:29:52.453] - Received FutureResult
[10:29:52.453] - Erased future from FutureRegistry
[10:29:52.454] result() for ClusterFuture ...
[10:29:52.454] - result already collected: FutureResult
[10:29:52.454] result() for ClusterFuture ... done
[10:29:52.454] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:52.452] MultisessionFuture:
[10:29:52.452] Label: ‘future_apply-1’
[10:29:52.452] Expression:
[10:29:52.452] {
[10:29:52.452]     do.call(function(...) {
[10:29:52.452]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.452]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.452]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.452]             on.exit(options(oopts), add = TRUE)
[10:29:52.452]         }
[10:29:52.452]         {
[10:29:52.452]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.452]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.452]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:52.452]                   envir = globalenv(), inherits = FALSE)
[10:29:52.452]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.452]             })
[10:29:52.452]         }
[10:29:52.452]     }, args = future.call.arguments)
[10:29:52.452] }
[10:29:52.452] Lazy evaluation: FALSE
[10:29:52.452] Asynchronous evaluation: TRUE
[10:29:52.452] Local evaluation: TRUE
[10:29:52.452] Environment: R_GlobalEnv
[10:29:52.452] Capture standard output: TRUE
[10:29:52.452] Capture condition classes: <none>
[10:29:52.452] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:52.452] Packages: <none>
[10:29:52.452] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:29:52.452] Resolved: TRUE
[10:29:52.452] Value: <not collected>
[10:29:52.452] Conditions captured: <none>
[10:29:52.452] Early signaling: FALSE
[10:29:52.452] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:52.452] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.454] Chunk #1 of 2 ... DONE
[10:29:52.454] Chunk #2 of 2 ...
[10:29:52.454]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:29:52.454]  - seeds: [1] <seeds>
[10:29:52.455]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.455] getGlobalsAndPackages() ...
[10:29:52.455] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.455] Resolving globals: FALSE
[10:29:52.455] Tweak future expression to call with '...' arguments ...
[10:29:52.455] {
[10:29:52.455]     do.call(function(...) {
[10:29:52.455]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.455]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.455]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.455]             on.exit(options(oopts), add = TRUE)
[10:29:52.455]         }
[10:29:52.455]         {
[10:29:52.455]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.455]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.455]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:52.455]                   envir = globalenv(), inherits = FALSE)
[10:29:52.455]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.455]             })
[10:29:52.455]         }
[10:29:52.455]     }, args = future.call.arguments)
[10:29:52.455] }
[10:29:52.455] Tweak future expression to call with '...' arguments ... DONE
[10:29:52.456] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.456] 
[10:29:52.456] getGlobalsAndPackages() ... DONE
[10:29:52.456] run() for ‘Future’ ...
[10:29:52.456] - state: ‘created’
[10:29:52.457] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:52.470] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.471] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:52.471]   - Field: ‘node’
[10:29:52.471]   - Field: ‘label’
[10:29:52.471]   - Field: ‘local’
[10:29:52.471]   - Field: ‘owner’
[10:29:52.471]   - Field: ‘envir’
[10:29:52.471]   - Field: ‘workers’
[10:29:52.471]   - Field: ‘packages’
[10:29:52.471]   - Field: ‘gc’
[10:29:52.471]   - Field: ‘conditions’
[10:29:52.471]   - Field: ‘persistent’
[10:29:52.472]   - Field: ‘expr’
[10:29:52.472]   - Field: ‘uuid’
[10:29:52.472]   - Field: ‘seed’
[10:29:52.472]   - Field: ‘version’
[10:29:52.472]   - Field: ‘result’
[10:29:52.472]   - Field: ‘asynchronous’
[10:29:52.472]   - Field: ‘calls’
[10:29:52.472]   - Field: ‘globals’
[10:29:52.472]   - Field: ‘stdout’
[10:29:52.472]   - Field: ‘earlySignal’
[10:29:52.472]   - Field: ‘lazy’
[10:29:52.473]   - Field: ‘state’
[10:29:52.473] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:52.473] - Launch lazy future ...
[10:29:52.473] Packages needed by the future expression (n = 0): <none>
[10:29:52.473] Packages needed by future strategies (n = 0): <none>
[10:29:52.474] {
[10:29:52.474]     {
[10:29:52.474]         {
[10:29:52.474]             ...future.startTime <- base::Sys.time()
[10:29:52.474]             {
[10:29:52.474]                 {
[10:29:52.474]                   {
[10:29:52.474]                     {
[10:29:52.474]                       base::local({
[10:29:52.474]                         has_future <- base::requireNamespace("future", 
[10:29:52.474]                           quietly = TRUE)
[10:29:52.474]                         if (has_future) {
[10:29:52.474]                           ns <- base::getNamespace("future")
[10:29:52.474]                           version <- ns[[".package"]][["version"]]
[10:29:52.474]                           if (is.null(version)) 
[10:29:52.474]                             version <- utils::packageVersion("future")
[10:29:52.474]                         }
[10:29:52.474]                         else {
[10:29:52.474]                           version <- NULL
[10:29:52.474]                         }
[10:29:52.474]                         if (!has_future || version < "1.8.0") {
[10:29:52.474]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:52.474]                             "", base::R.version$version.string), 
[10:29:52.474]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:52.474]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:52.474]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:52.474]                               "release", "version")], collapse = " "), 
[10:29:52.474]                             hostname = base::Sys.info()[["nodename"]])
[10:29:52.474]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:52.474]                             info)
[10:29:52.474]                           info <- base::paste(info, collapse = "; ")
[10:29:52.474]                           if (!has_future) {
[10:29:52.474]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:52.474]                               info)
[10:29:52.474]                           }
[10:29:52.474]                           else {
[10:29:52.474]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:52.474]                               info, version)
[10:29:52.474]                           }
[10:29:52.474]                           base::stop(msg)
[10:29:52.474]                         }
[10:29:52.474]                       })
[10:29:52.474]                     }
[10:29:52.474]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:52.474]                     base::options(mc.cores = 1L)
[10:29:52.474]                   }
[10:29:52.474]                   ...future.strategy.old <- future::plan("list")
[10:29:52.474]                   options(future.plan = NULL)
[10:29:52.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:52.474]                 }
[10:29:52.474]                 ...future.workdir <- getwd()
[10:29:52.474]             }
[10:29:52.474]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:52.474]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:52.474]         }
[10:29:52.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:52.474]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:29:52.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:52.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:52.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:52.474]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:52.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:52.474]             base::names(...future.oldOptions))
[10:29:52.474]     }
[10:29:52.474]     if (FALSE) {
[10:29:52.474]     }
[10:29:52.474]     else {
[10:29:52.474]         if (TRUE) {
[10:29:52.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:52.474]                 open = "w")
[10:29:52.474]         }
[10:29:52.474]         else {
[10:29:52.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:52.474]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:52.474]         }
[10:29:52.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:52.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:52.474]             base::sink(type = "output", split = FALSE)
[10:29:52.474]             base::close(...future.stdout)
[10:29:52.474]         }, add = TRUE)
[10:29:52.474]     }
[10:29:52.474]     ...future.frame <- base::sys.nframe()
[10:29:52.474]     ...future.conditions <- base::list()
[10:29:52.474]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:52.474]     if (FALSE) {
[10:29:52.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:52.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:52.474]     }
[10:29:52.474]     ...future.result <- base::tryCatch({
[10:29:52.474]         base::withCallingHandlers({
[10:29:52.474]             ...future.value <- base::withVisible(base::local({
[10:29:52.474]                 ...future.makeSendCondition <- base::local({
[10:29:52.474]                   sendCondition <- NULL
[10:29:52.474]                   function(frame = 1L) {
[10:29:52.474]                     if (is.function(sendCondition)) 
[10:29:52.474]                       return(sendCondition)
[10:29:52.474]                     ns <- getNamespace("parallel")
[10:29:52.474]                     if (exists("sendData", mode = "function", 
[10:29:52.474]                       envir = ns)) {
[10:29:52.474]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:52.474]                         envir = ns)
[10:29:52.474]                       envir <- sys.frame(frame)
[10:29:52.474]                       master <- NULL
[10:29:52.474]                       while (!identical(envir, .GlobalEnv) && 
[10:29:52.474]                         !identical(envir, emptyenv())) {
[10:29:52.474]                         if (exists("master", mode = "list", envir = envir, 
[10:29:52.474]                           inherits = FALSE)) {
[10:29:52.474]                           master <- get("master", mode = "list", 
[10:29:52.474]                             envir = envir, inherits = FALSE)
[10:29:52.474]                           if (inherits(master, c("SOCKnode", 
[10:29:52.474]                             "SOCK0node"))) {
[10:29:52.474]                             sendCondition <<- function(cond) {
[10:29:52.474]                               data <- list(type = "VALUE", value = cond, 
[10:29:52.474]                                 success = TRUE)
[10:29:52.474]                               parallel_sendData(master, data)
[10:29:52.474]                             }
[10:29:52.474]                             return(sendCondition)
[10:29:52.474]                           }
[10:29:52.474]                         }
[10:29:52.474]                         frame <- frame + 1L
[10:29:52.474]                         envir <- sys.frame(frame)
[10:29:52.474]                       }
[10:29:52.474]                     }
[10:29:52.474]                     sendCondition <<- function(cond) NULL
[10:29:52.474]                   }
[10:29:52.474]                 })
[10:29:52.474]                 withCallingHandlers({
[10:29:52.474]                   {
[10:29:52.474]                     do.call(function(...) {
[10:29:52.474]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.474]                       if (!identical(...future.globals.maxSize.org, 
[10:29:52.474]                         ...future.globals.maxSize)) {
[10:29:52.474]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.474]                         on.exit(options(oopts), add = TRUE)
[10:29:52.474]                       }
[10:29:52.474]                       {
[10:29:52.474]                         lapply(seq_along(...future.elements_ii), 
[10:29:52.474]                           FUN = function(jj) {
[10:29:52.474]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.474]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:52.474]                               envir = globalenv(), inherits = FALSE)
[10:29:52.474]                             ...future.FUN(...future.X_jj, ...)
[10:29:52.474]                           })
[10:29:52.474]                       }
[10:29:52.474]                     }, args = future.call.arguments)
[10:29:52.474]                   }
[10:29:52.474]                 }, immediateCondition = function(cond) {
[10:29:52.474]                   sendCondition <- ...future.makeSendCondition()
[10:29:52.474]                   sendCondition(cond)
[10:29:52.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.474]                   {
[10:29:52.474]                     inherits <- base::inherits
[10:29:52.474]                     invokeRestart <- base::invokeRestart
[10:29:52.474]                     is.null <- base::is.null
[10:29:52.474]                     muffled <- FALSE
[10:29:52.474]                     if (inherits(cond, "message")) {
[10:29:52.474]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:52.474]                       if (muffled) 
[10:29:52.474]                         invokeRestart("muffleMessage")
[10:29:52.474]                     }
[10:29:52.474]                     else if (inherits(cond, "warning")) {
[10:29:52.474]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:52.474]                       if (muffled) 
[10:29:52.474]                         invokeRestart("muffleWarning")
[10:29:52.474]                     }
[10:29:52.474]                     else if (inherits(cond, "condition")) {
[10:29:52.474]                       if (!is.null(pattern)) {
[10:29:52.474]                         computeRestarts <- base::computeRestarts
[10:29:52.474]                         grepl <- base::grepl
[10:29:52.474]                         restarts <- computeRestarts(cond)
[10:29:52.474]                         for (restart in restarts) {
[10:29:52.474]                           name <- restart$name
[10:29:52.474]                           if (is.null(name)) 
[10:29:52.474]                             next
[10:29:52.474]                           if (!grepl(pattern, name)) 
[10:29:52.474]                             next
[10:29:52.474]                           invokeRestart(restart)
[10:29:52.474]                           muffled <- TRUE
[10:29:52.474]                           break
[10:29:52.474]                         }
[10:29:52.474]                       }
[10:29:52.474]                     }
[10:29:52.474]                     invisible(muffled)
[10:29:52.474]                   }
[10:29:52.474]                   muffleCondition(cond)
[10:29:52.474]                 })
[10:29:52.474]             }))
[10:29:52.474]             future::FutureResult(value = ...future.value$value, 
[10:29:52.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.474]                   ...future.rng), globalenv = if (FALSE) 
[10:29:52.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:52.474]                     ...future.globalenv.names))
[10:29:52.474]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:52.474]         }, condition = base::local({
[10:29:52.474]             c <- base::c
[10:29:52.474]             inherits <- base::inherits
[10:29:52.474]             invokeRestart <- base::invokeRestart
[10:29:52.474]             length <- base::length
[10:29:52.474]             list <- base::list
[10:29:52.474]             seq.int <- base::seq.int
[10:29:52.474]             signalCondition <- base::signalCondition
[10:29:52.474]             sys.calls <- base::sys.calls
[10:29:52.474]             `[[` <- base::`[[`
[10:29:52.474]             `+` <- base::`+`
[10:29:52.474]             `<<-` <- base::`<<-`
[10:29:52.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:52.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:52.474]                   3L)]
[10:29:52.474]             }
[10:29:52.474]             function(cond) {
[10:29:52.474]                 is_error <- inherits(cond, "error")
[10:29:52.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:52.474]                   NULL)
[10:29:52.474]                 if (is_error) {
[10:29:52.474]                   sessionInformation <- function() {
[10:29:52.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:52.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:52.474]                       search = base::search(), system = base::Sys.info())
[10:29:52.474]                   }
[10:29:52.474]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:52.474]                     cond$call), session = sessionInformation(), 
[10:29:52.474]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:52.474]                   signalCondition(cond)
[10:29:52.474]                 }
[10:29:52.474]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:29:52.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:52.474]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:52.474]                   if (TRUE && !signal) {
[10:29:52.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.474]                     {
[10:29:52.474]                       inherits <- base::inherits
[10:29:52.474]                       invokeRestart <- base::invokeRestart
[10:29:52.474]                       is.null <- base::is.null
[10:29:52.474]                       muffled <- FALSE
[10:29:52.474]                       if (inherits(cond, "message")) {
[10:29:52.474]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.474]                         if (muffled) 
[10:29:52.474]                           invokeRestart("muffleMessage")
[10:29:52.474]                       }
[10:29:52.474]                       else if (inherits(cond, "warning")) {
[10:29:52.474]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.474]                         if (muffled) 
[10:29:52.474]                           invokeRestart("muffleWarning")
[10:29:52.474]                       }
[10:29:52.474]                       else if (inherits(cond, "condition")) {
[10:29:52.474]                         if (!is.null(pattern)) {
[10:29:52.474]                           computeRestarts <- base::computeRestarts
[10:29:52.474]                           grepl <- base::grepl
[10:29:52.474]                           restarts <- computeRestarts(cond)
[10:29:52.474]                           for (restart in restarts) {
[10:29:52.474]                             name <- restart$name
[10:29:52.474]                             if (is.null(name)) 
[10:29:52.474]                               next
[10:29:52.474]                             if (!grepl(pattern, name)) 
[10:29:52.474]                               next
[10:29:52.474]                             invokeRestart(restart)
[10:29:52.474]                             muffled <- TRUE
[10:29:52.474]                             break
[10:29:52.474]                           }
[10:29:52.474]                         }
[10:29:52.474]                       }
[10:29:52.474]                       invisible(muffled)
[10:29:52.474]                     }
[10:29:52.474]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.474]                   }
[10:29:52.474]                 }
[10:29:52.474]                 else {
[10:29:52.474]                   if (TRUE) {
[10:29:52.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.474]                     {
[10:29:52.474]                       inherits <- base::inherits
[10:29:52.474]                       invokeRestart <- base::invokeRestart
[10:29:52.474]                       is.null <- base::is.null
[10:29:52.474]                       muffled <- FALSE
[10:29:52.474]                       if (inherits(cond, "message")) {
[10:29:52.474]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.474]                         if (muffled) 
[10:29:52.474]                           invokeRestart("muffleMessage")
[10:29:52.474]                       }
[10:29:52.474]                       else if (inherits(cond, "warning")) {
[10:29:52.474]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.474]                         if (muffled) 
[10:29:52.474]                           invokeRestart("muffleWarning")
[10:29:52.474]                       }
[10:29:52.474]                       else if (inherits(cond, "condition")) {
[10:29:52.474]                         if (!is.null(pattern)) {
[10:29:52.474]                           computeRestarts <- base::computeRestarts
[10:29:52.474]                           grepl <- base::grepl
[10:29:52.474]                           restarts <- computeRestarts(cond)
[10:29:52.474]                           for (restart in restarts) {
[10:29:52.474]                             name <- restart$name
[10:29:52.474]                             if (is.null(name)) 
[10:29:52.474]                               next
[10:29:52.474]                             if (!grepl(pattern, name)) 
[10:29:52.474]                               next
[10:29:52.474]                             invokeRestart(restart)
[10:29:52.474]                             muffled <- TRUE
[10:29:52.474]                             break
[10:29:52.474]                           }
[10:29:52.474]                         }
[10:29:52.474]                       }
[10:29:52.474]                       invisible(muffled)
[10:29:52.474]                     }
[10:29:52.474]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.474]                   }
[10:29:52.474]                 }
[10:29:52.474]             }
[10:29:52.474]         }))
[10:29:52.474]     }, error = function(ex) {
[10:29:52.474]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:52.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.474]                 ...future.rng), started = ...future.startTime, 
[10:29:52.474]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:52.474]             version = "1.8"), class = "FutureResult")
[10:29:52.474]     }, finally = {
[10:29:52.474]         if (!identical(...future.workdir, getwd())) 
[10:29:52.474]             setwd(...future.workdir)
[10:29:52.474]         {
[10:29:52.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:52.474]                 ...future.oldOptions$nwarnings <- NULL
[10:29:52.474]             }
[10:29:52.474]             base::options(...future.oldOptions)
[10:29:52.474]             if (.Platform$OS.type == "windows") {
[10:29:52.474]                 old_names <- names(...future.oldEnvVars)
[10:29:52.474]                 envs <- base::Sys.getenv()
[10:29:52.474]                 names <- names(envs)
[10:29:52.474]                 common <- intersect(names, old_names)
[10:29:52.474]                 added <- setdiff(names, old_names)
[10:29:52.474]                 removed <- setdiff(old_names, names)
[10:29:52.474]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:52.474]                   envs[common]]
[10:29:52.474]                 NAMES <- toupper(changed)
[10:29:52.474]                 args <- list()
[10:29:52.474]                 for (kk in seq_along(NAMES)) {
[10:29:52.474]                   name <- changed[[kk]]
[10:29:52.474]                   NAME <- NAMES[[kk]]
[10:29:52.474]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.474]                     next
[10:29:52.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.474]                 }
[10:29:52.474]                 NAMES <- toupper(added)
[10:29:52.474]                 for (kk in seq_along(NAMES)) {
[10:29:52.474]                   name <- added[[kk]]
[10:29:52.474]                   NAME <- NAMES[[kk]]
[10:29:52.474]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.474]                     next
[10:29:52.474]                   args[[name]] <- ""
[10:29:52.474]                 }
[10:29:52.474]                 NAMES <- toupper(removed)
[10:29:52.474]                 for (kk in seq_along(NAMES)) {
[10:29:52.474]                   name <- removed[[kk]]
[10:29:52.474]                   NAME <- NAMES[[kk]]
[10:29:52.474]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.474]                     next
[10:29:52.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.474]                 }
[10:29:52.474]                 if (length(args) > 0) 
[10:29:52.474]                   base::do.call(base::Sys.setenv, args = args)
[10:29:52.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:52.474]             }
[10:29:52.474]             else {
[10:29:52.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:52.474]             }
[10:29:52.474]             {
[10:29:52.474]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:52.474]                   0L) {
[10:29:52.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:52.474]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:52.474]                   base::options(opts)
[10:29:52.474]                 }
[10:29:52.474]                 {
[10:29:52.474]                   {
[10:29:52.474]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:52.474]                     NULL
[10:29:52.474]                   }
[10:29:52.474]                   options(future.plan = NULL)
[10:29:52.474]                   if (is.na(NA_character_)) 
[10:29:52.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:52.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:52.474]                     .init = FALSE)
[10:29:52.474]                 }
[10:29:52.474]             }
[10:29:52.474]         }
[10:29:52.474]     })
[10:29:52.474]     if (TRUE) {
[10:29:52.474]         base::sink(type = "output", split = FALSE)
[10:29:52.474]         if (TRUE) {
[10:29:52.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:52.474]         }
[10:29:52.474]         else {
[10:29:52.474]             ...future.result["stdout"] <- base::list(NULL)
[10:29:52.474]         }
[10:29:52.474]         base::close(...future.stdout)
[10:29:52.474]         ...future.stdout <- NULL
[10:29:52.474]     }
[10:29:52.474]     ...future.result$conditions <- ...future.conditions
[10:29:52.474]     ...future.result$finished <- base::Sys.time()
[10:29:52.474]     ...future.result
[10:29:52.474] }
[10:29:52.476] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[10:29:52.477] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:52.477] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:52.477] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[10:29:52.521] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[10:29:52.521] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:29:52.522] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:29:52.522] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[10:29:52.522] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[10:29:52.522] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:29:52.523] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:29:52.523] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[10:29:52.523] MultisessionFuture started
[10:29:52.523] - Launch lazy future ... done
[10:29:52.523] run() for ‘MultisessionFuture’ ... done
[10:29:52.524] Created future:
[10:29:52.524] MultisessionFuture:
[10:29:52.524] Label: ‘future_apply-2’
[10:29:52.524] Expression:
[10:29:52.524] {
[10:29:52.524]     do.call(function(...) {
[10:29:52.524]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.524]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.524]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.524]             on.exit(options(oopts), add = TRUE)
[10:29:52.524]         }
[10:29:52.524]         {
[10:29:52.524]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.524]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.524]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:29:52.524]                   envir = globalenv(), inherits = FALSE)
[10:29:52.524]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.524]             })
[10:29:52.524]         }
[10:29:52.524]     }, args = future.call.arguments)
[10:29:52.524] }
[10:29:52.524] Lazy evaluation: FALSE
[10:29:52.524] Asynchronous evaluation: TRUE
[10:29:52.524] Local evaluation: TRUE
[10:29:52.524] Environment: R_GlobalEnv
[10:29:52.524] Capture standard output: TRUE
[10:29:52.524] Capture condition classes: <none>
[10:29:52.524] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:29:52.524] Packages: <none>
[10:29:52.524] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:29:52.524] Resolved: FALSE
[10:29:52.524] Value: <not collected>
[10:29:52.524] Conditions captured: <none>
[10:29:52.524] Early signaling: FALSE
[10:29:52.524] Owner process: 64278261-3bc8-fdb0-8f53-d1c854cc9be7
[10:29:52.524] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:52.537] Chunk #2 of 2 ... DONE
[10:29:52.538] Launching 2 futures (chunks) ... DONE
[10:29:52.538] Resolving 2 futures (chunks) ...
[10:29:52.538] resolve() on list ...
[10:29:52.538]  recursive: 0
[10:29:52.538]  length: 2
[10:29:52.538] 
[10:29:52.538] Future #1
[10:29:52.538] result() for ClusterFuture ...
[10:29:52.538] - result already collected: FutureResult
[10:29:52.538] result() for ClusterFuture ... done
[10:29:52.538] result() for ClusterFuture ...
[10:29:52.539] - result already collected: FutureResult
[10:29:52.539] result() for ClusterFuture ... done
[10:29:52.539] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:52.539] - nx: 2
[10:29:52.539] - relay: TRUE
[10:29:52.539] - stdout: TRUE
[10:29:52.539] - signal: TRUE
[10:29:52.539] - resignal: FALSE
[10:29:52.539] - force: TRUE
[10:29:52.539] - relayed: [n=2] FALSE, FALSE
[10:29:52.539] - queued futures: [n=2] FALSE, FALSE
[10:29:52.539]  - until=1
[10:29:52.540]  - relaying element #1
[10:29:52.540] result() for ClusterFuture ...
[10:29:52.540] - result already collected: FutureResult
[10:29:52.540] result() for ClusterFuture ... done
[10:29:52.540] result() for ClusterFuture ...
[10:29:52.540] - result already collected: FutureResult
[10:29:52.540] result() for ClusterFuture ... done
[10:29:52.540] result() for ClusterFuture ...
[10:29:52.540] - result already collected: FutureResult
[10:29:52.540] result() for ClusterFuture ... done
[10:29:52.540] result() for ClusterFuture ...
[10:29:52.540] - result already collected: FutureResult
[10:29:52.541] result() for ClusterFuture ... done
[10:29:52.541] - relayed: [n=2] TRUE, FALSE
[10:29:52.541] - queued futures: [n=2] TRUE, FALSE
[10:29:52.541] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:52.541]  length: 1 (resolved future 1)
[10:29:52.566] receiveMessageFromWorker() for ClusterFuture ...
[10:29:52.566] - Validating connection of MultisessionFuture
[10:29:52.567] - received message: FutureResult
[10:29:52.567] - Received FutureResult
[10:29:52.567] - Erased future from FutureRegistry
[10:29:52.567] result() for ClusterFuture ...
[10:29:52.567] - result already collected: FutureResult
[10:29:52.567] result() for ClusterFuture ... done
[10:29:52.567] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:52.567] Future #2
[10:29:52.568] result() for ClusterFuture ...
[10:29:52.568] - result already collected: FutureResult
[10:29:52.568] result() for ClusterFuture ... done
[10:29:52.568] result() for ClusterFuture ...
[10:29:52.568] - result already collected: FutureResult
[10:29:52.568] result() for ClusterFuture ... done
[10:29:52.568] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:52.568] - nx: 2
[10:29:52.568] - relay: TRUE
[10:29:52.568] - stdout: TRUE
[10:29:52.568] - signal: TRUE
[10:29:52.568] - resignal: FALSE
[10:29:52.569] - force: TRUE
[10:29:52.569] - relayed: [n=2] TRUE, FALSE
[10:29:52.569] - queued futures: [n=2] TRUE, FALSE
[10:29:52.569]  - until=2
[10:29:52.569]  - relaying element #2
[10:29:52.569] result() for ClusterFuture ...
[10:29:52.569] - result already collected: FutureResult
[10:29:52.569] result() for ClusterFuture ... done
[10:29:52.569] result() for ClusterFuture ...
[10:29:52.569] - result already collected: FutureResult
[10:29:52.569] result() for ClusterFuture ... done
[10:29:52.570] result() for ClusterFuture ...
[10:29:52.570] - result already collected: FutureResult
[10:29:52.570] result() for ClusterFuture ... done
[10:29:52.570] result() for ClusterFuture ...
[10:29:52.570] - result already collected: FutureResult
[10:29:52.570] result() for ClusterFuture ... done
[10:29:52.570] - relayed: [n=2] TRUE, TRUE
[10:29:52.570] - queued futures: [n=2] TRUE, TRUE
[10:29:52.570] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:52.570]  length: 0 (resolved future 2)
[10:29:52.570] Relaying remaining futures
[10:29:52.570] signalConditionsASAP(NULL, pos=0) ...
[10:29:52.571] - nx: 2
[10:29:52.571] - relay: TRUE
[10:29:52.571] - stdout: TRUE
[10:29:52.571] - signal: TRUE
[10:29:52.571] - resignal: FALSE
[10:29:52.571] - force: TRUE
[10:29:52.571] - relayed: [n=2] TRUE, TRUE
[10:29:52.571] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:52.571] - relayed: [n=2] TRUE, TRUE
[10:29:52.571] - queued futures: [n=2] TRUE, TRUE
[10:29:52.571] signalConditionsASAP(NULL, pos=0) ... done
[10:29:52.572] resolve() on list ... DONE
[10:29:52.572] result() for ClusterFuture ...
[10:29:52.572] - result already collected: FutureResult
[10:29:52.572] result() for ClusterFuture ... done
[10:29:52.572] result() for ClusterFuture ...
[10:29:52.572] - result already collected: FutureResult
[10:29:52.572] result() for ClusterFuture ... done
[10:29:52.572] result() for ClusterFuture ...
[10:29:52.572] - result already collected: FutureResult
[10:29:52.572] result() for ClusterFuture ... done
[10:29:52.572] result() for ClusterFuture ...
[10:29:52.572] - result already collected: FutureResult
[10:29:52.573] result() for ClusterFuture ... done
[10:29:52.573]  - Number of value chunks collected: 2
[10:29:52.573] Resolving 2 futures (chunks) ... DONE
[10:29:52.573] Reducing values from 2 chunks ...
[10:29:52.573]  - Number of values collected after concatenation: 2
[10:29:52.573]  - Number of values expected: 2
[10:29:52.573] Reducing values from 2 chunks ... DONE
[10:29:52.573] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:29:52.573] plan(): Setting new future strategy stack:
[10:29:52.574] List of future strategies:
[10:29:52.574] 1. sequential:
[10:29:52.574]    - args: function (..., envir = parent.frame())
[10:29:52.574]    - tweaked: FALSE
[10:29:52.574]    - call: plan(sequential)
[10:29:52.574] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[10:29:52.576] plan(): Setting new future strategy stack:
[10:29:52.576] List of future strategies:
[10:29:52.576] 1. FutureStrategy:
[10:29:52.576]    - args: function (..., envir = parent.frame())
[10:29:52.576]    - tweaked: FALSE
[10:29:52.576]    - call: future::plan(oplan)
[10:29:52.577] plan(): nbrOfWorkers() = 1
> 
