
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:33:35.895] plan(): Setting new future strategy stack:
[13:33:35.895] List of future strategies:
[13:33:35.895] 1. sequential:
[13:33:35.895]    - args: function (..., envir = parent.frame())
[13:33:35.895]    - tweaked: FALSE
[13:33:35.895]    - call: future::plan("sequential")
[13:33:35.908] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[13:33:35.964] plan(): Setting new future strategy stack:
[13:33:35.964] List of future strategies:
[13:33:35.964] 1. sequential:
[13:33:35.964]    - args: function (..., envir = parent.frame())
[13:33:35.964]    - tweaked: FALSE
[13:33:35.964]    - call: plan(strategy)
[13:33:35.974] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[13:33:35.975] getGlobalsAndPackagesXApply() ...
[13:33:35.975]  - future.globals: TRUE
[13:33:35.976] getGlobalsAndPackages() ...
[13:33:35.976] Searching for globals...
[13:33:36.015] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:33:36.015] Searching for globals ... DONE
[13:33:36.015] Resolving globals: FALSE
[13:33:36.017] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:33:36.018] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:33:36.018] - globals: [1] ‘FUN’
[13:33:36.018] 
[13:33:36.018] getGlobalsAndPackages() ... DONE
[13:33:36.018]  - globals found/used: [n=1] ‘FUN’
[13:33:36.018]  - needed namespaces: [n=0] 
[13:33:36.018] Finding globals ... DONE
[13:33:36.018]  - use_args: TRUE
[13:33:36.018]  - Getting '...' globals ...
[13:33:36.019] resolve() on list ...
[13:33:36.019]  recursive: 0
[13:33:36.020]  length: 1
[13:33:36.020]  elements: ‘...’
[13:33:36.020]  length: 0 (resolved future 1)
[13:33:36.020] resolve() on list ... DONE
[13:33:36.020]    - '...' content: [n=0] 
[13:33:36.020] List of 1
[13:33:36.020]  $ ...: list()
[13:33:36.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.020]  - attr(*, "where")=List of 1
[13:33:36.020]   ..$ ...:<environment: 0x55b949e7fad8> 
[13:33:36.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.020]  - attr(*, "resolved")= logi TRUE
[13:33:36.020]  - attr(*, "total_size")= num NA
[13:33:36.025]  - Getting '...' globals ... DONE
[13:33:36.025] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.025] List of 2
[13:33:36.025]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.025]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.025]  $ ...          : list()
[13:33:36.025]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.025]  - attr(*, "where")=List of 2
[13:33:36.025]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.025]   ..$ ...          :<environment: 0x55b949e7fad8> 
[13:33:36.025]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.025]  - attr(*, "resolved")= logi FALSE
[13:33:36.025]  - attr(*, "total_size")= num 354224
[13:33:36.028] Packages to be attached in all futures: [n=0] 
[13:33:36.028] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.028] future_lapply() ...
[13:33:36.059] Number of chunks: 1
[13:33:36.059] getGlobalsAndPackagesXApply() ...
[13:33:36.059]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.059]  - use_args: TRUE
[13:33:36.059] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.059] List of 2
[13:33:36.059]  $ ...          : list()
[13:33:36.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.059]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.059]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.059]  - attr(*, "where")=List of 2
[13:33:36.059]   ..$ ...          :<environment: 0x55b949e7fad8> 
[13:33:36.059]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:36.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.059]  - attr(*, "resolved")= logi FALSE
[13:33:36.059]  - attr(*, "total_size")= num NA
[13:33:36.062] Packages to be attached in all futures: [n=0] 
[13:33:36.062] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.063] Number of futures (= number of chunks): 1
[13:33:36.063] Launching 1 futures (chunks) ...
[13:33:36.063] Chunk #1 of 1 ...
[13:33:36.063]  - seeds: <none>
[13:33:36.063]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.063] getGlobalsAndPackages() ...
[13:33:36.064] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.064] Resolving globals: FALSE
[13:33:36.064] Tweak future expression to call with '...' arguments ...
[13:33:36.064] {
[13:33:36.064]     do.call(function(...) {
[13:33:36.064]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.064]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.064]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.064]             on.exit(options(oopts), add = TRUE)
[13:33:36.064]         }
[13:33:36.064]         {
[13:33:36.064]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.064]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.064]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.064]             })
[13:33:36.064]         }
[13:33:36.064]     }, args = future.call.arguments)
[13:33:36.064] }
[13:33:36.064] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.065] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.065] 
[13:33:36.065] getGlobalsAndPackages() ... DONE
[13:33:36.065] run() for ‘Future’ ...
[13:33:36.066] - state: ‘created’
[13:33:36.066] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:36.066] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.066] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:36.066]   - Field: ‘label’
[13:33:36.066]   - Field: ‘local’
[13:33:36.066]   - Field: ‘owner’
[13:33:36.067]   - Field: ‘envir’
[13:33:36.067]   - Field: ‘packages’
[13:33:36.067]   - Field: ‘gc’
[13:33:36.067]   - Field: ‘conditions’
[13:33:36.067]   - Field: ‘expr’
[13:33:36.067]   - Field: ‘uuid’
[13:33:36.067]   - Field: ‘seed’
[13:33:36.067]   - Field: ‘version’
[13:33:36.067]   - Field: ‘result’
[13:33:36.067]   - Field: ‘asynchronous’
[13:33:36.067]   - Field: ‘calls’
[13:33:36.068]   - Field: ‘globals’
[13:33:36.068]   - Field: ‘stdout’
[13:33:36.068]   - Field: ‘earlySignal’
[13:33:36.068]   - Field: ‘lazy’
[13:33:36.068]   - Field: ‘state’
[13:33:36.068] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:36.068] - Launch lazy future ...
[13:33:36.069] Packages needed by the future expression (n = 0): <none>
[13:33:36.069] Packages needed by future strategies (n = 0): <none>
[13:33:36.070] {
[13:33:36.070]     {
[13:33:36.070]         {
[13:33:36.070]             ...future.startTime <- base::Sys.time()
[13:33:36.070]             {
[13:33:36.070]                 {
[13:33:36.070]                   {
[13:33:36.070]                     base::local({
[13:33:36.070]                       has_future <- base::requireNamespace("future", 
[13:33:36.070]                         quietly = TRUE)
[13:33:36.070]                       if (has_future) {
[13:33:36.070]                         ns <- base::getNamespace("future")
[13:33:36.070]                         version <- ns[[".package"]][["version"]]
[13:33:36.070]                         if (is.null(version)) 
[13:33:36.070]                           version <- utils::packageVersion("future")
[13:33:36.070]                       }
[13:33:36.070]                       else {
[13:33:36.070]                         version <- NULL
[13:33:36.070]                       }
[13:33:36.070]                       if (!has_future || version < "1.8.0") {
[13:33:36.070]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.070]                           "", base::R.version$version.string), 
[13:33:36.070]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:36.070]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.070]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.070]                             "release", "version")], collapse = " "), 
[13:33:36.070]                           hostname = base::Sys.info()[["nodename"]])
[13:33:36.070]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.070]                           info)
[13:33:36.070]                         info <- base::paste(info, collapse = "; ")
[13:33:36.070]                         if (!has_future) {
[13:33:36.070]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.070]                             info)
[13:33:36.070]                         }
[13:33:36.070]                         else {
[13:33:36.070]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.070]                             info, version)
[13:33:36.070]                         }
[13:33:36.070]                         base::stop(msg)
[13:33:36.070]                       }
[13:33:36.070]                     })
[13:33:36.070]                   }
[13:33:36.070]                   ...future.strategy.old <- future::plan("list")
[13:33:36.070]                   options(future.plan = NULL)
[13:33:36.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.070]                 }
[13:33:36.070]                 ...future.workdir <- getwd()
[13:33:36.070]             }
[13:33:36.070]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.070]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.070]         }
[13:33:36.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.070]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.070]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.070]             base::names(...future.oldOptions))
[13:33:36.070]     }
[13:33:36.070]     if (FALSE) {
[13:33:36.070]     }
[13:33:36.070]     else {
[13:33:36.070]         if (TRUE) {
[13:33:36.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.070]                 open = "w")
[13:33:36.070]         }
[13:33:36.070]         else {
[13:33:36.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.070]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.070]         }
[13:33:36.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.070]             base::sink(type = "output", split = FALSE)
[13:33:36.070]             base::close(...future.stdout)
[13:33:36.070]         }, add = TRUE)
[13:33:36.070]     }
[13:33:36.070]     ...future.frame <- base::sys.nframe()
[13:33:36.070]     ...future.conditions <- base::list()
[13:33:36.070]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.070]     if (FALSE) {
[13:33:36.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.070]     }
[13:33:36.070]     ...future.result <- base::tryCatch({
[13:33:36.070]         base::withCallingHandlers({
[13:33:36.070]             ...future.value <- base::withVisible(base::local({
[13:33:36.070]                 do.call(function(...) {
[13:33:36.070]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.070]                   if (!identical(...future.globals.maxSize.org, 
[13:33:36.070]                     ...future.globals.maxSize)) {
[13:33:36.070]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.070]                     on.exit(options(oopts), add = TRUE)
[13:33:36.070]                   }
[13:33:36.070]                   {
[13:33:36.070]                     lapply(seq_along(...future.elements_ii), 
[13:33:36.070]                       FUN = function(jj) {
[13:33:36.070]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.070]                         ...future.FUN(...future.X_jj, ...)
[13:33:36.070]                       })
[13:33:36.070]                   }
[13:33:36.070]                 }, args = future.call.arguments)
[13:33:36.070]             }))
[13:33:36.070]             future::FutureResult(value = ...future.value$value, 
[13:33:36.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.070]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.070]                     ...future.globalenv.names))
[13:33:36.070]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.070]         }, condition = base::local({
[13:33:36.070]             c <- base::c
[13:33:36.070]             inherits <- base::inherits
[13:33:36.070]             invokeRestart <- base::invokeRestart
[13:33:36.070]             length <- base::length
[13:33:36.070]             list <- base::list
[13:33:36.070]             seq.int <- base::seq.int
[13:33:36.070]             signalCondition <- base::signalCondition
[13:33:36.070]             sys.calls <- base::sys.calls
[13:33:36.070]             `[[` <- base::`[[`
[13:33:36.070]             `+` <- base::`+`
[13:33:36.070]             `<<-` <- base::`<<-`
[13:33:36.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.070]                   3L)]
[13:33:36.070]             }
[13:33:36.070]             function(cond) {
[13:33:36.070]                 is_error <- inherits(cond, "error")
[13:33:36.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.070]                   NULL)
[13:33:36.070]                 if (is_error) {
[13:33:36.070]                   sessionInformation <- function() {
[13:33:36.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.070]                       search = base::search(), system = base::Sys.info())
[13:33:36.070]                   }
[13:33:36.070]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.070]                     cond$call), session = sessionInformation(), 
[13:33:36.070]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.070]                   signalCondition(cond)
[13:33:36.070]                 }
[13:33:36.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.070]                 "immediateCondition"))) {
[13:33:36.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.070]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.070]                   if (TRUE && !signal) {
[13:33:36.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.070]                     {
[13:33:36.070]                       inherits <- base::inherits
[13:33:36.070]                       invokeRestart <- base::invokeRestart
[13:33:36.070]                       is.null <- base::is.null
[13:33:36.070]                       muffled <- FALSE
[13:33:36.070]                       if (inherits(cond, "message")) {
[13:33:36.070]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.070]                         if (muffled) 
[13:33:36.070]                           invokeRestart("muffleMessage")
[13:33:36.070]                       }
[13:33:36.070]                       else if (inherits(cond, "warning")) {
[13:33:36.070]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.070]                         if (muffled) 
[13:33:36.070]                           invokeRestart("muffleWarning")
[13:33:36.070]                       }
[13:33:36.070]                       else if (inherits(cond, "condition")) {
[13:33:36.070]                         if (!is.null(pattern)) {
[13:33:36.070]                           computeRestarts <- base::computeRestarts
[13:33:36.070]                           grepl <- base::grepl
[13:33:36.070]                           restarts <- computeRestarts(cond)
[13:33:36.070]                           for (restart in restarts) {
[13:33:36.070]                             name <- restart$name
[13:33:36.070]                             if (is.null(name)) 
[13:33:36.070]                               next
[13:33:36.070]                             if (!grepl(pattern, name)) 
[13:33:36.070]                               next
[13:33:36.070]                             invokeRestart(restart)
[13:33:36.070]                             muffled <- TRUE
[13:33:36.070]                             break
[13:33:36.070]                           }
[13:33:36.070]                         }
[13:33:36.070]                       }
[13:33:36.070]                       invisible(muffled)
[13:33:36.070]                     }
[13:33:36.070]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.070]                   }
[13:33:36.070]                 }
[13:33:36.070]                 else {
[13:33:36.070]                   if (TRUE) {
[13:33:36.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.070]                     {
[13:33:36.070]                       inherits <- base::inherits
[13:33:36.070]                       invokeRestart <- base::invokeRestart
[13:33:36.070]                       is.null <- base::is.null
[13:33:36.070]                       muffled <- FALSE
[13:33:36.070]                       if (inherits(cond, "message")) {
[13:33:36.070]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.070]                         if (muffled) 
[13:33:36.070]                           invokeRestart("muffleMessage")
[13:33:36.070]                       }
[13:33:36.070]                       else if (inherits(cond, "warning")) {
[13:33:36.070]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.070]                         if (muffled) 
[13:33:36.070]                           invokeRestart("muffleWarning")
[13:33:36.070]                       }
[13:33:36.070]                       else if (inherits(cond, "condition")) {
[13:33:36.070]                         if (!is.null(pattern)) {
[13:33:36.070]                           computeRestarts <- base::computeRestarts
[13:33:36.070]                           grepl <- base::grepl
[13:33:36.070]                           restarts <- computeRestarts(cond)
[13:33:36.070]                           for (restart in restarts) {
[13:33:36.070]                             name <- restart$name
[13:33:36.070]                             if (is.null(name)) 
[13:33:36.070]                               next
[13:33:36.070]                             if (!grepl(pattern, name)) 
[13:33:36.070]                               next
[13:33:36.070]                             invokeRestart(restart)
[13:33:36.070]                             muffled <- TRUE
[13:33:36.070]                             break
[13:33:36.070]                           }
[13:33:36.070]                         }
[13:33:36.070]                       }
[13:33:36.070]                       invisible(muffled)
[13:33:36.070]                     }
[13:33:36.070]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.070]                   }
[13:33:36.070]                 }
[13:33:36.070]             }
[13:33:36.070]         }))
[13:33:36.070]     }, error = function(ex) {
[13:33:36.070]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.070]                 ...future.rng), started = ...future.startTime, 
[13:33:36.070]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.070]             version = "1.8"), class = "FutureResult")
[13:33:36.070]     }, finally = {
[13:33:36.070]         if (!identical(...future.workdir, getwd())) 
[13:33:36.070]             setwd(...future.workdir)
[13:33:36.070]         {
[13:33:36.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.070]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.070]             }
[13:33:36.070]             base::options(...future.oldOptions)
[13:33:36.070]             if (.Platform$OS.type == "windows") {
[13:33:36.070]                 old_names <- names(...future.oldEnvVars)
[13:33:36.070]                 envs <- base::Sys.getenv()
[13:33:36.070]                 names <- names(envs)
[13:33:36.070]                 common <- intersect(names, old_names)
[13:33:36.070]                 added <- setdiff(names, old_names)
[13:33:36.070]                 removed <- setdiff(old_names, names)
[13:33:36.070]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.070]                   envs[common]]
[13:33:36.070]                 NAMES <- toupper(changed)
[13:33:36.070]                 args <- list()
[13:33:36.070]                 for (kk in seq_along(NAMES)) {
[13:33:36.070]                   name <- changed[[kk]]
[13:33:36.070]                   NAME <- NAMES[[kk]]
[13:33:36.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.070]                     next
[13:33:36.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.070]                 }
[13:33:36.070]                 NAMES <- toupper(added)
[13:33:36.070]                 for (kk in seq_along(NAMES)) {
[13:33:36.070]                   name <- added[[kk]]
[13:33:36.070]                   NAME <- NAMES[[kk]]
[13:33:36.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.070]                     next
[13:33:36.070]                   args[[name]] <- ""
[13:33:36.070]                 }
[13:33:36.070]                 NAMES <- toupper(removed)
[13:33:36.070]                 for (kk in seq_along(NAMES)) {
[13:33:36.070]                   name <- removed[[kk]]
[13:33:36.070]                   NAME <- NAMES[[kk]]
[13:33:36.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.070]                     next
[13:33:36.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.070]                 }
[13:33:36.070]                 if (length(args) > 0) 
[13:33:36.070]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.070]             }
[13:33:36.070]             else {
[13:33:36.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.070]             }
[13:33:36.070]             {
[13:33:36.070]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.070]                   0L) {
[13:33:36.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.070]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.070]                   base::options(opts)
[13:33:36.070]                 }
[13:33:36.070]                 {
[13:33:36.070]                   {
[13:33:36.070]                     NULL
[13:33:36.070]                     RNGkind("Mersenne-Twister")
[13:33:36.070]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:36.070]                       inherits = FALSE)
[13:33:36.070]                   }
[13:33:36.070]                   options(future.plan = NULL)
[13:33:36.070]                   if (is.na(NA_character_)) 
[13:33:36.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.070]                     .init = FALSE)
[13:33:36.070]                 }
[13:33:36.070]             }
[13:33:36.070]         }
[13:33:36.070]     })
[13:33:36.070]     if (TRUE) {
[13:33:36.070]         base::sink(type = "output", split = FALSE)
[13:33:36.070]         if (TRUE) {
[13:33:36.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.070]         }
[13:33:36.070]         else {
[13:33:36.070]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.070]         }
[13:33:36.070]         base::close(...future.stdout)
[13:33:36.070]         ...future.stdout <- NULL
[13:33:36.070]     }
[13:33:36.070]     ...future.result$conditions <- ...future.conditions
[13:33:36.070]     ...future.result$finished <- base::Sys.time()
[13:33:36.070]     ...future.result
[13:33:36.070] }
[13:33:36.071] assign_globals() ...
[13:33:36.072] List of 5
[13:33:36.072]  $ future.call.arguments    : list()
[13:33:36.072]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.072]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.072]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.072]  $ ...future.elements_ii    :List of 2
[13:33:36.072]   ..$ : num [1:4] 1 3 1 7
[13:33:36.072]   ..$ : num [1:4] 2 4 6 8
[13:33:36.072]  $ ...future.seeds_ii       : NULL
[13:33:36.072]  $ ...future.globals.maxSize: num Inf
[13:33:36.072]  - attr(*, "resolved")= logi FALSE
[13:33:36.072]  - attr(*, "total_size")= num NA
[13:33:36.072]  - attr(*, "where")=List of 5
[13:33:36.072]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.072]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.072]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.072]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.072]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.072]  - attr(*, "already-done")= logi TRUE
[13:33:36.076] - copied ‘future.call.arguments’ to environment
[13:33:36.076] - copied ‘...future.FUN’ to environment
[13:33:36.076] - copied ‘...future.elements_ii’ to environment
[13:33:36.076] - copied ‘...future.seeds_ii’ to environment
[13:33:36.077] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.077] assign_globals() ... done
[13:33:36.077] plan(): Setting new future strategy stack:
[13:33:36.077] List of future strategies:
[13:33:36.077] 1. sequential:
[13:33:36.077]    - args: function (..., envir = parent.frame())
[13:33:36.077]    - tweaked: FALSE
[13:33:36.077]    - call: NULL
[13:33:36.077] plan(): nbrOfWorkers() = 1
[13:33:36.079] plan(): Setting new future strategy stack:
[13:33:36.079] List of future strategies:
[13:33:36.079] 1. sequential:
[13:33:36.079]    - args: function (..., envir = parent.frame())
[13:33:36.079]    - tweaked: FALSE
[13:33:36.079]    - call: plan(strategy)
[13:33:36.079] plan(): nbrOfWorkers() = 1
[13:33:36.079] SequentialFuture started (and completed)
[13:33:36.080] - Launch lazy future ... done
[13:33:36.080] run() for ‘SequentialFuture’ ... done
[13:33:36.080] Created future:
[13:33:36.080] SequentialFuture:
[13:33:36.080] Label: ‘future_apply-1’
[13:33:36.080] Expression:
[13:33:36.080] {
[13:33:36.080]     do.call(function(...) {
[13:33:36.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.080]             on.exit(options(oopts), add = TRUE)
[13:33:36.080]         }
[13:33:36.080]         {
[13:33:36.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.080]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.080]             })
[13:33:36.080]         }
[13:33:36.080]     }, args = future.call.arguments)
[13:33:36.080] }
[13:33:36.080] Lazy evaluation: FALSE
[13:33:36.080] Asynchronous evaluation: FALSE
[13:33:36.080] Local evaluation: TRUE
[13:33:36.080] Environment: R_GlobalEnv
[13:33:36.080] Capture standard output: TRUE
[13:33:36.080] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.080] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.080] Packages: <none>
[13:33:36.080] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.080] Resolved: TRUE
[13:33:36.080] Value: 2.21 KiB of class ‘list’
[13:33:36.080] Early signaling: FALSE
[13:33:36.080] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.080] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.083] Chunk #1 of 1 ... DONE
[13:33:36.083] Launching 1 futures (chunks) ... DONE
[13:33:36.083] Resolving 1 futures (chunks) ...
[13:33:36.083] resolve() on list ...
[13:33:36.083]  recursive: 0
[13:33:36.083]  length: 1
[13:33:36.083] 
[13:33:36.084] resolved() for ‘SequentialFuture’ ...
[13:33:36.084] - state: ‘finished’
[13:33:36.084] - run: TRUE
[13:33:36.084] - result: ‘FutureResult’
[13:33:36.084] resolved() for ‘SequentialFuture’ ... done
[13:33:36.084] Future #1
[13:33:36.084] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:36.084] - nx: 1
[13:33:36.085] - relay: TRUE
[13:33:36.085] - stdout: TRUE
[13:33:36.085] - signal: TRUE
[13:33:36.085] - resignal: FALSE
[13:33:36.085] - force: TRUE
[13:33:36.085] - relayed: [n=1] FALSE
[13:33:36.085] - queued futures: [n=1] FALSE
[13:33:36.085]  - until=1
[13:33:36.086]  - relaying element #1
[13:33:36.086] - relayed: [n=1] TRUE
[13:33:36.086] - queued futures: [n=1] TRUE
[13:33:36.086] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:36.086]  length: 0 (resolved future 1)
[13:33:36.087] Relaying remaining futures
[13:33:36.087] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.087] - nx: 1
[13:33:36.087] - relay: TRUE
[13:33:36.087] - stdout: TRUE
[13:33:36.087] - signal: TRUE
[13:33:36.087] - resignal: FALSE
[13:33:36.087] - force: TRUE
[13:33:36.087] - relayed: [n=1] TRUE
[13:33:36.088] - queued futures: [n=1] TRUE
 - flush all
[13:33:36.088] - relayed: [n=1] TRUE
[13:33:36.088] - queued futures: [n=1] TRUE
[13:33:36.088] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.088] resolve() on list ... DONE
[13:33:36.088]  - Number of value chunks collected: 1
[13:33:36.088] Resolving 1 futures (chunks) ... DONE
[13:33:36.088] Reducing values from 1 chunks ...
[13:33:36.088]  - Number of values collected after concatenation: 2
[13:33:36.088]  - Number of values expected: 2
[13:33:36.089] Reducing values from 1 chunks ... DONE
[13:33:36.089] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:33:36.090] getGlobalsAndPackagesXApply() ...
[13:33:36.090]  - future.globals: TRUE
[13:33:36.090] getGlobalsAndPackages() ...
[13:33:36.090] Searching for globals...
[13:33:36.120] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:33:36.121] Searching for globals ... DONE
[13:33:36.121] Resolving globals: FALSE
[13:33:36.122] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:33:36.123] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:33:36.123] - globals: [1] ‘FUN’
[13:33:36.123] 
[13:33:36.123] getGlobalsAndPackages() ... DONE
[13:33:36.123]  - globals found/used: [n=1] ‘FUN’
[13:33:36.123]  - needed namespaces: [n=0] 
[13:33:36.123] Finding globals ... DONE
[13:33:36.123]  - use_args: TRUE
[13:33:36.123]  - Getting '...' globals ...
[13:33:36.124] resolve() on list ...
[13:33:36.124]  recursive: 0
[13:33:36.124]  length: 1
[13:33:36.124]  elements: ‘...’
[13:33:36.124]  length: 0 (resolved future 1)
[13:33:36.124] resolve() on list ... DONE
[13:33:36.124]    - '...' content: [n=0] 
[13:33:36.124] List of 1
[13:33:36.124]  $ ...: list()
[13:33:36.124]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.124]  - attr(*, "where")=List of 1
[13:33:36.124]   ..$ ...:<environment: 0x55b9486879d8> 
[13:33:36.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.124]  - attr(*, "resolved")= logi TRUE
[13:33:36.124]  - attr(*, "total_size")= num NA
[13:33:36.127]  - Getting '...' globals ... DONE
[13:33:36.127] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.127] List of 2
[13:33:36.127]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.127]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.127]  $ ...          : list()
[13:33:36.127]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.127]  - attr(*, "where")=List of 2
[13:33:36.127]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.127]   ..$ ...          :<environment: 0x55b9486879d8> 
[13:33:36.127]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.127]  - attr(*, "resolved")= logi FALSE
[13:33:36.127]  - attr(*, "total_size")= num 354224
[13:33:36.129] Packages to be attached in all futures: [n=0] 
[13:33:36.129] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.130] future_lapply() ...
[13:33:36.158] Number of chunks: 1
[13:33:36.158] getGlobalsAndPackagesXApply() ...
[13:33:36.159]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.159]  - use_args: TRUE
[13:33:36.159] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.159] List of 2
[13:33:36.159]  $ ...          : list()
[13:33:36.159]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.159]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.159]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.159]  - attr(*, "where")=List of 2
[13:33:36.159]   ..$ ...          :<environment: 0x55b9486879d8> 
[13:33:36.159]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:36.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.159]  - attr(*, "resolved")= logi FALSE
[13:33:36.159]  - attr(*, "total_size")= num NA
[13:33:36.162] Packages to be attached in all futures: [n=0] 
[13:33:36.162] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.162] Number of futures (= number of chunks): 1
[13:33:36.162] Launching 1 futures (chunks) ...
[13:33:36.162] Chunk #1 of 1 ...
[13:33:36.163]  - seeds: <none>
[13:33:36.163]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.163] getGlobalsAndPackages() ...
[13:33:36.163] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.163] Resolving globals: FALSE
[13:33:36.163] Tweak future expression to call with '...' arguments ...
[13:33:36.163] {
[13:33:36.163]     do.call(function(...) {
[13:33:36.163]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.163]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.163]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.163]             on.exit(options(oopts), add = TRUE)
[13:33:36.163]         }
[13:33:36.163]         {
[13:33:36.163]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.163]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.163]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.163]             })
[13:33:36.163]         }
[13:33:36.163]     }, args = future.call.arguments)
[13:33:36.163] }
[13:33:36.163] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.164] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.164] 
[13:33:36.164] getGlobalsAndPackages() ... DONE
[13:33:36.164] run() for ‘Future’ ...
[13:33:36.164] - state: ‘created’
[13:33:36.164] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:36.165] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.165] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:36.165]   - Field: ‘label’
[13:33:36.165]   - Field: ‘local’
[13:33:36.165]   - Field: ‘owner’
[13:33:36.165]   - Field: ‘envir’
[13:33:36.165]   - Field: ‘packages’
[13:33:36.165]   - Field: ‘gc’
[13:33:36.165]   - Field: ‘conditions’
[13:33:36.165]   - Field: ‘expr’
[13:33:36.166]   - Field: ‘uuid’
[13:33:36.166]   - Field: ‘seed’
[13:33:36.166]   - Field: ‘version’
[13:33:36.166]   - Field: ‘result’
[13:33:36.166]   - Field: ‘asynchronous’
[13:33:36.166]   - Field: ‘calls’
[13:33:36.166]   - Field: ‘globals’
[13:33:36.166]   - Field: ‘stdout’
[13:33:36.166]   - Field: ‘earlySignal’
[13:33:36.166]   - Field: ‘lazy’
[13:33:36.166]   - Field: ‘state’
[13:33:36.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:36.167] - Launch lazy future ...
[13:33:36.167] Packages needed by the future expression (n = 0): <none>
[13:33:36.167] Packages needed by future strategies (n = 0): <none>
[13:33:36.167] {
[13:33:36.167]     {
[13:33:36.167]         {
[13:33:36.167]             ...future.startTime <- base::Sys.time()
[13:33:36.167]             {
[13:33:36.167]                 {
[13:33:36.167]                   {
[13:33:36.167]                     base::local({
[13:33:36.167]                       has_future <- base::requireNamespace("future", 
[13:33:36.167]                         quietly = TRUE)
[13:33:36.167]                       if (has_future) {
[13:33:36.167]                         ns <- base::getNamespace("future")
[13:33:36.167]                         version <- ns[[".package"]][["version"]]
[13:33:36.167]                         if (is.null(version)) 
[13:33:36.167]                           version <- utils::packageVersion("future")
[13:33:36.167]                       }
[13:33:36.167]                       else {
[13:33:36.167]                         version <- NULL
[13:33:36.167]                       }
[13:33:36.167]                       if (!has_future || version < "1.8.0") {
[13:33:36.167]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.167]                           "", base::R.version$version.string), 
[13:33:36.167]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:36.167]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.167]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.167]                             "release", "version")], collapse = " "), 
[13:33:36.167]                           hostname = base::Sys.info()[["nodename"]])
[13:33:36.167]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.167]                           info)
[13:33:36.167]                         info <- base::paste(info, collapse = "; ")
[13:33:36.167]                         if (!has_future) {
[13:33:36.167]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.167]                             info)
[13:33:36.167]                         }
[13:33:36.167]                         else {
[13:33:36.167]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.167]                             info, version)
[13:33:36.167]                         }
[13:33:36.167]                         base::stop(msg)
[13:33:36.167]                       }
[13:33:36.167]                     })
[13:33:36.167]                   }
[13:33:36.167]                   ...future.strategy.old <- future::plan("list")
[13:33:36.167]                   options(future.plan = NULL)
[13:33:36.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.167]                 }
[13:33:36.167]                 ...future.workdir <- getwd()
[13:33:36.167]             }
[13:33:36.167]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.167]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.167]         }
[13:33:36.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.167]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.167]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.167]             base::names(...future.oldOptions))
[13:33:36.167]     }
[13:33:36.167]     if (FALSE) {
[13:33:36.167]     }
[13:33:36.167]     else {
[13:33:36.167]         if (TRUE) {
[13:33:36.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.167]                 open = "w")
[13:33:36.167]         }
[13:33:36.167]         else {
[13:33:36.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.167]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.167]         }
[13:33:36.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.167]             base::sink(type = "output", split = FALSE)
[13:33:36.167]             base::close(...future.stdout)
[13:33:36.167]         }, add = TRUE)
[13:33:36.167]     }
[13:33:36.167]     ...future.frame <- base::sys.nframe()
[13:33:36.167]     ...future.conditions <- base::list()
[13:33:36.167]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.167]     if (FALSE) {
[13:33:36.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.167]     }
[13:33:36.167]     ...future.result <- base::tryCatch({
[13:33:36.167]         base::withCallingHandlers({
[13:33:36.167]             ...future.value <- base::withVisible(base::local({
[13:33:36.167]                 do.call(function(...) {
[13:33:36.167]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.167]                   if (!identical(...future.globals.maxSize.org, 
[13:33:36.167]                     ...future.globals.maxSize)) {
[13:33:36.167]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.167]                     on.exit(options(oopts), add = TRUE)
[13:33:36.167]                   }
[13:33:36.167]                   {
[13:33:36.167]                     lapply(seq_along(...future.elements_ii), 
[13:33:36.167]                       FUN = function(jj) {
[13:33:36.167]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.167]                         ...future.FUN(...future.X_jj, ...)
[13:33:36.167]                       })
[13:33:36.167]                   }
[13:33:36.167]                 }, args = future.call.arguments)
[13:33:36.167]             }))
[13:33:36.167]             future::FutureResult(value = ...future.value$value, 
[13:33:36.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.167]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.167]                     ...future.globalenv.names))
[13:33:36.167]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.167]         }, condition = base::local({
[13:33:36.167]             c <- base::c
[13:33:36.167]             inherits <- base::inherits
[13:33:36.167]             invokeRestart <- base::invokeRestart
[13:33:36.167]             length <- base::length
[13:33:36.167]             list <- base::list
[13:33:36.167]             seq.int <- base::seq.int
[13:33:36.167]             signalCondition <- base::signalCondition
[13:33:36.167]             sys.calls <- base::sys.calls
[13:33:36.167]             `[[` <- base::`[[`
[13:33:36.167]             `+` <- base::`+`
[13:33:36.167]             `<<-` <- base::`<<-`
[13:33:36.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.167]                   3L)]
[13:33:36.167]             }
[13:33:36.167]             function(cond) {
[13:33:36.167]                 is_error <- inherits(cond, "error")
[13:33:36.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.167]                   NULL)
[13:33:36.167]                 if (is_error) {
[13:33:36.167]                   sessionInformation <- function() {
[13:33:36.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.167]                       search = base::search(), system = base::Sys.info())
[13:33:36.167]                   }
[13:33:36.167]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.167]                     cond$call), session = sessionInformation(), 
[13:33:36.167]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.167]                   signalCondition(cond)
[13:33:36.167]                 }
[13:33:36.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.167]                 "immediateCondition"))) {
[13:33:36.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.167]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.167]                   if (TRUE && !signal) {
[13:33:36.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.167]                     {
[13:33:36.167]                       inherits <- base::inherits
[13:33:36.167]                       invokeRestart <- base::invokeRestart
[13:33:36.167]                       is.null <- base::is.null
[13:33:36.167]                       muffled <- FALSE
[13:33:36.167]                       if (inherits(cond, "message")) {
[13:33:36.167]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.167]                         if (muffled) 
[13:33:36.167]                           invokeRestart("muffleMessage")
[13:33:36.167]                       }
[13:33:36.167]                       else if (inherits(cond, "warning")) {
[13:33:36.167]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.167]                         if (muffled) 
[13:33:36.167]                           invokeRestart("muffleWarning")
[13:33:36.167]                       }
[13:33:36.167]                       else if (inherits(cond, "condition")) {
[13:33:36.167]                         if (!is.null(pattern)) {
[13:33:36.167]                           computeRestarts <- base::computeRestarts
[13:33:36.167]                           grepl <- base::grepl
[13:33:36.167]                           restarts <- computeRestarts(cond)
[13:33:36.167]                           for (restart in restarts) {
[13:33:36.167]                             name <- restart$name
[13:33:36.167]                             if (is.null(name)) 
[13:33:36.167]                               next
[13:33:36.167]                             if (!grepl(pattern, name)) 
[13:33:36.167]                               next
[13:33:36.167]                             invokeRestart(restart)
[13:33:36.167]                             muffled <- TRUE
[13:33:36.167]                             break
[13:33:36.167]                           }
[13:33:36.167]                         }
[13:33:36.167]                       }
[13:33:36.167]                       invisible(muffled)
[13:33:36.167]                     }
[13:33:36.167]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.167]                   }
[13:33:36.167]                 }
[13:33:36.167]                 else {
[13:33:36.167]                   if (TRUE) {
[13:33:36.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.167]                     {
[13:33:36.167]                       inherits <- base::inherits
[13:33:36.167]                       invokeRestart <- base::invokeRestart
[13:33:36.167]                       is.null <- base::is.null
[13:33:36.167]                       muffled <- FALSE
[13:33:36.167]                       if (inherits(cond, "message")) {
[13:33:36.167]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.167]                         if (muffled) 
[13:33:36.167]                           invokeRestart("muffleMessage")
[13:33:36.167]                       }
[13:33:36.167]                       else if (inherits(cond, "warning")) {
[13:33:36.167]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.167]                         if (muffled) 
[13:33:36.167]                           invokeRestart("muffleWarning")
[13:33:36.167]                       }
[13:33:36.167]                       else if (inherits(cond, "condition")) {
[13:33:36.167]                         if (!is.null(pattern)) {
[13:33:36.167]                           computeRestarts <- base::computeRestarts
[13:33:36.167]                           grepl <- base::grepl
[13:33:36.167]                           restarts <- computeRestarts(cond)
[13:33:36.167]                           for (restart in restarts) {
[13:33:36.167]                             name <- restart$name
[13:33:36.167]                             if (is.null(name)) 
[13:33:36.167]                               next
[13:33:36.167]                             if (!grepl(pattern, name)) 
[13:33:36.167]                               next
[13:33:36.167]                             invokeRestart(restart)
[13:33:36.167]                             muffled <- TRUE
[13:33:36.167]                             break
[13:33:36.167]                           }
[13:33:36.167]                         }
[13:33:36.167]                       }
[13:33:36.167]                       invisible(muffled)
[13:33:36.167]                     }
[13:33:36.167]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.167]                   }
[13:33:36.167]                 }
[13:33:36.167]             }
[13:33:36.167]         }))
[13:33:36.167]     }, error = function(ex) {
[13:33:36.167]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.167]                 ...future.rng), started = ...future.startTime, 
[13:33:36.167]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.167]             version = "1.8"), class = "FutureResult")
[13:33:36.167]     }, finally = {
[13:33:36.167]         if (!identical(...future.workdir, getwd())) 
[13:33:36.167]             setwd(...future.workdir)
[13:33:36.167]         {
[13:33:36.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.167]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.167]             }
[13:33:36.167]             base::options(...future.oldOptions)
[13:33:36.167]             if (.Platform$OS.type == "windows") {
[13:33:36.167]                 old_names <- names(...future.oldEnvVars)
[13:33:36.167]                 envs <- base::Sys.getenv()
[13:33:36.167]                 names <- names(envs)
[13:33:36.167]                 common <- intersect(names, old_names)
[13:33:36.167]                 added <- setdiff(names, old_names)
[13:33:36.167]                 removed <- setdiff(old_names, names)
[13:33:36.167]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.167]                   envs[common]]
[13:33:36.167]                 NAMES <- toupper(changed)
[13:33:36.167]                 args <- list()
[13:33:36.167]                 for (kk in seq_along(NAMES)) {
[13:33:36.167]                   name <- changed[[kk]]
[13:33:36.167]                   NAME <- NAMES[[kk]]
[13:33:36.167]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.167]                     next
[13:33:36.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.167]                 }
[13:33:36.167]                 NAMES <- toupper(added)
[13:33:36.167]                 for (kk in seq_along(NAMES)) {
[13:33:36.167]                   name <- added[[kk]]
[13:33:36.167]                   NAME <- NAMES[[kk]]
[13:33:36.167]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.167]                     next
[13:33:36.167]                   args[[name]] <- ""
[13:33:36.167]                 }
[13:33:36.167]                 NAMES <- toupper(removed)
[13:33:36.167]                 for (kk in seq_along(NAMES)) {
[13:33:36.167]                   name <- removed[[kk]]
[13:33:36.167]                   NAME <- NAMES[[kk]]
[13:33:36.167]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.167]                     next
[13:33:36.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.167]                 }
[13:33:36.167]                 if (length(args) > 0) 
[13:33:36.167]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.167]             }
[13:33:36.167]             else {
[13:33:36.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.167]             }
[13:33:36.167]             {
[13:33:36.167]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.167]                   0L) {
[13:33:36.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.167]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.167]                   base::options(opts)
[13:33:36.167]                 }
[13:33:36.167]                 {
[13:33:36.167]                   {
[13:33:36.167]                     NULL
[13:33:36.167]                     RNGkind("Mersenne-Twister")
[13:33:36.167]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:36.167]                       inherits = FALSE)
[13:33:36.167]                   }
[13:33:36.167]                   options(future.plan = NULL)
[13:33:36.167]                   if (is.na(NA_character_)) 
[13:33:36.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.167]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.167]                     .init = FALSE)
[13:33:36.167]                 }
[13:33:36.167]             }
[13:33:36.167]         }
[13:33:36.167]     })
[13:33:36.167]     if (TRUE) {
[13:33:36.167]         base::sink(type = "output", split = FALSE)
[13:33:36.167]         if (TRUE) {
[13:33:36.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.167]         }
[13:33:36.167]         else {
[13:33:36.167]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.167]         }
[13:33:36.167]         base::close(...future.stdout)
[13:33:36.167]         ...future.stdout <- NULL
[13:33:36.167]     }
[13:33:36.167]     ...future.result$conditions <- ...future.conditions
[13:33:36.167]     ...future.result$finished <- base::Sys.time()
[13:33:36.167]     ...future.result
[13:33:36.167] }
[13:33:36.169] assign_globals() ...
[13:33:36.169] List of 5
[13:33:36.169]  $ future.call.arguments    : list()
[13:33:36.169]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.169]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.169]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.169]  $ ...future.elements_ii    :List of 2
[13:33:36.169]   ..$ : num [1:4] 1 3 1 7
[13:33:36.169]   ..$ : num [1:4] 2 4 6 8
[13:33:36.169]  $ ...future.seeds_ii       : NULL
[13:33:36.169]  $ ...future.globals.maxSize: num Inf
[13:33:36.169]  - attr(*, "resolved")= logi FALSE
[13:33:36.169]  - attr(*, "total_size")= num NA
[13:33:36.169]  - attr(*, "where")=List of 5
[13:33:36.169]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.169]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.169]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.169]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.169]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.169]  - attr(*, "already-done")= logi TRUE
[13:33:36.174] - copied ‘future.call.arguments’ to environment
[13:33:36.175] - copied ‘...future.FUN’ to environment
[13:33:36.175] - copied ‘...future.elements_ii’ to environment
[13:33:36.175] - copied ‘...future.seeds_ii’ to environment
[13:33:36.175] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.175] assign_globals() ... done
[13:33:36.175] plan(): Setting new future strategy stack:
[13:33:36.175] List of future strategies:
[13:33:36.175] 1. sequential:
[13:33:36.175]    - args: function (..., envir = parent.frame())
[13:33:36.175]    - tweaked: FALSE
[13:33:36.175]    - call: NULL
[13:33:36.176] plan(): nbrOfWorkers() = 1
[13:33:36.176] plan(): Setting new future strategy stack:
[13:33:36.176] List of future strategies:
[13:33:36.176] 1. sequential:
[13:33:36.176]    - args: function (..., envir = parent.frame())
[13:33:36.176]    - tweaked: FALSE
[13:33:36.176]    - call: plan(strategy)
[13:33:36.177] plan(): nbrOfWorkers() = 1
[13:33:36.177] SequentialFuture started (and completed)
[13:33:36.177] - Launch lazy future ... done
[13:33:36.177] run() for ‘SequentialFuture’ ... done
[13:33:36.177] Created future:
[13:33:36.177] SequentialFuture:
[13:33:36.177] Label: ‘future_apply-1’
[13:33:36.177] Expression:
[13:33:36.177] {
[13:33:36.177]     do.call(function(...) {
[13:33:36.177]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.177]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.177]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.177]             on.exit(options(oopts), add = TRUE)
[13:33:36.177]         }
[13:33:36.177]         {
[13:33:36.177]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.177]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.177]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.177]             })
[13:33:36.177]         }
[13:33:36.177]     }, args = future.call.arguments)
[13:33:36.177] }
[13:33:36.177] Lazy evaluation: FALSE
[13:33:36.177] Asynchronous evaluation: FALSE
[13:33:36.177] Local evaluation: TRUE
[13:33:36.177] Environment: R_GlobalEnv
[13:33:36.177] Capture standard output: TRUE
[13:33:36.177] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.177] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.177] Packages: <none>
[13:33:36.177] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.177] Resolved: TRUE
[13:33:36.177] Value: 2.21 KiB of class ‘list’
[13:33:36.177] Early signaling: FALSE
[13:33:36.177] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.177] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.178] Chunk #1 of 1 ... DONE
[13:33:36.178] Launching 1 futures (chunks) ... DONE
[13:33:36.179] Resolving 1 futures (chunks) ...
[13:33:36.179] resolve() on list ...
[13:33:36.179]  recursive: 0
[13:33:36.179]  length: 1
[13:33:36.179] 
[13:33:36.179] resolved() for ‘SequentialFuture’ ...
[13:33:36.179] - state: ‘finished’
[13:33:36.179] - run: TRUE
[13:33:36.179] - result: ‘FutureResult’
[13:33:36.179] resolved() for ‘SequentialFuture’ ... done
[13:33:36.179] Future #1
[13:33:36.180] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:36.180] - nx: 1
[13:33:36.180] - relay: TRUE
[13:33:36.180] - stdout: TRUE
[13:33:36.180] - signal: TRUE
[13:33:36.180] - resignal: FALSE
[13:33:36.180] - force: TRUE
[13:33:36.180] - relayed: [n=1] FALSE
[13:33:36.180] - queued futures: [n=1] FALSE
[13:33:36.180]  - until=1
[13:33:36.180]  - relaying element #1
[13:33:36.181] - relayed: [n=1] TRUE
[13:33:36.181] - queued futures: [n=1] TRUE
[13:33:36.181] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:36.181]  length: 0 (resolved future 1)
[13:33:36.181] Relaying remaining futures
[13:33:36.181] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.181] - nx: 1
[13:33:36.181] - relay: TRUE
[13:33:36.181] - stdout: TRUE
[13:33:36.181] - signal: TRUE
[13:33:36.181] - resignal: FALSE
[13:33:36.181] - force: TRUE
[13:33:36.181] - relayed: [n=1] TRUE
[13:33:36.182] - queued futures: [n=1] TRUE
 - flush all
[13:33:36.182] - relayed: [n=1] TRUE
[13:33:36.182] - queued futures: [n=1] TRUE
[13:33:36.182] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.182] resolve() on list ... DONE
[13:33:36.182]  - Number of value chunks collected: 1
[13:33:36.182] Resolving 1 futures (chunks) ... DONE
[13:33:36.182] Reducing values from 1 chunks ...
[13:33:36.182]  - Number of values collected after concatenation: 2
[13:33:36.182]  - Number of values expected: 2
[13:33:36.182] Reducing values from 1 chunks ... DONE
[13:33:36.183] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:33:36.185] getGlobalsAndPackagesXApply() ...
[13:33:36.185]  - future.globals: TRUE
[13:33:36.185] getGlobalsAndPackages() ...
[13:33:36.185] Searching for globals...
[13:33:36.186] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:36.186] Searching for globals ... DONE
[13:33:36.186] Resolving globals: FALSE
[13:33:36.187] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:36.187] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:36.187] - globals: [1] ‘FUN’
[13:33:36.187] - packages: [1] ‘stats’
[13:33:36.187] getGlobalsAndPackages() ... DONE
[13:33:36.187]  - globals found/used: [n=1] ‘FUN’
[13:33:36.187]  - needed namespaces: [n=1] ‘stats’
[13:33:36.188] Finding globals ... DONE
[13:33:36.188]  - use_args: TRUE
[13:33:36.188]  - Getting '...' globals ...
[13:33:36.188] resolve() on list ...
[13:33:36.188]  recursive: 0
[13:33:36.188]  length: 1
[13:33:36.188]  elements: ‘...’
[13:33:36.188]  length: 0 (resolved future 1)
[13:33:36.188] resolve() on list ... DONE
[13:33:36.189]    - '...' content: [n=0] 
[13:33:36.189] List of 1
[13:33:36.189]  $ ...: list()
[13:33:36.189]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.189]  - attr(*, "where")=List of 1
[13:33:36.189]   ..$ ...:<environment: 0x55b949da30a8> 
[13:33:36.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.189]  - attr(*, "resolved")= logi TRUE
[13:33:36.189]  - attr(*, "total_size")= num NA
[13:33:36.191]  - Getting '...' globals ... DONE
[13:33:36.191] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.191] List of 2
[13:33:36.191]  $ ...future.FUN:function (x, ...)  
[13:33:36.191]  $ ...          : list()
[13:33:36.191]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.191]  - attr(*, "where")=List of 2
[13:33:36.191]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.191]   ..$ ...          :<environment: 0x55b949da30a8> 
[13:33:36.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.191]  - attr(*, "resolved")= logi FALSE
[13:33:36.191]  - attr(*, "total_size")= num 1248
[13:33:36.194] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:36.194] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.194] future_lapply() ...
[13:33:36.195] Number of chunks: 1
[13:33:36.195] getGlobalsAndPackagesXApply() ...
[13:33:36.195]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.196]  - use_args: TRUE
[13:33:36.196] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.196] List of 2
[13:33:36.196]  $ ...          : list()
[13:33:36.196]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.196]  $ ...future.FUN:function (x, ...)  
[13:33:36.196]  - attr(*, "where")=List of 2
[13:33:36.196]   ..$ ...          :<environment: 0x55b949da30a8> 
[13:33:36.196]   ..$ ...future.FUN:<environment: namespace:stats> 
[13:33:36.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.196]  - attr(*, "resolved")= logi FALSE
[13:33:36.196]  - attr(*, "total_size")= num NA
[13:33:36.198] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:36.198] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.199] Number of futures (= number of chunks): 1
[13:33:36.199] Launching 1 futures (chunks) ...
[13:33:36.199] Chunk #1 of 1 ...
[13:33:36.199]  - seeds: <none>
[13:33:36.199]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.199] getGlobalsAndPackages() ...
[13:33:36.199] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.199] Resolving globals: FALSE
[13:33:36.199] Tweak future expression to call with '...' arguments ...
[13:33:36.200] {
[13:33:36.200]     do.call(function(...) {
[13:33:36.200]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.200]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.200]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.200]             on.exit(options(oopts), add = TRUE)
[13:33:36.200]         }
[13:33:36.200]         {
[13:33:36.200]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.200]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.200]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.200]             })
[13:33:36.200]         }
[13:33:36.200]     }, args = future.call.arguments)
[13:33:36.200] }
[13:33:36.200] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.200] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.200] - packages: [1] ‘stats’
[13:33:36.200] getGlobalsAndPackages() ... DONE
[13:33:36.201] run() for ‘Future’ ...
[13:33:36.201] - state: ‘created’
[13:33:36.201] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:36.201] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:36.201]   - Field: ‘label’
[13:33:36.201]   - Field: ‘local’
[13:33:36.201]   - Field: ‘owner’
[13:33:36.201]   - Field: ‘envir’
[13:33:36.202]   - Field: ‘packages’
[13:33:36.202]   - Field: ‘gc’
[13:33:36.202]   - Field: ‘conditions’
[13:33:36.202]   - Field: ‘expr’
[13:33:36.202]   - Field: ‘uuid’
[13:33:36.202]   - Field: ‘seed’
[13:33:36.202]   - Field: ‘version’
[13:33:36.202]   - Field: ‘result’
[13:33:36.202]   - Field: ‘asynchronous’
[13:33:36.202]   - Field: ‘calls’
[13:33:36.202]   - Field: ‘globals’
[13:33:36.203]   - Field: ‘stdout’
[13:33:36.203]   - Field: ‘earlySignal’
[13:33:36.203]   - Field: ‘lazy’
[13:33:36.203]   - Field: ‘state’
[13:33:36.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:36.203] - Launch lazy future ...
[13:33:36.203] Packages needed by the future expression (n = 1): ‘stats’
[13:33:36.203] Packages needed by future strategies (n = 0): <none>
[13:33:36.204] {
[13:33:36.204]     {
[13:33:36.204]         {
[13:33:36.204]             ...future.startTime <- base::Sys.time()
[13:33:36.204]             {
[13:33:36.204]                 {
[13:33:36.204]                   {
[13:33:36.204]                     {
[13:33:36.204]                       base::local({
[13:33:36.204]                         has_future <- base::requireNamespace("future", 
[13:33:36.204]                           quietly = TRUE)
[13:33:36.204]                         if (has_future) {
[13:33:36.204]                           ns <- base::getNamespace("future")
[13:33:36.204]                           version <- ns[[".package"]][["version"]]
[13:33:36.204]                           if (is.null(version)) 
[13:33:36.204]                             version <- utils::packageVersion("future")
[13:33:36.204]                         }
[13:33:36.204]                         else {
[13:33:36.204]                           version <- NULL
[13:33:36.204]                         }
[13:33:36.204]                         if (!has_future || version < "1.8.0") {
[13:33:36.204]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.204]                             "", base::R.version$version.string), 
[13:33:36.204]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:36.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.204]                               "release", "version")], collapse = " "), 
[13:33:36.204]                             hostname = base::Sys.info()[["nodename"]])
[13:33:36.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.204]                             info)
[13:33:36.204]                           info <- base::paste(info, collapse = "; ")
[13:33:36.204]                           if (!has_future) {
[13:33:36.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.204]                               info)
[13:33:36.204]                           }
[13:33:36.204]                           else {
[13:33:36.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.204]                               info, version)
[13:33:36.204]                           }
[13:33:36.204]                           base::stop(msg)
[13:33:36.204]                         }
[13:33:36.204]                       })
[13:33:36.204]                     }
[13:33:36.204]                     base::local({
[13:33:36.204]                       for (pkg in "stats") {
[13:33:36.204]                         base::loadNamespace(pkg)
[13:33:36.204]                         base::library(pkg, character.only = TRUE)
[13:33:36.204]                       }
[13:33:36.204]                     })
[13:33:36.204]                   }
[13:33:36.204]                   ...future.strategy.old <- future::plan("list")
[13:33:36.204]                   options(future.plan = NULL)
[13:33:36.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.204]                 }
[13:33:36.204]                 ...future.workdir <- getwd()
[13:33:36.204]             }
[13:33:36.204]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.204]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.204]         }
[13:33:36.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.204]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.204]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.204]             base::names(...future.oldOptions))
[13:33:36.204]     }
[13:33:36.204]     if (FALSE) {
[13:33:36.204]     }
[13:33:36.204]     else {
[13:33:36.204]         if (TRUE) {
[13:33:36.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.204]                 open = "w")
[13:33:36.204]         }
[13:33:36.204]         else {
[13:33:36.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.204]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.204]         }
[13:33:36.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.204]             base::sink(type = "output", split = FALSE)
[13:33:36.204]             base::close(...future.stdout)
[13:33:36.204]         }, add = TRUE)
[13:33:36.204]     }
[13:33:36.204]     ...future.frame <- base::sys.nframe()
[13:33:36.204]     ...future.conditions <- base::list()
[13:33:36.204]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.204]     if (FALSE) {
[13:33:36.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.204]     }
[13:33:36.204]     ...future.result <- base::tryCatch({
[13:33:36.204]         base::withCallingHandlers({
[13:33:36.204]             ...future.value <- base::withVisible(base::local({
[13:33:36.204]                 do.call(function(...) {
[13:33:36.204]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.204]                   if (!identical(...future.globals.maxSize.org, 
[13:33:36.204]                     ...future.globals.maxSize)) {
[13:33:36.204]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.204]                     on.exit(options(oopts), add = TRUE)
[13:33:36.204]                   }
[13:33:36.204]                   {
[13:33:36.204]                     lapply(seq_along(...future.elements_ii), 
[13:33:36.204]                       FUN = function(jj) {
[13:33:36.204]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.204]                         ...future.FUN(...future.X_jj, ...)
[13:33:36.204]                       })
[13:33:36.204]                   }
[13:33:36.204]                 }, args = future.call.arguments)
[13:33:36.204]             }))
[13:33:36.204]             future::FutureResult(value = ...future.value$value, 
[13:33:36.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.204]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.204]                     ...future.globalenv.names))
[13:33:36.204]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.204]         }, condition = base::local({
[13:33:36.204]             c <- base::c
[13:33:36.204]             inherits <- base::inherits
[13:33:36.204]             invokeRestart <- base::invokeRestart
[13:33:36.204]             length <- base::length
[13:33:36.204]             list <- base::list
[13:33:36.204]             seq.int <- base::seq.int
[13:33:36.204]             signalCondition <- base::signalCondition
[13:33:36.204]             sys.calls <- base::sys.calls
[13:33:36.204]             `[[` <- base::`[[`
[13:33:36.204]             `+` <- base::`+`
[13:33:36.204]             `<<-` <- base::`<<-`
[13:33:36.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.204]                   3L)]
[13:33:36.204]             }
[13:33:36.204]             function(cond) {
[13:33:36.204]                 is_error <- inherits(cond, "error")
[13:33:36.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.204]                   NULL)
[13:33:36.204]                 if (is_error) {
[13:33:36.204]                   sessionInformation <- function() {
[13:33:36.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.204]                       search = base::search(), system = base::Sys.info())
[13:33:36.204]                   }
[13:33:36.204]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.204]                     cond$call), session = sessionInformation(), 
[13:33:36.204]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.204]                   signalCondition(cond)
[13:33:36.204]                 }
[13:33:36.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.204]                 "immediateCondition"))) {
[13:33:36.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.204]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.204]                   if (TRUE && !signal) {
[13:33:36.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.204]                     {
[13:33:36.204]                       inherits <- base::inherits
[13:33:36.204]                       invokeRestart <- base::invokeRestart
[13:33:36.204]                       is.null <- base::is.null
[13:33:36.204]                       muffled <- FALSE
[13:33:36.204]                       if (inherits(cond, "message")) {
[13:33:36.204]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.204]                         if (muffled) 
[13:33:36.204]                           invokeRestart("muffleMessage")
[13:33:36.204]                       }
[13:33:36.204]                       else if (inherits(cond, "warning")) {
[13:33:36.204]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.204]                         if (muffled) 
[13:33:36.204]                           invokeRestart("muffleWarning")
[13:33:36.204]                       }
[13:33:36.204]                       else if (inherits(cond, "condition")) {
[13:33:36.204]                         if (!is.null(pattern)) {
[13:33:36.204]                           computeRestarts <- base::computeRestarts
[13:33:36.204]                           grepl <- base::grepl
[13:33:36.204]                           restarts <- computeRestarts(cond)
[13:33:36.204]                           for (restart in restarts) {
[13:33:36.204]                             name <- restart$name
[13:33:36.204]                             if (is.null(name)) 
[13:33:36.204]                               next
[13:33:36.204]                             if (!grepl(pattern, name)) 
[13:33:36.204]                               next
[13:33:36.204]                             invokeRestart(restart)
[13:33:36.204]                             muffled <- TRUE
[13:33:36.204]                             break
[13:33:36.204]                           }
[13:33:36.204]                         }
[13:33:36.204]                       }
[13:33:36.204]                       invisible(muffled)
[13:33:36.204]                     }
[13:33:36.204]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.204]                   }
[13:33:36.204]                 }
[13:33:36.204]                 else {
[13:33:36.204]                   if (TRUE) {
[13:33:36.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.204]                     {
[13:33:36.204]                       inherits <- base::inherits
[13:33:36.204]                       invokeRestart <- base::invokeRestart
[13:33:36.204]                       is.null <- base::is.null
[13:33:36.204]                       muffled <- FALSE
[13:33:36.204]                       if (inherits(cond, "message")) {
[13:33:36.204]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.204]                         if (muffled) 
[13:33:36.204]                           invokeRestart("muffleMessage")
[13:33:36.204]                       }
[13:33:36.204]                       else if (inherits(cond, "warning")) {
[13:33:36.204]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.204]                         if (muffled) 
[13:33:36.204]                           invokeRestart("muffleWarning")
[13:33:36.204]                       }
[13:33:36.204]                       else if (inherits(cond, "condition")) {
[13:33:36.204]                         if (!is.null(pattern)) {
[13:33:36.204]                           computeRestarts <- base::computeRestarts
[13:33:36.204]                           grepl <- base::grepl
[13:33:36.204]                           restarts <- computeRestarts(cond)
[13:33:36.204]                           for (restart in restarts) {
[13:33:36.204]                             name <- restart$name
[13:33:36.204]                             if (is.null(name)) 
[13:33:36.204]                               next
[13:33:36.204]                             if (!grepl(pattern, name)) 
[13:33:36.204]                               next
[13:33:36.204]                             invokeRestart(restart)
[13:33:36.204]                             muffled <- TRUE
[13:33:36.204]                             break
[13:33:36.204]                           }
[13:33:36.204]                         }
[13:33:36.204]                       }
[13:33:36.204]                       invisible(muffled)
[13:33:36.204]                     }
[13:33:36.204]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.204]                   }
[13:33:36.204]                 }
[13:33:36.204]             }
[13:33:36.204]         }))
[13:33:36.204]     }, error = function(ex) {
[13:33:36.204]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.204]                 ...future.rng), started = ...future.startTime, 
[13:33:36.204]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.204]             version = "1.8"), class = "FutureResult")
[13:33:36.204]     }, finally = {
[13:33:36.204]         if (!identical(...future.workdir, getwd())) 
[13:33:36.204]             setwd(...future.workdir)
[13:33:36.204]         {
[13:33:36.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.204]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.204]             }
[13:33:36.204]             base::options(...future.oldOptions)
[13:33:36.204]             if (.Platform$OS.type == "windows") {
[13:33:36.204]                 old_names <- names(...future.oldEnvVars)
[13:33:36.204]                 envs <- base::Sys.getenv()
[13:33:36.204]                 names <- names(envs)
[13:33:36.204]                 common <- intersect(names, old_names)
[13:33:36.204]                 added <- setdiff(names, old_names)
[13:33:36.204]                 removed <- setdiff(old_names, names)
[13:33:36.204]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.204]                   envs[common]]
[13:33:36.204]                 NAMES <- toupper(changed)
[13:33:36.204]                 args <- list()
[13:33:36.204]                 for (kk in seq_along(NAMES)) {
[13:33:36.204]                   name <- changed[[kk]]
[13:33:36.204]                   NAME <- NAMES[[kk]]
[13:33:36.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.204]                     next
[13:33:36.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.204]                 }
[13:33:36.204]                 NAMES <- toupper(added)
[13:33:36.204]                 for (kk in seq_along(NAMES)) {
[13:33:36.204]                   name <- added[[kk]]
[13:33:36.204]                   NAME <- NAMES[[kk]]
[13:33:36.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.204]                     next
[13:33:36.204]                   args[[name]] <- ""
[13:33:36.204]                 }
[13:33:36.204]                 NAMES <- toupper(removed)
[13:33:36.204]                 for (kk in seq_along(NAMES)) {
[13:33:36.204]                   name <- removed[[kk]]
[13:33:36.204]                   NAME <- NAMES[[kk]]
[13:33:36.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.204]                     next
[13:33:36.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.204]                 }
[13:33:36.204]                 if (length(args) > 0) 
[13:33:36.204]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.204]             }
[13:33:36.204]             else {
[13:33:36.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.204]             }
[13:33:36.204]             {
[13:33:36.204]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.204]                   0L) {
[13:33:36.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.204]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.204]                   base::options(opts)
[13:33:36.204]                 }
[13:33:36.204]                 {
[13:33:36.204]                   {
[13:33:36.204]                     NULL
[13:33:36.204]                     RNGkind("Mersenne-Twister")
[13:33:36.204]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:36.204]                       inherits = FALSE)
[13:33:36.204]                   }
[13:33:36.204]                   options(future.plan = NULL)
[13:33:36.204]                   if (is.na(NA_character_)) 
[13:33:36.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.204]                     .init = FALSE)
[13:33:36.204]                 }
[13:33:36.204]             }
[13:33:36.204]         }
[13:33:36.204]     })
[13:33:36.204]     if (TRUE) {
[13:33:36.204]         base::sink(type = "output", split = FALSE)
[13:33:36.204]         if (TRUE) {
[13:33:36.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.204]         }
[13:33:36.204]         else {
[13:33:36.204]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.204]         }
[13:33:36.204]         base::close(...future.stdout)
[13:33:36.204]         ...future.stdout <- NULL
[13:33:36.204]     }
[13:33:36.204]     ...future.result$conditions <- ...future.conditions
[13:33:36.204]     ...future.result$finished <- base::Sys.time()
[13:33:36.204]     ...future.result
[13:33:36.204] }
[13:33:36.205] assign_globals() ...
[13:33:36.205] List of 5
[13:33:36.205]  $ future.call.arguments    : list()
[13:33:36.205]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.205]  $ ...future.FUN            :function (x, ...)  
[13:33:36.205]  $ ...future.elements_ii    :List of 2
[13:33:36.205]   ..$ : num [1:4] 1 3 1 7
[13:33:36.205]   ..$ : num [1:4] 2 4 6 8
[13:33:36.205]  $ ...future.seeds_ii       : NULL
[13:33:36.205]  $ ...future.globals.maxSize: num Inf
[13:33:36.205]  - attr(*, "resolved")= logi FALSE
[13:33:36.205]  - attr(*, "total_size")= num NA
[13:33:36.205]  - attr(*, "where")=List of 5
[13:33:36.205]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.205]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.205]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.205]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.205]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.205]  - attr(*, "already-done")= logi TRUE
[13:33:36.210] - copied ‘future.call.arguments’ to environment
[13:33:36.210] - copied ‘...future.FUN’ to environment
[13:33:36.210] - copied ‘...future.elements_ii’ to environment
[13:33:36.210] - copied ‘...future.seeds_ii’ to environment
[13:33:36.210] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.210] assign_globals() ... done
[13:33:36.211] plan(): Setting new future strategy stack:
[13:33:36.211] List of future strategies:
[13:33:36.211] 1. sequential:
[13:33:36.211]    - args: function (..., envir = parent.frame())
[13:33:36.211]    - tweaked: FALSE
[13:33:36.211]    - call: NULL
[13:33:36.211] plan(): nbrOfWorkers() = 1
[13:33:36.212] plan(): Setting new future strategy stack:
[13:33:36.212] List of future strategies:
[13:33:36.212] 1. sequential:
[13:33:36.212]    - args: function (..., envir = parent.frame())
[13:33:36.212]    - tweaked: FALSE
[13:33:36.212]    - call: plan(strategy)
[13:33:36.213] plan(): nbrOfWorkers() = 1
[13:33:36.213] SequentialFuture started (and completed)
[13:33:36.213] - Launch lazy future ... done
[13:33:36.213] run() for ‘SequentialFuture’ ... done
[13:33:36.213] Created future:
[13:33:36.213] SequentialFuture:
[13:33:36.213] Label: ‘future_apply-1’
[13:33:36.213] Expression:
[13:33:36.213] {
[13:33:36.213]     do.call(function(...) {
[13:33:36.213]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.213]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.213]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.213]             on.exit(options(oopts), add = TRUE)
[13:33:36.213]         }
[13:33:36.213]         {
[13:33:36.213]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.213]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.213]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.213]             })
[13:33:36.213]         }
[13:33:36.213]     }, args = future.call.arguments)
[13:33:36.213] }
[13:33:36.213] Lazy evaluation: FALSE
[13:33:36.213] Asynchronous evaluation: FALSE
[13:33:36.213] Local evaluation: TRUE
[13:33:36.213] Environment: R_GlobalEnv
[13:33:36.213] Capture standard output: TRUE
[13:33:36.213] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.213] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.213] Packages: 1 packages (‘stats’)
[13:33:36.213] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.213] Resolved: TRUE
[13:33:36.213] Value: 1.14 KiB of class ‘list’
[13:33:36.213] Early signaling: FALSE
[13:33:36.213] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.213] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.214] Chunk #1 of 1 ... DONE
[13:33:36.214] Launching 1 futures (chunks) ... DONE
[13:33:36.214] Resolving 1 futures (chunks) ...
[13:33:36.214] resolve() on list ...
[13:33:36.215]  recursive: 0
[13:33:36.215]  length: 1
[13:33:36.215] 
[13:33:36.215] resolved() for ‘SequentialFuture’ ...
[13:33:36.215] - state: ‘finished’
[13:33:36.215] - run: TRUE
[13:33:36.215] - result: ‘FutureResult’
[13:33:36.215] resolved() for ‘SequentialFuture’ ... done
[13:33:36.215] Future #1
[13:33:36.215] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:36.215] - nx: 1
[13:33:36.216] - relay: TRUE
[13:33:36.216] - stdout: TRUE
[13:33:36.216] - signal: TRUE
[13:33:36.217] - resignal: FALSE
[13:33:36.217] - force: TRUE
[13:33:36.217] - relayed: [n=1] FALSE
[13:33:36.217] - queued futures: [n=1] FALSE
[13:33:36.217]  - until=1
[13:33:36.217]  - relaying element #1
[13:33:36.217] - relayed: [n=1] TRUE
[13:33:36.217] - queued futures: [n=1] TRUE
[13:33:36.217] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:36.217]  length: 0 (resolved future 1)
[13:33:36.218] Relaying remaining futures
[13:33:36.218] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.218] - nx: 1
[13:33:36.218] - relay: TRUE
[13:33:36.218] - stdout: TRUE
[13:33:36.218] - signal: TRUE
[13:33:36.218] - resignal: FALSE
[13:33:36.218] - force: TRUE
[13:33:36.218] - relayed: [n=1] TRUE
[13:33:36.218] - queued futures: [n=1] TRUE
 - flush all
[13:33:36.218] - relayed: [n=1] TRUE
[13:33:36.218] - queued futures: [n=1] TRUE
[13:33:36.219] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.219] resolve() on list ... DONE
[13:33:36.219]  - Number of value chunks collected: 1
[13:33:36.219] Resolving 1 futures (chunks) ... DONE
[13:33:36.219] Reducing values from 1 chunks ...
[13:33:36.219]  - Number of values collected after concatenation: 2
[13:33:36.219]  - Number of values expected: 2
[13:33:36.219] Reducing values from 1 chunks ... DONE
[13:33:36.219] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[13:33:36.220] getGlobalsAndPackagesXApply() ...
[13:33:36.220]  - future.globals: TRUE
[13:33:36.220] getGlobalsAndPackages() ...
[13:33:36.220] Searching for globals...
[13:33:36.221] - globals found: [1] ‘FUN’
[13:33:36.221] Searching for globals ... DONE
[13:33:36.221] Resolving globals: FALSE
[13:33:36.222] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:36.222] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:36.222] - globals: [1] ‘FUN’
[13:33:36.222] 
[13:33:36.222] getGlobalsAndPackages() ... DONE
[13:33:36.222]  - globals found/used: [n=1] ‘FUN’
[13:33:36.222]  - needed namespaces: [n=0] 
[13:33:36.222] Finding globals ... DONE
[13:33:36.223]  - use_args: TRUE
[13:33:36.223]  - Getting '...' globals ...
[13:33:36.223] resolve() on list ...
[13:33:36.223]  recursive: 0
[13:33:36.223]  length: 1
[13:33:36.223]  elements: ‘...’
[13:33:36.223]  length: 0 (resolved future 1)
[13:33:36.223] resolve() on list ... DONE
[13:33:36.223]    - '...' content: [n=0] 
[13:33:36.224] List of 1
[13:33:36.224]  $ ...: list()
[13:33:36.224]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.224]  - attr(*, "where")=List of 1
[13:33:36.224]   ..$ ...:<environment: 0x55b94878ba08> 
[13:33:36.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.224]  - attr(*, "resolved")= logi TRUE
[13:33:36.224]  - attr(*, "total_size")= num NA
[13:33:36.226]  - Getting '...' globals ... DONE
[13:33:36.226] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.226] List of 2
[13:33:36.226]  $ ...future.FUN:function (x)  
[13:33:36.226]  $ ...          : list()
[13:33:36.226]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.226]  - attr(*, "where")=List of 2
[13:33:36.226]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.226]   ..$ ...          :<environment: 0x55b94878ba08> 
[13:33:36.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.226]  - attr(*, "resolved")= logi FALSE
[13:33:36.226]  - attr(*, "total_size")= num 848
[13:33:36.228] Packages to be attached in all futures: [n=0] 
[13:33:36.228] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.229] future_lapply() ...
[13:33:36.229] Number of chunks: 1
[13:33:36.229] getGlobalsAndPackagesXApply() ...
[13:33:36.229]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.229]  - use_args: TRUE
[13:33:36.230] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.230] List of 2
[13:33:36.230]  $ ...          : list()
[13:33:36.230]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.230]  $ ...future.FUN:function (x)  
[13:33:36.230]  - attr(*, "where")=List of 2
[13:33:36.230]   ..$ ...          :<environment: 0x55b94878ba08> 
[13:33:36.230]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:36.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.230]  - attr(*, "resolved")= logi FALSE
[13:33:36.230]  - attr(*, "total_size")= num NA
[13:33:36.233] Packages to be attached in all futures: [n=0] 
[13:33:36.233] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.233] Number of futures (= number of chunks): 1
[13:33:36.233] Launching 1 futures (chunks) ...
[13:33:36.233] Chunk #1 of 1 ...
[13:33:36.233]  - seeds: <none>
[13:33:36.233]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.233] getGlobalsAndPackages() ...
[13:33:36.233] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.234] Resolving globals: FALSE
[13:33:36.234] Tweak future expression to call with '...' arguments ...
[13:33:36.234] {
[13:33:36.234]     do.call(function(...) {
[13:33:36.234]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.234]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.234]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.234]             on.exit(options(oopts), add = TRUE)
[13:33:36.234]         }
[13:33:36.234]         {
[13:33:36.234]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.234]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.234]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.234]             })
[13:33:36.234]         }
[13:33:36.234]     }, args = future.call.arguments)
[13:33:36.234] }
[13:33:36.234] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.234] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.234] 
[13:33:36.235] getGlobalsAndPackages() ... DONE
[13:33:36.235] run() for ‘Future’ ...
[13:33:36.235] - state: ‘created’
[13:33:36.235] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:36.235] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.235] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:36.235]   - Field: ‘label’
[13:33:36.236]   - Field: ‘local’
[13:33:36.236]   - Field: ‘owner’
[13:33:36.236]   - Field: ‘envir’
[13:33:36.237]   - Field: ‘packages’
[13:33:36.237]   - Field: ‘gc’
[13:33:36.237]   - Field: ‘conditions’
[13:33:36.237]   - Field: ‘expr’
[13:33:36.237]   - Field: ‘uuid’
[13:33:36.237]   - Field: ‘seed’
[13:33:36.237]   - Field: ‘version’
[13:33:36.237]   - Field: ‘result’
[13:33:36.237]   - Field: ‘asynchronous’
[13:33:36.237]   - Field: ‘calls’
[13:33:36.237]   - Field: ‘globals’
[13:33:36.238]   - Field: ‘stdout’
[13:33:36.238]   - Field: ‘earlySignal’
[13:33:36.238]   - Field: ‘lazy’
[13:33:36.238]   - Field: ‘state’
[13:33:36.238] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:36.238] - Launch lazy future ...
[13:33:36.238] Packages needed by the future expression (n = 0): <none>
[13:33:36.238] Packages needed by future strategies (n = 0): <none>
[13:33:36.239] {
[13:33:36.239]     {
[13:33:36.239]         {
[13:33:36.239]             ...future.startTime <- base::Sys.time()
[13:33:36.239]             {
[13:33:36.239]                 {
[13:33:36.239]                   {
[13:33:36.239]                     base::local({
[13:33:36.239]                       has_future <- base::requireNamespace("future", 
[13:33:36.239]                         quietly = TRUE)
[13:33:36.239]                       if (has_future) {
[13:33:36.239]                         ns <- base::getNamespace("future")
[13:33:36.239]                         version <- ns[[".package"]][["version"]]
[13:33:36.239]                         if (is.null(version)) 
[13:33:36.239]                           version <- utils::packageVersion("future")
[13:33:36.239]                       }
[13:33:36.239]                       else {
[13:33:36.239]                         version <- NULL
[13:33:36.239]                       }
[13:33:36.239]                       if (!has_future || version < "1.8.0") {
[13:33:36.239]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.239]                           "", base::R.version$version.string), 
[13:33:36.239]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:36.239]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.239]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.239]                             "release", "version")], collapse = " "), 
[13:33:36.239]                           hostname = base::Sys.info()[["nodename"]])
[13:33:36.239]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.239]                           info)
[13:33:36.239]                         info <- base::paste(info, collapse = "; ")
[13:33:36.239]                         if (!has_future) {
[13:33:36.239]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.239]                             info)
[13:33:36.239]                         }
[13:33:36.239]                         else {
[13:33:36.239]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.239]                             info, version)
[13:33:36.239]                         }
[13:33:36.239]                         base::stop(msg)
[13:33:36.239]                       }
[13:33:36.239]                     })
[13:33:36.239]                   }
[13:33:36.239]                   ...future.strategy.old <- future::plan("list")
[13:33:36.239]                   options(future.plan = NULL)
[13:33:36.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.239]                 }
[13:33:36.239]                 ...future.workdir <- getwd()
[13:33:36.239]             }
[13:33:36.239]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.239]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.239]         }
[13:33:36.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.239]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.239]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.239]             base::names(...future.oldOptions))
[13:33:36.239]     }
[13:33:36.239]     if (FALSE) {
[13:33:36.239]     }
[13:33:36.239]     else {
[13:33:36.239]         if (TRUE) {
[13:33:36.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.239]                 open = "w")
[13:33:36.239]         }
[13:33:36.239]         else {
[13:33:36.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.239]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.239]         }
[13:33:36.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.239]             base::sink(type = "output", split = FALSE)
[13:33:36.239]             base::close(...future.stdout)
[13:33:36.239]         }, add = TRUE)
[13:33:36.239]     }
[13:33:36.239]     ...future.frame <- base::sys.nframe()
[13:33:36.239]     ...future.conditions <- base::list()
[13:33:36.239]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.239]     if (FALSE) {
[13:33:36.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.239]     }
[13:33:36.239]     ...future.result <- base::tryCatch({
[13:33:36.239]         base::withCallingHandlers({
[13:33:36.239]             ...future.value <- base::withVisible(base::local({
[13:33:36.239]                 do.call(function(...) {
[13:33:36.239]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.239]                   if (!identical(...future.globals.maxSize.org, 
[13:33:36.239]                     ...future.globals.maxSize)) {
[13:33:36.239]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.239]                     on.exit(options(oopts), add = TRUE)
[13:33:36.239]                   }
[13:33:36.239]                   {
[13:33:36.239]                     lapply(seq_along(...future.elements_ii), 
[13:33:36.239]                       FUN = function(jj) {
[13:33:36.239]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.239]                         ...future.FUN(...future.X_jj, ...)
[13:33:36.239]                       })
[13:33:36.239]                   }
[13:33:36.239]                 }, args = future.call.arguments)
[13:33:36.239]             }))
[13:33:36.239]             future::FutureResult(value = ...future.value$value, 
[13:33:36.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.239]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.239]                     ...future.globalenv.names))
[13:33:36.239]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.239]         }, condition = base::local({
[13:33:36.239]             c <- base::c
[13:33:36.239]             inherits <- base::inherits
[13:33:36.239]             invokeRestart <- base::invokeRestart
[13:33:36.239]             length <- base::length
[13:33:36.239]             list <- base::list
[13:33:36.239]             seq.int <- base::seq.int
[13:33:36.239]             signalCondition <- base::signalCondition
[13:33:36.239]             sys.calls <- base::sys.calls
[13:33:36.239]             `[[` <- base::`[[`
[13:33:36.239]             `+` <- base::`+`
[13:33:36.239]             `<<-` <- base::`<<-`
[13:33:36.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.239]                   3L)]
[13:33:36.239]             }
[13:33:36.239]             function(cond) {
[13:33:36.239]                 is_error <- inherits(cond, "error")
[13:33:36.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.239]                   NULL)
[13:33:36.239]                 if (is_error) {
[13:33:36.239]                   sessionInformation <- function() {
[13:33:36.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.239]                       search = base::search(), system = base::Sys.info())
[13:33:36.239]                   }
[13:33:36.239]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.239]                     cond$call), session = sessionInformation(), 
[13:33:36.239]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.239]                   signalCondition(cond)
[13:33:36.239]                 }
[13:33:36.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.239]                 "immediateCondition"))) {
[13:33:36.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.239]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.239]                   if (TRUE && !signal) {
[13:33:36.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.239]                     {
[13:33:36.239]                       inherits <- base::inherits
[13:33:36.239]                       invokeRestart <- base::invokeRestart
[13:33:36.239]                       is.null <- base::is.null
[13:33:36.239]                       muffled <- FALSE
[13:33:36.239]                       if (inherits(cond, "message")) {
[13:33:36.239]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.239]                         if (muffled) 
[13:33:36.239]                           invokeRestart("muffleMessage")
[13:33:36.239]                       }
[13:33:36.239]                       else if (inherits(cond, "warning")) {
[13:33:36.239]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.239]                         if (muffled) 
[13:33:36.239]                           invokeRestart("muffleWarning")
[13:33:36.239]                       }
[13:33:36.239]                       else if (inherits(cond, "condition")) {
[13:33:36.239]                         if (!is.null(pattern)) {
[13:33:36.239]                           computeRestarts <- base::computeRestarts
[13:33:36.239]                           grepl <- base::grepl
[13:33:36.239]                           restarts <- computeRestarts(cond)
[13:33:36.239]                           for (restart in restarts) {
[13:33:36.239]                             name <- restart$name
[13:33:36.239]                             if (is.null(name)) 
[13:33:36.239]                               next
[13:33:36.239]                             if (!grepl(pattern, name)) 
[13:33:36.239]                               next
[13:33:36.239]                             invokeRestart(restart)
[13:33:36.239]                             muffled <- TRUE
[13:33:36.239]                             break
[13:33:36.239]                           }
[13:33:36.239]                         }
[13:33:36.239]                       }
[13:33:36.239]                       invisible(muffled)
[13:33:36.239]                     }
[13:33:36.239]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.239]                   }
[13:33:36.239]                 }
[13:33:36.239]                 else {
[13:33:36.239]                   if (TRUE) {
[13:33:36.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.239]                     {
[13:33:36.239]                       inherits <- base::inherits
[13:33:36.239]                       invokeRestart <- base::invokeRestart
[13:33:36.239]                       is.null <- base::is.null
[13:33:36.239]                       muffled <- FALSE
[13:33:36.239]                       if (inherits(cond, "message")) {
[13:33:36.239]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.239]                         if (muffled) 
[13:33:36.239]                           invokeRestart("muffleMessage")
[13:33:36.239]                       }
[13:33:36.239]                       else if (inherits(cond, "warning")) {
[13:33:36.239]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.239]                         if (muffled) 
[13:33:36.239]                           invokeRestart("muffleWarning")
[13:33:36.239]                       }
[13:33:36.239]                       else if (inherits(cond, "condition")) {
[13:33:36.239]                         if (!is.null(pattern)) {
[13:33:36.239]                           computeRestarts <- base::computeRestarts
[13:33:36.239]                           grepl <- base::grepl
[13:33:36.239]                           restarts <- computeRestarts(cond)
[13:33:36.239]                           for (restart in restarts) {
[13:33:36.239]                             name <- restart$name
[13:33:36.239]                             if (is.null(name)) 
[13:33:36.239]                               next
[13:33:36.239]                             if (!grepl(pattern, name)) 
[13:33:36.239]                               next
[13:33:36.239]                             invokeRestart(restart)
[13:33:36.239]                             muffled <- TRUE
[13:33:36.239]                             break
[13:33:36.239]                           }
[13:33:36.239]                         }
[13:33:36.239]                       }
[13:33:36.239]                       invisible(muffled)
[13:33:36.239]                     }
[13:33:36.239]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.239]                   }
[13:33:36.239]                 }
[13:33:36.239]             }
[13:33:36.239]         }))
[13:33:36.239]     }, error = function(ex) {
[13:33:36.239]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.239]                 ...future.rng), started = ...future.startTime, 
[13:33:36.239]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.239]             version = "1.8"), class = "FutureResult")
[13:33:36.239]     }, finally = {
[13:33:36.239]         if (!identical(...future.workdir, getwd())) 
[13:33:36.239]             setwd(...future.workdir)
[13:33:36.239]         {
[13:33:36.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.239]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.239]             }
[13:33:36.239]             base::options(...future.oldOptions)
[13:33:36.239]             if (.Platform$OS.type == "windows") {
[13:33:36.239]                 old_names <- names(...future.oldEnvVars)
[13:33:36.239]                 envs <- base::Sys.getenv()
[13:33:36.239]                 names <- names(envs)
[13:33:36.239]                 common <- intersect(names, old_names)
[13:33:36.239]                 added <- setdiff(names, old_names)
[13:33:36.239]                 removed <- setdiff(old_names, names)
[13:33:36.239]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.239]                   envs[common]]
[13:33:36.239]                 NAMES <- toupper(changed)
[13:33:36.239]                 args <- list()
[13:33:36.239]                 for (kk in seq_along(NAMES)) {
[13:33:36.239]                   name <- changed[[kk]]
[13:33:36.239]                   NAME <- NAMES[[kk]]
[13:33:36.239]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.239]                     next
[13:33:36.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.239]                 }
[13:33:36.239]                 NAMES <- toupper(added)
[13:33:36.239]                 for (kk in seq_along(NAMES)) {
[13:33:36.239]                   name <- added[[kk]]
[13:33:36.239]                   NAME <- NAMES[[kk]]
[13:33:36.239]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.239]                     next
[13:33:36.239]                   args[[name]] <- ""
[13:33:36.239]                 }
[13:33:36.239]                 NAMES <- toupper(removed)
[13:33:36.239]                 for (kk in seq_along(NAMES)) {
[13:33:36.239]                   name <- removed[[kk]]
[13:33:36.239]                   NAME <- NAMES[[kk]]
[13:33:36.239]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.239]                     next
[13:33:36.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.239]                 }
[13:33:36.239]                 if (length(args) > 0) 
[13:33:36.239]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.239]             }
[13:33:36.239]             else {
[13:33:36.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.239]             }
[13:33:36.239]             {
[13:33:36.239]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.239]                   0L) {
[13:33:36.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.239]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.239]                   base::options(opts)
[13:33:36.239]                 }
[13:33:36.239]                 {
[13:33:36.239]                   {
[13:33:36.239]                     NULL
[13:33:36.239]                     RNGkind("Mersenne-Twister")
[13:33:36.239]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:36.239]                       inherits = FALSE)
[13:33:36.239]                   }
[13:33:36.239]                   options(future.plan = NULL)
[13:33:36.239]                   if (is.na(NA_character_)) 
[13:33:36.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.239]                     .init = FALSE)
[13:33:36.239]                 }
[13:33:36.239]             }
[13:33:36.239]         }
[13:33:36.239]     })
[13:33:36.239]     if (TRUE) {
[13:33:36.239]         base::sink(type = "output", split = FALSE)
[13:33:36.239]         if (TRUE) {
[13:33:36.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.239]         }
[13:33:36.239]         else {
[13:33:36.239]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.239]         }
[13:33:36.239]         base::close(...future.stdout)
[13:33:36.239]         ...future.stdout <- NULL
[13:33:36.239]     }
[13:33:36.239]     ...future.result$conditions <- ...future.conditions
[13:33:36.239]     ...future.result$finished <- base::Sys.time()
[13:33:36.239]     ...future.result
[13:33:36.239] }
[13:33:36.240] assign_globals() ...
[13:33:36.240] List of 5
[13:33:36.240]  $ future.call.arguments    : list()
[13:33:36.240]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.240]  $ ...future.FUN            :function (x)  
[13:33:36.240]  $ ...future.elements_ii    :List of 2
[13:33:36.240]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:33:36.240]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:33:36.240]  $ ...future.seeds_ii       : NULL
[13:33:36.240]  $ ...future.globals.maxSize: num Inf
[13:33:36.240]  - attr(*, "resolved")= logi FALSE
[13:33:36.240]  - attr(*, "total_size")= num NA
[13:33:36.240]  - attr(*, "where")=List of 5
[13:33:36.240]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.240]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.240]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.240]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.240]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.240]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.240]  - attr(*, "already-done")= logi TRUE
[13:33:36.245] - copied ‘future.call.arguments’ to environment
[13:33:36.245] - copied ‘...future.FUN’ to environment
[13:33:36.245] - copied ‘...future.elements_ii’ to environment
[13:33:36.245] - copied ‘...future.seeds_ii’ to environment
[13:33:36.245] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.245] assign_globals() ... done
[13:33:36.246] plan(): Setting new future strategy stack:
[13:33:36.246] List of future strategies:
[13:33:36.246] 1. sequential:
[13:33:36.246]    - args: function (..., envir = parent.frame())
[13:33:36.246]    - tweaked: FALSE
[13:33:36.246]    - call: NULL
[13:33:36.246] plan(): nbrOfWorkers() = 1
[13:33:36.247] plan(): Setting new future strategy stack:
[13:33:36.247] List of future strategies:
[13:33:36.247] 1. sequential:
[13:33:36.247]    - args: function (..., envir = parent.frame())
[13:33:36.247]    - tweaked: FALSE
[13:33:36.247]    - call: plan(strategy)
[13:33:36.247] plan(): nbrOfWorkers() = 1
[13:33:36.247] SequentialFuture started (and completed)
[13:33:36.247] - Launch lazy future ... done
[13:33:36.248] run() for ‘SequentialFuture’ ... done
[13:33:36.248] Created future:
[13:33:36.248] SequentialFuture:
[13:33:36.248] Label: ‘future_apply-1’
[13:33:36.248] Expression:
[13:33:36.248] {
[13:33:36.248]     do.call(function(...) {
[13:33:36.248]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.248]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.248]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.248]             on.exit(options(oopts), add = TRUE)
[13:33:36.248]         }
[13:33:36.248]         {
[13:33:36.248]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.248]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.248]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.248]             })
[13:33:36.248]         }
[13:33:36.248]     }, args = future.call.arguments)
[13:33:36.248] }
[13:33:36.248] Lazy evaluation: FALSE
[13:33:36.248] Asynchronous evaluation: FALSE
[13:33:36.248] Local evaluation: TRUE
[13:33:36.248] Environment: R_GlobalEnv
[13:33:36.248] Capture standard output: TRUE
[13:33:36.248] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.248] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.248] Packages: <none>
[13:33:36.248] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.248] Resolved: TRUE
[13:33:36.248] Value: 224 bytes of class ‘list’
[13:33:36.248] Early signaling: FALSE
[13:33:36.248] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.248] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.249] Chunk #1 of 1 ... DONE
[13:33:36.249] Launching 1 futures (chunks) ... DONE
[13:33:36.249] Resolving 1 futures (chunks) ...
[13:33:36.249] resolve() on list ...
[13:33:36.249]  recursive: 0
[13:33:36.249]  length: 1
[13:33:36.249] 
[13:33:36.249] resolved() for ‘SequentialFuture’ ...
[13:33:36.249] - state: ‘finished’
[13:33:36.249] - run: TRUE
[13:33:36.250] - result: ‘FutureResult’
[13:33:36.250] resolved() for ‘SequentialFuture’ ... done
[13:33:36.250] Future #1
[13:33:36.250] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:36.250] - nx: 1
[13:33:36.250] - relay: TRUE
[13:33:36.250] - stdout: TRUE
[13:33:36.250] - signal: TRUE
[13:33:36.250] - resignal: FALSE
[13:33:36.250] - force: TRUE
[13:33:36.250] - relayed: [n=1] FALSE
[13:33:36.250] - queued futures: [n=1] FALSE
[13:33:36.251]  - until=1
[13:33:36.251]  - relaying element #1
[13:33:36.251] - relayed: [n=1] TRUE
[13:33:36.251] - queued futures: [n=1] TRUE
[13:33:36.251] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:36.251]  length: 0 (resolved future 1)
[13:33:36.251] Relaying remaining futures
[13:33:36.251] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.251] - nx: 1
[13:33:36.251] - relay: TRUE
[13:33:36.252] - stdout: TRUE
[13:33:36.252] - signal: TRUE
[13:33:36.252] - resignal: FALSE
[13:33:36.252] - force: TRUE
[13:33:36.252] - relayed: [n=1] TRUE
[13:33:36.252] - queued futures: [n=1] TRUE
 - flush all
[13:33:36.252] - relayed: [n=1] TRUE
[13:33:36.252] - queued futures: [n=1] TRUE
[13:33:36.252] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.252] resolve() on list ... DONE
[13:33:36.252]  - Number of value chunks collected: 1
[13:33:36.252] Resolving 1 futures (chunks) ... DONE
[13:33:36.253] Reducing values from 1 chunks ...
[13:33:36.253]  - Number of values collected after concatenation: 2
[13:33:36.253]  - Number of values expected: 2
[13:33:36.253] Reducing values from 1 chunks ... DONE
[13:33:36.253] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[13:33:36.253] getGlobalsAndPackagesXApply() ...
[13:33:36.253]  - future.globals: TRUE
[13:33:36.253] getGlobalsAndPackages() ...
[13:33:36.253] Searching for globals...
[13:33:36.254] - globals found: [1] ‘FUN’
[13:33:36.254] Searching for globals ... DONE
[13:33:36.255] Resolving globals: FALSE
[13:33:36.255] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:36.255] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:36.255] - globals: [1] ‘FUN’
[13:33:36.255] 
[13:33:36.255] getGlobalsAndPackages() ... DONE
[13:33:36.256]  - globals found/used: [n=1] ‘FUN’
[13:33:36.256]  - needed namespaces: [n=0] 
[13:33:36.256] Finding globals ... DONE
[13:33:36.256]  - use_args: TRUE
[13:33:36.256]  - Getting '...' globals ...
[13:33:36.256] resolve() on list ...
[13:33:36.256]  recursive: 0
[13:33:36.256]  length: 1
[13:33:36.256]  elements: ‘...’
[13:33:36.257]  length: 0 (resolved future 1)
[13:33:36.257] resolve() on list ... DONE
[13:33:36.257]    - '...' content: [n=0] 
[13:33:36.257] List of 1
[13:33:36.257]  $ ...: list()
[13:33:36.257]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.257]  - attr(*, "where")=List of 1
[13:33:36.257]   ..$ ...:<environment: 0x55b94a3179d0> 
[13:33:36.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.257]  - attr(*, "resolved")= logi TRUE
[13:33:36.257]  - attr(*, "total_size")= num NA
[13:33:36.260]  - Getting '...' globals ... DONE
[13:33:36.260] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.260] List of 2
[13:33:36.260]  $ ...future.FUN:function (x)  
[13:33:36.260]  $ ...          : list()
[13:33:36.260]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.260]  - attr(*, "where")=List of 2
[13:33:36.260]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.260]   ..$ ...          :<environment: 0x55b94a3179d0> 
[13:33:36.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.260]  - attr(*, "resolved")= logi FALSE
[13:33:36.260]  - attr(*, "total_size")= num 848
[13:33:36.263] Packages to be attached in all futures: [n=0] 
[13:33:36.263] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.263] future_lapply() ...
[13:33:36.263] Number of chunks: 1
[13:33:36.263] getGlobalsAndPackagesXApply() ...
[13:33:36.264]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.264]  - use_args: TRUE
[13:33:36.264] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.264] List of 2
[13:33:36.264]  $ ...          : list()
[13:33:36.264]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.264]  $ ...future.FUN:function (x)  
[13:33:36.264]  - attr(*, "where")=List of 2
[13:33:36.264]   ..$ ...          :<environment: 0x55b94a3179d0> 
[13:33:36.264]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:36.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.264]  - attr(*, "resolved")= logi FALSE
[13:33:36.264]  - attr(*, "total_size")= num NA
[13:33:36.267] Packages to be attached in all futures: [n=0] 
[13:33:36.267] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.267] Number of futures (= number of chunks): 1
[13:33:36.267] Launching 1 futures (chunks) ...
[13:33:36.267] Chunk #1 of 1 ...
[13:33:36.267]  - seeds: <none>
[13:33:36.268]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.268] getGlobalsAndPackages() ...
[13:33:36.268] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.268] Resolving globals: FALSE
[13:33:36.268] Tweak future expression to call with '...' arguments ...
[13:33:36.268] {
[13:33:36.268]     do.call(function(...) {
[13:33:36.268]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.268]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.268]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.268]             on.exit(options(oopts), add = TRUE)
[13:33:36.268]         }
[13:33:36.268]         {
[13:33:36.268]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.268]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.268]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.268]             })
[13:33:36.268]         }
[13:33:36.268]     }, args = future.call.arguments)
[13:33:36.268] }
[13:33:36.268] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.269] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.269] 
[13:33:36.269] getGlobalsAndPackages() ... DONE
[13:33:36.269] run() for ‘Future’ ...
[13:33:36.269] - state: ‘created’
[13:33:36.269] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:36.270] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.270] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:36.270]   - Field: ‘label’
[13:33:36.270]   - Field: ‘local’
[13:33:36.270]   - Field: ‘owner’
[13:33:36.270]   - Field: ‘envir’
[13:33:36.270]   - Field: ‘packages’
[13:33:36.270]   - Field: ‘gc’
[13:33:36.270]   - Field: ‘conditions’
[13:33:36.270]   - Field: ‘expr’
[13:33:36.270]   - Field: ‘uuid’
[13:33:36.271]   - Field: ‘seed’
[13:33:36.271]   - Field: ‘version’
[13:33:36.271]   - Field: ‘result’
[13:33:36.271]   - Field: ‘asynchronous’
[13:33:36.271]   - Field: ‘calls’
[13:33:36.271]   - Field: ‘globals’
[13:33:36.271]   - Field: ‘stdout’
[13:33:36.271]   - Field: ‘earlySignal’
[13:33:36.271]   - Field: ‘lazy’
[13:33:36.271]   - Field: ‘state’
[13:33:36.271] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:36.271] - Launch lazy future ...
[13:33:36.272] Packages needed by the future expression (n = 0): <none>
[13:33:36.272] Packages needed by future strategies (n = 0): <none>
[13:33:36.272] {
[13:33:36.272]     {
[13:33:36.272]         {
[13:33:36.272]             ...future.startTime <- base::Sys.time()
[13:33:36.272]             {
[13:33:36.272]                 {
[13:33:36.272]                   {
[13:33:36.272]                     base::local({
[13:33:36.272]                       has_future <- base::requireNamespace("future", 
[13:33:36.272]                         quietly = TRUE)
[13:33:36.272]                       if (has_future) {
[13:33:36.272]                         ns <- base::getNamespace("future")
[13:33:36.272]                         version <- ns[[".package"]][["version"]]
[13:33:36.272]                         if (is.null(version)) 
[13:33:36.272]                           version <- utils::packageVersion("future")
[13:33:36.272]                       }
[13:33:36.272]                       else {
[13:33:36.272]                         version <- NULL
[13:33:36.272]                       }
[13:33:36.272]                       if (!has_future || version < "1.8.0") {
[13:33:36.272]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.272]                           "", base::R.version$version.string), 
[13:33:36.272]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:36.272]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.272]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.272]                             "release", "version")], collapse = " "), 
[13:33:36.272]                           hostname = base::Sys.info()[["nodename"]])
[13:33:36.272]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.272]                           info)
[13:33:36.272]                         info <- base::paste(info, collapse = "; ")
[13:33:36.272]                         if (!has_future) {
[13:33:36.272]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.272]                             info)
[13:33:36.272]                         }
[13:33:36.272]                         else {
[13:33:36.272]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.272]                             info, version)
[13:33:36.272]                         }
[13:33:36.272]                         base::stop(msg)
[13:33:36.272]                       }
[13:33:36.272]                     })
[13:33:36.272]                   }
[13:33:36.272]                   ...future.strategy.old <- future::plan("list")
[13:33:36.272]                   options(future.plan = NULL)
[13:33:36.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.272]                 }
[13:33:36.272]                 ...future.workdir <- getwd()
[13:33:36.272]             }
[13:33:36.272]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.272]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.272]         }
[13:33:36.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.272]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.272]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.272]             base::names(...future.oldOptions))
[13:33:36.272]     }
[13:33:36.272]     if (FALSE) {
[13:33:36.272]     }
[13:33:36.272]     else {
[13:33:36.272]         if (TRUE) {
[13:33:36.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.272]                 open = "w")
[13:33:36.272]         }
[13:33:36.272]         else {
[13:33:36.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.272]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.272]         }
[13:33:36.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.272]             base::sink(type = "output", split = FALSE)
[13:33:36.272]             base::close(...future.stdout)
[13:33:36.272]         }, add = TRUE)
[13:33:36.272]     }
[13:33:36.272]     ...future.frame <- base::sys.nframe()
[13:33:36.272]     ...future.conditions <- base::list()
[13:33:36.272]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.272]     if (FALSE) {
[13:33:36.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.272]     }
[13:33:36.272]     ...future.result <- base::tryCatch({
[13:33:36.272]         base::withCallingHandlers({
[13:33:36.272]             ...future.value <- base::withVisible(base::local({
[13:33:36.272]                 do.call(function(...) {
[13:33:36.272]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.272]                   if (!identical(...future.globals.maxSize.org, 
[13:33:36.272]                     ...future.globals.maxSize)) {
[13:33:36.272]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.272]                     on.exit(options(oopts), add = TRUE)
[13:33:36.272]                   }
[13:33:36.272]                   {
[13:33:36.272]                     lapply(seq_along(...future.elements_ii), 
[13:33:36.272]                       FUN = function(jj) {
[13:33:36.272]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.272]                         ...future.FUN(...future.X_jj, ...)
[13:33:36.272]                       })
[13:33:36.272]                   }
[13:33:36.272]                 }, args = future.call.arguments)
[13:33:36.272]             }))
[13:33:36.272]             future::FutureResult(value = ...future.value$value, 
[13:33:36.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.272]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.272]                     ...future.globalenv.names))
[13:33:36.272]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.272]         }, condition = base::local({
[13:33:36.272]             c <- base::c
[13:33:36.272]             inherits <- base::inherits
[13:33:36.272]             invokeRestart <- base::invokeRestart
[13:33:36.272]             length <- base::length
[13:33:36.272]             list <- base::list
[13:33:36.272]             seq.int <- base::seq.int
[13:33:36.272]             signalCondition <- base::signalCondition
[13:33:36.272]             sys.calls <- base::sys.calls
[13:33:36.272]             `[[` <- base::`[[`
[13:33:36.272]             `+` <- base::`+`
[13:33:36.272]             `<<-` <- base::`<<-`
[13:33:36.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.272]                   3L)]
[13:33:36.272]             }
[13:33:36.272]             function(cond) {
[13:33:36.272]                 is_error <- inherits(cond, "error")
[13:33:36.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.272]                   NULL)
[13:33:36.272]                 if (is_error) {
[13:33:36.272]                   sessionInformation <- function() {
[13:33:36.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.272]                       search = base::search(), system = base::Sys.info())
[13:33:36.272]                   }
[13:33:36.272]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.272]                     cond$call), session = sessionInformation(), 
[13:33:36.272]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.272]                   signalCondition(cond)
[13:33:36.272]                 }
[13:33:36.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.272]                 "immediateCondition"))) {
[13:33:36.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.272]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.272]                   if (TRUE && !signal) {
[13:33:36.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.272]                     {
[13:33:36.272]                       inherits <- base::inherits
[13:33:36.272]                       invokeRestart <- base::invokeRestart
[13:33:36.272]                       is.null <- base::is.null
[13:33:36.272]                       muffled <- FALSE
[13:33:36.272]                       if (inherits(cond, "message")) {
[13:33:36.272]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.272]                         if (muffled) 
[13:33:36.272]                           invokeRestart("muffleMessage")
[13:33:36.272]                       }
[13:33:36.272]                       else if (inherits(cond, "warning")) {
[13:33:36.272]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.272]                         if (muffled) 
[13:33:36.272]                           invokeRestart("muffleWarning")
[13:33:36.272]                       }
[13:33:36.272]                       else if (inherits(cond, "condition")) {
[13:33:36.272]                         if (!is.null(pattern)) {
[13:33:36.272]                           computeRestarts <- base::computeRestarts
[13:33:36.272]                           grepl <- base::grepl
[13:33:36.272]                           restarts <- computeRestarts(cond)
[13:33:36.272]                           for (restart in restarts) {
[13:33:36.272]                             name <- restart$name
[13:33:36.272]                             if (is.null(name)) 
[13:33:36.272]                               next
[13:33:36.272]                             if (!grepl(pattern, name)) 
[13:33:36.272]                               next
[13:33:36.272]                             invokeRestart(restart)
[13:33:36.272]                             muffled <- TRUE
[13:33:36.272]                             break
[13:33:36.272]                           }
[13:33:36.272]                         }
[13:33:36.272]                       }
[13:33:36.272]                       invisible(muffled)
[13:33:36.272]                     }
[13:33:36.272]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.272]                   }
[13:33:36.272]                 }
[13:33:36.272]                 else {
[13:33:36.272]                   if (TRUE) {
[13:33:36.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.272]                     {
[13:33:36.272]                       inherits <- base::inherits
[13:33:36.272]                       invokeRestart <- base::invokeRestart
[13:33:36.272]                       is.null <- base::is.null
[13:33:36.272]                       muffled <- FALSE
[13:33:36.272]                       if (inherits(cond, "message")) {
[13:33:36.272]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.272]                         if (muffled) 
[13:33:36.272]                           invokeRestart("muffleMessage")
[13:33:36.272]                       }
[13:33:36.272]                       else if (inherits(cond, "warning")) {
[13:33:36.272]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.272]                         if (muffled) 
[13:33:36.272]                           invokeRestart("muffleWarning")
[13:33:36.272]                       }
[13:33:36.272]                       else if (inherits(cond, "condition")) {
[13:33:36.272]                         if (!is.null(pattern)) {
[13:33:36.272]                           computeRestarts <- base::computeRestarts
[13:33:36.272]                           grepl <- base::grepl
[13:33:36.272]                           restarts <- computeRestarts(cond)
[13:33:36.272]                           for (restart in restarts) {
[13:33:36.272]                             name <- restart$name
[13:33:36.272]                             if (is.null(name)) 
[13:33:36.272]                               next
[13:33:36.272]                             if (!grepl(pattern, name)) 
[13:33:36.272]                               next
[13:33:36.272]                             invokeRestart(restart)
[13:33:36.272]                             muffled <- TRUE
[13:33:36.272]                             break
[13:33:36.272]                           }
[13:33:36.272]                         }
[13:33:36.272]                       }
[13:33:36.272]                       invisible(muffled)
[13:33:36.272]                     }
[13:33:36.272]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.272]                   }
[13:33:36.272]                 }
[13:33:36.272]             }
[13:33:36.272]         }))
[13:33:36.272]     }, error = function(ex) {
[13:33:36.272]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.272]                 ...future.rng), started = ...future.startTime, 
[13:33:36.272]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.272]             version = "1.8"), class = "FutureResult")
[13:33:36.272]     }, finally = {
[13:33:36.272]         if (!identical(...future.workdir, getwd())) 
[13:33:36.272]             setwd(...future.workdir)
[13:33:36.272]         {
[13:33:36.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.272]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.272]             }
[13:33:36.272]             base::options(...future.oldOptions)
[13:33:36.272]             if (.Platform$OS.type == "windows") {
[13:33:36.272]                 old_names <- names(...future.oldEnvVars)
[13:33:36.272]                 envs <- base::Sys.getenv()
[13:33:36.272]                 names <- names(envs)
[13:33:36.272]                 common <- intersect(names, old_names)
[13:33:36.272]                 added <- setdiff(names, old_names)
[13:33:36.272]                 removed <- setdiff(old_names, names)
[13:33:36.272]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.272]                   envs[common]]
[13:33:36.272]                 NAMES <- toupper(changed)
[13:33:36.272]                 args <- list()
[13:33:36.272]                 for (kk in seq_along(NAMES)) {
[13:33:36.272]                   name <- changed[[kk]]
[13:33:36.272]                   NAME <- NAMES[[kk]]
[13:33:36.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.272]                     next
[13:33:36.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.272]                 }
[13:33:36.272]                 NAMES <- toupper(added)
[13:33:36.272]                 for (kk in seq_along(NAMES)) {
[13:33:36.272]                   name <- added[[kk]]
[13:33:36.272]                   NAME <- NAMES[[kk]]
[13:33:36.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.272]                     next
[13:33:36.272]                   args[[name]] <- ""
[13:33:36.272]                 }
[13:33:36.272]                 NAMES <- toupper(removed)
[13:33:36.272]                 for (kk in seq_along(NAMES)) {
[13:33:36.272]                   name <- removed[[kk]]
[13:33:36.272]                   NAME <- NAMES[[kk]]
[13:33:36.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.272]                     next
[13:33:36.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.272]                 }
[13:33:36.272]                 if (length(args) > 0) 
[13:33:36.272]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.272]             }
[13:33:36.272]             else {
[13:33:36.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.272]             }
[13:33:36.272]             {
[13:33:36.272]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.272]                   0L) {
[13:33:36.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.272]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.272]                   base::options(opts)
[13:33:36.272]                 }
[13:33:36.272]                 {
[13:33:36.272]                   {
[13:33:36.272]                     NULL
[13:33:36.272]                     RNGkind("Mersenne-Twister")
[13:33:36.272]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:36.272]                       inherits = FALSE)
[13:33:36.272]                   }
[13:33:36.272]                   options(future.plan = NULL)
[13:33:36.272]                   if (is.na(NA_character_)) 
[13:33:36.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.272]                     .init = FALSE)
[13:33:36.272]                 }
[13:33:36.272]             }
[13:33:36.272]         }
[13:33:36.272]     })
[13:33:36.272]     if (TRUE) {
[13:33:36.272]         base::sink(type = "output", split = FALSE)
[13:33:36.272]         if (TRUE) {
[13:33:36.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.272]         }
[13:33:36.272]         else {
[13:33:36.272]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.272]         }
[13:33:36.272]         base::close(...future.stdout)
[13:33:36.272]         ...future.stdout <- NULL
[13:33:36.272]     }
[13:33:36.272]     ...future.result$conditions <- ...future.conditions
[13:33:36.272]     ...future.result$finished <- base::Sys.time()
[13:33:36.272]     ...future.result
[13:33:36.272] }
[13:33:36.274] assign_globals() ...
[13:33:36.274] List of 5
[13:33:36.274]  $ future.call.arguments    : list()
[13:33:36.274]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.274]  $ ...future.FUN            :function (x)  
[13:33:36.274]  $ ...future.elements_ii    :List of 6
[13:33:36.274]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:33:36.274]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:33:36.274]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:33:36.274]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:33:36.274]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:33:36.274]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:33:36.274]  $ ...future.seeds_ii       : NULL
[13:33:36.274]  $ ...future.globals.maxSize: num Inf
[13:33:36.274]  - attr(*, "resolved")= logi FALSE
[13:33:36.274]  - attr(*, "total_size")= num NA
[13:33:36.274]  - attr(*, "where")=List of 5
[13:33:36.274]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.274]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.274]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.274]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.274]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.274]  - attr(*, "already-done")= logi TRUE
[13:33:36.280] - copied ‘future.call.arguments’ to environment
[13:33:36.280] - copied ‘...future.FUN’ to environment
[13:33:36.281] - copied ‘...future.elements_ii’ to environment
[13:33:36.281] - copied ‘...future.seeds_ii’ to environment
[13:33:36.281] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.281] assign_globals() ... done
[13:33:36.281] plan(): Setting new future strategy stack:
[13:33:36.281] List of future strategies:
[13:33:36.281] 1. sequential:
[13:33:36.281]    - args: function (..., envir = parent.frame())
[13:33:36.281]    - tweaked: FALSE
[13:33:36.281]    - call: NULL
[13:33:36.281] plan(): nbrOfWorkers() = 1
[13:33:36.282] plan(): Setting new future strategy stack:
[13:33:36.282] List of future strategies:
[13:33:36.282] 1. sequential:
[13:33:36.282]    - args: function (..., envir = parent.frame())
[13:33:36.282]    - tweaked: FALSE
[13:33:36.282]    - call: plan(strategy)
[13:33:36.283] plan(): nbrOfWorkers() = 1
[13:33:36.283] SequentialFuture started (and completed)
[13:33:36.283] - Launch lazy future ... done
[13:33:36.283] run() for ‘SequentialFuture’ ... done
[13:33:36.283] Created future:
[13:33:36.283] SequentialFuture:
[13:33:36.283] Label: ‘future_apply-1’
[13:33:36.283] Expression:
[13:33:36.283] {
[13:33:36.283]     do.call(function(...) {
[13:33:36.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.283]             on.exit(options(oopts), add = TRUE)
[13:33:36.283]         }
[13:33:36.283]         {
[13:33:36.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.283]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.283]             })
[13:33:36.283]         }
[13:33:36.283]     }, args = future.call.arguments)
[13:33:36.283] }
[13:33:36.283] Lazy evaluation: FALSE
[13:33:36.283] Asynchronous evaluation: FALSE
[13:33:36.283] Local evaluation: TRUE
[13:33:36.283] Environment: R_GlobalEnv
[13:33:36.283] Capture standard output: TRUE
[13:33:36.283] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.283] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.283] Packages: <none>
[13:33:36.283] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.283] Resolved: TRUE
[13:33:36.283] Value: 672 bytes of class ‘list’
[13:33:36.283] Early signaling: FALSE
[13:33:36.283] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.283] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.284] Chunk #1 of 1 ... DONE
[13:33:36.284] Launching 1 futures (chunks) ... DONE
[13:33:36.284] Resolving 1 futures (chunks) ...
[13:33:36.284] resolve() on list ...
[13:33:36.284]  recursive: 0
[13:33:36.285]  length: 1
[13:33:36.285] 
[13:33:36.285] resolved() for ‘SequentialFuture’ ...
[13:33:36.285] - state: ‘finished’
[13:33:36.285] - run: TRUE
[13:33:36.285] - result: ‘FutureResult’
[13:33:36.285] resolved() for ‘SequentialFuture’ ... done
[13:33:36.285] Future #1
[13:33:36.285] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:36.285] - nx: 1
[13:33:36.285] - relay: TRUE
[13:33:36.285] - stdout: TRUE
[13:33:36.286] - signal: TRUE
[13:33:36.286] - resignal: FALSE
[13:33:36.286] - force: TRUE
[13:33:36.286] - relayed: [n=1] FALSE
[13:33:36.286] - queued futures: [n=1] FALSE
[13:33:36.286]  - until=1
[13:33:36.286]  - relaying element #1
[13:33:36.286] - relayed: [n=1] TRUE
[13:33:36.286] - queued futures: [n=1] TRUE
[13:33:36.286] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:36.287]  length: 0 (resolved future 1)
[13:33:36.287] Relaying remaining futures
[13:33:36.287] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.287] - nx: 1
[13:33:36.287] - relay: TRUE
[13:33:36.287] - stdout: TRUE
[13:33:36.287] - signal: TRUE
[13:33:36.287] - resignal: FALSE
[13:33:36.287] - force: TRUE
[13:33:36.287] - relayed: [n=1] TRUE
[13:33:36.287] - queued futures: [n=1] TRUE
 - flush all
[13:33:36.287] - relayed: [n=1] TRUE
[13:33:36.287] - queued futures: [n=1] TRUE
[13:33:36.288] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.288] resolve() on list ... DONE
[13:33:36.288]  - Number of value chunks collected: 1
[13:33:36.288] Resolving 1 futures (chunks) ... DONE
[13:33:36.288] Reducing values from 1 chunks ...
[13:33:36.288]  - Number of values collected after concatenation: 6
[13:33:36.288]  - Number of values expected: 6
[13:33:36.288] Reducing values from 1 chunks ... DONE
[13:33:36.288] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[13:33:36.289] getGlobalsAndPackagesXApply() ...
[13:33:36.289]  - future.globals: TRUE
[13:33:36.289] getGlobalsAndPackages() ...
[13:33:36.289] Searching for globals...
[13:33:36.290] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[13:33:36.290] Searching for globals ... DONE
[13:33:36.290] Resolving globals: FALSE
[13:33:36.291] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[13:33:36.291] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[13:33:36.291] - globals: [1] ‘FUN’
[13:33:36.291] 
[13:33:36.291] getGlobalsAndPackages() ... DONE
[13:33:36.291]  - globals found/used: [n=1] ‘FUN’
[13:33:36.291]  - needed namespaces: [n=0] 
[13:33:36.292] Finding globals ... DONE
[13:33:36.292]  - use_args: TRUE
[13:33:36.292]  - Getting '...' globals ...
[13:33:36.292] resolve() on list ...
[13:33:36.292]  recursive: 0
[13:33:36.292]  length: 1
[13:33:36.292]  elements: ‘...’
[13:33:36.292]  length: 0 (resolved future 1)
[13:33:36.292] resolve() on list ... DONE
[13:33:36.293]    - '...' content: [n=0] 
[13:33:36.293] List of 1
[13:33:36.293]  $ ...: list()
[13:33:36.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.293]  - attr(*, "where")=List of 1
[13:33:36.293]   ..$ ...:<environment: 0x55b949e44c88> 
[13:33:36.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.293]  - attr(*, "resolved")= logi TRUE
[13:33:36.293]  - attr(*, "total_size")= num NA
[13:33:36.295]  - Getting '...' globals ... DONE
[13:33:36.295] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.295] List of 2
[13:33:36.295]  $ ...future.FUN:function (x)  
[13:33:36.295]  $ ...          : list()
[13:33:36.295]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.295]  - attr(*, "where")=List of 2
[13:33:36.295]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.295]   ..$ ...          :<environment: 0x55b949e44c88> 
[13:33:36.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.295]  - attr(*, "resolved")= logi FALSE
[13:33:36.295]  - attr(*, "total_size")= num 1768
[13:33:36.298] Packages to be attached in all futures: [n=0] 
[13:33:36.298] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.299] future_lapply() ...
[13:33:36.299] Number of chunks: 1
[13:33:36.299] getGlobalsAndPackagesXApply() ...
[13:33:36.299]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.299]  - use_args: TRUE
[13:33:36.300] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.300] List of 2
[13:33:36.300]  $ ...          : list()
[13:33:36.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.300]  $ ...future.FUN:function (x)  
[13:33:36.300]  - attr(*, "where")=List of 2
[13:33:36.300]   ..$ ...          :<environment: 0x55b949e44c88> 
[13:33:36.300]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:33:36.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.300]  - attr(*, "resolved")= logi FALSE
[13:33:36.300]  - attr(*, "total_size")= num NA
[13:33:36.302] Packages to be attached in all futures: [n=0] 
[13:33:36.302] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.302] Number of futures (= number of chunks): 1
[13:33:36.302] Launching 1 futures (chunks) ...
[13:33:36.303] Chunk #1 of 1 ...
[13:33:36.303]  - seeds: <none>
[13:33:36.303]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.303] getGlobalsAndPackages() ...
[13:33:36.303] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.303] Resolving globals: FALSE
[13:33:36.303] Tweak future expression to call with '...' arguments ...
[13:33:36.303] {
[13:33:36.303]     do.call(function(...) {
[13:33:36.303]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.303]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.303]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.303]             on.exit(options(oopts), add = TRUE)
[13:33:36.303]         }
[13:33:36.303]         {
[13:33:36.303]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.303]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.303]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.303]             })
[13:33:36.303]         }
[13:33:36.303]     }, args = future.call.arguments)
[13:33:36.303] }
[13:33:36.304] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.304] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.304] 
[13:33:36.304] getGlobalsAndPackages() ... DONE
[13:33:36.304] run() for ‘Future’ ...
[13:33:36.304] - state: ‘created’
[13:33:36.304] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:36.305] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:36.305]   - Field: ‘label’
[13:33:36.305]   - Field: ‘local’
[13:33:36.305]   - Field: ‘owner’
[13:33:36.305]   - Field: ‘envir’
[13:33:36.305]   - Field: ‘packages’
[13:33:36.305]   - Field: ‘gc’
[13:33:36.305]   - Field: ‘conditions’
[13:33:36.306]   - Field: ‘expr’
[13:33:36.306]   - Field: ‘uuid’
[13:33:36.306]   - Field: ‘seed’
[13:33:36.306]   - Field: ‘version’
[13:33:36.306]   - Field: ‘result’
[13:33:36.306]   - Field: ‘asynchronous’
[13:33:36.306]   - Field: ‘calls’
[13:33:36.306]   - Field: ‘globals’
[13:33:36.306]   - Field: ‘stdout’
[13:33:36.306]   - Field: ‘earlySignal’
[13:33:36.306]   - Field: ‘lazy’
[13:33:36.307]   - Field: ‘state’
[13:33:36.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:36.307] - Launch lazy future ...
[13:33:36.307] Packages needed by the future expression (n = 0): <none>
[13:33:36.307] Packages needed by future strategies (n = 0): <none>
[13:33:36.307] {
[13:33:36.307]     {
[13:33:36.307]         {
[13:33:36.307]             ...future.startTime <- base::Sys.time()
[13:33:36.307]             {
[13:33:36.307]                 {
[13:33:36.307]                   {
[13:33:36.307]                     base::local({
[13:33:36.307]                       has_future <- base::requireNamespace("future", 
[13:33:36.307]                         quietly = TRUE)
[13:33:36.307]                       if (has_future) {
[13:33:36.307]                         ns <- base::getNamespace("future")
[13:33:36.307]                         version <- ns[[".package"]][["version"]]
[13:33:36.307]                         if (is.null(version)) 
[13:33:36.307]                           version <- utils::packageVersion("future")
[13:33:36.307]                       }
[13:33:36.307]                       else {
[13:33:36.307]                         version <- NULL
[13:33:36.307]                       }
[13:33:36.307]                       if (!has_future || version < "1.8.0") {
[13:33:36.307]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.307]                           "", base::R.version$version.string), 
[13:33:36.307]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:36.307]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.307]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.307]                             "release", "version")], collapse = " "), 
[13:33:36.307]                           hostname = base::Sys.info()[["nodename"]])
[13:33:36.307]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.307]                           info)
[13:33:36.307]                         info <- base::paste(info, collapse = "; ")
[13:33:36.307]                         if (!has_future) {
[13:33:36.307]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.307]                             info)
[13:33:36.307]                         }
[13:33:36.307]                         else {
[13:33:36.307]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.307]                             info, version)
[13:33:36.307]                         }
[13:33:36.307]                         base::stop(msg)
[13:33:36.307]                       }
[13:33:36.307]                     })
[13:33:36.307]                   }
[13:33:36.307]                   ...future.strategy.old <- future::plan("list")
[13:33:36.307]                   options(future.plan = NULL)
[13:33:36.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.307]                 }
[13:33:36.307]                 ...future.workdir <- getwd()
[13:33:36.307]             }
[13:33:36.307]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.307]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.307]         }
[13:33:36.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.307]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.307]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.307]             base::names(...future.oldOptions))
[13:33:36.307]     }
[13:33:36.307]     if (FALSE) {
[13:33:36.307]     }
[13:33:36.307]     else {
[13:33:36.307]         if (TRUE) {
[13:33:36.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.307]                 open = "w")
[13:33:36.307]         }
[13:33:36.307]         else {
[13:33:36.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.307]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.307]         }
[13:33:36.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.307]             base::sink(type = "output", split = FALSE)
[13:33:36.307]             base::close(...future.stdout)
[13:33:36.307]         }, add = TRUE)
[13:33:36.307]     }
[13:33:36.307]     ...future.frame <- base::sys.nframe()
[13:33:36.307]     ...future.conditions <- base::list()
[13:33:36.307]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.307]     if (FALSE) {
[13:33:36.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.307]     }
[13:33:36.307]     ...future.result <- base::tryCatch({
[13:33:36.307]         base::withCallingHandlers({
[13:33:36.307]             ...future.value <- base::withVisible(base::local({
[13:33:36.307]                 do.call(function(...) {
[13:33:36.307]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.307]                   if (!identical(...future.globals.maxSize.org, 
[13:33:36.307]                     ...future.globals.maxSize)) {
[13:33:36.307]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.307]                     on.exit(options(oopts), add = TRUE)
[13:33:36.307]                   }
[13:33:36.307]                   {
[13:33:36.307]                     lapply(seq_along(...future.elements_ii), 
[13:33:36.307]                       FUN = function(jj) {
[13:33:36.307]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.307]                         ...future.FUN(...future.X_jj, ...)
[13:33:36.307]                       })
[13:33:36.307]                   }
[13:33:36.307]                 }, args = future.call.arguments)
[13:33:36.307]             }))
[13:33:36.307]             future::FutureResult(value = ...future.value$value, 
[13:33:36.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.307]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.307]                     ...future.globalenv.names))
[13:33:36.307]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.307]         }, condition = base::local({
[13:33:36.307]             c <- base::c
[13:33:36.307]             inherits <- base::inherits
[13:33:36.307]             invokeRestart <- base::invokeRestart
[13:33:36.307]             length <- base::length
[13:33:36.307]             list <- base::list
[13:33:36.307]             seq.int <- base::seq.int
[13:33:36.307]             signalCondition <- base::signalCondition
[13:33:36.307]             sys.calls <- base::sys.calls
[13:33:36.307]             `[[` <- base::`[[`
[13:33:36.307]             `+` <- base::`+`
[13:33:36.307]             `<<-` <- base::`<<-`
[13:33:36.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.307]                   3L)]
[13:33:36.307]             }
[13:33:36.307]             function(cond) {
[13:33:36.307]                 is_error <- inherits(cond, "error")
[13:33:36.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.307]                   NULL)
[13:33:36.307]                 if (is_error) {
[13:33:36.307]                   sessionInformation <- function() {
[13:33:36.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.307]                       search = base::search(), system = base::Sys.info())
[13:33:36.307]                   }
[13:33:36.307]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.307]                     cond$call), session = sessionInformation(), 
[13:33:36.307]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.307]                   signalCondition(cond)
[13:33:36.307]                 }
[13:33:36.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.307]                 "immediateCondition"))) {
[13:33:36.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.307]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.307]                   if (TRUE && !signal) {
[13:33:36.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.307]                     {
[13:33:36.307]                       inherits <- base::inherits
[13:33:36.307]                       invokeRestart <- base::invokeRestart
[13:33:36.307]                       is.null <- base::is.null
[13:33:36.307]                       muffled <- FALSE
[13:33:36.307]                       if (inherits(cond, "message")) {
[13:33:36.307]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.307]                         if (muffled) 
[13:33:36.307]                           invokeRestart("muffleMessage")
[13:33:36.307]                       }
[13:33:36.307]                       else if (inherits(cond, "warning")) {
[13:33:36.307]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.307]                         if (muffled) 
[13:33:36.307]                           invokeRestart("muffleWarning")
[13:33:36.307]                       }
[13:33:36.307]                       else if (inherits(cond, "condition")) {
[13:33:36.307]                         if (!is.null(pattern)) {
[13:33:36.307]                           computeRestarts <- base::computeRestarts
[13:33:36.307]                           grepl <- base::grepl
[13:33:36.307]                           restarts <- computeRestarts(cond)
[13:33:36.307]                           for (restart in restarts) {
[13:33:36.307]                             name <- restart$name
[13:33:36.307]                             if (is.null(name)) 
[13:33:36.307]                               next
[13:33:36.307]                             if (!grepl(pattern, name)) 
[13:33:36.307]                               next
[13:33:36.307]                             invokeRestart(restart)
[13:33:36.307]                             muffled <- TRUE
[13:33:36.307]                             break
[13:33:36.307]                           }
[13:33:36.307]                         }
[13:33:36.307]                       }
[13:33:36.307]                       invisible(muffled)
[13:33:36.307]                     }
[13:33:36.307]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.307]                   }
[13:33:36.307]                 }
[13:33:36.307]                 else {
[13:33:36.307]                   if (TRUE) {
[13:33:36.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.307]                     {
[13:33:36.307]                       inherits <- base::inherits
[13:33:36.307]                       invokeRestart <- base::invokeRestart
[13:33:36.307]                       is.null <- base::is.null
[13:33:36.307]                       muffled <- FALSE
[13:33:36.307]                       if (inherits(cond, "message")) {
[13:33:36.307]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.307]                         if (muffled) 
[13:33:36.307]                           invokeRestart("muffleMessage")
[13:33:36.307]                       }
[13:33:36.307]                       else if (inherits(cond, "warning")) {
[13:33:36.307]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.307]                         if (muffled) 
[13:33:36.307]                           invokeRestart("muffleWarning")
[13:33:36.307]                       }
[13:33:36.307]                       else if (inherits(cond, "condition")) {
[13:33:36.307]                         if (!is.null(pattern)) {
[13:33:36.307]                           computeRestarts <- base::computeRestarts
[13:33:36.307]                           grepl <- base::grepl
[13:33:36.307]                           restarts <- computeRestarts(cond)
[13:33:36.307]                           for (restart in restarts) {
[13:33:36.307]                             name <- restart$name
[13:33:36.307]                             if (is.null(name)) 
[13:33:36.307]                               next
[13:33:36.307]                             if (!grepl(pattern, name)) 
[13:33:36.307]                               next
[13:33:36.307]                             invokeRestart(restart)
[13:33:36.307]                             muffled <- TRUE
[13:33:36.307]                             break
[13:33:36.307]                           }
[13:33:36.307]                         }
[13:33:36.307]                       }
[13:33:36.307]                       invisible(muffled)
[13:33:36.307]                     }
[13:33:36.307]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.307]                   }
[13:33:36.307]                 }
[13:33:36.307]             }
[13:33:36.307]         }))
[13:33:36.307]     }, error = function(ex) {
[13:33:36.307]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.307]                 ...future.rng), started = ...future.startTime, 
[13:33:36.307]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.307]             version = "1.8"), class = "FutureResult")
[13:33:36.307]     }, finally = {
[13:33:36.307]         if (!identical(...future.workdir, getwd())) 
[13:33:36.307]             setwd(...future.workdir)
[13:33:36.307]         {
[13:33:36.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.307]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.307]             }
[13:33:36.307]             base::options(...future.oldOptions)
[13:33:36.307]             if (.Platform$OS.type == "windows") {
[13:33:36.307]                 old_names <- names(...future.oldEnvVars)
[13:33:36.307]                 envs <- base::Sys.getenv()
[13:33:36.307]                 names <- names(envs)
[13:33:36.307]                 common <- intersect(names, old_names)
[13:33:36.307]                 added <- setdiff(names, old_names)
[13:33:36.307]                 removed <- setdiff(old_names, names)
[13:33:36.307]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.307]                   envs[common]]
[13:33:36.307]                 NAMES <- toupper(changed)
[13:33:36.307]                 args <- list()
[13:33:36.307]                 for (kk in seq_along(NAMES)) {
[13:33:36.307]                   name <- changed[[kk]]
[13:33:36.307]                   NAME <- NAMES[[kk]]
[13:33:36.307]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.307]                     next
[13:33:36.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.307]                 }
[13:33:36.307]                 NAMES <- toupper(added)
[13:33:36.307]                 for (kk in seq_along(NAMES)) {
[13:33:36.307]                   name <- added[[kk]]
[13:33:36.307]                   NAME <- NAMES[[kk]]
[13:33:36.307]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.307]                     next
[13:33:36.307]                   args[[name]] <- ""
[13:33:36.307]                 }
[13:33:36.307]                 NAMES <- toupper(removed)
[13:33:36.307]                 for (kk in seq_along(NAMES)) {
[13:33:36.307]                   name <- removed[[kk]]
[13:33:36.307]                   NAME <- NAMES[[kk]]
[13:33:36.307]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.307]                     next
[13:33:36.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.307]                 }
[13:33:36.307]                 if (length(args) > 0) 
[13:33:36.307]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.307]             }
[13:33:36.307]             else {
[13:33:36.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.307]             }
[13:33:36.307]             {
[13:33:36.307]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.307]                   0L) {
[13:33:36.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.307]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.307]                   base::options(opts)
[13:33:36.307]                 }
[13:33:36.307]                 {
[13:33:36.307]                   {
[13:33:36.307]                     NULL
[13:33:36.307]                     RNGkind("Mersenne-Twister")
[13:33:36.307]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:36.307]                       inherits = FALSE)
[13:33:36.307]                   }
[13:33:36.307]                   options(future.plan = NULL)
[13:33:36.307]                   if (is.na(NA_character_)) 
[13:33:36.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.307]                     .init = FALSE)
[13:33:36.307]                 }
[13:33:36.307]             }
[13:33:36.307]         }
[13:33:36.307]     })
[13:33:36.307]     if (TRUE) {
[13:33:36.307]         base::sink(type = "output", split = FALSE)
[13:33:36.307]         if (TRUE) {
[13:33:36.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.307]         }
[13:33:36.307]         else {
[13:33:36.307]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.307]         }
[13:33:36.307]         base::close(...future.stdout)
[13:33:36.307]         ...future.stdout <- NULL
[13:33:36.307]     }
[13:33:36.307]     ...future.result$conditions <- ...future.conditions
[13:33:36.307]     ...future.result$finished <- base::Sys.time()
[13:33:36.307]     ...future.result
[13:33:36.307] }
[13:33:36.309] assign_globals() ...
[13:33:36.309] List of 5
[13:33:36.309]  $ future.call.arguments    : list()
[13:33:36.309]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.309]  $ ...future.FUN            :function (x)  
[13:33:36.309]  $ ...future.elements_ii    :List of 6
[13:33:36.309]   ..$ : int [1:4] 1 7 13 19
[13:33:36.309]   ..$ : int [1:4] 2 8 14 20
[13:33:36.309]   ..$ : int [1:4] 3 9 15 21
[13:33:36.309]   ..$ : int [1:4] 4 10 16 22
[13:33:36.309]   ..$ : int [1:4] 5 11 17 23
[13:33:36.309]   ..$ : int [1:4] 6 12 18 24
[13:33:36.309]  $ ...future.seeds_ii       : NULL
[13:33:36.309]  $ ...future.globals.maxSize: num Inf
[13:33:36.309]  - attr(*, "resolved")= logi FALSE
[13:33:36.309]  - attr(*, "total_size")= num NA
[13:33:36.309]  - attr(*, "where")=List of 5
[13:33:36.309]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.309]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.309]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.309]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.309]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.309]  - attr(*, "already-done")= logi TRUE
[13:33:36.315] - copied ‘future.call.arguments’ to environment
[13:33:36.315] - reassign environment for ‘...future.FUN’
[13:33:36.315] - copied ‘...future.FUN’ to environment
[13:33:36.315] - copied ‘...future.elements_ii’ to environment
[13:33:36.315] - copied ‘...future.seeds_ii’ to environment
[13:33:36.315] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.315] assign_globals() ... done
[13:33:36.316] plan(): Setting new future strategy stack:
[13:33:36.316] List of future strategies:
[13:33:36.316] 1. sequential:
[13:33:36.316]    - args: function (..., envir = parent.frame())
[13:33:36.316]    - tweaked: FALSE
[13:33:36.316]    - call: NULL
[13:33:36.316] plan(): nbrOfWorkers() = 1
[13:33:36.317] plan(): Setting new future strategy stack:
[13:33:36.317] List of future strategies:
[13:33:36.317] 1. sequential:
[13:33:36.317]    - args: function (..., envir = parent.frame())
[13:33:36.317]    - tweaked: FALSE
[13:33:36.317]    - call: plan(strategy)
[13:33:36.345] plan(): nbrOfWorkers() = 1
[13:33:36.345] SequentialFuture started (and completed)
[13:33:36.345] - Launch lazy future ... done
[13:33:36.345] run() for ‘SequentialFuture’ ... done
[13:33:36.345] Created future:
[13:33:36.345] SequentialFuture:
[13:33:36.345] Label: ‘future_apply-1’
[13:33:36.345] Expression:
[13:33:36.345] {
[13:33:36.345]     do.call(function(...) {
[13:33:36.345]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.345]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.345]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.345]             on.exit(options(oopts), add = TRUE)
[13:33:36.345]         }
[13:33:36.345]         {
[13:33:36.345]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.345]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.345]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.345]             })
[13:33:36.345]         }
[13:33:36.345]     }, args = future.call.arguments)
[13:33:36.345] }
[13:33:36.345] Lazy evaluation: FALSE
[13:33:36.345] Asynchronous evaluation: FALSE
[13:33:36.345] Local evaluation: TRUE
[13:33:36.345] Environment: R_GlobalEnv
[13:33:36.345] Capture standard output: TRUE
[13:33:36.345] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.345] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.345] Packages: <none>
[13:33:36.345] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.345] Resolved: TRUE
[13:33:36.345] Value: 1.03 KiB of class ‘list’
[13:33:36.345] Early signaling: FALSE
[13:33:36.345] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.345] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.347] Chunk #1 of 1 ... DONE
[13:33:36.347] Launching 1 futures (chunks) ... DONE
[13:33:36.347] Resolving 1 futures (chunks) ...
[13:33:36.347] resolve() on list ...
[13:33:36.347]  recursive: 0
[13:33:36.347]  length: 1
[13:33:36.347] 
[13:33:36.347] resolved() for ‘SequentialFuture’ ...
[13:33:36.347] - state: ‘finished’
[13:33:36.347] - run: TRUE
[13:33:36.348] - result: ‘FutureResult’
[13:33:36.348] resolved() for ‘SequentialFuture’ ... done
[13:33:36.348] Future #1
[13:33:36.348] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:36.348] - nx: 1
[13:33:36.348] - relay: TRUE
[13:33:36.348] - stdout: TRUE
[13:33:36.348] - signal: TRUE
[13:33:36.348] - resignal: FALSE
[13:33:36.348] - force: TRUE
[13:33:36.348] - relayed: [n=1] FALSE
[13:33:36.349] - queued futures: [n=1] FALSE
[13:33:36.349]  - until=1
[13:33:36.349]  - relaying element #1
[13:33:36.349] - relayed: [n=1] TRUE
[13:33:36.349] - queued futures: [n=1] TRUE
[13:33:36.349] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:36.349]  length: 0 (resolved future 1)
[13:33:36.349] Relaying remaining futures
[13:33:36.349] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.349] - nx: 1
[13:33:36.350] - relay: TRUE
[13:33:36.350] - stdout: TRUE
[13:33:36.350] - signal: TRUE
[13:33:36.350] - resignal: FALSE
[13:33:36.350] - force: TRUE
[13:33:36.350] - relayed: [n=1] TRUE
[13:33:36.350] - queued futures: [n=1] TRUE
 - flush all
[13:33:36.350] - relayed: [n=1] TRUE
[13:33:36.350] - queued futures: [n=1] TRUE
[13:33:36.350] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.350] resolve() on list ... DONE
[13:33:36.351]  - Number of value chunks collected: 1
[13:33:36.351] Resolving 1 futures (chunks) ... DONE
[13:33:36.351] Reducing values from 1 chunks ...
[13:33:36.351]  - Number of values collected after concatenation: 6
[13:33:36.351]  - Number of values expected: 6
[13:33:36.351] Reducing values from 1 chunks ... DONE
[13:33:36.351] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[13:33:36.351] getGlobalsAndPackagesXApply() ...
[13:33:36.351]  - future.globals: TRUE
[13:33:36.352] getGlobalsAndPackages() ...
[13:33:36.352] Searching for globals...
[13:33:36.353] - globals found: [1] ‘FUN’
[13:33:36.353] Searching for globals ... DONE
[13:33:36.353] Resolving globals: FALSE
[13:33:36.353] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:36.353] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:36.354] - globals: [1] ‘FUN’
[13:33:36.354] 
[13:33:36.354] getGlobalsAndPackages() ... DONE
[13:33:36.354]  - globals found/used: [n=1] ‘FUN’
[13:33:36.354]  - needed namespaces: [n=0] 
[13:33:36.354] Finding globals ... DONE
[13:33:36.354]  - use_args: TRUE
[13:33:36.354]  - Getting '...' globals ...
[13:33:36.354] resolve() on list ...
[13:33:36.355]  recursive: 0
[13:33:36.355]  length: 1
[13:33:36.355]  elements: ‘...’
[13:33:36.355]  length: 0 (resolved future 1)
[13:33:36.355] resolve() on list ... DONE
[13:33:36.355]    - '...' content: [n=0] 
[13:33:36.355] List of 1
[13:33:36.355]  $ ...: list()
[13:33:36.355]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.355]  - attr(*, "where")=List of 1
[13:33:36.355]   ..$ ...:<environment: 0x55b947e159a0> 
[13:33:36.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.355]  - attr(*, "resolved")= logi TRUE
[13:33:36.355]  - attr(*, "total_size")= num NA
[13:33:36.358]  - Getting '...' globals ... DONE
[13:33:36.358] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.358] List of 2
[13:33:36.358]  $ ...future.FUN:function (x)  
[13:33:36.358]  $ ...          : list()
[13:33:36.358]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.358]  - attr(*, "where")=List of 2
[13:33:36.358]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.358]   ..$ ...          :<environment: 0x55b947e159a0> 
[13:33:36.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.358]  - attr(*, "resolved")= logi FALSE
[13:33:36.358]  - attr(*, "total_size")= num 848
[13:33:36.360] Packages to be attached in all futures: [n=0] 
[13:33:36.360] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.361] future_lapply() ...
[13:33:36.361] Number of chunks: 1
[13:33:36.361] getGlobalsAndPackagesXApply() ...
[13:33:36.361]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.361]  - use_args: TRUE
[13:33:36.362] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.362] List of 2
[13:33:36.362]  $ ...          : list()
[13:33:36.362]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.362]  $ ...future.FUN:function (x)  
[13:33:36.362]  - attr(*, "where")=List of 2
[13:33:36.362]   ..$ ...          :<environment: 0x55b947e159a0> 
[13:33:36.362]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:36.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.362]  - attr(*, "resolved")= logi FALSE
[13:33:36.362]  - attr(*, "total_size")= num NA
[13:33:36.365] Packages to be attached in all futures: [n=0] 
[13:33:36.365] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.365] Number of futures (= number of chunks): 1
[13:33:36.365] Launching 1 futures (chunks) ...
[13:33:36.365] Chunk #1 of 1 ...
[13:33:36.365]  - seeds: <none>
[13:33:36.365]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.365] getGlobalsAndPackages() ...
[13:33:36.366] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.366] Resolving globals: FALSE
[13:33:36.366] Tweak future expression to call with '...' arguments ...
[13:33:36.366] {
[13:33:36.366]     do.call(function(...) {
[13:33:36.366]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.366]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.366]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.366]             on.exit(options(oopts), add = TRUE)
[13:33:36.366]         }
[13:33:36.366]         {
[13:33:36.366]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.366]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.366]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.366]             })
[13:33:36.366]         }
[13:33:36.366]     }, args = future.call.arguments)
[13:33:36.366] }
[13:33:36.366] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.367] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.367] 
[13:33:36.367] getGlobalsAndPackages() ... DONE
[13:33:36.368] run() for ‘Future’ ...
[13:33:36.368] - state: ‘created’
[13:33:36.368] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:36.368] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.368] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:36.368]   - Field: ‘label’
[13:33:36.368]   - Field: ‘local’
[13:33:36.369]   - Field: ‘owner’
[13:33:36.369]   - Field: ‘envir’
[13:33:36.369]   - Field: ‘packages’
[13:33:36.369]   - Field: ‘gc’
[13:33:36.369]   - Field: ‘conditions’
[13:33:36.369]   - Field: ‘expr’
[13:33:36.369]   - Field: ‘uuid’
[13:33:36.369]   - Field: ‘seed’
[13:33:36.369]   - Field: ‘version’
[13:33:36.369]   - Field: ‘result’
[13:33:36.369]   - Field: ‘asynchronous’
[13:33:36.369]   - Field: ‘calls’
[13:33:36.370]   - Field: ‘globals’
[13:33:36.370]   - Field: ‘stdout’
[13:33:36.370]   - Field: ‘earlySignal’
[13:33:36.370]   - Field: ‘lazy’
[13:33:36.370]   - Field: ‘state’
[13:33:36.370] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:36.370] - Launch lazy future ...
[13:33:36.370] Packages needed by the future expression (n = 0): <none>
[13:33:36.370] Packages needed by future strategies (n = 0): <none>
[13:33:36.371] {
[13:33:36.371]     {
[13:33:36.371]         {
[13:33:36.371]             ...future.startTime <- base::Sys.time()
[13:33:36.371]             {
[13:33:36.371]                 {
[13:33:36.371]                   {
[13:33:36.371]                     base::local({
[13:33:36.371]                       has_future <- base::requireNamespace("future", 
[13:33:36.371]                         quietly = TRUE)
[13:33:36.371]                       if (has_future) {
[13:33:36.371]                         ns <- base::getNamespace("future")
[13:33:36.371]                         version <- ns[[".package"]][["version"]]
[13:33:36.371]                         if (is.null(version)) 
[13:33:36.371]                           version <- utils::packageVersion("future")
[13:33:36.371]                       }
[13:33:36.371]                       else {
[13:33:36.371]                         version <- NULL
[13:33:36.371]                       }
[13:33:36.371]                       if (!has_future || version < "1.8.0") {
[13:33:36.371]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.371]                           "", base::R.version$version.string), 
[13:33:36.371]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:36.371]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.371]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.371]                             "release", "version")], collapse = " "), 
[13:33:36.371]                           hostname = base::Sys.info()[["nodename"]])
[13:33:36.371]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.371]                           info)
[13:33:36.371]                         info <- base::paste(info, collapse = "; ")
[13:33:36.371]                         if (!has_future) {
[13:33:36.371]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.371]                             info)
[13:33:36.371]                         }
[13:33:36.371]                         else {
[13:33:36.371]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.371]                             info, version)
[13:33:36.371]                         }
[13:33:36.371]                         base::stop(msg)
[13:33:36.371]                       }
[13:33:36.371]                     })
[13:33:36.371]                   }
[13:33:36.371]                   ...future.strategy.old <- future::plan("list")
[13:33:36.371]                   options(future.plan = NULL)
[13:33:36.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.371]                 }
[13:33:36.371]                 ...future.workdir <- getwd()
[13:33:36.371]             }
[13:33:36.371]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.371]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.371]         }
[13:33:36.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.371]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.371]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.371]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.371]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.371]             base::names(...future.oldOptions))
[13:33:36.371]     }
[13:33:36.371]     if (FALSE) {
[13:33:36.371]     }
[13:33:36.371]     else {
[13:33:36.371]         if (TRUE) {
[13:33:36.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.371]                 open = "w")
[13:33:36.371]         }
[13:33:36.371]         else {
[13:33:36.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.371]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.371]         }
[13:33:36.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.371]             base::sink(type = "output", split = FALSE)
[13:33:36.371]             base::close(...future.stdout)
[13:33:36.371]         }, add = TRUE)
[13:33:36.371]     }
[13:33:36.371]     ...future.frame <- base::sys.nframe()
[13:33:36.371]     ...future.conditions <- base::list()
[13:33:36.371]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.371]     if (FALSE) {
[13:33:36.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.371]     }
[13:33:36.371]     ...future.result <- base::tryCatch({
[13:33:36.371]         base::withCallingHandlers({
[13:33:36.371]             ...future.value <- base::withVisible(base::local({
[13:33:36.371]                 do.call(function(...) {
[13:33:36.371]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.371]                   if (!identical(...future.globals.maxSize.org, 
[13:33:36.371]                     ...future.globals.maxSize)) {
[13:33:36.371]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.371]                     on.exit(options(oopts), add = TRUE)
[13:33:36.371]                   }
[13:33:36.371]                   {
[13:33:36.371]                     lapply(seq_along(...future.elements_ii), 
[13:33:36.371]                       FUN = function(jj) {
[13:33:36.371]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.371]                         ...future.FUN(...future.X_jj, ...)
[13:33:36.371]                       })
[13:33:36.371]                   }
[13:33:36.371]                 }, args = future.call.arguments)
[13:33:36.371]             }))
[13:33:36.371]             future::FutureResult(value = ...future.value$value, 
[13:33:36.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.371]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.371]                     ...future.globalenv.names))
[13:33:36.371]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.371]         }, condition = base::local({
[13:33:36.371]             c <- base::c
[13:33:36.371]             inherits <- base::inherits
[13:33:36.371]             invokeRestart <- base::invokeRestart
[13:33:36.371]             length <- base::length
[13:33:36.371]             list <- base::list
[13:33:36.371]             seq.int <- base::seq.int
[13:33:36.371]             signalCondition <- base::signalCondition
[13:33:36.371]             sys.calls <- base::sys.calls
[13:33:36.371]             `[[` <- base::`[[`
[13:33:36.371]             `+` <- base::`+`
[13:33:36.371]             `<<-` <- base::`<<-`
[13:33:36.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.371]                   3L)]
[13:33:36.371]             }
[13:33:36.371]             function(cond) {
[13:33:36.371]                 is_error <- inherits(cond, "error")
[13:33:36.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.371]                   NULL)
[13:33:36.371]                 if (is_error) {
[13:33:36.371]                   sessionInformation <- function() {
[13:33:36.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.371]                       search = base::search(), system = base::Sys.info())
[13:33:36.371]                   }
[13:33:36.371]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.371]                     cond$call), session = sessionInformation(), 
[13:33:36.371]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.371]                   signalCondition(cond)
[13:33:36.371]                 }
[13:33:36.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.371]                 "immediateCondition"))) {
[13:33:36.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.371]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.371]                   if (TRUE && !signal) {
[13:33:36.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.371]                     {
[13:33:36.371]                       inherits <- base::inherits
[13:33:36.371]                       invokeRestart <- base::invokeRestart
[13:33:36.371]                       is.null <- base::is.null
[13:33:36.371]                       muffled <- FALSE
[13:33:36.371]                       if (inherits(cond, "message")) {
[13:33:36.371]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.371]                         if (muffled) 
[13:33:36.371]                           invokeRestart("muffleMessage")
[13:33:36.371]                       }
[13:33:36.371]                       else if (inherits(cond, "warning")) {
[13:33:36.371]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.371]                         if (muffled) 
[13:33:36.371]                           invokeRestart("muffleWarning")
[13:33:36.371]                       }
[13:33:36.371]                       else if (inherits(cond, "condition")) {
[13:33:36.371]                         if (!is.null(pattern)) {
[13:33:36.371]                           computeRestarts <- base::computeRestarts
[13:33:36.371]                           grepl <- base::grepl
[13:33:36.371]                           restarts <- computeRestarts(cond)
[13:33:36.371]                           for (restart in restarts) {
[13:33:36.371]                             name <- restart$name
[13:33:36.371]                             if (is.null(name)) 
[13:33:36.371]                               next
[13:33:36.371]                             if (!grepl(pattern, name)) 
[13:33:36.371]                               next
[13:33:36.371]                             invokeRestart(restart)
[13:33:36.371]                             muffled <- TRUE
[13:33:36.371]                             break
[13:33:36.371]                           }
[13:33:36.371]                         }
[13:33:36.371]                       }
[13:33:36.371]                       invisible(muffled)
[13:33:36.371]                     }
[13:33:36.371]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.371]                   }
[13:33:36.371]                 }
[13:33:36.371]                 else {
[13:33:36.371]                   if (TRUE) {
[13:33:36.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.371]                     {
[13:33:36.371]                       inherits <- base::inherits
[13:33:36.371]                       invokeRestart <- base::invokeRestart
[13:33:36.371]                       is.null <- base::is.null
[13:33:36.371]                       muffled <- FALSE
[13:33:36.371]                       if (inherits(cond, "message")) {
[13:33:36.371]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.371]                         if (muffled) 
[13:33:36.371]                           invokeRestart("muffleMessage")
[13:33:36.371]                       }
[13:33:36.371]                       else if (inherits(cond, "warning")) {
[13:33:36.371]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.371]                         if (muffled) 
[13:33:36.371]                           invokeRestart("muffleWarning")
[13:33:36.371]                       }
[13:33:36.371]                       else if (inherits(cond, "condition")) {
[13:33:36.371]                         if (!is.null(pattern)) {
[13:33:36.371]                           computeRestarts <- base::computeRestarts
[13:33:36.371]                           grepl <- base::grepl
[13:33:36.371]                           restarts <- computeRestarts(cond)
[13:33:36.371]                           for (restart in restarts) {
[13:33:36.371]                             name <- restart$name
[13:33:36.371]                             if (is.null(name)) 
[13:33:36.371]                               next
[13:33:36.371]                             if (!grepl(pattern, name)) 
[13:33:36.371]                               next
[13:33:36.371]                             invokeRestart(restart)
[13:33:36.371]                             muffled <- TRUE
[13:33:36.371]                             break
[13:33:36.371]                           }
[13:33:36.371]                         }
[13:33:36.371]                       }
[13:33:36.371]                       invisible(muffled)
[13:33:36.371]                     }
[13:33:36.371]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.371]                   }
[13:33:36.371]                 }
[13:33:36.371]             }
[13:33:36.371]         }))
[13:33:36.371]     }, error = function(ex) {
[13:33:36.371]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.371]                 ...future.rng), started = ...future.startTime, 
[13:33:36.371]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.371]             version = "1.8"), class = "FutureResult")
[13:33:36.371]     }, finally = {
[13:33:36.371]         if (!identical(...future.workdir, getwd())) 
[13:33:36.371]             setwd(...future.workdir)
[13:33:36.371]         {
[13:33:36.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.371]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.371]             }
[13:33:36.371]             base::options(...future.oldOptions)
[13:33:36.371]             if (.Platform$OS.type == "windows") {
[13:33:36.371]                 old_names <- names(...future.oldEnvVars)
[13:33:36.371]                 envs <- base::Sys.getenv()
[13:33:36.371]                 names <- names(envs)
[13:33:36.371]                 common <- intersect(names, old_names)
[13:33:36.371]                 added <- setdiff(names, old_names)
[13:33:36.371]                 removed <- setdiff(old_names, names)
[13:33:36.371]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.371]                   envs[common]]
[13:33:36.371]                 NAMES <- toupper(changed)
[13:33:36.371]                 args <- list()
[13:33:36.371]                 for (kk in seq_along(NAMES)) {
[13:33:36.371]                   name <- changed[[kk]]
[13:33:36.371]                   NAME <- NAMES[[kk]]
[13:33:36.371]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.371]                     next
[13:33:36.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.371]                 }
[13:33:36.371]                 NAMES <- toupper(added)
[13:33:36.371]                 for (kk in seq_along(NAMES)) {
[13:33:36.371]                   name <- added[[kk]]
[13:33:36.371]                   NAME <- NAMES[[kk]]
[13:33:36.371]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.371]                     next
[13:33:36.371]                   args[[name]] <- ""
[13:33:36.371]                 }
[13:33:36.371]                 NAMES <- toupper(removed)
[13:33:36.371]                 for (kk in seq_along(NAMES)) {
[13:33:36.371]                   name <- removed[[kk]]
[13:33:36.371]                   NAME <- NAMES[[kk]]
[13:33:36.371]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.371]                     next
[13:33:36.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.371]                 }
[13:33:36.371]                 if (length(args) > 0) 
[13:33:36.371]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.371]             }
[13:33:36.371]             else {
[13:33:36.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.371]             }
[13:33:36.371]             {
[13:33:36.371]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.371]                   0L) {
[13:33:36.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.371]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.371]                   base::options(opts)
[13:33:36.371]                 }
[13:33:36.371]                 {
[13:33:36.371]                   {
[13:33:36.371]                     NULL
[13:33:36.371]                     RNGkind("Mersenne-Twister")
[13:33:36.371]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:36.371]                       inherits = FALSE)
[13:33:36.371]                   }
[13:33:36.371]                   options(future.plan = NULL)
[13:33:36.371]                   if (is.na(NA_character_)) 
[13:33:36.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.371]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.371]                     .init = FALSE)
[13:33:36.371]                 }
[13:33:36.371]             }
[13:33:36.371]         }
[13:33:36.371]     })
[13:33:36.371]     if (TRUE) {
[13:33:36.371]         base::sink(type = "output", split = FALSE)
[13:33:36.371]         if (TRUE) {
[13:33:36.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.371]         }
[13:33:36.371]         else {
[13:33:36.371]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.371]         }
[13:33:36.371]         base::close(...future.stdout)
[13:33:36.371]         ...future.stdout <- NULL
[13:33:36.371]     }
[13:33:36.371]     ...future.result$conditions <- ...future.conditions
[13:33:36.371]     ...future.result$finished <- base::Sys.time()
[13:33:36.371]     ...future.result
[13:33:36.371] }
[13:33:36.372] assign_globals() ...
[13:33:36.372] List of 5
[13:33:36.372]  $ future.call.arguments    : list()
[13:33:36.372]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.372]  $ ...future.FUN            :function (x)  
[13:33:36.372]  $ ...future.elements_ii    :List of 2
[13:33:36.372]   ..$ : int 1
[13:33:36.372]   ..$ : int 2
[13:33:36.372]  $ ...future.seeds_ii       : NULL
[13:33:36.372]  $ ...future.globals.maxSize: num Inf
[13:33:36.372]  - attr(*, "resolved")= logi FALSE
[13:33:36.372]  - attr(*, "total_size")= num NA
[13:33:36.372]  - attr(*, "where")=List of 5
[13:33:36.372]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.372]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.372]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.372]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.372]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.372]  - attr(*, "already-done")= logi TRUE
[13:33:36.377] - copied ‘future.call.arguments’ to environment
[13:33:36.377] - copied ‘...future.FUN’ to environment
[13:33:36.377] - copied ‘...future.elements_ii’ to environment
[13:33:36.378] - copied ‘...future.seeds_ii’ to environment
[13:33:36.378] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.378] assign_globals() ... done
[13:33:36.378] plan(): Setting new future strategy stack:
[13:33:36.378] List of future strategies:
[13:33:36.378] 1. sequential:
[13:33:36.378]    - args: function (..., envir = parent.frame())
[13:33:36.378]    - tweaked: FALSE
[13:33:36.378]    - call: NULL
[13:33:36.378] plan(): nbrOfWorkers() = 1
[13:33:36.379] plan(): Setting new future strategy stack:
[13:33:36.379] List of future strategies:
[13:33:36.379] 1. sequential:
[13:33:36.379]    - args: function (..., envir = parent.frame())
[13:33:36.379]    - tweaked: FALSE
[13:33:36.379]    - call: plan(strategy)
[13:33:36.380] plan(): nbrOfWorkers() = 1
[13:33:36.380] SequentialFuture started (and completed)
[13:33:36.380] - Launch lazy future ... done
[13:33:36.380] run() for ‘SequentialFuture’ ... done
[13:33:36.380] Created future:
[13:33:36.380] SequentialFuture:
[13:33:36.380] Label: ‘future_apply-1’
[13:33:36.380] Expression:
[13:33:36.380] {
[13:33:36.380]     do.call(function(...) {
[13:33:36.380]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.380]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.380]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.380]             on.exit(options(oopts), add = TRUE)
[13:33:36.380]         }
[13:33:36.380]         {
[13:33:36.380]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.380]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.380]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.380]             })
[13:33:36.380]         }
[13:33:36.380]     }, args = future.call.arguments)
[13:33:36.380] }
[13:33:36.380] Lazy evaluation: FALSE
[13:33:36.380] Asynchronous evaluation: FALSE
[13:33:36.380] Local evaluation: TRUE
[13:33:36.380] Environment: R_GlobalEnv
[13:33:36.380] Capture standard output: TRUE
[13:33:36.380] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.380] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.380] Packages: <none>
[13:33:36.380] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.380] Resolved: TRUE
[13:33:36.380] Value: 112 bytes of class ‘list’
[13:33:36.380] Early signaling: FALSE
[13:33:36.380] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.380] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.381] Chunk #1 of 1 ... DONE
[13:33:36.381] Launching 1 futures (chunks) ... DONE
[13:33:36.381] Resolving 1 futures (chunks) ...
[13:33:36.381] resolve() on list ...
[13:33:36.381]  recursive: 0
[13:33:36.381]  length: 1
[13:33:36.381] 
[13:33:36.382] resolved() for ‘SequentialFuture’ ...
[13:33:36.382] - state: ‘finished’
[13:33:36.382] - run: TRUE
[13:33:36.382] - result: ‘FutureResult’
[13:33:36.382] resolved() for ‘SequentialFuture’ ... done
[13:33:36.382] Future #1
[13:33:36.382] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:36.382] - nx: 1
[13:33:36.382] - relay: TRUE
[13:33:36.382] - stdout: TRUE
[13:33:36.383] - signal: TRUE
[13:33:36.383] - resignal: FALSE
[13:33:36.383] - force: TRUE
[13:33:36.383] - relayed: [n=1] FALSE
[13:33:36.383] - queued futures: [n=1] FALSE
[13:33:36.383]  - until=1
[13:33:36.383]  - relaying element #1
[13:33:36.383] - relayed: [n=1] TRUE
[13:33:36.383] - queued futures: [n=1] TRUE
[13:33:36.383] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:36.383]  length: 0 (resolved future 1)
[13:33:36.384] Relaying remaining futures
[13:33:36.384] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.384] - nx: 1
[13:33:36.384] - relay: TRUE
[13:33:36.384] - stdout: TRUE
[13:33:36.384] - signal: TRUE
[13:33:36.384] - resignal: FALSE
[13:33:36.384] - force: TRUE
[13:33:36.384] - relayed: [n=1] TRUE
[13:33:36.384] - queued futures: [n=1] TRUE
 - flush all
[13:33:36.384] - relayed: [n=1] TRUE
[13:33:36.385] - queued futures: [n=1] TRUE
[13:33:36.385] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.385] resolve() on list ... DONE
[13:33:36.385]  - Number of value chunks collected: 1
[13:33:36.385] Resolving 1 futures (chunks) ... DONE
[13:33:36.385] Reducing values from 1 chunks ...
[13:33:36.385]  - Number of values collected after concatenation: 2
[13:33:36.385]  - Number of values expected: 2
[13:33:36.385] Reducing values from 1 chunks ... DONE
[13:33:36.385] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[13:33:36.386] getGlobalsAndPackagesXApply() ...
[13:33:36.386]  - future.globals: TRUE
[13:33:36.386] getGlobalsAndPackages() ...
[13:33:36.386] Searching for globals...
[13:33:36.387] - globals found: [1] ‘FUN’
[13:33:36.387] Searching for globals ... DONE
[13:33:36.387] Resolving globals: FALSE
[13:33:36.387] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:36.387] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:36.388] - globals: [1] ‘FUN’
[13:33:36.388] 
[13:33:36.388] getGlobalsAndPackages() ... DONE
[13:33:36.388]  - globals found/used: [n=1] ‘FUN’
[13:33:36.388]  - needed namespaces: [n=0] 
[13:33:36.388] Finding globals ... DONE
[13:33:36.388]  - use_args: TRUE
[13:33:36.388]  - Getting '...' globals ...
[13:33:36.389] resolve() on list ...
[13:33:36.389]  recursive: 0
[13:33:36.389]  length: 1
[13:33:36.389]  elements: ‘...’
[13:33:36.389]  length: 0 (resolved future 1)
[13:33:36.389] resolve() on list ... DONE
[13:33:36.389]    - '...' content: [n=0] 
[13:33:36.389] List of 1
[13:33:36.389]  $ ...: list()
[13:33:36.389]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.389]  - attr(*, "where")=List of 1
[13:33:36.389]   ..$ ...:<environment: 0x55b94a3631f8> 
[13:33:36.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.389]  - attr(*, "resolved")= logi TRUE
[13:33:36.389]  - attr(*, "total_size")= num NA
[13:33:36.392]  - Getting '...' globals ... DONE
[13:33:36.392] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.392] List of 2
[13:33:36.392]  $ ...future.FUN:function (x)  
[13:33:36.392]  $ ...          : list()
[13:33:36.392]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.392]  - attr(*, "where")=List of 2
[13:33:36.392]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.392]   ..$ ...          :<environment: 0x55b94a3631f8> 
[13:33:36.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.392]  - attr(*, "resolved")= logi FALSE
[13:33:36.392]  - attr(*, "total_size")= num 848
[13:33:36.395] Packages to be attached in all futures: [n=0] 
[13:33:36.395] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.395] future_lapply() ...
[13:33:36.396] Number of chunks: 1
[13:33:36.396] getGlobalsAndPackagesXApply() ...
[13:33:36.396]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.396]  - use_args: TRUE
[13:33:36.396] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.396] List of 2
[13:33:36.396]  $ ...          : list()
[13:33:36.396]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.396]  $ ...future.FUN:function (x)  
[13:33:36.396]  - attr(*, "where")=List of 2
[13:33:36.396]   ..$ ...          :<environment: 0x55b94a3631f8> 
[13:33:36.396]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:36.396]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.396]  - attr(*, "resolved")= logi FALSE
[13:33:36.396]  - attr(*, "total_size")= num NA
[13:33:36.399] Packages to be attached in all futures: [n=0] 
[13:33:36.399] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.399] Number of futures (= number of chunks): 1
[13:33:36.399] Launching 1 futures (chunks) ...
[13:33:36.400] Chunk #1 of 1 ...
[13:33:36.400]  - seeds: <none>
[13:33:36.400]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.400] getGlobalsAndPackages() ...
[13:33:36.400] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.400] Resolving globals: FALSE
[13:33:36.400] Tweak future expression to call with '...' arguments ...
[13:33:36.400] {
[13:33:36.400]     do.call(function(...) {
[13:33:36.400]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.400]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.400]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.400]             on.exit(options(oopts), add = TRUE)
[13:33:36.400]         }
[13:33:36.400]         {
[13:33:36.400]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.400]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.400]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.400]             })
[13:33:36.400]         }
[13:33:36.400]     }, args = future.call.arguments)
[13:33:36.400] }
[13:33:36.400] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.401] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.401] 
[13:33:36.401] getGlobalsAndPackages() ... DONE
[13:33:36.401] run() for ‘Future’ ...
[13:33:36.401] - state: ‘created’
[13:33:36.401] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:36.402] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:36.402]   - Field: ‘label’
[13:33:36.402]   - Field: ‘local’
[13:33:36.402]   - Field: ‘owner’
[13:33:36.402]   - Field: ‘envir’
[13:33:36.402]   - Field: ‘packages’
[13:33:36.402]   - Field: ‘gc’
[13:33:36.402]   - Field: ‘conditions’
[13:33:36.403]   - Field: ‘expr’
[13:33:36.403]   - Field: ‘uuid’
[13:33:36.403]   - Field: ‘seed’
[13:33:36.403]   - Field: ‘version’
[13:33:36.403]   - Field: ‘result’
[13:33:36.403]   - Field: ‘asynchronous’
[13:33:36.403]   - Field: ‘calls’
[13:33:36.403]   - Field: ‘globals’
[13:33:36.403]   - Field: ‘stdout’
[13:33:36.403]   - Field: ‘earlySignal’
[13:33:36.403]   - Field: ‘lazy’
[13:33:36.404]   - Field: ‘state’
[13:33:36.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:36.404] - Launch lazy future ...
[13:33:36.404] Packages needed by the future expression (n = 0): <none>
[13:33:36.404] Packages needed by future strategies (n = 0): <none>
[13:33:36.404] {
[13:33:36.404]     {
[13:33:36.404]         {
[13:33:36.404]             ...future.startTime <- base::Sys.time()
[13:33:36.404]             {
[13:33:36.404]                 {
[13:33:36.404]                   {
[13:33:36.404]                     base::local({
[13:33:36.404]                       has_future <- base::requireNamespace("future", 
[13:33:36.404]                         quietly = TRUE)
[13:33:36.404]                       if (has_future) {
[13:33:36.404]                         ns <- base::getNamespace("future")
[13:33:36.404]                         version <- ns[[".package"]][["version"]]
[13:33:36.404]                         if (is.null(version)) 
[13:33:36.404]                           version <- utils::packageVersion("future")
[13:33:36.404]                       }
[13:33:36.404]                       else {
[13:33:36.404]                         version <- NULL
[13:33:36.404]                       }
[13:33:36.404]                       if (!has_future || version < "1.8.0") {
[13:33:36.404]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.404]                           "", base::R.version$version.string), 
[13:33:36.404]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:36.404]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.404]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.404]                             "release", "version")], collapse = " "), 
[13:33:36.404]                           hostname = base::Sys.info()[["nodename"]])
[13:33:36.404]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.404]                           info)
[13:33:36.404]                         info <- base::paste(info, collapse = "; ")
[13:33:36.404]                         if (!has_future) {
[13:33:36.404]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.404]                             info)
[13:33:36.404]                         }
[13:33:36.404]                         else {
[13:33:36.404]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.404]                             info, version)
[13:33:36.404]                         }
[13:33:36.404]                         base::stop(msg)
[13:33:36.404]                       }
[13:33:36.404]                     })
[13:33:36.404]                   }
[13:33:36.404]                   ...future.strategy.old <- future::plan("list")
[13:33:36.404]                   options(future.plan = NULL)
[13:33:36.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.404]                 }
[13:33:36.404]                 ...future.workdir <- getwd()
[13:33:36.404]             }
[13:33:36.404]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.404]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.404]         }
[13:33:36.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.404]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.404]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.404]             base::names(...future.oldOptions))
[13:33:36.404]     }
[13:33:36.404]     if (FALSE) {
[13:33:36.404]     }
[13:33:36.404]     else {
[13:33:36.404]         if (TRUE) {
[13:33:36.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.404]                 open = "w")
[13:33:36.404]         }
[13:33:36.404]         else {
[13:33:36.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.404]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.404]         }
[13:33:36.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.404]             base::sink(type = "output", split = FALSE)
[13:33:36.404]             base::close(...future.stdout)
[13:33:36.404]         }, add = TRUE)
[13:33:36.404]     }
[13:33:36.404]     ...future.frame <- base::sys.nframe()
[13:33:36.404]     ...future.conditions <- base::list()
[13:33:36.404]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.404]     if (FALSE) {
[13:33:36.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.404]     }
[13:33:36.404]     ...future.result <- base::tryCatch({
[13:33:36.404]         base::withCallingHandlers({
[13:33:36.404]             ...future.value <- base::withVisible(base::local({
[13:33:36.404]                 do.call(function(...) {
[13:33:36.404]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.404]                   if (!identical(...future.globals.maxSize.org, 
[13:33:36.404]                     ...future.globals.maxSize)) {
[13:33:36.404]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.404]                     on.exit(options(oopts), add = TRUE)
[13:33:36.404]                   }
[13:33:36.404]                   {
[13:33:36.404]                     lapply(seq_along(...future.elements_ii), 
[13:33:36.404]                       FUN = function(jj) {
[13:33:36.404]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.404]                         ...future.FUN(...future.X_jj, ...)
[13:33:36.404]                       })
[13:33:36.404]                   }
[13:33:36.404]                 }, args = future.call.arguments)
[13:33:36.404]             }))
[13:33:36.404]             future::FutureResult(value = ...future.value$value, 
[13:33:36.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.404]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.404]                     ...future.globalenv.names))
[13:33:36.404]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.404]         }, condition = base::local({
[13:33:36.404]             c <- base::c
[13:33:36.404]             inherits <- base::inherits
[13:33:36.404]             invokeRestart <- base::invokeRestart
[13:33:36.404]             length <- base::length
[13:33:36.404]             list <- base::list
[13:33:36.404]             seq.int <- base::seq.int
[13:33:36.404]             signalCondition <- base::signalCondition
[13:33:36.404]             sys.calls <- base::sys.calls
[13:33:36.404]             `[[` <- base::`[[`
[13:33:36.404]             `+` <- base::`+`
[13:33:36.404]             `<<-` <- base::`<<-`
[13:33:36.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.404]                   3L)]
[13:33:36.404]             }
[13:33:36.404]             function(cond) {
[13:33:36.404]                 is_error <- inherits(cond, "error")
[13:33:36.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.404]                   NULL)
[13:33:36.404]                 if (is_error) {
[13:33:36.404]                   sessionInformation <- function() {
[13:33:36.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.404]                       search = base::search(), system = base::Sys.info())
[13:33:36.404]                   }
[13:33:36.404]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.404]                     cond$call), session = sessionInformation(), 
[13:33:36.404]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.404]                   signalCondition(cond)
[13:33:36.404]                 }
[13:33:36.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.404]                 "immediateCondition"))) {
[13:33:36.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.404]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.404]                   if (TRUE && !signal) {
[13:33:36.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.404]                     {
[13:33:36.404]                       inherits <- base::inherits
[13:33:36.404]                       invokeRestart <- base::invokeRestart
[13:33:36.404]                       is.null <- base::is.null
[13:33:36.404]                       muffled <- FALSE
[13:33:36.404]                       if (inherits(cond, "message")) {
[13:33:36.404]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.404]                         if (muffled) 
[13:33:36.404]                           invokeRestart("muffleMessage")
[13:33:36.404]                       }
[13:33:36.404]                       else if (inherits(cond, "warning")) {
[13:33:36.404]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.404]                         if (muffled) 
[13:33:36.404]                           invokeRestart("muffleWarning")
[13:33:36.404]                       }
[13:33:36.404]                       else if (inherits(cond, "condition")) {
[13:33:36.404]                         if (!is.null(pattern)) {
[13:33:36.404]                           computeRestarts <- base::computeRestarts
[13:33:36.404]                           grepl <- base::grepl
[13:33:36.404]                           restarts <- computeRestarts(cond)
[13:33:36.404]                           for (restart in restarts) {
[13:33:36.404]                             name <- restart$name
[13:33:36.404]                             if (is.null(name)) 
[13:33:36.404]                               next
[13:33:36.404]                             if (!grepl(pattern, name)) 
[13:33:36.404]                               next
[13:33:36.404]                             invokeRestart(restart)
[13:33:36.404]                             muffled <- TRUE
[13:33:36.404]                             break
[13:33:36.404]                           }
[13:33:36.404]                         }
[13:33:36.404]                       }
[13:33:36.404]                       invisible(muffled)
[13:33:36.404]                     }
[13:33:36.404]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.404]                   }
[13:33:36.404]                 }
[13:33:36.404]                 else {
[13:33:36.404]                   if (TRUE) {
[13:33:36.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.404]                     {
[13:33:36.404]                       inherits <- base::inherits
[13:33:36.404]                       invokeRestart <- base::invokeRestart
[13:33:36.404]                       is.null <- base::is.null
[13:33:36.404]                       muffled <- FALSE
[13:33:36.404]                       if (inherits(cond, "message")) {
[13:33:36.404]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.404]                         if (muffled) 
[13:33:36.404]                           invokeRestart("muffleMessage")
[13:33:36.404]                       }
[13:33:36.404]                       else if (inherits(cond, "warning")) {
[13:33:36.404]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.404]                         if (muffled) 
[13:33:36.404]                           invokeRestart("muffleWarning")
[13:33:36.404]                       }
[13:33:36.404]                       else if (inherits(cond, "condition")) {
[13:33:36.404]                         if (!is.null(pattern)) {
[13:33:36.404]                           computeRestarts <- base::computeRestarts
[13:33:36.404]                           grepl <- base::grepl
[13:33:36.404]                           restarts <- computeRestarts(cond)
[13:33:36.404]                           for (restart in restarts) {
[13:33:36.404]                             name <- restart$name
[13:33:36.404]                             if (is.null(name)) 
[13:33:36.404]                               next
[13:33:36.404]                             if (!grepl(pattern, name)) 
[13:33:36.404]                               next
[13:33:36.404]                             invokeRestart(restart)
[13:33:36.404]                             muffled <- TRUE
[13:33:36.404]                             break
[13:33:36.404]                           }
[13:33:36.404]                         }
[13:33:36.404]                       }
[13:33:36.404]                       invisible(muffled)
[13:33:36.404]                     }
[13:33:36.404]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.404]                   }
[13:33:36.404]                 }
[13:33:36.404]             }
[13:33:36.404]         }))
[13:33:36.404]     }, error = function(ex) {
[13:33:36.404]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.404]                 ...future.rng), started = ...future.startTime, 
[13:33:36.404]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.404]             version = "1.8"), class = "FutureResult")
[13:33:36.404]     }, finally = {
[13:33:36.404]         if (!identical(...future.workdir, getwd())) 
[13:33:36.404]             setwd(...future.workdir)
[13:33:36.404]         {
[13:33:36.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.404]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.404]             }
[13:33:36.404]             base::options(...future.oldOptions)
[13:33:36.404]             if (.Platform$OS.type == "windows") {
[13:33:36.404]                 old_names <- names(...future.oldEnvVars)
[13:33:36.404]                 envs <- base::Sys.getenv()
[13:33:36.404]                 names <- names(envs)
[13:33:36.404]                 common <- intersect(names, old_names)
[13:33:36.404]                 added <- setdiff(names, old_names)
[13:33:36.404]                 removed <- setdiff(old_names, names)
[13:33:36.404]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.404]                   envs[common]]
[13:33:36.404]                 NAMES <- toupper(changed)
[13:33:36.404]                 args <- list()
[13:33:36.404]                 for (kk in seq_along(NAMES)) {
[13:33:36.404]                   name <- changed[[kk]]
[13:33:36.404]                   NAME <- NAMES[[kk]]
[13:33:36.404]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.404]                     next
[13:33:36.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.404]                 }
[13:33:36.404]                 NAMES <- toupper(added)
[13:33:36.404]                 for (kk in seq_along(NAMES)) {
[13:33:36.404]                   name <- added[[kk]]
[13:33:36.404]                   NAME <- NAMES[[kk]]
[13:33:36.404]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.404]                     next
[13:33:36.404]                   args[[name]] <- ""
[13:33:36.404]                 }
[13:33:36.404]                 NAMES <- toupper(removed)
[13:33:36.404]                 for (kk in seq_along(NAMES)) {
[13:33:36.404]                   name <- removed[[kk]]
[13:33:36.404]                   NAME <- NAMES[[kk]]
[13:33:36.404]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.404]                     next
[13:33:36.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.404]                 }
[13:33:36.404]                 if (length(args) > 0) 
[13:33:36.404]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.404]             }
[13:33:36.404]             else {
[13:33:36.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.404]             }
[13:33:36.404]             {
[13:33:36.404]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.404]                   0L) {
[13:33:36.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.404]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.404]                   base::options(opts)
[13:33:36.404]                 }
[13:33:36.404]                 {
[13:33:36.404]                   {
[13:33:36.404]                     NULL
[13:33:36.404]                     RNGkind("Mersenne-Twister")
[13:33:36.404]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:36.404]                       inherits = FALSE)
[13:33:36.404]                   }
[13:33:36.404]                   options(future.plan = NULL)
[13:33:36.404]                   if (is.na(NA_character_)) 
[13:33:36.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.404]                     .init = FALSE)
[13:33:36.404]                 }
[13:33:36.404]             }
[13:33:36.404]         }
[13:33:36.404]     })
[13:33:36.404]     if (TRUE) {
[13:33:36.404]         base::sink(type = "output", split = FALSE)
[13:33:36.404]         if (TRUE) {
[13:33:36.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.404]         }
[13:33:36.404]         else {
[13:33:36.404]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.404]         }
[13:33:36.404]         base::close(...future.stdout)
[13:33:36.404]         ...future.stdout <- NULL
[13:33:36.404]     }
[13:33:36.404]     ...future.result$conditions <- ...future.conditions
[13:33:36.404]     ...future.result$finished <- base::Sys.time()
[13:33:36.404]     ...future.result
[13:33:36.404] }
[13:33:36.406] assign_globals() ...
[13:33:36.406] List of 5
[13:33:36.406]  $ future.call.arguments    : list()
[13:33:36.406]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.406]  $ ...future.FUN            :function (x)  
[13:33:36.406]  $ ...future.elements_ii    :List of 2
[13:33:36.406]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[13:33:36.406]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[13:33:36.406]  $ ...future.seeds_ii       : NULL
[13:33:36.406]  $ ...future.globals.maxSize: num Inf
[13:33:36.406]  - attr(*, "resolved")= logi FALSE
[13:33:36.406]  - attr(*, "total_size")= num NA
[13:33:36.406]  - attr(*, "where")=List of 5
[13:33:36.406]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.406]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.406]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.406]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.406]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.406]  - attr(*, "already-done")= logi TRUE
[13:33:36.411] - copied ‘future.call.arguments’ to environment
[13:33:36.411] - copied ‘...future.FUN’ to environment
[13:33:36.411] - copied ‘...future.elements_ii’ to environment
[13:33:36.411] - copied ‘...future.seeds_ii’ to environment
[13:33:36.411] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.411] assign_globals() ... done
[13:33:36.412] plan(): Setting new future strategy stack:
[13:33:36.412] List of future strategies:
[13:33:36.412] 1. sequential:
[13:33:36.412]    - args: function (..., envir = parent.frame())
[13:33:36.412]    - tweaked: FALSE
[13:33:36.412]    - call: NULL
[13:33:36.413] plan(): nbrOfWorkers() = 1
[13:33:36.413] plan(): Setting new future strategy stack:
[13:33:36.414] List of future strategies:
[13:33:36.414] 1. sequential:
[13:33:36.414]    - args: function (..., envir = parent.frame())
[13:33:36.414]    - tweaked: FALSE
[13:33:36.414]    - call: plan(strategy)
[13:33:36.414] plan(): nbrOfWorkers() = 1
[13:33:36.414] SequentialFuture started (and completed)
[13:33:36.414] - Launch lazy future ... done
[13:33:36.414] run() for ‘SequentialFuture’ ... done
[13:33:36.414] Created future:
[13:33:36.415] SequentialFuture:
[13:33:36.415] Label: ‘future_apply-1’
[13:33:36.415] Expression:
[13:33:36.415] {
[13:33:36.415]     do.call(function(...) {
[13:33:36.415]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.415]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.415]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.415]             on.exit(options(oopts), add = TRUE)
[13:33:36.415]         }
[13:33:36.415]         {
[13:33:36.415]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.415]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.415]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.415]             })
[13:33:36.415]         }
[13:33:36.415]     }, args = future.call.arguments)
[13:33:36.415] }
[13:33:36.415] Lazy evaluation: FALSE
[13:33:36.415] Asynchronous evaluation: FALSE
[13:33:36.415] Local evaluation: TRUE
[13:33:36.415] Environment: R_GlobalEnv
[13:33:36.415] Capture standard output: TRUE
[13:33:36.415] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.415] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.415] Packages: <none>
[13:33:36.415] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.415] Resolved: TRUE
[13:33:36.415] Value: 496 bytes of class ‘list’
[13:33:36.415] Early signaling: FALSE
[13:33:36.415] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.415] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.415] Chunk #1 of 1 ... DONE
[13:33:36.415] Launching 1 futures (chunks) ... DONE
[13:33:36.416] Resolving 1 futures (chunks) ...
[13:33:36.416] resolve() on list ...
[13:33:36.416]  recursive: 0
[13:33:36.416]  length: 1
[13:33:36.416] 
[13:33:36.416] resolved() for ‘SequentialFuture’ ...
[13:33:36.416] - state: ‘finished’
[13:33:36.416] - run: TRUE
[13:33:36.416] - result: ‘FutureResult’
[13:33:36.416] resolved() for ‘SequentialFuture’ ... done
[13:33:36.416] Future #1
[13:33:36.417] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:36.417] - nx: 1
[13:33:36.417] - relay: TRUE
[13:33:36.417] - stdout: TRUE
[13:33:36.417] - signal: TRUE
[13:33:36.417] - resignal: FALSE
[13:33:36.417] - force: TRUE
[13:33:36.417] - relayed: [n=1] FALSE
[13:33:36.417] - queued futures: [n=1] FALSE
[13:33:36.417]  - until=1
[13:33:36.417]  - relaying element #1
[13:33:36.418] - relayed: [n=1] TRUE
[13:33:36.418] - queued futures: [n=1] TRUE
[13:33:36.418] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:36.418]  length: 0 (resolved future 1)
[13:33:36.418] Relaying remaining futures
[13:33:36.418] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.418] - nx: 1
[13:33:36.418] - relay: TRUE
[13:33:36.418] - stdout: TRUE
[13:33:36.418] - signal: TRUE
[13:33:36.418] - resignal: FALSE
[13:33:36.418] - force: TRUE
[13:33:36.419] - relayed: [n=1] TRUE
[13:33:36.419] - queued futures: [n=1] TRUE
 - flush all
[13:33:36.419] - relayed: [n=1] TRUE
[13:33:36.419] - queued futures: [n=1] TRUE
[13:33:36.419] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.419] resolve() on list ... DONE
[13:33:36.419]  - Number of value chunks collected: 1
[13:33:36.419] Resolving 1 futures (chunks) ... DONE
[13:33:36.419] Reducing values from 1 chunks ...
[13:33:36.419]  - Number of values collected after concatenation: 2
[13:33:36.419]  - Number of values expected: 2
[13:33:36.420] Reducing values from 1 chunks ... DONE
[13:33:36.420] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[13:33:36.420] getGlobalsAndPackagesXApply() ...
[13:33:36.420]  - future.globals: TRUE
[13:33:36.420] getGlobalsAndPackages() ...
[13:33:36.420] Searching for globals...
[13:33:36.422] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[13:33:36.423] Searching for globals ... DONE
[13:33:36.423] Resolving globals: FALSE
[13:33:36.423] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[13:33:36.423] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[13:33:36.424] - globals: [1] ‘FUN’
[13:33:36.424] 
[13:33:36.424] getGlobalsAndPackages() ... DONE
[13:33:36.424]  - globals found/used: [n=1] ‘FUN’
[13:33:36.424]  - needed namespaces: [n=0] 
[13:33:36.424] Finding globals ... DONE
[13:33:36.424]  - use_args: TRUE
[13:33:36.424]  - Getting '...' globals ...
[13:33:36.424] resolve() on list ...
[13:33:36.425]  recursive: 0
[13:33:36.425]  length: 1
[13:33:36.425]  elements: ‘...’
[13:33:36.425]  length: 0 (resolved future 1)
[13:33:36.425] resolve() on list ... DONE
[13:33:36.425]    - '...' content: [n=0] 
[13:33:36.425] List of 1
[13:33:36.425]  $ ...: list()
[13:33:36.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.425]  - attr(*, "where")=List of 1
[13:33:36.425]   ..$ ...:<environment: 0x55b9481645d8> 
[13:33:36.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.425]  - attr(*, "resolved")= logi TRUE
[13:33:36.425]  - attr(*, "total_size")= num NA
[13:33:36.427]  - Getting '...' globals ... DONE
[13:33:36.428] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.428] List of 2
[13:33:36.428]  $ ...future.FUN:function (x)  
[13:33:36.428]  $ ...          : list()
[13:33:36.428]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.428]  - attr(*, "where")=List of 2
[13:33:36.428]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.428]   ..$ ...          :<environment: 0x55b9481645d8> 
[13:33:36.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.428]  - attr(*, "resolved")= logi FALSE
[13:33:36.428]  - attr(*, "total_size")= num 9888
[13:33:36.430] Packages to be attached in all futures: [n=0] 
[13:33:36.430] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.430] future_lapply() ...
[13:33:36.432] Number of chunks: 1
[13:33:36.432] getGlobalsAndPackagesXApply() ...
[13:33:36.432]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.433]  - use_args: TRUE
[13:33:36.433] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.433] List of 2
[13:33:36.433]  $ ...          : list()
[13:33:36.433]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.433]  $ ...future.FUN:function (x)  
[13:33:36.433]  - attr(*, "where")=List of 2
[13:33:36.433]   ..$ ...          :<environment: 0x55b9481645d8> 
[13:33:36.433]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:33:36.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.433]  - attr(*, "resolved")= logi FALSE
[13:33:36.433]  - attr(*, "total_size")= num NA
[13:33:36.435] Packages to be attached in all futures: [n=0] 
[13:33:36.436] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.436] Number of futures (= number of chunks): 1
[13:33:36.436] Launching 1 futures (chunks) ...
[13:33:36.436] Chunk #1 of 1 ...
[13:33:36.436]  - seeds: <none>
[13:33:36.436]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.436] getGlobalsAndPackages() ...
[13:33:36.436] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.436] Resolving globals: FALSE
[13:33:36.437] Tweak future expression to call with '...' arguments ...
[13:33:36.437] {
[13:33:36.437]     do.call(function(...) {
[13:33:36.437]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.437]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.437]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.437]             on.exit(options(oopts), add = TRUE)
[13:33:36.437]         }
[13:33:36.437]         {
[13:33:36.437]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.437]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.437]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.437]             })
[13:33:36.437]         }
[13:33:36.437]     }, args = future.call.arguments)
[13:33:36.437] }
[13:33:36.437] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.437] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.437] 
[13:33:36.437] getGlobalsAndPackages() ... DONE
[13:33:36.438] run() for ‘Future’ ...
[13:33:36.438] - state: ‘created’
[13:33:36.438] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:36.438] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.438] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:36.438]   - Field: ‘label’
[13:33:36.438]   - Field: ‘local’
[13:33:36.438]   - Field: ‘owner’
[13:33:36.439]   - Field: ‘envir’
[13:33:36.439]   - Field: ‘packages’
[13:33:36.439]   - Field: ‘gc’
[13:33:36.439]   - Field: ‘conditions’
[13:33:36.439]   - Field: ‘expr’
[13:33:36.439]   - Field: ‘uuid’
[13:33:36.439]   - Field: ‘seed’
[13:33:36.439]   - Field: ‘version’
[13:33:36.439]   - Field: ‘result’
[13:33:36.439]   - Field: ‘asynchronous’
[13:33:36.439]   - Field: ‘calls’
[13:33:36.439]   - Field: ‘globals’
[13:33:36.440]   - Field: ‘stdout’
[13:33:36.440]   - Field: ‘earlySignal’
[13:33:36.440]   - Field: ‘lazy’
[13:33:36.440]   - Field: ‘state’
[13:33:36.440] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:36.440] - Launch lazy future ...
[13:33:36.440] Packages needed by the future expression (n = 0): <none>
[13:33:36.440] Packages needed by future strategies (n = 0): <none>
[13:33:36.441] {
[13:33:36.441]     {
[13:33:36.441]         {
[13:33:36.441]             ...future.startTime <- base::Sys.time()
[13:33:36.441]             {
[13:33:36.441]                 {
[13:33:36.441]                   {
[13:33:36.441]                     base::local({
[13:33:36.441]                       has_future <- base::requireNamespace("future", 
[13:33:36.441]                         quietly = TRUE)
[13:33:36.441]                       if (has_future) {
[13:33:36.441]                         ns <- base::getNamespace("future")
[13:33:36.441]                         version <- ns[[".package"]][["version"]]
[13:33:36.441]                         if (is.null(version)) 
[13:33:36.441]                           version <- utils::packageVersion("future")
[13:33:36.441]                       }
[13:33:36.441]                       else {
[13:33:36.441]                         version <- NULL
[13:33:36.441]                       }
[13:33:36.441]                       if (!has_future || version < "1.8.0") {
[13:33:36.441]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.441]                           "", base::R.version$version.string), 
[13:33:36.441]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:36.441]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.441]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.441]                             "release", "version")], collapse = " "), 
[13:33:36.441]                           hostname = base::Sys.info()[["nodename"]])
[13:33:36.441]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.441]                           info)
[13:33:36.441]                         info <- base::paste(info, collapse = "; ")
[13:33:36.441]                         if (!has_future) {
[13:33:36.441]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.441]                             info)
[13:33:36.441]                         }
[13:33:36.441]                         else {
[13:33:36.441]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.441]                             info, version)
[13:33:36.441]                         }
[13:33:36.441]                         base::stop(msg)
[13:33:36.441]                       }
[13:33:36.441]                     })
[13:33:36.441]                   }
[13:33:36.441]                   ...future.strategy.old <- future::plan("list")
[13:33:36.441]                   options(future.plan = NULL)
[13:33:36.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.441]                 }
[13:33:36.441]                 ...future.workdir <- getwd()
[13:33:36.441]             }
[13:33:36.441]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.441]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.441]         }
[13:33:36.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.441]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.441]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.441]             base::names(...future.oldOptions))
[13:33:36.441]     }
[13:33:36.441]     if (FALSE) {
[13:33:36.441]     }
[13:33:36.441]     else {
[13:33:36.441]         if (TRUE) {
[13:33:36.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.441]                 open = "w")
[13:33:36.441]         }
[13:33:36.441]         else {
[13:33:36.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.441]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.441]         }
[13:33:36.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.441]             base::sink(type = "output", split = FALSE)
[13:33:36.441]             base::close(...future.stdout)
[13:33:36.441]         }, add = TRUE)
[13:33:36.441]     }
[13:33:36.441]     ...future.frame <- base::sys.nframe()
[13:33:36.441]     ...future.conditions <- base::list()
[13:33:36.441]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.441]     if (FALSE) {
[13:33:36.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.441]     }
[13:33:36.441]     ...future.result <- base::tryCatch({
[13:33:36.441]         base::withCallingHandlers({
[13:33:36.441]             ...future.value <- base::withVisible(base::local({
[13:33:36.441]                 do.call(function(...) {
[13:33:36.441]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.441]                   if (!identical(...future.globals.maxSize.org, 
[13:33:36.441]                     ...future.globals.maxSize)) {
[13:33:36.441]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.441]                     on.exit(options(oopts), add = TRUE)
[13:33:36.441]                   }
[13:33:36.441]                   {
[13:33:36.441]                     lapply(seq_along(...future.elements_ii), 
[13:33:36.441]                       FUN = function(jj) {
[13:33:36.441]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.441]                         ...future.FUN(...future.X_jj, ...)
[13:33:36.441]                       })
[13:33:36.441]                   }
[13:33:36.441]                 }, args = future.call.arguments)
[13:33:36.441]             }))
[13:33:36.441]             future::FutureResult(value = ...future.value$value, 
[13:33:36.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.441]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.441]                     ...future.globalenv.names))
[13:33:36.441]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.441]         }, condition = base::local({
[13:33:36.441]             c <- base::c
[13:33:36.441]             inherits <- base::inherits
[13:33:36.441]             invokeRestart <- base::invokeRestart
[13:33:36.441]             length <- base::length
[13:33:36.441]             list <- base::list
[13:33:36.441]             seq.int <- base::seq.int
[13:33:36.441]             signalCondition <- base::signalCondition
[13:33:36.441]             sys.calls <- base::sys.calls
[13:33:36.441]             `[[` <- base::`[[`
[13:33:36.441]             `+` <- base::`+`
[13:33:36.441]             `<<-` <- base::`<<-`
[13:33:36.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.441]                   3L)]
[13:33:36.441]             }
[13:33:36.441]             function(cond) {
[13:33:36.441]                 is_error <- inherits(cond, "error")
[13:33:36.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.441]                   NULL)
[13:33:36.441]                 if (is_error) {
[13:33:36.441]                   sessionInformation <- function() {
[13:33:36.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.441]                       search = base::search(), system = base::Sys.info())
[13:33:36.441]                   }
[13:33:36.441]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.441]                     cond$call), session = sessionInformation(), 
[13:33:36.441]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.441]                   signalCondition(cond)
[13:33:36.441]                 }
[13:33:36.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.441]                 "immediateCondition"))) {
[13:33:36.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.441]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.441]                   if (TRUE && !signal) {
[13:33:36.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.441]                     {
[13:33:36.441]                       inherits <- base::inherits
[13:33:36.441]                       invokeRestart <- base::invokeRestart
[13:33:36.441]                       is.null <- base::is.null
[13:33:36.441]                       muffled <- FALSE
[13:33:36.441]                       if (inherits(cond, "message")) {
[13:33:36.441]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.441]                         if (muffled) 
[13:33:36.441]                           invokeRestart("muffleMessage")
[13:33:36.441]                       }
[13:33:36.441]                       else if (inherits(cond, "warning")) {
[13:33:36.441]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.441]                         if (muffled) 
[13:33:36.441]                           invokeRestart("muffleWarning")
[13:33:36.441]                       }
[13:33:36.441]                       else if (inherits(cond, "condition")) {
[13:33:36.441]                         if (!is.null(pattern)) {
[13:33:36.441]                           computeRestarts <- base::computeRestarts
[13:33:36.441]                           grepl <- base::grepl
[13:33:36.441]                           restarts <- computeRestarts(cond)
[13:33:36.441]                           for (restart in restarts) {
[13:33:36.441]                             name <- restart$name
[13:33:36.441]                             if (is.null(name)) 
[13:33:36.441]                               next
[13:33:36.441]                             if (!grepl(pattern, name)) 
[13:33:36.441]                               next
[13:33:36.441]                             invokeRestart(restart)
[13:33:36.441]                             muffled <- TRUE
[13:33:36.441]                             break
[13:33:36.441]                           }
[13:33:36.441]                         }
[13:33:36.441]                       }
[13:33:36.441]                       invisible(muffled)
[13:33:36.441]                     }
[13:33:36.441]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.441]                   }
[13:33:36.441]                 }
[13:33:36.441]                 else {
[13:33:36.441]                   if (TRUE) {
[13:33:36.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.441]                     {
[13:33:36.441]                       inherits <- base::inherits
[13:33:36.441]                       invokeRestart <- base::invokeRestart
[13:33:36.441]                       is.null <- base::is.null
[13:33:36.441]                       muffled <- FALSE
[13:33:36.441]                       if (inherits(cond, "message")) {
[13:33:36.441]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.441]                         if (muffled) 
[13:33:36.441]                           invokeRestart("muffleMessage")
[13:33:36.441]                       }
[13:33:36.441]                       else if (inherits(cond, "warning")) {
[13:33:36.441]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.441]                         if (muffled) 
[13:33:36.441]                           invokeRestart("muffleWarning")
[13:33:36.441]                       }
[13:33:36.441]                       else if (inherits(cond, "condition")) {
[13:33:36.441]                         if (!is.null(pattern)) {
[13:33:36.441]                           computeRestarts <- base::computeRestarts
[13:33:36.441]                           grepl <- base::grepl
[13:33:36.441]                           restarts <- computeRestarts(cond)
[13:33:36.441]                           for (restart in restarts) {
[13:33:36.441]                             name <- restart$name
[13:33:36.441]                             if (is.null(name)) 
[13:33:36.441]                               next
[13:33:36.441]                             if (!grepl(pattern, name)) 
[13:33:36.441]                               next
[13:33:36.441]                             invokeRestart(restart)
[13:33:36.441]                             muffled <- TRUE
[13:33:36.441]                             break
[13:33:36.441]                           }
[13:33:36.441]                         }
[13:33:36.441]                       }
[13:33:36.441]                       invisible(muffled)
[13:33:36.441]                     }
[13:33:36.441]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.441]                   }
[13:33:36.441]                 }
[13:33:36.441]             }
[13:33:36.441]         }))
[13:33:36.441]     }, error = function(ex) {
[13:33:36.441]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.441]                 ...future.rng), started = ...future.startTime, 
[13:33:36.441]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.441]             version = "1.8"), class = "FutureResult")
[13:33:36.441]     }, finally = {
[13:33:36.441]         if (!identical(...future.workdir, getwd())) 
[13:33:36.441]             setwd(...future.workdir)
[13:33:36.441]         {
[13:33:36.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.441]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.441]             }
[13:33:36.441]             base::options(...future.oldOptions)
[13:33:36.441]             if (.Platform$OS.type == "windows") {
[13:33:36.441]                 old_names <- names(...future.oldEnvVars)
[13:33:36.441]                 envs <- base::Sys.getenv()
[13:33:36.441]                 names <- names(envs)
[13:33:36.441]                 common <- intersect(names, old_names)
[13:33:36.441]                 added <- setdiff(names, old_names)
[13:33:36.441]                 removed <- setdiff(old_names, names)
[13:33:36.441]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.441]                   envs[common]]
[13:33:36.441]                 NAMES <- toupper(changed)
[13:33:36.441]                 args <- list()
[13:33:36.441]                 for (kk in seq_along(NAMES)) {
[13:33:36.441]                   name <- changed[[kk]]
[13:33:36.441]                   NAME <- NAMES[[kk]]
[13:33:36.441]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.441]                     next
[13:33:36.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.441]                 }
[13:33:36.441]                 NAMES <- toupper(added)
[13:33:36.441]                 for (kk in seq_along(NAMES)) {
[13:33:36.441]                   name <- added[[kk]]
[13:33:36.441]                   NAME <- NAMES[[kk]]
[13:33:36.441]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.441]                     next
[13:33:36.441]                   args[[name]] <- ""
[13:33:36.441]                 }
[13:33:36.441]                 NAMES <- toupper(removed)
[13:33:36.441]                 for (kk in seq_along(NAMES)) {
[13:33:36.441]                   name <- removed[[kk]]
[13:33:36.441]                   NAME <- NAMES[[kk]]
[13:33:36.441]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.441]                     next
[13:33:36.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.441]                 }
[13:33:36.441]                 if (length(args) > 0) 
[13:33:36.441]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.441]             }
[13:33:36.441]             else {
[13:33:36.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.441]             }
[13:33:36.441]             {
[13:33:36.441]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.441]                   0L) {
[13:33:36.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.441]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.441]                   base::options(opts)
[13:33:36.441]                 }
[13:33:36.441]                 {
[13:33:36.441]                   {
[13:33:36.441]                     NULL
[13:33:36.441]                     RNGkind("Mersenne-Twister")
[13:33:36.441]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:36.441]                       inherits = FALSE)
[13:33:36.441]                   }
[13:33:36.441]                   options(future.plan = NULL)
[13:33:36.441]                   if (is.na(NA_character_)) 
[13:33:36.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.441]                     .init = FALSE)
[13:33:36.441]                 }
[13:33:36.441]             }
[13:33:36.441]         }
[13:33:36.441]     })
[13:33:36.441]     if (TRUE) {
[13:33:36.441]         base::sink(type = "output", split = FALSE)
[13:33:36.441]         if (TRUE) {
[13:33:36.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.441]         }
[13:33:36.441]         else {
[13:33:36.441]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.441]         }
[13:33:36.441]         base::close(...future.stdout)
[13:33:36.441]         ...future.stdout <- NULL
[13:33:36.441]     }
[13:33:36.441]     ...future.result$conditions <- ...future.conditions
[13:33:36.441]     ...future.result$finished <- base::Sys.time()
[13:33:36.441]     ...future.result
[13:33:36.441] }
[13:33:36.442] assign_globals() ...
[13:33:36.442] List of 5
[13:33:36.442]  $ future.call.arguments    : list()
[13:33:36.442]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.442]  $ ...future.FUN            :function (x)  
[13:33:36.442]  $ ...future.elements_ii    :List of 2
[13:33:36.442]   ..$ : int [1:2] 1 3
[13:33:36.442]   ..$ : int [1:2] 2 4
[13:33:36.442]  $ ...future.seeds_ii       : NULL
[13:33:36.442]  $ ...future.globals.maxSize: num Inf
[13:33:36.442]  - attr(*, "resolved")= logi FALSE
[13:33:36.442]  - attr(*, "total_size")= num NA
[13:33:36.442]  - attr(*, "where")=List of 5
[13:33:36.442]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.442]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.442]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.442]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.442]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.442]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.442]  - attr(*, "already-done")= logi TRUE
[13:33:36.447] - copied ‘future.call.arguments’ to environment
[13:33:36.447] - reassign environment for ‘...future.FUN’
[13:33:36.447] - copied ‘...future.FUN’ to environment
[13:33:36.447] - copied ‘...future.elements_ii’ to environment
[13:33:36.447] - copied ‘...future.seeds_ii’ to environment
[13:33:36.447] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.447] assign_globals() ... done
[13:33:36.448] plan(): Setting new future strategy stack:
[13:33:36.448] List of future strategies:
[13:33:36.448] 1. sequential:
[13:33:36.448]    - args: function (..., envir = parent.frame())
[13:33:36.448]    - tweaked: FALSE
[13:33:36.448]    - call: NULL
[13:33:36.448] plan(): nbrOfWorkers() = 1
[13:33:36.449] plan(): Setting new future strategy stack:
[13:33:36.449] List of future strategies:
[13:33:36.449] 1. sequential:
[13:33:36.449]    - args: function (..., envir = parent.frame())
[13:33:36.449]    - tweaked: FALSE
[13:33:36.449]    - call: plan(strategy)
[13:33:36.449] plan(): nbrOfWorkers() = 1
[13:33:36.449] SequentialFuture started (and completed)
[13:33:36.449] - Launch lazy future ... done
[13:33:36.450] run() for ‘SequentialFuture’ ... done
[13:33:36.450] Created future:
[13:33:36.450] SequentialFuture:
[13:33:36.450] Label: ‘future_apply-1’
[13:33:36.450] Expression:
[13:33:36.450] {
[13:33:36.450]     do.call(function(...) {
[13:33:36.450]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.450]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.450]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.450]             on.exit(options(oopts), add = TRUE)
[13:33:36.450]         }
[13:33:36.450]         {
[13:33:36.450]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.450]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.450]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.450]             })
[13:33:36.450]         }
[13:33:36.450]     }, args = future.call.arguments)
[13:33:36.450] }
[13:33:36.450] Lazy evaluation: FALSE
[13:33:36.450] Asynchronous evaluation: FALSE
[13:33:36.450] Local evaluation: TRUE
[13:33:36.450] Environment: R_GlobalEnv
[13:33:36.450] Capture standard output: TRUE
[13:33:36.450] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.450] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.450] Packages: <none>
[13:33:36.450] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.450] Resolved: TRUE
[13:33:36.450] Value: 400 bytes of class ‘list’
[13:33:36.450] Early signaling: FALSE
[13:33:36.450] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.450] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.451] Chunk #1 of 1 ... DONE
[13:33:36.451] Launching 1 futures (chunks) ... DONE
[13:33:36.451] Resolving 1 futures (chunks) ...
[13:33:36.451] resolve() on list ...
[13:33:36.451]  recursive: 0
[13:33:36.451]  length: 1
[13:33:36.451] 
[13:33:36.451] resolved() for ‘SequentialFuture’ ...
[13:33:36.451] - state: ‘finished’
[13:33:36.451] - run: TRUE
[13:33:36.451] - result: ‘FutureResult’
[13:33:36.452] resolved() for ‘SequentialFuture’ ... done
[13:33:36.452] Future #1
[13:33:36.452] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:36.452] - nx: 1
[13:33:36.452] - relay: TRUE
[13:33:36.452] - stdout: TRUE
[13:33:36.452] - signal: TRUE
[13:33:36.452] - resignal: FALSE
[13:33:36.452] - force: TRUE
[13:33:36.452] - relayed: [n=1] FALSE
[13:33:36.452] - queued futures: [n=1] FALSE
[13:33:36.453]  - until=1
[13:33:36.453]  - relaying element #1
[13:33:36.453] - relayed: [n=1] TRUE
[13:33:36.453] - queued futures: [n=1] TRUE
[13:33:36.453] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:36.453]  length: 0 (resolved future 1)
[13:33:36.453] Relaying remaining futures
[13:33:36.453] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.453] - nx: 1
[13:33:36.453] - relay: TRUE
[13:33:36.453] - stdout: TRUE
[13:33:36.454] - signal: TRUE
[13:33:36.454] - resignal: FALSE
[13:33:36.454] - force: TRUE
[13:33:36.454] - relayed: [n=1] TRUE
[13:33:36.455] - queued futures: [n=1] TRUE
 - flush all
[13:33:36.455] - relayed: [n=1] TRUE
[13:33:36.455] - queued futures: [n=1] TRUE
[13:33:36.455] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.455] resolve() on list ... DONE
[13:33:36.455]  - Number of value chunks collected: 1
[13:33:36.455] Resolving 1 futures (chunks) ... DONE
[13:33:36.455] Reducing values from 1 chunks ...
[13:33:36.455]  - Number of values collected after concatenation: 2
[13:33:36.455]  - Number of values expected: 2
[13:33:36.456] Reducing values from 1 chunks ... DONE
[13:33:36.456] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[13:33:36.456] getGlobalsAndPackagesXApply() ...
[13:33:36.456]  - future.globals: TRUE
[13:33:36.456] getGlobalsAndPackages() ...
[13:33:36.456] Searching for globals...
[13:33:36.459] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[13:33:36.459] Searching for globals ... DONE
[13:33:36.459] Resolving globals: FALSE
[13:33:36.459] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[13:33:36.460] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[13:33:36.460] - globals: [1] ‘FUN’
[13:33:36.460] 
[13:33:36.460] getGlobalsAndPackages() ... DONE
[13:33:36.460]  - globals found/used: [n=1] ‘FUN’
[13:33:36.460]  - needed namespaces: [n=0] 
[13:33:36.460] Finding globals ... DONE
[13:33:36.460]  - use_args: TRUE
[13:33:36.460]  - Getting '...' globals ...
[13:33:36.461] resolve() on list ...
[13:33:36.461]  recursive: 0
[13:33:36.461]  length: 1
[13:33:36.461]  elements: ‘...’
[13:33:36.461]  length: 0 (resolved future 1)
[13:33:36.461] resolve() on list ... DONE
[13:33:36.461]    - '...' content: [n=0] 
[13:33:36.461] List of 1
[13:33:36.461]  $ ...: list()
[13:33:36.461]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.461]  - attr(*, "where")=List of 1
[13:33:36.461]   ..$ ...:<environment: 0x55b9496101d0> 
[13:33:36.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.461]  - attr(*, "resolved")= logi TRUE
[13:33:36.461]  - attr(*, "total_size")= num NA
[13:33:36.464]  - Getting '...' globals ... DONE
[13:33:36.464] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.464] List of 2
[13:33:36.464]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:33:36.464]  $ ...          : list()
[13:33:36.464]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.464]  - attr(*, "where")=List of 2
[13:33:36.464]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.464]   ..$ ...          :<environment: 0x55b9496101d0> 
[13:33:36.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.464]  - attr(*, "resolved")= logi FALSE
[13:33:36.464]  - attr(*, "total_size")= num 36296
[13:33:36.466] Packages to be attached in all futures: [n=0] 
[13:33:36.466] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.467] future_lapply() ...
[13:33:36.468] Generating random seeds ...
[13:33:36.468] Generating random seed streams for 2 elements ...
[13:33:36.469] Generating random seed streams for 2 elements ... DONE
[13:33:36.469] Generating random seeds ... DONE
[13:33:36.469] Will set RNG state on exit: 10407, 1101211037, 923942246, 429179484, 298292888, 105239380, -16683833
[13:33:36.469] Number of chunks: 1
[13:33:36.469] getGlobalsAndPackagesXApply() ...
[13:33:36.469]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.469]  - use_args: TRUE
[13:33:36.470] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.470] List of 2
[13:33:36.470]  $ ...          : list()
[13:33:36.470]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.470]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:33:36.470]  - attr(*, "where")=List of 2
[13:33:36.470]   ..$ ...          :<environment: 0x55b9496101d0> 
[13:33:36.470]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:36.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.470]  - attr(*, "resolved")= logi FALSE
[13:33:36.470]  - attr(*, "total_size")= num NA
[13:33:36.472] Packages to be attached in all futures: [n=0] 
[13:33:36.473] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.473] Number of futures (= number of chunks): 1
[13:33:36.473] Launching 1 futures (chunks) ...
[13:33:36.473] Chunk #1 of 1 ...
[13:33:36.473]  - seeds: [2] <seeds>
[13:33:36.473]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.474] getGlobalsAndPackages() ...
[13:33:36.474] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.474] Resolving globals: FALSE
[13:33:36.474] Tweak future expression to call with '...' arguments ...
[13:33:36.474] {
[13:33:36.474]     do.call(function(...) {
[13:33:36.474]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.474]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.474]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.474]             on.exit(options(oopts), add = TRUE)
[13:33:36.474]         }
[13:33:36.474]         {
[13:33:36.474]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.474]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.474]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:36.474]                   envir = globalenv(), inherits = FALSE)
[13:33:36.474]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.474]             })
[13:33:36.474]         }
[13:33:36.474]     }, args = future.call.arguments)
[13:33:36.474] }
[13:33:36.475] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.475] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.475] 
[13:33:36.475] getGlobalsAndPackages() ... DONE
[13:33:36.475] run() for ‘Future’ ...
[13:33:36.476] - state: ‘created’
[13:33:36.476] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:36.476] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.476] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:36.476]   - Field: ‘label’
[13:33:36.476]   - Field: ‘local’
[13:33:36.476]   - Field: ‘owner’
[13:33:36.476]   - Field: ‘envir’
[13:33:36.477]   - Field: ‘packages’
[13:33:36.477]   - Field: ‘gc’
[13:33:36.477]   - Field: ‘conditions’
[13:33:36.477]   - Field: ‘expr’
[13:33:36.477]   - Field: ‘uuid’
[13:33:36.477]   - Field: ‘seed’
[13:33:36.477]   - Field: ‘version’
[13:33:36.477]   - Field: ‘result’
[13:33:36.477]   - Field: ‘asynchronous’
[13:33:36.477]   - Field: ‘calls’
[13:33:36.477]   - Field: ‘globals’
[13:33:36.477]   - Field: ‘stdout’
[13:33:36.478]   - Field: ‘earlySignal’
[13:33:36.478]   - Field: ‘lazy’
[13:33:36.478]   - Field: ‘state’
[13:33:36.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:36.478] - Launch lazy future ...
[13:33:36.478] Packages needed by the future expression (n = 0): <none>
[13:33:36.478] Packages needed by future strategies (n = 0): <none>
[13:33:36.479] {
[13:33:36.479]     {
[13:33:36.479]         {
[13:33:36.479]             ...future.startTime <- base::Sys.time()
[13:33:36.479]             {
[13:33:36.479]                 {
[13:33:36.479]                   {
[13:33:36.479]                     base::local({
[13:33:36.479]                       has_future <- base::requireNamespace("future", 
[13:33:36.479]                         quietly = TRUE)
[13:33:36.479]                       if (has_future) {
[13:33:36.479]                         ns <- base::getNamespace("future")
[13:33:36.479]                         version <- ns[[".package"]][["version"]]
[13:33:36.479]                         if (is.null(version)) 
[13:33:36.479]                           version <- utils::packageVersion("future")
[13:33:36.479]                       }
[13:33:36.479]                       else {
[13:33:36.479]                         version <- NULL
[13:33:36.479]                       }
[13:33:36.479]                       if (!has_future || version < "1.8.0") {
[13:33:36.479]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.479]                           "", base::R.version$version.string), 
[13:33:36.479]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:36.479]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.479]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.479]                             "release", "version")], collapse = " "), 
[13:33:36.479]                           hostname = base::Sys.info()[["nodename"]])
[13:33:36.479]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.479]                           info)
[13:33:36.479]                         info <- base::paste(info, collapse = "; ")
[13:33:36.479]                         if (!has_future) {
[13:33:36.479]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.479]                             info)
[13:33:36.479]                         }
[13:33:36.479]                         else {
[13:33:36.479]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.479]                             info, version)
[13:33:36.479]                         }
[13:33:36.479]                         base::stop(msg)
[13:33:36.479]                       }
[13:33:36.479]                     })
[13:33:36.479]                   }
[13:33:36.479]                   ...future.strategy.old <- future::plan("list")
[13:33:36.479]                   options(future.plan = NULL)
[13:33:36.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.479]                 }
[13:33:36.479]                 ...future.workdir <- getwd()
[13:33:36.479]             }
[13:33:36.479]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.479]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.479]         }
[13:33:36.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.479]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.479]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.479]             base::names(...future.oldOptions))
[13:33:36.479]     }
[13:33:36.479]     if (FALSE) {
[13:33:36.479]     }
[13:33:36.479]     else {
[13:33:36.479]         if (TRUE) {
[13:33:36.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.479]                 open = "w")
[13:33:36.479]         }
[13:33:36.479]         else {
[13:33:36.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.479]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.479]         }
[13:33:36.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.479]             base::sink(type = "output", split = FALSE)
[13:33:36.479]             base::close(...future.stdout)
[13:33:36.479]         }, add = TRUE)
[13:33:36.479]     }
[13:33:36.479]     ...future.frame <- base::sys.nframe()
[13:33:36.479]     ...future.conditions <- base::list()
[13:33:36.479]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.479]     if (FALSE) {
[13:33:36.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.479]     }
[13:33:36.479]     ...future.result <- base::tryCatch({
[13:33:36.479]         base::withCallingHandlers({
[13:33:36.479]             ...future.value <- base::withVisible(base::local({
[13:33:36.479]                 do.call(function(...) {
[13:33:36.479]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.479]                   if (!identical(...future.globals.maxSize.org, 
[13:33:36.479]                     ...future.globals.maxSize)) {
[13:33:36.479]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.479]                     on.exit(options(oopts), add = TRUE)
[13:33:36.479]                   }
[13:33:36.479]                   {
[13:33:36.479]                     lapply(seq_along(...future.elements_ii), 
[13:33:36.479]                       FUN = function(jj) {
[13:33:36.479]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.479]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:36.479]                           envir = globalenv(), inherits = FALSE)
[13:33:36.479]                         ...future.FUN(...future.X_jj, ...)
[13:33:36.479]                       })
[13:33:36.479]                   }
[13:33:36.479]                 }, args = future.call.arguments)
[13:33:36.479]             }))
[13:33:36.479]             future::FutureResult(value = ...future.value$value, 
[13:33:36.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.479]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.479]                     ...future.globalenv.names))
[13:33:36.479]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.479]         }, condition = base::local({
[13:33:36.479]             c <- base::c
[13:33:36.479]             inherits <- base::inherits
[13:33:36.479]             invokeRestart <- base::invokeRestart
[13:33:36.479]             length <- base::length
[13:33:36.479]             list <- base::list
[13:33:36.479]             seq.int <- base::seq.int
[13:33:36.479]             signalCondition <- base::signalCondition
[13:33:36.479]             sys.calls <- base::sys.calls
[13:33:36.479]             `[[` <- base::`[[`
[13:33:36.479]             `+` <- base::`+`
[13:33:36.479]             `<<-` <- base::`<<-`
[13:33:36.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.479]                   3L)]
[13:33:36.479]             }
[13:33:36.479]             function(cond) {
[13:33:36.479]                 is_error <- inherits(cond, "error")
[13:33:36.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.479]                   NULL)
[13:33:36.479]                 if (is_error) {
[13:33:36.479]                   sessionInformation <- function() {
[13:33:36.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.479]                       search = base::search(), system = base::Sys.info())
[13:33:36.479]                   }
[13:33:36.479]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.479]                     cond$call), session = sessionInformation(), 
[13:33:36.479]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.479]                   signalCondition(cond)
[13:33:36.479]                 }
[13:33:36.479]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[13:33:36.479]                   signal <- TRUE && inherits(cond, character(0))
[13:33:36.479]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.479]                   if (TRUE && !signal) {
[13:33:36.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.479]                     {
[13:33:36.479]                       inherits <- base::inherits
[13:33:36.479]                       invokeRestart <- base::invokeRestart
[13:33:36.479]                       is.null <- base::is.null
[13:33:36.479]                       muffled <- FALSE
[13:33:36.479]                       if (inherits(cond, "message")) {
[13:33:36.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.479]                         if (muffled) 
[13:33:36.479]                           invokeRestart("muffleMessage")
[13:33:36.479]                       }
[13:33:36.479]                       else if (inherits(cond, "warning")) {
[13:33:36.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.479]                         if (muffled) 
[13:33:36.479]                           invokeRestart("muffleWarning")
[13:33:36.479]                       }
[13:33:36.479]                       else if (inherits(cond, "condition")) {
[13:33:36.479]                         if (!is.null(pattern)) {
[13:33:36.479]                           computeRestarts <- base::computeRestarts
[13:33:36.479]                           grepl <- base::grepl
[13:33:36.479]                           restarts <- computeRestarts(cond)
[13:33:36.479]                           for (restart in restarts) {
[13:33:36.479]                             name <- restart$name
[13:33:36.479]                             if (is.null(name)) 
[13:33:36.479]                               next
[13:33:36.479]                             if (!grepl(pattern, name)) 
[13:33:36.479]                               next
[13:33:36.479]                             invokeRestart(restart)
[13:33:36.479]                             muffled <- TRUE
[13:33:36.479]                             break
[13:33:36.479]                           }
[13:33:36.479]                         }
[13:33:36.479]                       }
[13:33:36.479]                       invisible(muffled)
[13:33:36.479]                     }
[13:33:36.479]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.479]                   }
[13:33:36.479]                 }
[13:33:36.479]                 else {
[13:33:36.479]                   if (FALSE) {
[13:33:36.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.479]                     {
[13:33:36.479]                       inherits <- base::inherits
[13:33:36.479]                       invokeRestart <- base::invokeRestart
[13:33:36.479]                       is.null <- base::is.null
[13:33:36.479]                       muffled <- FALSE
[13:33:36.479]                       if (inherits(cond, "message")) {
[13:33:36.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.479]                         if (muffled) 
[13:33:36.479]                           invokeRestart("muffleMessage")
[13:33:36.479]                       }
[13:33:36.479]                       else if (inherits(cond, "warning")) {
[13:33:36.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.479]                         if (muffled) 
[13:33:36.479]                           invokeRestart("muffleWarning")
[13:33:36.479]                       }
[13:33:36.479]                       else if (inherits(cond, "condition")) {
[13:33:36.479]                         if (!is.null(pattern)) {
[13:33:36.479]                           computeRestarts <- base::computeRestarts
[13:33:36.479]                           grepl <- base::grepl
[13:33:36.479]                           restarts <- computeRestarts(cond)
[13:33:36.479]                           for (restart in restarts) {
[13:33:36.479]                             name <- restart$name
[13:33:36.479]                             if (is.null(name)) 
[13:33:36.479]                               next
[13:33:36.479]                             if (!grepl(pattern, name)) 
[13:33:36.479]                               next
[13:33:36.479]                             invokeRestart(restart)
[13:33:36.479]                             muffled <- TRUE
[13:33:36.479]                             break
[13:33:36.479]                           }
[13:33:36.479]                         }
[13:33:36.479]                       }
[13:33:36.479]                       invisible(muffled)
[13:33:36.479]                     }
[13:33:36.479]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.479]                   }
[13:33:36.479]                 }
[13:33:36.479]             }
[13:33:36.479]         }))
[13:33:36.479]     }, error = function(ex) {
[13:33:36.479]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.479]                 ...future.rng), started = ...future.startTime, 
[13:33:36.479]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.479]             version = "1.8"), class = "FutureResult")
[13:33:36.479]     }, finally = {
[13:33:36.479]         if (!identical(...future.workdir, getwd())) 
[13:33:36.479]             setwd(...future.workdir)
[13:33:36.479]         {
[13:33:36.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.479]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.479]             }
[13:33:36.479]             base::options(...future.oldOptions)
[13:33:36.479]             if (.Platform$OS.type == "windows") {
[13:33:36.479]                 old_names <- names(...future.oldEnvVars)
[13:33:36.479]                 envs <- base::Sys.getenv()
[13:33:36.479]                 names <- names(envs)
[13:33:36.479]                 common <- intersect(names, old_names)
[13:33:36.479]                 added <- setdiff(names, old_names)
[13:33:36.479]                 removed <- setdiff(old_names, names)
[13:33:36.479]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.479]                   envs[common]]
[13:33:36.479]                 NAMES <- toupper(changed)
[13:33:36.479]                 args <- list()
[13:33:36.479]                 for (kk in seq_along(NAMES)) {
[13:33:36.479]                   name <- changed[[kk]]
[13:33:36.479]                   NAME <- NAMES[[kk]]
[13:33:36.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.479]                     next
[13:33:36.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.479]                 }
[13:33:36.479]                 NAMES <- toupper(added)
[13:33:36.479]                 for (kk in seq_along(NAMES)) {
[13:33:36.479]                   name <- added[[kk]]
[13:33:36.479]                   NAME <- NAMES[[kk]]
[13:33:36.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.479]                     next
[13:33:36.479]                   args[[name]] <- ""
[13:33:36.479]                 }
[13:33:36.479]                 NAMES <- toupper(removed)
[13:33:36.479]                 for (kk in seq_along(NAMES)) {
[13:33:36.479]                   name <- removed[[kk]]
[13:33:36.479]                   NAME <- NAMES[[kk]]
[13:33:36.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.479]                     next
[13:33:36.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.479]                 }
[13:33:36.479]                 if (length(args) > 0) 
[13:33:36.479]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.479]             }
[13:33:36.479]             else {
[13:33:36.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.479]             }
[13:33:36.479]             {
[13:33:36.479]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.479]                   0L) {
[13:33:36.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.479]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.479]                   base::options(opts)
[13:33:36.479]                 }
[13:33:36.479]                 {
[13:33:36.479]                   {
[13:33:36.479]                     base::assign(".Random.seed", c(10407L, 1101211037L, 
[13:33:36.479]                     923942246L, 429179484L, 298292888L, 105239380L, 
[13:33:36.479]                     -16683833L), envir = base::globalenv(), inherits = FALSE)
[13:33:36.479]                     NULL
[13:33:36.479]                   }
[13:33:36.479]                   options(future.plan = NULL)
[13:33:36.479]                   if (is.na(NA_character_)) 
[13:33:36.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.479]                     .init = FALSE)
[13:33:36.479]                 }
[13:33:36.479]             }
[13:33:36.479]         }
[13:33:36.479]     })
[13:33:36.479]     if (TRUE) {
[13:33:36.479]         base::sink(type = "output", split = FALSE)
[13:33:36.479]         if (TRUE) {
[13:33:36.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.479]         }
[13:33:36.479]         else {
[13:33:36.479]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.479]         }
[13:33:36.479]         base::close(...future.stdout)
[13:33:36.479]         ...future.stdout <- NULL
[13:33:36.479]     }
[13:33:36.479]     ...future.result$conditions <- ...future.conditions
[13:33:36.479]     ...future.result$finished <- base::Sys.time()
[13:33:36.479]     ...future.result
[13:33:36.479] }
[13:33:36.480] assign_globals() ...
[13:33:36.480] List of 5
[13:33:36.480]  $ future.call.arguments    : list()
[13:33:36.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.480]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[13:33:36.480]  $ ...future.elements_ii    :List of 2
[13:33:36.480]   ..$ : int [1:2] 1 3
[13:33:36.480]   ..$ : int [1:2] 2 4
[13:33:36.480]  $ ...future.seeds_ii       :List of 2
[13:33:36.480]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[13:33:36.480]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[13:33:36.480]  $ ...future.globals.maxSize: num Inf
[13:33:36.480]  - attr(*, "resolved")= logi FALSE
[13:33:36.480]  - attr(*, "total_size")= num NA
[13:33:36.480]  - attr(*, "where")=List of 5
[13:33:36.480]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.480]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.480]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.480]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.480]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.480]  - attr(*, "already-done")= logi TRUE
[13:33:36.485] - copied ‘future.call.arguments’ to environment
[13:33:36.486] - copied ‘...future.FUN’ to environment
[13:33:36.486] - copied ‘...future.elements_ii’ to environment
[13:33:36.486] - copied ‘...future.seeds_ii’ to environment
[13:33:36.486] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.486] assign_globals() ... done
[13:33:36.486] plan(): Setting new future strategy stack:
[13:33:36.486] List of future strategies:
[13:33:36.486] 1. sequential:
[13:33:36.486]    - args: function (..., envir = parent.frame())
[13:33:36.486]    - tweaked: FALSE
[13:33:36.486]    - call: NULL
[13:33:36.487] plan(): nbrOfWorkers() = 1
[13:33:36.487] plan(): Setting new future strategy stack:
[13:33:36.487] List of future strategies:
[13:33:36.487] 1. sequential:
[13:33:36.487]    - args: function (..., envir = parent.frame())
[13:33:36.487]    - tweaked: FALSE
[13:33:36.487]    - call: plan(strategy)
[13:33:36.488] plan(): nbrOfWorkers() = 1
[13:33:36.488] SequentialFuture started (and completed)
[13:33:36.488] - Launch lazy future ... done
[13:33:36.488] run() for ‘SequentialFuture’ ... done
[13:33:36.488] Created future:
[13:33:36.488] SequentialFuture:
[13:33:36.488] Label: ‘future_apply-1’
[13:33:36.488] Expression:
[13:33:36.488] {
[13:33:36.488]     do.call(function(...) {
[13:33:36.488]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.488]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.488]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.488]             on.exit(options(oopts), add = TRUE)
[13:33:36.488]         }
[13:33:36.488]         {
[13:33:36.488]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.488]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.488]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:36.488]                   envir = globalenv(), inherits = FALSE)
[13:33:36.488]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.488]             })
[13:33:36.488]         }
[13:33:36.488]     }, args = future.call.arguments)
[13:33:36.488] }
[13:33:36.488] Lazy evaluation: FALSE
[13:33:36.488] Asynchronous evaluation: FALSE
[13:33:36.488] Local evaluation: TRUE
[13:33:36.488] Environment: R_GlobalEnv
[13:33:36.488] Capture standard output: TRUE
[13:33:36.488] Capture condition classes: <none>
[13:33:36.488] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.488] Packages: <none>
[13:33:36.488] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:33:36.488] Resolved: TRUE
[13:33:36.488] Value: 112 bytes of class ‘list’
[13:33:36.488] Early signaling: FALSE
[13:33:36.488] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.488] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:36.489] Chunk #1 of 1 ... DONE
[13:33:36.489] Launching 1 futures (chunks) ... DONE
[13:33:36.489] Resolving 1 futures (chunks) ...
[13:33:36.489] resolve() on list ...
[13:33:36.489]  recursive: 0
[13:33:36.490]  length: 1
[13:33:36.490] 
[13:33:36.490] resolved() for ‘SequentialFuture’ ...
[13:33:36.490] - state: ‘finished’
[13:33:36.490] - run: TRUE
[13:33:36.490] - result: ‘FutureResult’
[13:33:36.490] resolved() for ‘SequentialFuture’ ... done
[13:33:36.490] Future #1
[13:33:36.490] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:36.490] - nx: 1
[13:33:36.490] - relay: TRUE
[13:33:36.491] - stdout: TRUE
[13:33:36.491] - signal: TRUE
[13:33:36.491] - resignal: FALSE
[13:33:36.491] - force: TRUE
[13:33:36.491] - relayed: [n=1] FALSE
[13:33:36.491] - queued futures: [n=1] FALSE
[13:33:36.491]  - until=1
[13:33:36.491]  - relaying element #1
[13:33:36.491] - relayed: [n=1] TRUE
[13:33:36.491] - queued futures: [n=1] TRUE
[13:33:36.491] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:36.492]  length: 0 (resolved future 1)
[13:33:36.492] Relaying remaining futures
[13:33:36.492] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.492] - nx: 1
[13:33:36.492] - relay: TRUE
[13:33:36.492] - stdout: TRUE
[13:33:36.492] - signal: TRUE
[13:33:36.492] - resignal: FALSE
[13:33:36.492] - force: TRUE
[13:33:36.492] - relayed: [n=1] TRUE
[13:33:36.492] - queued futures: [n=1] TRUE
 - flush all
[13:33:36.493] - relayed: [n=1] TRUE
[13:33:36.493] - queued futures: [n=1] TRUE
[13:33:36.493] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.493] resolve() on list ... DONE
[13:33:36.493]  - Number of value chunks collected: 1
[13:33:36.493] Resolving 1 futures (chunks) ... DONE
[13:33:36.493] Reducing values from 1 chunks ...
[13:33:36.493]  - Number of values collected after concatenation: 2
[13:33:36.493]  - Number of values expected: 2
[13:33:36.493] Reducing values from 1 chunks ... DONE
[13:33:36.493] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[13:33:36.494] plan(): Setting new future strategy stack:
[13:33:36.494] List of future strategies:
[13:33:36.494] 1. sequential:
[13:33:36.494]    - args: function (..., envir = parent.frame())
[13:33:36.494]    - tweaked: FALSE
[13:33:36.494]    - call: plan(sequential)
[13:33:36.494] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[13:33:36.494] plan(): Setting new future strategy stack:
[13:33:36.495] List of future strategies:
[13:33:36.495] 1. multicore:
[13:33:36.495]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:36.495]    - tweaked: FALSE
[13:33:36.495]    - call: plan(strategy)
[13:33:36.500] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[13:33:36.500] getGlobalsAndPackagesXApply() ...
[13:33:36.500]  - future.globals: TRUE
[13:33:36.501] getGlobalsAndPackages() ...
[13:33:36.501] Searching for globals...
[13:33:36.532] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:33:36.532] Searching for globals ... DONE
[13:33:36.532] Resolving globals: FALSE
[13:33:36.534] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:33:36.534] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:33:36.535] - globals: [1] ‘FUN’
[13:33:36.535] 
[13:33:36.535] getGlobalsAndPackages() ... DONE
[13:33:36.535]  - globals found/used: [n=1] ‘FUN’
[13:33:36.535]  - needed namespaces: [n=0] 
[13:33:36.535] Finding globals ... DONE
[13:33:36.535]  - use_args: TRUE
[13:33:36.535]  - Getting '...' globals ...
[13:33:36.535] resolve() on list ...
[13:33:36.536]  recursive: 0
[13:33:36.536]  length: 1
[13:33:36.536]  elements: ‘...’
[13:33:36.536]  length: 0 (resolved future 1)
[13:33:36.536] resolve() on list ... DONE
[13:33:36.536]    - '...' content: [n=0] 
[13:33:36.536] List of 1
[13:33:36.536]  $ ...: list()
[13:33:36.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.536]  - attr(*, "where")=List of 1
[13:33:36.536]   ..$ ...:<environment: 0x55b949feaff0> 
[13:33:36.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.536]  - attr(*, "resolved")= logi TRUE
[13:33:36.536]  - attr(*, "total_size")= num NA
[13:33:36.538]  - Getting '...' globals ... DONE
[13:33:36.539] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.539] List of 2
[13:33:36.539]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.539]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.539]  $ ...          : list()
[13:33:36.539]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.539]  - attr(*, "where")=List of 2
[13:33:36.539]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.539]   ..$ ...          :<environment: 0x55b949feaff0> 
[13:33:36.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.539]  - attr(*, "resolved")= logi FALSE
[13:33:36.539]  - attr(*, "total_size")= num 354224
[13:33:36.541] Packages to be attached in all futures: [n=0] 
[13:33:36.541] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.545] future_lapply() ...
[13:33:36.578] Number of chunks: 2
[13:33:36.578] getGlobalsAndPackagesXApply() ...
[13:33:36.578]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.578]  - use_args: TRUE
[13:33:36.578] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.578] List of 2
[13:33:36.578]  $ ...          : list()
[13:33:36.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.578]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.578]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.578]  - attr(*, "where")=List of 2
[13:33:36.578]   ..$ ...          :<environment: 0x55b949feaff0> 
[13:33:36.578]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:36.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.578]  - attr(*, "resolved")= logi FALSE
[13:33:36.578]  - attr(*, "total_size")= num NA
[13:33:36.581] Packages to be attached in all futures: [n=0] 
[13:33:36.581] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.582] Number of futures (= number of chunks): 2
[13:33:36.582] Launching 2 futures (chunks) ...
[13:33:36.582] Chunk #1 of 2 ...
[13:33:36.582]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:36.582]  - seeds: <none>
[13:33:36.582]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.582] getGlobalsAndPackages() ...
[13:33:36.582] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.583] Resolving globals: FALSE
[13:33:36.583] Tweak future expression to call with '...' arguments ...
[13:33:36.583] {
[13:33:36.583]     do.call(function(...) {
[13:33:36.583]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.583]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.583]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.583]             on.exit(options(oopts), add = TRUE)
[13:33:36.583]         }
[13:33:36.583]         {
[13:33:36.583]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.583]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.583]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.583]             })
[13:33:36.583]         }
[13:33:36.583]     }, args = future.call.arguments)
[13:33:36.583] }
[13:33:36.583] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.583] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.583] 
[13:33:36.584] getGlobalsAndPackages() ... DONE
[13:33:36.584] run() for ‘Future’ ...
[13:33:36.584] - state: ‘created’
[13:33:36.584] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:36.588] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:36.588]   - Field: ‘label’
[13:33:36.588]   - Field: ‘local’
[13:33:36.588]   - Field: ‘owner’
[13:33:36.588]   - Field: ‘envir’
[13:33:36.588]   - Field: ‘workers’
[13:33:36.588]   - Field: ‘packages’
[13:33:36.588]   - Field: ‘gc’
[13:33:36.588]   - Field: ‘job’
[13:33:36.589]   - Field: ‘conditions’
[13:33:36.589]   - Field: ‘expr’
[13:33:36.589]   - Field: ‘uuid’
[13:33:36.589]   - Field: ‘seed’
[13:33:36.589]   - Field: ‘version’
[13:33:36.589]   - Field: ‘result’
[13:33:36.589]   - Field: ‘asynchronous’
[13:33:36.589]   - Field: ‘calls’
[13:33:36.589]   - Field: ‘globals’
[13:33:36.589]   - Field: ‘stdout’
[13:33:36.589]   - Field: ‘earlySignal’
[13:33:36.589]   - Field: ‘lazy’
[13:33:36.590]   - Field: ‘state’
[13:33:36.590] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:36.590] - Launch lazy future ...
[13:33:36.591] Packages needed by the future expression (n = 0): <none>
[13:33:36.591] Packages needed by future strategies (n = 0): <none>
[13:33:36.591] {
[13:33:36.591]     {
[13:33:36.591]         {
[13:33:36.591]             ...future.startTime <- base::Sys.time()
[13:33:36.591]             {
[13:33:36.591]                 {
[13:33:36.591]                   {
[13:33:36.591]                     {
[13:33:36.591]                       base::local({
[13:33:36.591]                         has_future <- base::requireNamespace("future", 
[13:33:36.591]                           quietly = TRUE)
[13:33:36.591]                         if (has_future) {
[13:33:36.591]                           ns <- base::getNamespace("future")
[13:33:36.591]                           version <- ns[[".package"]][["version"]]
[13:33:36.591]                           if (is.null(version)) 
[13:33:36.591]                             version <- utils::packageVersion("future")
[13:33:36.591]                         }
[13:33:36.591]                         else {
[13:33:36.591]                           version <- NULL
[13:33:36.591]                         }
[13:33:36.591]                         if (!has_future || version < "1.8.0") {
[13:33:36.591]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.591]                             "", base::R.version$version.string), 
[13:33:36.591]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:36.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.591]                               "release", "version")], collapse = " "), 
[13:33:36.591]                             hostname = base::Sys.info()[["nodename"]])
[13:33:36.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.591]                             info)
[13:33:36.591]                           info <- base::paste(info, collapse = "; ")
[13:33:36.591]                           if (!has_future) {
[13:33:36.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.591]                               info)
[13:33:36.591]                           }
[13:33:36.591]                           else {
[13:33:36.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.591]                               info, version)
[13:33:36.591]                           }
[13:33:36.591]                           base::stop(msg)
[13:33:36.591]                         }
[13:33:36.591]                       })
[13:33:36.591]                     }
[13:33:36.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:36.591]                     base::options(mc.cores = 1L)
[13:33:36.591]                   }
[13:33:36.591]                   ...future.strategy.old <- future::plan("list")
[13:33:36.591]                   options(future.plan = NULL)
[13:33:36.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.591]                 }
[13:33:36.591]                 ...future.workdir <- getwd()
[13:33:36.591]             }
[13:33:36.591]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.591]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.591]         }
[13:33:36.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.591]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.591]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.591]             base::names(...future.oldOptions))
[13:33:36.591]     }
[13:33:36.591]     if (FALSE) {
[13:33:36.591]     }
[13:33:36.591]     else {
[13:33:36.591]         if (TRUE) {
[13:33:36.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.591]                 open = "w")
[13:33:36.591]         }
[13:33:36.591]         else {
[13:33:36.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.591]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.591]         }
[13:33:36.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.591]             base::sink(type = "output", split = FALSE)
[13:33:36.591]             base::close(...future.stdout)
[13:33:36.591]         }, add = TRUE)
[13:33:36.591]     }
[13:33:36.591]     ...future.frame <- base::sys.nframe()
[13:33:36.591]     ...future.conditions <- base::list()
[13:33:36.591]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.591]     if (FALSE) {
[13:33:36.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.591]     }
[13:33:36.591]     ...future.result <- base::tryCatch({
[13:33:36.591]         base::withCallingHandlers({
[13:33:36.591]             ...future.value <- base::withVisible(base::local({
[13:33:36.591]                 withCallingHandlers({
[13:33:36.591]                   {
[13:33:36.591]                     do.call(function(...) {
[13:33:36.591]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.591]                       if (!identical(...future.globals.maxSize.org, 
[13:33:36.591]                         ...future.globals.maxSize)) {
[13:33:36.591]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.591]                         on.exit(options(oopts), add = TRUE)
[13:33:36.591]                       }
[13:33:36.591]                       {
[13:33:36.591]                         lapply(seq_along(...future.elements_ii), 
[13:33:36.591]                           FUN = function(jj) {
[13:33:36.591]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.591]                             ...future.FUN(...future.X_jj, ...)
[13:33:36.591]                           })
[13:33:36.591]                       }
[13:33:36.591]                     }, args = future.call.arguments)
[13:33:36.591]                   }
[13:33:36.591]                 }, immediateCondition = function(cond) {
[13:33:36.591]                   save_rds <- function (object, pathname, ...) 
[13:33:36.591]                   {
[13:33:36.591]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:36.591]                     if (file_test("-f", pathname_tmp)) {
[13:33:36.591]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.591]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:36.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.591]                         fi_tmp[["mtime"]])
[13:33:36.591]                     }
[13:33:36.591]                     tryCatch({
[13:33:36.591]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:36.591]                     }, error = function(ex) {
[13:33:36.591]                       msg <- conditionMessage(ex)
[13:33:36.591]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.591]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:36.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.591]                         fi_tmp[["mtime"]], msg)
[13:33:36.591]                       ex$message <- msg
[13:33:36.591]                       stop(ex)
[13:33:36.591]                     })
[13:33:36.591]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:36.591]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:36.591]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:36.591]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.591]                       fi <- file.info(pathname)
[13:33:36.591]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:36.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.591]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:36.591]                         fi[["size"]], fi[["mtime"]])
[13:33:36.591]                       stop(msg)
[13:33:36.591]                     }
[13:33:36.591]                     invisible(pathname)
[13:33:36.591]                   }
[13:33:36.591]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:36.591]                     rootPath = tempdir()) 
[13:33:36.591]                   {
[13:33:36.591]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:36.591]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:36.591]                       tmpdir = path, fileext = ".rds")
[13:33:36.591]                     save_rds(obj, file)
[13:33:36.591]                   }
[13:33:36.591]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:36.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.591]                   {
[13:33:36.591]                     inherits <- base::inherits
[13:33:36.591]                     invokeRestart <- base::invokeRestart
[13:33:36.591]                     is.null <- base::is.null
[13:33:36.591]                     muffled <- FALSE
[13:33:36.591]                     if (inherits(cond, "message")) {
[13:33:36.591]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:36.591]                       if (muffled) 
[13:33:36.591]                         invokeRestart("muffleMessage")
[13:33:36.591]                     }
[13:33:36.591]                     else if (inherits(cond, "warning")) {
[13:33:36.591]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:36.591]                       if (muffled) 
[13:33:36.591]                         invokeRestart("muffleWarning")
[13:33:36.591]                     }
[13:33:36.591]                     else if (inherits(cond, "condition")) {
[13:33:36.591]                       if (!is.null(pattern)) {
[13:33:36.591]                         computeRestarts <- base::computeRestarts
[13:33:36.591]                         grepl <- base::grepl
[13:33:36.591]                         restarts <- computeRestarts(cond)
[13:33:36.591]                         for (restart in restarts) {
[13:33:36.591]                           name <- restart$name
[13:33:36.591]                           if (is.null(name)) 
[13:33:36.591]                             next
[13:33:36.591]                           if (!grepl(pattern, name)) 
[13:33:36.591]                             next
[13:33:36.591]                           invokeRestart(restart)
[13:33:36.591]                           muffled <- TRUE
[13:33:36.591]                           break
[13:33:36.591]                         }
[13:33:36.591]                       }
[13:33:36.591]                     }
[13:33:36.591]                     invisible(muffled)
[13:33:36.591]                   }
[13:33:36.591]                   muffleCondition(cond)
[13:33:36.591]                 })
[13:33:36.591]             }))
[13:33:36.591]             future::FutureResult(value = ...future.value$value, 
[13:33:36.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.591]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.591]                     ...future.globalenv.names))
[13:33:36.591]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.591]         }, condition = base::local({
[13:33:36.591]             c <- base::c
[13:33:36.591]             inherits <- base::inherits
[13:33:36.591]             invokeRestart <- base::invokeRestart
[13:33:36.591]             length <- base::length
[13:33:36.591]             list <- base::list
[13:33:36.591]             seq.int <- base::seq.int
[13:33:36.591]             signalCondition <- base::signalCondition
[13:33:36.591]             sys.calls <- base::sys.calls
[13:33:36.591]             `[[` <- base::`[[`
[13:33:36.591]             `+` <- base::`+`
[13:33:36.591]             `<<-` <- base::`<<-`
[13:33:36.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.591]                   3L)]
[13:33:36.591]             }
[13:33:36.591]             function(cond) {
[13:33:36.591]                 is_error <- inherits(cond, "error")
[13:33:36.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.591]                   NULL)
[13:33:36.591]                 if (is_error) {
[13:33:36.591]                   sessionInformation <- function() {
[13:33:36.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.591]                       search = base::search(), system = base::Sys.info())
[13:33:36.591]                   }
[13:33:36.591]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.591]                     cond$call), session = sessionInformation(), 
[13:33:36.591]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.591]                   signalCondition(cond)
[13:33:36.591]                 }
[13:33:36.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.591]                 "immediateCondition"))) {
[13:33:36.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.591]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.591]                   if (TRUE && !signal) {
[13:33:36.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.591]                     {
[13:33:36.591]                       inherits <- base::inherits
[13:33:36.591]                       invokeRestart <- base::invokeRestart
[13:33:36.591]                       is.null <- base::is.null
[13:33:36.591]                       muffled <- FALSE
[13:33:36.591]                       if (inherits(cond, "message")) {
[13:33:36.591]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.591]                         if (muffled) 
[13:33:36.591]                           invokeRestart("muffleMessage")
[13:33:36.591]                       }
[13:33:36.591]                       else if (inherits(cond, "warning")) {
[13:33:36.591]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.591]                         if (muffled) 
[13:33:36.591]                           invokeRestart("muffleWarning")
[13:33:36.591]                       }
[13:33:36.591]                       else if (inherits(cond, "condition")) {
[13:33:36.591]                         if (!is.null(pattern)) {
[13:33:36.591]                           computeRestarts <- base::computeRestarts
[13:33:36.591]                           grepl <- base::grepl
[13:33:36.591]                           restarts <- computeRestarts(cond)
[13:33:36.591]                           for (restart in restarts) {
[13:33:36.591]                             name <- restart$name
[13:33:36.591]                             if (is.null(name)) 
[13:33:36.591]                               next
[13:33:36.591]                             if (!grepl(pattern, name)) 
[13:33:36.591]                               next
[13:33:36.591]                             invokeRestart(restart)
[13:33:36.591]                             muffled <- TRUE
[13:33:36.591]                             break
[13:33:36.591]                           }
[13:33:36.591]                         }
[13:33:36.591]                       }
[13:33:36.591]                       invisible(muffled)
[13:33:36.591]                     }
[13:33:36.591]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.591]                   }
[13:33:36.591]                 }
[13:33:36.591]                 else {
[13:33:36.591]                   if (TRUE) {
[13:33:36.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.591]                     {
[13:33:36.591]                       inherits <- base::inherits
[13:33:36.591]                       invokeRestart <- base::invokeRestart
[13:33:36.591]                       is.null <- base::is.null
[13:33:36.591]                       muffled <- FALSE
[13:33:36.591]                       if (inherits(cond, "message")) {
[13:33:36.591]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.591]                         if (muffled) 
[13:33:36.591]                           invokeRestart("muffleMessage")
[13:33:36.591]                       }
[13:33:36.591]                       else if (inherits(cond, "warning")) {
[13:33:36.591]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.591]                         if (muffled) 
[13:33:36.591]                           invokeRestart("muffleWarning")
[13:33:36.591]                       }
[13:33:36.591]                       else if (inherits(cond, "condition")) {
[13:33:36.591]                         if (!is.null(pattern)) {
[13:33:36.591]                           computeRestarts <- base::computeRestarts
[13:33:36.591]                           grepl <- base::grepl
[13:33:36.591]                           restarts <- computeRestarts(cond)
[13:33:36.591]                           for (restart in restarts) {
[13:33:36.591]                             name <- restart$name
[13:33:36.591]                             if (is.null(name)) 
[13:33:36.591]                               next
[13:33:36.591]                             if (!grepl(pattern, name)) 
[13:33:36.591]                               next
[13:33:36.591]                             invokeRestart(restart)
[13:33:36.591]                             muffled <- TRUE
[13:33:36.591]                             break
[13:33:36.591]                           }
[13:33:36.591]                         }
[13:33:36.591]                       }
[13:33:36.591]                       invisible(muffled)
[13:33:36.591]                     }
[13:33:36.591]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.591]                   }
[13:33:36.591]                 }
[13:33:36.591]             }
[13:33:36.591]         }))
[13:33:36.591]     }, error = function(ex) {
[13:33:36.591]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.591]                 ...future.rng), started = ...future.startTime, 
[13:33:36.591]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.591]             version = "1.8"), class = "FutureResult")
[13:33:36.591]     }, finally = {
[13:33:36.591]         if (!identical(...future.workdir, getwd())) 
[13:33:36.591]             setwd(...future.workdir)
[13:33:36.591]         {
[13:33:36.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.591]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.591]             }
[13:33:36.591]             base::options(...future.oldOptions)
[13:33:36.591]             if (.Platform$OS.type == "windows") {
[13:33:36.591]                 old_names <- names(...future.oldEnvVars)
[13:33:36.591]                 envs <- base::Sys.getenv()
[13:33:36.591]                 names <- names(envs)
[13:33:36.591]                 common <- intersect(names, old_names)
[13:33:36.591]                 added <- setdiff(names, old_names)
[13:33:36.591]                 removed <- setdiff(old_names, names)
[13:33:36.591]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.591]                   envs[common]]
[13:33:36.591]                 NAMES <- toupper(changed)
[13:33:36.591]                 args <- list()
[13:33:36.591]                 for (kk in seq_along(NAMES)) {
[13:33:36.591]                   name <- changed[[kk]]
[13:33:36.591]                   NAME <- NAMES[[kk]]
[13:33:36.591]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.591]                     next
[13:33:36.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.591]                 }
[13:33:36.591]                 NAMES <- toupper(added)
[13:33:36.591]                 for (kk in seq_along(NAMES)) {
[13:33:36.591]                   name <- added[[kk]]
[13:33:36.591]                   NAME <- NAMES[[kk]]
[13:33:36.591]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.591]                     next
[13:33:36.591]                   args[[name]] <- ""
[13:33:36.591]                 }
[13:33:36.591]                 NAMES <- toupper(removed)
[13:33:36.591]                 for (kk in seq_along(NAMES)) {
[13:33:36.591]                   name <- removed[[kk]]
[13:33:36.591]                   NAME <- NAMES[[kk]]
[13:33:36.591]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.591]                     next
[13:33:36.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.591]                 }
[13:33:36.591]                 if (length(args) > 0) 
[13:33:36.591]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.591]             }
[13:33:36.591]             else {
[13:33:36.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.591]             }
[13:33:36.591]             {
[13:33:36.591]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.591]                   0L) {
[13:33:36.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.591]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.591]                   base::options(opts)
[13:33:36.591]                 }
[13:33:36.591]                 {
[13:33:36.591]                   {
[13:33:36.591]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:36.591]                     NULL
[13:33:36.591]                   }
[13:33:36.591]                   options(future.plan = NULL)
[13:33:36.591]                   if (is.na(NA_character_)) 
[13:33:36.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.591]                     .init = FALSE)
[13:33:36.591]                 }
[13:33:36.591]             }
[13:33:36.591]         }
[13:33:36.591]     })
[13:33:36.591]     if (TRUE) {
[13:33:36.591]         base::sink(type = "output", split = FALSE)
[13:33:36.591]         if (TRUE) {
[13:33:36.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.591]         }
[13:33:36.591]         else {
[13:33:36.591]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.591]         }
[13:33:36.591]         base::close(...future.stdout)
[13:33:36.591]         ...future.stdout <- NULL
[13:33:36.591]     }
[13:33:36.591]     ...future.result$conditions <- ...future.conditions
[13:33:36.591]     ...future.result$finished <- base::Sys.time()
[13:33:36.591]     ...future.result
[13:33:36.591] }
[13:33:36.594] assign_globals() ...
[13:33:36.594] List of 5
[13:33:36.594]  $ future.call.arguments    : list()
[13:33:36.594]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.594]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.594]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.594]  $ ...future.elements_ii    :List of 1
[13:33:36.594]   ..$ : num [1:4] 1 3 1 7
[13:33:36.594]  $ ...future.seeds_ii       : NULL
[13:33:36.594]  $ ...future.globals.maxSize: num Inf
[13:33:36.594]  - attr(*, "resolved")= logi FALSE
[13:33:36.594]  - attr(*, "total_size")= num NA
[13:33:36.594]  - attr(*, "where")=List of 5
[13:33:36.594]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.594]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.594]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.594]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.594]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.594]  - attr(*, "already-done")= logi TRUE
[13:33:36.600] - copied ‘future.call.arguments’ to environment
[13:33:36.600] - copied ‘...future.FUN’ to environment
[13:33:36.600] - copied ‘...future.elements_ii’ to environment
[13:33:36.600] - copied ‘...future.seeds_ii’ to environment
[13:33:36.600] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.600] assign_globals() ... done
[13:33:36.601] requestCore(): workers = 2
[13:33:36.604] MulticoreFuture started
[13:33:36.604] - Launch lazy future ... done
[13:33:36.605] plan(): Setting new future strategy stack:
[13:33:36.605] run() for ‘MulticoreFuture’ ... done
[13:33:36.605] Created future:
[13:33:36.605] List of future strategies:
[13:33:36.605] 1. sequential:
[13:33:36.605]    - args: function (..., envir = parent.frame())
[13:33:36.605]    - tweaked: FALSE
[13:33:36.605]    - call: NULL
[13:33:36.606] plan(): nbrOfWorkers() = 1
[13:33:36.608] plan(): Setting new future strategy stack:
[13:33:36.608] List of future strategies:
[13:33:36.608] 1. multicore:
[13:33:36.608]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:36.608]    - tweaked: FALSE
[13:33:36.608]    - call: plan(strategy)
[13:33:36.613] plan(): nbrOfWorkers() = 2
[13:33:36.605] MulticoreFuture:
[13:33:36.605] Label: ‘future_apply-1’
[13:33:36.605] Expression:
[13:33:36.605] {
[13:33:36.605]     do.call(function(...) {
[13:33:36.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.605]             on.exit(options(oopts), add = TRUE)
[13:33:36.605]         }
[13:33:36.605]         {
[13:33:36.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.605]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.605]             })
[13:33:36.605]         }
[13:33:36.605]     }, args = future.call.arguments)
[13:33:36.605] }
[13:33:36.605] Lazy evaluation: FALSE
[13:33:36.605] Asynchronous evaluation: TRUE
[13:33:36.605] Local evaluation: TRUE
[13:33:36.605] Environment: R_GlobalEnv
[13:33:36.605] Capture standard output: TRUE
[13:33:36.605] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.605] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.605] Packages: <none>
[13:33:36.605] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.605] Resolved: TRUE
[13:33:36.605] Value: <not collected>
[13:33:36.605] Conditions captured: <none>
[13:33:36.605] Early signaling: FALSE
[13:33:36.605] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.605] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.615] Chunk #1 of 2 ... DONE
[13:33:36.615] Chunk #2 of 2 ...
[13:33:36.615]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:36.615]  - seeds: <none>
[13:33:36.615]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.615] getGlobalsAndPackages() ...
[13:33:36.616] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.616] Resolving globals: FALSE
[13:33:36.616] Tweak future expression to call with '...' arguments ...
[13:33:36.616] {
[13:33:36.616]     do.call(function(...) {
[13:33:36.616]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.616]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.616]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.616]             on.exit(options(oopts), add = TRUE)
[13:33:36.616]         }
[13:33:36.616]         {
[13:33:36.616]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.616]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.616]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.616]             })
[13:33:36.616]         }
[13:33:36.616]     }, args = future.call.arguments)
[13:33:36.616] }
[13:33:36.617] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.617] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.617] 
[13:33:36.618] getGlobalsAndPackages() ... DONE
[13:33:36.618] run() for ‘Future’ ...
[13:33:36.618] - state: ‘created’
[13:33:36.619] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:36.623] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.623] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:36.623]   - Field: ‘label’
[13:33:36.624]   - Field: ‘local’
[13:33:36.624]   - Field: ‘owner’
[13:33:36.624]   - Field: ‘envir’
[13:33:36.624]   - Field: ‘workers’
[13:33:36.624]   - Field: ‘packages’
[13:33:36.624]   - Field: ‘gc’
[13:33:36.625]   - Field: ‘job’
[13:33:36.625]   - Field: ‘conditions’
[13:33:36.625]   - Field: ‘expr’
[13:33:36.625]   - Field: ‘uuid’
[13:33:36.625]   - Field: ‘seed’
[13:33:36.625]   - Field: ‘version’
[13:33:36.626]   - Field: ‘result’
[13:33:36.626]   - Field: ‘asynchronous’
[13:33:36.626]   - Field: ‘calls’
[13:33:36.626]   - Field: ‘globals’
[13:33:36.626]   - Field: ‘stdout’
[13:33:36.626]   - Field: ‘earlySignal’
[13:33:36.626]   - Field: ‘lazy’
[13:33:36.627]   - Field: ‘state’
[13:33:36.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:36.627] - Launch lazy future ...
[13:33:36.627] Packages needed by the future expression (n = 0): <none>
[13:33:36.627] Packages needed by future strategies (n = 0): <none>
[13:33:36.628] {
[13:33:36.628]     {
[13:33:36.628]         {
[13:33:36.628]             ...future.startTime <- base::Sys.time()
[13:33:36.628]             {
[13:33:36.628]                 {
[13:33:36.628]                   {
[13:33:36.628]                     {
[13:33:36.628]                       base::local({
[13:33:36.628]                         has_future <- base::requireNamespace("future", 
[13:33:36.628]                           quietly = TRUE)
[13:33:36.628]                         if (has_future) {
[13:33:36.628]                           ns <- base::getNamespace("future")
[13:33:36.628]                           version <- ns[[".package"]][["version"]]
[13:33:36.628]                           if (is.null(version)) 
[13:33:36.628]                             version <- utils::packageVersion("future")
[13:33:36.628]                         }
[13:33:36.628]                         else {
[13:33:36.628]                           version <- NULL
[13:33:36.628]                         }
[13:33:36.628]                         if (!has_future || version < "1.8.0") {
[13:33:36.628]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.628]                             "", base::R.version$version.string), 
[13:33:36.628]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:36.628]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.628]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.628]                               "release", "version")], collapse = " "), 
[13:33:36.628]                             hostname = base::Sys.info()[["nodename"]])
[13:33:36.628]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.628]                             info)
[13:33:36.628]                           info <- base::paste(info, collapse = "; ")
[13:33:36.628]                           if (!has_future) {
[13:33:36.628]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.628]                               info)
[13:33:36.628]                           }
[13:33:36.628]                           else {
[13:33:36.628]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.628]                               info, version)
[13:33:36.628]                           }
[13:33:36.628]                           base::stop(msg)
[13:33:36.628]                         }
[13:33:36.628]                       })
[13:33:36.628]                     }
[13:33:36.628]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:36.628]                     base::options(mc.cores = 1L)
[13:33:36.628]                   }
[13:33:36.628]                   ...future.strategy.old <- future::plan("list")
[13:33:36.628]                   options(future.plan = NULL)
[13:33:36.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.628]                 }
[13:33:36.628]                 ...future.workdir <- getwd()
[13:33:36.628]             }
[13:33:36.628]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.628]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.628]         }
[13:33:36.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.628]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.628]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.628]             base::names(...future.oldOptions))
[13:33:36.628]     }
[13:33:36.628]     if (FALSE) {
[13:33:36.628]     }
[13:33:36.628]     else {
[13:33:36.628]         if (TRUE) {
[13:33:36.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.628]                 open = "w")
[13:33:36.628]         }
[13:33:36.628]         else {
[13:33:36.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.628]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.628]         }
[13:33:36.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.628]             base::sink(type = "output", split = FALSE)
[13:33:36.628]             base::close(...future.stdout)
[13:33:36.628]         }, add = TRUE)
[13:33:36.628]     }
[13:33:36.628]     ...future.frame <- base::sys.nframe()
[13:33:36.628]     ...future.conditions <- base::list()
[13:33:36.628]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.628]     if (FALSE) {
[13:33:36.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.628]     }
[13:33:36.628]     ...future.result <- base::tryCatch({
[13:33:36.628]         base::withCallingHandlers({
[13:33:36.628]             ...future.value <- base::withVisible(base::local({
[13:33:36.628]                 withCallingHandlers({
[13:33:36.628]                   {
[13:33:36.628]                     do.call(function(...) {
[13:33:36.628]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.628]                       if (!identical(...future.globals.maxSize.org, 
[13:33:36.628]                         ...future.globals.maxSize)) {
[13:33:36.628]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.628]                         on.exit(options(oopts), add = TRUE)
[13:33:36.628]                       }
[13:33:36.628]                       {
[13:33:36.628]                         lapply(seq_along(...future.elements_ii), 
[13:33:36.628]                           FUN = function(jj) {
[13:33:36.628]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.628]                             ...future.FUN(...future.X_jj, ...)
[13:33:36.628]                           })
[13:33:36.628]                       }
[13:33:36.628]                     }, args = future.call.arguments)
[13:33:36.628]                   }
[13:33:36.628]                 }, immediateCondition = function(cond) {
[13:33:36.628]                   save_rds <- function (object, pathname, ...) 
[13:33:36.628]                   {
[13:33:36.628]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:36.628]                     if (file_test("-f", pathname_tmp)) {
[13:33:36.628]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.628]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:36.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.628]                         fi_tmp[["mtime"]])
[13:33:36.628]                     }
[13:33:36.628]                     tryCatch({
[13:33:36.628]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:36.628]                     }, error = function(ex) {
[13:33:36.628]                       msg <- conditionMessage(ex)
[13:33:36.628]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.628]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:36.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.628]                         fi_tmp[["mtime"]], msg)
[13:33:36.628]                       ex$message <- msg
[13:33:36.628]                       stop(ex)
[13:33:36.628]                     })
[13:33:36.628]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:36.628]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:36.628]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:36.628]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.628]                       fi <- file.info(pathname)
[13:33:36.628]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:36.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.628]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:36.628]                         fi[["size"]], fi[["mtime"]])
[13:33:36.628]                       stop(msg)
[13:33:36.628]                     }
[13:33:36.628]                     invisible(pathname)
[13:33:36.628]                   }
[13:33:36.628]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:36.628]                     rootPath = tempdir()) 
[13:33:36.628]                   {
[13:33:36.628]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:36.628]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:36.628]                       tmpdir = path, fileext = ".rds")
[13:33:36.628]                     save_rds(obj, file)
[13:33:36.628]                   }
[13:33:36.628]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:36.628]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.628]                   {
[13:33:36.628]                     inherits <- base::inherits
[13:33:36.628]                     invokeRestart <- base::invokeRestart
[13:33:36.628]                     is.null <- base::is.null
[13:33:36.628]                     muffled <- FALSE
[13:33:36.628]                     if (inherits(cond, "message")) {
[13:33:36.628]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:36.628]                       if (muffled) 
[13:33:36.628]                         invokeRestart("muffleMessage")
[13:33:36.628]                     }
[13:33:36.628]                     else if (inherits(cond, "warning")) {
[13:33:36.628]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:36.628]                       if (muffled) 
[13:33:36.628]                         invokeRestart("muffleWarning")
[13:33:36.628]                     }
[13:33:36.628]                     else if (inherits(cond, "condition")) {
[13:33:36.628]                       if (!is.null(pattern)) {
[13:33:36.628]                         computeRestarts <- base::computeRestarts
[13:33:36.628]                         grepl <- base::grepl
[13:33:36.628]                         restarts <- computeRestarts(cond)
[13:33:36.628]                         for (restart in restarts) {
[13:33:36.628]                           name <- restart$name
[13:33:36.628]                           if (is.null(name)) 
[13:33:36.628]                             next
[13:33:36.628]                           if (!grepl(pattern, name)) 
[13:33:36.628]                             next
[13:33:36.628]                           invokeRestart(restart)
[13:33:36.628]                           muffled <- TRUE
[13:33:36.628]                           break
[13:33:36.628]                         }
[13:33:36.628]                       }
[13:33:36.628]                     }
[13:33:36.628]                     invisible(muffled)
[13:33:36.628]                   }
[13:33:36.628]                   muffleCondition(cond)
[13:33:36.628]                 })
[13:33:36.628]             }))
[13:33:36.628]             future::FutureResult(value = ...future.value$value, 
[13:33:36.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.628]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.628]                     ...future.globalenv.names))
[13:33:36.628]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.628]         }, condition = base::local({
[13:33:36.628]             c <- base::c
[13:33:36.628]             inherits <- base::inherits
[13:33:36.628]             invokeRestart <- base::invokeRestart
[13:33:36.628]             length <- base::length
[13:33:36.628]             list <- base::list
[13:33:36.628]             seq.int <- base::seq.int
[13:33:36.628]             signalCondition <- base::signalCondition
[13:33:36.628]             sys.calls <- base::sys.calls
[13:33:36.628]             `[[` <- base::`[[`
[13:33:36.628]             `+` <- base::`+`
[13:33:36.628]             `<<-` <- base::`<<-`
[13:33:36.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.628]                   3L)]
[13:33:36.628]             }
[13:33:36.628]             function(cond) {
[13:33:36.628]                 is_error <- inherits(cond, "error")
[13:33:36.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.628]                   NULL)
[13:33:36.628]                 if (is_error) {
[13:33:36.628]                   sessionInformation <- function() {
[13:33:36.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.628]                       search = base::search(), system = base::Sys.info())
[13:33:36.628]                   }
[13:33:36.628]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.628]                     cond$call), session = sessionInformation(), 
[13:33:36.628]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.628]                   signalCondition(cond)
[13:33:36.628]                 }
[13:33:36.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.628]                 "immediateCondition"))) {
[13:33:36.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.628]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.628]                   if (TRUE && !signal) {
[13:33:36.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.628]                     {
[13:33:36.628]                       inherits <- base::inherits
[13:33:36.628]                       invokeRestart <- base::invokeRestart
[13:33:36.628]                       is.null <- base::is.null
[13:33:36.628]                       muffled <- FALSE
[13:33:36.628]                       if (inherits(cond, "message")) {
[13:33:36.628]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.628]                         if (muffled) 
[13:33:36.628]                           invokeRestart("muffleMessage")
[13:33:36.628]                       }
[13:33:36.628]                       else if (inherits(cond, "warning")) {
[13:33:36.628]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.628]                         if (muffled) 
[13:33:36.628]                           invokeRestart("muffleWarning")
[13:33:36.628]                       }
[13:33:36.628]                       else if (inherits(cond, "condition")) {
[13:33:36.628]                         if (!is.null(pattern)) {
[13:33:36.628]                           computeRestarts <- base::computeRestarts
[13:33:36.628]                           grepl <- base::grepl
[13:33:36.628]                           restarts <- computeRestarts(cond)
[13:33:36.628]                           for (restart in restarts) {
[13:33:36.628]                             name <- restart$name
[13:33:36.628]                             if (is.null(name)) 
[13:33:36.628]                               next
[13:33:36.628]                             if (!grepl(pattern, name)) 
[13:33:36.628]                               next
[13:33:36.628]                             invokeRestart(restart)
[13:33:36.628]                             muffled <- TRUE
[13:33:36.628]                             break
[13:33:36.628]                           }
[13:33:36.628]                         }
[13:33:36.628]                       }
[13:33:36.628]                       invisible(muffled)
[13:33:36.628]                     }
[13:33:36.628]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.628]                   }
[13:33:36.628]                 }
[13:33:36.628]                 else {
[13:33:36.628]                   if (TRUE) {
[13:33:36.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.628]                     {
[13:33:36.628]                       inherits <- base::inherits
[13:33:36.628]                       invokeRestart <- base::invokeRestart
[13:33:36.628]                       is.null <- base::is.null
[13:33:36.628]                       muffled <- FALSE
[13:33:36.628]                       if (inherits(cond, "message")) {
[13:33:36.628]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.628]                         if (muffled) 
[13:33:36.628]                           invokeRestart("muffleMessage")
[13:33:36.628]                       }
[13:33:36.628]                       else if (inherits(cond, "warning")) {
[13:33:36.628]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.628]                         if (muffled) 
[13:33:36.628]                           invokeRestart("muffleWarning")
[13:33:36.628]                       }
[13:33:36.628]                       else if (inherits(cond, "condition")) {
[13:33:36.628]                         if (!is.null(pattern)) {
[13:33:36.628]                           computeRestarts <- base::computeRestarts
[13:33:36.628]                           grepl <- base::grepl
[13:33:36.628]                           restarts <- computeRestarts(cond)
[13:33:36.628]                           for (restart in restarts) {
[13:33:36.628]                             name <- restart$name
[13:33:36.628]                             if (is.null(name)) 
[13:33:36.628]                               next
[13:33:36.628]                             if (!grepl(pattern, name)) 
[13:33:36.628]                               next
[13:33:36.628]                             invokeRestart(restart)
[13:33:36.628]                             muffled <- TRUE
[13:33:36.628]                             break
[13:33:36.628]                           }
[13:33:36.628]                         }
[13:33:36.628]                       }
[13:33:36.628]                       invisible(muffled)
[13:33:36.628]                     }
[13:33:36.628]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.628]                   }
[13:33:36.628]                 }
[13:33:36.628]             }
[13:33:36.628]         }))
[13:33:36.628]     }, error = function(ex) {
[13:33:36.628]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.628]                 ...future.rng), started = ...future.startTime, 
[13:33:36.628]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.628]             version = "1.8"), class = "FutureResult")
[13:33:36.628]     }, finally = {
[13:33:36.628]         if (!identical(...future.workdir, getwd())) 
[13:33:36.628]             setwd(...future.workdir)
[13:33:36.628]         {
[13:33:36.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.628]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.628]             }
[13:33:36.628]             base::options(...future.oldOptions)
[13:33:36.628]             if (.Platform$OS.type == "windows") {
[13:33:36.628]                 old_names <- names(...future.oldEnvVars)
[13:33:36.628]                 envs <- base::Sys.getenv()
[13:33:36.628]                 names <- names(envs)
[13:33:36.628]                 common <- intersect(names, old_names)
[13:33:36.628]                 added <- setdiff(names, old_names)
[13:33:36.628]                 removed <- setdiff(old_names, names)
[13:33:36.628]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.628]                   envs[common]]
[13:33:36.628]                 NAMES <- toupper(changed)
[13:33:36.628]                 args <- list()
[13:33:36.628]                 for (kk in seq_along(NAMES)) {
[13:33:36.628]                   name <- changed[[kk]]
[13:33:36.628]                   NAME <- NAMES[[kk]]
[13:33:36.628]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.628]                     next
[13:33:36.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.628]                 }
[13:33:36.628]                 NAMES <- toupper(added)
[13:33:36.628]                 for (kk in seq_along(NAMES)) {
[13:33:36.628]                   name <- added[[kk]]
[13:33:36.628]                   NAME <- NAMES[[kk]]
[13:33:36.628]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.628]                     next
[13:33:36.628]                   args[[name]] <- ""
[13:33:36.628]                 }
[13:33:36.628]                 NAMES <- toupper(removed)
[13:33:36.628]                 for (kk in seq_along(NAMES)) {
[13:33:36.628]                   name <- removed[[kk]]
[13:33:36.628]                   NAME <- NAMES[[kk]]
[13:33:36.628]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.628]                     next
[13:33:36.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.628]                 }
[13:33:36.628]                 if (length(args) > 0) 
[13:33:36.628]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.628]             }
[13:33:36.628]             else {
[13:33:36.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.628]             }
[13:33:36.628]             {
[13:33:36.628]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.628]                   0L) {
[13:33:36.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.628]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.628]                   base::options(opts)
[13:33:36.628]                 }
[13:33:36.628]                 {
[13:33:36.628]                   {
[13:33:36.628]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:36.628]                     NULL
[13:33:36.628]                   }
[13:33:36.628]                   options(future.plan = NULL)
[13:33:36.628]                   if (is.na(NA_character_)) 
[13:33:36.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.628]                     .init = FALSE)
[13:33:36.628]                 }
[13:33:36.628]             }
[13:33:36.628]         }
[13:33:36.628]     })
[13:33:36.628]     if (TRUE) {
[13:33:36.628]         base::sink(type = "output", split = FALSE)
[13:33:36.628]         if (TRUE) {
[13:33:36.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.628]         }
[13:33:36.628]         else {
[13:33:36.628]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.628]         }
[13:33:36.628]         base::close(...future.stdout)
[13:33:36.628]         ...future.stdout <- NULL
[13:33:36.628]     }
[13:33:36.628]     ...future.result$conditions <- ...future.conditions
[13:33:36.628]     ...future.result$finished <- base::Sys.time()
[13:33:36.628]     ...future.result
[13:33:36.628] }
[13:33:36.632] assign_globals() ...
[13:33:36.632] List of 5
[13:33:36.632]  $ future.call.arguments    : list()
[13:33:36.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.632]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.632]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.632]  $ ...future.elements_ii    :List of 1
[13:33:36.632]   ..$ : num [1:4] 2 4 6 8
[13:33:36.632]  $ ...future.seeds_ii       : NULL
[13:33:36.632]  $ ...future.globals.maxSize: num Inf
[13:33:36.632]  - attr(*, "resolved")= logi FALSE
[13:33:36.632]  - attr(*, "total_size")= num NA
[13:33:36.632]  - attr(*, "where")=List of 5
[13:33:36.632]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.632]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.632]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.632]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.632]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.632]  - attr(*, "already-done")= logi TRUE
[13:33:36.638] - copied ‘future.call.arguments’ to environment
[13:33:36.639] - copied ‘...future.FUN’ to environment
[13:33:36.639] - copied ‘...future.elements_ii’ to environment
[13:33:36.639] - copied ‘...future.seeds_ii’ to environment
[13:33:36.642] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.642] assign_globals() ... done
[13:33:36.642] requestCore(): workers = 2
[13:33:36.649] MulticoreFuture started
[13:33:36.649] - Launch lazy future ... done
[13:33:36.650] run() for ‘MulticoreFuture’ ... done
[13:33:36.650] Created future:
[13:33:36.650] plan(): Setting new future strategy stack:
[13:33:36.651] List of future strategies:
[13:33:36.651] 1. sequential:
[13:33:36.651]    - args: function (..., envir = parent.frame())
[13:33:36.651]    - tweaked: FALSE
[13:33:36.651]    - call: NULL
[13:33:36.652] plan(): nbrOfWorkers() = 1
[13:33:36.655] plan(): Setting new future strategy stack:
[13:33:36.655] List of future strategies:
[13:33:36.655] 1. multicore:
[13:33:36.655]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:36.655]    - tweaked: FALSE
[13:33:36.655]    - call: plan(strategy)
[13:33:36.660] plan(): nbrOfWorkers() = 2
[13:33:36.650] MulticoreFuture:
[13:33:36.650] Label: ‘future_apply-2’
[13:33:36.650] Expression:
[13:33:36.650] {
[13:33:36.650]     do.call(function(...) {
[13:33:36.650]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.650]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.650]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.650]             on.exit(options(oopts), add = TRUE)
[13:33:36.650]         }
[13:33:36.650]         {
[13:33:36.650]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.650]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.650]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.650]             })
[13:33:36.650]         }
[13:33:36.650]     }, args = future.call.arguments)
[13:33:36.650] }
[13:33:36.650] Lazy evaluation: FALSE
[13:33:36.650] Asynchronous evaluation: TRUE
[13:33:36.650] Local evaluation: TRUE
[13:33:36.650] Environment: R_GlobalEnv
[13:33:36.650] Capture standard output: TRUE
[13:33:36.650] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.650] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.650] Packages: <none>
[13:33:36.650] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.650] Resolved: TRUE
[13:33:36.650] Value: <not collected>
[13:33:36.650] Conditions captured: <none>
[13:33:36.650] Early signaling: FALSE
[13:33:36.650] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.650] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.661] Chunk #2 of 2 ... DONE
[13:33:36.661] Launching 2 futures (chunks) ... DONE
[13:33:36.661] Resolving 2 futures (chunks) ...
[13:33:36.662] resolve() on list ...
[13:33:36.662]  recursive: 0
[13:33:36.662]  length: 2
[13:33:36.662] 
[13:33:36.663] Future #1
[13:33:36.663] result() for MulticoreFuture ...
[13:33:36.665] result() for MulticoreFuture ...
[13:33:36.665] result() for MulticoreFuture ... done
[13:33:36.665] result() for MulticoreFuture ... done
[13:33:36.666] result() for MulticoreFuture ...
[13:33:36.666] result() for MulticoreFuture ... done
[13:33:36.666] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:36.666] - nx: 2
[13:33:36.666] - relay: TRUE
[13:33:36.667] - stdout: TRUE
[13:33:36.667] - signal: TRUE
[13:33:36.667] - resignal: FALSE
[13:33:36.667] - force: TRUE
[13:33:36.667] - relayed: [n=2] FALSE, FALSE
[13:33:36.667] - queued futures: [n=2] FALSE, FALSE
[13:33:36.667]  - until=1
[13:33:36.668]  - relaying element #1
[13:33:36.668] result() for MulticoreFuture ...
[13:33:36.668] result() for MulticoreFuture ... done
[13:33:36.668] result() for MulticoreFuture ...
[13:33:36.668] result() for MulticoreFuture ... done
[13:33:36.668] result() for MulticoreFuture ...
[13:33:36.669] result() for MulticoreFuture ... done
[13:33:36.669] result() for MulticoreFuture ...
[13:33:36.669] result() for MulticoreFuture ... done
[13:33:36.669] - relayed: [n=2] TRUE, FALSE
[13:33:36.669] - queued futures: [n=2] TRUE, FALSE
[13:33:36.669] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:36.669]  length: 1 (resolved future 1)
[13:33:36.670] Future #2
[13:33:36.670] result() for MulticoreFuture ...
[13:33:36.671] result() for MulticoreFuture ...
[13:33:36.671] result() for MulticoreFuture ... done
[13:33:36.671] result() for MulticoreFuture ... done
[13:33:36.671] result() for MulticoreFuture ...
[13:33:36.671] result() for MulticoreFuture ... done
[13:33:36.671] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:36.672] - nx: 2
[13:33:36.672] - relay: TRUE
[13:33:36.672] - stdout: TRUE
[13:33:36.672] - signal: TRUE
[13:33:36.672] - resignal: FALSE
[13:33:36.672] - force: TRUE
[13:33:36.672] - relayed: [n=2] TRUE, FALSE
[13:33:36.672] - queued futures: [n=2] TRUE, FALSE
[13:33:36.672]  - until=2
[13:33:36.672]  - relaying element #2
[13:33:36.673] result() for MulticoreFuture ...
[13:33:36.673] result() for MulticoreFuture ... done
[13:33:36.673] result() for MulticoreFuture ...
[13:33:36.673] result() for MulticoreFuture ... done
[13:33:36.673] result() for MulticoreFuture ...
[13:33:36.673] result() for MulticoreFuture ... done
[13:33:36.673] result() for MulticoreFuture ...
[13:33:36.674] result() for MulticoreFuture ... done
[13:33:36.674] - relayed: [n=2] TRUE, TRUE
[13:33:36.674] - queued futures: [n=2] TRUE, TRUE
[13:33:36.674] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:36.674]  length: 0 (resolved future 2)
[13:33:36.674] Relaying remaining futures
[13:33:36.674] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.674] - nx: 2
[13:33:36.674] - relay: TRUE
[13:33:36.675] - stdout: TRUE
[13:33:36.675] - signal: TRUE
[13:33:36.675] - resignal: FALSE
[13:33:36.675] - force: TRUE
[13:33:36.675] - relayed: [n=2] TRUE, TRUE
[13:33:36.675] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:36.675] - relayed: [n=2] TRUE, TRUE
[13:33:36.675] - queued futures: [n=2] TRUE, TRUE
[13:33:36.676] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.676] resolve() on list ... DONE
[13:33:36.676] result() for MulticoreFuture ...
[13:33:36.676] result() for MulticoreFuture ... done
[13:33:36.676] result() for MulticoreFuture ...
[13:33:36.676] result() for MulticoreFuture ... done
[13:33:36.676] result() for MulticoreFuture ...
[13:33:36.676] result() for MulticoreFuture ... done
[13:33:36.676] result() for MulticoreFuture ...
[13:33:36.677] result() for MulticoreFuture ... done
[13:33:36.677]  - Number of value chunks collected: 2
[13:33:36.677] Resolving 2 futures (chunks) ... DONE
[13:33:36.677] Reducing values from 2 chunks ...
[13:33:36.677]  - Number of values collected after concatenation: 2
[13:33:36.677]  - Number of values expected: 2
[13:33:36.677] Reducing values from 2 chunks ... DONE
[13:33:36.677] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:33:36.678] getGlobalsAndPackagesXApply() ...
[13:33:36.678]  - future.globals: TRUE
[13:33:36.678] getGlobalsAndPackages() ...
[13:33:36.678] Searching for globals...
[13:33:36.716] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:33:36.716] Searching for globals ... DONE
[13:33:36.716] Resolving globals: FALSE
[13:33:36.718] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:33:36.720] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:33:36.720] - globals: [1] ‘FUN’
[13:33:36.720] 
[13:33:36.720] getGlobalsAndPackages() ... DONE
[13:33:36.720]  - globals found/used: [n=1] ‘FUN’
[13:33:36.720]  - needed namespaces: [n=0] 
[13:33:36.720] Finding globals ... DONE
[13:33:36.721]  - use_args: TRUE
[13:33:36.721]  - Getting '...' globals ...
[13:33:36.721] resolve() on list ...
[13:33:36.721]  recursive: 0
[13:33:36.721]  length: 1
[13:33:36.721]  elements: ‘...’
[13:33:36.721]  length: 0 (resolved future 1)
[13:33:36.722] resolve() on list ... DONE
[13:33:36.722]    - '...' content: [n=0] 
[13:33:36.722] List of 1
[13:33:36.722]  $ ...: list()
[13:33:36.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.722]  - attr(*, "where")=List of 1
[13:33:36.722]   ..$ ...:<environment: 0x55b94a1c9f28> 
[13:33:36.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.722]  - attr(*, "resolved")= logi TRUE
[13:33:36.722]  - attr(*, "total_size")= num NA
[13:33:36.724]  - Getting '...' globals ... DONE
[13:33:36.725] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.725] List of 2
[13:33:36.725]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.725]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.725]  $ ...          : list()
[13:33:36.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.725]  - attr(*, "where")=List of 2
[13:33:36.725]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.725]   ..$ ...          :<environment: 0x55b94a1c9f28> 
[13:33:36.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.725]  - attr(*, "resolved")= logi FALSE
[13:33:36.725]  - attr(*, "total_size")= num 354224
[13:33:36.727] Packages to be attached in all futures: [n=0] 
[13:33:36.727] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.731] future_lapply() ...
[13:33:36.765] Number of chunks: 2
[13:33:36.765] getGlobalsAndPackagesXApply() ...
[13:33:36.765]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.765]  - use_args: TRUE
[13:33:36.765] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.765] List of 2
[13:33:36.765]  $ ...          : list()
[13:33:36.765]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.765]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.765]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.765]  - attr(*, "where")=List of 2
[13:33:36.765]   ..$ ...          :<environment: 0x55b94a1c9f28> 
[13:33:36.765]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:36.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.765]  - attr(*, "resolved")= logi FALSE
[13:33:36.765]  - attr(*, "total_size")= num NA
[13:33:36.769] Packages to be attached in all futures: [n=0] 
[13:33:36.769] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.769] Number of futures (= number of chunks): 2
[13:33:36.769] Launching 2 futures (chunks) ...
[13:33:36.769] Chunk #1 of 2 ...
[13:33:36.769]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:36.769]  - seeds: <none>
[13:33:36.769]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.770] getGlobalsAndPackages() ...
[13:33:36.770] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.770] Resolving globals: FALSE
[13:33:36.770] Tweak future expression to call with '...' arguments ...
[13:33:36.770] {
[13:33:36.770]     do.call(function(...) {
[13:33:36.770]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.770]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.770]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.770]             on.exit(options(oopts), add = TRUE)
[13:33:36.770]         }
[13:33:36.770]         {
[13:33:36.770]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.770]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.770]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.770]             })
[13:33:36.770]         }
[13:33:36.770]     }, args = future.call.arguments)
[13:33:36.770] }
[13:33:36.770] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.771] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.771] 
[13:33:36.771] getGlobalsAndPackages() ... DONE
[13:33:36.771] run() for ‘Future’ ...
[13:33:36.771] - state: ‘created’
[13:33:36.771] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:36.775] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.775] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:36.775]   - Field: ‘label’
[13:33:36.775]   - Field: ‘local’
[13:33:36.775]   - Field: ‘owner’
[13:33:36.775]   - Field: ‘envir’
[13:33:36.776]   - Field: ‘workers’
[13:33:36.776]   - Field: ‘packages’
[13:33:36.776]   - Field: ‘gc’
[13:33:36.776]   - Field: ‘job’
[13:33:36.776]   - Field: ‘conditions’
[13:33:36.776]   - Field: ‘expr’
[13:33:36.776]   - Field: ‘uuid’
[13:33:36.776]   - Field: ‘seed’
[13:33:36.776]   - Field: ‘version’
[13:33:36.776]   - Field: ‘result’
[13:33:36.776]   - Field: ‘asynchronous’
[13:33:36.777]   - Field: ‘calls’
[13:33:36.778]   - Field: ‘globals’
[13:33:36.778]   - Field: ‘stdout’
[13:33:36.778]   - Field: ‘earlySignal’
[13:33:36.778]   - Field: ‘lazy’
[13:33:36.778]   - Field: ‘state’
[13:33:36.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:36.778] - Launch lazy future ...
[13:33:36.779] Packages needed by the future expression (n = 0): <none>
[13:33:36.779] Packages needed by future strategies (n = 0): <none>
[13:33:36.779] {
[13:33:36.779]     {
[13:33:36.779]         {
[13:33:36.779]             ...future.startTime <- base::Sys.time()
[13:33:36.779]             {
[13:33:36.779]                 {
[13:33:36.779]                   {
[13:33:36.779]                     {
[13:33:36.779]                       base::local({
[13:33:36.779]                         has_future <- base::requireNamespace("future", 
[13:33:36.779]                           quietly = TRUE)
[13:33:36.779]                         if (has_future) {
[13:33:36.779]                           ns <- base::getNamespace("future")
[13:33:36.779]                           version <- ns[[".package"]][["version"]]
[13:33:36.779]                           if (is.null(version)) 
[13:33:36.779]                             version <- utils::packageVersion("future")
[13:33:36.779]                         }
[13:33:36.779]                         else {
[13:33:36.779]                           version <- NULL
[13:33:36.779]                         }
[13:33:36.779]                         if (!has_future || version < "1.8.0") {
[13:33:36.779]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.779]                             "", base::R.version$version.string), 
[13:33:36.779]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:36.779]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.779]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.779]                               "release", "version")], collapse = " "), 
[13:33:36.779]                             hostname = base::Sys.info()[["nodename"]])
[13:33:36.779]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.779]                             info)
[13:33:36.779]                           info <- base::paste(info, collapse = "; ")
[13:33:36.779]                           if (!has_future) {
[13:33:36.779]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.779]                               info)
[13:33:36.779]                           }
[13:33:36.779]                           else {
[13:33:36.779]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.779]                               info, version)
[13:33:36.779]                           }
[13:33:36.779]                           base::stop(msg)
[13:33:36.779]                         }
[13:33:36.779]                       })
[13:33:36.779]                     }
[13:33:36.779]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:36.779]                     base::options(mc.cores = 1L)
[13:33:36.779]                   }
[13:33:36.779]                   ...future.strategy.old <- future::plan("list")
[13:33:36.779]                   options(future.plan = NULL)
[13:33:36.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.779]                 }
[13:33:36.779]                 ...future.workdir <- getwd()
[13:33:36.779]             }
[13:33:36.779]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.779]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.779]         }
[13:33:36.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.779]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.779]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.779]             base::names(...future.oldOptions))
[13:33:36.779]     }
[13:33:36.779]     if (FALSE) {
[13:33:36.779]     }
[13:33:36.779]     else {
[13:33:36.779]         if (TRUE) {
[13:33:36.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.779]                 open = "w")
[13:33:36.779]         }
[13:33:36.779]         else {
[13:33:36.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.779]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.779]         }
[13:33:36.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.779]             base::sink(type = "output", split = FALSE)
[13:33:36.779]             base::close(...future.stdout)
[13:33:36.779]         }, add = TRUE)
[13:33:36.779]     }
[13:33:36.779]     ...future.frame <- base::sys.nframe()
[13:33:36.779]     ...future.conditions <- base::list()
[13:33:36.779]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.779]     if (FALSE) {
[13:33:36.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.779]     }
[13:33:36.779]     ...future.result <- base::tryCatch({
[13:33:36.779]         base::withCallingHandlers({
[13:33:36.779]             ...future.value <- base::withVisible(base::local({
[13:33:36.779]                 withCallingHandlers({
[13:33:36.779]                   {
[13:33:36.779]                     do.call(function(...) {
[13:33:36.779]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.779]                       if (!identical(...future.globals.maxSize.org, 
[13:33:36.779]                         ...future.globals.maxSize)) {
[13:33:36.779]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.779]                         on.exit(options(oopts), add = TRUE)
[13:33:36.779]                       }
[13:33:36.779]                       {
[13:33:36.779]                         lapply(seq_along(...future.elements_ii), 
[13:33:36.779]                           FUN = function(jj) {
[13:33:36.779]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.779]                             ...future.FUN(...future.X_jj, ...)
[13:33:36.779]                           })
[13:33:36.779]                       }
[13:33:36.779]                     }, args = future.call.arguments)
[13:33:36.779]                   }
[13:33:36.779]                 }, immediateCondition = function(cond) {
[13:33:36.779]                   save_rds <- function (object, pathname, ...) 
[13:33:36.779]                   {
[13:33:36.779]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:36.779]                     if (file_test("-f", pathname_tmp)) {
[13:33:36.779]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.779]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:36.779]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.779]                         fi_tmp[["mtime"]])
[13:33:36.779]                     }
[13:33:36.779]                     tryCatch({
[13:33:36.779]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:36.779]                     }, error = function(ex) {
[13:33:36.779]                       msg <- conditionMessage(ex)
[13:33:36.779]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.779]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:36.779]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.779]                         fi_tmp[["mtime"]], msg)
[13:33:36.779]                       ex$message <- msg
[13:33:36.779]                       stop(ex)
[13:33:36.779]                     })
[13:33:36.779]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:36.779]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:36.779]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:36.779]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.779]                       fi <- file.info(pathname)
[13:33:36.779]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:36.779]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.779]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:36.779]                         fi[["size"]], fi[["mtime"]])
[13:33:36.779]                       stop(msg)
[13:33:36.779]                     }
[13:33:36.779]                     invisible(pathname)
[13:33:36.779]                   }
[13:33:36.779]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:36.779]                     rootPath = tempdir()) 
[13:33:36.779]                   {
[13:33:36.779]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:36.779]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:36.779]                       tmpdir = path, fileext = ".rds")
[13:33:36.779]                     save_rds(obj, file)
[13:33:36.779]                   }
[13:33:36.779]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:36.779]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.779]                   {
[13:33:36.779]                     inherits <- base::inherits
[13:33:36.779]                     invokeRestart <- base::invokeRestart
[13:33:36.779]                     is.null <- base::is.null
[13:33:36.779]                     muffled <- FALSE
[13:33:36.779]                     if (inherits(cond, "message")) {
[13:33:36.779]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:36.779]                       if (muffled) 
[13:33:36.779]                         invokeRestart("muffleMessage")
[13:33:36.779]                     }
[13:33:36.779]                     else if (inherits(cond, "warning")) {
[13:33:36.779]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:36.779]                       if (muffled) 
[13:33:36.779]                         invokeRestart("muffleWarning")
[13:33:36.779]                     }
[13:33:36.779]                     else if (inherits(cond, "condition")) {
[13:33:36.779]                       if (!is.null(pattern)) {
[13:33:36.779]                         computeRestarts <- base::computeRestarts
[13:33:36.779]                         grepl <- base::grepl
[13:33:36.779]                         restarts <- computeRestarts(cond)
[13:33:36.779]                         for (restart in restarts) {
[13:33:36.779]                           name <- restart$name
[13:33:36.779]                           if (is.null(name)) 
[13:33:36.779]                             next
[13:33:36.779]                           if (!grepl(pattern, name)) 
[13:33:36.779]                             next
[13:33:36.779]                           invokeRestart(restart)
[13:33:36.779]                           muffled <- TRUE
[13:33:36.779]                           break
[13:33:36.779]                         }
[13:33:36.779]                       }
[13:33:36.779]                     }
[13:33:36.779]                     invisible(muffled)
[13:33:36.779]                   }
[13:33:36.779]                   muffleCondition(cond)
[13:33:36.779]                 })
[13:33:36.779]             }))
[13:33:36.779]             future::FutureResult(value = ...future.value$value, 
[13:33:36.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.779]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.779]                     ...future.globalenv.names))
[13:33:36.779]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.779]         }, condition = base::local({
[13:33:36.779]             c <- base::c
[13:33:36.779]             inherits <- base::inherits
[13:33:36.779]             invokeRestart <- base::invokeRestart
[13:33:36.779]             length <- base::length
[13:33:36.779]             list <- base::list
[13:33:36.779]             seq.int <- base::seq.int
[13:33:36.779]             signalCondition <- base::signalCondition
[13:33:36.779]             sys.calls <- base::sys.calls
[13:33:36.779]             `[[` <- base::`[[`
[13:33:36.779]             `+` <- base::`+`
[13:33:36.779]             `<<-` <- base::`<<-`
[13:33:36.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.779]                   3L)]
[13:33:36.779]             }
[13:33:36.779]             function(cond) {
[13:33:36.779]                 is_error <- inherits(cond, "error")
[13:33:36.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.779]                   NULL)
[13:33:36.779]                 if (is_error) {
[13:33:36.779]                   sessionInformation <- function() {
[13:33:36.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.779]                       search = base::search(), system = base::Sys.info())
[13:33:36.779]                   }
[13:33:36.779]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.779]                     cond$call), session = sessionInformation(), 
[13:33:36.779]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.779]                   signalCondition(cond)
[13:33:36.779]                 }
[13:33:36.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.779]                 "immediateCondition"))) {
[13:33:36.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.779]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.779]                   if (TRUE && !signal) {
[13:33:36.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.779]                     {
[13:33:36.779]                       inherits <- base::inherits
[13:33:36.779]                       invokeRestart <- base::invokeRestart
[13:33:36.779]                       is.null <- base::is.null
[13:33:36.779]                       muffled <- FALSE
[13:33:36.779]                       if (inherits(cond, "message")) {
[13:33:36.779]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.779]                         if (muffled) 
[13:33:36.779]                           invokeRestart("muffleMessage")
[13:33:36.779]                       }
[13:33:36.779]                       else if (inherits(cond, "warning")) {
[13:33:36.779]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.779]                         if (muffled) 
[13:33:36.779]                           invokeRestart("muffleWarning")
[13:33:36.779]                       }
[13:33:36.779]                       else if (inherits(cond, "condition")) {
[13:33:36.779]                         if (!is.null(pattern)) {
[13:33:36.779]                           computeRestarts <- base::computeRestarts
[13:33:36.779]                           grepl <- base::grepl
[13:33:36.779]                           restarts <- computeRestarts(cond)
[13:33:36.779]                           for (restart in restarts) {
[13:33:36.779]                             name <- restart$name
[13:33:36.779]                             if (is.null(name)) 
[13:33:36.779]                               next
[13:33:36.779]                             if (!grepl(pattern, name)) 
[13:33:36.779]                               next
[13:33:36.779]                             invokeRestart(restart)
[13:33:36.779]                             muffled <- TRUE
[13:33:36.779]                             break
[13:33:36.779]                           }
[13:33:36.779]                         }
[13:33:36.779]                       }
[13:33:36.779]                       invisible(muffled)
[13:33:36.779]                     }
[13:33:36.779]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.779]                   }
[13:33:36.779]                 }
[13:33:36.779]                 else {
[13:33:36.779]                   if (TRUE) {
[13:33:36.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.779]                     {
[13:33:36.779]                       inherits <- base::inherits
[13:33:36.779]                       invokeRestart <- base::invokeRestart
[13:33:36.779]                       is.null <- base::is.null
[13:33:36.779]                       muffled <- FALSE
[13:33:36.779]                       if (inherits(cond, "message")) {
[13:33:36.779]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.779]                         if (muffled) 
[13:33:36.779]                           invokeRestart("muffleMessage")
[13:33:36.779]                       }
[13:33:36.779]                       else if (inherits(cond, "warning")) {
[13:33:36.779]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.779]                         if (muffled) 
[13:33:36.779]                           invokeRestart("muffleWarning")
[13:33:36.779]                       }
[13:33:36.779]                       else if (inherits(cond, "condition")) {
[13:33:36.779]                         if (!is.null(pattern)) {
[13:33:36.779]                           computeRestarts <- base::computeRestarts
[13:33:36.779]                           grepl <- base::grepl
[13:33:36.779]                           restarts <- computeRestarts(cond)
[13:33:36.779]                           for (restart in restarts) {
[13:33:36.779]                             name <- restart$name
[13:33:36.779]                             if (is.null(name)) 
[13:33:36.779]                               next
[13:33:36.779]                             if (!grepl(pattern, name)) 
[13:33:36.779]                               next
[13:33:36.779]                             invokeRestart(restart)
[13:33:36.779]                             muffled <- TRUE
[13:33:36.779]                             break
[13:33:36.779]                           }
[13:33:36.779]                         }
[13:33:36.779]                       }
[13:33:36.779]                       invisible(muffled)
[13:33:36.779]                     }
[13:33:36.779]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.779]                   }
[13:33:36.779]                 }
[13:33:36.779]             }
[13:33:36.779]         }))
[13:33:36.779]     }, error = function(ex) {
[13:33:36.779]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.779]                 ...future.rng), started = ...future.startTime, 
[13:33:36.779]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.779]             version = "1.8"), class = "FutureResult")
[13:33:36.779]     }, finally = {
[13:33:36.779]         if (!identical(...future.workdir, getwd())) 
[13:33:36.779]             setwd(...future.workdir)
[13:33:36.779]         {
[13:33:36.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.779]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.779]             }
[13:33:36.779]             base::options(...future.oldOptions)
[13:33:36.779]             if (.Platform$OS.type == "windows") {
[13:33:36.779]                 old_names <- names(...future.oldEnvVars)
[13:33:36.779]                 envs <- base::Sys.getenv()
[13:33:36.779]                 names <- names(envs)
[13:33:36.779]                 common <- intersect(names, old_names)
[13:33:36.779]                 added <- setdiff(names, old_names)
[13:33:36.779]                 removed <- setdiff(old_names, names)
[13:33:36.779]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.779]                   envs[common]]
[13:33:36.779]                 NAMES <- toupper(changed)
[13:33:36.779]                 args <- list()
[13:33:36.779]                 for (kk in seq_along(NAMES)) {
[13:33:36.779]                   name <- changed[[kk]]
[13:33:36.779]                   NAME <- NAMES[[kk]]
[13:33:36.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.779]                     next
[13:33:36.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.779]                 }
[13:33:36.779]                 NAMES <- toupper(added)
[13:33:36.779]                 for (kk in seq_along(NAMES)) {
[13:33:36.779]                   name <- added[[kk]]
[13:33:36.779]                   NAME <- NAMES[[kk]]
[13:33:36.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.779]                     next
[13:33:36.779]                   args[[name]] <- ""
[13:33:36.779]                 }
[13:33:36.779]                 NAMES <- toupper(removed)
[13:33:36.779]                 for (kk in seq_along(NAMES)) {
[13:33:36.779]                   name <- removed[[kk]]
[13:33:36.779]                   NAME <- NAMES[[kk]]
[13:33:36.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.779]                     next
[13:33:36.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.779]                 }
[13:33:36.779]                 if (length(args) > 0) 
[13:33:36.779]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.779]             }
[13:33:36.779]             else {
[13:33:36.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.779]             }
[13:33:36.779]             {
[13:33:36.779]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.779]                   0L) {
[13:33:36.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.779]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.779]                   base::options(opts)
[13:33:36.779]                 }
[13:33:36.779]                 {
[13:33:36.779]                   {
[13:33:36.779]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:36.779]                     NULL
[13:33:36.779]                   }
[13:33:36.779]                   options(future.plan = NULL)
[13:33:36.779]                   if (is.na(NA_character_)) 
[13:33:36.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.779]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.779]                     .init = FALSE)
[13:33:36.779]                 }
[13:33:36.779]             }
[13:33:36.779]         }
[13:33:36.779]     })
[13:33:36.779]     if (TRUE) {
[13:33:36.779]         base::sink(type = "output", split = FALSE)
[13:33:36.779]         if (TRUE) {
[13:33:36.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.779]         }
[13:33:36.779]         else {
[13:33:36.779]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.779]         }
[13:33:36.779]         base::close(...future.stdout)
[13:33:36.779]         ...future.stdout <- NULL
[13:33:36.779]     }
[13:33:36.779]     ...future.result$conditions <- ...future.conditions
[13:33:36.779]     ...future.result$finished <- base::Sys.time()
[13:33:36.779]     ...future.result
[13:33:36.779] }
[13:33:36.781] assign_globals() ...
[13:33:36.781] List of 5
[13:33:36.781]  $ future.call.arguments    : list()
[13:33:36.781]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.781]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.781]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.781]  $ ...future.elements_ii    :List of 1
[13:33:36.781]   ..$ : num [1:4] 1 3 1 7
[13:33:36.781]  $ ...future.seeds_ii       : NULL
[13:33:36.781]  $ ...future.globals.maxSize: num Inf
[13:33:36.781]  - attr(*, "resolved")= logi FALSE
[13:33:36.781]  - attr(*, "total_size")= num NA
[13:33:36.781]  - attr(*, "where")=List of 5
[13:33:36.781]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.781]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.781]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.781]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.781]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.781]  - attr(*, "already-done")= logi TRUE
[13:33:36.786] - copied ‘future.call.arguments’ to environment
[13:33:36.786] - copied ‘...future.FUN’ to environment
[13:33:36.786] - copied ‘...future.elements_ii’ to environment
[13:33:36.786] - copied ‘...future.seeds_ii’ to environment
[13:33:36.786] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.786] assign_globals() ... done
[13:33:36.786] requestCore(): workers = 2
[13:33:36.788] MulticoreFuture started
[13:33:36.789] - Launch lazy future ... done
[13:33:36.789] run() for ‘MulticoreFuture’ ... done
[13:33:36.789] Created future:
[13:33:36.790] plan(): Setting new future strategy stack:
[13:33:36.790] List of future strategies:
[13:33:36.790] 1. sequential:
[13:33:36.790]    - args: function (..., envir = parent.frame())
[13:33:36.790]    - tweaked: FALSE
[13:33:36.790]    - call: NULL
[13:33:36.791] plan(): nbrOfWorkers() = 1
[13:33:36.793] plan(): Setting new future strategy stack:
[13:33:36.793] List of future strategies:
[13:33:36.793] 1. multicore:
[13:33:36.793]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:36.793]    - tweaked: FALSE
[13:33:36.793]    - call: plan(strategy)
[13:33:36.798] plan(): nbrOfWorkers() = 2
[13:33:36.789] MulticoreFuture:
[13:33:36.789] Label: ‘future_apply-1’
[13:33:36.789] Expression:
[13:33:36.789] {
[13:33:36.789]     do.call(function(...) {
[13:33:36.789]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.789]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.789]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.789]             on.exit(options(oopts), add = TRUE)
[13:33:36.789]         }
[13:33:36.789]         {
[13:33:36.789]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.789]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.789]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.789]             })
[13:33:36.789]         }
[13:33:36.789]     }, args = future.call.arguments)
[13:33:36.789] }
[13:33:36.789] Lazy evaluation: FALSE
[13:33:36.789] Asynchronous evaluation: TRUE
[13:33:36.789] Local evaluation: TRUE
[13:33:36.789] Environment: R_GlobalEnv
[13:33:36.789] Capture standard output: TRUE
[13:33:36.789] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.789] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.789] Packages: <none>
[13:33:36.789] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.789] Resolved: TRUE
[13:33:36.789] Value: <not collected>
[13:33:36.789] Conditions captured: <none>
[13:33:36.789] Early signaling: FALSE
[13:33:36.789] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.789] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.799] Chunk #1 of 2 ... DONE
[13:33:36.799] Chunk #2 of 2 ...
[13:33:36.800]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:36.800]  - seeds: <none>
[13:33:36.800]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.800] getGlobalsAndPackages() ...
[13:33:36.800] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.800] Resolving globals: FALSE
[13:33:36.801] Tweak future expression to call with '...' arguments ...
[13:33:36.801] {
[13:33:36.801]     do.call(function(...) {
[13:33:36.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.801]             on.exit(options(oopts), add = TRUE)
[13:33:36.801]         }
[13:33:36.801]         {
[13:33:36.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.801]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.801]             })
[13:33:36.801]         }
[13:33:36.801]     }, args = future.call.arguments)
[13:33:36.801] }
[13:33:36.801] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.802] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.802] 
[13:33:36.802] getGlobalsAndPackages() ... DONE
[13:33:36.803] run() for ‘Future’ ...
[13:33:36.803] - state: ‘created’
[13:33:36.803] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:36.808] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:36.808]   - Field: ‘label’
[13:33:36.808]   - Field: ‘local’
[13:33:36.808]   - Field: ‘owner’
[13:33:36.808]   - Field: ‘envir’
[13:33:36.809]   - Field: ‘workers’
[13:33:36.809]   - Field: ‘packages’
[13:33:36.809]   - Field: ‘gc’
[13:33:36.809]   - Field: ‘job’
[13:33:36.809]   - Field: ‘conditions’
[13:33:36.809]   - Field: ‘expr’
[13:33:36.809]   - Field: ‘uuid’
[13:33:36.810]   - Field: ‘seed’
[13:33:36.810]   - Field: ‘version’
[13:33:36.810]   - Field: ‘result’
[13:33:36.810]   - Field: ‘asynchronous’
[13:33:36.810]   - Field: ‘calls’
[13:33:36.810]   - Field: ‘globals’
[13:33:36.810]   - Field: ‘stdout’
[13:33:36.811]   - Field: ‘earlySignal’
[13:33:36.811]   - Field: ‘lazy’
[13:33:36.811]   - Field: ‘state’
[13:33:36.811] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:36.811] - Launch lazy future ...
[13:33:36.811] Packages needed by the future expression (n = 0): <none>
[13:33:36.812] Packages needed by future strategies (n = 0): <none>
[13:33:36.812] {
[13:33:36.812]     {
[13:33:36.812]         {
[13:33:36.812]             ...future.startTime <- base::Sys.time()
[13:33:36.812]             {
[13:33:36.812]                 {
[13:33:36.812]                   {
[13:33:36.812]                     {
[13:33:36.812]                       base::local({
[13:33:36.812]                         has_future <- base::requireNamespace("future", 
[13:33:36.812]                           quietly = TRUE)
[13:33:36.812]                         if (has_future) {
[13:33:36.812]                           ns <- base::getNamespace("future")
[13:33:36.812]                           version <- ns[[".package"]][["version"]]
[13:33:36.812]                           if (is.null(version)) 
[13:33:36.812]                             version <- utils::packageVersion("future")
[13:33:36.812]                         }
[13:33:36.812]                         else {
[13:33:36.812]                           version <- NULL
[13:33:36.812]                         }
[13:33:36.812]                         if (!has_future || version < "1.8.0") {
[13:33:36.812]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.812]                             "", base::R.version$version.string), 
[13:33:36.812]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:36.812]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:36.812]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.812]                               "release", "version")], collapse = " "), 
[13:33:36.812]                             hostname = base::Sys.info()[["nodename"]])
[13:33:36.812]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.812]                             info)
[13:33:36.812]                           info <- base::paste(info, collapse = "; ")
[13:33:36.812]                           if (!has_future) {
[13:33:36.812]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.812]                               info)
[13:33:36.812]                           }
[13:33:36.812]                           else {
[13:33:36.812]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.812]                               info, version)
[13:33:36.812]                           }
[13:33:36.812]                           base::stop(msg)
[13:33:36.812]                         }
[13:33:36.812]                       })
[13:33:36.812]                     }
[13:33:36.812]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:36.812]                     base::options(mc.cores = 1L)
[13:33:36.812]                   }
[13:33:36.812]                   ...future.strategy.old <- future::plan("list")
[13:33:36.812]                   options(future.plan = NULL)
[13:33:36.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.812]                 }
[13:33:36.812]                 ...future.workdir <- getwd()
[13:33:36.812]             }
[13:33:36.812]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.812]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.812]         }
[13:33:36.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.812]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.812]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.812]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.812]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.812]             base::names(...future.oldOptions))
[13:33:36.812]     }
[13:33:36.812]     if (FALSE) {
[13:33:36.812]     }
[13:33:36.812]     else {
[13:33:36.812]         if (TRUE) {
[13:33:36.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.812]                 open = "w")
[13:33:36.812]         }
[13:33:36.812]         else {
[13:33:36.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.812]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.812]         }
[13:33:36.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.812]             base::sink(type = "output", split = FALSE)
[13:33:36.812]             base::close(...future.stdout)
[13:33:36.812]         }, add = TRUE)
[13:33:36.812]     }
[13:33:36.812]     ...future.frame <- base::sys.nframe()
[13:33:36.812]     ...future.conditions <- base::list()
[13:33:36.812]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.812]     if (FALSE) {
[13:33:36.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.812]     }
[13:33:36.812]     ...future.result <- base::tryCatch({
[13:33:36.812]         base::withCallingHandlers({
[13:33:36.812]             ...future.value <- base::withVisible(base::local({
[13:33:36.812]                 withCallingHandlers({
[13:33:36.812]                   {
[13:33:36.812]                     do.call(function(...) {
[13:33:36.812]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.812]                       if (!identical(...future.globals.maxSize.org, 
[13:33:36.812]                         ...future.globals.maxSize)) {
[13:33:36.812]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.812]                         on.exit(options(oopts), add = TRUE)
[13:33:36.812]                       }
[13:33:36.812]                       {
[13:33:36.812]                         lapply(seq_along(...future.elements_ii), 
[13:33:36.812]                           FUN = function(jj) {
[13:33:36.812]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.812]                             ...future.FUN(...future.X_jj, ...)
[13:33:36.812]                           })
[13:33:36.812]                       }
[13:33:36.812]                     }, args = future.call.arguments)
[13:33:36.812]                   }
[13:33:36.812]                 }, immediateCondition = function(cond) {
[13:33:36.812]                   save_rds <- function (object, pathname, ...) 
[13:33:36.812]                   {
[13:33:36.812]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:36.812]                     if (file_test("-f", pathname_tmp)) {
[13:33:36.812]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.812]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:36.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.812]                         fi_tmp[["mtime"]])
[13:33:36.812]                     }
[13:33:36.812]                     tryCatch({
[13:33:36.812]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:36.812]                     }, error = function(ex) {
[13:33:36.812]                       msg <- conditionMessage(ex)
[13:33:36.812]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.812]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:36.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.812]                         fi_tmp[["mtime"]], msg)
[13:33:36.812]                       ex$message <- msg
[13:33:36.812]                       stop(ex)
[13:33:36.812]                     })
[13:33:36.812]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:36.812]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:36.812]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:36.812]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.812]                       fi <- file.info(pathname)
[13:33:36.812]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:36.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.812]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:36.812]                         fi[["size"]], fi[["mtime"]])
[13:33:36.812]                       stop(msg)
[13:33:36.812]                     }
[13:33:36.812]                     invisible(pathname)
[13:33:36.812]                   }
[13:33:36.812]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:36.812]                     rootPath = tempdir()) 
[13:33:36.812]                   {
[13:33:36.812]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:36.812]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:36.812]                       tmpdir = path, fileext = ".rds")
[13:33:36.812]                     save_rds(obj, file)
[13:33:36.812]                   }
[13:33:36.812]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:36.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.812]                   {
[13:33:36.812]                     inherits <- base::inherits
[13:33:36.812]                     invokeRestart <- base::invokeRestart
[13:33:36.812]                     is.null <- base::is.null
[13:33:36.812]                     muffled <- FALSE
[13:33:36.812]                     if (inherits(cond, "message")) {
[13:33:36.812]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:36.812]                       if (muffled) 
[13:33:36.812]                         invokeRestart("muffleMessage")
[13:33:36.812]                     }
[13:33:36.812]                     else if (inherits(cond, "warning")) {
[13:33:36.812]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:36.812]                       if (muffled) 
[13:33:36.812]                         invokeRestart("muffleWarning")
[13:33:36.812]                     }
[13:33:36.812]                     else if (inherits(cond, "condition")) {
[13:33:36.812]                       if (!is.null(pattern)) {
[13:33:36.812]                         computeRestarts <- base::computeRestarts
[13:33:36.812]                         grepl <- base::grepl
[13:33:36.812]                         restarts <- computeRestarts(cond)
[13:33:36.812]                         for (restart in restarts) {
[13:33:36.812]                           name <- restart$name
[13:33:36.812]                           if (is.null(name)) 
[13:33:36.812]                             next
[13:33:36.812]                           if (!grepl(pattern, name)) 
[13:33:36.812]                             next
[13:33:36.812]                           invokeRestart(restart)
[13:33:36.812]                           muffled <- TRUE
[13:33:36.812]                           break
[13:33:36.812]                         }
[13:33:36.812]                       }
[13:33:36.812]                     }
[13:33:36.812]                     invisible(muffled)
[13:33:36.812]                   }
[13:33:36.812]                   muffleCondition(cond)
[13:33:36.812]                 })
[13:33:36.812]             }))
[13:33:36.812]             future::FutureResult(value = ...future.value$value, 
[13:33:36.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.812]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.812]                     ...future.globalenv.names))
[13:33:36.812]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.812]         }, condition = base::local({
[13:33:36.812]             c <- base::c
[13:33:36.812]             inherits <- base::inherits
[13:33:36.812]             invokeRestart <- base::invokeRestart
[13:33:36.812]             length <- base::length
[13:33:36.812]             list <- base::list
[13:33:36.812]             seq.int <- base::seq.int
[13:33:36.812]             signalCondition <- base::signalCondition
[13:33:36.812]             sys.calls <- base::sys.calls
[13:33:36.812]             `[[` <- base::`[[`
[13:33:36.812]             `+` <- base::`+`
[13:33:36.812]             `<<-` <- base::`<<-`
[13:33:36.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.812]                   3L)]
[13:33:36.812]             }
[13:33:36.812]             function(cond) {
[13:33:36.812]                 is_error <- inherits(cond, "error")
[13:33:36.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.812]                   NULL)
[13:33:36.812]                 if (is_error) {
[13:33:36.812]                   sessionInformation <- function() {
[13:33:36.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.812]                       search = base::search(), system = base::Sys.info())
[13:33:36.812]                   }
[13:33:36.812]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.812]                     cond$call), session = sessionInformation(), 
[13:33:36.812]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.812]                   signalCondition(cond)
[13:33:36.812]                 }
[13:33:36.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.812]                 "immediateCondition"))) {
[13:33:36.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.812]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.812]                   if (TRUE && !signal) {
[13:33:36.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.812]                     {
[13:33:36.812]                       inherits <- base::inherits
[13:33:36.812]                       invokeRestart <- base::invokeRestart
[13:33:36.812]                       is.null <- base::is.null
[13:33:36.812]                       muffled <- FALSE
[13:33:36.812]                       if (inherits(cond, "message")) {
[13:33:36.812]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.812]                         if (muffled) 
[13:33:36.812]                           invokeRestart("muffleMessage")
[13:33:36.812]                       }
[13:33:36.812]                       else if (inherits(cond, "warning")) {
[13:33:36.812]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.812]                         if (muffled) 
[13:33:36.812]                           invokeRestart("muffleWarning")
[13:33:36.812]                       }
[13:33:36.812]                       else if (inherits(cond, "condition")) {
[13:33:36.812]                         if (!is.null(pattern)) {
[13:33:36.812]                           computeRestarts <- base::computeRestarts
[13:33:36.812]                           grepl <- base::grepl
[13:33:36.812]                           restarts <- computeRestarts(cond)
[13:33:36.812]                           for (restart in restarts) {
[13:33:36.812]                             name <- restart$name
[13:33:36.812]                             if (is.null(name)) 
[13:33:36.812]                               next
[13:33:36.812]                             if (!grepl(pattern, name)) 
[13:33:36.812]                               next
[13:33:36.812]                             invokeRestart(restart)
[13:33:36.812]                             muffled <- TRUE
[13:33:36.812]                             break
[13:33:36.812]                           }
[13:33:36.812]                         }
[13:33:36.812]                       }
[13:33:36.812]                       invisible(muffled)
[13:33:36.812]                     }
[13:33:36.812]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.812]                   }
[13:33:36.812]                 }
[13:33:36.812]                 else {
[13:33:36.812]                   if (TRUE) {
[13:33:36.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.812]                     {
[13:33:36.812]                       inherits <- base::inherits
[13:33:36.812]                       invokeRestart <- base::invokeRestart
[13:33:36.812]                       is.null <- base::is.null
[13:33:36.812]                       muffled <- FALSE
[13:33:36.812]                       if (inherits(cond, "message")) {
[13:33:36.812]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.812]                         if (muffled) 
[13:33:36.812]                           invokeRestart("muffleMessage")
[13:33:36.812]                       }
[13:33:36.812]                       else if (inherits(cond, "warning")) {
[13:33:36.812]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.812]                         if (muffled) 
[13:33:36.812]                           invokeRestart("muffleWarning")
[13:33:36.812]                       }
[13:33:36.812]                       else if (inherits(cond, "condition")) {
[13:33:36.812]                         if (!is.null(pattern)) {
[13:33:36.812]                           computeRestarts <- base::computeRestarts
[13:33:36.812]                           grepl <- base::grepl
[13:33:36.812]                           restarts <- computeRestarts(cond)
[13:33:36.812]                           for (restart in restarts) {
[13:33:36.812]                             name <- restart$name
[13:33:36.812]                             if (is.null(name)) 
[13:33:36.812]                               next
[13:33:36.812]                             if (!grepl(pattern, name)) 
[13:33:36.812]                               next
[13:33:36.812]                             invokeRestart(restart)
[13:33:36.812]                             muffled <- TRUE
[13:33:36.812]                             break
[13:33:36.812]                           }
[13:33:36.812]                         }
[13:33:36.812]                       }
[13:33:36.812]                       invisible(muffled)
[13:33:36.812]                     }
[13:33:36.812]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.812]                   }
[13:33:36.812]                 }
[13:33:36.812]             }
[13:33:36.812]         }))
[13:33:36.812]     }, error = function(ex) {
[13:33:36.812]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.812]                 ...future.rng), started = ...future.startTime, 
[13:33:36.812]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.812]             version = "1.8"), class = "FutureResult")
[13:33:36.812]     }, finally = {
[13:33:36.812]         if (!identical(...future.workdir, getwd())) 
[13:33:36.812]             setwd(...future.workdir)
[13:33:36.812]         {
[13:33:36.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.812]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.812]             }
[13:33:36.812]             base::options(...future.oldOptions)
[13:33:36.812]             if (.Platform$OS.type == "windows") {
[13:33:36.812]                 old_names <- names(...future.oldEnvVars)
[13:33:36.812]                 envs <- base::Sys.getenv()
[13:33:36.812]                 names <- names(envs)
[13:33:36.812]                 common <- intersect(names, old_names)
[13:33:36.812]                 added <- setdiff(names, old_names)
[13:33:36.812]                 removed <- setdiff(old_names, names)
[13:33:36.812]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.812]                   envs[common]]
[13:33:36.812]                 NAMES <- toupper(changed)
[13:33:36.812]                 args <- list()
[13:33:36.812]                 for (kk in seq_along(NAMES)) {
[13:33:36.812]                   name <- changed[[kk]]
[13:33:36.812]                   NAME <- NAMES[[kk]]
[13:33:36.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.812]                     next
[13:33:36.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.812]                 }
[13:33:36.812]                 NAMES <- toupper(added)
[13:33:36.812]                 for (kk in seq_along(NAMES)) {
[13:33:36.812]                   name <- added[[kk]]
[13:33:36.812]                   NAME <- NAMES[[kk]]
[13:33:36.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.812]                     next
[13:33:36.812]                   args[[name]] <- ""
[13:33:36.812]                 }
[13:33:36.812]                 NAMES <- toupper(removed)
[13:33:36.812]                 for (kk in seq_along(NAMES)) {
[13:33:36.812]                   name <- removed[[kk]]
[13:33:36.812]                   NAME <- NAMES[[kk]]
[13:33:36.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.812]                     next
[13:33:36.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.812]                 }
[13:33:36.812]                 if (length(args) > 0) 
[13:33:36.812]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.812]             }
[13:33:36.812]             else {
[13:33:36.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.812]             }
[13:33:36.812]             {
[13:33:36.812]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.812]                   0L) {
[13:33:36.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.812]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.812]                   base::options(opts)
[13:33:36.812]                 }
[13:33:36.812]                 {
[13:33:36.812]                   {
[13:33:36.812]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:36.812]                     NULL
[13:33:36.812]                   }
[13:33:36.812]                   options(future.plan = NULL)
[13:33:36.812]                   if (is.na(NA_character_)) 
[13:33:36.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.812]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.812]                     .init = FALSE)
[13:33:36.812]                 }
[13:33:36.812]             }
[13:33:36.812]         }
[13:33:36.812]     })
[13:33:36.812]     if (TRUE) {
[13:33:36.812]         base::sink(type = "output", split = FALSE)
[13:33:36.812]         if (TRUE) {
[13:33:36.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.812]         }
[13:33:36.812]         else {
[13:33:36.812]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.812]         }
[13:33:36.812]         base::close(...future.stdout)
[13:33:36.812]         ...future.stdout <- NULL
[13:33:36.812]     }
[13:33:36.812]     ...future.result$conditions <- ...future.conditions
[13:33:36.812]     ...future.result$finished <- base::Sys.time()
[13:33:36.812]     ...future.result
[13:33:36.812] }
[13:33:36.815] assign_globals() ...
[13:33:36.815] List of 5
[13:33:36.815]  $ future.call.arguments    : list()
[13:33:36.815]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.815]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:36.815]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:36.815]  $ ...future.elements_ii    :List of 1
[13:33:36.815]   ..$ : num [1:4] 2 4 6 8
[13:33:36.815]  $ ...future.seeds_ii       : NULL
[13:33:36.815]  $ ...future.globals.maxSize: num Inf
[13:33:36.815]  - attr(*, "resolved")= logi FALSE
[13:33:36.815]  - attr(*, "total_size")= num NA
[13:33:36.815]  - attr(*, "where")=List of 5
[13:33:36.815]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.815]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.815]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.815]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.815]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.815]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.815]  - attr(*, "already-done")= logi TRUE
[13:33:36.827] - copied ‘future.call.arguments’ to environment
[13:33:36.827] - copied ‘...future.FUN’ to environment
[13:33:36.827] - copied ‘...future.elements_ii’ to environment
[13:33:36.827] - copied ‘...future.seeds_ii’ to environment
[13:33:36.827] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.828] assign_globals() ... done
[13:33:36.828] requestCore(): workers = 2
[13:33:36.830] MulticoreFuture started
[13:33:36.831] - Launch lazy future ... done
[13:33:36.831] run() for ‘MulticoreFuture’ ... done
[13:33:36.831] Created future:
[13:33:36.831] plan(): Setting new future strategy stack:
[13:33:36.832] List of future strategies:
[13:33:36.832] 1. sequential:
[13:33:36.832]    - args: function (..., envir = parent.frame())
[13:33:36.832]    - tweaked: FALSE
[13:33:36.832]    - call: NULL
[13:33:36.833] plan(): nbrOfWorkers() = 1
[13:33:36.836] plan(): Setting new future strategy stack:
[13:33:36.836] List of future strategies:
[13:33:36.836] 1. multicore:
[13:33:36.836]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:36.836]    - tweaked: FALSE
[13:33:36.836]    - call: plan(strategy)
[13:33:36.841] plan(): nbrOfWorkers() = 2
[13:33:36.831] MulticoreFuture:
[13:33:36.831] Label: ‘future_apply-2’
[13:33:36.831] Expression:
[13:33:36.831] {
[13:33:36.831]     do.call(function(...) {
[13:33:36.831]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.831]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.831]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.831]             on.exit(options(oopts), add = TRUE)
[13:33:36.831]         }
[13:33:36.831]         {
[13:33:36.831]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.831]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.831]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.831]             })
[13:33:36.831]         }
[13:33:36.831]     }, args = future.call.arguments)
[13:33:36.831] }
[13:33:36.831] Lazy evaluation: FALSE
[13:33:36.831] Asynchronous evaluation: TRUE
[13:33:36.831] Local evaluation: TRUE
[13:33:36.831] Environment: R_GlobalEnv
[13:33:36.831] Capture standard output: TRUE
[13:33:36.831] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.831] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.831] Packages: <none>
[13:33:36.831] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.831] Resolved: TRUE
[13:33:36.831] Value: <not collected>
[13:33:36.831] Conditions captured: <none>
[13:33:36.831] Early signaling: FALSE
[13:33:36.831] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.831] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.842] Chunk #2 of 2 ... DONE
[13:33:36.842] Launching 2 futures (chunks) ... DONE
[13:33:36.843] Resolving 2 futures (chunks) ...
[13:33:36.843] resolve() on list ...
[13:33:36.843]  recursive: 0
[13:33:36.843]  length: 2
[13:33:36.843] 
[13:33:36.844] Future #1
[13:33:36.844] result() for MulticoreFuture ...
[13:33:36.845] result() for MulticoreFuture ...
[13:33:36.845] result() for MulticoreFuture ... done
[13:33:36.845] result() for MulticoreFuture ... done
[13:33:36.845] result() for MulticoreFuture ...
[13:33:36.846] result() for MulticoreFuture ... done
[13:33:36.846] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:36.846] - nx: 2
[13:33:36.846] - relay: TRUE
[13:33:36.846] - stdout: TRUE
[13:33:36.846] - signal: TRUE
[13:33:36.847] - resignal: FALSE
[13:33:36.847] - force: TRUE
[13:33:36.847] - relayed: [n=2] FALSE, FALSE
[13:33:36.847] - queued futures: [n=2] FALSE, FALSE
[13:33:36.847]  - until=1
[13:33:36.847]  - relaying element #1
[13:33:36.847] result() for MulticoreFuture ...
[13:33:36.848] result() for MulticoreFuture ... done
[13:33:36.848] result() for MulticoreFuture ...
[13:33:36.848] result() for MulticoreFuture ... done
[13:33:36.848] result() for MulticoreFuture ...
[13:33:36.848] result() for MulticoreFuture ... done
[13:33:36.848] result() for MulticoreFuture ...
[13:33:36.849] result() for MulticoreFuture ... done
[13:33:36.849] - relayed: [n=2] TRUE, FALSE
[13:33:36.849] - queued futures: [n=2] TRUE, FALSE
[13:33:36.849] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:36.849]  length: 1 (resolved future 1)
[13:33:36.849] Future #2
[13:33:36.850] result() for MulticoreFuture ...
[13:33:36.850] result() for MulticoreFuture ...
[13:33:36.850] result() for MulticoreFuture ... done
[13:33:36.851] result() for MulticoreFuture ... done
[13:33:36.851] result() for MulticoreFuture ...
[13:33:36.851] result() for MulticoreFuture ... done
[13:33:36.851] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:36.851] - nx: 2
[13:33:36.851] - relay: TRUE
[13:33:36.851] - stdout: TRUE
[13:33:36.852] - signal: TRUE
[13:33:36.852] - resignal: FALSE
[13:33:36.852] - force: TRUE
[13:33:36.852] - relayed: [n=2] TRUE, FALSE
[13:33:36.852] - queued futures: [n=2] TRUE, FALSE
[13:33:36.852]  - until=2
[13:33:36.852]  - relaying element #2
[13:33:36.852] result() for MulticoreFuture ...
[13:33:36.852] result() for MulticoreFuture ... done
[13:33:36.853] result() for MulticoreFuture ...
[13:33:36.853] result() for MulticoreFuture ... done
[13:33:36.853] result() for MulticoreFuture ...
[13:33:36.853] result() for MulticoreFuture ... done
[13:33:36.853] result() for MulticoreFuture ...
[13:33:36.853] result() for MulticoreFuture ... done
[13:33:36.853] - relayed: [n=2] TRUE, TRUE
[13:33:36.853] - queued futures: [n=2] TRUE, TRUE
[13:33:36.854] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:36.854]  length: 0 (resolved future 2)
[13:33:36.854] Relaying remaining futures
[13:33:36.854] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.854] - nx: 2
[13:33:36.854] - relay: TRUE
[13:33:36.854] - stdout: TRUE
[13:33:36.854] - signal: TRUE
[13:33:36.854] - resignal: FALSE
[13:33:36.854] - force: TRUE
[13:33:36.855] - relayed: [n=2] TRUE, TRUE
[13:33:36.855] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:36.855] - relayed: [n=2] TRUE, TRUE
[13:33:36.855] - queued futures: [n=2] TRUE, TRUE
[13:33:36.855] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.855] resolve() on list ... DONE
[13:33:36.855] result() for MulticoreFuture ...
[13:33:36.855] result() for MulticoreFuture ... done
[13:33:36.856] result() for MulticoreFuture ...
[13:33:36.856] result() for MulticoreFuture ... done
[13:33:36.856] result() for MulticoreFuture ...
[13:33:36.856] result() for MulticoreFuture ... done
[13:33:36.856] result() for MulticoreFuture ...
[13:33:36.856] result() for MulticoreFuture ... done
[13:33:36.856]  - Number of value chunks collected: 2
[13:33:36.856] Resolving 2 futures (chunks) ... DONE
[13:33:36.856] Reducing values from 2 chunks ...
[13:33:36.857]  - Number of values collected after concatenation: 2
[13:33:36.857]  - Number of values expected: 2
[13:33:36.857] Reducing values from 2 chunks ... DONE
[13:33:36.857] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:33:36.858] getGlobalsAndPackagesXApply() ...
[13:33:36.858]  - future.globals: TRUE
[13:33:36.858] getGlobalsAndPackages() ...
[13:33:36.858] Searching for globals...
[13:33:36.860] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:36.860] Searching for globals ... DONE
[13:33:36.860] Resolving globals: FALSE
[13:33:36.860] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:36.861] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:36.861] - globals: [1] ‘FUN’
[13:33:36.861] - packages: [1] ‘stats’
[13:33:36.861] getGlobalsAndPackages() ... DONE
[13:33:36.861]  - globals found/used: [n=1] ‘FUN’
[13:33:36.861]  - needed namespaces: [n=1] ‘stats’
[13:33:36.862] Finding globals ... DONE
[13:33:36.862]  - use_args: TRUE
[13:33:36.862]  - Getting '...' globals ...
[13:33:36.862] resolve() on list ...
[13:33:36.862]  recursive: 0
[13:33:36.862]  length: 1
[13:33:36.862]  elements: ‘...’
[13:33:36.863]  length: 0 (resolved future 1)
[13:33:36.863] resolve() on list ... DONE
[13:33:36.863]    - '...' content: [n=0] 
[13:33:36.863] List of 1
[13:33:36.863]  $ ...: list()
[13:33:36.863]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.863]  - attr(*, "where")=List of 1
[13:33:36.863]   ..$ ...:<environment: 0x55b94a1d5de8> 
[13:33:36.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.863]  - attr(*, "resolved")= logi TRUE
[13:33:36.863]  - attr(*, "total_size")= num NA
[13:33:36.870]  - Getting '...' globals ... DONE
[13:33:36.871] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.871] List of 2
[13:33:36.871]  $ ...future.FUN:function (x, ...)  
[13:33:36.871]  $ ...          : list()
[13:33:36.871]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.871]  - attr(*, "where")=List of 2
[13:33:36.871]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.871]   ..$ ...          :<environment: 0x55b94a1d5de8> 
[13:33:36.871]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.871]  - attr(*, "resolved")= logi FALSE
[13:33:36.871]  - attr(*, "total_size")= num 1248
[13:33:36.874] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:36.874] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.877] future_lapply() ...
[13:33:36.881] Number of chunks: 2
[13:33:36.881] getGlobalsAndPackagesXApply() ...
[13:33:36.881]  - future.globals: <name-value list> with names ‘list()’
[13:33:36.882]  - use_args: TRUE
[13:33:36.882] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:36.882] List of 2
[13:33:36.882]  $ ...          : list()
[13:33:36.882]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.882]  $ ...future.FUN:function (x, ...)  
[13:33:36.882]  - attr(*, "where")=List of 2
[13:33:36.882]   ..$ ...          :<environment: 0x55b94a1d5de8> 
[13:33:36.882]   ..$ ...future.FUN:<environment: namespace:stats> 
[13:33:36.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.882]  - attr(*, "resolved")= logi FALSE
[13:33:36.882]  - attr(*, "total_size")= num NA
[13:33:36.885] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:36.885] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.885] Number of futures (= number of chunks): 2
[13:33:36.885] Launching 2 futures (chunks) ...
[13:33:36.885] Chunk #1 of 2 ...
[13:33:36.885]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:36.885]  - seeds: <none>
[13:33:36.885]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.886] getGlobalsAndPackages() ...
[13:33:36.886] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.886] Resolving globals: FALSE
[13:33:36.886] Tweak future expression to call with '...' arguments ...
[13:33:36.886] {
[13:33:36.886]     do.call(function(...) {
[13:33:36.886]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.886]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.886]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.886]             on.exit(options(oopts), add = TRUE)
[13:33:36.886]         }
[13:33:36.886]         {
[13:33:36.886]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.886]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.886]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.886]             })
[13:33:36.886]         }
[13:33:36.886]     }, args = future.call.arguments)
[13:33:36.886] }
[13:33:36.886] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.887] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.887] - packages: [1] ‘stats’
[13:33:36.887] getGlobalsAndPackages() ... DONE
[13:33:36.887] run() for ‘Future’ ...
[13:33:36.887] - state: ‘created’
[13:33:36.887] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:36.891] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.891] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:36.891]   - Field: ‘label’
[13:33:36.891]   - Field: ‘local’
[13:33:36.891]   - Field: ‘owner’
[13:33:36.891]   - Field: ‘envir’
[13:33:36.892]   - Field: ‘workers’
[13:33:36.892]   - Field: ‘packages’
[13:33:36.892]   - Field: ‘gc’
[13:33:36.892]   - Field: ‘job’
[13:33:36.892]   - Field: ‘conditions’
[13:33:36.892]   - Field: ‘expr’
[13:33:36.892]   - Field: ‘uuid’
[13:33:36.892]   - Field: ‘seed’
[13:33:36.892]   - Field: ‘version’
[13:33:36.892]   - Field: ‘result’
[13:33:36.892]   - Field: ‘asynchronous’
[13:33:36.892]   - Field: ‘calls’
[13:33:36.893]   - Field: ‘globals’
[13:33:36.893]   - Field: ‘stdout’
[13:33:36.893]   - Field: ‘earlySignal’
[13:33:36.893]   - Field: ‘lazy’
[13:33:36.893]   - Field: ‘state’
[13:33:36.893] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:36.893] - Launch lazy future ...
[13:33:36.893] Packages needed by the future expression (n = 1): ‘stats’
[13:33:36.893] Packages needed by future strategies (n = 0): <none>
[13:33:36.894] {
[13:33:36.894]     {
[13:33:36.894]         {
[13:33:36.894]             ...future.startTime <- base::Sys.time()
[13:33:36.894]             {
[13:33:36.894]                 {
[13:33:36.894]                   {
[13:33:36.894]                     {
[13:33:36.894]                       {
[13:33:36.894]                         base::local({
[13:33:36.894]                           has_future <- base::requireNamespace("future", 
[13:33:36.894]                             quietly = TRUE)
[13:33:36.894]                           if (has_future) {
[13:33:36.894]                             ns <- base::getNamespace("future")
[13:33:36.894]                             version <- ns[[".package"]][["version"]]
[13:33:36.894]                             if (is.null(version)) 
[13:33:36.894]                               version <- utils::packageVersion("future")
[13:33:36.894]                           }
[13:33:36.894]                           else {
[13:33:36.894]                             version <- NULL
[13:33:36.894]                           }
[13:33:36.894]                           if (!has_future || version < "1.8.0") {
[13:33:36.894]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.894]                               "", base::R.version$version.string), 
[13:33:36.894]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:36.894]                                 base::R.version$platform, 8 * 
[13:33:36.894]                                   base::.Machine$sizeof.pointer), 
[13:33:36.894]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.894]                                 "release", "version")], collapse = " "), 
[13:33:36.894]                               hostname = base::Sys.info()[["nodename"]])
[13:33:36.894]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.894]                               info)
[13:33:36.894]                             info <- base::paste(info, collapse = "; ")
[13:33:36.894]                             if (!has_future) {
[13:33:36.894]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.894]                                 info)
[13:33:36.894]                             }
[13:33:36.894]                             else {
[13:33:36.894]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.894]                                 info, version)
[13:33:36.894]                             }
[13:33:36.894]                             base::stop(msg)
[13:33:36.894]                           }
[13:33:36.894]                         })
[13:33:36.894]                       }
[13:33:36.894]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:36.894]                       base::options(mc.cores = 1L)
[13:33:36.894]                     }
[13:33:36.894]                     base::local({
[13:33:36.894]                       for (pkg in "stats") {
[13:33:36.894]                         base::loadNamespace(pkg)
[13:33:36.894]                         base::library(pkg, character.only = TRUE)
[13:33:36.894]                       }
[13:33:36.894]                     })
[13:33:36.894]                   }
[13:33:36.894]                   ...future.strategy.old <- future::plan("list")
[13:33:36.894]                   options(future.plan = NULL)
[13:33:36.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.894]                 }
[13:33:36.894]                 ...future.workdir <- getwd()
[13:33:36.894]             }
[13:33:36.894]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.894]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.894]         }
[13:33:36.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.894]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.894]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.894]             base::names(...future.oldOptions))
[13:33:36.894]     }
[13:33:36.894]     if (FALSE) {
[13:33:36.894]     }
[13:33:36.894]     else {
[13:33:36.894]         if (TRUE) {
[13:33:36.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.894]                 open = "w")
[13:33:36.894]         }
[13:33:36.894]         else {
[13:33:36.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.894]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.894]         }
[13:33:36.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.894]             base::sink(type = "output", split = FALSE)
[13:33:36.894]             base::close(...future.stdout)
[13:33:36.894]         }, add = TRUE)
[13:33:36.894]     }
[13:33:36.894]     ...future.frame <- base::sys.nframe()
[13:33:36.894]     ...future.conditions <- base::list()
[13:33:36.894]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.894]     if (FALSE) {
[13:33:36.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.894]     }
[13:33:36.894]     ...future.result <- base::tryCatch({
[13:33:36.894]         base::withCallingHandlers({
[13:33:36.894]             ...future.value <- base::withVisible(base::local({
[13:33:36.894]                 withCallingHandlers({
[13:33:36.894]                   {
[13:33:36.894]                     do.call(function(...) {
[13:33:36.894]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.894]                       if (!identical(...future.globals.maxSize.org, 
[13:33:36.894]                         ...future.globals.maxSize)) {
[13:33:36.894]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.894]                         on.exit(options(oopts), add = TRUE)
[13:33:36.894]                       }
[13:33:36.894]                       {
[13:33:36.894]                         lapply(seq_along(...future.elements_ii), 
[13:33:36.894]                           FUN = function(jj) {
[13:33:36.894]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.894]                             ...future.FUN(...future.X_jj, ...)
[13:33:36.894]                           })
[13:33:36.894]                       }
[13:33:36.894]                     }, args = future.call.arguments)
[13:33:36.894]                   }
[13:33:36.894]                 }, immediateCondition = function(cond) {
[13:33:36.894]                   save_rds <- function (object, pathname, ...) 
[13:33:36.894]                   {
[13:33:36.894]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:36.894]                     if (file_test("-f", pathname_tmp)) {
[13:33:36.894]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.894]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:36.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.894]                         fi_tmp[["mtime"]])
[13:33:36.894]                     }
[13:33:36.894]                     tryCatch({
[13:33:36.894]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:36.894]                     }, error = function(ex) {
[13:33:36.894]                       msg <- conditionMessage(ex)
[13:33:36.894]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.894]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:36.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.894]                         fi_tmp[["mtime"]], msg)
[13:33:36.894]                       ex$message <- msg
[13:33:36.894]                       stop(ex)
[13:33:36.894]                     })
[13:33:36.894]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:36.894]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:36.894]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:36.894]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.894]                       fi <- file.info(pathname)
[13:33:36.894]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:36.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.894]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:36.894]                         fi[["size"]], fi[["mtime"]])
[13:33:36.894]                       stop(msg)
[13:33:36.894]                     }
[13:33:36.894]                     invisible(pathname)
[13:33:36.894]                   }
[13:33:36.894]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:36.894]                     rootPath = tempdir()) 
[13:33:36.894]                   {
[13:33:36.894]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:36.894]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:36.894]                       tmpdir = path, fileext = ".rds")
[13:33:36.894]                     save_rds(obj, file)
[13:33:36.894]                   }
[13:33:36.894]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:36.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.894]                   {
[13:33:36.894]                     inherits <- base::inherits
[13:33:36.894]                     invokeRestart <- base::invokeRestart
[13:33:36.894]                     is.null <- base::is.null
[13:33:36.894]                     muffled <- FALSE
[13:33:36.894]                     if (inherits(cond, "message")) {
[13:33:36.894]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:36.894]                       if (muffled) 
[13:33:36.894]                         invokeRestart("muffleMessage")
[13:33:36.894]                     }
[13:33:36.894]                     else if (inherits(cond, "warning")) {
[13:33:36.894]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:36.894]                       if (muffled) 
[13:33:36.894]                         invokeRestart("muffleWarning")
[13:33:36.894]                     }
[13:33:36.894]                     else if (inherits(cond, "condition")) {
[13:33:36.894]                       if (!is.null(pattern)) {
[13:33:36.894]                         computeRestarts <- base::computeRestarts
[13:33:36.894]                         grepl <- base::grepl
[13:33:36.894]                         restarts <- computeRestarts(cond)
[13:33:36.894]                         for (restart in restarts) {
[13:33:36.894]                           name <- restart$name
[13:33:36.894]                           if (is.null(name)) 
[13:33:36.894]                             next
[13:33:36.894]                           if (!grepl(pattern, name)) 
[13:33:36.894]                             next
[13:33:36.894]                           invokeRestart(restart)
[13:33:36.894]                           muffled <- TRUE
[13:33:36.894]                           break
[13:33:36.894]                         }
[13:33:36.894]                       }
[13:33:36.894]                     }
[13:33:36.894]                     invisible(muffled)
[13:33:36.894]                   }
[13:33:36.894]                   muffleCondition(cond)
[13:33:36.894]                 })
[13:33:36.894]             }))
[13:33:36.894]             future::FutureResult(value = ...future.value$value, 
[13:33:36.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.894]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.894]                     ...future.globalenv.names))
[13:33:36.894]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.894]         }, condition = base::local({
[13:33:36.894]             c <- base::c
[13:33:36.894]             inherits <- base::inherits
[13:33:36.894]             invokeRestart <- base::invokeRestart
[13:33:36.894]             length <- base::length
[13:33:36.894]             list <- base::list
[13:33:36.894]             seq.int <- base::seq.int
[13:33:36.894]             signalCondition <- base::signalCondition
[13:33:36.894]             sys.calls <- base::sys.calls
[13:33:36.894]             `[[` <- base::`[[`
[13:33:36.894]             `+` <- base::`+`
[13:33:36.894]             `<<-` <- base::`<<-`
[13:33:36.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.894]                   3L)]
[13:33:36.894]             }
[13:33:36.894]             function(cond) {
[13:33:36.894]                 is_error <- inherits(cond, "error")
[13:33:36.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.894]                   NULL)
[13:33:36.894]                 if (is_error) {
[13:33:36.894]                   sessionInformation <- function() {
[13:33:36.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.894]                       search = base::search(), system = base::Sys.info())
[13:33:36.894]                   }
[13:33:36.894]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.894]                     cond$call), session = sessionInformation(), 
[13:33:36.894]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.894]                   signalCondition(cond)
[13:33:36.894]                 }
[13:33:36.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.894]                 "immediateCondition"))) {
[13:33:36.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.894]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.894]                   if (TRUE && !signal) {
[13:33:36.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.894]                     {
[13:33:36.894]                       inherits <- base::inherits
[13:33:36.894]                       invokeRestart <- base::invokeRestart
[13:33:36.894]                       is.null <- base::is.null
[13:33:36.894]                       muffled <- FALSE
[13:33:36.894]                       if (inherits(cond, "message")) {
[13:33:36.894]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.894]                         if (muffled) 
[13:33:36.894]                           invokeRestart("muffleMessage")
[13:33:36.894]                       }
[13:33:36.894]                       else if (inherits(cond, "warning")) {
[13:33:36.894]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.894]                         if (muffled) 
[13:33:36.894]                           invokeRestart("muffleWarning")
[13:33:36.894]                       }
[13:33:36.894]                       else if (inherits(cond, "condition")) {
[13:33:36.894]                         if (!is.null(pattern)) {
[13:33:36.894]                           computeRestarts <- base::computeRestarts
[13:33:36.894]                           grepl <- base::grepl
[13:33:36.894]                           restarts <- computeRestarts(cond)
[13:33:36.894]                           for (restart in restarts) {
[13:33:36.894]                             name <- restart$name
[13:33:36.894]                             if (is.null(name)) 
[13:33:36.894]                               next
[13:33:36.894]                             if (!grepl(pattern, name)) 
[13:33:36.894]                               next
[13:33:36.894]                             invokeRestart(restart)
[13:33:36.894]                             muffled <- TRUE
[13:33:36.894]                             break
[13:33:36.894]                           }
[13:33:36.894]                         }
[13:33:36.894]                       }
[13:33:36.894]                       invisible(muffled)
[13:33:36.894]                     }
[13:33:36.894]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.894]                   }
[13:33:36.894]                 }
[13:33:36.894]                 else {
[13:33:36.894]                   if (TRUE) {
[13:33:36.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.894]                     {
[13:33:36.894]                       inherits <- base::inherits
[13:33:36.894]                       invokeRestart <- base::invokeRestart
[13:33:36.894]                       is.null <- base::is.null
[13:33:36.894]                       muffled <- FALSE
[13:33:36.894]                       if (inherits(cond, "message")) {
[13:33:36.894]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.894]                         if (muffled) 
[13:33:36.894]                           invokeRestart("muffleMessage")
[13:33:36.894]                       }
[13:33:36.894]                       else if (inherits(cond, "warning")) {
[13:33:36.894]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.894]                         if (muffled) 
[13:33:36.894]                           invokeRestart("muffleWarning")
[13:33:36.894]                       }
[13:33:36.894]                       else if (inherits(cond, "condition")) {
[13:33:36.894]                         if (!is.null(pattern)) {
[13:33:36.894]                           computeRestarts <- base::computeRestarts
[13:33:36.894]                           grepl <- base::grepl
[13:33:36.894]                           restarts <- computeRestarts(cond)
[13:33:36.894]                           for (restart in restarts) {
[13:33:36.894]                             name <- restart$name
[13:33:36.894]                             if (is.null(name)) 
[13:33:36.894]                               next
[13:33:36.894]                             if (!grepl(pattern, name)) 
[13:33:36.894]                               next
[13:33:36.894]                             invokeRestart(restart)
[13:33:36.894]                             muffled <- TRUE
[13:33:36.894]                             break
[13:33:36.894]                           }
[13:33:36.894]                         }
[13:33:36.894]                       }
[13:33:36.894]                       invisible(muffled)
[13:33:36.894]                     }
[13:33:36.894]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.894]                   }
[13:33:36.894]                 }
[13:33:36.894]             }
[13:33:36.894]         }))
[13:33:36.894]     }, error = function(ex) {
[13:33:36.894]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.894]                 ...future.rng), started = ...future.startTime, 
[13:33:36.894]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.894]             version = "1.8"), class = "FutureResult")
[13:33:36.894]     }, finally = {
[13:33:36.894]         if (!identical(...future.workdir, getwd())) 
[13:33:36.894]             setwd(...future.workdir)
[13:33:36.894]         {
[13:33:36.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.894]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.894]             }
[13:33:36.894]             base::options(...future.oldOptions)
[13:33:36.894]             if (.Platform$OS.type == "windows") {
[13:33:36.894]                 old_names <- names(...future.oldEnvVars)
[13:33:36.894]                 envs <- base::Sys.getenv()
[13:33:36.894]                 names <- names(envs)
[13:33:36.894]                 common <- intersect(names, old_names)
[13:33:36.894]                 added <- setdiff(names, old_names)
[13:33:36.894]                 removed <- setdiff(old_names, names)
[13:33:36.894]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.894]                   envs[common]]
[13:33:36.894]                 NAMES <- toupper(changed)
[13:33:36.894]                 args <- list()
[13:33:36.894]                 for (kk in seq_along(NAMES)) {
[13:33:36.894]                   name <- changed[[kk]]
[13:33:36.894]                   NAME <- NAMES[[kk]]
[13:33:36.894]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.894]                     next
[13:33:36.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.894]                 }
[13:33:36.894]                 NAMES <- toupper(added)
[13:33:36.894]                 for (kk in seq_along(NAMES)) {
[13:33:36.894]                   name <- added[[kk]]
[13:33:36.894]                   NAME <- NAMES[[kk]]
[13:33:36.894]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.894]                     next
[13:33:36.894]                   args[[name]] <- ""
[13:33:36.894]                 }
[13:33:36.894]                 NAMES <- toupper(removed)
[13:33:36.894]                 for (kk in seq_along(NAMES)) {
[13:33:36.894]                   name <- removed[[kk]]
[13:33:36.894]                   NAME <- NAMES[[kk]]
[13:33:36.894]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.894]                     next
[13:33:36.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.894]                 }
[13:33:36.894]                 if (length(args) > 0) 
[13:33:36.894]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.894]             }
[13:33:36.894]             else {
[13:33:36.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.894]             }
[13:33:36.894]             {
[13:33:36.894]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.894]                   0L) {
[13:33:36.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.894]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.894]                   base::options(opts)
[13:33:36.894]                 }
[13:33:36.894]                 {
[13:33:36.894]                   {
[13:33:36.894]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:36.894]                     NULL
[13:33:36.894]                   }
[13:33:36.894]                   options(future.plan = NULL)
[13:33:36.894]                   if (is.na(NA_character_)) 
[13:33:36.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.894]                     .init = FALSE)
[13:33:36.894]                 }
[13:33:36.894]             }
[13:33:36.894]         }
[13:33:36.894]     })
[13:33:36.894]     if (TRUE) {
[13:33:36.894]         base::sink(type = "output", split = FALSE)
[13:33:36.894]         if (TRUE) {
[13:33:36.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.894]         }
[13:33:36.894]         else {
[13:33:36.894]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.894]         }
[13:33:36.894]         base::close(...future.stdout)
[13:33:36.894]         ...future.stdout <- NULL
[13:33:36.894]     }
[13:33:36.894]     ...future.result$conditions <- ...future.conditions
[13:33:36.894]     ...future.result$finished <- base::Sys.time()
[13:33:36.894]     ...future.result
[13:33:36.894] }
[13:33:36.896] assign_globals() ...
[13:33:36.896] List of 5
[13:33:36.896]  $ future.call.arguments    : list()
[13:33:36.896]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.896]  $ ...future.FUN            :function (x, ...)  
[13:33:36.896]  $ ...future.elements_ii    :List of 1
[13:33:36.896]   ..$ : num [1:4] 1 3 1 7
[13:33:36.896]  $ ...future.seeds_ii       : NULL
[13:33:36.896]  $ ...future.globals.maxSize: num Inf
[13:33:36.896]  - attr(*, "resolved")= logi FALSE
[13:33:36.896]  - attr(*, "total_size")= num NA
[13:33:36.896]  - attr(*, "where")=List of 5
[13:33:36.896]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.896]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.896]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.896]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.896]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.896]  - attr(*, "already-done")= logi TRUE
[13:33:36.903] - copied ‘future.call.arguments’ to environment
[13:33:36.903] - copied ‘...future.FUN’ to environment
[13:33:36.903] - copied ‘...future.elements_ii’ to environment
[13:33:36.903] - copied ‘...future.seeds_ii’ to environment
[13:33:36.903] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.903] assign_globals() ... done
[13:33:36.903] requestCore(): workers = 2
[13:33:36.905] MulticoreFuture started
[13:33:36.906] - Launch lazy future ... done
[13:33:36.906] run() for ‘MulticoreFuture’ ... done
[13:33:36.907] Created future:
[13:33:36.907] plan(): Setting new future strategy stack:
[13:33:36.907] List of future strategies:
[13:33:36.907] 1. sequential:
[13:33:36.907]    - args: function (..., envir = parent.frame())
[13:33:36.907]    - tweaked: FALSE
[13:33:36.907]    - call: NULL
[13:33:36.908] plan(): nbrOfWorkers() = 1
[13:33:36.911] plan(): Setting new future strategy stack:
[13:33:36.911] List of future strategies:
[13:33:36.911] 1. multicore:
[13:33:36.911]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:36.911]    - tweaked: FALSE
[13:33:36.911]    - call: plan(strategy)
[13:33:36.917] plan(): nbrOfWorkers() = 2
[13:33:36.907] MulticoreFuture:
[13:33:36.907] Label: ‘future_apply-1’
[13:33:36.907] Expression:
[13:33:36.907] {
[13:33:36.907]     do.call(function(...) {
[13:33:36.907]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.907]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.907]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.907]             on.exit(options(oopts), add = TRUE)
[13:33:36.907]         }
[13:33:36.907]         {
[13:33:36.907]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.907]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.907]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.907]             })
[13:33:36.907]         }
[13:33:36.907]     }, args = future.call.arguments)
[13:33:36.907] }
[13:33:36.907] Lazy evaluation: FALSE
[13:33:36.907] Asynchronous evaluation: TRUE
[13:33:36.907] Local evaluation: TRUE
[13:33:36.907] Environment: R_GlobalEnv
[13:33:36.907] Capture standard output: TRUE
[13:33:36.907] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.907] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.907] Packages: 1 packages (‘stats’)
[13:33:36.907] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.907] Resolved: TRUE
[13:33:36.907] Value: <not collected>
[13:33:36.907] Conditions captured: <none>
[13:33:36.907] Early signaling: FALSE
[13:33:36.907] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.907] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.918] Chunk #1 of 2 ... DONE
[13:33:36.918] Chunk #2 of 2 ...
[13:33:36.918]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:36.918]  - seeds: <none>
[13:33:36.919]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.919] getGlobalsAndPackages() ...
[13:33:36.919] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.919] Resolving globals: FALSE
[13:33:36.919] Tweak future expression to call with '...' arguments ...
[13:33:36.920] {
[13:33:36.920]     do.call(function(...) {
[13:33:36.920]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.920]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.920]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.920]             on.exit(options(oopts), add = TRUE)
[13:33:36.920]         }
[13:33:36.920]         {
[13:33:36.920]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.920]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.920]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.920]             })
[13:33:36.920]         }
[13:33:36.920]     }, args = future.call.arguments)
[13:33:36.920] }
[13:33:36.920] Tweak future expression to call with '...' arguments ... DONE
[13:33:36.921] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:36.921] - packages: [1] ‘stats’
[13:33:36.921] getGlobalsAndPackages() ... DONE
[13:33:36.922] run() for ‘Future’ ...
[13:33:36.922] - state: ‘created’
[13:33:36.922] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:36.926] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.927] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:36.927]   - Field: ‘label’
[13:33:36.927]   - Field: ‘local’
[13:33:36.927]   - Field: ‘owner’
[13:33:36.927]   - Field: ‘envir’
[13:33:36.927]   - Field: ‘workers’
[13:33:36.927]   - Field: ‘packages’
[13:33:36.928]   - Field: ‘gc’
[13:33:36.928]   - Field: ‘job’
[13:33:36.928]   - Field: ‘conditions’
[13:33:36.928]   - Field: ‘expr’
[13:33:36.928]   - Field: ‘uuid’
[13:33:36.928]   - Field: ‘seed’
[13:33:36.929]   - Field: ‘version’
[13:33:36.929]   - Field: ‘result’
[13:33:36.929]   - Field: ‘asynchronous’
[13:33:36.929]   - Field: ‘calls’
[13:33:36.929]   - Field: ‘globals’
[13:33:36.929]   - Field: ‘stdout’
[13:33:36.929]   - Field: ‘earlySignal’
[13:33:36.930]   - Field: ‘lazy’
[13:33:36.930]   - Field: ‘state’
[13:33:36.930] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:36.930] - Launch lazy future ...
[13:33:36.930] Packages needed by the future expression (n = 1): ‘stats’
[13:33:36.931] Packages needed by future strategies (n = 0): <none>
[13:33:36.931] {
[13:33:36.931]     {
[13:33:36.931]         {
[13:33:36.931]             ...future.startTime <- base::Sys.time()
[13:33:36.931]             {
[13:33:36.931]                 {
[13:33:36.931]                   {
[13:33:36.931]                     {
[13:33:36.931]                       {
[13:33:36.931]                         base::local({
[13:33:36.931]                           has_future <- base::requireNamespace("future", 
[13:33:36.931]                             quietly = TRUE)
[13:33:36.931]                           if (has_future) {
[13:33:36.931]                             ns <- base::getNamespace("future")
[13:33:36.931]                             version <- ns[[".package"]][["version"]]
[13:33:36.931]                             if (is.null(version)) 
[13:33:36.931]                               version <- utils::packageVersion("future")
[13:33:36.931]                           }
[13:33:36.931]                           else {
[13:33:36.931]                             version <- NULL
[13:33:36.931]                           }
[13:33:36.931]                           if (!has_future || version < "1.8.0") {
[13:33:36.931]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:36.931]                               "", base::R.version$version.string), 
[13:33:36.931]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:36.931]                                 base::R.version$platform, 8 * 
[13:33:36.931]                                   base::.Machine$sizeof.pointer), 
[13:33:36.931]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:36.931]                                 "release", "version")], collapse = " "), 
[13:33:36.931]                               hostname = base::Sys.info()[["nodename"]])
[13:33:36.931]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:36.931]                               info)
[13:33:36.931]                             info <- base::paste(info, collapse = "; ")
[13:33:36.931]                             if (!has_future) {
[13:33:36.931]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:36.931]                                 info)
[13:33:36.931]                             }
[13:33:36.931]                             else {
[13:33:36.931]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:36.931]                                 info, version)
[13:33:36.931]                             }
[13:33:36.931]                             base::stop(msg)
[13:33:36.931]                           }
[13:33:36.931]                         })
[13:33:36.931]                       }
[13:33:36.931]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:36.931]                       base::options(mc.cores = 1L)
[13:33:36.931]                     }
[13:33:36.931]                     base::local({
[13:33:36.931]                       for (pkg in "stats") {
[13:33:36.931]                         base::loadNamespace(pkg)
[13:33:36.931]                         base::library(pkg, character.only = TRUE)
[13:33:36.931]                       }
[13:33:36.931]                     })
[13:33:36.931]                   }
[13:33:36.931]                   ...future.strategy.old <- future::plan("list")
[13:33:36.931]                   options(future.plan = NULL)
[13:33:36.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:36.931]                 }
[13:33:36.931]                 ...future.workdir <- getwd()
[13:33:36.931]             }
[13:33:36.931]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:36.931]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:36.931]         }
[13:33:36.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:36.931]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:36.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:36.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:36.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:36.931]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:36.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:36.931]             base::names(...future.oldOptions))
[13:33:36.931]     }
[13:33:36.931]     if (FALSE) {
[13:33:36.931]     }
[13:33:36.931]     else {
[13:33:36.931]         if (TRUE) {
[13:33:36.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:36.931]                 open = "w")
[13:33:36.931]         }
[13:33:36.931]         else {
[13:33:36.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:36.931]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:36.931]         }
[13:33:36.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:36.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:36.931]             base::sink(type = "output", split = FALSE)
[13:33:36.931]             base::close(...future.stdout)
[13:33:36.931]         }, add = TRUE)
[13:33:36.931]     }
[13:33:36.931]     ...future.frame <- base::sys.nframe()
[13:33:36.931]     ...future.conditions <- base::list()
[13:33:36.931]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:36.931]     if (FALSE) {
[13:33:36.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:36.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:36.931]     }
[13:33:36.931]     ...future.result <- base::tryCatch({
[13:33:36.931]         base::withCallingHandlers({
[13:33:36.931]             ...future.value <- base::withVisible(base::local({
[13:33:36.931]                 withCallingHandlers({
[13:33:36.931]                   {
[13:33:36.931]                     do.call(function(...) {
[13:33:36.931]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.931]                       if (!identical(...future.globals.maxSize.org, 
[13:33:36.931]                         ...future.globals.maxSize)) {
[13:33:36.931]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.931]                         on.exit(options(oopts), add = TRUE)
[13:33:36.931]                       }
[13:33:36.931]                       {
[13:33:36.931]                         lapply(seq_along(...future.elements_ii), 
[13:33:36.931]                           FUN = function(jj) {
[13:33:36.931]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.931]                             ...future.FUN(...future.X_jj, ...)
[13:33:36.931]                           })
[13:33:36.931]                       }
[13:33:36.931]                     }, args = future.call.arguments)
[13:33:36.931]                   }
[13:33:36.931]                 }, immediateCondition = function(cond) {
[13:33:36.931]                   save_rds <- function (object, pathname, ...) 
[13:33:36.931]                   {
[13:33:36.931]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:36.931]                     if (file_test("-f", pathname_tmp)) {
[13:33:36.931]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.931]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:36.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.931]                         fi_tmp[["mtime"]])
[13:33:36.931]                     }
[13:33:36.931]                     tryCatch({
[13:33:36.931]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:36.931]                     }, error = function(ex) {
[13:33:36.931]                       msg <- conditionMessage(ex)
[13:33:36.931]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.931]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:36.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.931]                         fi_tmp[["mtime"]], msg)
[13:33:36.931]                       ex$message <- msg
[13:33:36.931]                       stop(ex)
[13:33:36.931]                     })
[13:33:36.931]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:36.931]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:36.931]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:36.931]                       fi_tmp <- file.info(pathname_tmp)
[13:33:36.931]                       fi <- file.info(pathname)
[13:33:36.931]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:36.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:36.931]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:36.931]                         fi[["size"]], fi[["mtime"]])
[13:33:36.931]                       stop(msg)
[13:33:36.931]                     }
[13:33:36.931]                     invisible(pathname)
[13:33:36.931]                   }
[13:33:36.931]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:36.931]                     rootPath = tempdir()) 
[13:33:36.931]                   {
[13:33:36.931]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:36.931]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:36.931]                       tmpdir = path, fileext = ".rds")
[13:33:36.931]                     save_rds(obj, file)
[13:33:36.931]                   }
[13:33:36.931]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:36.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.931]                   {
[13:33:36.931]                     inherits <- base::inherits
[13:33:36.931]                     invokeRestart <- base::invokeRestart
[13:33:36.931]                     is.null <- base::is.null
[13:33:36.931]                     muffled <- FALSE
[13:33:36.931]                     if (inherits(cond, "message")) {
[13:33:36.931]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:36.931]                       if (muffled) 
[13:33:36.931]                         invokeRestart("muffleMessage")
[13:33:36.931]                     }
[13:33:36.931]                     else if (inherits(cond, "warning")) {
[13:33:36.931]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:36.931]                       if (muffled) 
[13:33:36.931]                         invokeRestart("muffleWarning")
[13:33:36.931]                     }
[13:33:36.931]                     else if (inherits(cond, "condition")) {
[13:33:36.931]                       if (!is.null(pattern)) {
[13:33:36.931]                         computeRestarts <- base::computeRestarts
[13:33:36.931]                         grepl <- base::grepl
[13:33:36.931]                         restarts <- computeRestarts(cond)
[13:33:36.931]                         for (restart in restarts) {
[13:33:36.931]                           name <- restart$name
[13:33:36.931]                           if (is.null(name)) 
[13:33:36.931]                             next
[13:33:36.931]                           if (!grepl(pattern, name)) 
[13:33:36.931]                             next
[13:33:36.931]                           invokeRestart(restart)
[13:33:36.931]                           muffled <- TRUE
[13:33:36.931]                           break
[13:33:36.931]                         }
[13:33:36.931]                       }
[13:33:36.931]                     }
[13:33:36.931]                     invisible(muffled)
[13:33:36.931]                   }
[13:33:36.931]                   muffleCondition(cond)
[13:33:36.931]                 })
[13:33:36.931]             }))
[13:33:36.931]             future::FutureResult(value = ...future.value$value, 
[13:33:36.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.931]                   ...future.rng), globalenv = if (FALSE) 
[13:33:36.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:36.931]                     ...future.globalenv.names))
[13:33:36.931]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:36.931]         }, condition = base::local({
[13:33:36.931]             c <- base::c
[13:33:36.931]             inherits <- base::inherits
[13:33:36.931]             invokeRestart <- base::invokeRestart
[13:33:36.931]             length <- base::length
[13:33:36.931]             list <- base::list
[13:33:36.931]             seq.int <- base::seq.int
[13:33:36.931]             signalCondition <- base::signalCondition
[13:33:36.931]             sys.calls <- base::sys.calls
[13:33:36.931]             `[[` <- base::`[[`
[13:33:36.931]             `+` <- base::`+`
[13:33:36.931]             `<<-` <- base::`<<-`
[13:33:36.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:36.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:36.931]                   3L)]
[13:33:36.931]             }
[13:33:36.931]             function(cond) {
[13:33:36.931]                 is_error <- inherits(cond, "error")
[13:33:36.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:36.931]                   NULL)
[13:33:36.931]                 if (is_error) {
[13:33:36.931]                   sessionInformation <- function() {
[13:33:36.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:36.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:36.931]                       search = base::search(), system = base::Sys.info())
[13:33:36.931]                   }
[13:33:36.931]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:36.931]                     cond$call), session = sessionInformation(), 
[13:33:36.931]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:36.931]                   signalCondition(cond)
[13:33:36.931]                 }
[13:33:36.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:36.931]                 "immediateCondition"))) {
[13:33:36.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:36.931]                   ...future.conditions[[length(...future.conditions) + 
[13:33:36.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:36.931]                   if (TRUE && !signal) {
[13:33:36.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.931]                     {
[13:33:36.931]                       inherits <- base::inherits
[13:33:36.931]                       invokeRestart <- base::invokeRestart
[13:33:36.931]                       is.null <- base::is.null
[13:33:36.931]                       muffled <- FALSE
[13:33:36.931]                       if (inherits(cond, "message")) {
[13:33:36.931]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.931]                         if (muffled) 
[13:33:36.931]                           invokeRestart("muffleMessage")
[13:33:36.931]                       }
[13:33:36.931]                       else if (inherits(cond, "warning")) {
[13:33:36.931]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.931]                         if (muffled) 
[13:33:36.931]                           invokeRestart("muffleWarning")
[13:33:36.931]                       }
[13:33:36.931]                       else if (inherits(cond, "condition")) {
[13:33:36.931]                         if (!is.null(pattern)) {
[13:33:36.931]                           computeRestarts <- base::computeRestarts
[13:33:36.931]                           grepl <- base::grepl
[13:33:36.931]                           restarts <- computeRestarts(cond)
[13:33:36.931]                           for (restart in restarts) {
[13:33:36.931]                             name <- restart$name
[13:33:36.931]                             if (is.null(name)) 
[13:33:36.931]                               next
[13:33:36.931]                             if (!grepl(pattern, name)) 
[13:33:36.931]                               next
[13:33:36.931]                             invokeRestart(restart)
[13:33:36.931]                             muffled <- TRUE
[13:33:36.931]                             break
[13:33:36.931]                           }
[13:33:36.931]                         }
[13:33:36.931]                       }
[13:33:36.931]                       invisible(muffled)
[13:33:36.931]                     }
[13:33:36.931]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.931]                   }
[13:33:36.931]                 }
[13:33:36.931]                 else {
[13:33:36.931]                   if (TRUE) {
[13:33:36.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:36.931]                     {
[13:33:36.931]                       inherits <- base::inherits
[13:33:36.931]                       invokeRestart <- base::invokeRestart
[13:33:36.931]                       is.null <- base::is.null
[13:33:36.931]                       muffled <- FALSE
[13:33:36.931]                       if (inherits(cond, "message")) {
[13:33:36.931]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:36.931]                         if (muffled) 
[13:33:36.931]                           invokeRestart("muffleMessage")
[13:33:36.931]                       }
[13:33:36.931]                       else if (inherits(cond, "warning")) {
[13:33:36.931]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:36.931]                         if (muffled) 
[13:33:36.931]                           invokeRestart("muffleWarning")
[13:33:36.931]                       }
[13:33:36.931]                       else if (inherits(cond, "condition")) {
[13:33:36.931]                         if (!is.null(pattern)) {
[13:33:36.931]                           computeRestarts <- base::computeRestarts
[13:33:36.931]                           grepl <- base::grepl
[13:33:36.931]                           restarts <- computeRestarts(cond)
[13:33:36.931]                           for (restart in restarts) {
[13:33:36.931]                             name <- restart$name
[13:33:36.931]                             if (is.null(name)) 
[13:33:36.931]                               next
[13:33:36.931]                             if (!grepl(pattern, name)) 
[13:33:36.931]                               next
[13:33:36.931]                             invokeRestart(restart)
[13:33:36.931]                             muffled <- TRUE
[13:33:36.931]                             break
[13:33:36.931]                           }
[13:33:36.931]                         }
[13:33:36.931]                       }
[13:33:36.931]                       invisible(muffled)
[13:33:36.931]                     }
[13:33:36.931]                     muffleCondition(cond, pattern = "^muffle")
[13:33:36.931]                   }
[13:33:36.931]                 }
[13:33:36.931]             }
[13:33:36.931]         }))
[13:33:36.931]     }, error = function(ex) {
[13:33:36.931]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:36.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:36.931]                 ...future.rng), started = ...future.startTime, 
[13:33:36.931]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:36.931]             version = "1.8"), class = "FutureResult")
[13:33:36.931]     }, finally = {
[13:33:36.931]         if (!identical(...future.workdir, getwd())) 
[13:33:36.931]             setwd(...future.workdir)
[13:33:36.931]         {
[13:33:36.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:36.931]                 ...future.oldOptions$nwarnings <- NULL
[13:33:36.931]             }
[13:33:36.931]             base::options(...future.oldOptions)
[13:33:36.931]             if (.Platform$OS.type == "windows") {
[13:33:36.931]                 old_names <- names(...future.oldEnvVars)
[13:33:36.931]                 envs <- base::Sys.getenv()
[13:33:36.931]                 names <- names(envs)
[13:33:36.931]                 common <- intersect(names, old_names)
[13:33:36.931]                 added <- setdiff(names, old_names)
[13:33:36.931]                 removed <- setdiff(old_names, names)
[13:33:36.931]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:36.931]                   envs[common]]
[13:33:36.931]                 NAMES <- toupper(changed)
[13:33:36.931]                 args <- list()
[13:33:36.931]                 for (kk in seq_along(NAMES)) {
[13:33:36.931]                   name <- changed[[kk]]
[13:33:36.931]                   NAME <- NAMES[[kk]]
[13:33:36.931]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.931]                     next
[13:33:36.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.931]                 }
[13:33:36.931]                 NAMES <- toupper(added)
[13:33:36.931]                 for (kk in seq_along(NAMES)) {
[13:33:36.931]                   name <- added[[kk]]
[13:33:36.931]                   NAME <- NAMES[[kk]]
[13:33:36.931]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.931]                     next
[13:33:36.931]                   args[[name]] <- ""
[13:33:36.931]                 }
[13:33:36.931]                 NAMES <- toupper(removed)
[13:33:36.931]                 for (kk in seq_along(NAMES)) {
[13:33:36.931]                   name <- removed[[kk]]
[13:33:36.931]                   NAME <- NAMES[[kk]]
[13:33:36.931]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:36.931]                     next
[13:33:36.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:36.931]                 }
[13:33:36.931]                 if (length(args) > 0) 
[13:33:36.931]                   base::do.call(base::Sys.setenv, args = args)
[13:33:36.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:36.931]             }
[13:33:36.931]             else {
[13:33:36.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:36.931]             }
[13:33:36.931]             {
[13:33:36.931]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:36.931]                   0L) {
[13:33:36.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:36.931]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:36.931]                   base::options(opts)
[13:33:36.931]                 }
[13:33:36.931]                 {
[13:33:36.931]                   {
[13:33:36.931]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:36.931]                     NULL
[13:33:36.931]                   }
[13:33:36.931]                   options(future.plan = NULL)
[13:33:36.931]                   if (is.na(NA_character_)) 
[13:33:36.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:36.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:36.931]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:36.931]                     .init = FALSE)
[13:33:36.931]                 }
[13:33:36.931]             }
[13:33:36.931]         }
[13:33:36.931]     })
[13:33:36.931]     if (TRUE) {
[13:33:36.931]         base::sink(type = "output", split = FALSE)
[13:33:36.931]         if (TRUE) {
[13:33:36.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:36.931]         }
[13:33:36.931]         else {
[13:33:36.931]             ...future.result["stdout"] <- base::list(NULL)
[13:33:36.931]         }
[13:33:36.931]         base::close(...future.stdout)
[13:33:36.931]         ...future.stdout <- NULL
[13:33:36.931]     }
[13:33:36.931]     ...future.result$conditions <- ...future.conditions
[13:33:36.931]     ...future.result$finished <- base::Sys.time()
[13:33:36.931]     ...future.result
[13:33:36.931] }
[13:33:36.935] assign_globals() ...
[13:33:36.935] List of 5
[13:33:36.935]  $ future.call.arguments    : list()
[13:33:36.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.935]  $ ...future.FUN            :function (x, ...)  
[13:33:36.935]  $ ...future.elements_ii    :List of 1
[13:33:36.935]   ..$ : num [1:4] 2 4 6 8
[13:33:36.935]  $ ...future.seeds_ii       : NULL
[13:33:36.935]  $ ...future.globals.maxSize: num Inf
[13:33:36.935]  - attr(*, "resolved")= logi FALSE
[13:33:36.935]  - attr(*, "total_size")= num NA
[13:33:36.935]  - attr(*, "where")=List of 5
[13:33:36.935]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:36.935]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:36.935]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:36.935]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:36.935]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:36.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.935]  - attr(*, "already-done")= logi TRUE
[13:33:36.942] - copied ‘future.call.arguments’ to environment
[13:33:36.942] - copied ‘...future.FUN’ to environment
[13:33:36.942] - copied ‘...future.elements_ii’ to environment
[13:33:36.943] - copied ‘...future.seeds_ii’ to environment
[13:33:36.943] - copied ‘...future.globals.maxSize’ to environment
[13:33:36.943] assign_globals() ... done
[13:33:36.943] requestCore(): workers = 2
[13:33:36.945] MulticoreFuture started
[13:33:36.945] - Launch lazy future ... done
[13:33:36.945] run() for ‘MulticoreFuture’ ... done
[13:33:36.946] Created future:
[13:33:36.946] plan(): Setting new future strategy stack:
[13:33:36.947] List of future strategies:
[13:33:36.947] 1. sequential:
[13:33:36.947]    - args: function (..., envir = parent.frame())
[13:33:36.947]    - tweaked: FALSE
[13:33:36.947]    - call: NULL
[13:33:36.948] plan(): nbrOfWorkers() = 1
[13:33:36.954] plan(): Setting new future strategy stack:
[13:33:36.954] List of future strategies:
[13:33:36.954] 1. multicore:
[13:33:36.954]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:36.954]    - tweaked: FALSE
[13:33:36.954]    - call: plan(strategy)
[13:33:36.961] plan(): nbrOfWorkers() = 2
[13:33:36.946] MulticoreFuture:
[13:33:36.946] Label: ‘future_apply-2’
[13:33:36.946] Expression:
[13:33:36.946] {
[13:33:36.946]     do.call(function(...) {
[13:33:36.946]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:36.946]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:36.946]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:36.946]             on.exit(options(oopts), add = TRUE)
[13:33:36.946]         }
[13:33:36.946]         {
[13:33:36.946]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:36.946]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:36.946]                 ...future.FUN(...future.X_jj, ...)
[13:33:36.946]             })
[13:33:36.946]         }
[13:33:36.946]     }, args = future.call.arguments)
[13:33:36.946] }
[13:33:36.946] Lazy evaluation: FALSE
[13:33:36.946] Asynchronous evaluation: TRUE
[13:33:36.946] Local evaluation: TRUE
[13:33:36.946] Environment: R_GlobalEnv
[13:33:36.946] Capture standard output: TRUE
[13:33:36.946] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:36.946] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:36.946] Packages: 1 packages (‘stats’)
[13:33:36.946] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:36.946] Resolved: TRUE
[13:33:36.946] Value: <not collected>
[13:33:36.946] Conditions captured: <none>
[13:33:36.946] Early signaling: FALSE
[13:33:36.946] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:36.946] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:36.962] Chunk #2 of 2 ... DONE
[13:33:36.963] Launching 2 futures (chunks) ... DONE
[13:33:36.963] Resolving 2 futures (chunks) ...
[13:33:36.963] resolve() on list ...
[13:33:36.964]  recursive: 0
[13:33:36.964]  length: 2
[13:33:36.964] 
[13:33:36.964] Future #1
[13:33:36.965] result() for MulticoreFuture ...
[13:33:36.966] result() for MulticoreFuture ...
[13:33:36.966] result() for MulticoreFuture ... done
[13:33:36.966] result() for MulticoreFuture ... done
[13:33:36.967] result() for MulticoreFuture ...
[13:33:36.967] result() for MulticoreFuture ... done
[13:33:36.967] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:36.967] - nx: 2
[13:33:36.968] - relay: TRUE
[13:33:36.968] - stdout: TRUE
[13:33:36.968] - signal: TRUE
[13:33:36.968] - resignal: FALSE
[13:33:36.968] - force: TRUE
[13:33:36.969] - relayed: [n=2] FALSE, FALSE
[13:33:36.969] - queued futures: [n=2] FALSE, FALSE
[13:33:36.969]  - until=1
[13:33:36.969]  - relaying element #1
[13:33:36.970] result() for MulticoreFuture ...
[13:33:36.970] result() for MulticoreFuture ... done
[13:33:36.970] result() for MulticoreFuture ...
[13:33:36.970] result() for MulticoreFuture ... done
[13:33:36.970] result() for MulticoreFuture ...
[13:33:36.970] result() for MulticoreFuture ... done
[13:33:36.970] result() for MulticoreFuture ...
[13:33:36.971] result() for MulticoreFuture ... done
[13:33:36.971] - relayed: [n=2] TRUE, FALSE
[13:33:36.971] - queued futures: [n=2] TRUE, FALSE
[13:33:36.971] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:36.971]  length: 1 (resolved future 1)
[13:33:36.972] Future #2
[13:33:36.972] result() for MulticoreFuture ...
[13:33:36.973] result() for MulticoreFuture ...
[13:33:36.973] result() for MulticoreFuture ... done
[13:33:36.973] result() for MulticoreFuture ... done
[13:33:36.973] result() for MulticoreFuture ...
[13:33:36.973] result() for MulticoreFuture ... done
[13:33:36.974] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:36.974] - nx: 2
[13:33:36.974] - relay: TRUE
[13:33:36.974] - stdout: TRUE
[13:33:36.974] - signal: TRUE
[13:33:36.974] - resignal: FALSE
[13:33:36.974] - force: TRUE
[13:33:36.974] - relayed: [n=2] TRUE, FALSE
[13:33:36.975] - queued futures: [n=2] TRUE, FALSE
[13:33:36.975]  - until=2
[13:33:36.975]  - relaying element #2
[13:33:36.975] result() for MulticoreFuture ...
[13:33:36.975] result() for MulticoreFuture ... done
[13:33:36.975] result() for MulticoreFuture ...
[13:33:36.975] result() for MulticoreFuture ... done
[13:33:36.976] result() for MulticoreFuture ...
[13:33:36.976] result() for MulticoreFuture ... done
[13:33:36.976] result() for MulticoreFuture ...
[13:33:36.976] result() for MulticoreFuture ... done
[13:33:36.976] - relayed: [n=2] TRUE, TRUE
[13:33:36.976] - queued futures: [n=2] TRUE, TRUE
[13:33:36.976] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:36.976]  length: 0 (resolved future 2)
[13:33:36.976] Relaying remaining futures
[13:33:36.976] signalConditionsASAP(NULL, pos=0) ...
[13:33:36.977] - nx: 2
[13:33:36.977] - relay: TRUE
[13:33:36.977] - stdout: TRUE
[13:33:36.977] - signal: TRUE
[13:33:36.977] - resignal: FALSE
[13:33:36.977] - force: TRUE
[13:33:36.977] - relayed: [n=2] TRUE, TRUE
[13:33:36.977] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:36.977] - relayed: [n=2] TRUE, TRUE
[13:33:36.978] - queued futures: [n=2] TRUE, TRUE
[13:33:36.978] signalConditionsASAP(NULL, pos=0) ... done
[13:33:36.978] resolve() on list ... DONE
[13:33:36.978] result() for MulticoreFuture ...
[13:33:36.978] result() for MulticoreFuture ... done
[13:33:36.978] result() for MulticoreFuture ...
[13:33:36.978] result() for MulticoreFuture ... done
[13:33:36.978] result() for MulticoreFuture ...
[13:33:36.978] result() for MulticoreFuture ... done
[13:33:36.979] result() for MulticoreFuture ...
[13:33:36.979] result() for MulticoreFuture ... done
[13:33:36.979]  - Number of value chunks collected: 2
[13:33:36.979] Resolving 2 futures (chunks) ... DONE
[13:33:36.979] Reducing values from 2 chunks ...
[13:33:36.979]  - Number of values collected after concatenation: 2
[13:33:36.979]  - Number of values expected: 2
[13:33:36.979] Reducing values from 2 chunks ... DONE
[13:33:36.979] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[13:33:36.980] getGlobalsAndPackagesXApply() ...
[13:33:36.980]  - future.globals: TRUE
[13:33:36.980] getGlobalsAndPackages() ...
[13:33:36.980] Searching for globals...
[13:33:36.982] - globals found: [1] ‘FUN’
[13:33:36.982] Searching for globals ... DONE
[13:33:36.982] Resolving globals: FALSE
[13:33:36.982] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:36.983] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:36.983] - globals: [1] ‘FUN’
[13:33:36.983] 
[13:33:36.983] getGlobalsAndPackages() ... DONE
[13:33:36.983]  - globals found/used: [n=1] ‘FUN’
[13:33:36.983]  - needed namespaces: [n=0] 
[13:33:36.983] Finding globals ... DONE
[13:33:36.983]  - use_args: TRUE
[13:33:36.984]  - Getting '...' globals ...
[13:33:36.984] resolve() on list ...
[13:33:36.984]  recursive: 0
[13:33:36.984]  length: 1
[13:33:36.984]  elements: ‘...’
[13:33:36.984]  length: 0 (resolved future 1)
[13:33:36.984] resolve() on list ... DONE
[13:33:36.985]    - '...' content: [n=0] 
[13:33:36.985] List of 1
[13:33:36.985]  $ ...: list()
[13:33:36.985]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.985]  - attr(*, "where")=List of 1
[13:33:36.985]   ..$ ...:<environment: 0x55b94894b128> 
[13:33:36.985]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.985]  - attr(*, "resolved")= logi TRUE
[13:33:36.985]  - attr(*, "total_size")= num NA
[13:33:36.987]  - Getting '...' globals ... DONE
[13:33:36.988] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:36.988] List of 2
[13:33:36.988]  $ ...future.FUN:function (x)  
[13:33:36.988]  $ ...          : list()
[13:33:36.988]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:36.988]  - attr(*, "where")=List of 2
[13:33:36.988]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:36.988]   ..$ ...          :<environment: 0x55b94894b128> 
[13:33:36.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:36.988]  - attr(*, "resolved")= logi FALSE
[13:33:36.988]  - attr(*, "total_size")= num 848
[13:33:36.992] Packages to be attached in all futures: [n=0] 
[13:33:36.992] getGlobalsAndPackagesXApply() ... DONE
[13:33:36.996] future_lapply() ...
[13:33:37.000] Number of chunks: 2
[13:33:37.000] getGlobalsAndPackagesXApply() ...
[13:33:37.000]  - future.globals: <name-value list> with names ‘list()’
[13:33:37.000]  - use_args: TRUE
[13:33:37.000] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:37.000] List of 2
[13:33:37.000]  $ ...          : list()
[13:33:37.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.000]  $ ...future.FUN:function (x)  
[13:33:37.000]  - attr(*, "where")=List of 2
[13:33:37.000]   ..$ ...          :<environment: 0x55b94894b128> 
[13:33:37.000]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:37.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.000]  - attr(*, "resolved")= logi FALSE
[13:33:37.000]  - attr(*, "total_size")= num NA
[13:33:37.004] Packages to be attached in all futures: [n=0] 
[13:33:37.004] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.004] Number of futures (= number of chunks): 2
[13:33:37.004] Launching 2 futures (chunks) ...
[13:33:37.004] Chunk #1 of 2 ...
[13:33:37.004]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.004]  - seeds: <none>
[13:33:37.004]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.005] getGlobalsAndPackages() ...
[13:33:37.005] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.005] Resolving globals: FALSE
[13:33:37.005] Tweak future expression to call with '...' arguments ...
[13:33:37.005] {
[13:33:37.005]     do.call(function(...) {
[13:33:37.005]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.005]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.005]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.005]             on.exit(options(oopts), add = TRUE)
[13:33:37.005]         }
[13:33:37.005]         {
[13:33:37.005]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.005]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.005]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.005]             })
[13:33:37.005]         }
[13:33:37.005]     }, args = future.call.arguments)
[13:33:37.005] }
[13:33:37.005] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.006] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.006] 
[13:33:37.006] getGlobalsAndPackages() ... DONE
[13:33:37.006] run() for ‘Future’ ...
[13:33:37.006] - state: ‘created’
[13:33:37.006] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.010] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.010] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.010]   - Field: ‘label’
[13:33:37.010]   - Field: ‘local’
[13:33:37.010]   - Field: ‘owner’
[13:33:37.010]   - Field: ‘envir’
[13:33:37.011]   - Field: ‘workers’
[13:33:37.011]   - Field: ‘packages’
[13:33:37.011]   - Field: ‘gc’
[13:33:37.011]   - Field: ‘job’
[13:33:37.011]   - Field: ‘conditions’
[13:33:37.011]   - Field: ‘expr’
[13:33:37.011]   - Field: ‘uuid’
[13:33:37.011]   - Field: ‘seed’
[13:33:37.011]   - Field: ‘version’
[13:33:37.011]   - Field: ‘result’
[13:33:37.011]   - Field: ‘asynchronous’
[13:33:37.012]   - Field: ‘calls’
[13:33:37.012]   - Field: ‘globals’
[13:33:37.012]   - Field: ‘stdout’
[13:33:37.012]   - Field: ‘earlySignal’
[13:33:37.012]   - Field: ‘lazy’
[13:33:37.012]   - Field: ‘state’
[13:33:37.012] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.012] - Launch lazy future ...
[13:33:37.012] Packages needed by the future expression (n = 0): <none>
[13:33:37.013] Packages needed by future strategies (n = 0): <none>
[13:33:37.013] {
[13:33:37.013]     {
[13:33:37.013]         {
[13:33:37.013]             ...future.startTime <- base::Sys.time()
[13:33:37.013]             {
[13:33:37.013]                 {
[13:33:37.013]                   {
[13:33:37.013]                     {
[13:33:37.013]                       base::local({
[13:33:37.013]                         has_future <- base::requireNamespace("future", 
[13:33:37.013]                           quietly = TRUE)
[13:33:37.013]                         if (has_future) {
[13:33:37.013]                           ns <- base::getNamespace("future")
[13:33:37.013]                           version <- ns[[".package"]][["version"]]
[13:33:37.013]                           if (is.null(version)) 
[13:33:37.013]                             version <- utils::packageVersion("future")
[13:33:37.013]                         }
[13:33:37.013]                         else {
[13:33:37.013]                           version <- NULL
[13:33:37.013]                         }
[13:33:37.013]                         if (!has_future || version < "1.8.0") {
[13:33:37.013]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.013]                             "", base::R.version$version.string), 
[13:33:37.013]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.013]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.013]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.013]                               "release", "version")], collapse = " "), 
[13:33:37.013]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.013]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.013]                             info)
[13:33:37.013]                           info <- base::paste(info, collapse = "; ")
[13:33:37.013]                           if (!has_future) {
[13:33:37.013]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.013]                               info)
[13:33:37.013]                           }
[13:33:37.013]                           else {
[13:33:37.013]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.013]                               info, version)
[13:33:37.013]                           }
[13:33:37.013]                           base::stop(msg)
[13:33:37.013]                         }
[13:33:37.013]                       })
[13:33:37.013]                     }
[13:33:37.013]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.013]                     base::options(mc.cores = 1L)
[13:33:37.013]                   }
[13:33:37.013]                   ...future.strategy.old <- future::plan("list")
[13:33:37.013]                   options(future.plan = NULL)
[13:33:37.013]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.013]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.013]                 }
[13:33:37.013]                 ...future.workdir <- getwd()
[13:33:37.013]             }
[13:33:37.013]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.013]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.013]         }
[13:33:37.013]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.013]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.013]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.013]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.013]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.013]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.013]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.013]             base::names(...future.oldOptions))
[13:33:37.013]     }
[13:33:37.013]     if (FALSE) {
[13:33:37.013]     }
[13:33:37.013]     else {
[13:33:37.013]         if (TRUE) {
[13:33:37.013]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.013]                 open = "w")
[13:33:37.013]         }
[13:33:37.013]         else {
[13:33:37.013]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.013]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.013]         }
[13:33:37.013]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.013]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.013]             base::sink(type = "output", split = FALSE)
[13:33:37.013]             base::close(...future.stdout)
[13:33:37.013]         }, add = TRUE)
[13:33:37.013]     }
[13:33:37.013]     ...future.frame <- base::sys.nframe()
[13:33:37.013]     ...future.conditions <- base::list()
[13:33:37.013]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.013]     if (FALSE) {
[13:33:37.013]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.013]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.013]     }
[13:33:37.013]     ...future.result <- base::tryCatch({
[13:33:37.013]         base::withCallingHandlers({
[13:33:37.013]             ...future.value <- base::withVisible(base::local({
[13:33:37.013]                 withCallingHandlers({
[13:33:37.013]                   {
[13:33:37.013]                     do.call(function(...) {
[13:33:37.013]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.013]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.013]                         ...future.globals.maxSize)) {
[13:33:37.013]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.013]                         on.exit(options(oopts), add = TRUE)
[13:33:37.013]                       }
[13:33:37.013]                       {
[13:33:37.013]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.013]                           FUN = function(jj) {
[13:33:37.013]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.013]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.013]                           })
[13:33:37.013]                       }
[13:33:37.013]                     }, args = future.call.arguments)
[13:33:37.013]                   }
[13:33:37.013]                 }, immediateCondition = function(cond) {
[13:33:37.013]                   save_rds <- function (object, pathname, ...) 
[13:33:37.013]                   {
[13:33:37.013]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.013]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.013]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.013]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.013]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.013]                         fi_tmp[["mtime"]])
[13:33:37.013]                     }
[13:33:37.013]                     tryCatch({
[13:33:37.013]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.013]                     }, error = function(ex) {
[13:33:37.013]                       msg <- conditionMessage(ex)
[13:33:37.013]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.013]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.013]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.013]                         fi_tmp[["mtime"]], msg)
[13:33:37.013]                       ex$message <- msg
[13:33:37.013]                       stop(ex)
[13:33:37.013]                     })
[13:33:37.013]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.013]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.013]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.013]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.013]                       fi <- file.info(pathname)
[13:33:37.013]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.013]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.013]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.013]                         fi[["size"]], fi[["mtime"]])
[13:33:37.013]                       stop(msg)
[13:33:37.013]                     }
[13:33:37.013]                     invisible(pathname)
[13:33:37.013]                   }
[13:33:37.013]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.013]                     rootPath = tempdir()) 
[13:33:37.013]                   {
[13:33:37.013]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.013]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.013]                       tmpdir = path, fileext = ".rds")
[13:33:37.013]                     save_rds(obj, file)
[13:33:37.013]                   }
[13:33:37.013]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.013]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.013]                   {
[13:33:37.013]                     inherits <- base::inherits
[13:33:37.013]                     invokeRestart <- base::invokeRestart
[13:33:37.013]                     is.null <- base::is.null
[13:33:37.013]                     muffled <- FALSE
[13:33:37.013]                     if (inherits(cond, "message")) {
[13:33:37.013]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.013]                       if (muffled) 
[13:33:37.013]                         invokeRestart("muffleMessage")
[13:33:37.013]                     }
[13:33:37.013]                     else if (inherits(cond, "warning")) {
[13:33:37.013]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.013]                       if (muffled) 
[13:33:37.013]                         invokeRestart("muffleWarning")
[13:33:37.013]                     }
[13:33:37.013]                     else if (inherits(cond, "condition")) {
[13:33:37.013]                       if (!is.null(pattern)) {
[13:33:37.013]                         computeRestarts <- base::computeRestarts
[13:33:37.013]                         grepl <- base::grepl
[13:33:37.013]                         restarts <- computeRestarts(cond)
[13:33:37.013]                         for (restart in restarts) {
[13:33:37.013]                           name <- restart$name
[13:33:37.013]                           if (is.null(name)) 
[13:33:37.013]                             next
[13:33:37.013]                           if (!grepl(pattern, name)) 
[13:33:37.013]                             next
[13:33:37.013]                           invokeRestart(restart)
[13:33:37.013]                           muffled <- TRUE
[13:33:37.013]                           break
[13:33:37.013]                         }
[13:33:37.013]                       }
[13:33:37.013]                     }
[13:33:37.013]                     invisible(muffled)
[13:33:37.013]                   }
[13:33:37.013]                   muffleCondition(cond)
[13:33:37.013]                 })
[13:33:37.013]             }))
[13:33:37.013]             future::FutureResult(value = ...future.value$value, 
[13:33:37.013]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.013]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.013]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.013]                     ...future.globalenv.names))
[13:33:37.013]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.013]         }, condition = base::local({
[13:33:37.013]             c <- base::c
[13:33:37.013]             inherits <- base::inherits
[13:33:37.013]             invokeRestart <- base::invokeRestart
[13:33:37.013]             length <- base::length
[13:33:37.013]             list <- base::list
[13:33:37.013]             seq.int <- base::seq.int
[13:33:37.013]             signalCondition <- base::signalCondition
[13:33:37.013]             sys.calls <- base::sys.calls
[13:33:37.013]             `[[` <- base::`[[`
[13:33:37.013]             `+` <- base::`+`
[13:33:37.013]             `<<-` <- base::`<<-`
[13:33:37.013]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.013]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.013]                   3L)]
[13:33:37.013]             }
[13:33:37.013]             function(cond) {
[13:33:37.013]                 is_error <- inherits(cond, "error")
[13:33:37.013]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.013]                   NULL)
[13:33:37.013]                 if (is_error) {
[13:33:37.013]                   sessionInformation <- function() {
[13:33:37.013]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.013]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.013]                       search = base::search(), system = base::Sys.info())
[13:33:37.013]                   }
[13:33:37.013]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.013]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.013]                     cond$call), session = sessionInformation(), 
[13:33:37.013]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.013]                   signalCondition(cond)
[13:33:37.013]                 }
[13:33:37.013]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.013]                 "immediateCondition"))) {
[13:33:37.013]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.013]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.013]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.013]                   if (TRUE && !signal) {
[13:33:37.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.013]                     {
[13:33:37.013]                       inherits <- base::inherits
[13:33:37.013]                       invokeRestart <- base::invokeRestart
[13:33:37.013]                       is.null <- base::is.null
[13:33:37.013]                       muffled <- FALSE
[13:33:37.013]                       if (inherits(cond, "message")) {
[13:33:37.013]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.013]                         if (muffled) 
[13:33:37.013]                           invokeRestart("muffleMessage")
[13:33:37.013]                       }
[13:33:37.013]                       else if (inherits(cond, "warning")) {
[13:33:37.013]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.013]                         if (muffled) 
[13:33:37.013]                           invokeRestart("muffleWarning")
[13:33:37.013]                       }
[13:33:37.013]                       else if (inherits(cond, "condition")) {
[13:33:37.013]                         if (!is.null(pattern)) {
[13:33:37.013]                           computeRestarts <- base::computeRestarts
[13:33:37.013]                           grepl <- base::grepl
[13:33:37.013]                           restarts <- computeRestarts(cond)
[13:33:37.013]                           for (restart in restarts) {
[13:33:37.013]                             name <- restart$name
[13:33:37.013]                             if (is.null(name)) 
[13:33:37.013]                               next
[13:33:37.013]                             if (!grepl(pattern, name)) 
[13:33:37.013]                               next
[13:33:37.013]                             invokeRestart(restart)
[13:33:37.013]                             muffled <- TRUE
[13:33:37.013]                             break
[13:33:37.013]                           }
[13:33:37.013]                         }
[13:33:37.013]                       }
[13:33:37.013]                       invisible(muffled)
[13:33:37.013]                     }
[13:33:37.013]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.013]                   }
[13:33:37.013]                 }
[13:33:37.013]                 else {
[13:33:37.013]                   if (TRUE) {
[13:33:37.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.013]                     {
[13:33:37.013]                       inherits <- base::inherits
[13:33:37.013]                       invokeRestart <- base::invokeRestart
[13:33:37.013]                       is.null <- base::is.null
[13:33:37.013]                       muffled <- FALSE
[13:33:37.013]                       if (inherits(cond, "message")) {
[13:33:37.013]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.013]                         if (muffled) 
[13:33:37.013]                           invokeRestart("muffleMessage")
[13:33:37.013]                       }
[13:33:37.013]                       else if (inherits(cond, "warning")) {
[13:33:37.013]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.013]                         if (muffled) 
[13:33:37.013]                           invokeRestart("muffleWarning")
[13:33:37.013]                       }
[13:33:37.013]                       else if (inherits(cond, "condition")) {
[13:33:37.013]                         if (!is.null(pattern)) {
[13:33:37.013]                           computeRestarts <- base::computeRestarts
[13:33:37.013]                           grepl <- base::grepl
[13:33:37.013]                           restarts <- computeRestarts(cond)
[13:33:37.013]                           for (restart in restarts) {
[13:33:37.013]                             name <- restart$name
[13:33:37.013]                             if (is.null(name)) 
[13:33:37.013]                               next
[13:33:37.013]                             if (!grepl(pattern, name)) 
[13:33:37.013]                               next
[13:33:37.013]                             invokeRestart(restart)
[13:33:37.013]                             muffled <- TRUE
[13:33:37.013]                             break
[13:33:37.013]                           }
[13:33:37.013]                         }
[13:33:37.013]                       }
[13:33:37.013]                       invisible(muffled)
[13:33:37.013]                     }
[13:33:37.013]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.013]                   }
[13:33:37.013]                 }
[13:33:37.013]             }
[13:33:37.013]         }))
[13:33:37.013]     }, error = function(ex) {
[13:33:37.013]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.013]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.013]                 ...future.rng), started = ...future.startTime, 
[13:33:37.013]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.013]             version = "1.8"), class = "FutureResult")
[13:33:37.013]     }, finally = {
[13:33:37.013]         if (!identical(...future.workdir, getwd())) 
[13:33:37.013]             setwd(...future.workdir)
[13:33:37.013]         {
[13:33:37.013]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.013]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.013]             }
[13:33:37.013]             base::options(...future.oldOptions)
[13:33:37.013]             if (.Platform$OS.type == "windows") {
[13:33:37.013]                 old_names <- names(...future.oldEnvVars)
[13:33:37.013]                 envs <- base::Sys.getenv()
[13:33:37.013]                 names <- names(envs)
[13:33:37.013]                 common <- intersect(names, old_names)
[13:33:37.013]                 added <- setdiff(names, old_names)
[13:33:37.013]                 removed <- setdiff(old_names, names)
[13:33:37.013]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.013]                   envs[common]]
[13:33:37.013]                 NAMES <- toupper(changed)
[13:33:37.013]                 args <- list()
[13:33:37.013]                 for (kk in seq_along(NAMES)) {
[13:33:37.013]                   name <- changed[[kk]]
[13:33:37.013]                   NAME <- NAMES[[kk]]
[13:33:37.013]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.013]                     next
[13:33:37.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.013]                 }
[13:33:37.013]                 NAMES <- toupper(added)
[13:33:37.013]                 for (kk in seq_along(NAMES)) {
[13:33:37.013]                   name <- added[[kk]]
[13:33:37.013]                   NAME <- NAMES[[kk]]
[13:33:37.013]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.013]                     next
[13:33:37.013]                   args[[name]] <- ""
[13:33:37.013]                 }
[13:33:37.013]                 NAMES <- toupper(removed)
[13:33:37.013]                 for (kk in seq_along(NAMES)) {
[13:33:37.013]                   name <- removed[[kk]]
[13:33:37.013]                   NAME <- NAMES[[kk]]
[13:33:37.013]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.013]                     next
[13:33:37.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.013]                 }
[13:33:37.013]                 if (length(args) > 0) 
[13:33:37.013]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.013]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.013]             }
[13:33:37.013]             else {
[13:33:37.013]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.013]             }
[13:33:37.013]             {
[13:33:37.013]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.013]                   0L) {
[13:33:37.013]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.013]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.013]                   base::options(opts)
[13:33:37.013]                 }
[13:33:37.013]                 {
[13:33:37.013]                   {
[13:33:37.013]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.013]                     NULL
[13:33:37.013]                   }
[13:33:37.013]                   options(future.plan = NULL)
[13:33:37.013]                   if (is.na(NA_character_)) 
[13:33:37.013]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.013]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.013]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.013]                     .init = FALSE)
[13:33:37.013]                 }
[13:33:37.013]             }
[13:33:37.013]         }
[13:33:37.013]     })
[13:33:37.013]     if (TRUE) {
[13:33:37.013]         base::sink(type = "output", split = FALSE)
[13:33:37.013]         if (TRUE) {
[13:33:37.013]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.013]         }
[13:33:37.013]         else {
[13:33:37.013]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.013]         }
[13:33:37.013]         base::close(...future.stdout)
[13:33:37.013]         ...future.stdout <- NULL
[13:33:37.013]     }
[13:33:37.013]     ...future.result$conditions <- ...future.conditions
[13:33:37.013]     ...future.result$finished <- base::Sys.time()
[13:33:37.013]     ...future.result
[13:33:37.013] }
[13:33:37.016] assign_globals() ...
[13:33:37.016] List of 5
[13:33:37.016]  $ future.call.arguments    : list()
[13:33:37.016]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.016]  $ ...future.FUN            :function (x)  
[13:33:37.016]  $ ...future.elements_ii    :List of 1
[13:33:37.016]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:33:37.016]  $ ...future.seeds_ii       : NULL
[13:33:37.016]  $ ...future.globals.maxSize: num Inf
[13:33:37.016]  - attr(*, "resolved")= logi FALSE
[13:33:37.016]  - attr(*, "total_size")= num NA
[13:33:37.016]  - attr(*, "where")=List of 5
[13:33:37.016]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.016]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.016]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.016]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.016]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.016]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.016]  - attr(*, "already-done")= logi TRUE
[13:33:37.021] - copied ‘future.call.arguments’ to environment
[13:33:37.021] - copied ‘...future.FUN’ to environment
[13:33:37.021] - copied ‘...future.elements_ii’ to environment
[13:33:37.021] - copied ‘...future.seeds_ii’ to environment
[13:33:37.021] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.021] assign_globals() ... done
[13:33:37.021] requestCore(): workers = 2
[13:33:37.024] MulticoreFuture started
[13:33:37.024] - Launch lazy future ... done
[13:33:37.029] plan(): Setting new future strategy stack:
[13:33:37.030] run() for ‘MulticoreFuture’ ... done
[13:33:37.030] Created future:
[13:33:37.030] List of future strategies:
[13:33:37.030] 1. sequential:
[13:33:37.030]    - args: function (..., envir = parent.frame())
[13:33:37.030]    - tweaked: FALSE
[13:33:37.030]    - call: NULL
[13:33:37.032] plan(): nbrOfWorkers() = 1
[13:33:37.035] plan(): Setting new future strategy stack:
[13:33:37.035] List of future strategies:
[13:33:37.035] 1. multicore:
[13:33:37.035]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.035]    - tweaked: FALSE
[13:33:37.035]    - call: plan(strategy)
[13:33:37.042] plan(): nbrOfWorkers() = 2
[13:33:37.031] MulticoreFuture:
[13:33:37.031] Label: ‘future_apply-1’
[13:33:37.031] Expression:
[13:33:37.031] {
[13:33:37.031]     do.call(function(...) {
[13:33:37.031]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.031]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.031]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.031]             on.exit(options(oopts), add = TRUE)
[13:33:37.031]         }
[13:33:37.031]         {
[13:33:37.031]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.031]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.031]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.031]             })
[13:33:37.031]         }
[13:33:37.031]     }, args = future.call.arguments)
[13:33:37.031] }
[13:33:37.031] Lazy evaluation: FALSE
[13:33:37.031] Asynchronous evaluation: TRUE
[13:33:37.031] Local evaluation: TRUE
[13:33:37.031] Environment: R_GlobalEnv
[13:33:37.031] Capture standard output: TRUE
[13:33:37.031] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.031] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.031] Packages: <none>
[13:33:37.031] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.031] Resolved: TRUE
[13:33:37.031] Value: <not collected>
[13:33:37.031] Conditions captured: <none>
[13:33:37.031] Early signaling: FALSE
[13:33:37.031] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.031] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.043] Chunk #1 of 2 ... DONE
[13:33:37.043] Chunk #2 of 2 ...
[13:33:37.043]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.044]  - seeds: <none>
[13:33:37.044]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.044] getGlobalsAndPackages() ...
[13:33:37.044] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.045] Resolving globals: FALSE
[13:33:37.045] Tweak future expression to call with '...' arguments ...
[13:33:37.045] {
[13:33:37.045]     do.call(function(...) {
[13:33:37.045]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.045]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.045]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.045]             on.exit(options(oopts), add = TRUE)
[13:33:37.045]         }
[13:33:37.045]         {
[13:33:37.045]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.045]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.045]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.045]             })
[13:33:37.045]         }
[13:33:37.045]     }, args = future.call.arguments)
[13:33:37.045] }
[13:33:37.045] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.046] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.047] 
[13:33:37.047] getGlobalsAndPackages() ... DONE
[13:33:37.047] run() for ‘Future’ ...
[13:33:37.048] - state: ‘created’
[13:33:37.048] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.053] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.053] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.054]   - Field: ‘label’
[13:33:37.054]   - Field: ‘local’
[13:33:37.054]   - Field: ‘owner’
[13:33:37.055]   - Field: ‘envir’
[13:33:37.055]   - Field: ‘workers’
[13:33:37.055]   - Field: ‘packages’
[13:33:37.055]   - Field: ‘gc’
[13:33:37.055]   - Field: ‘job’
[13:33:37.055]   - Field: ‘conditions’
[13:33:37.056]   - Field: ‘expr’
[13:33:37.056]   - Field: ‘uuid’
[13:33:37.056]   - Field: ‘seed’
[13:33:37.056]   - Field: ‘version’
[13:33:37.056]   - Field: ‘result’
[13:33:37.056]   - Field: ‘asynchronous’
[13:33:37.056]   - Field: ‘calls’
[13:33:37.057]   - Field: ‘globals’
[13:33:37.057]   - Field: ‘stdout’
[13:33:37.057]   - Field: ‘earlySignal’
[13:33:37.057]   - Field: ‘lazy’
[13:33:37.057]   - Field: ‘state’
[13:33:37.057] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.057] - Launch lazy future ...
[13:33:37.058] Packages needed by the future expression (n = 0): <none>
[13:33:37.058] Packages needed by future strategies (n = 0): <none>
[13:33:37.059] {
[13:33:37.059]     {
[13:33:37.059]         {
[13:33:37.059]             ...future.startTime <- base::Sys.time()
[13:33:37.059]             {
[13:33:37.059]                 {
[13:33:37.059]                   {
[13:33:37.059]                     {
[13:33:37.059]                       base::local({
[13:33:37.059]                         has_future <- base::requireNamespace("future", 
[13:33:37.059]                           quietly = TRUE)
[13:33:37.059]                         if (has_future) {
[13:33:37.059]                           ns <- base::getNamespace("future")
[13:33:37.059]                           version <- ns[[".package"]][["version"]]
[13:33:37.059]                           if (is.null(version)) 
[13:33:37.059]                             version <- utils::packageVersion("future")
[13:33:37.059]                         }
[13:33:37.059]                         else {
[13:33:37.059]                           version <- NULL
[13:33:37.059]                         }
[13:33:37.059]                         if (!has_future || version < "1.8.0") {
[13:33:37.059]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.059]                             "", base::R.version$version.string), 
[13:33:37.059]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.059]                               "release", "version")], collapse = " "), 
[13:33:37.059]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.059]                             info)
[13:33:37.059]                           info <- base::paste(info, collapse = "; ")
[13:33:37.059]                           if (!has_future) {
[13:33:37.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.059]                               info)
[13:33:37.059]                           }
[13:33:37.059]                           else {
[13:33:37.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.059]                               info, version)
[13:33:37.059]                           }
[13:33:37.059]                           base::stop(msg)
[13:33:37.059]                         }
[13:33:37.059]                       })
[13:33:37.059]                     }
[13:33:37.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.059]                     base::options(mc.cores = 1L)
[13:33:37.059]                   }
[13:33:37.059]                   ...future.strategy.old <- future::plan("list")
[13:33:37.059]                   options(future.plan = NULL)
[13:33:37.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.059]                 }
[13:33:37.059]                 ...future.workdir <- getwd()
[13:33:37.059]             }
[13:33:37.059]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.059]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.059]         }
[13:33:37.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.059]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.059]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.059]             base::names(...future.oldOptions))
[13:33:37.059]     }
[13:33:37.059]     if (FALSE) {
[13:33:37.059]     }
[13:33:37.059]     else {
[13:33:37.059]         if (TRUE) {
[13:33:37.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.059]                 open = "w")
[13:33:37.059]         }
[13:33:37.059]         else {
[13:33:37.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.059]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.059]         }
[13:33:37.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.059]             base::sink(type = "output", split = FALSE)
[13:33:37.059]             base::close(...future.stdout)
[13:33:37.059]         }, add = TRUE)
[13:33:37.059]     }
[13:33:37.059]     ...future.frame <- base::sys.nframe()
[13:33:37.059]     ...future.conditions <- base::list()
[13:33:37.059]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.059]     if (FALSE) {
[13:33:37.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.059]     }
[13:33:37.059]     ...future.result <- base::tryCatch({
[13:33:37.059]         base::withCallingHandlers({
[13:33:37.059]             ...future.value <- base::withVisible(base::local({
[13:33:37.059]                 withCallingHandlers({
[13:33:37.059]                   {
[13:33:37.059]                     do.call(function(...) {
[13:33:37.059]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.059]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.059]                         ...future.globals.maxSize)) {
[13:33:37.059]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.059]                         on.exit(options(oopts), add = TRUE)
[13:33:37.059]                       }
[13:33:37.059]                       {
[13:33:37.059]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.059]                           FUN = function(jj) {
[13:33:37.059]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.059]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.059]                           })
[13:33:37.059]                       }
[13:33:37.059]                     }, args = future.call.arguments)
[13:33:37.059]                   }
[13:33:37.059]                 }, immediateCondition = function(cond) {
[13:33:37.059]                   save_rds <- function (object, pathname, ...) 
[13:33:37.059]                   {
[13:33:37.059]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.059]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.059]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.059]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.059]                         fi_tmp[["mtime"]])
[13:33:37.059]                     }
[13:33:37.059]                     tryCatch({
[13:33:37.059]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.059]                     }, error = function(ex) {
[13:33:37.059]                       msg <- conditionMessage(ex)
[13:33:37.059]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.059]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.059]                         fi_tmp[["mtime"]], msg)
[13:33:37.059]                       ex$message <- msg
[13:33:37.059]                       stop(ex)
[13:33:37.059]                     })
[13:33:37.059]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.059]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.059]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.059]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.059]                       fi <- file.info(pathname)
[13:33:37.059]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.059]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.059]                         fi[["size"]], fi[["mtime"]])
[13:33:37.059]                       stop(msg)
[13:33:37.059]                     }
[13:33:37.059]                     invisible(pathname)
[13:33:37.059]                   }
[13:33:37.059]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.059]                     rootPath = tempdir()) 
[13:33:37.059]                   {
[13:33:37.059]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.059]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.059]                       tmpdir = path, fileext = ".rds")
[13:33:37.059]                     save_rds(obj, file)
[13:33:37.059]                   }
[13:33:37.059]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.059]                   {
[13:33:37.059]                     inherits <- base::inherits
[13:33:37.059]                     invokeRestart <- base::invokeRestart
[13:33:37.059]                     is.null <- base::is.null
[13:33:37.059]                     muffled <- FALSE
[13:33:37.059]                     if (inherits(cond, "message")) {
[13:33:37.059]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.059]                       if (muffled) 
[13:33:37.059]                         invokeRestart("muffleMessage")
[13:33:37.059]                     }
[13:33:37.059]                     else if (inherits(cond, "warning")) {
[13:33:37.059]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.059]                       if (muffled) 
[13:33:37.059]                         invokeRestart("muffleWarning")
[13:33:37.059]                     }
[13:33:37.059]                     else if (inherits(cond, "condition")) {
[13:33:37.059]                       if (!is.null(pattern)) {
[13:33:37.059]                         computeRestarts <- base::computeRestarts
[13:33:37.059]                         grepl <- base::grepl
[13:33:37.059]                         restarts <- computeRestarts(cond)
[13:33:37.059]                         for (restart in restarts) {
[13:33:37.059]                           name <- restart$name
[13:33:37.059]                           if (is.null(name)) 
[13:33:37.059]                             next
[13:33:37.059]                           if (!grepl(pattern, name)) 
[13:33:37.059]                             next
[13:33:37.059]                           invokeRestart(restart)
[13:33:37.059]                           muffled <- TRUE
[13:33:37.059]                           break
[13:33:37.059]                         }
[13:33:37.059]                       }
[13:33:37.059]                     }
[13:33:37.059]                     invisible(muffled)
[13:33:37.059]                   }
[13:33:37.059]                   muffleCondition(cond)
[13:33:37.059]                 })
[13:33:37.059]             }))
[13:33:37.059]             future::FutureResult(value = ...future.value$value, 
[13:33:37.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.059]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.059]                     ...future.globalenv.names))
[13:33:37.059]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.059]         }, condition = base::local({
[13:33:37.059]             c <- base::c
[13:33:37.059]             inherits <- base::inherits
[13:33:37.059]             invokeRestart <- base::invokeRestart
[13:33:37.059]             length <- base::length
[13:33:37.059]             list <- base::list
[13:33:37.059]             seq.int <- base::seq.int
[13:33:37.059]             signalCondition <- base::signalCondition
[13:33:37.059]             sys.calls <- base::sys.calls
[13:33:37.059]             `[[` <- base::`[[`
[13:33:37.059]             `+` <- base::`+`
[13:33:37.059]             `<<-` <- base::`<<-`
[13:33:37.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.059]                   3L)]
[13:33:37.059]             }
[13:33:37.059]             function(cond) {
[13:33:37.059]                 is_error <- inherits(cond, "error")
[13:33:37.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.059]                   NULL)
[13:33:37.059]                 if (is_error) {
[13:33:37.059]                   sessionInformation <- function() {
[13:33:37.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.059]                       search = base::search(), system = base::Sys.info())
[13:33:37.059]                   }
[13:33:37.059]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.059]                     cond$call), session = sessionInformation(), 
[13:33:37.059]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.059]                   signalCondition(cond)
[13:33:37.059]                 }
[13:33:37.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.059]                 "immediateCondition"))) {
[13:33:37.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.059]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.059]                   if (TRUE && !signal) {
[13:33:37.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.059]                     {
[13:33:37.059]                       inherits <- base::inherits
[13:33:37.059]                       invokeRestart <- base::invokeRestart
[13:33:37.059]                       is.null <- base::is.null
[13:33:37.059]                       muffled <- FALSE
[13:33:37.059]                       if (inherits(cond, "message")) {
[13:33:37.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.059]                         if (muffled) 
[13:33:37.059]                           invokeRestart("muffleMessage")
[13:33:37.059]                       }
[13:33:37.059]                       else if (inherits(cond, "warning")) {
[13:33:37.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.059]                         if (muffled) 
[13:33:37.059]                           invokeRestart("muffleWarning")
[13:33:37.059]                       }
[13:33:37.059]                       else if (inherits(cond, "condition")) {
[13:33:37.059]                         if (!is.null(pattern)) {
[13:33:37.059]                           computeRestarts <- base::computeRestarts
[13:33:37.059]                           grepl <- base::grepl
[13:33:37.059]                           restarts <- computeRestarts(cond)
[13:33:37.059]                           for (restart in restarts) {
[13:33:37.059]                             name <- restart$name
[13:33:37.059]                             if (is.null(name)) 
[13:33:37.059]                               next
[13:33:37.059]                             if (!grepl(pattern, name)) 
[13:33:37.059]                               next
[13:33:37.059]                             invokeRestart(restart)
[13:33:37.059]                             muffled <- TRUE
[13:33:37.059]                             break
[13:33:37.059]                           }
[13:33:37.059]                         }
[13:33:37.059]                       }
[13:33:37.059]                       invisible(muffled)
[13:33:37.059]                     }
[13:33:37.059]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.059]                   }
[13:33:37.059]                 }
[13:33:37.059]                 else {
[13:33:37.059]                   if (TRUE) {
[13:33:37.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.059]                     {
[13:33:37.059]                       inherits <- base::inherits
[13:33:37.059]                       invokeRestart <- base::invokeRestart
[13:33:37.059]                       is.null <- base::is.null
[13:33:37.059]                       muffled <- FALSE
[13:33:37.059]                       if (inherits(cond, "message")) {
[13:33:37.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.059]                         if (muffled) 
[13:33:37.059]                           invokeRestart("muffleMessage")
[13:33:37.059]                       }
[13:33:37.059]                       else if (inherits(cond, "warning")) {
[13:33:37.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.059]                         if (muffled) 
[13:33:37.059]                           invokeRestart("muffleWarning")
[13:33:37.059]                       }
[13:33:37.059]                       else if (inherits(cond, "condition")) {
[13:33:37.059]                         if (!is.null(pattern)) {
[13:33:37.059]                           computeRestarts <- base::computeRestarts
[13:33:37.059]                           grepl <- base::grepl
[13:33:37.059]                           restarts <- computeRestarts(cond)
[13:33:37.059]                           for (restart in restarts) {
[13:33:37.059]                             name <- restart$name
[13:33:37.059]                             if (is.null(name)) 
[13:33:37.059]                               next
[13:33:37.059]                             if (!grepl(pattern, name)) 
[13:33:37.059]                               next
[13:33:37.059]                             invokeRestart(restart)
[13:33:37.059]                             muffled <- TRUE
[13:33:37.059]                             break
[13:33:37.059]                           }
[13:33:37.059]                         }
[13:33:37.059]                       }
[13:33:37.059]                       invisible(muffled)
[13:33:37.059]                     }
[13:33:37.059]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.059]                   }
[13:33:37.059]                 }
[13:33:37.059]             }
[13:33:37.059]         }))
[13:33:37.059]     }, error = function(ex) {
[13:33:37.059]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.059]                 ...future.rng), started = ...future.startTime, 
[13:33:37.059]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.059]             version = "1.8"), class = "FutureResult")
[13:33:37.059]     }, finally = {
[13:33:37.059]         if (!identical(...future.workdir, getwd())) 
[13:33:37.059]             setwd(...future.workdir)
[13:33:37.059]         {
[13:33:37.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.059]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.059]             }
[13:33:37.059]             base::options(...future.oldOptions)
[13:33:37.059]             if (.Platform$OS.type == "windows") {
[13:33:37.059]                 old_names <- names(...future.oldEnvVars)
[13:33:37.059]                 envs <- base::Sys.getenv()
[13:33:37.059]                 names <- names(envs)
[13:33:37.059]                 common <- intersect(names, old_names)
[13:33:37.059]                 added <- setdiff(names, old_names)
[13:33:37.059]                 removed <- setdiff(old_names, names)
[13:33:37.059]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.059]                   envs[common]]
[13:33:37.059]                 NAMES <- toupper(changed)
[13:33:37.059]                 args <- list()
[13:33:37.059]                 for (kk in seq_along(NAMES)) {
[13:33:37.059]                   name <- changed[[kk]]
[13:33:37.059]                   NAME <- NAMES[[kk]]
[13:33:37.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.059]                     next
[13:33:37.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.059]                 }
[13:33:37.059]                 NAMES <- toupper(added)
[13:33:37.059]                 for (kk in seq_along(NAMES)) {
[13:33:37.059]                   name <- added[[kk]]
[13:33:37.059]                   NAME <- NAMES[[kk]]
[13:33:37.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.059]                     next
[13:33:37.059]                   args[[name]] <- ""
[13:33:37.059]                 }
[13:33:37.059]                 NAMES <- toupper(removed)
[13:33:37.059]                 for (kk in seq_along(NAMES)) {
[13:33:37.059]                   name <- removed[[kk]]
[13:33:37.059]                   NAME <- NAMES[[kk]]
[13:33:37.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.059]                     next
[13:33:37.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.059]                 }
[13:33:37.059]                 if (length(args) > 0) 
[13:33:37.059]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.059]             }
[13:33:37.059]             else {
[13:33:37.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.059]             }
[13:33:37.059]             {
[13:33:37.059]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.059]                   0L) {
[13:33:37.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.059]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.059]                   base::options(opts)
[13:33:37.059]                 }
[13:33:37.059]                 {
[13:33:37.059]                   {
[13:33:37.059]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.059]                     NULL
[13:33:37.059]                   }
[13:33:37.059]                   options(future.plan = NULL)
[13:33:37.059]                   if (is.na(NA_character_)) 
[13:33:37.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.059]                     .init = FALSE)
[13:33:37.059]                 }
[13:33:37.059]             }
[13:33:37.059]         }
[13:33:37.059]     })
[13:33:37.059]     if (TRUE) {
[13:33:37.059]         base::sink(type = "output", split = FALSE)
[13:33:37.059]         if (TRUE) {
[13:33:37.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.059]         }
[13:33:37.059]         else {
[13:33:37.059]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.059]         }
[13:33:37.059]         base::close(...future.stdout)
[13:33:37.059]         ...future.stdout <- NULL
[13:33:37.059]     }
[13:33:37.059]     ...future.result$conditions <- ...future.conditions
[13:33:37.059]     ...future.result$finished <- base::Sys.time()
[13:33:37.059]     ...future.result
[13:33:37.059] }
[13:33:37.062] assign_globals() ...
[13:33:37.062] List of 5
[13:33:37.062]  $ future.call.arguments    : list()
[13:33:37.062]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.062]  $ ...future.FUN            :function (x)  
[13:33:37.062]  $ ...future.elements_ii    :List of 1
[13:33:37.062]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:33:37.062]  $ ...future.seeds_ii       : NULL
[13:33:37.062]  $ ...future.globals.maxSize: num Inf
[13:33:37.062]  - attr(*, "resolved")= logi FALSE
[13:33:37.062]  - attr(*, "total_size")= num NA
[13:33:37.062]  - attr(*, "where")=List of 5
[13:33:37.062]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.062]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.062]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.062]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.062]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.062]  - attr(*, "already-done")= logi TRUE
[13:33:37.068] - copied ‘future.call.arguments’ to environment
[13:33:37.068] - copied ‘...future.FUN’ to environment
[13:33:37.068] - copied ‘...future.elements_ii’ to environment
[13:33:37.069] - copied ‘...future.seeds_ii’ to environment
[13:33:37.069] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.069] assign_globals() ... done
[13:33:37.069] requestCore(): workers = 2
[13:33:37.071] MulticoreFuture started
[13:33:37.072] - Launch lazy future ... done
[13:33:37.072] run() for ‘MulticoreFuture’ ... done
[13:33:37.072] Created future:
[13:33:37.072] plan(): Setting new future strategy stack:
[13:33:37.073] List of future strategies:
[13:33:37.073] 1. sequential:
[13:33:37.073]    - args: function (..., envir = parent.frame())
[13:33:37.073]    - tweaked: FALSE
[13:33:37.073]    - call: NULL
[13:33:37.074] plan(): nbrOfWorkers() = 1
[13:33:37.076] plan(): Setting new future strategy stack:
[13:33:37.076] List of future strategies:
[13:33:37.076] 1. multicore:
[13:33:37.076]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.076]    - tweaked: FALSE
[13:33:37.076]    - call: plan(strategy)
[13:33:37.081] plan(): nbrOfWorkers() = 2
[13:33:37.072] MulticoreFuture:
[13:33:37.072] Label: ‘future_apply-2’
[13:33:37.072] Expression:
[13:33:37.072] {
[13:33:37.072]     do.call(function(...) {
[13:33:37.072]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.072]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.072]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.072]             on.exit(options(oopts), add = TRUE)
[13:33:37.072]         }
[13:33:37.072]         {
[13:33:37.072]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.072]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.072]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.072]             })
[13:33:37.072]         }
[13:33:37.072]     }, args = future.call.arguments)
[13:33:37.072] }
[13:33:37.072] Lazy evaluation: FALSE
[13:33:37.072] Asynchronous evaluation: TRUE
[13:33:37.072] Local evaluation: TRUE
[13:33:37.072] Environment: R_GlobalEnv
[13:33:37.072] Capture standard output: TRUE
[13:33:37.072] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.072] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.072] Packages: <none>
[13:33:37.072] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.072] Resolved: TRUE
[13:33:37.072] Value: <not collected>
[13:33:37.072] Conditions captured: <none>
[13:33:37.072] Early signaling: FALSE
[13:33:37.072] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.072] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.082] Chunk #2 of 2 ... DONE
[13:33:37.082] Launching 2 futures (chunks) ... DONE
[13:33:37.082] Resolving 2 futures (chunks) ...
[13:33:37.082] resolve() on list ...
[13:33:37.082]  recursive: 0
[13:33:37.083]  length: 2
[13:33:37.083] 
[13:33:37.083] Future #1
[13:33:37.083] result() for MulticoreFuture ...
[13:33:37.084] result() for MulticoreFuture ...
[13:33:37.084] result() for MulticoreFuture ... done
[13:33:37.084] result() for MulticoreFuture ... done
[13:33:37.085] result() for MulticoreFuture ...
[13:33:37.085] result() for MulticoreFuture ... done
[13:33:37.085] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:37.085] - nx: 2
[13:33:37.085] - relay: TRUE
[13:33:37.086] - stdout: TRUE
[13:33:37.086] - signal: TRUE
[13:33:37.086] - resignal: FALSE
[13:33:37.086] - force: TRUE
[13:33:37.086] - relayed: [n=2] FALSE, FALSE
[13:33:37.087] - queued futures: [n=2] FALSE, FALSE
[13:33:37.087]  - until=1
[13:33:37.087]  - relaying element #1
[13:33:37.087] result() for MulticoreFuture ...
[13:33:37.087] result() for MulticoreFuture ... done
[13:33:37.087] result() for MulticoreFuture ...
[13:33:37.088] result() for MulticoreFuture ... done
[13:33:37.088] result() for MulticoreFuture ...
[13:33:37.088] result() for MulticoreFuture ... done
[13:33:37.088] result() for MulticoreFuture ...
[13:33:37.089] result() for MulticoreFuture ... done
[13:33:37.089] - relayed: [n=2] TRUE, FALSE
[13:33:37.089] - queued futures: [n=2] TRUE, FALSE
[13:33:37.089] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:37.089]  length: 1 (resolved future 1)
[13:33:37.090] Future #2
[13:33:37.090] result() for MulticoreFuture ...
[13:33:37.090] result() for MulticoreFuture ...
[13:33:37.094] result() for MulticoreFuture ... done
[13:33:37.094] result() for MulticoreFuture ... done
[13:33:37.095] result() for MulticoreFuture ...
[13:33:37.095] result() for MulticoreFuture ... done
[13:33:37.095] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:37.095] - nx: 2
[13:33:37.096] - relay: TRUE
[13:33:37.096] - stdout: TRUE
[13:33:37.096] - signal: TRUE
[13:33:37.096] - resignal: FALSE
[13:33:37.096] - force: TRUE
[13:33:37.096] - relayed: [n=2] TRUE, FALSE
[13:33:37.096] - queued futures: [n=2] TRUE, FALSE
[13:33:37.097]  - until=2
[13:33:37.097]  - relaying element #2
[13:33:37.097] result() for MulticoreFuture ...
[13:33:37.097] result() for MulticoreFuture ... done
[13:33:37.097] result() for MulticoreFuture ...
[13:33:37.097] result() for MulticoreFuture ... done
[13:33:37.098] result() for MulticoreFuture ...
[13:33:37.098] result() for MulticoreFuture ... done
[13:33:37.098] result() for MulticoreFuture ...
[13:33:37.098] result() for MulticoreFuture ... done
[13:33:37.098] - relayed: [n=2] TRUE, TRUE
[13:33:37.099] - queued futures: [n=2] TRUE, TRUE
[13:33:37.099] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:37.099]  length: 0 (resolved future 2)
[13:33:37.099] Relaying remaining futures
[13:33:37.099] signalConditionsASAP(NULL, pos=0) ...
[13:33:37.099] - nx: 2
[13:33:37.099] - relay: TRUE
[13:33:37.100] - stdout: TRUE
[13:33:37.100] - signal: TRUE
[13:33:37.100] - resignal: FALSE
[13:33:37.100] - force: TRUE
[13:33:37.100] - relayed: [n=2] TRUE, TRUE
[13:33:37.100] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:37.100] - relayed: [n=2] TRUE, TRUE
[13:33:37.100] - queued futures: [n=2] TRUE, TRUE
[13:33:37.100] signalConditionsASAP(NULL, pos=0) ... done
[13:33:37.100] resolve() on list ... DONE
[13:33:37.101] result() for MulticoreFuture ...
[13:33:37.101] result() for MulticoreFuture ... done
[13:33:37.101] result() for MulticoreFuture ...
[13:33:37.101] result() for MulticoreFuture ... done
[13:33:37.101] result() for MulticoreFuture ...
[13:33:37.101] result() for MulticoreFuture ... done
[13:33:37.102] result() for MulticoreFuture ...
[13:33:37.102] result() for MulticoreFuture ... done
[13:33:37.102]  - Number of value chunks collected: 2
[13:33:37.102] Resolving 2 futures (chunks) ... DONE
[13:33:37.102] Reducing values from 2 chunks ...
[13:33:37.102]  - Number of values collected after concatenation: 2
[13:33:37.102]  - Number of values expected: 2
[13:33:37.102] Reducing values from 2 chunks ... DONE
[13:33:37.102] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[13:33:37.103] getGlobalsAndPackagesXApply() ...
[13:33:37.103]  - future.globals: TRUE
[13:33:37.103] getGlobalsAndPackages() ...
[13:33:37.103] Searching for globals...
[13:33:37.105] - globals found: [1] ‘FUN’
[13:33:37.105] Searching for globals ... DONE
[13:33:37.105] Resolving globals: FALSE
[13:33:37.105] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:37.106] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:37.106] - globals: [1] ‘FUN’
[13:33:37.106] 
[13:33:37.106] getGlobalsAndPackages() ... DONE
[13:33:37.106]  - globals found/used: [n=1] ‘FUN’
[13:33:37.106]  - needed namespaces: [n=0] 
[13:33:37.106] Finding globals ... DONE
[13:33:37.107]  - use_args: TRUE
[13:33:37.107]  - Getting '...' globals ...
[13:33:37.107] resolve() on list ...
[13:33:37.107]  recursive: 0
[13:33:37.107]  length: 1
[13:33:37.107]  elements: ‘...’
[13:33:37.107]  length: 0 (resolved future 1)
[13:33:37.108] resolve() on list ... DONE
[13:33:37.108]    - '...' content: [n=0] 
[13:33:37.108] List of 1
[13:33:37.108]  $ ...: list()
[13:33:37.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.108]  - attr(*, "where")=List of 1
[13:33:37.108]   ..$ ...:<environment: 0x55b9489169f8> 
[13:33:37.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.108]  - attr(*, "resolved")= logi TRUE
[13:33:37.108]  - attr(*, "total_size")= num NA
[13:33:37.111]  - Getting '...' globals ... DONE
[13:33:37.111] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:37.111] List of 2
[13:33:37.111]  $ ...future.FUN:function (x)  
[13:33:37.111]  $ ...          : list()
[13:33:37.111]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.111]  - attr(*, "where")=List of 2
[13:33:37.111]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:37.111]   ..$ ...          :<environment: 0x55b9489169f8> 
[13:33:37.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.111]  - attr(*, "resolved")= logi FALSE
[13:33:37.111]  - attr(*, "total_size")= num 848
[13:33:37.114] Packages to be attached in all futures: [n=0] 
[13:33:37.114] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.117] future_lapply() ...
[13:33:37.121] Number of chunks: 2
[13:33:37.121] getGlobalsAndPackagesXApply() ...
[13:33:37.121]  - future.globals: <name-value list> with names ‘list()’
[13:33:37.121]  - use_args: TRUE
[13:33:37.121] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:37.122] List of 2
[13:33:37.122]  $ ...          : list()
[13:33:37.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.122]  $ ...future.FUN:function (x)  
[13:33:37.122]  - attr(*, "where")=List of 2
[13:33:37.122]   ..$ ...          :<environment: 0x55b9489169f8> 
[13:33:37.122]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:37.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.122]  - attr(*, "resolved")= logi FALSE
[13:33:37.122]  - attr(*, "total_size")= num NA
[13:33:37.127] Packages to be attached in all futures: [n=0] 
[13:33:37.127] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.127] Number of futures (= number of chunks): 2
[13:33:37.127] Launching 2 futures (chunks) ...
[13:33:37.128] Chunk #1 of 2 ...
[13:33:37.128]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.128]  - seeds: <none>
[13:33:37.128]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.128] getGlobalsAndPackages() ...
[13:33:37.128] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.128] Resolving globals: FALSE
[13:33:37.128] Tweak future expression to call with '...' arguments ...
[13:33:37.129] {
[13:33:37.129]     do.call(function(...) {
[13:33:37.129]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.129]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.129]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.129]             on.exit(options(oopts), add = TRUE)
[13:33:37.129]         }
[13:33:37.129]         {
[13:33:37.129]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.129]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.129]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.129]             })
[13:33:37.129]         }
[13:33:37.129]     }, args = future.call.arguments)
[13:33:37.129] }
[13:33:37.129] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.129] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.129] 
[13:33:37.129] getGlobalsAndPackages() ... DONE
[13:33:37.130] run() for ‘Future’ ...
[13:33:37.130] - state: ‘created’
[13:33:37.130] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.133] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.134] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.134]   - Field: ‘label’
[13:33:37.134]   - Field: ‘local’
[13:33:37.134]   - Field: ‘owner’
[13:33:37.134]   - Field: ‘envir’
[13:33:37.134]   - Field: ‘workers’
[13:33:37.134]   - Field: ‘packages’
[13:33:37.134]   - Field: ‘gc’
[13:33:37.134]   - Field: ‘job’
[13:33:37.134]   - Field: ‘conditions’
[13:33:37.135]   - Field: ‘expr’
[13:33:37.135]   - Field: ‘uuid’
[13:33:37.135]   - Field: ‘seed’
[13:33:37.135]   - Field: ‘version’
[13:33:37.135]   - Field: ‘result’
[13:33:37.135]   - Field: ‘asynchronous’
[13:33:37.135]   - Field: ‘calls’
[13:33:37.135]   - Field: ‘globals’
[13:33:37.135]   - Field: ‘stdout’
[13:33:37.135]   - Field: ‘earlySignal’
[13:33:37.135]   - Field: ‘lazy’
[13:33:37.136]   - Field: ‘state’
[13:33:37.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.136] - Launch lazy future ...
[13:33:37.136] Packages needed by the future expression (n = 0): <none>
[13:33:37.136] Packages needed by future strategies (n = 0): <none>
[13:33:37.137] {
[13:33:37.137]     {
[13:33:37.137]         {
[13:33:37.137]             ...future.startTime <- base::Sys.time()
[13:33:37.137]             {
[13:33:37.137]                 {
[13:33:37.137]                   {
[13:33:37.137]                     {
[13:33:37.137]                       base::local({
[13:33:37.137]                         has_future <- base::requireNamespace("future", 
[13:33:37.137]                           quietly = TRUE)
[13:33:37.137]                         if (has_future) {
[13:33:37.137]                           ns <- base::getNamespace("future")
[13:33:37.137]                           version <- ns[[".package"]][["version"]]
[13:33:37.137]                           if (is.null(version)) 
[13:33:37.137]                             version <- utils::packageVersion("future")
[13:33:37.137]                         }
[13:33:37.137]                         else {
[13:33:37.137]                           version <- NULL
[13:33:37.137]                         }
[13:33:37.137]                         if (!has_future || version < "1.8.0") {
[13:33:37.137]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.137]                             "", base::R.version$version.string), 
[13:33:37.137]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.137]                               "release", "version")], collapse = " "), 
[13:33:37.137]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.137]                             info)
[13:33:37.137]                           info <- base::paste(info, collapse = "; ")
[13:33:37.137]                           if (!has_future) {
[13:33:37.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.137]                               info)
[13:33:37.137]                           }
[13:33:37.137]                           else {
[13:33:37.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.137]                               info, version)
[13:33:37.137]                           }
[13:33:37.137]                           base::stop(msg)
[13:33:37.137]                         }
[13:33:37.137]                       })
[13:33:37.137]                     }
[13:33:37.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.137]                     base::options(mc.cores = 1L)
[13:33:37.137]                   }
[13:33:37.137]                   ...future.strategy.old <- future::plan("list")
[13:33:37.137]                   options(future.plan = NULL)
[13:33:37.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.137]                 }
[13:33:37.137]                 ...future.workdir <- getwd()
[13:33:37.137]             }
[13:33:37.137]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.137]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.137]         }
[13:33:37.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.137]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.137]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.137]             base::names(...future.oldOptions))
[13:33:37.137]     }
[13:33:37.137]     if (FALSE) {
[13:33:37.137]     }
[13:33:37.137]     else {
[13:33:37.137]         if (TRUE) {
[13:33:37.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.137]                 open = "w")
[13:33:37.137]         }
[13:33:37.137]         else {
[13:33:37.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.137]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.137]         }
[13:33:37.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.137]             base::sink(type = "output", split = FALSE)
[13:33:37.137]             base::close(...future.stdout)
[13:33:37.137]         }, add = TRUE)
[13:33:37.137]     }
[13:33:37.137]     ...future.frame <- base::sys.nframe()
[13:33:37.137]     ...future.conditions <- base::list()
[13:33:37.137]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.137]     if (FALSE) {
[13:33:37.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.137]     }
[13:33:37.137]     ...future.result <- base::tryCatch({
[13:33:37.137]         base::withCallingHandlers({
[13:33:37.137]             ...future.value <- base::withVisible(base::local({
[13:33:37.137]                 withCallingHandlers({
[13:33:37.137]                   {
[13:33:37.137]                     do.call(function(...) {
[13:33:37.137]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.137]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.137]                         ...future.globals.maxSize)) {
[13:33:37.137]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.137]                         on.exit(options(oopts), add = TRUE)
[13:33:37.137]                       }
[13:33:37.137]                       {
[13:33:37.137]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.137]                           FUN = function(jj) {
[13:33:37.137]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.137]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.137]                           })
[13:33:37.137]                       }
[13:33:37.137]                     }, args = future.call.arguments)
[13:33:37.137]                   }
[13:33:37.137]                 }, immediateCondition = function(cond) {
[13:33:37.137]                   save_rds <- function (object, pathname, ...) 
[13:33:37.137]                   {
[13:33:37.137]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.137]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.137]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.137]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.137]                         fi_tmp[["mtime"]])
[13:33:37.137]                     }
[13:33:37.137]                     tryCatch({
[13:33:37.137]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.137]                     }, error = function(ex) {
[13:33:37.137]                       msg <- conditionMessage(ex)
[13:33:37.137]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.137]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.137]                         fi_tmp[["mtime"]], msg)
[13:33:37.137]                       ex$message <- msg
[13:33:37.137]                       stop(ex)
[13:33:37.137]                     })
[13:33:37.137]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.137]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.137]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.137]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.137]                       fi <- file.info(pathname)
[13:33:37.137]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.137]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.137]                         fi[["size"]], fi[["mtime"]])
[13:33:37.137]                       stop(msg)
[13:33:37.137]                     }
[13:33:37.137]                     invisible(pathname)
[13:33:37.137]                   }
[13:33:37.137]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.137]                     rootPath = tempdir()) 
[13:33:37.137]                   {
[13:33:37.137]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.137]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.137]                       tmpdir = path, fileext = ".rds")
[13:33:37.137]                     save_rds(obj, file)
[13:33:37.137]                   }
[13:33:37.137]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.137]                   {
[13:33:37.137]                     inherits <- base::inherits
[13:33:37.137]                     invokeRestart <- base::invokeRestart
[13:33:37.137]                     is.null <- base::is.null
[13:33:37.137]                     muffled <- FALSE
[13:33:37.137]                     if (inherits(cond, "message")) {
[13:33:37.137]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.137]                       if (muffled) 
[13:33:37.137]                         invokeRestart("muffleMessage")
[13:33:37.137]                     }
[13:33:37.137]                     else if (inherits(cond, "warning")) {
[13:33:37.137]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.137]                       if (muffled) 
[13:33:37.137]                         invokeRestart("muffleWarning")
[13:33:37.137]                     }
[13:33:37.137]                     else if (inherits(cond, "condition")) {
[13:33:37.137]                       if (!is.null(pattern)) {
[13:33:37.137]                         computeRestarts <- base::computeRestarts
[13:33:37.137]                         grepl <- base::grepl
[13:33:37.137]                         restarts <- computeRestarts(cond)
[13:33:37.137]                         for (restart in restarts) {
[13:33:37.137]                           name <- restart$name
[13:33:37.137]                           if (is.null(name)) 
[13:33:37.137]                             next
[13:33:37.137]                           if (!grepl(pattern, name)) 
[13:33:37.137]                             next
[13:33:37.137]                           invokeRestart(restart)
[13:33:37.137]                           muffled <- TRUE
[13:33:37.137]                           break
[13:33:37.137]                         }
[13:33:37.137]                       }
[13:33:37.137]                     }
[13:33:37.137]                     invisible(muffled)
[13:33:37.137]                   }
[13:33:37.137]                   muffleCondition(cond)
[13:33:37.137]                 })
[13:33:37.137]             }))
[13:33:37.137]             future::FutureResult(value = ...future.value$value, 
[13:33:37.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.137]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.137]                     ...future.globalenv.names))
[13:33:37.137]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.137]         }, condition = base::local({
[13:33:37.137]             c <- base::c
[13:33:37.137]             inherits <- base::inherits
[13:33:37.137]             invokeRestart <- base::invokeRestart
[13:33:37.137]             length <- base::length
[13:33:37.137]             list <- base::list
[13:33:37.137]             seq.int <- base::seq.int
[13:33:37.137]             signalCondition <- base::signalCondition
[13:33:37.137]             sys.calls <- base::sys.calls
[13:33:37.137]             `[[` <- base::`[[`
[13:33:37.137]             `+` <- base::`+`
[13:33:37.137]             `<<-` <- base::`<<-`
[13:33:37.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.137]                   3L)]
[13:33:37.137]             }
[13:33:37.137]             function(cond) {
[13:33:37.137]                 is_error <- inherits(cond, "error")
[13:33:37.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.137]                   NULL)
[13:33:37.137]                 if (is_error) {
[13:33:37.137]                   sessionInformation <- function() {
[13:33:37.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.137]                       search = base::search(), system = base::Sys.info())
[13:33:37.137]                   }
[13:33:37.137]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.137]                     cond$call), session = sessionInformation(), 
[13:33:37.137]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.137]                   signalCondition(cond)
[13:33:37.137]                 }
[13:33:37.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.137]                 "immediateCondition"))) {
[13:33:37.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.137]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.137]                   if (TRUE && !signal) {
[13:33:37.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.137]                     {
[13:33:37.137]                       inherits <- base::inherits
[13:33:37.137]                       invokeRestart <- base::invokeRestart
[13:33:37.137]                       is.null <- base::is.null
[13:33:37.137]                       muffled <- FALSE
[13:33:37.137]                       if (inherits(cond, "message")) {
[13:33:37.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.137]                         if (muffled) 
[13:33:37.137]                           invokeRestart("muffleMessage")
[13:33:37.137]                       }
[13:33:37.137]                       else if (inherits(cond, "warning")) {
[13:33:37.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.137]                         if (muffled) 
[13:33:37.137]                           invokeRestart("muffleWarning")
[13:33:37.137]                       }
[13:33:37.137]                       else if (inherits(cond, "condition")) {
[13:33:37.137]                         if (!is.null(pattern)) {
[13:33:37.137]                           computeRestarts <- base::computeRestarts
[13:33:37.137]                           grepl <- base::grepl
[13:33:37.137]                           restarts <- computeRestarts(cond)
[13:33:37.137]                           for (restart in restarts) {
[13:33:37.137]                             name <- restart$name
[13:33:37.137]                             if (is.null(name)) 
[13:33:37.137]                               next
[13:33:37.137]                             if (!grepl(pattern, name)) 
[13:33:37.137]                               next
[13:33:37.137]                             invokeRestart(restart)
[13:33:37.137]                             muffled <- TRUE
[13:33:37.137]                             break
[13:33:37.137]                           }
[13:33:37.137]                         }
[13:33:37.137]                       }
[13:33:37.137]                       invisible(muffled)
[13:33:37.137]                     }
[13:33:37.137]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.137]                   }
[13:33:37.137]                 }
[13:33:37.137]                 else {
[13:33:37.137]                   if (TRUE) {
[13:33:37.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.137]                     {
[13:33:37.137]                       inherits <- base::inherits
[13:33:37.137]                       invokeRestart <- base::invokeRestart
[13:33:37.137]                       is.null <- base::is.null
[13:33:37.137]                       muffled <- FALSE
[13:33:37.137]                       if (inherits(cond, "message")) {
[13:33:37.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.137]                         if (muffled) 
[13:33:37.137]                           invokeRestart("muffleMessage")
[13:33:37.137]                       }
[13:33:37.137]                       else if (inherits(cond, "warning")) {
[13:33:37.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.137]                         if (muffled) 
[13:33:37.137]                           invokeRestart("muffleWarning")
[13:33:37.137]                       }
[13:33:37.137]                       else if (inherits(cond, "condition")) {
[13:33:37.137]                         if (!is.null(pattern)) {
[13:33:37.137]                           computeRestarts <- base::computeRestarts
[13:33:37.137]                           grepl <- base::grepl
[13:33:37.137]                           restarts <- computeRestarts(cond)
[13:33:37.137]                           for (restart in restarts) {
[13:33:37.137]                             name <- restart$name
[13:33:37.137]                             if (is.null(name)) 
[13:33:37.137]                               next
[13:33:37.137]                             if (!grepl(pattern, name)) 
[13:33:37.137]                               next
[13:33:37.137]                             invokeRestart(restart)
[13:33:37.137]                             muffled <- TRUE
[13:33:37.137]                             break
[13:33:37.137]                           }
[13:33:37.137]                         }
[13:33:37.137]                       }
[13:33:37.137]                       invisible(muffled)
[13:33:37.137]                     }
[13:33:37.137]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.137]                   }
[13:33:37.137]                 }
[13:33:37.137]             }
[13:33:37.137]         }))
[13:33:37.137]     }, error = function(ex) {
[13:33:37.137]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.137]                 ...future.rng), started = ...future.startTime, 
[13:33:37.137]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.137]             version = "1.8"), class = "FutureResult")
[13:33:37.137]     }, finally = {
[13:33:37.137]         if (!identical(...future.workdir, getwd())) 
[13:33:37.137]             setwd(...future.workdir)
[13:33:37.137]         {
[13:33:37.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.137]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.137]             }
[13:33:37.137]             base::options(...future.oldOptions)
[13:33:37.137]             if (.Platform$OS.type == "windows") {
[13:33:37.137]                 old_names <- names(...future.oldEnvVars)
[13:33:37.137]                 envs <- base::Sys.getenv()
[13:33:37.137]                 names <- names(envs)
[13:33:37.137]                 common <- intersect(names, old_names)
[13:33:37.137]                 added <- setdiff(names, old_names)
[13:33:37.137]                 removed <- setdiff(old_names, names)
[13:33:37.137]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.137]                   envs[common]]
[13:33:37.137]                 NAMES <- toupper(changed)
[13:33:37.137]                 args <- list()
[13:33:37.137]                 for (kk in seq_along(NAMES)) {
[13:33:37.137]                   name <- changed[[kk]]
[13:33:37.137]                   NAME <- NAMES[[kk]]
[13:33:37.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.137]                     next
[13:33:37.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.137]                 }
[13:33:37.137]                 NAMES <- toupper(added)
[13:33:37.137]                 for (kk in seq_along(NAMES)) {
[13:33:37.137]                   name <- added[[kk]]
[13:33:37.137]                   NAME <- NAMES[[kk]]
[13:33:37.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.137]                     next
[13:33:37.137]                   args[[name]] <- ""
[13:33:37.137]                 }
[13:33:37.137]                 NAMES <- toupper(removed)
[13:33:37.137]                 for (kk in seq_along(NAMES)) {
[13:33:37.137]                   name <- removed[[kk]]
[13:33:37.137]                   NAME <- NAMES[[kk]]
[13:33:37.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.137]                     next
[13:33:37.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.137]                 }
[13:33:37.137]                 if (length(args) > 0) 
[13:33:37.137]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.137]             }
[13:33:37.137]             else {
[13:33:37.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.137]             }
[13:33:37.137]             {
[13:33:37.137]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.137]                   0L) {
[13:33:37.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.137]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.137]                   base::options(opts)
[13:33:37.137]                 }
[13:33:37.137]                 {
[13:33:37.137]                   {
[13:33:37.137]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.137]                     NULL
[13:33:37.137]                   }
[13:33:37.137]                   options(future.plan = NULL)
[13:33:37.137]                   if (is.na(NA_character_)) 
[13:33:37.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.137]                     .init = FALSE)
[13:33:37.137]                 }
[13:33:37.137]             }
[13:33:37.137]         }
[13:33:37.137]     })
[13:33:37.137]     if (TRUE) {
[13:33:37.137]         base::sink(type = "output", split = FALSE)
[13:33:37.137]         if (TRUE) {
[13:33:37.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.137]         }
[13:33:37.137]         else {
[13:33:37.137]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.137]         }
[13:33:37.137]         base::close(...future.stdout)
[13:33:37.137]         ...future.stdout <- NULL
[13:33:37.137]     }
[13:33:37.137]     ...future.result$conditions <- ...future.conditions
[13:33:37.137]     ...future.result$finished <- base::Sys.time()
[13:33:37.137]     ...future.result
[13:33:37.137] }
[13:33:37.139] assign_globals() ...
[13:33:37.139] List of 5
[13:33:37.139]  $ future.call.arguments    : list()
[13:33:37.139]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.139]  $ ...future.FUN            :function (x)  
[13:33:37.139]  $ ...future.elements_ii    :List of 3
[13:33:37.139]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:33:37.139]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:33:37.139]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:33:37.139]  $ ...future.seeds_ii       : NULL
[13:33:37.139]  $ ...future.globals.maxSize: num Inf
[13:33:37.139]  - attr(*, "resolved")= logi FALSE
[13:33:37.139]  - attr(*, "total_size")= num NA
[13:33:37.139]  - attr(*, "where")=List of 5
[13:33:37.139]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.139]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.139]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.139]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.139]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.139]  - attr(*, "already-done")= logi TRUE
[13:33:37.144] - copied ‘future.call.arguments’ to environment
[13:33:37.144] - copied ‘...future.FUN’ to environment
[13:33:37.144] - copied ‘...future.elements_ii’ to environment
[13:33:37.144] - copied ‘...future.seeds_ii’ to environment
[13:33:37.145] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.145] assign_globals() ... done
[13:33:37.145] requestCore(): workers = 2
[13:33:37.147] MulticoreFuture started
[13:33:37.147] - Launch lazy future ... done
[13:33:37.147] run() for ‘MulticoreFuture’ ... done
[13:33:37.148] Created future:
[13:33:37.148] plan(): Setting new future strategy stack:
[13:33:37.148] List of future strategies:
[13:33:37.148] 1. sequential:
[13:33:37.148]    - args: function (..., envir = parent.frame())
[13:33:37.148]    - tweaked: FALSE
[13:33:37.148]    - call: NULL
[13:33:37.149] plan(): nbrOfWorkers() = 1
[13:33:37.151] plan(): Setting new future strategy stack:
[13:33:37.151] List of future strategies:
[13:33:37.151] 1. multicore:
[13:33:37.151]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.151]    - tweaked: FALSE
[13:33:37.151]    - call: plan(strategy)
[13:33:37.156] plan(): nbrOfWorkers() = 2
[13:33:37.148] MulticoreFuture:
[13:33:37.148] Label: ‘future_apply-1’
[13:33:37.148] Expression:
[13:33:37.148] {
[13:33:37.148]     do.call(function(...) {
[13:33:37.148]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.148]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.148]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.148]             on.exit(options(oopts), add = TRUE)
[13:33:37.148]         }
[13:33:37.148]         {
[13:33:37.148]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.148]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.148]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.148]             })
[13:33:37.148]         }
[13:33:37.148]     }, args = future.call.arguments)
[13:33:37.148] }
[13:33:37.148] Lazy evaluation: FALSE
[13:33:37.148] Asynchronous evaluation: TRUE
[13:33:37.148] Local evaluation: TRUE
[13:33:37.148] Environment: R_GlobalEnv
[13:33:37.148] Capture standard output: TRUE
[13:33:37.148] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.148] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.148] Packages: <none>
[13:33:37.148] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.148] Resolved: TRUE
[13:33:37.148] Value: <not collected>
[13:33:37.148] Conditions captured: <none>
[13:33:37.148] Early signaling: FALSE
[13:33:37.148] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.148] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.157] Chunk #1 of 2 ... DONE
[13:33:37.157] Chunk #2 of 2 ...
[13:33:37.157]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.157]  - seeds: <none>
[13:33:37.158]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.158] getGlobalsAndPackages() ...
[13:33:37.158] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.158] Resolving globals: FALSE
[13:33:37.158] Tweak future expression to call with '...' arguments ...
[13:33:37.158] {
[13:33:37.158]     do.call(function(...) {
[13:33:37.158]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.158]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.158]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.158]             on.exit(options(oopts), add = TRUE)
[13:33:37.158]         }
[13:33:37.158]         {
[13:33:37.158]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.158]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.158]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.158]             })
[13:33:37.158]         }
[13:33:37.158]     }, args = future.call.arguments)
[13:33:37.158] }
[13:33:37.159] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.159] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.160] 
[13:33:37.160] getGlobalsAndPackages() ... DONE
[13:33:37.160] run() for ‘Future’ ...
[13:33:37.160] - state: ‘created’
[13:33:37.161] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.170] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.171]   - Field: ‘label’
[13:33:37.171]   - Field: ‘local’
[13:33:37.171]   - Field: ‘owner’
[13:33:37.172]   - Field: ‘envir’
[13:33:37.172]   - Field: ‘workers’
[13:33:37.172]   - Field: ‘packages’
[13:33:37.172]   - Field: ‘gc’
[13:33:37.173]   - Field: ‘job’
[13:33:37.173]   - Field: ‘conditions’
[13:33:37.173]   - Field: ‘expr’
[13:33:37.173]   - Field: ‘uuid’
[13:33:37.174]   - Field: ‘seed’
[13:33:37.174]   - Field: ‘version’
[13:33:37.174]   - Field: ‘result’
[13:33:37.174]   - Field: ‘asynchronous’
[13:33:37.175]   - Field: ‘calls’
[13:33:37.175]   - Field: ‘globals’
[13:33:37.175]   - Field: ‘stdout’
[13:33:37.175]   - Field: ‘earlySignal’
[13:33:37.175]   - Field: ‘lazy’
[13:33:37.175]   - Field: ‘state’
[13:33:37.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.176] - Launch lazy future ...
[13:33:37.176] Packages needed by the future expression (n = 0): <none>
[13:33:37.176] Packages needed by future strategies (n = 0): <none>
[13:33:37.177] {
[13:33:37.177]     {
[13:33:37.177]         {
[13:33:37.177]             ...future.startTime <- base::Sys.time()
[13:33:37.177]             {
[13:33:37.177]                 {
[13:33:37.177]                   {
[13:33:37.177]                     {
[13:33:37.177]                       base::local({
[13:33:37.177]                         has_future <- base::requireNamespace("future", 
[13:33:37.177]                           quietly = TRUE)
[13:33:37.177]                         if (has_future) {
[13:33:37.177]                           ns <- base::getNamespace("future")
[13:33:37.177]                           version <- ns[[".package"]][["version"]]
[13:33:37.177]                           if (is.null(version)) 
[13:33:37.177]                             version <- utils::packageVersion("future")
[13:33:37.177]                         }
[13:33:37.177]                         else {
[13:33:37.177]                           version <- NULL
[13:33:37.177]                         }
[13:33:37.177]                         if (!has_future || version < "1.8.0") {
[13:33:37.177]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.177]                             "", base::R.version$version.string), 
[13:33:37.177]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.177]                               "release", "version")], collapse = " "), 
[13:33:37.177]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.177]                             info)
[13:33:37.177]                           info <- base::paste(info, collapse = "; ")
[13:33:37.177]                           if (!has_future) {
[13:33:37.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.177]                               info)
[13:33:37.177]                           }
[13:33:37.177]                           else {
[13:33:37.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.177]                               info, version)
[13:33:37.177]                           }
[13:33:37.177]                           base::stop(msg)
[13:33:37.177]                         }
[13:33:37.177]                       })
[13:33:37.177]                     }
[13:33:37.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.177]                     base::options(mc.cores = 1L)
[13:33:37.177]                   }
[13:33:37.177]                   ...future.strategy.old <- future::plan("list")
[13:33:37.177]                   options(future.plan = NULL)
[13:33:37.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.177]                 }
[13:33:37.177]                 ...future.workdir <- getwd()
[13:33:37.177]             }
[13:33:37.177]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.177]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.177]         }
[13:33:37.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.177]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.177]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.177]             base::names(...future.oldOptions))
[13:33:37.177]     }
[13:33:37.177]     if (FALSE) {
[13:33:37.177]     }
[13:33:37.177]     else {
[13:33:37.177]         if (TRUE) {
[13:33:37.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.177]                 open = "w")
[13:33:37.177]         }
[13:33:37.177]         else {
[13:33:37.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.177]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.177]         }
[13:33:37.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.177]             base::sink(type = "output", split = FALSE)
[13:33:37.177]             base::close(...future.stdout)
[13:33:37.177]         }, add = TRUE)
[13:33:37.177]     }
[13:33:37.177]     ...future.frame <- base::sys.nframe()
[13:33:37.177]     ...future.conditions <- base::list()
[13:33:37.177]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.177]     if (FALSE) {
[13:33:37.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.177]     }
[13:33:37.177]     ...future.result <- base::tryCatch({
[13:33:37.177]         base::withCallingHandlers({
[13:33:37.177]             ...future.value <- base::withVisible(base::local({
[13:33:37.177]                 withCallingHandlers({
[13:33:37.177]                   {
[13:33:37.177]                     do.call(function(...) {
[13:33:37.177]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.177]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.177]                         ...future.globals.maxSize)) {
[13:33:37.177]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.177]                         on.exit(options(oopts), add = TRUE)
[13:33:37.177]                       }
[13:33:37.177]                       {
[13:33:37.177]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.177]                           FUN = function(jj) {
[13:33:37.177]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.177]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.177]                           })
[13:33:37.177]                       }
[13:33:37.177]                     }, args = future.call.arguments)
[13:33:37.177]                   }
[13:33:37.177]                 }, immediateCondition = function(cond) {
[13:33:37.177]                   save_rds <- function (object, pathname, ...) 
[13:33:37.177]                   {
[13:33:37.177]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.177]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.177]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.177]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.177]                         fi_tmp[["mtime"]])
[13:33:37.177]                     }
[13:33:37.177]                     tryCatch({
[13:33:37.177]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.177]                     }, error = function(ex) {
[13:33:37.177]                       msg <- conditionMessage(ex)
[13:33:37.177]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.177]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.177]                         fi_tmp[["mtime"]], msg)
[13:33:37.177]                       ex$message <- msg
[13:33:37.177]                       stop(ex)
[13:33:37.177]                     })
[13:33:37.177]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.177]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.177]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.177]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.177]                       fi <- file.info(pathname)
[13:33:37.177]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.177]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.177]                         fi[["size"]], fi[["mtime"]])
[13:33:37.177]                       stop(msg)
[13:33:37.177]                     }
[13:33:37.177]                     invisible(pathname)
[13:33:37.177]                   }
[13:33:37.177]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.177]                     rootPath = tempdir()) 
[13:33:37.177]                   {
[13:33:37.177]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.177]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.177]                       tmpdir = path, fileext = ".rds")
[13:33:37.177]                     save_rds(obj, file)
[13:33:37.177]                   }
[13:33:37.177]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.177]                   {
[13:33:37.177]                     inherits <- base::inherits
[13:33:37.177]                     invokeRestart <- base::invokeRestart
[13:33:37.177]                     is.null <- base::is.null
[13:33:37.177]                     muffled <- FALSE
[13:33:37.177]                     if (inherits(cond, "message")) {
[13:33:37.177]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.177]                       if (muffled) 
[13:33:37.177]                         invokeRestart("muffleMessage")
[13:33:37.177]                     }
[13:33:37.177]                     else if (inherits(cond, "warning")) {
[13:33:37.177]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.177]                       if (muffled) 
[13:33:37.177]                         invokeRestart("muffleWarning")
[13:33:37.177]                     }
[13:33:37.177]                     else if (inherits(cond, "condition")) {
[13:33:37.177]                       if (!is.null(pattern)) {
[13:33:37.177]                         computeRestarts <- base::computeRestarts
[13:33:37.177]                         grepl <- base::grepl
[13:33:37.177]                         restarts <- computeRestarts(cond)
[13:33:37.177]                         for (restart in restarts) {
[13:33:37.177]                           name <- restart$name
[13:33:37.177]                           if (is.null(name)) 
[13:33:37.177]                             next
[13:33:37.177]                           if (!grepl(pattern, name)) 
[13:33:37.177]                             next
[13:33:37.177]                           invokeRestart(restart)
[13:33:37.177]                           muffled <- TRUE
[13:33:37.177]                           break
[13:33:37.177]                         }
[13:33:37.177]                       }
[13:33:37.177]                     }
[13:33:37.177]                     invisible(muffled)
[13:33:37.177]                   }
[13:33:37.177]                   muffleCondition(cond)
[13:33:37.177]                 })
[13:33:37.177]             }))
[13:33:37.177]             future::FutureResult(value = ...future.value$value, 
[13:33:37.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.177]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.177]                     ...future.globalenv.names))
[13:33:37.177]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.177]         }, condition = base::local({
[13:33:37.177]             c <- base::c
[13:33:37.177]             inherits <- base::inherits
[13:33:37.177]             invokeRestart <- base::invokeRestart
[13:33:37.177]             length <- base::length
[13:33:37.177]             list <- base::list
[13:33:37.177]             seq.int <- base::seq.int
[13:33:37.177]             signalCondition <- base::signalCondition
[13:33:37.177]             sys.calls <- base::sys.calls
[13:33:37.177]             `[[` <- base::`[[`
[13:33:37.177]             `+` <- base::`+`
[13:33:37.177]             `<<-` <- base::`<<-`
[13:33:37.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.177]                   3L)]
[13:33:37.177]             }
[13:33:37.177]             function(cond) {
[13:33:37.177]                 is_error <- inherits(cond, "error")
[13:33:37.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.177]                   NULL)
[13:33:37.177]                 if (is_error) {
[13:33:37.177]                   sessionInformation <- function() {
[13:33:37.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.177]                       search = base::search(), system = base::Sys.info())
[13:33:37.177]                   }
[13:33:37.177]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.177]                     cond$call), session = sessionInformation(), 
[13:33:37.177]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.177]                   signalCondition(cond)
[13:33:37.177]                 }
[13:33:37.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.177]                 "immediateCondition"))) {
[13:33:37.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.177]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.177]                   if (TRUE && !signal) {
[13:33:37.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.177]                     {
[13:33:37.177]                       inherits <- base::inherits
[13:33:37.177]                       invokeRestart <- base::invokeRestart
[13:33:37.177]                       is.null <- base::is.null
[13:33:37.177]                       muffled <- FALSE
[13:33:37.177]                       if (inherits(cond, "message")) {
[13:33:37.177]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.177]                         if (muffled) 
[13:33:37.177]                           invokeRestart("muffleMessage")
[13:33:37.177]                       }
[13:33:37.177]                       else if (inherits(cond, "warning")) {
[13:33:37.177]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.177]                         if (muffled) 
[13:33:37.177]                           invokeRestart("muffleWarning")
[13:33:37.177]                       }
[13:33:37.177]                       else if (inherits(cond, "condition")) {
[13:33:37.177]                         if (!is.null(pattern)) {
[13:33:37.177]                           computeRestarts <- base::computeRestarts
[13:33:37.177]                           grepl <- base::grepl
[13:33:37.177]                           restarts <- computeRestarts(cond)
[13:33:37.177]                           for (restart in restarts) {
[13:33:37.177]                             name <- restart$name
[13:33:37.177]                             if (is.null(name)) 
[13:33:37.177]                               next
[13:33:37.177]                             if (!grepl(pattern, name)) 
[13:33:37.177]                               next
[13:33:37.177]                             invokeRestart(restart)
[13:33:37.177]                             muffled <- TRUE
[13:33:37.177]                             break
[13:33:37.177]                           }
[13:33:37.177]                         }
[13:33:37.177]                       }
[13:33:37.177]                       invisible(muffled)
[13:33:37.177]                     }
[13:33:37.177]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.177]                   }
[13:33:37.177]                 }
[13:33:37.177]                 else {
[13:33:37.177]                   if (TRUE) {
[13:33:37.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.177]                     {
[13:33:37.177]                       inherits <- base::inherits
[13:33:37.177]                       invokeRestart <- base::invokeRestart
[13:33:37.177]                       is.null <- base::is.null
[13:33:37.177]                       muffled <- FALSE
[13:33:37.177]                       if (inherits(cond, "message")) {
[13:33:37.177]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.177]                         if (muffled) 
[13:33:37.177]                           invokeRestart("muffleMessage")
[13:33:37.177]                       }
[13:33:37.177]                       else if (inherits(cond, "warning")) {
[13:33:37.177]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.177]                         if (muffled) 
[13:33:37.177]                           invokeRestart("muffleWarning")
[13:33:37.177]                       }
[13:33:37.177]                       else if (inherits(cond, "condition")) {
[13:33:37.177]                         if (!is.null(pattern)) {
[13:33:37.177]                           computeRestarts <- base::computeRestarts
[13:33:37.177]                           grepl <- base::grepl
[13:33:37.177]                           restarts <- computeRestarts(cond)
[13:33:37.177]                           for (restart in restarts) {
[13:33:37.177]                             name <- restart$name
[13:33:37.177]                             if (is.null(name)) 
[13:33:37.177]                               next
[13:33:37.177]                             if (!grepl(pattern, name)) 
[13:33:37.177]                               next
[13:33:37.177]                             invokeRestart(restart)
[13:33:37.177]                             muffled <- TRUE
[13:33:37.177]                             break
[13:33:37.177]                           }
[13:33:37.177]                         }
[13:33:37.177]                       }
[13:33:37.177]                       invisible(muffled)
[13:33:37.177]                     }
[13:33:37.177]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.177]                   }
[13:33:37.177]                 }
[13:33:37.177]             }
[13:33:37.177]         }))
[13:33:37.177]     }, error = function(ex) {
[13:33:37.177]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.177]                 ...future.rng), started = ...future.startTime, 
[13:33:37.177]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.177]             version = "1.8"), class = "FutureResult")
[13:33:37.177]     }, finally = {
[13:33:37.177]         if (!identical(...future.workdir, getwd())) 
[13:33:37.177]             setwd(...future.workdir)
[13:33:37.177]         {
[13:33:37.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.177]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.177]             }
[13:33:37.177]             base::options(...future.oldOptions)
[13:33:37.177]             if (.Platform$OS.type == "windows") {
[13:33:37.177]                 old_names <- names(...future.oldEnvVars)
[13:33:37.177]                 envs <- base::Sys.getenv()
[13:33:37.177]                 names <- names(envs)
[13:33:37.177]                 common <- intersect(names, old_names)
[13:33:37.177]                 added <- setdiff(names, old_names)
[13:33:37.177]                 removed <- setdiff(old_names, names)
[13:33:37.177]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.177]                   envs[common]]
[13:33:37.177]                 NAMES <- toupper(changed)
[13:33:37.177]                 args <- list()
[13:33:37.177]                 for (kk in seq_along(NAMES)) {
[13:33:37.177]                   name <- changed[[kk]]
[13:33:37.177]                   NAME <- NAMES[[kk]]
[13:33:37.177]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.177]                     next
[13:33:37.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.177]                 }
[13:33:37.177]                 NAMES <- toupper(added)
[13:33:37.177]                 for (kk in seq_along(NAMES)) {
[13:33:37.177]                   name <- added[[kk]]
[13:33:37.177]                   NAME <- NAMES[[kk]]
[13:33:37.177]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.177]                     next
[13:33:37.177]                   args[[name]] <- ""
[13:33:37.177]                 }
[13:33:37.177]                 NAMES <- toupper(removed)
[13:33:37.177]                 for (kk in seq_along(NAMES)) {
[13:33:37.177]                   name <- removed[[kk]]
[13:33:37.177]                   NAME <- NAMES[[kk]]
[13:33:37.177]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.177]                     next
[13:33:37.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.177]                 }
[13:33:37.177]                 if (length(args) > 0) 
[13:33:37.177]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.177]             }
[13:33:37.177]             else {
[13:33:37.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.177]             }
[13:33:37.177]             {
[13:33:37.177]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.177]                   0L) {
[13:33:37.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.177]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.177]                   base::options(opts)
[13:33:37.177]                 }
[13:33:37.177]                 {
[13:33:37.177]                   {
[13:33:37.177]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.177]                     NULL
[13:33:37.177]                   }
[13:33:37.177]                   options(future.plan = NULL)
[13:33:37.177]                   if (is.na(NA_character_)) 
[13:33:37.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.177]                     .init = FALSE)
[13:33:37.177]                 }
[13:33:37.177]             }
[13:33:37.177]         }
[13:33:37.177]     })
[13:33:37.177]     if (TRUE) {
[13:33:37.177]         base::sink(type = "output", split = FALSE)
[13:33:37.177]         if (TRUE) {
[13:33:37.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.177]         }
[13:33:37.177]         else {
[13:33:37.177]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.177]         }
[13:33:37.177]         base::close(...future.stdout)
[13:33:37.177]         ...future.stdout <- NULL
[13:33:37.177]     }
[13:33:37.177]     ...future.result$conditions <- ...future.conditions
[13:33:37.177]     ...future.result$finished <- base::Sys.time()
[13:33:37.177]     ...future.result
[13:33:37.177] }
[13:33:37.180] assign_globals() ...
[13:33:37.180] List of 5
[13:33:37.180]  $ future.call.arguments    : list()
[13:33:37.180]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.180]  $ ...future.FUN            :function (x)  
[13:33:37.180]  $ ...future.elements_ii    :List of 3
[13:33:37.180]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:33:37.180]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:33:37.180]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:33:37.180]  $ ...future.seeds_ii       : NULL
[13:33:37.180]  $ ...future.globals.maxSize: num Inf
[13:33:37.180]  - attr(*, "resolved")= logi FALSE
[13:33:37.180]  - attr(*, "total_size")= num NA
[13:33:37.180]  - attr(*, "where")=List of 5
[13:33:37.180]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.180]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.180]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.180]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.180]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.180]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.180]  - attr(*, "already-done")= logi TRUE
[13:33:37.188] - copied ‘future.call.arguments’ to environment
[13:33:37.188] - copied ‘...future.FUN’ to environment
[13:33:37.188] - copied ‘...future.elements_ii’ to environment
[13:33:37.188] - copied ‘...future.seeds_ii’ to environment
[13:33:37.188] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.189] assign_globals() ... done
[13:33:37.189] requestCore(): workers = 2
[13:33:37.191] MulticoreFuture started
[13:33:37.191] - Launch lazy future ... done
[13:33:37.191] run() for ‘MulticoreFuture’ ... done
[13:33:37.192] Created future:
[13:33:37.192] plan(): Setting new future strategy stack:
[13:33:37.192] List of future strategies:
[13:33:37.192] 1. sequential:
[13:33:37.192]    - args: function (..., envir = parent.frame())
[13:33:37.192]    - tweaked: FALSE
[13:33:37.192]    - call: NULL
[13:33:37.193] plan(): nbrOfWorkers() = 1
[13:33:37.195] plan(): Setting new future strategy stack:
[13:33:37.195] List of future strategies:
[13:33:37.195] 1. multicore:
[13:33:37.195]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.195]    - tweaked: FALSE
[13:33:37.195]    - call: plan(strategy)
[13:33:37.201] plan(): nbrOfWorkers() = 2
[13:33:37.192] MulticoreFuture:
[13:33:37.192] Label: ‘future_apply-2’
[13:33:37.192] Expression:
[13:33:37.192] {
[13:33:37.192]     do.call(function(...) {
[13:33:37.192]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.192]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.192]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.192]             on.exit(options(oopts), add = TRUE)
[13:33:37.192]         }
[13:33:37.192]         {
[13:33:37.192]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.192]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.192]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.192]             })
[13:33:37.192]         }
[13:33:37.192]     }, args = future.call.arguments)
[13:33:37.192] }
[13:33:37.192] Lazy evaluation: FALSE
[13:33:37.192] Asynchronous evaluation: TRUE
[13:33:37.192] Local evaluation: TRUE
[13:33:37.192] Environment: R_GlobalEnv
[13:33:37.192] Capture standard output: TRUE
[13:33:37.192] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.192] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.192] Packages: <none>
[13:33:37.192] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.192] Resolved: TRUE
[13:33:37.192] Value: <not collected>
[13:33:37.192] Conditions captured: <none>
[13:33:37.192] Early signaling: FALSE
[13:33:37.192] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.192] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.202] Chunk #2 of 2 ... DONE
[13:33:37.202] Launching 2 futures (chunks) ... DONE
[13:33:37.202] Resolving 2 futures (chunks) ...
[13:33:37.202] resolve() on list ...
[13:33:37.203]  recursive: 0
[13:33:37.203]  length: 2
[13:33:37.203] 
[13:33:37.203] Future #1
[13:33:37.203] result() for MulticoreFuture ...
[13:33:37.204] result() for MulticoreFuture ...
[13:33:37.204] result() for MulticoreFuture ... done
[13:33:37.205] result() for MulticoreFuture ... done
[13:33:37.205] result() for MulticoreFuture ...
[13:33:37.205] result() for MulticoreFuture ... done
[13:33:37.205] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:37.205] - nx: 2
[13:33:37.205] - relay: TRUE
[13:33:37.205] - stdout: TRUE
[13:33:37.206] - signal: TRUE
[13:33:37.206] - resignal: FALSE
[13:33:37.206] - force: TRUE
[13:33:37.206] - relayed: [n=2] FALSE, FALSE
[13:33:37.206] - queued futures: [n=2] FALSE, FALSE
[13:33:37.206]  - until=1
[13:33:37.206]  - relaying element #1
[13:33:37.207] result() for MulticoreFuture ...
[13:33:37.207] result() for MulticoreFuture ... done
[13:33:37.207] result() for MulticoreFuture ...
[13:33:37.207] result() for MulticoreFuture ... done
[13:33:37.207] result() for MulticoreFuture ...
[13:33:37.207] result() for MulticoreFuture ... done
[13:33:37.208] result() for MulticoreFuture ...
[13:33:37.208] result() for MulticoreFuture ... done
[13:33:37.208] - relayed: [n=2] TRUE, FALSE
[13:33:37.208] - queued futures: [n=2] TRUE, FALSE
[13:33:37.208] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:37.208]  length: 1 (resolved future 1)
[13:33:37.209] Future #2
[13:33:37.209] result() for MulticoreFuture ...
[13:33:37.209] result() for MulticoreFuture ...
[13:33:37.209] result() for MulticoreFuture ... done
[13:33:37.210] result() for MulticoreFuture ... done
[13:33:37.210] result() for MulticoreFuture ...
[13:33:37.210] result() for MulticoreFuture ... done
[13:33:37.210] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:37.210] - nx: 2
[13:33:37.210] - relay: TRUE
[13:33:37.210] - stdout: TRUE
[13:33:37.211] - signal: TRUE
[13:33:37.211] - resignal: FALSE
[13:33:37.211] - force: TRUE
[13:33:37.211] - relayed: [n=2] TRUE, FALSE
[13:33:37.211] - queued futures: [n=2] TRUE, FALSE
[13:33:37.211]  - until=2
[13:33:37.211]  - relaying element #2
[13:33:37.211] result() for MulticoreFuture ...
[13:33:37.212] result() for MulticoreFuture ... done
[13:33:37.212] result() for MulticoreFuture ...
[13:33:37.212] result() for MulticoreFuture ... done
[13:33:37.212] result() for MulticoreFuture ...
[13:33:37.212] result() for MulticoreFuture ... done
[13:33:37.212] result() for MulticoreFuture ...
[13:33:37.212] result() for MulticoreFuture ... done
[13:33:37.212] - relayed: [n=2] TRUE, TRUE
[13:33:37.215] - queued futures: [n=2] TRUE, TRUE
[13:33:37.215] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:37.215]  length: 0 (resolved future 2)
[13:33:37.216] Relaying remaining futures
[13:33:37.216] signalConditionsASAP(NULL, pos=0) ...
[13:33:37.216] - nx: 2
[13:33:37.216] - relay: TRUE
[13:33:37.216] - stdout: TRUE
[13:33:37.216] - signal: TRUE
[13:33:37.217] - resignal: FALSE
[13:33:37.217] - force: TRUE
[13:33:37.217] - relayed: [n=2] TRUE, TRUE
[13:33:37.217] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:37.217] - relayed: [n=2] TRUE, TRUE
[13:33:37.217] - queued futures: [n=2] TRUE, TRUE
[13:33:37.217] signalConditionsASAP(NULL, pos=0) ... done
[13:33:37.218] resolve() on list ... DONE
[13:33:37.218] result() for MulticoreFuture ...
[13:33:37.218] result() for MulticoreFuture ... done
[13:33:37.218] result() for MulticoreFuture ...
[13:33:37.218] result() for MulticoreFuture ... done
[13:33:37.218] result() for MulticoreFuture ...
[13:33:37.219] result() for MulticoreFuture ... done
[13:33:37.219] result() for MulticoreFuture ...
[13:33:37.219] result() for MulticoreFuture ... done
[13:33:37.219]  - Number of value chunks collected: 2
[13:33:37.219] Resolving 2 futures (chunks) ... DONE
[13:33:37.219] Reducing values from 2 chunks ...
[13:33:37.219]  - Number of values collected after concatenation: 6
[13:33:37.220]  - Number of values expected: 6
[13:33:37.220] Reducing values from 2 chunks ... DONE
[13:33:37.220] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[13:33:37.220] getGlobalsAndPackagesXApply() ...
[13:33:37.220]  - future.globals: TRUE
[13:33:37.221] getGlobalsAndPackages() ...
[13:33:37.221] Searching for globals...
[13:33:37.223] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[13:33:37.223] Searching for globals ... DONE
[13:33:37.223] Resolving globals: FALSE
[13:33:37.223] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[13:33:37.224] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[13:33:37.224] - globals: [1] ‘FUN’
[13:33:37.224] 
[13:33:37.224] getGlobalsAndPackages() ... DONE
[13:33:37.224]  - globals found/used: [n=1] ‘FUN’
[13:33:37.224]  - needed namespaces: [n=0] 
[13:33:37.224] Finding globals ... DONE
[13:33:37.225]  - use_args: TRUE
[13:33:37.225]  - Getting '...' globals ...
[13:33:37.225] resolve() on list ...
[13:33:37.225]  recursive: 0
[13:33:37.225]  length: 1
[13:33:37.225]  elements: ‘...’
[13:33:37.225]  length: 0 (resolved future 1)
[13:33:37.226] resolve() on list ... DONE
[13:33:37.226]    - '...' content: [n=0] 
[13:33:37.226] List of 1
[13:33:37.226]  $ ...: list()
[13:33:37.226]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.226]  - attr(*, "where")=List of 1
[13:33:37.226]   ..$ ...:<environment: 0x55b9495c09d8> 
[13:33:37.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.226]  - attr(*, "resolved")= logi TRUE
[13:33:37.226]  - attr(*, "total_size")= num NA
[13:33:37.229]  - Getting '...' globals ... DONE
[13:33:37.229] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:37.229] List of 2
[13:33:37.229]  $ ...future.FUN:function (x)  
[13:33:37.229]  $ ...          : list()
[13:33:37.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.229]  - attr(*, "where")=List of 2
[13:33:37.229]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:37.229]   ..$ ...          :<environment: 0x55b9495c09d8> 
[13:33:37.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.229]  - attr(*, "resolved")= logi FALSE
[13:33:37.229]  - attr(*, "total_size")= num 1768
[13:33:37.232] Packages to be attached in all futures: [n=0] 
[13:33:37.232] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.235] future_lapply() ...
[13:33:37.239] Number of chunks: 2
[13:33:37.239] getGlobalsAndPackagesXApply() ...
[13:33:37.239]  - future.globals: <name-value list> with names ‘list()’
[13:33:37.239]  - use_args: TRUE
[13:33:37.240] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:37.240] List of 2
[13:33:37.240]  $ ...          : list()
[13:33:37.240]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.240]  $ ...future.FUN:function (x)  
[13:33:37.240]  - attr(*, "where")=List of 2
[13:33:37.240]   ..$ ...          :<environment: 0x55b9495c09d8> 
[13:33:37.240]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:33:37.240]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.240]  - attr(*, "resolved")= logi FALSE
[13:33:37.240]  - attr(*, "total_size")= num NA
[13:33:37.244] Packages to be attached in all futures: [n=0] 
[13:33:37.244] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.244] Number of futures (= number of chunks): 2
[13:33:37.244] Launching 2 futures (chunks) ...
[13:33:37.245] Chunk #1 of 2 ...
[13:33:37.245]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.245]  - seeds: <none>
[13:33:37.245]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.245] getGlobalsAndPackages() ...
[13:33:37.245] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.245] Resolving globals: FALSE
[13:33:37.245] Tweak future expression to call with '...' arguments ...
[13:33:37.245] {
[13:33:37.245]     do.call(function(...) {
[13:33:37.245]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.245]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.245]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.245]             on.exit(options(oopts), add = TRUE)
[13:33:37.245]         }
[13:33:37.245]         {
[13:33:37.245]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.245]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.245]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.245]             })
[13:33:37.245]         }
[13:33:37.245]     }, args = future.call.arguments)
[13:33:37.245] }
[13:33:37.246] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.246] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.246] 
[13:33:37.246] getGlobalsAndPackages() ... DONE
[13:33:37.247] run() for ‘Future’ ...
[13:33:37.247] - state: ‘created’
[13:33:37.247] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.250] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.251] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.251]   - Field: ‘label’
[13:33:37.251]   - Field: ‘local’
[13:33:37.251]   - Field: ‘owner’
[13:33:37.251]   - Field: ‘envir’
[13:33:37.251]   - Field: ‘workers’
[13:33:37.251]   - Field: ‘packages’
[13:33:37.251]   - Field: ‘gc’
[13:33:37.251]   - Field: ‘job’
[13:33:37.251]   - Field: ‘conditions’
[13:33:37.252]   - Field: ‘expr’
[13:33:37.252]   - Field: ‘uuid’
[13:33:37.252]   - Field: ‘seed’
[13:33:37.252]   - Field: ‘version’
[13:33:37.252]   - Field: ‘result’
[13:33:37.252]   - Field: ‘asynchronous’
[13:33:37.252]   - Field: ‘calls’
[13:33:37.252]   - Field: ‘globals’
[13:33:37.252]   - Field: ‘stdout’
[13:33:37.252]   - Field: ‘earlySignal’
[13:33:37.252]   - Field: ‘lazy’
[13:33:37.253]   - Field: ‘state’
[13:33:37.253] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.253] - Launch lazy future ...
[13:33:37.253] Packages needed by the future expression (n = 0): <none>
[13:33:37.253] Packages needed by future strategies (n = 0): <none>
[13:33:37.254] {
[13:33:37.254]     {
[13:33:37.254]         {
[13:33:37.254]             ...future.startTime <- base::Sys.time()
[13:33:37.254]             {
[13:33:37.254]                 {
[13:33:37.254]                   {
[13:33:37.254]                     {
[13:33:37.254]                       base::local({
[13:33:37.254]                         has_future <- base::requireNamespace("future", 
[13:33:37.254]                           quietly = TRUE)
[13:33:37.254]                         if (has_future) {
[13:33:37.254]                           ns <- base::getNamespace("future")
[13:33:37.254]                           version <- ns[[".package"]][["version"]]
[13:33:37.254]                           if (is.null(version)) 
[13:33:37.254]                             version <- utils::packageVersion("future")
[13:33:37.254]                         }
[13:33:37.254]                         else {
[13:33:37.254]                           version <- NULL
[13:33:37.254]                         }
[13:33:37.254]                         if (!has_future || version < "1.8.0") {
[13:33:37.254]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.254]                             "", base::R.version$version.string), 
[13:33:37.254]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.254]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.254]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.254]                               "release", "version")], collapse = " "), 
[13:33:37.254]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.254]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.254]                             info)
[13:33:37.254]                           info <- base::paste(info, collapse = "; ")
[13:33:37.254]                           if (!has_future) {
[13:33:37.254]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.254]                               info)
[13:33:37.254]                           }
[13:33:37.254]                           else {
[13:33:37.254]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.254]                               info, version)
[13:33:37.254]                           }
[13:33:37.254]                           base::stop(msg)
[13:33:37.254]                         }
[13:33:37.254]                       })
[13:33:37.254]                     }
[13:33:37.254]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.254]                     base::options(mc.cores = 1L)
[13:33:37.254]                   }
[13:33:37.254]                   ...future.strategy.old <- future::plan("list")
[13:33:37.254]                   options(future.plan = NULL)
[13:33:37.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.254]                 }
[13:33:37.254]                 ...future.workdir <- getwd()
[13:33:37.254]             }
[13:33:37.254]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.254]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.254]         }
[13:33:37.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.254]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.254]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.254]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.254]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.254]             base::names(...future.oldOptions))
[13:33:37.254]     }
[13:33:37.254]     if (FALSE) {
[13:33:37.254]     }
[13:33:37.254]     else {
[13:33:37.254]         if (TRUE) {
[13:33:37.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.254]                 open = "w")
[13:33:37.254]         }
[13:33:37.254]         else {
[13:33:37.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.254]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.254]         }
[13:33:37.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.254]             base::sink(type = "output", split = FALSE)
[13:33:37.254]             base::close(...future.stdout)
[13:33:37.254]         }, add = TRUE)
[13:33:37.254]     }
[13:33:37.254]     ...future.frame <- base::sys.nframe()
[13:33:37.254]     ...future.conditions <- base::list()
[13:33:37.254]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.254]     if (FALSE) {
[13:33:37.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.254]     }
[13:33:37.254]     ...future.result <- base::tryCatch({
[13:33:37.254]         base::withCallingHandlers({
[13:33:37.254]             ...future.value <- base::withVisible(base::local({
[13:33:37.254]                 withCallingHandlers({
[13:33:37.254]                   {
[13:33:37.254]                     do.call(function(...) {
[13:33:37.254]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.254]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.254]                         ...future.globals.maxSize)) {
[13:33:37.254]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.254]                         on.exit(options(oopts), add = TRUE)
[13:33:37.254]                       }
[13:33:37.254]                       {
[13:33:37.254]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.254]                           FUN = function(jj) {
[13:33:37.254]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.254]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.254]                           })
[13:33:37.254]                       }
[13:33:37.254]                     }, args = future.call.arguments)
[13:33:37.254]                   }
[13:33:37.254]                 }, immediateCondition = function(cond) {
[13:33:37.254]                   save_rds <- function (object, pathname, ...) 
[13:33:37.254]                   {
[13:33:37.254]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.254]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.254]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.254]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.254]                         fi_tmp[["mtime"]])
[13:33:37.254]                     }
[13:33:37.254]                     tryCatch({
[13:33:37.254]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.254]                     }, error = function(ex) {
[13:33:37.254]                       msg <- conditionMessage(ex)
[13:33:37.254]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.254]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.254]                         fi_tmp[["mtime"]], msg)
[13:33:37.254]                       ex$message <- msg
[13:33:37.254]                       stop(ex)
[13:33:37.254]                     })
[13:33:37.254]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.254]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.254]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.254]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.254]                       fi <- file.info(pathname)
[13:33:37.254]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.254]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.254]                         fi[["size"]], fi[["mtime"]])
[13:33:37.254]                       stop(msg)
[13:33:37.254]                     }
[13:33:37.254]                     invisible(pathname)
[13:33:37.254]                   }
[13:33:37.254]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.254]                     rootPath = tempdir()) 
[13:33:37.254]                   {
[13:33:37.254]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.254]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.254]                       tmpdir = path, fileext = ".rds")
[13:33:37.254]                     save_rds(obj, file)
[13:33:37.254]                   }
[13:33:37.254]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.254]                   {
[13:33:37.254]                     inherits <- base::inherits
[13:33:37.254]                     invokeRestart <- base::invokeRestart
[13:33:37.254]                     is.null <- base::is.null
[13:33:37.254]                     muffled <- FALSE
[13:33:37.254]                     if (inherits(cond, "message")) {
[13:33:37.254]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.254]                       if (muffled) 
[13:33:37.254]                         invokeRestart("muffleMessage")
[13:33:37.254]                     }
[13:33:37.254]                     else if (inherits(cond, "warning")) {
[13:33:37.254]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.254]                       if (muffled) 
[13:33:37.254]                         invokeRestart("muffleWarning")
[13:33:37.254]                     }
[13:33:37.254]                     else if (inherits(cond, "condition")) {
[13:33:37.254]                       if (!is.null(pattern)) {
[13:33:37.254]                         computeRestarts <- base::computeRestarts
[13:33:37.254]                         grepl <- base::grepl
[13:33:37.254]                         restarts <- computeRestarts(cond)
[13:33:37.254]                         for (restart in restarts) {
[13:33:37.254]                           name <- restart$name
[13:33:37.254]                           if (is.null(name)) 
[13:33:37.254]                             next
[13:33:37.254]                           if (!grepl(pattern, name)) 
[13:33:37.254]                             next
[13:33:37.254]                           invokeRestart(restart)
[13:33:37.254]                           muffled <- TRUE
[13:33:37.254]                           break
[13:33:37.254]                         }
[13:33:37.254]                       }
[13:33:37.254]                     }
[13:33:37.254]                     invisible(muffled)
[13:33:37.254]                   }
[13:33:37.254]                   muffleCondition(cond)
[13:33:37.254]                 })
[13:33:37.254]             }))
[13:33:37.254]             future::FutureResult(value = ...future.value$value, 
[13:33:37.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.254]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.254]                     ...future.globalenv.names))
[13:33:37.254]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.254]         }, condition = base::local({
[13:33:37.254]             c <- base::c
[13:33:37.254]             inherits <- base::inherits
[13:33:37.254]             invokeRestart <- base::invokeRestart
[13:33:37.254]             length <- base::length
[13:33:37.254]             list <- base::list
[13:33:37.254]             seq.int <- base::seq.int
[13:33:37.254]             signalCondition <- base::signalCondition
[13:33:37.254]             sys.calls <- base::sys.calls
[13:33:37.254]             `[[` <- base::`[[`
[13:33:37.254]             `+` <- base::`+`
[13:33:37.254]             `<<-` <- base::`<<-`
[13:33:37.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.254]                   3L)]
[13:33:37.254]             }
[13:33:37.254]             function(cond) {
[13:33:37.254]                 is_error <- inherits(cond, "error")
[13:33:37.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.254]                   NULL)
[13:33:37.254]                 if (is_error) {
[13:33:37.254]                   sessionInformation <- function() {
[13:33:37.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.254]                       search = base::search(), system = base::Sys.info())
[13:33:37.254]                   }
[13:33:37.254]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.254]                     cond$call), session = sessionInformation(), 
[13:33:37.254]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.254]                   signalCondition(cond)
[13:33:37.254]                 }
[13:33:37.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.254]                 "immediateCondition"))) {
[13:33:37.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.254]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.254]                   if (TRUE && !signal) {
[13:33:37.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.254]                     {
[13:33:37.254]                       inherits <- base::inherits
[13:33:37.254]                       invokeRestart <- base::invokeRestart
[13:33:37.254]                       is.null <- base::is.null
[13:33:37.254]                       muffled <- FALSE
[13:33:37.254]                       if (inherits(cond, "message")) {
[13:33:37.254]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.254]                         if (muffled) 
[13:33:37.254]                           invokeRestart("muffleMessage")
[13:33:37.254]                       }
[13:33:37.254]                       else if (inherits(cond, "warning")) {
[13:33:37.254]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.254]                         if (muffled) 
[13:33:37.254]                           invokeRestart("muffleWarning")
[13:33:37.254]                       }
[13:33:37.254]                       else if (inherits(cond, "condition")) {
[13:33:37.254]                         if (!is.null(pattern)) {
[13:33:37.254]                           computeRestarts <- base::computeRestarts
[13:33:37.254]                           grepl <- base::grepl
[13:33:37.254]                           restarts <- computeRestarts(cond)
[13:33:37.254]                           for (restart in restarts) {
[13:33:37.254]                             name <- restart$name
[13:33:37.254]                             if (is.null(name)) 
[13:33:37.254]                               next
[13:33:37.254]                             if (!grepl(pattern, name)) 
[13:33:37.254]                               next
[13:33:37.254]                             invokeRestart(restart)
[13:33:37.254]                             muffled <- TRUE
[13:33:37.254]                             break
[13:33:37.254]                           }
[13:33:37.254]                         }
[13:33:37.254]                       }
[13:33:37.254]                       invisible(muffled)
[13:33:37.254]                     }
[13:33:37.254]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.254]                   }
[13:33:37.254]                 }
[13:33:37.254]                 else {
[13:33:37.254]                   if (TRUE) {
[13:33:37.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.254]                     {
[13:33:37.254]                       inherits <- base::inherits
[13:33:37.254]                       invokeRestart <- base::invokeRestart
[13:33:37.254]                       is.null <- base::is.null
[13:33:37.254]                       muffled <- FALSE
[13:33:37.254]                       if (inherits(cond, "message")) {
[13:33:37.254]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.254]                         if (muffled) 
[13:33:37.254]                           invokeRestart("muffleMessage")
[13:33:37.254]                       }
[13:33:37.254]                       else if (inherits(cond, "warning")) {
[13:33:37.254]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.254]                         if (muffled) 
[13:33:37.254]                           invokeRestart("muffleWarning")
[13:33:37.254]                       }
[13:33:37.254]                       else if (inherits(cond, "condition")) {
[13:33:37.254]                         if (!is.null(pattern)) {
[13:33:37.254]                           computeRestarts <- base::computeRestarts
[13:33:37.254]                           grepl <- base::grepl
[13:33:37.254]                           restarts <- computeRestarts(cond)
[13:33:37.254]                           for (restart in restarts) {
[13:33:37.254]                             name <- restart$name
[13:33:37.254]                             if (is.null(name)) 
[13:33:37.254]                               next
[13:33:37.254]                             if (!grepl(pattern, name)) 
[13:33:37.254]                               next
[13:33:37.254]                             invokeRestart(restart)
[13:33:37.254]                             muffled <- TRUE
[13:33:37.254]                             break
[13:33:37.254]                           }
[13:33:37.254]                         }
[13:33:37.254]                       }
[13:33:37.254]                       invisible(muffled)
[13:33:37.254]                     }
[13:33:37.254]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.254]                   }
[13:33:37.254]                 }
[13:33:37.254]             }
[13:33:37.254]         }))
[13:33:37.254]     }, error = function(ex) {
[13:33:37.254]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.254]                 ...future.rng), started = ...future.startTime, 
[13:33:37.254]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.254]             version = "1.8"), class = "FutureResult")
[13:33:37.254]     }, finally = {
[13:33:37.254]         if (!identical(...future.workdir, getwd())) 
[13:33:37.254]             setwd(...future.workdir)
[13:33:37.254]         {
[13:33:37.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.254]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.254]             }
[13:33:37.254]             base::options(...future.oldOptions)
[13:33:37.254]             if (.Platform$OS.type == "windows") {
[13:33:37.254]                 old_names <- names(...future.oldEnvVars)
[13:33:37.254]                 envs <- base::Sys.getenv()
[13:33:37.254]                 names <- names(envs)
[13:33:37.254]                 common <- intersect(names, old_names)
[13:33:37.254]                 added <- setdiff(names, old_names)
[13:33:37.254]                 removed <- setdiff(old_names, names)
[13:33:37.254]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.254]                   envs[common]]
[13:33:37.254]                 NAMES <- toupper(changed)
[13:33:37.254]                 args <- list()
[13:33:37.254]                 for (kk in seq_along(NAMES)) {
[13:33:37.254]                   name <- changed[[kk]]
[13:33:37.254]                   NAME <- NAMES[[kk]]
[13:33:37.254]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.254]                     next
[13:33:37.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.254]                 }
[13:33:37.254]                 NAMES <- toupper(added)
[13:33:37.254]                 for (kk in seq_along(NAMES)) {
[13:33:37.254]                   name <- added[[kk]]
[13:33:37.254]                   NAME <- NAMES[[kk]]
[13:33:37.254]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.254]                     next
[13:33:37.254]                   args[[name]] <- ""
[13:33:37.254]                 }
[13:33:37.254]                 NAMES <- toupper(removed)
[13:33:37.254]                 for (kk in seq_along(NAMES)) {
[13:33:37.254]                   name <- removed[[kk]]
[13:33:37.254]                   NAME <- NAMES[[kk]]
[13:33:37.254]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.254]                     next
[13:33:37.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.254]                 }
[13:33:37.254]                 if (length(args) > 0) 
[13:33:37.254]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.254]             }
[13:33:37.254]             else {
[13:33:37.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.254]             }
[13:33:37.254]             {
[13:33:37.254]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.254]                   0L) {
[13:33:37.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.254]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.254]                   base::options(opts)
[13:33:37.254]                 }
[13:33:37.254]                 {
[13:33:37.254]                   {
[13:33:37.254]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.254]                     NULL
[13:33:37.254]                   }
[13:33:37.254]                   options(future.plan = NULL)
[13:33:37.254]                   if (is.na(NA_character_)) 
[13:33:37.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.254]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.254]                     .init = FALSE)
[13:33:37.254]                 }
[13:33:37.254]             }
[13:33:37.254]         }
[13:33:37.254]     })
[13:33:37.254]     if (TRUE) {
[13:33:37.254]         base::sink(type = "output", split = FALSE)
[13:33:37.254]         if (TRUE) {
[13:33:37.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.254]         }
[13:33:37.254]         else {
[13:33:37.254]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.254]         }
[13:33:37.254]         base::close(...future.stdout)
[13:33:37.254]         ...future.stdout <- NULL
[13:33:37.254]     }
[13:33:37.254]     ...future.result$conditions <- ...future.conditions
[13:33:37.254]     ...future.result$finished <- base::Sys.time()
[13:33:37.254]     ...future.result
[13:33:37.254] }
[13:33:37.256] assign_globals() ...
[13:33:37.256] List of 5
[13:33:37.256]  $ future.call.arguments    : list()
[13:33:37.256]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.256]  $ ...future.FUN            :function (x)  
[13:33:37.256]  $ ...future.elements_ii    :List of 3
[13:33:37.256]   ..$ : int [1:4] 1 7 13 19
[13:33:37.256]   ..$ : int [1:4] 2 8 14 20
[13:33:37.256]   ..$ : int [1:4] 3 9 15 21
[13:33:37.256]  $ ...future.seeds_ii       : NULL
[13:33:37.256]  $ ...future.globals.maxSize: num Inf
[13:33:37.256]  - attr(*, "resolved")= logi FALSE
[13:33:37.256]  - attr(*, "total_size")= num NA
[13:33:37.256]  - attr(*, "where")=List of 5
[13:33:37.256]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.256]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.256]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.256]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.256]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.256]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.256]  - attr(*, "already-done")= logi TRUE
[13:33:37.261] - copied ‘future.call.arguments’ to environment
[13:33:37.261] - reassign environment for ‘...future.FUN’
[13:33:37.261] - copied ‘...future.FUN’ to environment
[13:33:37.261] - copied ‘...future.elements_ii’ to environment
[13:33:37.261] - copied ‘...future.seeds_ii’ to environment
[13:33:37.261] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.262] assign_globals() ... done
[13:33:37.262] requestCore(): workers = 2
[13:33:37.264] MulticoreFuture started
[13:33:37.264] - Launch lazy future ... done
[13:33:37.264] run() for ‘MulticoreFuture’ ... done
[13:33:37.265] Created future:
[13:33:37.265] plan(): Setting new future strategy stack:
[13:33:37.265] List of future strategies:
[13:33:37.265] 1. sequential:
[13:33:37.265]    - args: function (..., envir = parent.frame())
[13:33:37.265]    - tweaked: FALSE
[13:33:37.265]    - call: NULL
[13:33:37.266] plan(): nbrOfWorkers() = 1
[13:33:37.268] plan(): Setting new future strategy stack:
[13:33:37.268] List of future strategies:
[13:33:37.268] 1. multicore:
[13:33:37.268]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.268]    - tweaked: FALSE
[13:33:37.268]    - call: plan(strategy)
[13:33:37.273] plan(): nbrOfWorkers() = 2
[13:33:37.265] MulticoreFuture:
[13:33:37.265] Label: ‘future_apply-1’
[13:33:37.265] Expression:
[13:33:37.265] {
[13:33:37.265]     do.call(function(...) {
[13:33:37.265]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.265]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.265]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.265]             on.exit(options(oopts), add = TRUE)
[13:33:37.265]         }
[13:33:37.265]         {
[13:33:37.265]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.265]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.265]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.265]             })
[13:33:37.265]         }
[13:33:37.265]     }, args = future.call.arguments)
[13:33:37.265] }
[13:33:37.265] Lazy evaluation: FALSE
[13:33:37.265] Asynchronous evaluation: TRUE
[13:33:37.265] Local evaluation: TRUE
[13:33:37.265] Environment: R_GlobalEnv
[13:33:37.265] Capture standard output: TRUE
[13:33:37.265] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.265] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.265] Packages: <none>
[13:33:37.265] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.265] Resolved: TRUE
[13:33:37.265] Value: <not collected>
[13:33:37.265] Conditions captured: <none>
[13:33:37.265] Early signaling: FALSE
[13:33:37.265] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.265] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.274] Chunk #1 of 2 ... DONE
[13:33:37.274] Chunk #2 of 2 ...
[13:33:37.274]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.275]  - seeds: <none>
[13:33:37.275]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.275] getGlobalsAndPackages() ...
[13:33:37.275] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.275] Resolving globals: FALSE
[13:33:37.275] Tweak future expression to call with '...' arguments ...
[13:33:37.275] {
[13:33:37.275]     do.call(function(...) {
[13:33:37.275]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.275]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.275]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.275]             on.exit(options(oopts), add = TRUE)
[13:33:37.275]         }
[13:33:37.275]         {
[13:33:37.275]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.275]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.275]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.275]             })
[13:33:37.275]         }
[13:33:37.275]     }, args = future.call.arguments)
[13:33:37.275] }
[13:33:37.276] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.276] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.277] 
[13:33:37.277] getGlobalsAndPackages() ... DONE
[13:33:37.277] run() for ‘Future’ ...
[13:33:37.277] - state: ‘created’
[13:33:37.278] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.282] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.282] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.286]   - Field: ‘label’
[13:33:37.286]   - Field: ‘local’
[13:33:37.286]   - Field: ‘owner’
[13:33:37.287]   - Field: ‘envir’
[13:33:37.287]   - Field: ‘workers’
[13:33:37.287]   - Field: ‘packages’
[13:33:37.288]   - Field: ‘gc’
[13:33:37.288]   - Field: ‘job’
[13:33:37.288]   - Field: ‘conditions’
[13:33:37.289]   - Field: ‘expr’
[13:33:37.289]   - Field: ‘uuid’
[13:33:37.289]   - Field: ‘seed’
[13:33:37.289]   - Field: ‘version’
[13:33:37.289]   - Field: ‘result’
[13:33:37.290]   - Field: ‘asynchronous’
[13:33:37.290]   - Field: ‘calls’
[13:33:37.290]   - Field: ‘globals’
[13:33:37.291]   - Field: ‘stdout’
[13:33:37.291]   - Field: ‘earlySignal’
[13:33:37.291]   - Field: ‘lazy’
[13:33:37.291]   - Field: ‘state’
[13:33:37.292] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.292] - Launch lazy future ...
[13:33:37.292] Packages needed by the future expression (n = 0): <none>
[13:33:37.293] Packages needed by future strategies (n = 0): <none>
[13:33:37.294] {
[13:33:37.294]     {
[13:33:37.294]         {
[13:33:37.294]             ...future.startTime <- base::Sys.time()
[13:33:37.294]             {
[13:33:37.294]                 {
[13:33:37.294]                   {
[13:33:37.294]                     {
[13:33:37.294]                       base::local({
[13:33:37.294]                         has_future <- base::requireNamespace("future", 
[13:33:37.294]                           quietly = TRUE)
[13:33:37.294]                         if (has_future) {
[13:33:37.294]                           ns <- base::getNamespace("future")
[13:33:37.294]                           version <- ns[[".package"]][["version"]]
[13:33:37.294]                           if (is.null(version)) 
[13:33:37.294]                             version <- utils::packageVersion("future")
[13:33:37.294]                         }
[13:33:37.294]                         else {
[13:33:37.294]                           version <- NULL
[13:33:37.294]                         }
[13:33:37.294]                         if (!has_future || version < "1.8.0") {
[13:33:37.294]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.294]                             "", base::R.version$version.string), 
[13:33:37.294]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.294]                               "release", "version")], collapse = " "), 
[13:33:37.294]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.294]                             info)
[13:33:37.294]                           info <- base::paste(info, collapse = "; ")
[13:33:37.294]                           if (!has_future) {
[13:33:37.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.294]                               info)
[13:33:37.294]                           }
[13:33:37.294]                           else {
[13:33:37.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.294]                               info, version)
[13:33:37.294]                           }
[13:33:37.294]                           base::stop(msg)
[13:33:37.294]                         }
[13:33:37.294]                       })
[13:33:37.294]                     }
[13:33:37.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.294]                     base::options(mc.cores = 1L)
[13:33:37.294]                   }
[13:33:37.294]                   ...future.strategy.old <- future::plan("list")
[13:33:37.294]                   options(future.plan = NULL)
[13:33:37.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.294]                 }
[13:33:37.294]                 ...future.workdir <- getwd()
[13:33:37.294]             }
[13:33:37.294]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.294]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.294]         }
[13:33:37.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.294]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.294]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.294]             base::names(...future.oldOptions))
[13:33:37.294]     }
[13:33:37.294]     if (FALSE) {
[13:33:37.294]     }
[13:33:37.294]     else {
[13:33:37.294]         if (TRUE) {
[13:33:37.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.294]                 open = "w")
[13:33:37.294]         }
[13:33:37.294]         else {
[13:33:37.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.294]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.294]         }
[13:33:37.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.294]             base::sink(type = "output", split = FALSE)
[13:33:37.294]             base::close(...future.stdout)
[13:33:37.294]         }, add = TRUE)
[13:33:37.294]     }
[13:33:37.294]     ...future.frame <- base::sys.nframe()
[13:33:37.294]     ...future.conditions <- base::list()
[13:33:37.294]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.294]     if (FALSE) {
[13:33:37.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.294]     }
[13:33:37.294]     ...future.result <- base::tryCatch({
[13:33:37.294]         base::withCallingHandlers({
[13:33:37.294]             ...future.value <- base::withVisible(base::local({
[13:33:37.294]                 withCallingHandlers({
[13:33:37.294]                   {
[13:33:37.294]                     do.call(function(...) {
[13:33:37.294]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.294]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.294]                         ...future.globals.maxSize)) {
[13:33:37.294]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.294]                         on.exit(options(oopts), add = TRUE)
[13:33:37.294]                       }
[13:33:37.294]                       {
[13:33:37.294]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.294]                           FUN = function(jj) {
[13:33:37.294]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.294]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.294]                           })
[13:33:37.294]                       }
[13:33:37.294]                     }, args = future.call.arguments)
[13:33:37.294]                   }
[13:33:37.294]                 }, immediateCondition = function(cond) {
[13:33:37.294]                   save_rds <- function (object, pathname, ...) 
[13:33:37.294]                   {
[13:33:37.294]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.294]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.294]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.294]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.294]                         fi_tmp[["mtime"]])
[13:33:37.294]                     }
[13:33:37.294]                     tryCatch({
[13:33:37.294]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.294]                     }, error = function(ex) {
[13:33:37.294]                       msg <- conditionMessage(ex)
[13:33:37.294]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.294]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.294]                         fi_tmp[["mtime"]], msg)
[13:33:37.294]                       ex$message <- msg
[13:33:37.294]                       stop(ex)
[13:33:37.294]                     })
[13:33:37.294]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.294]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.294]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.294]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.294]                       fi <- file.info(pathname)
[13:33:37.294]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.294]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.294]                         fi[["size"]], fi[["mtime"]])
[13:33:37.294]                       stop(msg)
[13:33:37.294]                     }
[13:33:37.294]                     invisible(pathname)
[13:33:37.294]                   }
[13:33:37.294]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.294]                     rootPath = tempdir()) 
[13:33:37.294]                   {
[13:33:37.294]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.294]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.294]                       tmpdir = path, fileext = ".rds")
[13:33:37.294]                     save_rds(obj, file)
[13:33:37.294]                   }
[13:33:37.294]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.294]                   {
[13:33:37.294]                     inherits <- base::inherits
[13:33:37.294]                     invokeRestart <- base::invokeRestart
[13:33:37.294]                     is.null <- base::is.null
[13:33:37.294]                     muffled <- FALSE
[13:33:37.294]                     if (inherits(cond, "message")) {
[13:33:37.294]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.294]                       if (muffled) 
[13:33:37.294]                         invokeRestart("muffleMessage")
[13:33:37.294]                     }
[13:33:37.294]                     else if (inherits(cond, "warning")) {
[13:33:37.294]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.294]                       if (muffled) 
[13:33:37.294]                         invokeRestart("muffleWarning")
[13:33:37.294]                     }
[13:33:37.294]                     else if (inherits(cond, "condition")) {
[13:33:37.294]                       if (!is.null(pattern)) {
[13:33:37.294]                         computeRestarts <- base::computeRestarts
[13:33:37.294]                         grepl <- base::grepl
[13:33:37.294]                         restarts <- computeRestarts(cond)
[13:33:37.294]                         for (restart in restarts) {
[13:33:37.294]                           name <- restart$name
[13:33:37.294]                           if (is.null(name)) 
[13:33:37.294]                             next
[13:33:37.294]                           if (!grepl(pattern, name)) 
[13:33:37.294]                             next
[13:33:37.294]                           invokeRestart(restart)
[13:33:37.294]                           muffled <- TRUE
[13:33:37.294]                           break
[13:33:37.294]                         }
[13:33:37.294]                       }
[13:33:37.294]                     }
[13:33:37.294]                     invisible(muffled)
[13:33:37.294]                   }
[13:33:37.294]                   muffleCondition(cond)
[13:33:37.294]                 })
[13:33:37.294]             }))
[13:33:37.294]             future::FutureResult(value = ...future.value$value, 
[13:33:37.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.294]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.294]                     ...future.globalenv.names))
[13:33:37.294]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.294]         }, condition = base::local({
[13:33:37.294]             c <- base::c
[13:33:37.294]             inherits <- base::inherits
[13:33:37.294]             invokeRestart <- base::invokeRestart
[13:33:37.294]             length <- base::length
[13:33:37.294]             list <- base::list
[13:33:37.294]             seq.int <- base::seq.int
[13:33:37.294]             signalCondition <- base::signalCondition
[13:33:37.294]             sys.calls <- base::sys.calls
[13:33:37.294]             `[[` <- base::`[[`
[13:33:37.294]             `+` <- base::`+`
[13:33:37.294]             `<<-` <- base::`<<-`
[13:33:37.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.294]                   3L)]
[13:33:37.294]             }
[13:33:37.294]             function(cond) {
[13:33:37.294]                 is_error <- inherits(cond, "error")
[13:33:37.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.294]                   NULL)
[13:33:37.294]                 if (is_error) {
[13:33:37.294]                   sessionInformation <- function() {
[13:33:37.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.294]                       search = base::search(), system = base::Sys.info())
[13:33:37.294]                   }
[13:33:37.294]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.294]                     cond$call), session = sessionInformation(), 
[13:33:37.294]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.294]                   signalCondition(cond)
[13:33:37.294]                 }
[13:33:37.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.294]                 "immediateCondition"))) {
[13:33:37.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.294]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.294]                   if (TRUE && !signal) {
[13:33:37.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.294]                     {
[13:33:37.294]                       inherits <- base::inherits
[13:33:37.294]                       invokeRestart <- base::invokeRestart
[13:33:37.294]                       is.null <- base::is.null
[13:33:37.294]                       muffled <- FALSE
[13:33:37.294]                       if (inherits(cond, "message")) {
[13:33:37.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.294]                         if (muffled) 
[13:33:37.294]                           invokeRestart("muffleMessage")
[13:33:37.294]                       }
[13:33:37.294]                       else if (inherits(cond, "warning")) {
[13:33:37.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.294]                         if (muffled) 
[13:33:37.294]                           invokeRestart("muffleWarning")
[13:33:37.294]                       }
[13:33:37.294]                       else if (inherits(cond, "condition")) {
[13:33:37.294]                         if (!is.null(pattern)) {
[13:33:37.294]                           computeRestarts <- base::computeRestarts
[13:33:37.294]                           grepl <- base::grepl
[13:33:37.294]                           restarts <- computeRestarts(cond)
[13:33:37.294]                           for (restart in restarts) {
[13:33:37.294]                             name <- restart$name
[13:33:37.294]                             if (is.null(name)) 
[13:33:37.294]                               next
[13:33:37.294]                             if (!grepl(pattern, name)) 
[13:33:37.294]                               next
[13:33:37.294]                             invokeRestart(restart)
[13:33:37.294]                             muffled <- TRUE
[13:33:37.294]                             break
[13:33:37.294]                           }
[13:33:37.294]                         }
[13:33:37.294]                       }
[13:33:37.294]                       invisible(muffled)
[13:33:37.294]                     }
[13:33:37.294]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.294]                   }
[13:33:37.294]                 }
[13:33:37.294]                 else {
[13:33:37.294]                   if (TRUE) {
[13:33:37.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.294]                     {
[13:33:37.294]                       inherits <- base::inherits
[13:33:37.294]                       invokeRestart <- base::invokeRestart
[13:33:37.294]                       is.null <- base::is.null
[13:33:37.294]                       muffled <- FALSE
[13:33:37.294]                       if (inherits(cond, "message")) {
[13:33:37.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.294]                         if (muffled) 
[13:33:37.294]                           invokeRestart("muffleMessage")
[13:33:37.294]                       }
[13:33:37.294]                       else if (inherits(cond, "warning")) {
[13:33:37.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.294]                         if (muffled) 
[13:33:37.294]                           invokeRestart("muffleWarning")
[13:33:37.294]                       }
[13:33:37.294]                       else if (inherits(cond, "condition")) {
[13:33:37.294]                         if (!is.null(pattern)) {
[13:33:37.294]                           computeRestarts <- base::computeRestarts
[13:33:37.294]                           grepl <- base::grepl
[13:33:37.294]                           restarts <- computeRestarts(cond)
[13:33:37.294]                           for (restart in restarts) {
[13:33:37.294]                             name <- restart$name
[13:33:37.294]                             if (is.null(name)) 
[13:33:37.294]                               next
[13:33:37.294]                             if (!grepl(pattern, name)) 
[13:33:37.294]                               next
[13:33:37.294]                             invokeRestart(restart)
[13:33:37.294]                             muffled <- TRUE
[13:33:37.294]                             break
[13:33:37.294]                           }
[13:33:37.294]                         }
[13:33:37.294]                       }
[13:33:37.294]                       invisible(muffled)
[13:33:37.294]                     }
[13:33:37.294]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.294]                   }
[13:33:37.294]                 }
[13:33:37.294]             }
[13:33:37.294]         }))
[13:33:37.294]     }, error = function(ex) {
[13:33:37.294]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.294]                 ...future.rng), started = ...future.startTime, 
[13:33:37.294]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.294]             version = "1.8"), class = "FutureResult")
[13:33:37.294]     }, finally = {
[13:33:37.294]         if (!identical(...future.workdir, getwd())) 
[13:33:37.294]             setwd(...future.workdir)
[13:33:37.294]         {
[13:33:37.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.294]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.294]             }
[13:33:37.294]             base::options(...future.oldOptions)
[13:33:37.294]             if (.Platform$OS.type == "windows") {
[13:33:37.294]                 old_names <- names(...future.oldEnvVars)
[13:33:37.294]                 envs <- base::Sys.getenv()
[13:33:37.294]                 names <- names(envs)
[13:33:37.294]                 common <- intersect(names, old_names)
[13:33:37.294]                 added <- setdiff(names, old_names)
[13:33:37.294]                 removed <- setdiff(old_names, names)
[13:33:37.294]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.294]                   envs[common]]
[13:33:37.294]                 NAMES <- toupper(changed)
[13:33:37.294]                 args <- list()
[13:33:37.294]                 for (kk in seq_along(NAMES)) {
[13:33:37.294]                   name <- changed[[kk]]
[13:33:37.294]                   NAME <- NAMES[[kk]]
[13:33:37.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.294]                     next
[13:33:37.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.294]                 }
[13:33:37.294]                 NAMES <- toupper(added)
[13:33:37.294]                 for (kk in seq_along(NAMES)) {
[13:33:37.294]                   name <- added[[kk]]
[13:33:37.294]                   NAME <- NAMES[[kk]]
[13:33:37.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.294]                     next
[13:33:37.294]                   args[[name]] <- ""
[13:33:37.294]                 }
[13:33:37.294]                 NAMES <- toupper(removed)
[13:33:37.294]                 for (kk in seq_along(NAMES)) {
[13:33:37.294]                   name <- removed[[kk]]
[13:33:37.294]                   NAME <- NAMES[[kk]]
[13:33:37.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.294]                     next
[13:33:37.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.294]                 }
[13:33:37.294]                 if (length(args) > 0) 
[13:33:37.294]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.294]             }
[13:33:37.294]             else {
[13:33:37.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.294]             }
[13:33:37.294]             {
[13:33:37.294]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.294]                   0L) {
[13:33:37.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.294]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.294]                   base::options(opts)
[13:33:37.294]                 }
[13:33:37.294]                 {
[13:33:37.294]                   {
[13:33:37.294]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.294]                     NULL
[13:33:37.294]                   }
[13:33:37.294]                   options(future.plan = NULL)
[13:33:37.294]                   if (is.na(NA_character_)) 
[13:33:37.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.294]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.294]                     .init = FALSE)
[13:33:37.294]                 }
[13:33:37.294]             }
[13:33:37.294]         }
[13:33:37.294]     })
[13:33:37.294]     if (TRUE) {
[13:33:37.294]         base::sink(type = "output", split = FALSE)
[13:33:37.294]         if (TRUE) {
[13:33:37.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.294]         }
[13:33:37.294]         else {
[13:33:37.294]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.294]         }
[13:33:37.294]         base::close(...future.stdout)
[13:33:37.294]         ...future.stdout <- NULL
[13:33:37.294]     }
[13:33:37.294]     ...future.result$conditions <- ...future.conditions
[13:33:37.294]     ...future.result$finished <- base::Sys.time()
[13:33:37.294]     ...future.result
[13:33:37.294] }
[13:33:37.296] assign_globals() ...
[13:33:37.296] List of 5
[13:33:37.296]  $ future.call.arguments    : list()
[13:33:37.296]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.296]  $ ...future.FUN            :function (x)  
[13:33:37.296]  $ ...future.elements_ii    :List of 3
[13:33:37.296]   ..$ : int [1:4] 4 10 16 22
[13:33:37.296]   ..$ : int [1:4] 5 11 17 23
[13:33:37.296]   ..$ : int [1:4] 6 12 18 24
[13:33:37.296]  $ ...future.seeds_ii       : NULL
[13:33:37.296]  $ ...future.globals.maxSize: num Inf
[13:33:37.296]  - attr(*, "resolved")= logi FALSE
[13:33:37.296]  - attr(*, "total_size")= num NA
[13:33:37.296]  - attr(*, "where")=List of 5
[13:33:37.296]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.296]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.296]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.296]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.296]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.296]  - attr(*, "already-done")= logi TRUE
[13:33:37.305] - copied ‘future.call.arguments’ to environment
[13:33:37.305] - reassign environment for ‘...future.FUN’
[13:33:37.305] - copied ‘...future.FUN’ to environment
[13:33:37.305] - copied ‘...future.elements_ii’ to environment
[13:33:37.305] - copied ‘...future.seeds_ii’ to environment
[13:33:37.305] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.305] assign_globals() ... done
[13:33:37.306] requestCore(): workers = 2
[13:33:37.308] MulticoreFuture started
[13:33:37.308] - Launch lazy future ... done
[13:33:37.308] run() for ‘MulticoreFuture’ ... done
[13:33:37.309] Created future:
[13:33:37.309] plan(): Setting new future strategy stack:
[13:33:37.309] List of future strategies:
[13:33:37.309] 1. sequential:
[13:33:37.309]    - args: function (..., envir = parent.frame())
[13:33:37.309]    - tweaked: FALSE
[13:33:37.309]    - call: NULL
[13:33:37.310] plan(): nbrOfWorkers() = 1
[13:33:37.312] plan(): Setting new future strategy stack:
[13:33:37.312] List of future strategies:
[13:33:37.312] 1. multicore:
[13:33:37.312]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.312]    - tweaked: FALSE
[13:33:37.312]    - call: plan(strategy)
[13:33:37.317] plan(): nbrOfWorkers() = 2
[13:33:37.309] MulticoreFuture:
[13:33:37.309] Label: ‘future_apply-2’
[13:33:37.309] Expression:
[13:33:37.309] {
[13:33:37.309]     do.call(function(...) {
[13:33:37.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.309]             on.exit(options(oopts), add = TRUE)
[13:33:37.309]         }
[13:33:37.309]         {
[13:33:37.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.309]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.309]             })
[13:33:37.309]         }
[13:33:37.309]     }, args = future.call.arguments)
[13:33:37.309] }
[13:33:37.309] Lazy evaluation: FALSE
[13:33:37.309] Asynchronous evaluation: TRUE
[13:33:37.309] Local evaluation: TRUE
[13:33:37.309] Environment: R_GlobalEnv
[13:33:37.309] Capture standard output: TRUE
[13:33:37.309] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.309] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.309] Packages: <none>
[13:33:37.309] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.309] Resolved: TRUE
[13:33:37.309] Value: <not collected>
[13:33:37.309] Conditions captured: <none>
[13:33:37.309] Early signaling: FALSE
[13:33:37.309] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.309] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.318] Chunk #2 of 2 ... DONE
[13:33:37.319] Launching 2 futures (chunks) ... DONE
[13:33:37.319] Resolving 2 futures (chunks) ...
[13:33:37.319] resolve() on list ...
[13:33:37.319]  recursive: 0
[13:33:37.319]  length: 2
[13:33:37.319] 
[13:33:37.320] Future #1
[13:33:37.320] result() for MulticoreFuture ...
[13:33:37.321] result() for MulticoreFuture ...
[13:33:37.321] result() for MulticoreFuture ... done
[13:33:37.321] result() for MulticoreFuture ... done
[13:33:37.321] result() for MulticoreFuture ...
[13:33:37.321] result() for MulticoreFuture ... done
[13:33:37.322] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:37.322] - nx: 2
[13:33:37.322] - relay: TRUE
[13:33:37.322] - stdout: TRUE
[13:33:37.322] - signal: TRUE
[13:33:37.322] - resignal: FALSE
[13:33:37.323] - force: TRUE
[13:33:37.323] - relayed: [n=2] FALSE, FALSE
[13:33:37.323] - queued futures: [n=2] FALSE, FALSE
[13:33:37.323]  - until=1
[13:33:37.323]  - relaying element #1
[13:33:37.323] result() for MulticoreFuture ...
[13:33:37.323] result() for MulticoreFuture ... done
[13:33:37.324] result() for MulticoreFuture ...
[13:33:37.324] result() for MulticoreFuture ... done
[13:33:37.324] result() for MulticoreFuture ...
[13:33:37.324] result() for MulticoreFuture ... done
[13:33:37.324] result() for MulticoreFuture ...
[13:33:37.324] result() for MulticoreFuture ... done
[13:33:37.324] - relayed: [n=2] TRUE, FALSE
[13:33:37.325] - queued futures: [n=2] TRUE, FALSE
[13:33:37.325] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:37.325]  length: 1 (resolved future 1)
[13:33:37.325] Future #2
[13:33:37.325] result() for MulticoreFuture ...
[13:33:37.326] result() for MulticoreFuture ...
[13:33:37.326] result() for MulticoreFuture ... done
[13:33:37.326] result() for MulticoreFuture ... done
[13:33:37.327] result() for MulticoreFuture ...
[13:33:37.327] result() for MulticoreFuture ... done
[13:33:37.327] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:37.327] - nx: 2
[13:33:37.327] - relay: TRUE
[13:33:37.327] - stdout: TRUE
[13:33:37.327] - signal: TRUE
[13:33:37.327] - resignal: FALSE
[13:33:37.328] - force: TRUE
[13:33:37.328] - relayed: [n=2] TRUE, FALSE
[13:33:37.328] - queued futures: [n=2] TRUE, FALSE
[13:33:37.328]  - until=2
[13:33:37.328]  - relaying element #2
[13:33:37.328] result() for MulticoreFuture ...
[13:33:37.328] result() for MulticoreFuture ... done
[13:33:37.328] result() for MulticoreFuture ...
[13:33:37.329] result() for MulticoreFuture ... done
[13:33:37.329] result() for MulticoreFuture ...
[13:33:37.329] result() for MulticoreFuture ... done
[13:33:37.329] result() for MulticoreFuture ...
[13:33:37.329] result() for MulticoreFuture ... done
[13:33:37.329] - relayed: [n=2] TRUE, TRUE
[13:33:37.329] - queued futures: [n=2] TRUE, TRUE
[13:33:37.329] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:37.329]  length: 0 (resolved future 2)
[13:33:37.330] Relaying remaining futures
[13:33:37.330] signalConditionsASAP(NULL, pos=0) ...
[13:33:37.330] - nx: 2
[13:33:37.330] - relay: TRUE
[13:33:37.330] - stdout: TRUE
[13:33:37.333] - signal: TRUE
[13:33:37.333] - resignal: FALSE
[13:33:37.333] - force: TRUE
[13:33:37.333] - relayed: [n=2] TRUE, TRUE
[13:33:37.333] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:37.334] - relayed: [n=2] TRUE, TRUE
[13:33:37.334] - queued futures: [n=2] TRUE, TRUE
[13:33:37.334] signalConditionsASAP(NULL, pos=0) ... done
[13:33:37.334] resolve() on list ... DONE
[13:33:37.334] result() for MulticoreFuture ...
[13:33:37.334] result() for MulticoreFuture ... done
[13:33:37.334] result() for MulticoreFuture ...
[13:33:37.335] result() for MulticoreFuture ... done
[13:33:37.335] result() for MulticoreFuture ...
[13:33:37.335] result() for MulticoreFuture ... done
[13:33:37.335] result() for MulticoreFuture ...
[13:33:37.335] result() for MulticoreFuture ... done
[13:33:37.336]  - Number of value chunks collected: 2
[13:33:37.336] Resolving 2 futures (chunks) ... DONE
[13:33:37.336] Reducing values from 2 chunks ...
[13:33:37.336]  - Number of values collected after concatenation: 6
[13:33:37.336]  - Number of values expected: 6
[13:33:37.336] Reducing values from 2 chunks ... DONE
[13:33:37.336] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[13:33:37.337] getGlobalsAndPackagesXApply() ...
[13:33:37.337]  - future.globals: TRUE
[13:33:37.337] getGlobalsAndPackages() ...
[13:33:37.337] Searching for globals...
[13:33:37.339] - globals found: [1] ‘FUN’
[13:33:37.339] Searching for globals ... DONE
[13:33:37.339] Resolving globals: FALSE
[13:33:37.339] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:37.340] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:37.340] - globals: [1] ‘FUN’
[13:33:37.340] 
[13:33:37.340] getGlobalsAndPackages() ... DONE
[13:33:37.340]  - globals found/used: [n=1] ‘FUN’
[13:33:37.340]  - needed namespaces: [n=0] 
[13:33:37.341] Finding globals ... DONE
[13:33:37.341]  - use_args: TRUE
[13:33:37.341]  - Getting '...' globals ...
[13:33:37.341] resolve() on list ...
[13:33:37.341]  recursive: 0
[13:33:37.341]  length: 1
[13:33:37.342]  elements: ‘...’
[13:33:37.342]  length: 0 (resolved future 1)
[13:33:37.342] resolve() on list ... DONE
[13:33:37.342]    - '...' content: [n=0] 
[13:33:37.342] List of 1
[13:33:37.342]  $ ...: list()
[13:33:37.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.342]  - attr(*, "where")=List of 1
[13:33:37.342]   ..$ ...:<environment: 0x55b94a4cd3d0> 
[13:33:37.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.342]  - attr(*, "resolved")= logi TRUE
[13:33:37.342]  - attr(*, "total_size")= num NA
[13:33:37.345]  - Getting '...' globals ... DONE
[13:33:37.345] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:37.345] List of 2
[13:33:37.345]  $ ...future.FUN:function (x)  
[13:33:37.345]  $ ...          : list()
[13:33:37.345]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.345]  - attr(*, "where")=List of 2
[13:33:37.345]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:37.345]   ..$ ...          :<environment: 0x55b94a4cd3d0> 
[13:33:37.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.345]  - attr(*, "resolved")= logi FALSE
[13:33:37.345]  - attr(*, "total_size")= num 848
[13:33:37.348] Packages to be attached in all futures: [n=0] 
[13:33:37.348] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.352] future_lapply() ...
[13:33:37.356] Number of chunks: 2
[13:33:37.356] getGlobalsAndPackagesXApply() ...
[13:33:37.356]  - future.globals: <name-value list> with names ‘list()’
[13:33:37.356]  - use_args: TRUE
[13:33:37.356] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:37.356] List of 2
[13:33:37.356]  $ ...          : list()
[13:33:37.356]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.356]  $ ...future.FUN:function (x)  
[13:33:37.356]  - attr(*, "where")=List of 2
[13:33:37.356]   ..$ ...          :<environment: 0x55b94a4cd3d0> 
[13:33:37.356]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:37.356]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.356]  - attr(*, "resolved")= logi FALSE
[13:33:37.356]  - attr(*, "total_size")= num NA
[13:33:37.360] Packages to be attached in all futures: [n=0] 
[13:33:37.360] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.360] Number of futures (= number of chunks): 2
[13:33:37.360] Launching 2 futures (chunks) ...
[13:33:37.362] Chunk #1 of 2 ...
[13:33:37.362]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.362]  - seeds: <none>
[13:33:37.362]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.362] getGlobalsAndPackages() ...
[13:33:37.362] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.362] Resolving globals: FALSE
[13:33:37.363] Tweak future expression to call with '...' arguments ...
[13:33:37.363] {
[13:33:37.363]     do.call(function(...) {
[13:33:37.363]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.363]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.363]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.363]             on.exit(options(oopts), add = TRUE)
[13:33:37.363]         }
[13:33:37.363]         {
[13:33:37.363]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.363]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.363]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.363]             })
[13:33:37.363]         }
[13:33:37.363]     }, args = future.call.arguments)
[13:33:37.363] }
[13:33:37.363] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.363] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.364] 
[13:33:37.364] getGlobalsAndPackages() ... DONE
[13:33:37.364] run() for ‘Future’ ...
[13:33:37.364] - state: ‘created’
[13:33:37.364] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.368] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.368]   - Field: ‘label’
[13:33:37.368]   - Field: ‘local’
[13:33:37.368]   - Field: ‘owner’
[13:33:37.368]   - Field: ‘envir’
[13:33:37.368]   - Field: ‘workers’
[13:33:37.369]   - Field: ‘packages’
[13:33:37.369]   - Field: ‘gc’
[13:33:37.369]   - Field: ‘job’
[13:33:37.369]   - Field: ‘conditions’
[13:33:37.369]   - Field: ‘expr’
[13:33:37.369]   - Field: ‘uuid’
[13:33:37.369]   - Field: ‘seed’
[13:33:37.369]   - Field: ‘version’
[13:33:37.369]   - Field: ‘result’
[13:33:37.369]   - Field: ‘asynchronous’
[13:33:37.369]   - Field: ‘calls’
[13:33:37.370]   - Field: ‘globals’
[13:33:37.370]   - Field: ‘stdout’
[13:33:37.370]   - Field: ‘earlySignal’
[13:33:37.370]   - Field: ‘lazy’
[13:33:37.370]   - Field: ‘state’
[13:33:37.370] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.370] - Launch lazy future ...
[13:33:37.370] Packages needed by the future expression (n = 0): <none>
[13:33:37.371] Packages needed by future strategies (n = 0): <none>
[13:33:37.371] {
[13:33:37.371]     {
[13:33:37.371]         {
[13:33:37.371]             ...future.startTime <- base::Sys.time()
[13:33:37.371]             {
[13:33:37.371]                 {
[13:33:37.371]                   {
[13:33:37.371]                     {
[13:33:37.371]                       base::local({
[13:33:37.371]                         has_future <- base::requireNamespace("future", 
[13:33:37.371]                           quietly = TRUE)
[13:33:37.371]                         if (has_future) {
[13:33:37.371]                           ns <- base::getNamespace("future")
[13:33:37.371]                           version <- ns[[".package"]][["version"]]
[13:33:37.371]                           if (is.null(version)) 
[13:33:37.371]                             version <- utils::packageVersion("future")
[13:33:37.371]                         }
[13:33:37.371]                         else {
[13:33:37.371]                           version <- NULL
[13:33:37.371]                         }
[13:33:37.371]                         if (!has_future || version < "1.8.0") {
[13:33:37.371]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.371]                             "", base::R.version$version.string), 
[13:33:37.371]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.371]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.371]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.371]                               "release", "version")], collapse = " "), 
[13:33:37.371]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.371]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.371]                             info)
[13:33:37.371]                           info <- base::paste(info, collapse = "; ")
[13:33:37.371]                           if (!has_future) {
[13:33:37.371]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.371]                               info)
[13:33:37.371]                           }
[13:33:37.371]                           else {
[13:33:37.371]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.371]                               info, version)
[13:33:37.371]                           }
[13:33:37.371]                           base::stop(msg)
[13:33:37.371]                         }
[13:33:37.371]                       })
[13:33:37.371]                     }
[13:33:37.371]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.371]                     base::options(mc.cores = 1L)
[13:33:37.371]                   }
[13:33:37.371]                   ...future.strategy.old <- future::plan("list")
[13:33:37.371]                   options(future.plan = NULL)
[13:33:37.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.371]                 }
[13:33:37.371]                 ...future.workdir <- getwd()
[13:33:37.371]             }
[13:33:37.371]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.371]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.371]         }
[13:33:37.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.371]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.371]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.371]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.371]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.371]             base::names(...future.oldOptions))
[13:33:37.371]     }
[13:33:37.371]     if (FALSE) {
[13:33:37.371]     }
[13:33:37.371]     else {
[13:33:37.371]         if (TRUE) {
[13:33:37.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.371]                 open = "w")
[13:33:37.371]         }
[13:33:37.371]         else {
[13:33:37.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.371]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.371]         }
[13:33:37.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.371]             base::sink(type = "output", split = FALSE)
[13:33:37.371]             base::close(...future.stdout)
[13:33:37.371]         }, add = TRUE)
[13:33:37.371]     }
[13:33:37.371]     ...future.frame <- base::sys.nframe()
[13:33:37.371]     ...future.conditions <- base::list()
[13:33:37.371]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.371]     if (FALSE) {
[13:33:37.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.371]     }
[13:33:37.371]     ...future.result <- base::tryCatch({
[13:33:37.371]         base::withCallingHandlers({
[13:33:37.371]             ...future.value <- base::withVisible(base::local({
[13:33:37.371]                 withCallingHandlers({
[13:33:37.371]                   {
[13:33:37.371]                     do.call(function(...) {
[13:33:37.371]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.371]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.371]                         ...future.globals.maxSize)) {
[13:33:37.371]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.371]                         on.exit(options(oopts), add = TRUE)
[13:33:37.371]                       }
[13:33:37.371]                       {
[13:33:37.371]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.371]                           FUN = function(jj) {
[13:33:37.371]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.371]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.371]                           })
[13:33:37.371]                       }
[13:33:37.371]                     }, args = future.call.arguments)
[13:33:37.371]                   }
[13:33:37.371]                 }, immediateCondition = function(cond) {
[13:33:37.371]                   save_rds <- function (object, pathname, ...) 
[13:33:37.371]                   {
[13:33:37.371]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.371]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.371]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.371]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.371]                         fi_tmp[["mtime"]])
[13:33:37.371]                     }
[13:33:37.371]                     tryCatch({
[13:33:37.371]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.371]                     }, error = function(ex) {
[13:33:37.371]                       msg <- conditionMessage(ex)
[13:33:37.371]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.371]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.371]                         fi_tmp[["mtime"]], msg)
[13:33:37.371]                       ex$message <- msg
[13:33:37.371]                       stop(ex)
[13:33:37.371]                     })
[13:33:37.371]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.371]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.371]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.371]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.371]                       fi <- file.info(pathname)
[13:33:37.371]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.371]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.371]                         fi[["size"]], fi[["mtime"]])
[13:33:37.371]                       stop(msg)
[13:33:37.371]                     }
[13:33:37.371]                     invisible(pathname)
[13:33:37.371]                   }
[13:33:37.371]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.371]                     rootPath = tempdir()) 
[13:33:37.371]                   {
[13:33:37.371]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.371]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.371]                       tmpdir = path, fileext = ".rds")
[13:33:37.371]                     save_rds(obj, file)
[13:33:37.371]                   }
[13:33:37.371]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.371]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.371]                   {
[13:33:37.371]                     inherits <- base::inherits
[13:33:37.371]                     invokeRestart <- base::invokeRestart
[13:33:37.371]                     is.null <- base::is.null
[13:33:37.371]                     muffled <- FALSE
[13:33:37.371]                     if (inherits(cond, "message")) {
[13:33:37.371]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.371]                       if (muffled) 
[13:33:37.371]                         invokeRestart("muffleMessage")
[13:33:37.371]                     }
[13:33:37.371]                     else if (inherits(cond, "warning")) {
[13:33:37.371]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.371]                       if (muffled) 
[13:33:37.371]                         invokeRestart("muffleWarning")
[13:33:37.371]                     }
[13:33:37.371]                     else if (inherits(cond, "condition")) {
[13:33:37.371]                       if (!is.null(pattern)) {
[13:33:37.371]                         computeRestarts <- base::computeRestarts
[13:33:37.371]                         grepl <- base::grepl
[13:33:37.371]                         restarts <- computeRestarts(cond)
[13:33:37.371]                         for (restart in restarts) {
[13:33:37.371]                           name <- restart$name
[13:33:37.371]                           if (is.null(name)) 
[13:33:37.371]                             next
[13:33:37.371]                           if (!grepl(pattern, name)) 
[13:33:37.371]                             next
[13:33:37.371]                           invokeRestart(restart)
[13:33:37.371]                           muffled <- TRUE
[13:33:37.371]                           break
[13:33:37.371]                         }
[13:33:37.371]                       }
[13:33:37.371]                     }
[13:33:37.371]                     invisible(muffled)
[13:33:37.371]                   }
[13:33:37.371]                   muffleCondition(cond)
[13:33:37.371]                 })
[13:33:37.371]             }))
[13:33:37.371]             future::FutureResult(value = ...future.value$value, 
[13:33:37.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.371]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.371]                     ...future.globalenv.names))
[13:33:37.371]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.371]         }, condition = base::local({
[13:33:37.371]             c <- base::c
[13:33:37.371]             inherits <- base::inherits
[13:33:37.371]             invokeRestart <- base::invokeRestart
[13:33:37.371]             length <- base::length
[13:33:37.371]             list <- base::list
[13:33:37.371]             seq.int <- base::seq.int
[13:33:37.371]             signalCondition <- base::signalCondition
[13:33:37.371]             sys.calls <- base::sys.calls
[13:33:37.371]             `[[` <- base::`[[`
[13:33:37.371]             `+` <- base::`+`
[13:33:37.371]             `<<-` <- base::`<<-`
[13:33:37.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.371]                   3L)]
[13:33:37.371]             }
[13:33:37.371]             function(cond) {
[13:33:37.371]                 is_error <- inherits(cond, "error")
[13:33:37.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.371]                   NULL)
[13:33:37.371]                 if (is_error) {
[13:33:37.371]                   sessionInformation <- function() {
[13:33:37.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.371]                       search = base::search(), system = base::Sys.info())
[13:33:37.371]                   }
[13:33:37.371]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.371]                     cond$call), session = sessionInformation(), 
[13:33:37.371]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.371]                   signalCondition(cond)
[13:33:37.371]                 }
[13:33:37.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.371]                 "immediateCondition"))) {
[13:33:37.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.371]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.371]                   if (TRUE && !signal) {
[13:33:37.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.371]                     {
[13:33:37.371]                       inherits <- base::inherits
[13:33:37.371]                       invokeRestart <- base::invokeRestart
[13:33:37.371]                       is.null <- base::is.null
[13:33:37.371]                       muffled <- FALSE
[13:33:37.371]                       if (inherits(cond, "message")) {
[13:33:37.371]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.371]                         if (muffled) 
[13:33:37.371]                           invokeRestart("muffleMessage")
[13:33:37.371]                       }
[13:33:37.371]                       else if (inherits(cond, "warning")) {
[13:33:37.371]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.371]                         if (muffled) 
[13:33:37.371]                           invokeRestart("muffleWarning")
[13:33:37.371]                       }
[13:33:37.371]                       else if (inherits(cond, "condition")) {
[13:33:37.371]                         if (!is.null(pattern)) {
[13:33:37.371]                           computeRestarts <- base::computeRestarts
[13:33:37.371]                           grepl <- base::grepl
[13:33:37.371]                           restarts <- computeRestarts(cond)
[13:33:37.371]                           for (restart in restarts) {
[13:33:37.371]                             name <- restart$name
[13:33:37.371]                             if (is.null(name)) 
[13:33:37.371]                               next
[13:33:37.371]                             if (!grepl(pattern, name)) 
[13:33:37.371]                               next
[13:33:37.371]                             invokeRestart(restart)
[13:33:37.371]                             muffled <- TRUE
[13:33:37.371]                             break
[13:33:37.371]                           }
[13:33:37.371]                         }
[13:33:37.371]                       }
[13:33:37.371]                       invisible(muffled)
[13:33:37.371]                     }
[13:33:37.371]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.371]                   }
[13:33:37.371]                 }
[13:33:37.371]                 else {
[13:33:37.371]                   if (TRUE) {
[13:33:37.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.371]                     {
[13:33:37.371]                       inherits <- base::inherits
[13:33:37.371]                       invokeRestart <- base::invokeRestart
[13:33:37.371]                       is.null <- base::is.null
[13:33:37.371]                       muffled <- FALSE
[13:33:37.371]                       if (inherits(cond, "message")) {
[13:33:37.371]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.371]                         if (muffled) 
[13:33:37.371]                           invokeRestart("muffleMessage")
[13:33:37.371]                       }
[13:33:37.371]                       else if (inherits(cond, "warning")) {
[13:33:37.371]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.371]                         if (muffled) 
[13:33:37.371]                           invokeRestart("muffleWarning")
[13:33:37.371]                       }
[13:33:37.371]                       else if (inherits(cond, "condition")) {
[13:33:37.371]                         if (!is.null(pattern)) {
[13:33:37.371]                           computeRestarts <- base::computeRestarts
[13:33:37.371]                           grepl <- base::grepl
[13:33:37.371]                           restarts <- computeRestarts(cond)
[13:33:37.371]                           for (restart in restarts) {
[13:33:37.371]                             name <- restart$name
[13:33:37.371]                             if (is.null(name)) 
[13:33:37.371]                               next
[13:33:37.371]                             if (!grepl(pattern, name)) 
[13:33:37.371]                               next
[13:33:37.371]                             invokeRestart(restart)
[13:33:37.371]                             muffled <- TRUE
[13:33:37.371]                             break
[13:33:37.371]                           }
[13:33:37.371]                         }
[13:33:37.371]                       }
[13:33:37.371]                       invisible(muffled)
[13:33:37.371]                     }
[13:33:37.371]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.371]                   }
[13:33:37.371]                 }
[13:33:37.371]             }
[13:33:37.371]         }))
[13:33:37.371]     }, error = function(ex) {
[13:33:37.371]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.371]                 ...future.rng), started = ...future.startTime, 
[13:33:37.371]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.371]             version = "1.8"), class = "FutureResult")
[13:33:37.371]     }, finally = {
[13:33:37.371]         if (!identical(...future.workdir, getwd())) 
[13:33:37.371]             setwd(...future.workdir)
[13:33:37.371]         {
[13:33:37.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.371]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.371]             }
[13:33:37.371]             base::options(...future.oldOptions)
[13:33:37.371]             if (.Platform$OS.type == "windows") {
[13:33:37.371]                 old_names <- names(...future.oldEnvVars)
[13:33:37.371]                 envs <- base::Sys.getenv()
[13:33:37.371]                 names <- names(envs)
[13:33:37.371]                 common <- intersect(names, old_names)
[13:33:37.371]                 added <- setdiff(names, old_names)
[13:33:37.371]                 removed <- setdiff(old_names, names)
[13:33:37.371]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.371]                   envs[common]]
[13:33:37.371]                 NAMES <- toupper(changed)
[13:33:37.371]                 args <- list()
[13:33:37.371]                 for (kk in seq_along(NAMES)) {
[13:33:37.371]                   name <- changed[[kk]]
[13:33:37.371]                   NAME <- NAMES[[kk]]
[13:33:37.371]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.371]                     next
[13:33:37.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.371]                 }
[13:33:37.371]                 NAMES <- toupper(added)
[13:33:37.371]                 for (kk in seq_along(NAMES)) {
[13:33:37.371]                   name <- added[[kk]]
[13:33:37.371]                   NAME <- NAMES[[kk]]
[13:33:37.371]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.371]                     next
[13:33:37.371]                   args[[name]] <- ""
[13:33:37.371]                 }
[13:33:37.371]                 NAMES <- toupper(removed)
[13:33:37.371]                 for (kk in seq_along(NAMES)) {
[13:33:37.371]                   name <- removed[[kk]]
[13:33:37.371]                   NAME <- NAMES[[kk]]
[13:33:37.371]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.371]                     next
[13:33:37.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.371]                 }
[13:33:37.371]                 if (length(args) > 0) 
[13:33:37.371]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.371]             }
[13:33:37.371]             else {
[13:33:37.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.371]             }
[13:33:37.371]             {
[13:33:37.371]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.371]                   0L) {
[13:33:37.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.371]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.371]                   base::options(opts)
[13:33:37.371]                 }
[13:33:37.371]                 {
[13:33:37.371]                   {
[13:33:37.371]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.371]                     NULL
[13:33:37.371]                   }
[13:33:37.371]                   options(future.plan = NULL)
[13:33:37.371]                   if (is.na(NA_character_)) 
[13:33:37.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.371]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.371]                     .init = FALSE)
[13:33:37.371]                 }
[13:33:37.371]             }
[13:33:37.371]         }
[13:33:37.371]     })
[13:33:37.371]     if (TRUE) {
[13:33:37.371]         base::sink(type = "output", split = FALSE)
[13:33:37.371]         if (TRUE) {
[13:33:37.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.371]         }
[13:33:37.371]         else {
[13:33:37.371]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.371]         }
[13:33:37.371]         base::close(...future.stdout)
[13:33:37.371]         ...future.stdout <- NULL
[13:33:37.371]     }
[13:33:37.371]     ...future.result$conditions <- ...future.conditions
[13:33:37.371]     ...future.result$finished <- base::Sys.time()
[13:33:37.371]     ...future.result
[13:33:37.371] }
[13:33:37.373] assign_globals() ...
[13:33:37.373] List of 5
[13:33:37.373]  $ future.call.arguments    : list()
[13:33:37.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.373]  $ ...future.FUN            :function (x)  
[13:33:37.373]  $ ...future.elements_ii    :List of 1
[13:33:37.373]   ..$ : int 1
[13:33:37.373]  $ ...future.seeds_ii       : NULL
[13:33:37.373]  $ ...future.globals.maxSize: num Inf
[13:33:37.373]  - attr(*, "resolved")= logi FALSE
[13:33:37.373]  - attr(*, "total_size")= num NA
[13:33:37.373]  - attr(*, "where")=List of 5
[13:33:37.373]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.373]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.373]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.373]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.373]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.373]  - attr(*, "already-done")= logi TRUE
[13:33:37.378] - copied ‘future.call.arguments’ to environment
[13:33:37.378] - copied ‘...future.FUN’ to environment
[13:33:37.378] - copied ‘...future.elements_ii’ to environment
[13:33:37.378] - copied ‘...future.seeds_ii’ to environment
[13:33:37.378] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.378] assign_globals() ... done
[13:33:37.379] requestCore(): workers = 2
[13:33:37.380] MulticoreFuture started
[13:33:37.381] - Launch lazy future ... done
[13:33:37.381] run() for ‘MulticoreFuture’ ... done
[13:33:37.381] Created future:
[13:33:37.382] plan(): Setting new future strategy stack:
[13:33:37.382] List of future strategies:
[13:33:37.382] 1. sequential:
[13:33:37.382]    - args: function (..., envir = parent.frame())
[13:33:37.382]    - tweaked: FALSE
[13:33:37.382]    - call: NULL
[13:33:37.383] plan(): nbrOfWorkers() = 1
[13:33:37.385] plan(): Setting new future strategy stack:
[13:33:37.385] List of future strategies:
[13:33:37.385] 1. multicore:
[13:33:37.385]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.385]    - tweaked: FALSE
[13:33:37.385]    - call: plan(strategy)
[13:33:37.390] plan(): nbrOfWorkers() = 2
[13:33:37.382] MulticoreFuture:
[13:33:37.382] Label: ‘future_apply-1’
[13:33:37.382] Expression:
[13:33:37.382] {
[13:33:37.382]     do.call(function(...) {
[13:33:37.382]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.382]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.382]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.382]             on.exit(options(oopts), add = TRUE)
[13:33:37.382]         }
[13:33:37.382]         {
[13:33:37.382]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.382]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.382]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.382]             })
[13:33:37.382]         }
[13:33:37.382]     }, args = future.call.arguments)
[13:33:37.382] }
[13:33:37.382] Lazy evaluation: FALSE
[13:33:37.382] Asynchronous evaluation: TRUE
[13:33:37.382] Local evaluation: TRUE
[13:33:37.382] Environment: R_GlobalEnv
[13:33:37.382] Capture standard output: TRUE
[13:33:37.382] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.382] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.382] Packages: <none>
[13:33:37.382] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.382] Resolved: TRUE
[13:33:37.382] Value: <not collected>
[13:33:37.382] Conditions captured: <none>
[13:33:37.382] Early signaling: FALSE
[13:33:37.382] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.382] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.391] Chunk #1 of 2 ... DONE
[13:33:37.391] Chunk #2 of 2 ...
[13:33:37.391]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.391]  - seeds: <none>
[13:33:37.392]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.392] getGlobalsAndPackages() ...
[13:33:37.392] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.392] Resolving globals: FALSE
[13:33:37.392] Tweak future expression to call with '...' arguments ...
[13:33:37.392] {
[13:33:37.392]     do.call(function(...) {
[13:33:37.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.392]             on.exit(options(oopts), add = TRUE)
[13:33:37.392]         }
[13:33:37.392]         {
[13:33:37.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.392]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.392]             })
[13:33:37.392]         }
[13:33:37.392]     }, args = future.call.arguments)
[13:33:37.392] }
[13:33:37.393] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.393] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.394] 
[13:33:37.394] getGlobalsAndPackages() ... DONE
[13:33:37.394] run() for ‘Future’ ...
[13:33:37.394] - state: ‘created’
[13:33:37.395] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.399] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.399] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.399]   - Field: ‘label’
[13:33:37.399]   - Field: ‘local’
[13:33:37.400]   - Field: ‘owner’
[13:33:37.400]   - Field: ‘envir’
[13:33:37.400]   - Field: ‘workers’
[13:33:37.400]   - Field: ‘packages’
[13:33:37.400]   - Field: ‘gc’
[13:33:37.400]   - Field: ‘job’
[13:33:37.400]   - Field: ‘conditions’
[13:33:37.401]   - Field: ‘expr’
[13:33:37.401]   - Field: ‘uuid’
[13:33:37.401]   - Field: ‘seed’
[13:33:37.404]   - Field: ‘version’
[13:33:37.404]   - Field: ‘result’
[13:33:37.405]   - Field: ‘asynchronous’
[13:33:37.405]   - Field: ‘calls’
[13:33:37.405]   - Field: ‘globals’
[13:33:37.406]   - Field: ‘stdout’
[13:33:37.406]   - Field: ‘earlySignal’
[13:33:37.406]   - Field: ‘lazy’
[13:33:37.407]   - Field: ‘state’
[13:33:37.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.407] - Launch lazy future ...
[13:33:37.408] Packages needed by the future expression (n = 0): <none>
[13:33:37.408] Packages needed by future strategies (n = 0): <none>
[13:33:37.409] {
[13:33:37.409]     {
[13:33:37.409]         {
[13:33:37.409]             ...future.startTime <- base::Sys.time()
[13:33:37.409]             {
[13:33:37.409]                 {
[13:33:37.409]                   {
[13:33:37.409]                     {
[13:33:37.409]                       base::local({
[13:33:37.409]                         has_future <- base::requireNamespace("future", 
[13:33:37.409]                           quietly = TRUE)
[13:33:37.409]                         if (has_future) {
[13:33:37.409]                           ns <- base::getNamespace("future")
[13:33:37.409]                           version <- ns[[".package"]][["version"]]
[13:33:37.409]                           if (is.null(version)) 
[13:33:37.409]                             version <- utils::packageVersion("future")
[13:33:37.409]                         }
[13:33:37.409]                         else {
[13:33:37.409]                           version <- NULL
[13:33:37.409]                         }
[13:33:37.409]                         if (!has_future || version < "1.8.0") {
[13:33:37.409]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.409]                             "", base::R.version$version.string), 
[13:33:37.409]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.409]                               "release", "version")], collapse = " "), 
[13:33:37.409]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.409]                             info)
[13:33:37.409]                           info <- base::paste(info, collapse = "; ")
[13:33:37.409]                           if (!has_future) {
[13:33:37.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.409]                               info)
[13:33:37.409]                           }
[13:33:37.409]                           else {
[13:33:37.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.409]                               info, version)
[13:33:37.409]                           }
[13:33:37.409]                           base::stop(msg)
[13:33:37.409]                         }
[13:33:37.409]                       })
[13:33:37.409]                     }
[13:33:37.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.409]                     base::options(mc.cores = 1L)
[13:33:37.409]                   }
[13:33:37.409]                   ...future.strategy.old <- future::plan("list")
[13:33:37.409]                   options(future.plan = NULL)
[13:33:37.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.409]                 }
[13:33:37.409]                 ...future.workdir <- getwd()
[13:33:37.409]             }
[13:33:37.409]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.409]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.409]         }
[13:33:37.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.409]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.409]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.409]             base::names(...future.oldOptions))
[13:33:37.409]     }
[13:33:37.409]     if (FALSE) {
[13:33:37.409]     }
[13:33:37.409]     else {
[13:33:37.409]         if (TRUE) {
[13:33:37.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.409]                 open = "w")
[13:33:37.409]         }
[13:33:37.409]         else {
[13:33:37.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.409]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.409]         }
[13:33:37.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.409]             base::sink(type = "output", split = FALSE)
[13:33:37.409]             base::close(...future.stdout)
[13:33:37.409]         }, add = TRUE)
[13:33:37.409]     }
[13:33:37.409]     ...future.frame <- base::sys.nframe()
[13:33:37.409]     ...future.conditions <- base::list()
[13:33:37.409]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.409]     if (FALSE) {
[13:33:37.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.409]     }
[13:33:37.409]     ...future.result <- base::tryCatch({
[13:33:37.409]         base::withCallingHandlers({
[13:33:37.409]             ...future.value <- base::withVisible(base::local({
[13:33:37.409]                 withCallingHandlers({
[13:33:37.409]                   {
[13:33:37.409]                     do.call(function(...) {
[13:33:37.409]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.409]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.409]                         ...future.globals.maxSize)) {
[13:33:37.409]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.409]                         on.exit(options(oopts), add = TRUE)
[13:33:37.409]                       }
[13:33:37.409]                       {
[13:33:37.409]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.409]                           FUN = function(jj) {
[13:33:37.409]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.409]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.409]                           })
[13:33:37.409]                       }
[13:33:37.409]                     }, args = future.call.arguments)
[13:33:37.409]                   }
[13:33:37.409]                 }, immediateCondition = function(cond) {
[13:33:37.409]                   save_rds <- function (object, pathname, ...) 
[13:33:37.409]                   {
[13:33:37.409]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.409]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.409]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.409]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.409]                         fi_tmp[["mtime"]])
[13:33:37.409]                     }
[13:33:37.409]                     tryCatch({
[13:33:37.409]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.409]                     }, error = function(ex) {
[13:33:37.409]                       msg <- conditionMessage(ex)
[13:33:37.409]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.409]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.409]                         fi_tmp[["mtime"]], msg)
[13:33:37.409]                       ex$message <- msg
[13:33:37.409]                       stop(ex)
[13:33:37.409]                     })
[13:33:37.409]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.409]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.409]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.409]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.409]                       fi <- file.info(pathname)
[13:33:37.409]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.409]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.409]                         fi[["size"]], fi[["mtime"]])
[13:33:37.409]                       stop(msg)
[13:33:37.409]                     }
[13:33:37.409]                     invisible(pathname)
[13:33:37.409]                   }
[13:33:37.409]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.409]                     rootPath = tempdir()) 
[13:33:37.409]                   {
[13:33:37.409]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.409]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.409]                       tmpdir = path, fileext = ".rds")
[13:33:37.409]                     save_rds(obj, file)
[13:33:37.409]                   }
[13:33:37.409]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.409]                   {
[13:33:37.409]                     inherits <- base::inherits
[13:33:37.409]                     invokeRestart <- base::invokeRestart
[13:33:37.409]                     is.null <- base::is.null
[13:33:37.409]                     muffled <- FALSE
[13:33:37.409]                     if (inherits(cond, "message")) {
[13:33:37.409]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.409]                       if (muffled) 
[13:33:37.409]                         invokeRestart("muffleMessage")
[13:33:37.409]                     }
[13:33:37.409]                     else if (inherits(cond, "warning")) {
[13:33:37.409]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.409]                       if (muffled) 
[13:33:37.409]                         invokeRestart("muffleWarning")
[13:33:37.409]                     }
[13:33:37.409]                     else if (inherits(cond, "condition")) {
[13:33:37.409]                       if (!is.null(pattern)) {
[13:33:37.409]                         computeRestarts <- base::computeRestarts
[13:33:37.409]                         grepl <- base::grepl
[13:33:37.409]                         restarts <- computeRestarts(cond)
[13:33:37.409]                         for (restart in restarts) {
[13:33:37.409]                           name <- restart$name
[13:33:37.409]                           if (is.null(name)) 
[13:33:37.409]                             next
[13:33:37.409]                           if (!grepl(pattern, name)) 
[13:33:37.409]                             next
[13:33:37.409]                           invokeRestart(restart)
[13:33:37.409]                           muffled <- TRUE
[13:33:37.409]                           break
[13:33:37.409]                         }
[13:33:37.409]                       }
[13:33:37.409]                     }
[13:33:37.409]                     invisible(muffled)
[13:33:37.409]                   }
[13:33:37.409]                   muffleCondition(cond)
[13:33:37.409]                 })
[13:33:37.409]             }))
[13:33:37.409]             future::FutureResult(value = ...future.value$value, 
[13:33:37.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.409]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.409]                     ...future.globalenv.names))
[13:33:37.409]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.409]         }, condition = base::local({
[13:33:37.409]             c <- base::c
[13:33:37.409]             inherits <- base::inherits
[13:33:37.409]             invokeRestart <- base::invokeRestart
[13:33:37.409]             length <- base::length
[13:33:37.409]             list <- base::list
[13:33:37.409]             seq.int <- base::seq.int
[13:33:37.409]             signalCondition <- base::signalCondition
[13:33:37.409]             sys.calls <- base::sys.calls
[13:33:37.409]             `[[` <- base::`[[`
[13:33:37.409]             `+` <- base::`+`
[13:33:37.409]             `<<-` <- base::`<<-`
[13:33:37.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.409]                   3L)]
[13:33:37.409]             }
[13:33:37.409]             function(cond) {
[13:33:37.409]                 is_error <- inherits(cond, "error")
[13:33:37.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.409]                   NULL)
[13:33:37.409]                 if (is_error) {
[13:33:37.409]                   sessionInformation <- function() {
[13:33:37.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.409]                       search = base::search(), system = base::Sys.info())
[13:33:37.409]                   }
[13:33:37.409]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.409]                     cond$call), session = sessionInformation(), 
[13:33:37.409]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.409]                   signalCondition(cond)
[13:33:37.409]                 }
[13:33:37.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.409]                 "immediateCondition"))) {
[13:33:37.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.409]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.409]                   if (TRUE && !signal) {
[13:33:37.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.409]                     {
[13:33:37.409]                       inherits <- base::inherits
[13:33:37.409]                       invokeRestart <- base::invokeRestart
[13:33:37.409]                       is.null <- base::is.null
[13:33:37.409]                       muffled <- FALSE
[13:33:37.409]                       if (inherits(cond, "message")) {
[13:33:37.409]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.409]                         if (muffled) 
[13:33:37.409]                           invokeRestart("muffleMessage")
[13:33:37.409]                       }
[13:33:37.409]                       else if (inherits(cond, "warning")) {
[13:33:37.409]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.409]                         if (muffled) 
[13:33:37.409]                           invokeRestart("muffleWarning")
[13:33:37.409]                       }
[13:33:37.409]                       else if (inherits(cond, "condition")) {
[13:33:37.409]                         if (!is.null(pattern)) {
[13:33:37.409]                           computeRestarts <- base::computeRestarts
[13:33:37.409]                           grepl <- base::grepl
[13:33:37.409]                           restarts <- computeRestarts(cond)
[13:33:37.409]                           for (restart in restarts) {
[13:33:37.409]                             name <- restart$name
[13:33:37.409]                             if (is.null(name)) 
[13:33:37.409]                               next
[13:33:37.409]                             if (!grepl(pattern, name)) 
[13:33:37.409]                               next
[13:33:37.409]                             invokeRestart(restart)
[13:33:37.409]                             muffled <- TRUE
[13:33:37.409]                             break
[13:33:37.409]                           }
[13:33:37.409]                         }
[13:33:37.409]                       }
[13:33:37.409]                       invisible(muffled)
[13:33:37.409]                     }
[13:33:37.409]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.409]                   }
[13:33:37.409]                 }
[13:33:37.409]                 else {
[13:33:37.409]                   if (TRUE) {
[13:33:37.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.409]                     {
[13:33:37.409]                       inherits <- base::inherits
[13:33:37.409]                       invokeRestart <- base::invokeRestart
[13:33:37.409]                       is.null <- base::is.null
[13:33:37.409]                       muffled <- FALSE
[13:33:37.409]                       if (inherits(cond, "message")) {
[13:33:37.409]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.409]                         if (muffled) 
[13:33:37.409]                           invokeRestart("muffleMessage")
[13:33:37.409]                       }
[13:33:37.409]                       else if (inherits(cond, "warning")) {
[13:33:37.409]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.409]                         if (muffled) 
[13:33:37.409]                           invokeRestart("muffleWarning")
[13:33:37.409]                       }
[13:33:37.409]                       else if (inherits(cond, "condition")) {
[13:33:37.409]                         if (!is.null(pattern)) {
[13:33:37.409]                           computeRestarts <- base::computeRestarts
[13:33:37.409]                           grepl <- base::grepl
[13:33:37.409]                           restarts <- computeRestarts(cond)
[13:33:37.409]                           for (restart in restarts) {
[13:33:37.409]                             name <- restart$name
[13:33:37.409]                             if (is.null(name)) 
[13:33:37.409]                               next
[13:33:37.409]                             if (!grepl(pattern, name)) 
[13:33:37.409]                               next
[13:33:37.409]                             invokeRestart(restart)
[13:33:37.409]                             muffled <- TRUE
[13:33:37.409]                             break
[13:33:37.409]                           }
[13:33:37.409]                         }
[13:33:37.409]                       }
[13:33:37.409]                       invisible(muffled)
[13:33:37.409]                     }
[13:33:37.409]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.409]                   }
[13:33:37.409]                 }
[13:33:37.409]             }
[13:33:37.409]         }))
[13:33:37.409]     }, error = function(ex) {
[13:33:37.409]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.409]                 ...future.rng), started = ...future.startTime, 
[13:33:37.409]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.409]             version = "1.8"), class = "FutureResult")
[13:33:37.409]     }, finally = {
[13:33:37.409]         if (!identical(...future.workdir, getwd())) 
[13:33:37.409]             setwd(...future.workdir)
[13:33:37.409]         {
[13:33:37.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.409]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.409]             }
[13:33:37.409]             base::options(...future.oldOptions)
[13:33:37.409]             if (.Platform$OS.type == "windows") {
[13:33:37.409]                 old_names <- names(...future.oldEnvVars)
[13:33:37.409]                 envs <- base::Sys.getenv()
[13:33:37.409]                 names <- names(envs)
[13:33:37.409]                 common <- intersect(names, old_names)
[13:33:37.409]                 added <- setdiff(names, old_names)
[13:33:37.409]                 removed <- setdiff(old_names, names)
[13:33:37.409]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.409]                   envs[common]]
[13:33:37.409]                 NAMES <- toupper(changed)
[13:33:37.409]                 args <- list()
[13:33:37.409]                 for (kk in seq_along(NAMES)) {
[13:33:37.409]                   name <- changed[[kk]]
[13:33:37.409]                   NAME <- NAMES[[kk]]
[13:33:37.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.409]                     next
[13:33:37.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.409]                 }
[13:33:37.409]                 NAMES <- toupper(added)
[13:33:37.409]                 for (kk in seq_along(NAMES)) {
[13:33:37.409]                   name <- added[[kk]]
[13:33:37.409]                   NAME <- NAMES[[kk]]
[13:33:37.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.409]                     next
[13:33:37.409]                   args[[name]] <- ""
[13:33:37.409]                 }
[13:33:37.409]                 NAMES <- toupper(removed)
[13:33:37.409]                 for (kk in seq_along(NAMES)) {
[13:33:37.409]                   name <- removed[[kk]]
[13:33:37.409]                   NAME <- NAMES[[kk]]
[13:33:37.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.409]                     next
[13:33:37.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.409]                 }
[13:33:37.409]                 if (length(args) > 0) 
[13:33:37.409]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.409]             }
[13:33:37.409]             else {
[13:33:37.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.409]             }
[13:33:37.409]             {
[13:33:37.409]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.409]                   0L) {
[13:33:37.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.409]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.409]                   base::options(opts)
[13:33:37.409]                 }
[13:33:37.409]                 {
[13:33:37.409]                   {
[13:33:37.409]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.409]                     NULL
[13:33:37.409]                   }
[13:33:37.409]                   options(future.plan = NULL)
[13:33:37.409]                   if (is.na(NA_character_)) 
[13:33:37.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.409]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.409]                     .init = FALSE)
[13:33:37.409]                 }
[13:33:37.409]             }
[13:33:37.409]         }
[13:33:37.409]     })
[13:33:37.409]     if (TRUE) {
[13:33:37.409]         base::sink(type = "output", split = FALSE)
[13:33:37.409]         if (TRUE) {
[13:33:37.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.409]         }
[13:33:37.409]         else {
[13:33:37.409]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.409]         }
[13:33:37.409]         base::close(...future.stdout)
[13:33:37.409]         ...future.stdout <- NULL
[13:33:37.409]     }
[13:33:37.409]     ...future.result$conditions <- ...future.conditions
[13:33:37.409]     ...future.result$finished <- base::Sys.time()
[13:33:37.409]     ...future.result
[13:33:37.409] }
[13:33:37.412] assign_globals() ...
[13:33:37.412] List of 5
[13:33:37.412]  $ future.call.arguments    : list()
[13:33:37.412]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.412]  $ ...future.FUN            :function (x)  
[13:33:37.412]  $ ...future.elements_ii    :List of 1
[13:33:37.412]   ..$ : int 2
[13:33:37.412]  $ ...future.seeds_ii       : NULL
[13:33:37.412]  $ ...future.globals.maxSize: num Inf
[13:33:37.412]  - attr(*, "resolved")= logi FALSE
[13:33:37.412]  - attr(*, "total_size")= num NA
[13:33:37.412]  - attr(*, "where")=List of 5
[13:33:37.412]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.412]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.412]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.412]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.412]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.412]  - attr(*, "already-done")= logi TRUE
[13:33:37.420] - copied ‘future.call.arguments’ to environment
[13:33:37.421] - copied ‘...future.FUN’ to environment
[13:33:37.421] - copied ‘...future.elements_ii’ to environment
[13:33:37.421] - copied ‘...future.seeds_ii’ to environment
[13:33:37.421] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.421] assign_globals() ... done
[13:33:37.421] requestCore(): workers = 2
[13:33:37.423] MulticoreFuture started
[13:33:37.424] - Launch lazy future ... done
[13:33:37.424] run() for ‘MulticoreFuture’ ... done
[13:33:37.424] Created future:
[13:33:37.425] plan(): Setting new future strategy stack:
[13:33:37.425] List of future strategies:
[13:33:37.425] 1. sequential:
[13:33:37.425]    - args: function (..., envir = parent.frame())
[13:33:37.425]    - tweaked: FALSE
[13:33:37.425]    - call: NULL
[13:33:37.426] plan(): nbrOfWorkers() = 1
[13:33:37.428] plan(): Setting new future strategy stack:
[13:33:37.428] List of future strategies:
[13:33:37.428] 1. multicore:
[13:33:37.428]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.428]    - tweaked: FALSE
[13:33:37.428]    - call: plan(strategy)
[13:33:37.433] plan(): nbrOfWorkers() = 2
[13:33:37.424] MulticoreFuture:
[13:33:37.424] Label: ‘future_apply-2’
[13:33:37.424] Expression:
[13:33:37.424] {
[13:33:37.424]     do.call(function(...) {
[13:33:37.424]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.424]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.424]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.424]             on.exit(options(oopts), add = TRUE)
[13:33:37.424]         }
[13:33:37.424]         {
[13:33:37.424]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.424]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.424]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.424]             })
[13:33:37.424]         }
[13:33:37.424]     }, args = future.call.arguments)
[13:33:37.424] }
[13:33:37.424] Lazy evaluation: FALSE
[13:33:37.424] Asynchronous evaluation: TRUE
[13:33:37.424] Local evaluation: TRUE
[13:33:37.424] Environment: R_GlobalEnv
[13:33:37.424] Capture standard output: TRUE
[13:33:37.424] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.424] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.424] Packages: <none>
[13:33:37.424] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.424] Resolved: TRUE
[13:33:37.424] Value: <not collected>
[13:33:37.424] Conditions captured: <none>
[13:33:37.424] Early signaling: FALSE
[13:33:37.424] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.424] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.434] Chunk #2 of 2 ... DONE
[13:33:37.434] Launching 2 futures (chunks) ... DONE
[13:33:37.434] Resolving 2 futures (chunks) ...
[13:33:37.435] resolve() on list ...
[13:33:37.435]  recursive: 0
[13:33:37.435]  length: 2
[13:33:37.435] 
[13:33:37.435] Future #1
[13:33:37.436] result() for MulticoreFuture ...
[13:33:37.436] result() for MulticoreFuture ...
[13:33:37.437] result() for MulticoreFuture ... done
[13:33:37.437] result() for MulticoreFuture ... done
[13:33:37.437] result() for MulticoreFuture ...
[13:33:37.437] result() for MulticoreFuture ... done
[13:33:37.437] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:37.437] - nx: 2
[13:33:37.438] - relay: TRUE
[13:33:37.438] - stdout: TRUE
[13:33:37.438] - signal: TRUE
[13:33:37.438] - resignal: FALSE
[13:33:37.438] - force: TRUE
[13:33:37.438] - relayed: [n=2] FALSE, FALSE
[13:33:37.438] - queued futures: [n=2] FALSE, FALSE
[13:33:37.439]  - until=1
[13:33:37.439]  - relaying element #1
[13:33:37.439] result() for MulticoreFuture ...
[13:33:37.439] result() for MulticoreFuture ... done
[13:33:37.439] result() for MulticoreFuture ...
[13:33:37.439] result() for MulticoreFuture ... done
[13:33:37.440] result() for MulticoreFuture ...
[13:33:37.440] result() for MulticoreFuture ... done
[13:33:37.440] result() for MulticoreFuture ...
[13:33:37.440] result() for MulticoreFuture ... done
[13:33:37.440] - relayed: [n=2] TRUE, FALSE
[13:33:37.440] - queued futures: [n=2] TRUE, FALSE
[13:33:37.441] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:37.441]  length: 1 (resolved future 1)
[13:33:37.441] Future #2
[13:33:37.441] result() for MulticoreFuture ...
[13:33:37.442] result() for MulticoreFuture ...
[13:33:37.442] result() for MulticoreFuture ... done
[13:33:37.442] result() for MulticoreFuture ... done
[13:33:37.442] result() for MulticoreFuture ...
[13:33:37.442] result() for MulticoreFuture ... done
[13:33:37.443] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:37.443] - nx: 2
[13:33:37.443] - relay: TRUE
[13:33:37.443] - stdout: TRUE
[13:33:37.443] - signal: TRUE
[13:33:37.443] - resignal: FALSE
[13:33:37.443] - force: TRUE
[13:33:37.443] - relayed: [n=2] TRUE, FALSE
[13:33:37.444] - queued futures: [n=2] TRUE, FALSE
[13:33:37.444]  - until=2
[13:33:37.444]  - relaying element #2
[13:33:37.444] result() for MulticoreFuture ...
[13:33:37.444] result() for MulticoreFuture ... done
[13:33:37.444] result() for MulticoreFuture ...
[13:33:37.444] result() for MulticoreFuture ... done
[13:33:37.444] result() for MulticoreFuture ...
[13:33:37.444] result() for MulticoreFuture ... done
[13:33:37.445] result() for MulticoreFuture ...
[13:33:37.445] result() for MulticoreFuture ... done
[13:33:37.445] - relayed: [n=2] TRUE, TRUE
[13:33:37.445] - queued futures: [n=2] TRUE, TRUE
[13:33:37.445] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:37.445]  length: 0 (resolved future 2)
[13:33:37.445] Relaying remaining futures
[13:33:37.445] signalConditionsASAP(NULL, pos=0) ...
[13:33:37.445] - nx: 2
[13:33:37.446] - relay: TRUE
[13:33:37.446] - stdout: TRUE
[13:33:37.446] - signal: TRUE
[13:33:37.446] - resignal: FALSE
[13:33:37.446] - force: TRUE
[13:33:37.446] - relayed: [n=2] TRUE, TRUE
[13:33:37.446] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:37.446] - relayed: [n=2] TRUE, TRUE
[13:33:37.446] - queued futures: [n=2] TRUE, TRUE
[13:33:37.447] signalConditionsASAP(NULL, pos=0) ... done
[13:33:37.447] resolve() on list ... DONE
[13:33:37.447] result() for MulticoreFuture ...
[13:33:37.447] result() for MulticoreFuture ... done
[13:33:37.447] result() for MulticoreFuture ...
[13:33:37.447] result() for MulticoreFuture ... done
[13:33:37.447] result() for MulticoreFuture ...
[13:33:37.447] result() for MulticoreFuture ... done
[13:33:37.448] result() for MulticoreFuture ...
[13:33:37.450] result() for MulticoreFuture ... done
[13:33:37.450]  - Number of value chunks collected: 2
[13:33:37.450] Resolving 2 futures (chunks) ... DONE
[13:33:37.451] Reducing values from 2 chunks ...
[13:33:37.451]  - Number of values collected after concatenation: 2
[13:33:37.451]  - Number of values expected: 2
[13:33:37.451] Reducing values from 2 chunks ... DONE
[13:33:37.451] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[13:33:37.452] getGlobalsAndPackagesXApply() ...
[13:33:37.452]  - future.globals: TRUE
[13:33:37.452] getGlobalsAndPackages() ...
[13:33:37.452] Searching for globals...
[13:33:37.454] - globals found: [1] ‘FUN’
[13:33:37.454] Searching for globals ... DONE
[13:33:37.454] Resolving globals: FALSE
[13:33:37.455] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:37.455] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:37.455] - globals: [1] ‘FUN’
[13:33:37.455] 
[13:33:37.455] getGlobalsAndPackages() ... DONE
[13:33:37.456]  - globals found/used: [n=1] ‘FUN’
[13:33:37.456]  - needed namespaces: [n=0] 
[13:33:37.456] Finding globals ... DONE
[13:33:37.456]  - use_args: TRUE
[13:33:37.456]  - Getting '...' globals ...
[13:33:37.456] resolve() on list ...
[13:33:37.456]  recursive: 0
[13:33:37.457]  length: 1
[13:33:37.457]  elements: ‘...’
[13:33:37.457]  length: 0 (resolved future 1)
[13:33:37.457] resolve() on list ... DONE
[13:33:37.457]    - '...' content: [n=0] 
[13:33:37.457] List of 1
[13:33:37.457]  $ ...: list()
[13:33:37.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.457]  - attr(*, "where")=List of 1
[13:33:37.457]   ..$ ...:<environment: 0x55b94a11d7b8> 
[13:33:37.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.457]  - attr(*, "resolved")= logi TRUE
[13:33:37.457]  - attr(*, "total_size")= num NA
[13:33:37.460]  - Getting '...' globals ... DONE
[13:33:37.461] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:37.461] List of 2
[13:33:37.461]  $ ...future.FUN:function (x)  
[13:33:37.461]  $ ...          : list()
[13:33:37.461]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.461]  - attr(*, "where")=List of 2
[13:33:37.461]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:37.461]   ..$ ...          :<environment: 0x55b94a11d7b8> 
[13:33:37.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.461]  - attr(*, "resolved")= logi FALSE
[13:33:37.461]  - attr(*, "total_size")= num 848
[13:33:37.463] Packages to be attached in all futures: [n=0] 
[13:33:37.463] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.467] future_lapply() ...
[13:33:37.471] Number of chunks: 2
[13:33:37.471] getGlobalsAndPackagesXApply() ...
[13:33:37.471]  - future.globals: <name-value list> with names ‘list()’
[13:33:37.471]  - use_args: TRUE
[13:33:37.471] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:37.471] List of 2
[13:33:37.471]  $ ...          : list()
[13:33:37.471]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.471]  $ ...future.FUN:function (x)  
[13:33:37.471]  - attr(*, "where")=List of 2
[13:33:37.471]   ..$ ...          :<environment: 0x55b94a11d7b8> 
[13:33:37.471]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:37.471]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.471]  - attr(*, "resolved")= logi FALSE
[13:33:37.471]  - attr(*, "total_size")= num NA
[13:33:37.474] Packages to be attached in all futures: [n=0] 
[13:33:37.475] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.475] Number of futures (= number of chunks): 2
[13:33:37.475] Launching 2 futures (chunks) ...
[13:33:37.475] Chunk #1 of 2 ...
[13:33:37.475]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.475]  - seeds: <none>
[13:33:37.475]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.475] getGlobalsAndPackages() ...
[13:33:37.476] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.476] Resolving globals: FALSE
[13:33:37.476] Tweak future expression to call with '...' arguments ...
[13:33:37.476] {
[13:33:37.476]     do.call(function(...) {
[13:33:37.476]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.476]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.476]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.476]             on.exit(options(oopts), add = TRUE)
[13:33:37.476]         }
[13:33:37.476]         {
[13:33:37.476]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.476]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.476]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.476]             })
[13:33:37.476]         }
[13:33:37.476]     }, args = future.call.arguments)
[13:33:37.476] }
[13:33:37.476] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.478] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.478] 
[13:33:37.478] getGlobalsAndPackages() ... DONE
[13:33:37.479] run() for ‘Future’ ...
[13:33:37.479] - state: ‘created’
[13:33:37.479] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.482] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.482] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.483]   - Field: ‘label’
[13:33:37.483]   - Field: ‘local’
[13:33:37.483]   - Field: ‘owner’
[13:33:37.483]   - Field: ‘envir’
[13:33:37.483]   - Field: ‘workers’
[13:33:37.483]   - Field: ‘packages’
[13:33:37.483]   - Field: ‘gc’
[13:33:37.483]   - Field: ‘job’
[13:33:37.483]   - Field: ‘conditions’
[13:33:37.484]   - Field: ‘expr’
[13:33:37.484]   - Field: ‘uuid’
[13:33:37.484]   - Field: ‘seed’
[13:33:37.484]   - Field: ‘version’
[13:33:37.484]   - Field: ‘result’
[13:33:37.484]   - Field: ‘asynchronous’
[13:33:37.484]   - Field: ‘calls’
[13:33:37.484]   - Field: ‘globals’
[13:33:37.484]   - Field: ‘stdout’
[13:33:37.484]   - Field: ‘earlySignal’
[13:33:37.484]   - Field: ‘lazy’
[13:33:37.485]   - Field: ‘state’
[13:33:37.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.485] - Launch lazy future ...
[13:33:37.485] Packages needed by the future expression (n = 0): <none>
[13:33:37.485] Packages needed by future strategies (n = 0): <none>
[13:33:37.486] {
[13:33:37.486]     {
[13:33:37.486]         {
[13:33:37.486]             ...future.startTime <- base::Sys.time()
[13:33:37.486]             {
[13:33:37.486]                 {
[13:33:37.486]                   {
[13:33:37.486]                     {
[13:33:37.486]                       base::local({
[13:33:37.486]                         has_future <- base::requireNamespace("future", 
[13:33:37.486]                           quietly = TRUE)
[13:33:37.486]                         if (has_future) {
[13:33:37.486]                           ns <- base::getNamespace("future")
[13:33:37.486]                           version <- ns[[".package"]][["version"]]
[13:33:37.486]                           if (is.null(version)) 
[13:33:37.486]                             version <- utils::packageVersion("future")
[13:33:37.486]                         }
[13:33:37.486]                         else {
[13:33:37.486]                           version <- NULL
[13:33:37.486]                         }
[13:33:37.486]                         if (!has_future || version < "1.8.0") {
[13:33:37.486]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.486]                             "", base::R.version$version.string), 
[13:33:37.486]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.486]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.486]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.486]                               "release", "version")], collapse = " "), 
[13:33:37.486]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.486]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.486]                             info)
[13:33:37.486]                           info <- base::paste(info, collapse = "; ")
[13:33:37.486]                           if (!has_future) {
[13:33:37.486]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.486]                               info)
[13:33:37.486]                           }
[13:33:37.486]                           else {
[13:33:37.486]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.486]                               info, version)
[13:33:37.486]                           }
[13:33:37.486]                           base::stop(msg)
[13:33:37.486]                         }
[13:33:37.486]                       })
[13:33:37.486]                     }
[13:33:37.486]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.486]                     base::options(mc.cores = 1L)
[13:33:37.486]                   }
[13:33:37.486]                   ...future.strategy.old <- future::plan("list")
[13:33:37.486]                   options(future.plan = NULL)
[13:33:37.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.486]                 }
[13:33:37.486]                 ...future.workdir <- getwd()
[13:33:37.486]             }
[13:33:37.486]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.486]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.486]         }
[13:33:37.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.486]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.486]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.486]             base::names(...future.oldOptions))
[13:33:37.486]     }
[13:33:37.486]     if (FALSE) {
[13:33:37.486]     }
[13:33:37.486]     else {
[13:33:37.486]         if (TRUE) {
[13:33:37.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.486]                 open = "w")
[13:33:37.486]         }
[13:33:37.486]         else {
[13:33:37.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.486]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.486]         }
[13:33:37.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.486]             base::sink(type = "output", split = FALSE)
[13:33:37.486]             base::close(...future.stdout)
[13:33:37.486]         }, add = TRUE)
[13:33:37.486]     }
[13:33:37.486]     ...future.frame <- base::sys.nframe()
[13:33:37.486]     ...future.conditions <- base::list()
[13:33:37.486]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.486]     if (FALSE) {
[13:33:37.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.486]     }
[13:33:37.486]     ...future.result <- base::tryCatch({
[13:33:37.486]         base::withCallingHandlers({
[13:33:37.486]             ...future.value <- base::withVisible(base::local({
[13:33:37.486]                 withCallingHandlers({
[13:33:37.486]                   {
[13:33:37.486]                     do.call(function(...) {
[13:33:37.486]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.486]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.486]                         ...future.globals.maxSize)) {
[13:33:37.486]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.486]                         on.exit(options(oopts), add = TRUE)
[13:33:37.486]                       }
[13:33:37.486]                       {
[13:33:37.486]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.486]                           FUN = function(jj) {
[13:33:37.486]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.486]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.486]                           })
[13:33:37.486]                       }
[13:33:37.486]                     }, args = future.call.arguments)
[13:33:37.486]                   }
[13:33:37.486]                 }, immediateCondition = function(cond) {
[13:33:37.486]                   save_rds <- function (object, pathname, ...) 
[13:33:37.486]                   {
[13:33:37.486]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.486]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.486]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.486]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.486]                         fi_tmp[["mtime"]])
[13:33:37.486]                     }
[13:33:37.486]                     tryCatch({
[13:33:37.486]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.486]                     }, error = function(ex) {
[13:33:37.486]                       msg <- conditionMessage(ex)
[13:33:37.486]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.486]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.486]                         fi_tmp[["mtime"]], msg)
[13:33:37.486]                       ex$message <- msg
[13:33:37.486]                       stop(ex)
[13:33:37.486]                     })
[13:33:37.486]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.486]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.486]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.486]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.486]                       fi <- file.info(pathname)
[13:33:37.486]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.486]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.486]                         fi[["size"]], fi[["mtime"]])
[13:33:37.486]                       stop(msg)
[13:33:37.486]                     }
[13:33:37.486]                     invisible(pathname)
[13:33:37.486]                   }
[13:33:37.486]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.486]                     rootPath = tempdir()) 
[13:33:37.486]                   {
[13:33:37.486]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.486]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.486]                       tmpdir = path, fileext = ".rds")
[13:33:37.486]                     save_rds(obj, file)
[13:33:37.486]                   }
[13:33:37.486]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.486]                   {
[13:33:37.486]                     inherits <- base::inherits
[13:33:37.486]                     invokeRestart <- base::invokeRestart
[13:33:37.486]                     is.null <- base::is.null
[13:33:37.486]                     muffled <- FALSE
[13:33:37.486]                     if (inherits(cond, "message")) {
[13:33:37.486]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.486]                       if (muffled) 
[13:33:37.486]                         invokeRestart("muffleMessage")
[13:33:37.486]                     }
[13:33:37.486]                     else if (inherits(cond, "warning")) {
[13:33:37.486]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.486]                       if (muffled) 
[13:33:37.486]                         invokeRestart("muffleWarning")
[13:33:37.486]                     }
[13:33:37.486]                     else if (inherits(cond, "condition")) {
[13:33:37.486]                       if (!is.null(pattern)) {
[13:33:37.486]                         computeRestarts <- base::computeRestarts
[13:33:37.486]                         grepl <- base::grepl
[13:33:37.486]                         restarts <- computeRestarts(cond)
[13:33:37.486]                         for (restart in restarts) {
[13:33:37.486]                           name <- restart$name
[13:33:37.486]                           if (is.null(name)) 
[13:33:37.486]                             next
[13:33:37.486]                           if (!grepl(pattern, name)) 
[13:33:37.486]                             next
[13:33:37.486]                           invokeRestart(restart)
[13:33:37.486]                           muffled <- TRUE
[13:33:37.486]                           break
[13:33:37.486]                         }
[13:33:37.486]                       }
[13:33:37.486]                     }
[13:33:37.486]                     invisible(muffled)
[13:33:37.486]                   }
[13:33:37.486]                   muffleCondition(cond)
[13:33:37.486]                 })
[13:33:37.486]             }))
[13:33:37.486]             future::FutureResult(value = ...future.value$value, 
[13:33:37.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.486]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.486]                     ...future.globalenv.names))
[13:33:37.486]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.486]         }, condition = base::local({
[13:33:37.486]             c <- base::c
[13:33:37.486]             inherits <- base::inherits
[13:33:37.486]             invokeRestart <- base::invokeRestart
[13:33:37.486]             length <- base::length
[13:33:37.486]             list <- base::list
[13:33:37.486]             seq.int <- base::seq.int
[13:33:37.486]             signalCondition <- base::signalCondition
[13:33:37.486]             sys.calls <- base::sys.calls
[13:33:37.486]             `[[` <- base::`[[`
[13:33:37.486]             `+` <- base::`+`
[13:33:37.486]             `<<-` <- base::`<<-`
[13:33:37.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.486]                   3L)]
[13:33:37.486]             }
[13:33:37.486]             function(cond) {
[13:33:37.486]                 is_error <- inherits(cond, "error")
[13:33:37.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.486]                   NULL)
[13:33:37.486]                 if (is_error) {
[13:33:37.486]                   sessionInformation <- function() {
[13:33:37.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.486]                       search = base::search(), system = base::Sys.info())
[13:33:37.486]                   }
[13:33:37.486]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.486]                     cond$call), session = sessionInformation(), 
[13:33:37.486]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.486]                   signalCondition(cond)
[13:33:37.486]                 }
[13:33:37.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.486]                 "immediateCondition"))) {
[13:33:37.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.486]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.486]                   if (TRUE && !signal) {
[13:33:37.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.486]                     {
[13:33:37.486]                       inherits <- base::inherits
[13:33:37.486]                       invokeRestart <- base::invokeRestart
[13:33:37.486]                       is.null <- base::is.null
[13:33:37.486]                       muffled <- FALSE
[13:33:37.486]                       if (inherits(cond, "message")) {
[13:33:37.486]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.486]                         if (muffled) 
[13:33:37.486]                           invokeRestart("muffleMessage")
[13:33:37.486]                       }
[13:33:37.486]                       else if (inherits(cond, "warning")) {
[13:33:37.486]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.486]                         if (muffled) 
[13:33:37.486]                           invokeRestart("muffleWarning")
[13:33:37.486]                       }
[13:33:37.486]                       else if (inherits(cond, "condition")) {
[13:33:37.486]                         if (!is.null(pattern)) {
[13:33:37.486]                           computeRestarts <- base::computeRestarts
[13:33:37.486]                           grepl <- base::grepl
[13:33:37.486]                           restarts <- computeRestarts(cond)
[13:33:37.486]                           for (restart in restarts) {
[13:33:37.486]                             name <- restart$name
[13:33:37.486]                             if (is.null(name)) 
[13:33:37.486]                               next
[13:33:37.486]                             if (!grepl(pattern, name)) 
[13:33:37.486]                               next
[13:33:37.486]                             invokeRestart(restart)
[13:33:37.486]                             muffled <- TRUE
[13:33:37.486]                             break
[13:33:37.486]                           }
[13:33:37.486]                         }
[13:33:37.486]                       }
[13:33:37.486]                       invisible(muffled)
[13:33:37.486]                     }
[13:33:37.486]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.486]                   }
[13:33:37.486]                 }
[13:33:37.486]                 else {
[13:33:37.486]                   if (TRUE) {
[13:33:37.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.486]                     {
[13:33:37.486]                       inherits <- base::inherits
[13:33:37.486]                       invokeRestart <- base::invokeRestart
[13:33:37.486]                       is.null <- base::is.null
[13:33:37.486]                       muffled <- FALSE
[13:33:37.486]                       if (inherits(cond, "message")) {
[13:33:37.486]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.486]                         if (muffled) 
[13:33:37.486]                           invokeRestart("muffleMessage")
[13:33:37.486]                       }
[13:33:37.486]                       else if (inherits(cond, "warning")) {
[13:33:37.486]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.486]                         if (muffled) 
[13:33:37.486]                           invokeRestart("muffleWarning")
[13:33:37.486]                       }
[13:33:37.486]                       else if (inherits(cond, "condition")) {
[13:33:37.486]                         if (!is.null(pattern)) {
[13:33:37.486]                           computeRestarts <- base::computeRestarts
[13:33:37.486]                           grepl <- base::grepl
[13:33:37.486]                           restarts <- computeRestarts(cond)
[13:33:37.486]                           for (restart in restarts) {
[13:33:37.486]                             name <- restart$name
[13:33:37.486]                             if (is.null(name)) 
[13:33:37.486]                               next
[13:33:37.486]                             if (!grepl(pattern, name)) 
[13:33:37.486]                               next
[13:33:37.486]                             invokeRestart(restart)
[13:33:37.486]                             muffled <- TRUE
[13:33:37.486]                             break
[13:33:37.486]                           }
[13:33:37.486]                         }
[13:33:37.486]                       }
[13:33:37.486]                       invisible(muffled)
[13:33:37.486]                     }
[13:33:37.486]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.486]                   }
[13:33:37.486]                 }
[13:33:37.486]             }
[13:33:37.486]         }))
[13:33:37.486]     }, error = function(ex) {
[13:33:37.486]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.486]                 ...future.rng), started = ...future.startTime, 
[13:33:37.486]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.486]             version = "1.8"), class = "FutureResult")
[13:33:37.486]     }, finally = {
[13:33:37.486]         if (!identical(...future.workdir, getwd())) 
[13:33:37.486]             setwd(...future.workdir)
[13:33:37.486]         {
[13:33:37.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.486]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.486]             }
[13:33:37.486]             base::options(...future.oldOptions)
[13:33:37.486]             if (.Platform$OS.type == "windows") {
[13:33:37.486]                 old_names <- names(...future.oldEnvVars)
[13:33:37.486]                 envs <- base::Sys.getenv()
[13:33:37.486]                 names <- names(envs)
[13:33:37.486]                 common <- intersect(names, old_names)
[13:33:37.486]                 added <- setdiff(names, old_names)
[13:33:37.486]                 removed <- setdiff(old_names, names)
[13:33:37.486]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.486]                   envs[common]]
[13:33:37.486]                 NAMES <- toupper(changed)
[13:33:37.486]                 args <- list()
[13:33:37.486]                 for (kk in seq_along(NAMES)) {
[13:33:37.486]                   name <- changed[[kk]]
[13:33:37.486]                   NAME <- NAMES[[kk]]
[13:33:37.486]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.486]                     next
[13:33:37.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.486]                 }
[13:33:37.486]                 NAMES <- toupper(added)
[13:33:37.486]                 for (kk in seq_along(NAMES)) {
[13:33:37.486]                   name <- added[[kk]]
[13:33:37.486]                   NAME <- NAMES[[kk]]
[13:33:37.486]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.486]                     next
[13:33:37.486]                   args[[name]] <- ""
[13:33:37.486]                 }
[13:33:37.486]                 NAMES <- toupper(removed)
[13:33:37.486]                 for (kk in seq_along(NAMES)) {
[13:33:37.486]                   name <- removed[[kk]]
[13:33:37.486]                   NAME <- NAMES[[kk]]
[13:33:37.486]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.486]                     next
[13:33:37.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.486]                 }
[13:33:37.486]                 if (length(args) > 0) 
[13:33:37.486]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.486]             }
[13:33:37.486]             else {
[13:33:37.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.486]             }
[13:33:37.486]             {
[13:33:37.486]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.486]                   0L) {
[13:33:37.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.486]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.486]                   base::options(opts)
[13:33:37.486]                 }
[13:33:37.486]                 {
[13:33:37.486]                   {
[13:33:37.486]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.486]                     NULL
[13:33:37.486]                   }
[13:33:37.486]                   options(future.plan = NULL)
[13:33:37.486]                   if (is.na(NA_character_)) 
[13:33:37.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.486]                     .init = FALSE)
[13:33:37.486]                 }
[13:33:37.486]             }
[13:33:37.486]         }
[13:33:37.486]     })
[13:33:37.486]     if (TRUE) {
[13:33:37.486]         base::sink(type = "output", split = FALSE)
[13:33:37.486]         if (TRUE) {
[13:33:37.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.486]         }
[13:33:37.486]         else {
[13:33:37.486]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.486]         }
[13:33:37.486]         base::close(...future.stdout)
[13:33:37.486]         ...future.stdout <- NULL
[13:33:37.486]     }
[13:33:37.486]     ...future.result$conditions <- ...future.conditions
[13:33:37.486]     ...future.result$finished <- base::Sys.time()
[13:33:37.486]     ...future.result
[13:33:37.486] }
[13:33:37.488] assign_globals() ...
[13:33:37.488] List of 5
[13:33:37.488]  $ future.call.arguments    : list()
[13:33:37.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.488]  $ ...future.FUN            :function (x)  
[13:33:37.488]  $ ...future.elements_ii    :List of 1
[13:33:37.488]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[13:33:37.488]  $ ...future.seeds_ii       : NULL
[13:33:37.488]  $ ...future.globals.maxSize: num Inf
[13:33:37.488]  - attr(*, "resolved")= logi FALSE
[13:33:37.488]  - attr(*, "total_size")= num NA
[13:33:37.488]  - attr(*, "where")=List of 5
[13:33:37.488]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.488]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.488]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.488]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.488]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.488]  - attr(*, "already-done")= logi TRUE
[13:33:37.493] - copied ‘future.call.arguments’ to environment
[13:33:37.493] - copied ‘...future.FUN’ to environment
[13:33:37.493] - copied ‘...future.elements_ii’ to environment
[13:33:37.493] - copied ‘...future.seeds_ii’ to environment
[13:33:37.493] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.493] assign_globals() ... done
[13:33:37.493] requestCore(): workers = 2
[13:33:37.495] MulticoreFuture started
[13:33:37.496] - Launch lazy future ... done
[13:33:37.496] run() for ‘MulticoreFuture’ ... done
[13:33:37.496] Created future:
[13:33:37.496] plan(): Setting new future strategy stack:
[13:33:37.497] List of future strategies:
[13:33:37.497] 1. sequential:
[13:33:37.497]    - args: function (..., envir = parent.frame())
[13:33:37.497]    - tweaked: FALSE
[13:33:37.497]    - call: NULL
[13:33:37.498] plan(): nbrOfWorkers() = 1
[13:33:37.500] plan(): Setting new future strategy stack:
[13:33:37.500] List of future strategies:
[13:33:37.500] 1. multicore:
[13:33:37.500]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.500]    - tweaked: FALSE
[13:33:37.500]    - call: plan(strategy)
[13:33:37.505] plan(): nbrOfWorkers() = 2
[13:33:37.496] MulticoreFuture:
[13:33:37.496] Label: ‘future_apply-1’
[13:33:37.496] Expression:
[13:33:37.496] {
[13:33:37.496]     do.call(function(...) {
[13:33:37.496]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.496]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.496]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.496]             on.exit(options(oopts), add = TRUE)
[13:33:37.496]         }
[13:33:37.496]         {
[13:33:37.496]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.496]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.496]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.496]             })
[13:33:37.496]         }
[13:33:37.496]     }, args = future.call.arguments)
[13:33:37.496] }
[13:33:37.496] Lazy evaluation: FALSE
[13:33:37.496] Asynchronous evaluation: TRUE
[13:33:37.496] Local evaluation: TRUE
[13:33:37.496] Environment: R_GlobalEnv
[13:33:37.496] Capture standard output: TRUE
[13:33:37.496] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.496] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.496] Packages: <none>
[13:33:37.496] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.496] Resolved: TRUE
[13:33:37.496] Value: <not collected>
[13:33:37.496] Conditions captured: <none>
[13:33:37.496] Early signaling: FALSE
[13:33:37.496] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.496] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.506] Chunk #1 of 2 ... DONE
[13:33:37.506] Chunk #2 of 2 ...
[13:33:37.507]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.507]  - seeds: <none>
[13:33:37.507]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.507] getGlobalsAndPackages() ...
[13:33:37.507] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.508] Resolving globals: FALSE
[13:33:37.508] Tweak future expression to call with '...' arguments ...
[13:33:37.508] {
[13:33:37.508]     do.call(function(...) {
[13:33:37.508]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.508]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.508]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.508]             on.exit(options(oopts), add = TRUE)
[13:33:37.508]         }
[13:33:37.508]         {
[13:33:37.508]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.508]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.508]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.508]             })
[13:33:37.508]         }
[13:33:37.508]     }, args = future.call.arguments)
[13:33:37.508] }
[13:33:37.508] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.509] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.509] 
[13:33:37.509] getGlobalsAndPackages() ... DONE
[13:33:37.510] run() for ‘Future’ ...
[13:33:37.510] - state: ‘created’
[13:33:37.510] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.515] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.515] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.515]   - Field: ‘label’
[13:33:37.515]   - Field: ‘local’
[13:33:37.515]   - Field: ‘owner’
[13:33:37.515]   - Field: ‘envir’
[13:33:37.515]   - Field: ‘workers’
[13:33:37.516]   - Field: ‘packages’
[13:33:37.516]   - Field: ‘gc’
[13:33:37.516]   - Field: ‘job’
[13:33:37.516]   - Field: ‘conditions’
[13:33:37.516]   - Field: ‘expr’
[13:33:37.516]   - Field: ‘uuid’
[13:33:37.516]   - Field: ‘seed’
[13:33:37.517]   - Field: ‘version’
[13:33:37.517]   - Field: ‘result’
[13:33:37.517]   - Field: ‘asynchronous’
[13:33:37.517]   - Field: ‘calls’
[13:33:37.517]   - Field: ‘globals’
[13:33:37.517]   - Field: ‘stdout’
[13:33:37.517]   - Field: ‘earlySignal’
[13:33:37.518]   - Field: ‘lazy’
[13:33:37.518]   - Field: ‘state’
[13:33:37.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.521] - Launch lazy future ...
[13:33:37.522] Packages needed by the future expression (n = 0): <none>
[13:33:37.522] Packages needed by future strategies (n = 0): <none>
[13:33:37.524] {
[13:33:37.524]     {
[13:33:37.524]         {
[13:33:37.524]             ...future.startTime <- base::Sys.time()
[13:33:37.524]             {
[13:33:37.524]                 {
[13:33:37.524]                   {
[13:33:37.524]                     {
[13:33:37.524]                       base::local({
[13:33:37.524]                         has_future <- base::requireNamespace("future", 
[13:33:37.524]                           quietly = TRUE)
[13:33:37.524]                         if (has_future) {
[13:33:37.524]                           ns <- base::getNamespace("future")
[13:33:37.524]                           version <- ns[[".package"]][["version"]]
[13:33:37.524]                           if (is.null(version)) 
[13:33:37.524]                             version <- utils::packageVersion("future")
[13:33:37.524]                         }
[13:33:37.524]                         else {
[13:33:37.524]                           version <- NULL
[13:33:37.524]                         }
[13:33:37.524]                         if (!has_future || version < "1.8.0") {
[13:33:37.524]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.524]                             "", base::R.version$version.string), 
[13:33:37.524]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.524]                               "release", "version")], collapse = " "), 
[13:33:37.524]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.524]                             info)
[13:33:37.524]                           info <- base::paste(info, collapse = "; ")
[13:33:37.524]                           if (!has_future) {
[13:33:37.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.524]                               info)
[13:33:37.524]                           }
[13:33:37.524]                           else {
[13:33:37.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.524]                               info, version)
[13:33:37.524]                           }
[13:33:37.524]                           base::stop(msg)
[13:33:37.524]                         }
[13:33:37.524]                       })
[13:33:37.524]                     }
[13:33:37.524]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.524]                     base::options(mc.cores = 1L)
[13:33:37.524]                   }
[13:33:37.524]                   ...future.strategy.old <- future::plan("list")
[13:33:37.524]                   options(future.plan = NULL)
[13:33:37.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.524]                 }
[13:33:37.524]                 ...future.workdir <- getwd()
[13:33:37.524]             }
[13:33:37.524]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.524]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.524]         }
[13:33:37.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.524]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.524]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.524]             base::names(...future.oldOptions))
[13:33:37.524]     }
[13:33:37.524]     if (FALSE) {
[13:33:37.524]     }
[13:33:37.524]     else {
[13:33:37.524]         if (TRUE) {
[13:33:37.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.524]                 open = "w")
[13:33:37.524]         }
[13:33:37.524]         else {
[13:33:37.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.524]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.524]         }
[13:33:37.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.524]             base::sink(type = "output", split = FALSE)
[13:33:37.524]             base::close(...future.stdout)
[13:33:37.524]         }, add = TRUE)
[13:33:37.524]     }
[13:33:37.524]     ...future.frame <- base::sys.nframe()
[13:33:37.524]     ...future.conditions <- base::list()
[13:33:37.524]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.524]     if (FALSE) {
[13:33:37.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.524]     }
[13:33:37.524]     ...future.result <- base::tryCatch({
[13:33:37.524]         base::withCallingHandlers({
[13:33:37.524]             ...future.value <- base::withVisible(base::local({
[13:33:37.524]                 withCallingHandlers({
[13:33:37.524]                   {
[13:33:37.524]                     do.call(function(...) {
[13:33:37.524]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.524]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.524]                         ...future.globals.maxSize)) {
[13:33:37.524]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.524]                         on.exit(options(oopts), add = TRUE)
[13:33:37.524]                       }
[13:33:37.524]                       {
[13:33:37.524]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.524]                           FUN = function(jj) {
[13:33:37.524]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.524]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.524]                           })
[13:33:37.524]                       }
[13:33:37.524]                     }, args = future.call.arguments)
[13:33:37.524]                   }
[13:33:37.524]                 }, immediateCondition = function(cond) {
[13:33:37.524]                   save_rds <- function (object, pathname, ...) 
[13:33:37.524]                   {
[13:33:37.524]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.524]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.524]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.524]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.524]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.524]                         fi_tmp[["mtime"]])
[13:33:37.524]                     }
[13:33:37.524]                     tryCatch({
[13:33:37.524]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.524]                     }, error = function(ex) {
[13:33:37.524]                       msg <- conditionMessage(ex)
[13:33:37.524]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.524]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.524]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.524]                         fi_tmp[["mtime"]], msg)
[13:33:37.524]                       ex$message <- msg
[13:33:37.524]                       stop(ex)
[13:33:37.524]                     })
[13:33:37.524]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.524]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.524]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.524]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.524]                       fi <- file.info(pathname)
[13:33:37.524]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.524]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.524]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.524]                         fi[["size"]], fi[["mtime"]])
[13:33:37.524]                       stop(msg)
[13:33:37.524]                     }
[13:33:37.524]                     invisible(pathname)
[13:33:37.524]                   }
[13:33:37.524]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.524]                     rootPath = tempdir()) 
[13:33:37.524]                   {
[13:33:37.524]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.524]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.524]                       tmpdir = path, fileext = ".rds")
[13:33:37.524]                     save_rds(obj, file)
[13:33:37.524]                   }
[13:33:37.524]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.524]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.524]                   {
[13:33:37.524]                     inherits <- base::inherits
[13:33:37.524]                     invokeRestart <- base::invokeRestart
[13:33:37.524]                     is.null <- base::is.null
[13:33:37.524]                     muffled <- FALSE
[13:33:37.524]                     if (inherits(cond, "message")) {
[13:33:37.524]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.524]                       if (muffled) 
[13:33:37.524]                         invokeRestart("muffleMessage")
[13:33:37.524]                     }
[13:33:37.524]                     else if (inherits(cond, "warning")) {
[13:33:37.524]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.524]                       if (muffled) 
[13:33:37.524]                         invokeRestart("muffleWarning")
[13:33:37.524]                     }
[13:33:37.524]                     else if (inherits(cond, "condition")) {
[13:33:37.524]                       if (!is.null(pattern)) {
[13:33:37.524]                         computeRestarts <- base::computeRestarts
[13:33:37.524]                         grepl <- base::grepl
[13:33:37.524]                         restarts <- computeRestarts(cond)
[13:33:37.524]                         for (restart in restarts) {
[13:33:37.524]                           name <- restart$name
[13:33:37.524]                           if (is.null(name)) 
[13:33:37.524]                             next
[13:33:37.524]                           if (!grepl(pattern, name)) 
[13:33:37.524]                             next
[13:33:37.524]                           invokeRestart(restart)
[13:33:37.524]                           muffled <- TRUE
[13:33:37.524]                           break
[13:33:37.524]                         }
[13:33:37.524]                       }
[13:33:37.524]                     }
[13:33:37.524]                     invisible(muffled)
[13:33:37.524]                   }
[13:33:37.524]                   muffleCondition(cond)
[13:33:37.524]                 })
[13:33:37.524]             }))
[13:33:37.524]             future::FutureResult(value = ...future.value$value, 
[13:33:37.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.524]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.524]                     ...future.globalenv.names))
[13:33:37.524]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.524]         }, condition = base::local({
[13:33:37.524]             c <- base::c
[13:33:37.524]             inherits <- base::inherits
[13:33:37.524]             invokeRestart <- base::invokeRestart
[13:33:37.524]             length <- base::length
[13:33:37.524]             list <- base::list
[13:33:37.524]             seq.int <- base::seq.int
[13:33:37.524]             signalCondition <- base::signalCondition
[13:33:37.524]             sys.calls <- base::sys.calls
[13:33:37.524]             `[[` <- base::`[[`
[13:33:37.524]             `+` <- base::`+`
[13:33:37.524]             `<<-` <- base::`<<-`
[13:33:37.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.524]                   3L)]
[13:33:37.524]             }
[13:33:37.524]             function(cond) {
[13:33:37.524]                 is_error <- inherits(cond, "error")
[13:33:37.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.524]                   NULL)
[13:33:37.524]                 if (is_error) {
[13:33:37.524]                   sessionInformation <- function() {
[13:33:37.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.524]                       search = base::search(), system = base::Sys.info())
[13:33:37.524]                   }
[13:33:37.524]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.524]                     cond$call), session = sessionInformation(), 
[13:33:37.524]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.524]                   signalCondition(cond)
[13:33:37.524]                 }
[13:33:37.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.524]                 "immediateCondition"))) {
[13:33:37.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.524]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.524]                   if (TRUE && !signal) {
[13:33:37.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.524]                     {
[13:33:37.524]                       inherits <- base::inherits
[13:33:37.524]                       invokeRestart <- base::invokeRestart
[13:33:37.524]                       is.null <- base::is.null
[13:33:37.524]                       muffled <- FALSE
[13:33:37.524]                       if (inherits(cond, "message")) {
[13:33:37.524]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.524]                         if (muffled) 
[13:33:37.524]                           invokeRestart("muffleMessage")
[13:33:37.524]                       }
[13:33:37.524]                       else if (inherits(cond, "warning")) {
[13:33:37.524]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.524]                         if (muffled) 
[13:33:37.524]                           invokeRestart("muffleWarning")
[13:33:37.524]                       }
[13:33:37.524]                       else if (inherits(cond, "condition")) {
[13:33:37.524]                         if (!is.null(pattern)) {
[13:33:37.524]                           computeRestarts <- base::computeRestarts
[13:33:37.524]                           grepl <- base::grepl
[13:33:37.524]                           restarts <- computeRestarts(cond)
[13:33:37.524]                           for (restart in restarts) {
[13:33:37.524]                             name <- restart$name
[13:33:37.524]                             if (is.null(name)) 
[13:33:37.524]                               next
[13:33:37.524]                             if (!grepl(pattern, name)) 
[13:33:37.524]                               next
[13:33:37.524]                             invokeRestart(restart)
[13:33:37.524]                             muffled <- TRUE
[13:33:37.524]                             break
[13:33:37.524]                           }
[13:33:37.524]                         }
[13:33:37.524]                       }
[13:33:37.524]                       invisible(muffled)
[13:33:37.524]                     }
[13:33:37.524]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.524]                   }
[13:33:37.524]                 }
[13:33:37.524]                 else {
[13:33:37.524]                   if (TRUE) {
[13:33:37.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.524]                     {
[13:33:37.524]                       inherits <- base::inherits
[13:33:37.524]                       invokeRestart <- base::invokeRestart
[13:33:37.524]                       is.null <- base::is.null
[13:33:37.524]                       muffled <- FALSE
[13:33:37.524]                       if (inherits(cond, "message")) {
[13:33:37.524]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.524]                         if (muffled) 
[13:33:37.524]                           invokeRestart("muffleMessage")
[13:33:37.524]                       }
[13:33:37.524]                       else if (inherits(cond, "warning")) {
[13:33:37.524]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.524]                         if (muffled) 
[13:33:37.524]                           invokeRestart("muffleWarning")
[13:33:37.524]                       }
[13:33:37.524]                       else if (inherits(cond, "condition")) {
[13:33:37.524]                         if (!is.null(pattern)) {
[13:33:37.524]                           computeRestarts <- base::computeRestarts
[13:33:37.524]                           grepl <- base::grepl
[13:33:37.524]                           restarts <- computeRestarts(cond)
[13:33:37.524]                           for (restart in restarts) {
[13:33:37.524]                             name <- restart$name
[13:33:37.524]                             if (is.null(name)) 
[13:33:37.524]                               next
[13:33:37.524]                             if (!grepl(pattern, name)) 
[13:33:37.524]                               next
[13:33:37.524]                             invokeRestart(restart)
[13:33:37.524]                             muffled <- TRUE
[13:33:37.524]                             break
[13:33:37.524]                           }
[13:33:37.524]                         }
[13:33:37.524]                       }
[13:33:37.524]                       invisible(muffled)
[13:33:37.524]                     }
[13:33:37.524]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.524]                   }
[13:33:37.524]                 }
[13:33:37.524]             }
[13:33:37.524]         }))
[13:33:37.524]     }, error = function(ex) {
[13:33:37.524]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.524]                 ...future.rng), started = ...future.startTime, 
[13:33:37.524]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.524]             version = "1.8"), class = "FutureResult")
[13:33:37.524]     }, finally = {
[13:33:37.524]         if (!identical(...future.workdir, getwd())) 
[13:33:37.524]             setwd(...future.workdir)
[13:33:37.524]         {
[13:33:37.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.524]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.524]             }
[13:33:37.524]             base::options(...future.oldOptions)
[13:33:37.524]             if (.Platform$OS.type == "windows") {
[13:33:37.524]                 old_names <- names(...future.oldEnvVars)
[13:33:37.524]                 envs <- base::Sys.getenv()
[13:33:37.524]                 names <- names(envs)
[13:33:37.524]                 common <- intersect(names, old_names)
[13:33:37.524]                 added <- setdiff(names, old_names)
[13:33:37.524]                 removed <- setdiff(old_names, names)
[13:33:37.524]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.524]                   envs[common]]
[13:33:37.524]                 NAMES <- toupper(changed)
[13:33:37.524]                 args <- list()
[13:33:37.524]                 for (kk in seq_along(NAMES)) {
[13:33:37.524]                   name <- changed[[kk]]
[13:33:37.524]                   NAME <- NAMES[[kk]]
[13:33:37.524]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.524]                     next
[13:33:37.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.524]                 }
[13:33:37.524]                 NAMES <- toupper(added)
[13:33:37.524]                 for (kk in seq_along(NAMES)) {
[13:33:37.524]                   name <- added[[kk]]
[13:33:37.524]                   NAME <- NAMES[[kk]]
[13:33:37.524]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.524]                     next
[13:33:37.524]                   args[[name]] <- ""
[13:33:37.524]                 }
[13:33:37.524]                 NAMES <- toupper(removed)
[13:33:37.524]                 for (kk in seq_along(NAMES)) {
[13:33:37.524]                   name <- removed[[kk]]
[13:33:37.524]                   NAME <- NAMES[[kk]]
[13:33:37.524]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.524]                     next
[13:33:37.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.524]                 }
[13:33:37.524]                 if (length(args) > 0) 
[13:33:37.524]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.524]             }
[13:33:37.524]             else {
[13:33:37.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.524]             }
[13:33:37.524]             {
[13:33:37.524]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.524]                   0L) {
[13:33:37.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.524]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.524]                   base::options(opts)
[13:33:37.524]                 }
[13:33:37.524]                 {
[13:33:37.524]                   {
[13:33:37.524]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.524]                     NULL
[13:33:37.524]                   }
[13:33:37.524]                   options(future.plan = NULL)
[13:33:37.524]                   if (is.na(NA_character_)) 
[13:33:37.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.524]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.524]                     .init = FALSE)
[13:33:37.524]                 }
[13:33:37.524]             }
[13:33:37.524]         }
[13:33:37.524]     })
[13:33:37.524]     if (TRUE) {
[13:33:37.524]         base::sink(type = "output", split = FALSE)
[13:33:37.524]         if (TRUE) {
[13:33:37.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.524]         }
[13:33:37.524]         else {
[13:33:37.524]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.524]         }
[13:33:37.524]         base::close(...future.stdout)
[13:33:37.524]         ...future.stdout <- NULL
[13:33:37.524]     }
[13:33:37.524]     ...future.result$conditions <- ...future.conditions
[13:33:37.524]     ...future.result$finished <- base::Sys.time()
[13:33:37.524]     ...future.result
[13:33:37.524] }
[13:33:37.527] assign_globals() ...
[13:33:37.527] List of 5
[13:33:37.527]  $ future.call.arguments    : list()
[13:33:37.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.527]  $ ...future.FUN            :function (x)  
[13:33:37.527]  $ ...future.elements_ii    :List of 1
[13:33:37.527]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[13:33:37.527]  $ ...future.seeds_ii       : NULL
[13:33:37.527]  $ ...future.globals.maxSize: num Inf
[13:33:37.527]  - attr(*, "resolved")= logi FALSE
[13:33:37.527]  - attr(*, "total_size")= num NA
[13:33:37.527]  - attr(*, "where")=List of 5
[13:33:37.527]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.527]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.527]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.527]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.527]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.527]  - attr(*, "already-done")= logi TRUE
[13:33:37.536] - copied ‘future.call.arguments’ to environment
[13:33:37.536] - copied ‘...future.FUN’ to environment
[13:33:37.536] - copied ‘...future.elements_ii’ to environment
[13:33:37.536] - copied ‘...future.seeds_ii’ to environment
[13:33:37.537] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.537] assign_globals() ... done
[13:33:37.537] requestCore(): workers = 2
[13:33:37.539] MulticoreFuture started
[13:33:37.539] - Launch lazy future ... done
[13:33:37.540] run() for ‘MulticoreFuture’ ... done
[13:33:37.540] Created future:
[13:33:37.540] plan(): Setting new future strategy stack:
[13:33:37.541] List of future strategies:
[13:33:37.541] 1. sequential:
[13:33:37.541]    - args: function (..., envir = parent.frame())
[13:33:37.541]    - tweaked: FALSE
[13:33:37.541]    - call: NULL
[13:33:37.541] plan(): nbrOfWorkers() = 1
[13:33:37.543] plan(): Setting new future strategy stack:
[13:33:37.544] List of future strategies:
[13:33:37.544] 1. multicore:
[13:33:37.544]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.544]    - tweaked: FALSE
[13:33:37.544]    - call: plan(strategy)
[13:33:37.549] plan(): nbrOfWorkers() = 2
[13:33:37.540] MulticoreFuture:
[13:33:37.540] Label: ‘future_apply-2’
[13:33:37.540] Expression:
[13:33:37.540] {
[13:33:37.540]     do.call(function(...) {
[13:33:37.540]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.540]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.540]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.540]             on.exit(options(oopts), add = TRUE)
[13:33:37.540]         }
[13:33:37.540]         {
[13:33:37.540]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.540]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.540]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.540]             })
[13:33:37.540]         }
[13:33:37.540]     }, args = future.call.arguments)
[13:33:37.540] }
[13:33:37.540] Lazy evaluation: FALSE
[13:33:37.540] Asynchronous evaluation: TRUE
[13:33:37.540] Local evaluation: TRUE
[13:33:37.540] Environment: R_GlobalEnv
[13:33:37.540] Capture standard output: TRUE
[13:33:37.540] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.540] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.540] Packages: <none>
[13:33:37.540] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.540] Resolved: TRUE
[13:33:37.540] Value: <not collected>
[13:33:37.540] Conditions captured: <none>
[13:33:37.540] Early signaling: FALSE
[13:33:37.540] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.540] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.550] Chunk #2 of 2 ... DONE
[13:33:37.550] Launching 2 futures (chunks) ... DONE
[13:33:37.550] Resolving 2 futures (chunks) ...
[13:33:37.550] resolve() on list ...
[13:33:37.550]  recursive: 0
[13:33:37.551]  length: 2
[13:33:37.551] 
[13:33:37.551] Future #1
[13:33:37.551] result() for MulticoreFuture ...
[13:33:37.552] result() for MulticoreFuture ...
[13:33:37.552] result() for MulticoreFuture ... done
[13:33:37.552] result() for MulticoreFuture ... done
[13:33:37.553] result() for MulticoreFuture ...
[13:33:37.553] result() for MulticoreFuture ... done
[13:33:37.553] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:37.553] - nx: 2
[13:33:37.553] - relay: TRUE
[13:33:37.553] - stdout: TRUE
[13:33:37.554] - signal: TRUE
[13:33:37.554] - resignal: FALSE
[13:33:37.554] - force: TRUE
[13:33:37.554] - relayed: [n=2] FALSE, FALSE
[13:33:37.554] - queued futures: [n=2] FALSE, FALSE
[13:33:37.554]  - until=1
[13:33:37.554]  - relaying element #1
[13:33:37.555] result() for MulticoreFuture ...
[13:33:37.555] result() for MulticoreFuture ... done
[13:33:37.555] result() for MulticoreFuture ...
[13:33:37.555] result() for MulticoreFuture ... done
[13:33:37.555] result() for MulticoreFuture ...
[13:33:37.555] result() for MulticoreFuture ... done
[13:33:37.556] result() for MulticoreFuture ...
[13:33:37.556] result() for MulticoreFuture ... done
[13:33:37.556] - relayed: [n=2] TRUE, FALSE
[13:33:37.556] - queued futures: [n=2] TRUE, FALSE
[13:33:37.556] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:37.556]  length: 1 (resolved future 1)
[13:33:37.557] Future #2
[13:33:37.557] result() for MulticoreFuture ...
[13:33:37.558] result() for MulticoreFuture ...
[13:33:37.558] result() for MulticoreFuture ... done
[13:33:37.558] result() for MulticoreFuture ... done
[13:33:37.558] result() for MulticoreFuture ...
[13:33:37.558] result() for MulticoreFuture ... done
[13:33:37.558] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:37.559] - nx: 2
[13:33:37.559] - relay: TRUE
[13:33:37.559] - stdout: TRUE
[13:33:37.559] - signal: TRUE
[13:33:37.559] - resignal: FALSE
[13:33:37.559] - force: TRUE
[13:33:37.559] - relayed: [n=2] TRUE, FALSE
[13:33:37.559] - queued futures: [n=2] TRUE, FALSE
[13:33:37.559]  - until=2
[13:33:37.560]  - relaying element #2
[13:33:37.560] result() for MulticoreFuture ...
[13:33:37.560] result() for MulticoreFuture ... done
[13:33:37.560] result() for MulticoreFuture ...
[13:33:37.560] result() for MulticoreFuture ... done
[13:33:37.560] result() for MulticoreFuture ...
[13:33:37.560] result() for MulticoreFuture ... done
[13:33:37.560] result() for MulticoreFuture ...
[13:33:37.561] result() for MulticoreFuture ... done
[13:33:37.561] - relayed: [n=2] TRUE, TRUE
[13:33:37.561] - queued futures: [n=2] TRUE, TRUE
[13:33:37.561] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:37.561]  length: 0 (resolved future 2)
[13:33:37.561] Relaying remaining futures
[13:33:37.561] signalConditionsASAP(NULL, pos=0) ...
[13:33:37.561] - nx: 2
[13:33:37.561] - relay: TRUE
[13:33:37.561] - stdout: TRUE
[13:33:37.562] - signal: TRUE
[13:33:37.562] - resignal: FALSE
[13:33:37.562] - force: TRUE
[13:33:37.562] - relayed: [n=2] TRUE, TRUE
[13:33:37.562] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:37.562] - relayed: [n=2] TRUE, TRUE
[13:33:37.562] - queued futures: [n=2] TRUE, TRUE
[13:33:37.562] signalConditionsASAP(NULL, pos=0) ... done
[13:33:37.563] resolve() on list ... DONE
[13:33:37.563] result() for MulticoreFuture ...
[13:33:37.563] result() for MulticoreFuture ... done
[13:33:37.563] result() for MulticoreFuture ...
[13:33:37.563] result() for MulticoreFuture ... done
[13:33:37.563] result() for MulticoreFuture ...
[13:33:37.563] result() for MulticoreFuture ... done
[13:33:37.563] result() for MulticoreFuture ...
[13:33:37.563] result() for MulticoreFuture ... done
[13:33:37.564]  - Number of value chunks collected: 2
[13:33:37.564] Resolving 2 futures (chunks) ... DONE
[13:33:37.564] Reducing values from 2 chunks ...
[13:33:37.564]  - Number of values collected after concatenation: 2
[13:33:37.564]  - Number of values expected: 2
[13:33:37.564] Reducing values from 2 chunks ... DONE
[13:33:37.567] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[13:33:37.567] getGlobalsAndPackagesXApply() ...
[13:33:37.568]  - future.globals: TRUE
[13:33:37.568] getGlobalsAndPackages() ...
[13:33:37.568] Searching for globals...
[13:33:37.572] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[13:33:37.572] Searching for globals ... DONE
[13:33:37.572] Resolving globals: FALSE
[13:33:37.573] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[13:33:37.573] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[13:33:37.573] - globals: [1] ‘FUN’
[13:33:37.573] 
[13:33:37.573] getGlobalsAndPackages() ... DONE
[13:33:37.573]  - globals found/used: [n=1] ‘FUN’
[13:33:37.574]  - needed namespaces: [n=0] 
[13:33:37.574] Finding globals ... DONE
[13:33:37.574]  - use_args: TRUE
[13:33:37.574]  - Getting '...' globals ...
[13:33:37.575] resolve() on list ...
[13:33:37.575]  recursive: 0
[13:33:37.575]  length: 1
[13:33:37.575]  elements: ‘...’
[13:33:37.575]  length: 0 (resolved future 1)
[13:33:37.575] resolve() on list ... DONE
[13:33:37.575]    - '...' content: [n=0] 
[13:33:37.575] List of 1
[13:33:37.575]  $ ...: list()
[13:33:37.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.575]  - attr(*, "where")=List of 1
[13:33:37.575]   ..$ ...:<environment: 0x55b94a1bae78> 
[13:33:37.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.575]  - attr(*, "resolved")= logi TRUE
[13:33:37.575]  - attr(*, "total_size")= num NA
[13:33:37.578]  - Getting '...' globals ... DONE
[13:33:37.578] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:37.578] List of 2
[13:33:37.578]  $ ...future.FUN:function (x)  
[13:33:37.578]  $ ...          : list()
[13:33:37.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.578]  - attr(*, "where")=List of 2
[13:33:37.578]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:37.578]   ..$ ...          :<environment: 0x55b94a1bae78> 
[13:33:37.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.578]  - attr(*, "resolved")= logi FALSE
[13:33:37.578]  - attr(*, "total_size")= num 9888
[13:33:37.581] Packages to be attached in all futures: [n=0] 
[13:33:37.581] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.585] future_lapply() ...
[13:33:37.589] Number of chunks: 2
[13:33:37.590] getGlobalsAndPackagesXApply() ...
[13:33:37.590]  - future.globals: <name-value list> with names ‘list()’
[13:33:37.590]  - use_args: TRUE
[13:33:37.590] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:37.590] List of 2
[13:33:37.590]  $ ...          : list()
[13:33:37.590]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.590]  $ ...future.FUN:function (x)  
[13:33:37.590]  - attr(*, "where")=List of 2
[13:33:37.590]   ..$ ...          :<environment: 0x55b94a1bae78> 
[13:33:37.590]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:33:37.590]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.590]  - attr(*, "resolved")= logi FALSE
[13:33:37.590]  - attr(*, "total_size")= num NA
[13:33:37.595] Packages to be attached in all futures: [n=0] 
[13:33:37.595] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.595] Number of futures (= number of chunks): 2
[13:33:37.595] Launching 2 futures (chunks) ...
[13:33:37.595] Chunk #1 of 2 ...
[13:33:37.595]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.596]  - seeds: <none>
[13:33:37.596]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.596] getGlobalsAndPackages() ...
[13:33:37.596] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.596] Resolving globals: FALSE
[13:33:37.596] Tweak future expression to call with '...' arguments ...
[13:33:37.596] {
[13:33:37.596]     do.call(function(...) {
[13:33:37.596]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.596]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.596]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.596]             on.exit(options(oopts), add = TRUE)
[13:33:37.596]         }
[13:33:37.596]         {
[13:33:37.596]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.596]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.596]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.596]             })
[13:33:37.596]         }
[13:33:37.596]     }, args = future.call.arguments)
[13:33:37.596] }
[13:33:37.597] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.597] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.597] 
[13:33:37.597] getGlobalsAndPackages() ... DONE
[13:33:37.597] run() for ‘Future’ ...
[13:33:37.597] - state: ‘created’
[13:33:37.598] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.601] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.601] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.601]   - Field: ‘label’
[13:33:37.601]   - Field: ‘local’
[13:33:37.602]   - Field: ‘owner’
[13:33:37.602]   - Field: ‘envir’
[13:33:37.602]   - Field: ‘workers’
[13:33:37.602]   - Field: ‘packages’
[13:33:37.602]   - Field: ‘gc’
[13:33:37.602]   - Field: ‘job’
[13:33:37.602]   - Field: ‘conditions’
[13:33:37.602]   - Field: ‘expr’
[13:33:37.602]   - Field: ‘uuid’
[13:33:37.602]   - Field: ‘seed’
[13:33:37.603]   - Field: ‘version’
[13:33:37.603]   - Field: ‘result’
[13:33:37.603]   - Field: ‘asynchronous’
[13:33:37.603]   - Field: ‘calls’
[13:33:37.603]   - Field: ‘globals’
[13:33:37.603]   - Field: ‘stdout’
[13:33:37.603]   - Field: ‘earlySignal’
[13:33:37.603]   - Field: ‘lazy’
[13:33:37.603]   - Field: ‘state’
[13:33:37.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.603] - Launch lazy future ...
[13:33:37.604] Packages needed by the future expression (n = 0): <none>
[13:33:37.604] Packages needed by future strategies (n = 0): <none>
[13:33:37.604] {
[13:33:37.604]     {
[13:33:37.604]         {
[13:33:37.604]             ...future.startTime <- base::Sys.time()
[13:33:37.604]             {
[13:33:37.604]                 {
[13:33:37.604]                   {
[13:33:37.604]                     {
[13:33:37.604]                       base::local({
[13:33:37.604]                         has_future <- base::requireNamespace("future", 
[13:33:37.604]                           quietly = TRUE)
[13:33:37.604]                         if (has_future) {
[13:33:37.604]                           ns <- base::getNamespace("future")
[13:33:37.604]                           version <- ns[[".package"]][["version"]]
[13:33:37.604]                           if (is.null(version)) 
[13:33:37.604]                             version <- utils::packageVersion("future")
[13:33:37.604]                         }
[13:33:37.604]                         else {
[13:33:37.604]                           version <- NULL
[13:33:37.604]                         }
[13:33:37.604]                         if (!has_future || version < "1.8.0") {
[13:33:37.604]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.604]                             "", base::R.version$version.string), 
[13:33:37.604]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.604]                               "release", "version")], collapse = " "), 
[13:33:37.604]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.604]                             info)
[13:33:37.604]                           info <- base::paste(info, collapse = "; ")
[13:33:37.604]                           if (!has_future) {
[13:33:37.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.604]                               info)
[13:33:37.604]                           }
[13:33:37.604]                           else {
[13:33:37.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.604]                               info, version)
[13:33:37.604]                           }
[13:33:37.604]                           base::stop(msg)
[13:33:37.604]                         }
[13:33:37.604]                       })
[13:33:37.604]                     }
[13:33:37.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.604]                     base::options(mc.cores = 1L)
[13:33:37.604]                   }
[13:33:37.604]                   ...future.strategy.old <- future::plan("list")
[13:33:37.604]                   options(future.plan = NULL)
[13:33:37.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.604]                 }
[13:33:37.604]                 ...future.workdir <- getwd()
[13:33:37.604]             }
[13:33:37.604]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.604]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.604]         }
[13:33:37.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.604]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.604]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.604]             base::names(...future.oldOptions))
[13:33:37.604]     }
[13:33:37.604]     if (FALSE) {
[13:33:37.604]     }
[13:33:37.604]     else {
[13:33:37.604]         if (TRUE) {
[13:33:37.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.604]                 open = "w")
[13:33:37.604]         }
[13:33:37.604]         else {
[13:33:37.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.604]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.604]         }
[13:33:37.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.604]             base::sink(type = "output", split = FALSE)
[13:33:37.604]             base::close(...future.stdout)
[13:33:37.604]         }, add = TRUE)
[13:33:37.604]     }
[13:33:37.604]     ...future.frame <- base::sys.nframe()
[13:33:37.604]     ...future.conditions <- base::list()
[13:33:37.604]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.604]     if (FALSE) {
[13:33:37.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.604]     }
[13:33:37.604]     ...future.result <- base::tryCatch({
[13:33:37.604]         base::withCallingHandlers({
[13:33:37.604]             ...future.value <- base::withVisible(base::local({
[13:33:37.604]                 withCallingHandlers({
[13:33:37.604]                   {
[13:33:37.604]                     do.call(function(...) {
[13:33:37.604]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.604]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.604]                         ...future.globals.maxSize)) {
[13:33:37.604]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.604]                         on.exit(options(oopts), add = TRUE)
[13:33:37.604]                       }
[13:33:37.604]                       {
[13:33:37.604]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.604]                           FUN = function(jj) {
[13:33:37.604]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.604]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.604]                           })
[13:33:37.604]                       }
[13:33:37.604]                     }, args = future.call.arguments)
[13:33:37.604]                   }
[13:33:37.604]                 }, immediateCondition = function(cond) {
[13:33:37.604]                   save_rds <- function (object, pathname, ...) 
[13:33:37.604]                   {
[13:33:37.604]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.604]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.604]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.604]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.604]                         fi_tmp[["mtime"]])
[13:33:37.604]                     }
[13:33:37.604]                     tryCatch({
[13:33:37.604]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.604]                     }, error = function(ex) {
[13:33:37.604]                       msg <- conditionMessage(ex)
[13:33:37.604]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.604]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.604]                         fi_tmp[["mtime"]], msg)
[13:33:37.604]                       ex$message <- msg
[13:33:37.604]                       stop(ex)
[13:33:37.604]                     })
[13:33:37.604]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.604]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.604]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.604]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.604]                       fi <- file.info(pathname)
[13:33:37.604]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.604]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.604]                         fi[["size"]], fi[["mtime"]])
[13:33:37.604]                       stop(msg)
[13:33:37.604]                     }
[13:33:37.604]                     invisible(pathname)
[13:33:37.604]                   }
[13:33:37.604]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.604]                     rootPath = tempdir()) 
[13:33:37.604]                   {
[13:33:37.604]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.604]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.604]                       tmpdir = path, fileext = ".rds")
[13:33:37.604]                     save_rds(obj, file)
[13:33:37.604]                   }
[13:33:37.604]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.604]                   {
[13:33:37.604]                     inherits <- base::inherits
[13:33:37.604]                     invokeRestart <- base::invokeRestart
[13:33:37.604]                     is.null <- base::is.null
[13:33:37.604]                     muffled <- FALSE
[13:33:37.604]                     if (inherits(cond, "message")) {
[13:33:37.604]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.604]                       if (muffled) 
[13:33:37.604]                         invokeRestart("muffleMessage")
[13:33:37.604]                     }
[13:33:37.604]                     else if (inherits(cond, "warning")) {
[13:33:37.604]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.604]                       if (muffled) 
[13:33:37.604]                         invokeRestart("muffleWarning")
[13:33:37.604]                     }
[13:33:37.604]                     else if (inherits(cond, "condition")) {
[13:33:37.604]                       if (!is.null(pattern)) {
[13:33:37.604]                         computeRestarts <- base::computeRestarts
[13:33:37.604]                         grepl <- base::grepl
[13:33:37.604]                         restarts <- computeRestarts(cond)
[13:33:37.604]                         for (restart in restarts) {
[13:33:37.604]                           name <- restart$name
[13:33:37.604]                           if (is.null(name)) 
[13:33:37.604]                             next
[13:33:37.604]                           if (!grepl(pattern, name)) 
[13:33:37.604]                             next
[13:33:37.604]                           invokeRestart(restart)
[13:33:37.604]                           muffled <- TRUE
[13:33:37.604]                           break
[13:33:37.604]                         }
[13:33:37.604]                       }
[13:33:37.604]                     }
[13:33:37.604]                     invisible(muffled)
[13:33:37.604]                   }
[13:33:37.604]                   muffleCondition(cond)
[13:33:37.604]                 })
[13:33:37.604]             }))
[13:33:37.604]             future::FutureResult(value = ...future.value$value, 
[13:33:37.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.604]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.604]                     ...future.globalenv.names))
[13:33:37.604]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.604]         }, condition = base::local({
[13:33:37.604]             c <- base::c
[13:33:37.604]             inherits <- base::inherits
[13:33:37.604]             invokeRestart <- base::invokeRestart
[13:33:37.604]             length <- base::length
[13:33:37.604]             list <- base::list
[13:33:37.604]             seq.int <- base::seq.int
[13:33:37.604]             signalCondition <- base::signalCondition
[13:33:37.604]             sys.calls <- base::sys.calls
[13:33:37.604]             `[[` <- base::`[[`
[13:33:37.604]             `+` <- base::`+`
[13:33:37.604]             `<<-` <- base::`<<-`
[13:33:37.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.604]                   3L)]
[13:33:37.604]             }
[13:33:37.604]             function(cond) {
[13:33:37.604]                 is_error <- inherits(cond, "error")
[13:33:37.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.604]                   NULL)
[13:33:37.604]                 if (is_error) {
[13:33:37.604]                   sessionInformation <- function() {
[13:33:37.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.604]                       search = base::search(), system = base::Sys.info())
[13:33:37.604]                   }
[13:33:37.604]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.604]                     cond$call), session = sessionInformation(), 
[13:33:37.604]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.604]                   signalCondition(cond)
[13:33:37.604]                 }
[13:33:37.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.604]                 "immediateCondition"))) {
[13:33:37.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.604]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.604]                   if (TRUE && !signal) {
[13:33:37.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.604]                     {
[13:33:37.604]                       inherits <- base::inherits
[13:33:37.604]                       invokeRestart <- base::invokeRestart
[13:33:37.604]                       is.null <- base::is.null
[13:33:37.604]                       muffled <- FALSE
[13:33:37.604]                       if (inherits(cond, "message")) {
[13:33:37.604]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.604]                         if (muffled) 
[13:33:37.604]                           invokeRestart("muffleMessage")
[13:33:37.604]                       }
[13:33:37.604]                       else if (inherits(cond, "warning")) {
[13:33:37.604]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.604]                         if (muffled) 
[13:33:37.604]                           invokeRestart("muffleWarning")
[13:33:37.604]                       }
[13:33:37.604]                       else if (inherits(cond, "condition")) {
[13:33:37.604]                         if (!is.null(pattern)) {
[13:33:37.604]                           computeRestarts <- base::computeRestarts
[13:33:37.604]                           grepl <- base::grepl
[13:33:37.604]                           restarts <- computeRestarts(cond)
[13:33:37.604]                           for (restart in restarts) {
[13:33:37.604]                             name <- restart$name
[13:33:37.604]                             if (is.null(name)) 
[13:33:37.604]                               next
[13:33:37.604]                             if (!grepl(pattern, name)) 
[13:33:37.604]                               next
[13:33:37.604]                             invokeRestart(restart)
[13:33:37.604]                             muffled <- TRUE
[13:33:37.604]                             break
[13:33:37.604]                           }
[13:33:37.604]                         }
[13:33:37.604]                       }
[13:33:37.604]                       invisible(muffled)
[13:33:37.604]                     }
[13:33:37.604]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.604]                   }
[13:33:37.604]                 }
[13:33:37.604]                 else {
[13:33:37.604]                   if (TRUE) {
[13:33:37.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.604]                     {
[13:33:37.604]                       inherits <- base::inherits
[13:33:37.604]                       invokeRestart <- base::invokeRestart
[13:33:37.604]                       is.null <- base::is.null
[13:33:37.604]                       muffled <- FALSE
[13:33:37.604]                       if (inherits(cond, "message")) {
[13:33:37.604]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.604]                         if (muffled) 
[13:33:37.604]                           invokeRestart("muffleMessage")
[13:33:37.604]                       }
[13:33:37.604]                       else if (inherits(cond, "warning")) {
[13:33:37.604]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.604]                         if (muffled) 
[13:33:37.604]                           invokeRestart("muffleWarning")
[13:33:37.604]                       }
[13:33:37.604]                       else if (inherits(cond, "condition")) {
[13:33:37.604]                         if (!is.null(pattern)) {
[13:33:37.604]                           computeRestarts <- base::computeRestarts
[13:33:37.604]                           grepl <- base::grepl
[13:33:37.604]                           restarts <- computeRestarts(cond)
[13:33:37.604]                           for (restart in restarts) {
[13:33:37.604]                             name <- restart$name
[13:33:37.604]                             if (is.null(name)) 
[13:33:37.604]                               next
[13:33:37.604]                             if (!grepl(pattern, name)) 
[13:33:37.604]                               next
[13:33:37.604]                             invokeRestart(restart)
[13:33:37.604]                             muffled <- TRUE
[13:33:37.604]                             break
[13:33:37.604]                           }
[13:33:37.604]                         }
[13:33:37.604]                       }
[13:33:37.604]                       invisible(muffled)
[13:33:37.604]                     }
[13:33:37.604]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.604]                   }
[13:33:37.604]                 }
[13:33:37.604]             }
[13:33:37.604]         }))
[13:33:37.604]     }, error = function(ex) {
[13:33:37.604]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.604]                 ...future.rng), started = ...future.startTime, 
[13:33:37.604]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.604]             version = "1.8"), class = "FutureResult")
[13:33:37.604]     }, finally = {
[13:33:37.604]         if (!identical(...future.workdir, getwd())) 
[13:33:37.604]             setwd(...future.workdir)
[13:33:37.604]         {
[13:33:37.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.604]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.604]             }
[13:33:37.604]             base::options(...future.oldOptions)
[13:33:37.604]             if (.Platform$OS.type == "windows") {
[13:33:37.604]                 old_names <- names(...future.oldEnvVars)
[13:33:37.604]                 envs <- base::Sys.getenv()
[13:33:37.604]                 names <- names(envs)
[13:33:37.604]                 common <- intersect(names, old_names)
[13:33:37.604]                 added <- setdiff(names, old_names)
[13:33:37.604]                 removed <- setdiff(old_names, names)
[13:33:37.604]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.604]                   envs[common]]
[13:33:37.604]                 NAMES <- toupper(changed)
[13:33:37.604]                 args <- list()
[13:33:37.604]                 for (kk in seq_along(NAMES)) {
[13:33:37.604]                   name <- changed[[kk]]
[13:33:37.604]                   NAME <- NAMES[[kk]]
[13:33:37.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.604]                     next
[13:33:37.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.604]                 }
[13:33:37.604]                 NAMES <- toupper(added)
[13:33:37.604]                 for (kk in seq_along(NAMES)) {
[13:33:37.604]                   name <- added[[kk]]
[13:33:37.604]                   NAME <- NAMES[[kk]]
[13:33:37.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.604]                     next
[13:33:37.604]                   args[[name]] <- ""
[13:33:37.604]                 }
[13:33:37.604]                 NAMES <- toupper(removed)
[13:33:37.604]                 for (kk in seq_along(NAMES)) {
[13:33:37.604]                   name <- removed[[kk]]
[13:33:37.604]                   NAME <- NAMES[[kk]]
[13:33:37.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.604]                     next
[13:33:37.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.604]                 }
[13:33:37.604]                 if (length(args) > 0) 
[13:33:37.604]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.604]             }
[13:33:37.604]             else {
[13:33:37.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.604]             }
[13:33:37.604]             {
[13:33:37.604]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.604]                   0L) {
[13:33:37.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.604]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.604]                   base::options(opts)
[13:33:37.604]                 }
[13:33:37.604]                 {
[13:33:37.604]                   {
[13:33:37.604]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.604]                     NULL
[13:33:37.604]                   }
[13:33:37.604]                   options(future.plan = NULL)
[13:33:37.604]                   if (is.na(NA_character_)) 
[13:33:37.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.604]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.604]                     .init = FALSE)
[13:33:37.604]                 }
[13:33:37.604]             }
[13:33:37.604]         }
[13:33:37.604]     })
[13:33:37.604]     if (TRUE) {
[13:33:37.604]         base::sink(type = "output", split = FALSE)
[13:33:37.604]         if (TRUE) {
[13:33:37.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.604]         }
[13:33:37.604]         else {
[13:33:37.604]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.604]         }
[13:33:37.604]         base::close(...future.stdout)
[13:33:37.604]         ...future.stdout <- NULL
[13:33:37.604]     }
[13:33:37.604]     ...future.result$conditions <- ...future.conditions
[13:33:37.604]     ...future.result$finished <- base::Sys.time()
[13:33:37.604]     ...future.result
[13:33:37.604] }
[13:33:37.607] assign_globals() ...
[13:33:37.607] List of 5
[13:33:37.607]  $ future.call.arguments    : list()
[13:33:37.607]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.607]  $ ...future.FUN            :function (x)  
[13:33:37.607]  $ ...future.elements_ii    :List of 1
[13:33:37.607]   ..$ : int [1:2] 1 3
[13:33:37.607]  $ ...future.seeds_ii       : NULL
[13:33:37.607]  $ ...future.globals.maxSize: num Inf
[13:33:37.607]  - attr(*, "resolved")= logi FALSE
[13:33:37.607]  - attr(*, "total_size")= num NA
[13:33:37.607]  - attr(*, "where")=List of 5
[13:33:37.607]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.607]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.607]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.607]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.607]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.607]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.607]  - attr(*, "already-done")= logi TRUE
[13:33:37.611] - copied ‘future.call.arguments’ to environment
[13:33:37.611] - reassign environment for ‘...future.FUN’
[13:33:37.611] - copied ‘...future.FUN’ to environment
[13:33:37.611] - copied ‘...future.elements_ii’ to environment
[13:33:37.612] - copied ‘...future.seeds_ii’ to environment
[13:33:37.612] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.612] assign_globals() ... done
[13:33:37.612] requestCore(): workers = 2
[13:33:37.614] MulticoreFuture started
[13:33:37.614] - Launch lazy future ... done
[13:33:37.614] run() for ‘MulticoreFuture’ ... done
[13:33:37.615] Created future:
[13:33:37.615] plan(): Setting new future strategy stack:
[13:33:37.615] List of future strategies:
[13:33:37.615] 1. sequential:
[13:33:37.615]    - args: function (..., envir = parent.frame())
[13:33:37.615]    - tweaked: FALSE
[13:33:37.615]    - call: NULL
[13:33:37.616] plan(): nbrOfWorkers() = 1
[13:33:37.618] plan(): Setting new future strategy stack:
[13:33:37.618] List of future strategies:
[13:33:37.618] 1. multicore:
[13:33:37.618]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.618]    - tweaked: FALSE
[13:33:37.618]    - call: plan(strategy)
[13:33:37.623] plan(): nbrOfWorkers() = 2
[13:33:37.615] MulticoreFuture:
[13:33:37.615] Label: ‘future_apply-1’
[13:33:37.615] Expression:
[13:33:37.615] {
[13:33:37.615]     do.call(function(...) {
[13:33:37.615]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.615]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.615]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.615]             on.exit(options(oopts), add = TRUE)
[13:33:37.615]         }
[13:33:37.615]         {
[13:33:37.615]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.615]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.615]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.615]             })
[13:33:37.615]         }
[13:33:37.615]     }, args = future.call.arguments)
[13:33:37.615] }
[13:33:37.615] Lazy evaluation: FALSE
[13:33:37.615] Asynchronous evaluation: TRUE
[13:33:37.615] Local evaluation: TRUE
[13:33:37.615] Environment: R_GlobalEnv
[13:33:37.615] Capture standard output: TRUE
[13:33:37.615] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.615] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.615] Packages: <none>
[13:33:37.615] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.615] Resolved: TRUE
[13:33:37.615] Value: <not collected>
[13:33:37.615] Conditions captured: <none>
[13:33:37.615] Early signaling: FALSE
[13:33:37.615] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.615] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.624] Chunk #1 of 2 ... DONE
[13:33:37.624] Chunk #2 of 2 ...
[13:33:37.625]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.625]  - seeds: <none>
[13:33:37.625]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.625] getGlobalsAndPackages() ...
[13:33:37.625] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.625] Resolving globals: FALSE
[13:33:37.626] Tweak future expression to call with '...' arguments ...
[13:33:37.626] {
[13:33:37.626]     do.call(function(...) {
[13:33:37.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.626]             on.exit(options(oopts), add = TRUE)
[13:33:37.626]         }
[13:33:37.626]         {
[13:33:37.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.626]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.626]             })
[13:33:37.626]         }
[13:33:37.626]     }, args = future.call.arguments)
[13:33:37.626] }
[13:33:37.626] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.627] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.627] 
[13:33:37.627] getGlobalsAndPackages() ... DONE
[13:33:37.627] run() for ‘Future’ ...
[13:33:37.628] - state: ‘created’
[13:33:37.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.637] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.638]   - Field: ‘label’
[13:33:37.638]   - Field: ‘local’
[13:33:37.638]   - Field: ‘owner’
[13:33:37.639]   - Field: ‘envir’
[13:33:37.639]   - Field: ‘workers’
[13:33:37.639]   - Field: ‘packages’
[13:33:37.639]   - Field: ‘gc’
[13:33:37.640]   - Field: ‘job’
[13:33:37.640]   - Field: ‘conditions’
[13:33:37.640]   - Field: ‘expr’
[13:33:37.640]   - Field: ‘uuid’
[13:33:37.640]   - Field: ‘seed’
[13:33:37.641]   - Field: ‘version’
[13:33:37.641]   - Field: ‘result’
[13:33:37.641]   - Field: ‘asynchronous’
[13:33:37.641]   - Field: ‘calls’
[13:33:37.642]   - Field: ‘globals’
[13:33:37.642]   - Field: ‘stdout’
[13:33:37.642]   - Field: ‘earlySignal’
[13:33:37.642]   - Field: ‘lazy’
[13:33:37.642]   - Field: ‘state’
[13:33:37.642] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.642] - Launch lazy future ...
[13:33:37.643] Packages needed by the future expression (n = 0): <none>
[13:33:37.643] Packages needed by future strategies (n = 0): <none>
[13:33:37.644] {
[13:33:37.644]     {
[13:33:37.644]         {
[13:33:37.644]             ...future.startTime <- base::Sys.time()
[13:33:37.644]             {
[13:33:37.644]                 {
[13:33:37.644]                   {
[13:33:37.644]                     {
[13:33:37.644]                       base::local({
[13:33:37.644]                         has_future <- base::requireNamespace("future", 
[13:33:37.644]                           quietly = TRUE)
[13:33:37.644]                         if (has_future) {
[13:33:37.644]                           ns <- base::getNamespace("future")
[13:33:37.644]                           version <- ns[[".package"]][["version"]]
[13:33:37.644]                           if (is.null(version)) 
[13:33:37.644]                             version <- utils::packageVersion("future")
[13:33:37.644]                         }
[13:33:37.644]                         else {
[13:33:37.644]                           version <- NULL
[13:33:37.644]                         }
[13:33:37.644]                         if (!has_future || version < "1.8.0") {
[13:33:37.644]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.644]                             "", base::R.version$version.string), 
[13:33:37.644]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.644]                               "release", "version")], collapse = " "), 
[13:33:37.644]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.644]                             info)
[13:33:37.644]                           info <- base::paste(info, collapse = "; ")
[13:33:37.644]                           if (!has_future) {
[13:33:37.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.644]                               info)
[13:33:37.644]                           }
[13:33:37.644]                           else {
[13:33:37.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.644]                               info, version)
[13:33:37.644]                           }
[13:33:37.644]                           base::stop(msg)
[13:33:37.644]                         }
[13:33:37.644]                       })
[13:33:37.644]                     }
[13:33:37.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.644]                     base::options(mc.cores = 1L)
[13:33:37.644]                   }
[13:33:37.644]                   ...future.strategy.old <- future::plan("list")
[13:33:37.644]                   options(future.plan = NULL)
[13:33:37.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.644]                 }
[13:33:37.644]                 ...future.workdir <- getwd()
[13:33:37.644]             }
[13:33:37.644]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.644]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.644]         }
[13:33:37.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.644]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.644]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.644]             base::names(...future.oldOptions))
[13:33:37.644]     }
[13:33:37.644]     if (FALSE) {
[13:33:37.644]     }
[13:33:37.644]     else {
[13:33:37.644]         if (TRUE) {
[13:33:37.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.644]                 open = "w")
[13:33:37.644]         }
[13:33:37.644]         else {
[13:33:37.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.644]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.644]         }
[13:33:37.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.644]             base::sink(type = "output", split = FALSE)
[13:33:37.644]             base::close(...future.stdout)
[13:33:37.644]         }, add = TRUE)
[13:33:37.644]     }
[13:33:37.644]     ...future.frame <- base::sys.nframe()
[13:33:37.644]     ...future.conditions <- base::list()
[13:33:37.644]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.644]     if (FALSE) {
[13:33:37.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.644]     }
[13:33:37.644]     ...future.result <- base::tryCatch({
[13:33:37.644]         base::withCallingHandlers({
[13:33:37.644]             ...future.value <- base::withVisible(base::local({
[13:33:37.644]                 withCallingHandlers({
[13:33:37.644]                   {
[13:33:37.644]                     do.call(function(...) {
[13:33:37.644]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.644]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.644]                         ...future.globals.maxSize)) {
[13:33:37.644]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.644]                         on.exit(options(oopts), add = TRUE)
[13:33:37.644]                       }
[13:33:37.644]                       {
[13:33:37.644]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.644]                           FUN = function(jj) {
[13:33:37.644]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.644]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.644]                           })
[13:33:37.644]                       }
[13:33:37.644]                     }, args = future.call.arguments)
[13:33:37.644]                   }
[13:33:37.644]                 }, immediateCondition = function(cond) {
[13:33:37.644]                   save_rds <- function (object, pathname, ...) 
[13:33:37.644]                   {
[13:33:37.644]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.644]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.644]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.644]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.644]                         fi_tmp[["mtime"]])
[13:33:37.644]                     }
[13:33:37.644]                     tryCatch({
[13:33:37.644]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.644]                     }, error = function(ex) {
[13:33:37.644]                       msg <- conditionMessage(ex)
[13:33:37.644]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.644]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.644]                         fi_tmp[["mtime"]], msg)
[13:33:37.644]                       ex$message <- msg
[13:33:37.644]                       stop(ex)
[13:33:37.644]                     })
[13:33:37.644]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.644]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.644]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.644]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.644]                       fi <- file.info(pathname)
[13:33:37.644]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.644]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.644]                         fi[["size"]], fi[["mtime"]])
[13:33:37.644]                       stop(msg)
[13:33:37.644]                     }
[13:33:37.644]                     invisible(pathname)
[13:33:37.644]                   }
[13:33:37.644]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.644]                     rootPath = tempdir()) 
[13:33:37.644]                   {
[13:33:37.644]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.644]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.644]                       tmpdir = path, fileext = ".rds")
[13:33:37.644]                     save_rds(obj, file)
[13:33:37.644]                   }
[13:33:37.644]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.644]                   {
[13:33:37.644]                     inherits <- base::inherits
[13:33:37.644]                     invokeRestart <- base::invokeRestart
[13:33:37.644]                     is.null <- base::is.null
[13:33:37.644]                     muffled <- FALSE
[13:33:37.644]                     if (inherits(cond, "message")) {
[13:33:37.644]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.644]                       if (muffled) 
[13:33:37.644]                         invokeRestart("muffleMessage")
[13:33:37.644]                     }
[13:33:37.644]                     else if (inherits(cond, "warning")) {
[13:33:37.644]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.644]                       if (muffled) 
[13:33:37.644]                         invokeRestart("muffleWarning")
[13:33:37.644]                     }
[13:33:37.644]                     else if (inherits(cond, "condition")) {
[13:33:37.644]                       if (!is.null(pattern)) {
[13:33:37.644]                         computeRestarts <- base::computeRestarts
[13:33:37.644]                         grepl <- base::grepl
[13:33:37.644]                         restarts <- computeRestarts(cond)
[13:33:37.644]                         for (restart in restarts) {
[13:33:37.644]                           name <- restart$name
[13:33:37.644]                           if (is.null(name)) 
[13:33:37.644]                             next
[13:33:37.644]                           if (!grepl(pattern, name)) 
[13:33:37.644]                             next
[13:33:37.644]                           invokeRestart(restart)
[13:33:37.644]                           muffled <- TRUE
[13:33:37.644]                           break
[13:33:37.644]                         }
[13:33:37.644]                       }
[13:33:37.644]                     }
[13:33:37.644]                     invisible(muffled)
[13:33:37.644]                   }
[13:33:37.644]                   muffleCondition(cond)
[13:33:37.644]                 })
[13:33:37.644]             }))
[13:33:37.644]             future::FutureResult(value = ...future.value$value, 
[13:33:37.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.644]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.644]                     ...future.globalenv.names))
[13:33:37.644]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.644]         }, condition = base::local({
[13:33:37.644]             c <- base::c
[13:33:37.644]             inherits <- base::inherits
[13:33:37.644]             invokeRestart <- base::invokeRestart
[13:33:37.644]             length <- base::length
[13:33:37.644]             list <- base::list
[13:33:37.644]             seq.int <- base::seq.int
[13:33:37.644]             signalCondition <- base::signalCondition
[13:33:37.644]             sys.calls <- base::sys.calls
[13:33:37.644]             `[[` <- base::`[[`
[13:33:37.644]             `+` <- base::`+`
[13:33:37.644]             `<<-` <- base::`<<-`
[13:33:37.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.644]                   3L)]
[13:33:37.644]             }
[13:33:37.644]             function(cond) {
[13:33:37.644]                 is_error <- inherits(cond, "error")
[13:33:37.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.644]                   NULL)
[13:33:37.644]                 if (is_error) {
[13:33:37.644]                   sessionInformation <- function() {
[13:33:37.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.644]                       search = base::search(), system = base::Sys.info())
[13:33:37.644]                   }
[13:33:37.644]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.644]                     cond$call), session = sessionInformation(), 
[13:33:37.644]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.644]                   signalCondition(cond)
[13:33:37.644]                 }
[13:33:37.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:37.644]                 "immediateCondition"))) {
[13:33:37.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.644]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.644]                   if (TRUE && !signal) {
[13:33:37.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.644]                     {
[13:33:37.644]                       inherits <- base::inherits
[13:33:37.644]                       invokeRestart <- base::invokeRestart
[13:33:37.644]                       is.null <- base::is.null
[13:33:37.644]                       muffled <- FALSE
[13:33:37.644]                       if (inherits(cond, "message")) {
[13:33:37.644]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.644]                         if (muffled) 
[13:33:37.644]                           invokeRestart("muffleMessage")
[13:33:37.644]                       }
[13:33:37.644]                       else if (inherits(cond, "warning")) {
[13:33:37.644]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.644]                         if (muffled) 
[13:33:37.644]                           invokeRestart("muffleWarning")
[13:33:37.644]                       }
[13:33:37.644]                       else if (inherits(cond, "condition")) {
[13:33:37.644]                         if (!is.null(pattern)) {
[13:33:37.644]                           computeRestarts <- base::computeRestarts
[13:33:37.644]                           grepl <- base::grepl
[13:33:37.644]                           restarts <- computeRestarts(cond)
[13:33:37.644]                           for (restart in restarts) {
[13:33:37.644]                             name <- restart$name
[13:33:37.644]                             if (is.null(name)) 
[13:33:37.644]                               next
[13:33:37.644]                             if (!grepl(pattern, name)) 
[13:33:37.644]                               next
[13:33:37.644]                             invokeRestart(restart)
[13:33:37.644]                             muffled <- TRUE
[13:33:37.644]                             break
[13:33:37.644]                           }
[13:33:37.644]                         }
[13:33:37.644]                       }
[13:33:37.644]                       invisible(muffled)
[13:33:37.644]                     }
[13:33:37.644]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.644]                   }
[13:33:37.644]                 }
[13:33:37.644]                 else {
[13:33:37.644]                   if (TRUE) {
[13:33:37.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.644]                     {
[13:33:37.644]                       inherits <- base::inherits
[13:33:37.644]                       invokeRestart <- base::invokeRestart
[13:33:37.644]                       is.null <- base::is.null
[13:33:37.644]                       muffled <- FALSE
[13:33:37.644]                       if (inherits(cond, "message")) {
[13:33:37.644]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.644]                         if (muffled) 
[13:33:37.644]                           invokeRestart("muffleMessage")
[13:33:37.644]                       }
[13:33:37.644]                       else if (inherits(cond, "warning")) {
[13:33:37.644]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.644]                         if (muffled) 
[13:33:37.644]                           invokeRestart("muffleWarning")
[13:33:37.644]                       }
[13:33:37.644]                       else if (inherits(cond, "condition")) {
[13:33:37.644]                         if (!is.null(pattern)) {
[13:33:37.644]                           computeRestarts <- base::computeRestarts
[13:33:37.644]                           grepl <- base::grepl
[13:33:37.644]                           restarts <- computeRestarts(cond)
[13:33:37.644]                           for (restart in restarts) {
[13:33:37.644]                             name <- restart$name
[13:33:37.644]                             if (is.null(name)) 
[13:33:37.644]                               next
[13:33:37.644]                             if (!grepl(pattern, name)) 
[13:33:37.644]                               next
[13:33:37.644]                             invokeRestart(restart)
[13:33:37.644]                             muffled <- TRUE
[13:33:37.644]                             break
[13:33:37.644]                           }
[13:33:37.644]                         }
[13:33:37.644]                       }
[13:33:37.644]                       invisible(muffled)
[13:33:37.644]                     }
[13:33:37.644]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.644]                   }
[13:33:37.644]                 }
[13:33:37.644]             }
[13:33:37.644]         }))
[13:33:37.644]     }, error = function(ex) {
[13:33:37.644]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.644]                 ...future.rng), started = ...future.startTime, 
[13:33:37.644]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.644]             version = "1.8"), class = "FutureResult")
[13:33:37.644]     }, finally = {
[13:33:37.644]         if (!identical(...future.workdir, getwd())) 
[13:33:37.644]             setwd(...future.workdir)
[13:33:37.644]         {
[13:33:37.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.644]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.644]             }
[13:33:37.644]             base::options(...future.oldOptions)
[13:33:37.644]             if (.Platform$OS.type == "windows") {
[13:33:37.644]                 old_names <- names(...future.oldEnvVars)
[13:33:37.644]                 envs <- base::Sys.getenv()
[13:33:37.644]                 names <- names(envs)
[13:33:37.644]                 common <- intersect(names, old_names)
[13:33:37.644]                 added <- setdiff(names, old_names)
[13:33:37.644]                 removed <- setdiff(old_names, names)
[13:33:37.644]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.644]                   envs[common]]
[13:33:37.644]                 NAMES <- toupper(changed)
[13:33:37.644]                 args <- list()
[13:33:37.644]                 for (kk in seq_along(NAMES)) {
[13:33:37.644]                   name <- changed[[kk]]
[13:33:37.644]                   NAME <- NAMES[[kk]]
[13:33:37.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.644]                     next
[13:33:37.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.644]                 }
[13:33:37.644]                 NAMES <- toupper(added)
[13:33:37.644]                 for (kk in seq_along(NAMES)) {
[13:33:37.644]                   name <- added[[kk]]
[13:33:37.644]                   NAME <- NAMES[[kk]]
[13:33:37.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.644]                     next
[13:33:37.644]                   args[[name]] <- ""
[13:33:37.644]                 }
[13:33:37.644]                 NAMES <- toupper(removed)
[13:33:37.644]                 for (kk in seq_along(NAMES)) {
[13:33:37.644]                   name <- removed[[kk]]
[13:33:37.644]                   NAME <- NAMES[[kk]]
[13:33:37.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.644]                     next
[13:33:37.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.644]                 }
[13:33:37.644]                 if (length(args) > 0) 
[13:33:37.644]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.644]             }
[13:33:37.644]             else {
[13:33:37.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.644]             }
[13:33:37.644]             {
[13:33:37.644]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.644]                   0L) {
[13:33:37.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.644]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.644]                   base::options(opts)
[13:33:37.644]                 }
[13:33:37.644]                 {
[13:33:37.644]                   {
[13:33:37.644]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.644]                     NULL
[13:33:37.644]                   }
[13:33:37.644]                   options(future.plan = NULL)
[13:33:37.644]                   if (is.na(NA_character_)) 
[13:33:37.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.644]                     .init = FALSE)
[13:33:37.644]                 }
[13:33:37.644]             }
[13:33:37.644]         }
[13:33:37.644]     })
[13:33:37.644]     if (TRUE) {
[13:33:37.644]         base::sink(type = "output", split = FALSE)
[13:33:37.644]         if (TRUE) {
[13:33:37.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.644]         }
[13:33:37.644]         else {
[13:33:37.644]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.644]         }
[13:33:37.644]         base::close(...future.stdout)
[13:33:37.644]         ...future.stdout <- NULL
[13:33:37.644]     }
[13:33:37.644]     ...future.result$conditions <- ...future.conditions
[13:33:37.644]     ...future.result$finished <- base::Sys.time()
[13:33:37.644]     ...future.result
[13:33:37.644] }
[13:33:37.647] assign_globals() ...
[13:33:37.647] List of 5
[13:33:37.647]  $ future.call.arguments    : list()
[13:33:37.647]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.647]  $ ...future.FUN            :function (x)  
[13:33:37.647]  $ ...future.elements_ii    :List of 1
[13:33:37.647]   ..$ : int [1:2] 2 4
[13:33:37.647]  $ ...future.seeds_ii       : NULL
[13:33:37.647]  $ ...future.globals.maxSize: num Inf
[13:33:37.647]  - attr(*, "resolved")= logi FALSE
[13:33:37.647]  - attr(*, "total_size")= num NA
[13:33:37.647]  - attr(*, "where")=List of 5
[13:33:37.647]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.647]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.647]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.647]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.647]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.647]  - attr(*, "already-done")= logi TRUE
[13:33:37.653] - copied ‘future.call.arguments’ to environment
[13:33:37.654] - reassign environment for ‘...future.FUN’
[13:33:37.654] - copied ‘...future.FUN’ to environment
[13:33:37.654] - copied ‘...future.elements_ii’ to environment
[13:33:37.654] - copied ‘...future.seeds_ii’ to environment
[13:33:37.654] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.654] assign_globals() ... done
[13:33:37.654] requestCore(): workers = 2
[13:33:37.656] MulticoreFuture started
[13:33:37.657] - Launch lazy future ... done
[13:33:37.657] run() for ‘MulticoreFuture’ ... done
[13:33:37.657] Created future:
[13:33:37.658] plan(): Setting new future strategy stack:
[13:33:37.658] List of future strategies:
[13:33:37.658] 1. sequential:
[13:33:37.658]    - args: function (..., envir = parent.frame())
[13:33:37.658]    - tweaked: FALSE
[13:33:37.658]    - call: NULL
[13:33:37.659] plan(): nbrOfWorkers() = 1
[13:33:37.661] plan(): Setting new future strategy stack:
[13:33:37.661] List of future strategies:
[13:33:37.661] 1. multicore:
[13:33:37.661]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.661]    - tweaked: FALSE
[13:33:37.661]    - call: plan(strategy)
[13:33:37.666] plan(): nbrOfWorkers() = 2
[13:33:37.657] MulticoreFuture:
[13:33:37.657] Label: ‘future_apply-2’
[13:33:37.657] Expression:
[13:33:37.657] {
[13:33:37.657]     do.call(function(...) {
[13:33:37.657]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.657]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.657]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.657]             on.exit(options(oopts), add = TRUE)
[13:33:37.657]         }
[13:33:37.657]         {
[13:33:37.657]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.657]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.657]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.657]             })
[13:33:37.657]         }
[13:33:37.657]     }, args = future.call.arguments)
[13:33:37.657] }
[13:33:37.657] Lazy evaluation: FALSE
[13:33:37.657] Asynchronous evaluation: TRUE
[13:33:37.657] Local evaluation: TRUE
[13:33:37.657] Environment: R_GlobalEnv
[13:33:37.657] Capture standard output: TRUE
[13:33:37.657] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:37.657] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.657] Packages: <none>
[13:33:37.657] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:37.657] Resolved: TRUE
[13:33:37.657] Value: <not collected>
[13:33:37.657] Conditions captured: <none>
[13:33:37.657] Early signaling: FALSE
[13:33:37.657] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.657] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.667] Chunk #2 of 2 ... DONE
[13:33:37.667] Launching 2 futures (chunks) ... DONE
[13:33:37.667] Resolving 2 futures (chunks) ...
[13:33:37.668] resolve() on list ...
[13:33:37.668]  recursive: 0
[13:33:37.668]  length: 2
[13:33:37.668] 
[13:33:37.668] Future #1
[13:33:37.668] result() for MulticoreFuture ...
[13:33:37.669] result() for MulticoreFuture ...
[13:33:37.670] result() for MulticoreFuture ... done
[13:33:37.670] result() for MulticoreFuture ... done
[13:33:37.670] result() for MulticoreFuture ...
[13:33:37.670] result() for MulticoreFuture ... done
[13:33:37.670] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:37.670] - nx: 2
[13:33:37.671] - relay: TRUE
[13:33:37.671] - stdout: TRUE
[13:33:37.671] - signal: TRUE
[13:33:37.671] - resignal: FALSE
[13:33:37.671] - force: TRUE
[13:33:37.671] - relayed: [n=2] FALSE, FALSE
[13:33:37.671] - queued futures: [n=2] FALSE, FALSE
[13:33:37.671]  - until=1
[13:33:37.672]  - relaying element #1
[13:33:37.672] result() for MulticoreFuture ...
[13:33:37.672] result() for MulticoreFuture ... done
[13:33:37.672] result() for MulticoreFuture ...
[13:33:37.672] result() for MulticoreFuture ... done
[13:33:37.672] result() for MulticoreFuture ...
[13:33:37.672] result() for MulticoreFuture ... done
[13:33:37.673] result() for MulticoreFuture ...
[13:33:37.673] result() for MulticoreFuture ... done
[13:33:37.673] - relayed: [n=2] TRUE, FALSE
[13:33:37.673] - queued futures: [n=2] TRUE, FALSE
[13:33:37.673] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:37.673]  length: 1 (resolved future 1)
[13:33:37.674] Future #2
[13:33:37.674] result() for MulticoreFuture ...
[13:33:37.675] result() for MulticoreFuture ...
[13:33:37.675] result() for MulticoreFuture ... done
[13:33:37.675] result() for MulticoreFuture ... done
[13:33:37.675] result() for MulticoreFuture ...
[13:33:37.675] result() for MulticoreFuture ... done
[13:33:37.675] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:37.676] - nx: 2
[13:33:37.676] - relay: TRUE
[13:33:37.676] - stdout: TRUE
[13:33:37.676] - signal: TRUE
[13:33:37.676] - resignal: FALSE
[13:33:37.676] - force: TRUE
[13:33:37.676] - relayed: [n=2] TRUE, FALSE
[13:33:37.676] - queued futures: [n=2] TRUE, FALSE
[13:33:37.676]  - until=2
[13:33:37.677]  - relaying element #2
[13:33:37.677] result() for MulticoreFuture ...
[13:33:37.679] result() for MulticoreFuture ... done
[13:33:37.680] result() for MulticoreFuture ...
[13:33:37.680] result() for MulticoreFuture ... done
[13:33:37.680] result() for MulticoreFuture ...
[13:33:37.680] result() for MulticoreFuture ... done
[13:33:37.680] result() for MulticoreFuture ...
[13:33:37.680] result() for MulticoreFuture ... done
[13:33:37.681] - relayed: [n=2] TRUE, TRUE
[13:33:37.681] - queued futures: [n=2] TRUE, TRUE
[13:33:37.681] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:37.681]  length: 0 (resolved future 2)
[13:33:37.681] Relaying remaining futures
[13:33:37.681] signalConditionsASAP(NULL, pos=0) ...
[13:33:37.681] - nx: 2
[13:33:37.682] - relay: TRUE
[13:33:37.682] - stdout: TRUE
[13:33:37.682] - signal: TRUE
[13:33:37.682] - resignal: FALSE
[13:33:37.682] - force: TRUE
[13:33:37.682] - relayed: [n=2] TRUE, TRUE
[13:33:37.683] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:37.683] - relayed: [n=2] TRUE, TRUE
[13:33:37.683] - queued futures: [n=2] TRUE, TRUE
[13:33:37.683] signalConditionsASAP(NULL, pos=0) ... done
[13:33:37.683] resolve() on list ... DONE
[13:33:37.683] result() for MulticoreFuture ...
[13:33:37.683] result() for MulticoreFuture ... done
[13:33:37.684] result() for MulticoreFuture ...
[13:33:37.684] result() for MulticoreFuture ... done
[13:33:37.684] result() for MulticoreFuture ...
[13:33:37.684] result() for MulticoreFuture ... done
[13:33:37.684] result() for MulticoreFuture ...
[13:33:37.684] result() for MulticoreFuture ... done
[13:33:37.684]  - Number of value chunks collected: 2
[13:33:37.684] Resolving 2 futures (chunks) ... DONE
[13:33:37.685] Reducing values from 2 chunks ...
[13:33:37.685]  - Number of values collected after concatenation: 2
[13:33:37.685]  - Number of values expected: 2
[13:33:37.685] Reducing values from 2 chunks ... DONE
[13:33:37.685] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[13:33:37.685] getGlobalsAndPackagesXApply() ...
[13:33:37.686]  - future.globals: TRUE
[13:33:37.686] getGlobalsAndPackages() ...
[13:33:37.686] Searching for globals...
[13:33:37.690] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[13:33:37.690] Searching for globals ... DONE
[13:33:37.690] Resolving globals: FALSE
[13:33:37.691] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[13:33:37.691] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[13:33:37.691] - globals: [1] ‘FUN’
[13:33:37.691] 
[13:33:37.691] getGlobalsAndPackages() ... DONE
[13:33:37.691]  - globals found/used: [n=1] ‘FUN’
[13:33:37.692]  - needed namespaces: [n=0] 
[13:33:37.692] Finding globals ... DONE
[13:33:37.692]  - use_args: TRUE
[13:33:37.692]  - Getting '...' globals ...
[13:33:37.692] resolve() on list ...
[13:33:37.692]  recursive: 0
[13:33:37.692]  length: 1
[13:33:37.692]  elements: ‘...’
[13:33:37.693]  length: 0 (resolved future 1)
[13:33:37.693] resolve() on list ... DONE
[13:33:37.693]    - '...' content: [n=0] 
[13:33:37.693] List of 1
[13:33:37.693]  $ ...: list()
[13:33:37.693]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.693]  - attr(*, "where")=List of 1
[13:33:37.693]   ..$ ...:<environment: 0x55b948d0b730> 
[13:33:37.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.693]  - attr(*, "resolved")= logi TRUE
[13:33:37.693]  - attr(*, "total_size")= num NA
[13:33:37.695]  - Getting '...' globals ... DONE
[13:33:37.696] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:37.696] List of 2
[13:33:37.696]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:33:37.696]  $ ...          : list()
[13:33:37.696]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.696]  - attr(*, "where")=List of 2
[13:33:37.696]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:37.696]   ..$ ...          :<environment: 0x55b948d0b730> 
[13:33:37.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.696]  - attr(*, "resolved")= logi FALSE
[13:33:37.696]  - attr(*, "total_size")= num 36296
[13:33:37.698] Packages to be attached in all futures: [n=0] 
[13:33:37.698] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.702] future_lapply() ...
[13:33:37.707] Generating random seeds ...
[13:33:37.707] Generating random seed streams for 2 elements ...
[13:33:37.707] Generating random seed streams for 2 elements ... DONE
[13:33:37.707] Generating random seeds ... DONE
[13:33:37.707] Will set RNG state on exit: 10407, 429179484, -497706903, -688074440, -16683833, 28753199, -2028330292
[13:33:37.711] Number of chunks: 2
[13:33:37.711] getGlobalsAndPackagesXApply() ...
[13:33:37.711]  - future.globals: <name-value list> with names ‘list()’
[13:33:37.712]  - use_args: TRUE
[13:33:37.712] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:37.712] List of 2
[13:33:37.712]  $ ...          : list()
[13:33:37.712]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.712]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:33:37.712]  - attr(*, "where")=List of 2
[13:33:37.712]   ..$ ...          :<environment: 0x55b948d0b730> 
[13:33:37.712]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:37.712]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.712]  - attr(*, "resolved")= logi FALSE
[13:33:37.712]  - attr(*, "total_size")= num NA
[13:33:37.715] Packages to be attached in all futures: [n=0] 
[13:33:37.715] getGlobalsAndPackagesXApply() ... DONE
[13:33:37.715] Number of futures (= number of chunks): 2
[13:33:37.716] Launching 2 futures (chunks) ...
[13:33:37.716] Chunk #1 of 2 ...
[13:33:37.716]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.716]  - seeds: [1] <seeds>
[13:33:37.716]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.716] getGlobalsAndPackages() ...
[13:33:37.716] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.716] Resolving globals: FALSE
[13:33:37.716] Tweak future expression to call with '...' arguments ...
[13:33:37.717] {
[13:33:37.717]     do.call(function(...) {
[13:33:37.717]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.717]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.717]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.717]             on.exit(options(oopts), add = TRUE)
[13:33:37.717]         }
[13:33:37.717]         {
[13:33:37.717]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.717]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.717]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:37.717]                   envir = globalenv(), inherits = FALSE)
[13:33:37.717]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.717]             })
[13:33:37.717]         }
[13:33:37.717]     }, args = future.call.arguments)
[13:33:37.717] }
[13:33:37.717] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.717] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.717] 
[13:33:37.717] getGlobalsAndPackages() ... DONE
[13:33:37.718] run() for ‘Future’ ...
[13:33:37.718] - state: ‘created’
[13:33:37.718] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.721] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.722]   - Field: ‘label’
[13:33:37.722]   - Field: ‘local’
[13:33:37.722]   - Field: ‘owner’
[13:33:37.722]   - Field: ‘envir’
[13:33:37.722]   - Field: ‘workers’
[13:33:37.722]   - Field: ‘packages’
[13:33:37.722]   - Field: ‘gc’
[13:33:37.722]   - Field: ‘job’
[13:33:37.722]   - Field: ‘conditions’
[13:33:37.723]   - Field: ‘expr’
[13:33:37.723]   - Field: ‘uuid’
[13:33:37.723]   - Field: ‘seed’
[13:33:37.723]   - Field: ‘version’
[13:33:37.723]   - Field: ‘result’
[13:33:37.723]   - Field: ‘asynchronous’
[13:33:37.723]   - Field: ‘calls’
[13:33:37.723]   - Field: ‘globals’
[13:33:37.723]   - Field: ‘stdout’
[13:33:37.723]   - Field: ‘earlySignal’
[13:33:37.723]   - Field: ‘lazy’
[13:33:37.723]   - Field: ‘state’
[13:33:37.724] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.724] - Launch lazy future ...
[13:33:37.724] Packages needed by the future expression (n = 0): <none>
[13:33:37.724] Packages needed by future strategies (n = 0): <none>
[13:33:37.724] {
[13:33:37.724]     {
[13:33:37.724]         {
[13:33:37.724]             ...future.startTime <- base::Sys.time()
[13:33:37.724]             {
[13:33:37.724]                 {
[13:33:37.724]                   {
[13:33:37.724]                     {
[13:33:37.724]                       base::local({
[13:33:37.724]                         has_future <- base::requireNamespace("future", 
[13:33:37.724]                           quietly = TRUE)
[13:33:37.724]                         if (has_future) {
[13:33:37.724]                           ns <- base::getNamespace("future")
[13:33:37.724]                           version <- ns[[".package"]][["version"]]
[13:33:37.724]                           if (is.null(version)) 
[13:33:37.724]                             version <- utils::packageVersion("future")
[13:33:37.724]                         }
[13:33:37.724]                         else {
[13:33:37.724]                           version <- NULL
[13:33:37.724]                         }
[13:33:37.724]                         if (!has_future || version < "1.8.0") {
[13:33:37.724]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.724]                             "", base::R.version$version.string), 
[13:33:37.724]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.724]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.724]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.724]                               "release", "version")], collapse = " "), 
[13:33:37.724]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.724]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.724]                             info)
[13:33:37.724]                           info <- base::paste(info, collapse = "; ")
[13:33:37.724]                           if (!has_future) {
[13:33:37.724]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.724]                               info)
[13:33:37.724]                           }
[13:33:37.724]                           else {
[13:33:37.724]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.724]                               info, version)
[13:33:37.724]                           }
[13:33:37.724]                           base::stop(msg)
[13:33:37.724]                         }
[13:33:37.724]                       })
[13:33:37.724]                     }
[13:33:37.724]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.724]                     base::options(mc.cores = 1L)
[13:33:37.724]                   }
[13:33:37.724]                   ...future.strategy.old <- future::plan("list")
[13:33:37.724]                   options(future.plan = NULL)
[13:33:37.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.724]                 }
[13:33:37.724]                 ...future.workdir <- getwd()
[13:33:37.724]             }
[13:33:37.724]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.724]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.724]         }
[13:33:37.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.724]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.724]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.724]             base::names(...future.oldOptions))
[13:33:37.724]     }
[13:33:37.724]     if (FALSE) {
[13:33:37.724]     }
[13:33:37.724]     else {
[13:33:37.724]         if (TRUE) {
[13:33:37.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.724]                 open = "w")
[13:33:37.724]         }
[13:33:37.724]         else {
[13:33:37.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.724]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.724]         }
[13:33:37.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.724]             base::sink(type = "output", split = FALSE)
[13:33:37.724]             base::close(...future.stdout)
[13:33:37.724]         }, add = TRUE)
[13:33:37.724]     }
[13:33:37.724]     ...future.frame <- base::sys.nframe()
[13:33:37.724]     ...future.conditions <- base::list()
[13:33:37.724]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.724]     if (FALSE) {
[13:33:37.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.724]     }
[13:33:37.724]     ...future.result <- base::tryCatch({
[13:33:37.724]         base::withCallingHandlers({
[13:33:37.724]             ...future.value <- base::withVisible(base::local({
[13:33:37.724]                 withCallingHandlers({
[13:33:37.724]                   {
[13:33:37.724]                     do.call(function(...) {
[13:33:37.724]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.724]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.724]                         ...future.globals.maxSize)) {
[13:33:37.724]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.724]                         on.exit(options(oopts), add = TRUE)
[13:33:37.724]                       }
[13:33:37.724]                       {
[13:33:37.724]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.724]                           FUN = function(jj) {
[13:33:37.724]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.724]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:37.724]                               envir = globalenv(), inherits = FALSE)
[13:33:37.724]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.724]                           })
[13:33:37.724]                       }
[13:33:37.724]                     }, args = future.call.arguments)
[13:33:37.724]                   }
[13:33:37.724]                 }, immediateCondition = function(cond) {
[13:33:37.724]                   save_rds <- function (object, pathname, ...) 
[13:33:37.724]                   {
[13:33:37.724]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.724]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.724]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.724]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.724]                         fi_tmp[["mtime"]])
[13:33:37.724]                     }
[13:33:37.724]                     tryCatch({
[13:33:37.724]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.724]                     }, error = function(ex) {
[13:33:37.724]                       msg <- conditionMessage(ex)
[13:33:37.724]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.724]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.724]                         fi_tmp[["mtime"]], msg)
[13:33:37.724]                       ex$message <- msg
[13:33:37.724]                       stop(ex)
[13:33:37.724]                     })
[13:33:37.724]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.724]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.724]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.724]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.724]                       fi <- file.info(pathname)
[13:33:37.724]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.724]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.724]                         fi[["size"]], fi[["mtime"]])
[13:33:37.724]                       stop(msg)
[13:33:37.724]                     }
[13:33:37.724]                     invisible(pathname)
[13:33:37.724]                   }
[13:33:37.724]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.724]                     rootPath = tempdir()) 
[13:33:37.724]                   {
[13:33:37.724]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.724]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.724]                       tmpdir = path, fileext = ".rds")
[13:33:37.724]                     save_rds(obj, file)
[13:33:37.724]                   }
[13:33:37.724]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.724]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.724]                   {
[13:33:37.724]                     inherits <- base::inherits
[13:33:37.724]                     invokeRestart <- base::invokeRestart
[13:33:37.724]                     is.null <- base::is.null
[13:33:37.724]                     muffled <- FALSE
[13:33:37.724]                     if (inherits(cond, "message")) {
[13:33:37.724]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.724]                       if (muffled) 
[13:33:37.724]                         invokeRestart("muffleMessage")
[13:33:37.724]                     }
[13:33:37.724]                     else if (inherits(cond, "warning")) {
[13:33:37.724]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.724]                       if (muffled) 
[13:33:37.724]                         invokeRestart("muffleWarning")
[13:33:37.724]                     }
[13:33:37.724]                     else if (inherits(cond, "condition")) {
[13:33:37.724]                       if (!is.null(pattern)) {
[13:33:37.724]                         computeRestarts <- base::computeRestarts
[13:33:37.724]                         grepl <- base::grepl
[13:33:37.724]                         restarts <- computeRestarts(cond)
[13:33:37.724]                         for (restart in restarts) {
[13:33:37.724]                           name <- restart$name
[13:33:37.724]                           if (is.null(name)) 
[13:33:37.724]                             next
[13:33:37.724]                           if (!grepl(pattern, name)) 
[13:33:37.724]                             next
[13:33:37.724]                           invokeRestart(restart)
[13:33:37.724]                           muffled <- TRUE
[13:33:37.724]                           break
[13:33:37.724]                         }
[13:33:37.724]                       }
[13:33:37.724]                     }
[13:33:37.724]                     invisible(muffled)
[13:33:37.724]                   }
[13:33:37.724]                   muffleCondition(cond)
[13:33:37.724]                 })
[13:33:37.724]             }))
[13:33:37.724]             future::FutureResult(value = ...future.value$value, 
[13:33:37.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.724]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.724]                     ...future.globalenv.names))
[13:33:37.724]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.724]         }, condition = base::local({
[13:33:37.724]             c <- base::c
[13:33:37.724]             inherits <- base::inherits
[13:33:37.724]             invokeRestart <- base::invokeRestart
[13:33:37.724]             length <- base::length
[13:33:37.724]             list <- base::list
[13:33:37.724]             seq.int <- base::seq.int
[13:33:37.724]             signalCondition <- base::signalCondition
[13:33:37.724]             sys.calls <- base::sys.calls
[13:33:37.724]             `[[` <- base::`[[`
[13:33:37.724]             `+` <- base::`+`
[13:33:37.724]             `<<-` <- base::`<<-`
[13:33:37.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.724]                   3L)]
[13:33:37.724]             }
[13:33:37.724]             function(cond) {
[13:33:37.724]                 is_error <- inherits(cond, "error")
[13:33:37.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.724]                   NULL)
[13:33:37.724]                 if (is_error) {
[13:33:37.724]                   sessionInformation <- function() {
[13:33:37.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.724]                       search = base::search(), system = base::Sys.info())
[13:33:37.724]                   }
[13:33:37.724]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.724]                     cond$call), session = sessionInformation(), 
[13:33:37.724]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.724]                   signalCondition(cond)
[13:33:37.724]                 }
[13:33:37.724]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:33:37.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.724]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.724]                   if (TRUE && !signal) {
[13:33:37.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.724]                     {
[13:33:37.724]                       inherits <- base::inherits
[13:33:37.724]                       invokeRestart <- base::invokeRestart
[13:33:37.724]                       is.null <- base::is.null
[13:33:37.724]                       muffled <- FALSE
[13:33:37.724]                       if (inherits(cond, "message")) {
[13:33:37.724]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.724]                         if (muffled) 
[13:33:37.724]                           invokeRestart("muffleMessage")
[13:33:37.724]                       }
[13:33:37.724]                       else if (inherits(cond, "warning")) {
[13:33:37.724]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.724]                         if (muffled) 
[13:33:37.724]                           invokeRestart("muffleWarning")
[13:33:37.724]                       }
[13:33:37.724]                       else if (inherits(cond, "condition")) {
[13:33:37.724]                         if (!is.null(pattern)) {
[13:33:37.724]                           computeRestarts <- base::computeRestarts
[13:33:37.724]                           grepl <- base::grepl
[13:33:37.724]                           restarts <- computeRestarts(cond)
[13:33:37.724]                           for (restart in restarts) {
[13:33:37.724]                             name <- restart$name
[13:33:37.724]                             if (is.null(name)) 
[13:33:37.724]                               next
[13:33:37.724]                             if (!grepl(pattern, name)) 
[13:33:37.724]                               next
[13:33:37.724]                             invokeRestart(restart)
[13:33:37.724]                             muffled <- TRUE
[13:33:37.724]                             break
[13:33:37.724]                           }
[13:33:37.724]                         }
[13:33:37.724]                       }
[13:33:37.724]                       invisible(muffled)
[13:33:37.724]                     }
[13:33:37.724]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.724]                   }
[13:33:37.724]                 }
[13:33:37.724]                 else {
[13:33:37.724]                   if (TRUE) {
[13:33:37.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.724]                     {
[13:33:37.724]                       inherits <- base::inherits
[13:33:37.724]                       invokeRestart <- base::invokeRestart
[13:33:37.724]                       is.null <- base::is.null
[13:33:37.724]                       muffled <- FALSE
[13:33:37.724]                       if (inherits(cond, "message")) {
[13:33:37.724]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.724]                         if (muffled) 
[13:33:37.724]                           invokeRestart("muffleMessage")
[13:33:37.724]                       }
[13:33:37.724]                       else if (inherits(cond, "warning")) {
[13:33:37.724]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.724]                         if (muffled) 
[13:33:37.724]                           invokeRestart("muffleWarning")
[13:33:37.724]                       }
[13:33:37.724]                       else if (inherits(cond, "condition")) {
[13:33:37.724]                         if (!is.null(pattern)) {
[13:33:37.724]                           computeRestarts <- base::computeRestarts
[13:33:37.724]                           grepl <- base::grepl
[13:33:37.724]                           restarts <- computeRestarts(cond)
[13:33:37.724]                           for (restart in restarts) {
[13:33:37.724]                             name <- restart$name
[13:33:37.724]                             if (is.null(name)) 
[13:33:37.724]                               next
[13:33:37.724]                             if (!grepl(pattern, name)) 
[13:33:37.724]                               next
[13:33:37.724]                             invokeRestart(restart)
[13:33:37.724]                             muffled <- TRUE
[13:33:37.724]                             break
[13:33:37.724]                           }
[13:33:37.724]                         }
[13:33:37.724]                       }
[13:33:37.724]                       invisible(muffled)
[13:33:37.724]                     }
[13:33:37.724]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.724]                   }
[13:33:37.724]                 }
[13:33:37.724]             }
[13:33:37.724]         }))
[13:33:37.724]     }, error = function(ex) {
[13:33:37.724]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.724]                 ...future.rng), started = ...future.startTime, 
[13:33:37.724]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.724]             version = "1.8"), class = "FutureResult")
[13:33:37.724]     }, finally = {
[13:33:37.724]         if (!identical(...future.workdir, getwd())) 
[13:33:37.724]             setwd(...future.workdir)
[13:33:37.724]         {
[13:33:37.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.724]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.724]             }
[13:33:37.724]             base::options(...future.oldOptions)
[13:33:37.724]             if (.Platform$OS.type == "windows") {
[13:33:37.724]                 old_names <- names(...future.oldEnvVars)
[13:33:37.724]                 envs <- base::Sys.getenv()
[13:33:37.724]                 names <- names(envs)
[13:33:37.724]                 common <- intersect(names, old_names)
[13:33:37.724]                 added <- setdiff(names, old_names)
[13:33:37.724]                 removed <- setdiff(old_names, names)
[13:33:37.724]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.724]                   envs[common]]
[13:33:37.724]                 NAMES <- toupper(changed)
[13:33:37.724]                 args <- list()
[13:33:37.724]                 for (kk in seq_along(NAMES)) {
[13:33:37.724]                   name <- changed[[kk]]
[13:33:37.724]                   NAME <- NAMES[[kk]]
[13:33:37.724]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.724]                     next
[13:33:37.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.724]                 }
[13:33:37.724]                 NAMES <- toupper(added)
[13:33:37.724]                 for (kk in seq_along(NAMES)) {
[13:33:37.724]                   name <- added[[kk]]
[13:33:37.724]                   NAME <- NAMES[[kk]]
[13:33:37.724]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.724]                     next
[13:33:37.724]                   args[[name]] <- ""
[13:33:37.724]                 }
[13:33:37.724]                 NAMES <- toupper(removed)
[13:33:37.724]                 for (kk in seq_along(NAMES)) {
[13:33:37.724]                   name <- removed[[kk]]
[13:33:37.724]                   NAME <- NAMES[[kk]]
[13:33:37.724]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.724]                     next
[13:33:37.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.724]                 }
[13:33:37.724]                 if (length(args) > 0) 
[13:33:37.724]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.724]             }
[13:33:37.724]             else {
[13:33:37.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.724]             }
[13:33:37.724]             {
[13:33:37.724]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.724]                   0L) {
[13:33:37.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.724]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.724]                   base::options(opts)
[13:33:37.724]                 }
[13:33:37.724]                 {
[13:33:37.724]                   {
[13:33:37.724]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.724]                     NULL
[13:33:37.724]                   }
[13:33:37.724]                   options(future.plan = NULL)
[13:33:37.724]                   if (is.na(NA_character_)) 
[13:33:37.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.724]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.724]                     .init = FALSE)
[13:33:37.724]                 }
[13:33:37.724]             }
[13:33:37.724]         }
[13:33:37.724]     })
[13:33:37.724]     if (TRUE) {
[13:33:37.724]         base::sink(type = "output", split = FALSE)
[13:33:37.724]         if (TRUE) {
[13:33:37.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.724]         }
[13:33:37.724]         else {
[13:33:37.724]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.724]         }
[13:33:37.724]         base::close(...future.stdout)
[13:33:37.724]         ...future.stdout <- NULL
[13:33:37.724]     }
[13:33:37.724]     ...future.result$conditions <- ...future.conditions
[13:33:37.724]     ...future.result$finished <- base::Sys.time()
[13:33:37.724]     ...future.result
[13:33:37.724] }
[13:33:37.727] assign_globals() ...
[13:33:37.727] List of 5
[13:33:37.727]  $ future.call.arguments    : list()
[13:33:37.727]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.727]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[13:33:37.727]  $ ...future.elements_ii    :List of 1
[13:33:37.727]   ..$ : int [1:2] 1 3
[13:33:37.727]  $ ...future.seeds_ii       :List of 1
[13:33:37.727]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[13:33:37.727]  $ ...future.globals.maxSize: num Inf
[13:33:37.727]  - attr(*, "resolved")= logi FALSE
[13:33:37.727]  - attr(*, "total_size")= num NA
[13:33:37.727]  - attr(*, "where")=List of 5
[13:33:37.727]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.727]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.727]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.727]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.727]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.727]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.727]  - attr(*, "already-done")= logi TRUE
[13:33:37.733] - copied ‘future.call.arguments’ to environment
[13:33:37.733] - copied ‘...future.FUN’ to environment
[13:33:37.733] - copied ‘...future.elements_ii’ to environment
[13:33:37.733] - copied ‘...future.seeds_ii’ to environment
[13:33:37.733] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.733] assign_globals() ... done
[13:33:37.734] requestCore(): workers = 2
[13:33:37.736] MulticoreFuture started
[13:33:37.736] - Launch lazy future ... done
[13:33:37.737] plan(): Setting new future strategy stack:
[13:33:37.737] run() for ‘MulticoreFuture’ ... done
[13:33:37.738] Created future:
[13:33:37.737] List of future strategies:
[13:33:37.737] 1. sequential:
[13:33:37.737]    - args: function (..., envir = parent.frame())
[13:33:37.737]    - tweaked: FALSE
[13:33:37.737]    - call: NULL
[13:33:37.739] plan(): nbrOfWorkers() = 1
[13:33:37.741] plan(): Setting new future strategy stack:
[13:33:37.742] List of future strategies:
[13:33:37.742] 1. multicore:
[13:33:37.742]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.742]    - tweaked: FALSE
[13:33:37.742]    - call: plan(strategy)
[13:33:37.748] plan(): nbrOfWorkers() = 2
[13:33:37.738] MulticoreFuture:
[13:33:37.738] Label: ‘future_apply-1’
[13:33:37.738] Expression:
[13:33:37.738] {
[13:33:37.738]     do.call(function(...) {
[13:33:37.738]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.738]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.738]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.738]             on.exit(options(oopts), add = TRUE)
[13:33:37.738]         }
[13:33:37.738]         {
[13:33:37.738]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.738]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.738]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:37.738]                   envir = globalenv(), inherits = FALSE)
[13:33:37.738]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.738]             })
[13:33:37.738]         }
[13:33:37.738]     }, args = future.call.arguments)
[13:33:37.738] }
[13:33:37.738] Lazy evaluation: FALSE
[13:33:37.738] Asynchronous evaluation: TRUE
[13:33:37.738] Local evaluation: TRUE
[13:33:37.738] Environment: R_GlobalEnv
[13:33:37.738] Capture standard output: TRUE
[13:33:37.738] Capture condition classes: <none>
[13:33:37.738] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.738] Packages: <none>
[13:33:37.738] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:33:37.738] Resolved: TRUE
[13:33:37.738] Value: <not collected>
[13:33:37.738] Conditions captured: <none>
[13:33:37.738] Early signaling: FALSE
[13:33:37.738] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.738] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.750] Chunk #1 of 2 ... DONE
[13:33:37.750] Chunk #2 of 2 ...
[13:33:37.750]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:37.751]  - seeds: [1] <seeds>
[13:33:37.751]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.751] getGlobalsAndPackages() ...
[13:33:37.751] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.752] Resolving globals: FALSE
[13:33:37.752] Tweak future expression to call with '...' arguments ...
[13:33:37.752] {
[13:33:37.752]     do.call(function(...) {
[13:33:37.752]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.752]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.752]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.752]             on.exit(options(oopts), add = TRUE)
[13:33:37.752]         }
[13:33:37.752]         {
[13:33:37.752]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.752]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.752]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:37.752]                   envir = globalenv(), inherits = FALSE)
[13:33:37.752]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.752]             })
[13:33:37.752]         }
[13:33:37.752]     }, args = future.call.arguments)
[13:33:37.752] }
[13:33:37.753] Tweak future expression to call with '...' arguments ... DONE
[13:33:37.753] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:37.753] 
[13:33:37.754] getGlobalsAndPackages() ... DONE
[13:33:37.754] run() for ‘Future’ ...
[13:33:37.754] - state: ‘created’
[13:33:37.755] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:37.760] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:37.760]   - Field: ‘label’
[13:33:37.760]   - Field: ‘local’
[13:33:37.760]   - Field: ‘owner’
[13:33:37.761]   - Field: ‘envir’
[13:33:37.761]   - Field: ‘workers’
[13:33:37.761]   - Field: ‘packages’
[13:33:37.761]   - Field: ‘gc’
[13:33:37.761]   - Field: ‘job’
[13:33:37.761]   - Field: ‘conditions’
[13:33:37.762]   - Field: ‘expr’
[13:33:37.762]   - Field: ‘uuid’
[13:33:37.762]   - Field: ‘seed’
[13:33:37.762]   - Field: ‘version’
[13:33:37.762]   - Field: ‘result’
[13:33:37.762]   - Field: ‘asynchronous’
[13:33:37.763]   - Field: ‘calls’
[13:33:37.763]   - Field: ‘globals’
[13:33:37.763]   - Field: ‘stdout’
[13:33:37.763]   - Field: ‘earlySignal’
[13:33:37.763]   - Field: ‘lazy’
[13:33:37.763]   - Field: ‘state’
[13:33:37.763] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:37.764] - Launch lazy future ...
[13:33:37.764] Packages needed by the future expression (n = 0): <none>
[13:33:37.764] Packages needed by future strategies (n = 0): <none>
[13:33:37.765] {
[13:33:37.765]     {
[13:33:37.765]         {
[13:33:37.765]             ...future.startTime <- base::Sys.time()
[13:33:37.765]             {
[13:33:37.765]                 {
[13:33:37.765]                   {
[13:33:37.765]                     {
[13:33:37.765]                       base::local({
[13:33:37.765]                         has_future <- base::requireNamespace("future", 
[13:33:37.765]                           quietly = TRUE)
[13:33:37.765]                         if (has_future) {
[13:33:37.765]                           ns <- base::getNamespace("future")
[13:33:37.765]                           version <- ns[[".package"]][["version"]]
[13:33:37.765]                           if (is.null(version)) 
[13:33:37.765]                             version <- utils::packageVersion("future")
[13:33:37.765]                         }
[13:33:37.765]                         else {
[13:33:37.765]                           version <- NULL
[13:33:37.765]                         }
[13:33:37.765]                         if (!has_future || version < "1.8.0") {
[13:33:37.765]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:37.765]                             "", base::R.version$version.string), 
[13:33:37.765]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:37.765]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:37.765]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:37.765]                               "release", "version")], collapse = " "), 
[13:33:37.765]                             hostname = base::Sys.info()[["nodename"]])
[13:33:37.765]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:37.765]                             info)
[13:33:37.765]                           info <- base::paste(info, collapse = "; ")
[13:33:37.765]                           if (!has_future) {
[13:33:37.765]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:37.765]                               info)
[13:33:37.765]                           }
[13:33:37.765]                           else {
[13:33:37.765]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:37.765]                               info, version)
[13:33:37.765]                           }
[13:33:37.765]                           base::stop(msg)
[13:33:37.765]                         }
[13:33:37.765]                       })
[13:33:37.765]                     }
[13:33:37.765]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:37.765]                     base::options(mc.cores = 1L)
[13:33:37.765]                   }
[13:33:37.765]                   ...future.strategy.old <- future::plan("list")
[13:33:37.765]                   options(future.plan = NULL)
[13:33:37.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:37.765]                 }
[13:33:37.765]                 ...future.workdir <- getwd()
[13:33:37.765]             }
[13:33:37.765]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:37.765]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:37.765]         }
[13:33:37.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:37.765]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:37.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:37.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:37.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:37.765]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:37.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:37.765]             base::names(...future.oldOptions))
[13:33:37.765]     }
[13:33:37.765]     if (FALSE) {
[13:33:37.765]     }
[13:33:37.765]     else {
[13:33:37.765]         if (TRUE) {
[13:33:37.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:37.765]                 open = "w")
[13:33:37.765]         }
[13:33:37.765]         else {
[13:33:37.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:37.765]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:37.765]         }
[13:33:37.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:37.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:37.765]             base::sink(type = "output", split = FALSE)
[13:33:37.765]             base::close(...future.stdout)
[13:33:37.765]         }, add = TRUE)
[13:33:37.765]     }
[13:33:37.765]     ...future.frame <- base::sys.nframe()
[13:33:37.765]     ...future.conditions <- base::list()
[13:33:37.765]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:37.765]     if (FALSE) {
[13:33:37.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:37.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:37.765]     }
[13:33:37.765]     ...future.result <- base::tryCatch({
[13:33:37.765]         base::withCallingHandlers({
[13:33:37.765]             ...future.value <- base::withVisible(base::local({
[13:33:37.765]                 withCallingHandlers({
[13:33:37.765]                   {
[13:33:37.765]                     do.call(function(...) {
[13:33:37.765]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.765]                       if (!identical(...future.globals.maxSize.org, 
[13:33:37.765]                         ...future.globals.maxSize)) {
[13:33:37.765]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.765]                         on.exit(options(oopts), add = TRUE)
[13:33:37.765]                       }
[13:33:37.765]                       {
[13:33:37.765]                         lapply(seq_along(...future.elements_ii), 
[13:33:37.765]                           FUN = function(jj) {
[13:33:37.765]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.765]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:37.765]                               envir = globalenv(), inherits = FALSE)
[13:33:37.765]                             ...future.FUN(...future.X_jj, ...)
[13:33:37.765]                           })
[13:33:37.765]                       }
[13:33:37.765]                     }, args = future.call.arguments)
[13:33:37.765]                   }
[13:33:37.765]                 }, immediateCondition = function(cond) {
[13:33:37.765]                   save_rds <- function (object, pathname, ...) 
[13:33:37.765]                   {
[13:33:37.765]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:37.765]                     if (file_test("-f", pathname_tmp)) {
[13:33:37.765]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.765]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:37.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.765]                         fi_tmp[["mtime"]])
[13:33:37.765]                     }
[13:33:37.765]                     tryCatch({
[13:33:37.765]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:37.765]                     }, error = function(ex) {
[13:33:37.765]                       msg <- conditionMessage(ex)
[13:33:37.765]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.765]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:37.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.765]                         fi_tmp[["mtime"]], msg)
[13:33:37.765]                       ex$message <- msg
[13:33:37.765]                       stop(ex)
[13:33:37.765]                     })
[13:33:37.765]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:37.765]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:37.765]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:37.765]                       fi_tmp <- file.info(pathname_tmp)
[13:33:37.765]                       fi <- file.info(pathname)
[13:33:37.765]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:37.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:37.765]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:37.765]                         fi[["size"]], fi[["mtime"]])
[13:33:37.765]                       stop(msg)
[13:33:37.765]                     }
[13:33:37.765]                     invisible(pathname)
[13:33:37.765]                   }
[13:33:37.765]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:37.765]                     rootPath = tempdir()) 
[13:33:37.765]                   {
[13:33:37.765]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:37.765]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:37.765]                       tmpdir = path, fileext = ".rds")
[13:33:37.765]                     save_rds(obj, file)
[13:33:37.765]                   }
[13:33:37.765]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4yxGoc/.future/immediateConditions")
[13:33:37.765]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.765]                   {
[13:33:37.765]                     inherits <- base::inherits
[13:33:37.765]                     invokeRestart <- base::invokeRestart
[13:33:37.765]                     is.null <- base::is.null
[13:33:37.765]                     muffled <- FALSE
[13:33:37.765]                     if (inherits(cond, "message")) {
[13:33:37.765]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:37.765]                       if (muffled) 
[13:33:37.765]                         invokeRestart("muffleMessage")
[13:33:37.765]                     }
[13:33:37.765]                     else if (inherits(cond, "warning")) {
[13:33:37.765]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:37.765]                       if (muffled) 
[13:33:37.765]                         invokeRestart("muffleWarning")
[13:33:37.765]                     }
[13:33:37.765]                     else if (inherits(cond, "condition")) {
[13:33:37.765]                       if (!is.null(pattern)) {
[13:33:37.765]                         computeRestarts <- base::computeRestarts
[13:33:37.765]                         grepl <- base::grepl
[13:33:37.765]                         restarts <- computeRestarts(cond)
[13:33:37.765]                         for (restart in restarts) {
[13:33:37.765]                           name <- restart$name
[13:33:37.765]                           if (is.null(name)) 
[13:33:37.765]                             next
[13:33:37.765]                           if (!grepl(pattern, name)) 
[13:33:37.765]                             next
[13:33:37.765]                           invokeRestart(restart)
[13:33:37.765]                           muffled <- TRUE
[13:33:37.765]                           break
[13:33:37.765]                         }
[13:33:37.765]                       }
[13:33:37.765]                     }
[13:33:37.765]                     invisible(muffled)
[13:33:37.765]                   }
[13:33:37.765]                   muffleCondition(cond)
[13:33:37.765]                 })
[13:33:37.765]             }))
[13:33:37.765]             future::FutureResult(value = ...future.value$value, 
[13:33:37.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.765]                   ...future.rng), globalenv = if (FALSE) 
[13:33:37.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:37.765]                     ...future.globalenv.names))
[13:33:37.765]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:37.765]         }, condition = base::local({
[13:33:37.765]             c <- base::c
[13:33:37.765]             inherits <- base::inherits
[13:33:37.765]             invokeRestart <- base::invokeRestart
[13:33:37.765]             length <- base::length
[13:33:37.765]             list <- base::list
[13:33:37.765]             seq.int <- base::seq.int
[13:33:37.765]             signalCondition <- base::signalCondition
[13:33:37.765]             sys.calls <- base::sys.calls
[13:33:37.765]             `[[` <- base::`[[`
[13:33:37.765]             `+` <- base::`+`
[13:33:37.765]             `<<-` <- base::`<<-`
[13:33:37.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:37.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:37.765]                   3L)]
[13:33:37.765]             }
[13:33:37.765]             function(cond) {
[13:33:37.765]                 is_error <- inherits(cond, "error")
[13:33:37.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:37.765]                   NULL)
[13:33:37.765]                 if (is_error) {
[13:33:37.765]                   sessionInformation <- function() {
[13:33:37.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:37.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:37.765]                       search = base::search(), system = base::Sys.info())
[13:33:37.765]                   }
[13:33:37.765]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:37.765]                     cond$call), session = sessionInformation(), 
[13:33:37.765]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:37.765]                   signalCondition(cond)
[13:33:37.765]                 }
[13:33:37.765]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:33:37.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:37.765]                   ...future.conditions[[length(...future.conditions) + 
[13:33:37.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:37.765]                   if (TRUE && !signal) {
[13:33:37.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.765]                     {
[13:33:37.765]                       inherits <- base::inherits
[13:33:37.765]                       invokeRestart <- base::invokeRestart
[13:33:37.765]                       is.null <- base::is.null
[13:33:37.765]                       muffled <- FALSE
[13:33:37.765]                       if (inherits(cond, "message")) {
[13:33:37.765]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.765]                         if (muffled) 
[13:33:37.765]                           invokeRestart("muffleMessage")
[13:33:37.765]                       }
[13:33:37.765]                       else if (inherits(cond, "warning")) {
[13:33:37.765]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.765]                         if (muffled) 
[13:33:37.765]                           invokeRestart("muffleWarning")
[13:33:37.765]                       }
[13:33:37.765]                       else if (inherits(cond, "condition")) {
[13:33:37.765]                         if (!is.null(pattern)) {
[13:33:37.765]                           computeRestarts <- base::computeRestarts
[13:33:37.765]                           grepl <- base::grepl
[13:33:37.765]                           restarts <- computeRestarts(cond)
[13:33:37.765]                           for (restart in restarts) {
[13:33:37.765]                             name <- restart$name
[13:33:37.765]                             if (is.null(name)) 
[13:33:37.765]                               next
[13:33:37.765]                             if (!grepl(pattern, name)) 
[13:33:37.765]                               next
[13:33:37.765]                             invokeRestart(restart)
[13:33:37.765]                             muffled <- TRUE
[13:33:37.765]                             break
[13:33:37.765]                           }
[13:33:37.765]                         }
[13:33:37.765]                       }
[13:33:37.765]                       invisible(muffled)
[13:33:37.765]                     }
[13:33:37.765]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.765]                   }
[13:33:37.765]                 }
[13:33:37.765]                 else {
[13:33:37.765]                   if (TRUE) {
[13:33:37.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:37.765]                     {
[13:33:37.765]                       inherits <- base::inherits
[13:33:37.765]                       invokeRestart <- base::invokeRestart
[13:33:37.765]                       is.null <- base::is.null
[13:33:37.765]                       muffled <- FALSE
[13:33:37.765]                       if (inherits(cond, "message")) {
[13:33:37.765]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:37.765]                         if (muffled) 
[13:33:37.765]                           invokeRestart("muffleMessage")
[13:33:37.765]                       }
[13:33:37.765]                       else if (inherits(cond, "warning")) {
[13:33:37.765]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:37.765]                         if (muffled) 
[13:33:37.765]                           invokeRestart("muffleWarning")
[13:33:37.765]                       }
[13:33:37.765]                       else if (inherits(cond, "condition")) {
[13:33:37.765]                         if (!is.null(pattern)) {
[13:33:37.765]                           computeRestarts <- base::computeRestarts
[13:33:37.765]                           grepl <- base::grepl
[13:33:37.765]                           restarts <- computeRestarts(cond)
[13:33:37.765]                           for (restart in restarts) {
[13:33:37.765]                             name <- restart$name
[13:33:37.765]                             if (is.null(name)) 
[13:33:37.765]                               next
[13:33:37.765]                             if (!grepl(pattern, name)) 
[13:33:37.765]                               next
[13:33:37.765]                             invokeRestart(restart)
[13:33:37.765]                             muffled <- TRUE
[13:33:37.765]                             break
[13:33:37.765]                           }
[13:33:37.765]                         }
[13:33:37.765]                       }
[13:33:37.765]                       invisible(muffled)
[13:33:37.765]                     }
[13:33:37.765]                     muffleCondition(cond, pattern = "^muffle")
[13:33:37.765]                   }
[13:33:37.765]                 }
[13:33:37.765]             }
[13:33:37.765]         }))
[13:33:37.765]     }, error = function(ex) {
[13:33:37.765]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:37.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:37.765]                 ...future.rng), started = ...future.startTime, 
[13:33:37.765]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:37.765]             version = "1.8"), class = "FutureResult")
[13:33:37.765]     }, finally = {
[13:33:37.765]         if (!identical(...future.workdir, getwd())) 
[13:33:37.765]             setwd(...future.workdir)
[13:33:37.765]         {
[13:33:37.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:37.765]                 ...future.oldOptions$nwarnings <- NULL
[13:33:37.765]             }
[13:33:37.765]             base::options(...future.oldOptions)
[13:33:37.765]             if (.Platform$OS.type == "windows") {
[13:33:37.765]                 old_names <- names(...future.oldEnvVars)
[13:33:37.765]                 envs <- base::Sys.getenv()
[13:33:37.765]                 names <- names(envs)
[13:33:37.765]                 common <- intersect(names, old_names)
[13:33:37.765]                 added <- setdiff(names, old_names)
[13:33:37.765]                 removed <- setdiff(old_names, names)
[13:33:37.765]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:37.765]                   envs[common]]
[13:33:37.765]                 NAMES <- toupper(changed)
[13:33:37.765]                 args <- list()
[13:33:37.765]                 for (kk in seq_along(NAMES)) {
[13:33:37.765]                   name <- changed[[kk]]
[13:33:37.765]                   NAME <- NAMES[[kk]]
[13:33:37.765]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.765]                     next
[13:33:37.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.765]                 }
[13:33:37.765]                 NAMES <- toupper(added)
[13:33:37.765]                 for (kk in seq_along(NAMES)) {
[13:33:37.765]                   name <- added[[kk]]
[13:33:37.765]                   NAME <- NAMES[[kk]]
[13:33:37.765]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.765]                     next
[13:33:37.765]                   args[[name]] <- ""
[13:33:37.765]                 }
[13:33:37.765]                 NAMES <- toupper(removed)
[13:33:37.765]                 for (kk in seq_along(NAMES)) {
[13:33:37.765]                   name <- removed[[kk]]
[13:33:37.765]                   NAME <- NAMES[[kk]]
[13:33:37.765]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:37.765]                     next
[13:33:37.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:37.765]                 }
[13:33:37.765]                 if (length(args) > 0) 
[13:33:37.765]                   base::do.call(base::Sys.setenv, args = args)
[13:33:37.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:37.765]             }
[13:33:37.765]             else {
[13:33:37.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:37.765]             }
[13:33:37.765]             {
[13:33:37.765]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:37.765]                   0L) {
[13:33:37.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:37.765]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:37.765]                   base::options(opts)
[13:33:37.765]                 }
[13:33:37.765]                 {
[13:33:37.765]                   {
[13:33:37.765]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:37.765]                     NULL
[13:33:37.765]                   }
[13:33:37.765]                   options(future.plan = NULL)
[13:33:37.765]                   if (is.na(NA_character_)) 
[13:33:37.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:37.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:37.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:37.765]                     .init = FALSE)
[13:33:37.765]                 }
[13:33:37.765]             }
[13:33:37.765]         }
[13:33:37.765]     })
[13:33:37.765]     if (TRUE) {
[13:33:37.765]         base::sink(type = "output", split = FALSE)
[13:33:37.765]         if (TRUE) {
[13:33:37.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:37.765]         }
[13:33:37.765]         else {
[13:33:37.765]             ...future.result["stdout"] <- base::list(NULL)
[13:33:37.765]         }
[13:33:37.765]         base::close(...future.stdout)
[13:33:37.765]         ...future.stdout <- NULL
[13:33:37.765]     }
[13:33:37.765]     ...future.result$conditions <- ...future.conditions
[13:33:37.765]     ...future.result$finished <- base::Sys.time()
[13:33:37.765]     ...future.result
[13:33:37.765] }
[13:33:37.768] assign_globals() ...
[13:33:37.768] List of 5
[13:33:37.768]  $ future.call.arguments    : list()
[13:33:37.768]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:37.768]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[13:33:37.768]  $ ...future.elements_ii    :List of 1
[13:33:37.768]   ..$ : int [1:2] 2 4
[13:33:37.768]  $ ...future.seeds_ii       :List of 1
[13:33:37.768]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[13:33:37.768]  $ ...future.globals.maxSize: num Inf
[13:33:37.768]  - attr(*, "resolved")= logi FALSE
[13:33:37.768]  - attr(*, "total_size")= num NA
[13:33:37.768]  - attr(*, "where")=List of 5
[13:33:37.768]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:37.768]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:37.768]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:37.768]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:37.768]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:37.768]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:37.768]  - attr(*, "already-done")= logi TRUE
[13:33:37.775] - copied ‘future.call.arguments’ to environment
[13:33:37.775] - copied ‘...future.FUN’ to environment
[13:33:37.775] - copied ‘...future.elements_ii’ to environment
[13:33:37.775] - copied ‘...future.seeds_ii’ to environment
[13:33:37.776] - copied ‘...future.globals.maxSize’ to environment
[13:33:37.776] assign_globals() ... done
[13:33:37.776] requestCore(): workers = 2
[13:33:37.778] MulticoreFuture started
[13:33:37.778] - Launch lazy future ... done
[13:33:37.779] run() for ‘MulticoreFuture’ ... done
[13:33:37.779] Created future:
[13:33:37.779] plan(): Setting new future strategy stack:
[13:33:37.779] List of future strategies:
[13:33:37.779] 1. sequential:
[13:33:37.779]    - args: function (..., envir = parent.frame())
[13:33:37.779]    - tweaked: FALSE
[13:33:37.779]    - call: NULL
[13:33:37.780] plan(): nbrOfWorkers() = 1
[13:33:37.782] plan(): Setting new future strategy stack:
[13:33:37.782] List of future strategies:
[13:33:37.782] 1. multicore:
[13:33:37.782]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:37.782]    - tweaked: FALSE
[13:33:37.782]    - call: plan(strategy)
[13:33:37.788] plan(): nbrOfWorkers() = 2
[13:33:37.779] MulticoreFuture:
[13:33:37.779] Label: ‘future_apply-2’
[13:33:37.779] Expression:
[13:33:37.779] {
[13:33:37.779]     do.call(function(...) {
[13:33:37.779]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:37.779]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:37.779]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:37.779]             on.exit(options(oopts), add = TRUE)
[13:33:37.779]         }
[13:33:37.779]         {
[13:33:37.779]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:37.779]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:37.779]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:37.779]                   envir = globalenv(), inherits = FALSE)
[13:33:37.779]                 ...future.FUN(...future.X_jj, ...)
[13:33:37.779]             })
[13:33:37.779]         }
[13:33:37.779]     }, args = future.call.arguments)
[13:33:37.779] }
[13:33:37.779] Lazy evaluation: FALSE
[13:33:37.779] Asynchronous evaluation: TRUE
[13:33:37.779] Local evaluation: TRUE
[13:33:37.779] Environment: R_GlobalEnv
[13:33:37.779] Capture standard output: TRUE
[13:33:37.779] Capture condition classes: <none>
[13:33:37.779] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:37.779] Packages: <none>
[13:33:37.779] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:33:37.779] Resolved: TRUE
[13:33:37.779] Value: <not collected>
[13:33:37.779] Conditions captured: <none>
[13:33:37.779] Early signaling: FALSE
[13:33:37.779] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:37.779] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:37.789] Chunk #2 of 2 ... DONE
[13:33:37.789] Launching 2 futures (chunks) ... DONE
[13:33:37.789] Resolving 2 futures (chunks) ...
[13:33:37.789] resolve() on list ...
[13:33:37.789]  recursive: 0
[13:33:37.789]  length: 2
[13:33:37.790] 
[13:33:37.790] Future #1
[13:33:37.790] result() for MulticoreFuture ...
[13:33:37.791] result() for MulticoreFuture ...
[13:33:37.791] result() for MulticoreFuture ... done
[13:33:37.791] result() for MulticoreFuture ... done
[13:33:37.791] result() for MulticoreFuture ...
[13:33:37.792] result() for MulticoreFuture ... done
[13:33:37.796] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:37.796] - nx: 2
[13:33:37.796] - relay: TRUE
[13:33:37.797] - stdout: TRUE
[13:33:37.797] - signal: TRUE
[13:33:37.798] - resignal: FALSE
[13:33:37.798] - force: TRUE
[13:33:37.798] - relayed: [n=2] FALSE, FALSE
[13:33:37.798] - queued futures: [n=2] FALSE, FALSE
[13:33:37.799]  - until=1
[13:33:37.799]  - relaying element #1
[13:33:37.799] result() for MulticoreFuture ...
[13:33:37.800] result() for MulticoreFuture ... done
[13:33:37.800] result() for MulticoreFuture ...
[13:33:37.800] result() for MulticoreFuture ... done
[13:33:37.800] result() for MulticoreFuture ...
[13:33:37.801] result() for MulticoreFuture ... done
[13:33:37.801] result() for MulticoreFuture ...
[13:33:37.801] result() for MulticoreFuture ... done
[13:33:37.801] - relayed: [n=2] TRUE, FALSE
[13:33:37.802] - queued futures: [n=2] TRUE, FALSE
[13:33:37.802] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:37.802]  length: 1 (resolved future 1)
[13:33:37.803] Future #2
[13:33:37.803] result() for MulticoreFuture ...
[13:33:37.804] result() for MulticoreFuture ...
[13:33:37.804] result() for MulticoreFuture ... done
[13:33:37.804] result() for MulticoreFuture ... done
[13:33:37.805] result() for MulticoreFuture ...
[13:33:37.805] result() for MulticoreFuture ... done
[13:33:37.805] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:37.805] - nx: 2
[13:33:37.805] - relay: TRUE
[13:33:37.806] - stdout: TRUE
[13:33:37.806] - signal: TRUE
[13:33:37.806] - resignal: FALSE
[13:33:37.806] - force: TRUE
[13:33:37.806] - relayed: [n=2] TRUE, FALSE
[13:33:37.806] - queued futures: [n=2] TRUE, FALSE
[13:33:37.806]  - until=2
[13:33:37.807]  - relaying element #2
[13:33:37.807] result() for MulticoreFuture ...
[13:33:37.807] result() for MulticoreFuture ... done
[13:33:37.807] result() for MulticoreFuture ...
[13:33:37.807] result() for MulticoreFuture ... done
[13:33:37.807] result() for MulticoreFuture ...
[13:33:37.807] result() for MulticoreFuture ... done
[13:33:37.807] result() for MulticoreFuture ...
[13:33:37.807] result() for MulticoreFuture ... done
[13:33:37.808] - relayed: [n=2] TRUE, TRUE
[13:33:37.808] - queued futures: [n=2] TRUE, TRUE
[13:33:37.808] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:37.808]  length: 0 (resolved future 2)
[13:33:37.808] Relaying remaining futures
[13:33:37.808] signalConditionsASAP(NULL, pos=0) ...
[13:33:37.808] - nx: 2
[13:33:37.809] - relay: TRUE
[13:33:37.809] - stdout: TRUE
[13:33:37.809] - signal: TRUE
[13:33:37.809] - resignal: FALSE
[13:33:37.809] - force: TRUE
[13:33:37.809] - relayed: [n=2] TRUE, TRUE
[13:33:37.809] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:37.809] - relayed: [n=2] TRUE, TRUE
[13:33:37.809] - queued futures: [n=2] TRUE, TRUE
[13:33:37.810] signalConditionsASAP(NULL, pos=0) ... done
[13:33:37.810] resolve() on list ... DONE
[13:33:37.810] result() for MulticoreFuture ...
[13:33:37.810] result() for MulticoreFuture ... done
[13:33:37.810] result() for MulticoreFuture ...
[13:33:37.810] result() for MulticoreFuture ... done
[13:33:37.810] result() for MulticoreFuture ...
[13:33:37.810] result() for MulticoreFuture ... done
[13:33:37.810] result() for MulticoreFuture ...
[13:33:37.811] result() for MulticoreFuture ... done
[13:33:37.811]  - Number of value chunks collected: 2
[13:33:37.811] Resolving 2 futures (chunks) ... DONE
[13:33:37.811] Reducing values from 2 chunks ...
[13:33:37.811]  - Number of values collected after concatenation: 2
[13:33:37.811]  - Number of values expected: 2
[13:33:37.811] Reducing values from 2 chunks ... DONE
[13:33:37.811] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[13:33:37.812] plan(): Setting new future strategy stack:
[13:33:37.812] List of future strategies:
[13:33:37.812] 1. sequential:
[13:33:37.812]    - args: function (..., envir = parent.frame())
[13:33:37.812]    - tweaked: FALSE
[13:33:37.812]    - call: plan(sequential)
[13:33:37.812] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[13:33:37.813] plan(): Setting new future strategy stack:
[13:33:37.813] List of future strategies:
[13:33:37.813] 1. multisession:
[13:33:37.813]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:37.813]    - tweaked: FALSE
[13:33:37.813]    - call: plan(strategy)
[13:33:37.813] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:33:37.813] multisession:
[13:33:37.813] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:37.813] - tweaked: FALSE
[13:33:37.813] - call: plan(strategy)
[13:33:37.820] getGlobalsAndPackages() ...
[13:33:37.820] Not searching for globals
[13:33:37.820] - globals: [0] <none>
[13:33:37.820] getGlobalsAndPackages() ... DONE
[13:33:37.821] [local output] makeClusterPSOCK() ...
[13:33:37.866] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:33:37.867] [local output] Base port: 11159
[13:33:37.868] [local output] Getting setup options for 2 cluster nodes ...
[13:33:37.868] [local output]  - Node 1 of 2 ...
[13:33:37.868] [local output] localMachine=TRUE => revtunnel=FALSE

[13:33:37.869] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4yxGoc/worker.rank=1.parallelly.parent=68878.10d0e203188b9.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp4yxGoc/worker.rank=1.parallelly.parent=68878.10d0e203188b9.pid")'’
[13:33:38.057] - Possible to infer worker's PID: TRUE
[13:33:38.058] [local output] Rscript port: 11159

[13:33:38.058] [local output]  - Node 2 of 2 ...
[13:33:38.059] [local output] localMachine=TRUE => revtunnel=FALSE

[13:33:38.059] [local output] Rscript port: 11159

[13:33:38.059] [local output] Getting setup options for 2 cluster nodes ... done
[13:33:38.060] [local output]  - Parallel setup requested for some PSOCK nodes
[13:33:38.060] [local output] Setting up PSOCK nodes in parallel
[13:33:38.060] List of 36
[13:33:38.060]  $ worker          : chr "localhost"
[13:33:38.060]   ..- attr(*, "localhost")= logi TRUE
[13:33:38.060]  $ master          : chr "localhost"
[13:33:38.060]  $ port            : int 11159
[13:33:38.060]  $ connectTimeout  : num 120
[13:33:38.060]  $ timeout         : num 2592000
[13:33:38.060]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:33:38.060]  $ homogeneous     : logi TRUE
[13:33:38.060]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:33:38.060]  $ rscript_envs    : NULL
[13:33:38.060]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:33:38.060]  $ rscript_startup : NULL
[13:33:38.060]  $ rscript_sh      : chr "sh"
[13:33:38.060]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:33:38.060]  $ methods         : logi TRUE
[13:33:38.060]  $ socketOptions   : chr "no-delay"
[13:33:38.060]  $ useXDR          : logi FALSE
[13:33:38.060]  $ outfile         : chr "/dev/null"
[13:33:38.060]  $ renice          : int NA
[13:33:38.060]  $ rshcmd          : NULL
[13:33:38.060]  $ user            : chr(0) 
[13:33:38.060]  $ revtunnel       : logi FALSE
[13:33:38.060]  $ rshlogfile      : NULL
[13:33:38.060]  $ rshopts         : chr(0) 
[13:33:38.060]  $ rank            : int 1
[13:33:38.060]  $ manual          : logi FALSE
[13:33:38.060]  $ dryrun          : logi FALSE
[13:33:38.060]  $ quiet           : logi FALSE
[13:33:38.060]  $ setup_strategy  : chr "parallel"
[13:33:38.060]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:33:38.060]  $ pidfile         : chr "/tmp/Rtmp4yxGoc/worker.rank=1.parallelly.parent=68878.10d0e203188b9.pid"
[13:33:38.060]  $ rshcmd_label    : NULL
[13:33:38.060]  $ rsh_call        : NULL
[13:33:38.060]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:33:38.060]  $ localMachine    : logi TRUE
[13:33:38.060]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:33:38.060]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:33:38.060]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:33:38.060]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:33:38.060]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:33:38.060]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:33:38.060]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:33:38.060]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:33:38.060]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:33:38.060]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:33:38.060]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:33:38.060]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:33:38.060]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:33:38.060]  $ arguments       :List of 28
[13:33:38.060]   ..$ worker          : chr "localhost"
[13:33:38.060]   ..$ master          : NULL
[13:33:38.060]   ..$ port            : int 11159
[13:33:38.060]   ..$ connectTimeout  : num 120
[13:33:38.060]   ..$ timeout         : num 2592000
[13:33:38.060]   ..$ rscript         : NULL
[13:33:38.060]   ..$ homogeneous     : NULL
[13:33:38.060]   ..$ rscript_args    : NULL
[13:33:38.060]   ..$ rscript_envs    : NULL
[13:33:38.060]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:33:38.060]   ..$ rscript_startup : NULL
[13:33:38.060]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:33:38.060]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:33:38.060]   ..$ methods         : logi TRUE
[13:33:38.060]   ..$ socketOptions   : chr "no-delay"
[13:33:38.060]   ..$ useXDR          : logi FALSE
[13:33:38.060]   ..$ outfile         : chr "/dev/null"
[13:33:38.060]   ..$ renice          : int NA
[13:33:38.060]   ..$ rshcmd          : NULL
[13:33:38.060]   ..$ user            : NULL
[13:33:38.060]   ..$ revtunnel       : logi NA
[13:33:38.060]   ..$ rshlogfile      : NULL
[13:33:38.060]   ..$ rshopts         : NULL
[13:33:38.060]   ..$ rank            : int 1
[13:33:38.060]   ..$ manual          : logi FALSE
[13:33:38.060]   ..$ dryrun          : logi FALSE
[13:33:38.060]   ..$ quiet           : logi FALSE
[13:33:38.060]   ..$ setup_strategy  : chr "parallel"
[13:33:38.060]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:33:38.077] [local output] System call to launch all workers:
[13:33:38.077] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4yxGoc/worker.rank=1.parallelly.parent=68878.10d0e203188b9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11159 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:33:38.077] [local output] Starting PSOCK main server
[13:33:38.083] [local output] Workers launched
[13:33:38.083] [local output] Waiting for workers to connect back
[13:33:38.083]  - [local output] 0 workers out of 2 ready
[13:33:38.328]  - [local output] 0 workers out of 2 ready
[13:33:38.328]  - [local output] 1 workers out of 2 ready
[13:33:38.329]  - [local output] 2 workers out of 2 ready
[13:33:38.329] [local output] Launching of workers completed
[13:33:38.329] [local output] Collecting session information from workers
[13:33:38.330] [local output]  - Worker #1 of 2
[13:33:38.330] [local output]  - Worker #2 of 2
[13:33:38.330] [local output] makeClusterPSOCK() ... done
[13:33:38.342] Packages needed by the future expression (n = 0): <none>
[13:33:38.342] Packages needed by future strategies (n = 0): <none>
[13:33:38.342] {
[13:33:38.342]     {
[13:33:38.342]         {
[13:33:38.342]             ...future.startTime <- base::Sys.time()
[13:33:38.342]             {
[13:33:38.342]                 {
[13:33:38.342]                   {
[13:33:38.342]                     {
[13:33:38.342]                       base::local({
[13:33:38.342]                         has_future <- base::requireNamespace("future", 
[13:33:38.342]                           quietly = TRUE)
[13:33:38.342]                         if (has_future) {
[13:33:38.342]                           ns <- base::getNamespace("future")
[13:33:38.342]                           version <- ns[[".package"]][["version"]]
[13:33:38.342]                           if (is.null(version)) 
[13:33:38.342]                             version <- utils::packageVersion("future")
[13:33:38.342]                         }
[13:33:38.342]                         else {
[13:33:38.342]                           version <- NULL
[13:33:38.342]                         }
[13:33:38.342]                         if (!has_future || version < "1.8.0") {
[13:33:38.342]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:38.342]                             "", base::R.version$version.string), 
[13:33:38.342]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:38.342]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:38.342]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:38.342]                               "release", "version")], collapse = " "), 
[13:33:38.342]                             hostname = base::Sys.info()[["nodename"]])
[13:33:38.342]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:38.342]                             info)
[13:33:38.342]                           info <- base::paste(info, collapse = "; ")
[13:33:38.342]                           if (!has_future) {
[13:33:38.342]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:38.342]                               info)
[13:33:38.342]                           }
[13:33:38.342]                           else {
[13:33:38.342]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:38.342]                               info, version)
[13:33:38.342]                           }
[13:33:38.342]                           base::stop(msg)
[13:33:38.342]                         }
[13:33:38.342]                       })
[13:33:38.342]                     }
[13:33:38.342]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:38.342]                     base::options(mc.cores = 1L)
[13:33:38.342]                   }
[13:33:38.342]                   ...future.strategy.old <- future::plan("list")
[13:33:38.342]                   options(future.plan = NULL)
[13:33:38.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:38.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:38.342]                 }
[13:33:38.342]                 ...future.workdir <- getwd()
[13:33:38.342]             }
[13:33:38.342]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:38.342]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:38.342]         }
[13:33:38.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:38.342]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:38.342]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:38.342]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:38.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:38.342]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:38.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:38.342]             base::names(...future.oldOptions))
[13:33:38.342]     }
[13:33:38.342]     if (FALSE) {
[13:33:38.342]     }
[13:33:38.342]     else {
[13:33:38.342]         if (TRUE) {
[13:33:38.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:38.342]                 open = "w")
[13:33:38.342]         }
[13:33:38.342]         else {
[13:33:38.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:38.342]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:38.342]         }
[13:33:38.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:38.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:38.342]             base::sink(type = "output", split = FALSE)
[13:33:38.342]             base::close(...future.stdout)
[13:33:38.342]         }, add = TRUE)
[13:33:38.342]     }
[13:33:38.342]     ...future.frame <- base::sys.nframe()
[13:33:38.342]     ...future.conditions <- base::list()
[13:33:38.342]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:38.342]     if (FALSE) {
[13:33:38.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:38.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:38.342]     }
[13:33:38.342]     ...future.result <- base::tryCatch({
[13:33:38.342]         base::withCallingHandlers({
[13:33:38.342]             ...future.value <- base::withVisible(base::local({
[13:33:38.342]                 ...future.makeSendCondition <- base::local({
[13:33:38.342]                   sendCondition <- NULL
[13:33:38.342]                   function(frame = 1L) {
[13:33:38.342]                     if (is.function(sendCondition)) 
[13:33:38.342]                       return(sendCondition)
[13:33:38.342]                     ns <- getNamespace("parallel")
[13:33:38.342]                     if (exists("sendData", mode = "function", 
[13:33:38.342]                       envir = ns)) {
[13:33:38.342]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:38.342]                         envir = ns)
[13:33:38.342]                       envir <- sys.frame(frame)
[13:33:38.342]                       master <- NULL
[13:33:38.342]                       while (!identical(envir, .GlobalEnv) && 
[13:33:38.342]                         !identical(envir, emptyenv())) {
[13:33:38.342]                         if (exists("master", mode = "list", envir = envir, 
[13:33:38.342]                           inherits = FALSE)) {
[13:33:38.342]                           master <- get("master", mode = "list", 
[13:33:38.342]                             envir = envir, inherits = FALSE)
[13:33:38.342]                           if (inherits(master, c("SOCKnode", 
[13:33:38.342]                             "SOCK0node"))) {
[13:33:38.342]                             sendCondition <<- function(cond) {
[13:33:38.342]                               data <- list(type = "VALUE", value = cond, 
[13:33:38.342]                                 success = TRUE)
[13:33:38.342]                               parallel_sendData(master, data)
[13:33:38.342]                             }
[13:33:38.342]                             return(sendCondition)
[13:33:38.342]                           }
[13:33:38.342]                         }
[13:33:38.342]                         frame <- frame + 1L
[13:33:38.342]                         envir <- sys.frame(frame)
[13:33:38.342]                       }
[13:33:38.342]                     }
[13:33:38.342]                     sendCondition <<- function(cond) NULL
[13:33:38.342]                   }
[13:33:38.342]                 })
[13:33:38.342]                 withCallingHandlers({
[13:33:38.342]                   NA
[13:33:38.342]                 }, immediateCondition = function(cond) {
[13:33:38.342]                   sendCondition <- ...future.makeSendCondition()
[13:33:38.342]                   sendCondition(cond)
[13:33:38.342]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.342]                   {
[13:33:38.342]                     inherits <- base::inherits
[13:33:38.342]                     invokeRestart <- base::invokeRestart
[13:33:38.342]                     is.null <- base::is.null
[13:33:38.342]                     muffled <- FALSE
[13:33:38.342]                     if (inherits(cond, "message")) {
[13:33:38.342]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:38.342]                       if (muffled) 
[13:33:38.342]                         invokeRestart("muffleMessage")
[13:33:38.342]                     }
[13:33:38.342]                     else if (inherits(cond, "warning")) {
[13:33:38.342]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:38.342]                       if (muffled) 
[13:33:38.342]                         invokeRestart("muffleWarning")
[13:33:38.342]                     }
[13:33:38.342]                     else if (inherits(cond, "condition")) {
[13:33:38.342]                       if (!is.null(pattern)) {
[13:33:38.342]                         computeRestarts <- base::computeRestarts
[13:33:38.342]                         grepl <- base::grepl
[13:33:38.342]                         restarts <- computeRestarts(cond)
[13:33:38.342]                         for (restart in restarts) {
[13:33:38.342]                           name <- restart$name
[13:33:38.342]                           if (is.null(name)) 
[13:33:38.342]                             next
[13:33:38.342]                           if (!grepl(pattern, name)) 
[13:33:38.342]                             next
[13:33:38.342]                           invokeRestart(restart)
[13:33:38.342]                           muffled <- TRUE
[13:33:38.342]                           break
[13:33:38.342]                         }
[13:33:38.342]                       }
[13:33:38.342]                     }
[13:33:38.342]                     invisible(muffled)
[13:33:38.342]                   }
[13:33:38.342]                   muffleCondition(cond)
[13:33:38.342]                 })
[13:33:38.342]             }))
[13:33:38.342]             future::FutureResult(value = ...future.value$value, 
[13:33:38.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:38.342]                   ...future.rng), globalenv = if (FALSE) 
[13:33:38.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:38.342]                     ...future.globalenv.names))
[13:33:38.342]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:38.342]         }, condition = base::local({
[13:33:38.342]             c <- base::c
[13:33:38.342]             inherits <- base::inherits
[13:33:38.342]             invokeRestart <- base::invokeRestart
[13:33:38.342]             length <- base::length
[13:33:38.342]             list <- base::list
[13:33:38.342]             seq.int <- base::seq.int
[13:33:38.342]             signalCondition <- base::signalCondition
[13:33:38.342]             sys.calls <- base::sys.calls
[13:33:38.342]             `[[` <- base::`[[`
[13:33:38.342]             `+` <- base::`+`
[13:33:38.342]             `<<-` <- base::`<<-`
[13:33:38.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:38.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:38.342]                   3L)]
[13:33:38.342]             }
[13:33:38.342]             function(cond) {
[13:33:38.342]                 is_error <- inherits(cond, "error")
[13:33:38.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:38.342]                   NULL)
[13:33:38.342]                 if (is_error) {
[13:33:38.342]                   sessionInformation <- function() {
[13:33:38.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:38.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:38.342]                       search = base::search(), system = base::Sys.info())
[13:33:38.342]                   }
[13:33:38.342]                   ...future.conditions[[length(...future.conditions) + 
[13:33:38.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:38.342]                     cond$call), session = sessionInformation(), 
[13:33:38.342]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:38.342]                   signalCondition(cond)
[13:33:38.342]                 }
[13:33:38.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:38.342]                 "immediateCondition"))) {
[13:33:38.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:38.342]                   ...future.conditions[[length(...future.conditions) + 
[13:33:38.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:38.342]                   if (TRUE && !signal) {
[13:33:38.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.342]                     {
[13:33:38.342]                       inherits <- base::inherits
[13:33:38.342]                       invokeRestart <- base::invokeRestart
[13:33:38.342]                       is.null <- base::is.null
[13:33:38.342]                       muffled <- FALSE
[13:33:38.342]                       if (inherits(cond, "message")) {
[13:33:38.342]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:38.342]                         if (muffled) 
[13:33:38.342]                           invokeRestart("muffleMessage")
[13:33:38.342]                       }
[13:33:38.342]                       else if (inherits(cond, "warning")) {
[13:33:38.342]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:38.342]                         if (muffled) 
[13:33:38.342]                           invokeRestart("muffleWarning")
[13:33:38.342]                       }
[13:33:38.342]                       else if (inherits(cond, "condition")) {
[13:33:38.342]                         if (!is.null(pattern)) {
[13:33:38.342]                           computeRestarts <- base::computeRestarts
[13:33:38.342]                           grepl <- base::grepl
[13:33:38.342]                           restarts <- computeRestarts(cond)
[13:33:38.342]                           for (restart in restarts) {
[13:33:38.342]                             name <- restart$name
[13:33:38.342]                             if (is.null(name)) 
[13:33:38.342]                               next
[13:33:38.342]                             if (!grepl(pattern, name)) 
[13:33:38.342]                               next
[13:33:38.342]                             invokeRestart(restart)
[13:33:38.342]                             muffled <- TRUE
[13:33:38.342]                             break
[13:33:38.342]                           }
[13:33:38.342]                         }
[13:33:38.342]                       }
[13:33:38.342]                       invisible(muffled)
[13:33:38.342]                     }
[13:33:38.342]                     muffleCondition(cond, pattern = "^muffle")
[13:33:38.342]                   }
[13:33:38.342]                 }
[13:33:38.342]                 else {
[13:33:38.342]                   if (TRUE) {
[13:33:38.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.342]                     {
[13:33:38.342]                       inherits <- base::inherits
[13:33:38.342]                       invokeRestart <- base::invokeRestart
[13:33:38.342]                       is.null <- base::is.null
[13:33:38.342]                       muffled <- FALSE
[13:33:38.342]                       if (inherits(cond, "message")) {
[13:33:38.342]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:38.342]                         if (muffled) 
[13:33:38.342]                           invokeRestart("muffleMessage")
[13:33:38.342]                       }
[13:33:38.342]                       else if (inherits(cond, "warning")) {
[13:33:38.342]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:38.342]                         if (muffled) 
[13:33:38.342]                           invokeRestart("muffleWarning")
[13:33:38.342]                       }
[13:33:38.342]                       else if (inherits(cond, "condition")) {
[13:33:38.342]                         if (!is.null(pattern)) {
[13:33:38.342]                           computeRestarts <- base::computeRestarts
[13:33:38.342]                           grepl <- base::grepl
[13:33:38.342]                           restarts <- computeRestarts(cond)
[13:33:38.342]                           for (restart in restarts) {
[13:33:38.342]                             name <- restart$name
[13:33:38.342]                             if (is.null(name)) 
[13:33:38.342]                               next
[13:33:38.342]                             if (!grepl(pattern, name)) 
[13:33:38.342]                               next
[13:33:38.342]                             invokeRestart(restart)
[13:33:38.342]                             muffled <- TRUE
[13:33:38.342]                             break
[13:33:38.342]                           }
[13:33:38.342]                         }
[13:33:38.342]                       }
[13:33:38.342]                       invisible(muffled)
[13:33:38.342]                     }
[13:33:38.342]                     muffleCondition(cond, pattern = "^muffle")
[13:33:38.342]                   }
[13:33:38.342]                 }
[13:33:38.342]             }
[13:33:38.342]         }))
[13:33:38.342]     }, error = function(ex) {
[13:33:38.342]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:38.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:38.342]                 ...future.rng), started = ...future.startTime, 
[13:33:38.342]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:38.342]             version = "1.8"), class = "FutureResult")
[13:33:38.342]     }, finally = {
[13:33:38.342]         if (!identical(...future.workdir, getwd())) 
[13:33:38.342]             setwd(...future.workdir)
[13:33:38.342]         {
[13:33:38.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:38.342]                 ...future.oldOptions$nwarnings <- NULL
[13:33:38.342]             }
[13:33:38.342]             base::options(...future.oldOptions)
[13:33:38.342]             if (.Platform$OS.type == "windows") {
[13:33:38.342]                 old_names <- names(...future.oldEnvVars)
[13:33:38.342]                 envs <- base::Sys.getenv()
[13:33:38.342]                 names <- names(envs)
[13:33:38.342]                 common <- intersect(names, old_names)
[13:33:38.342]                 added <- setdiff(names, old_names)
[13:33:38.342]                 removed <- setdiff(old_names, names)
[13:33:38.342]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:38.342]                   envs[common]]
[13:33:38.342]                 NAMES <- toupper(changed)
[13:33:38.342]                 args <- list()
[13:33:38.342]                 for (kk in seq_along(NAMES)) {
[13:33:38.342]                   name <- changed[[kk]]
[13:33:38.342]                   NAME <- NAMES[[kk]]
[13:33:38.342]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.342]                     next
[13:33:38.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:38.342]                 }
[13:33:38.342]                 NAMES <- toupper(added)
[13:33:38.342]                 for (kk in seq_along(NAMES)) {
[13:33:38.342]                   name <- added[[kk]]
[13:33:38.342]                   NAME <- NAMES[[kk]]
[13:33:38.342]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.342]                     next
[13:33:38.342]                   args[[name]] <- ""
[13:33:38.342]                 }
[13:33:38.342]                 NAMES <- toupper(removed)
[13:33:38.342]                 for (kk in seq_along(NAMES)) {
[13:33:38.342]                   name <- removed[[kk]]
[13:33:38.342]                   NAME <- NAMES[[kk]]
[13:33:38.342]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.342]                     next
[13:33:38.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:38.342]                 }
[13:33:38.342]                 if (length(args) > 0) 
[13:33:38.342]                   base::do.call(base::Sys.setenv, args = args)
[13:33:38.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:38.342]             }
[13:33:38.342]             else {
[13:33:38.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:38.342]             }
[13:33:38.342]             {
[13:33:38.342]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:38.342]                   0L) {
[13:33:38.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:38.342]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:38.342]                   base::options(opts)
[13:33:38.342]                 }
[13:33:38.342]                 {
[13:33:38.342]                   {
[13:33:38.342]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:38.342]                     NULL
[13:33:38.342]                   }
[13:33:38.342]                   options(future.plan = NULL)
[13:33:38.342]                   if (is.na(NA_character_)) 
[13:33:38.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:38.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:38.342]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:38.342]                     .init = FALSE)
[13:33:38.342]                 }
[13:33:38.342]             }
[13:33:38.342]         }
[13:33:38.342]     })
[13:33:38.342]     if (TRUE) {
[13:33:38.342]         base::sink(type = "output", split = FALSE)
[13:33:38.342]         if (TRUE) {
[13:33:38.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:38.342]         }
[13:33:38.342]         else {
[13:33:38.342]             ...future.result["stdout"] <- base::list(NULL)
[13:33:38.342]         }
[13:33:38.342]         base::close(...future.stdout)
[13:33:38.342]         ...future.stdout <- NULL
[13:33:38.342]     }
[13:33:38.342]     ...future.result$conditions <- ...future.conditions
[13:33:38.342]     ...future.result$finished <- base::Sys.time()
[13:33:38.342]     ...future.result
[13:33:38.342] }
[13:33:38.395] MultisessionFuture started
[13:33:38.395] result() for ClusterFuture ...
[13:33:38.396] receiveMessageFromWorker() for ClusterFuture ...
[13:33:38.396] - Validating connection of MultisessionFuture
[13:33:38.428] - received message: FutureResult
[13:33:38.428] - Received FutureResult
[13:33:38.428] - Erased future from FutureRegistry
[13:33:38.428] result() for ClusterFuture ...
[13:33:38.428] - result already collected: FutureResult
[13:33:38.429] result() for ClusterFuture ... done
[13:33:38.429] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:38.429] result() for ClusterFuture ... done
[13:33:38.429] result() for ClusterFuture ...
[13:33:38.429] - result already collected: FutureResult
[13:33:38.429] result() for ClusterFuture ... done
[13:33:38.429] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:33:38.433] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[13:33:38.434] getGlobalsAndPackagesXApply() ...
[13:33:38.434]  - future.globals: TRUE
[13:33:38.434] getGlobalsAndPackages() ...
[13:33:38.434] Searching for globals...
[13:33:38.478] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:33:38.478] Searching for globals ... DONE
[13:33:38.479] Resolving globals: FALSE
[13:33:38.480] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:33:38.481] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:33:38.481] - globals: [1] ‘FUN’
[13:33:38.481] 
[13:33:38.481] getGlobalsAndPackages() ... DONE
[13:33:38.481]  - globals found/used: [n=1] ‘FUN’
[13:33:38.481]  - needed namespaces: [n=0] 
[13:33:38.481] Finding globals ... DONE
[13:33:38.481]  - use_args: TRUE
[13:33:38.481]  - Getting '...' globals ...
[13:33:38.482] resolve() on list ...
[13:33:38.482]  recursive: 0
[13:33:38.482]  length: 1
[13:33:38.482]  elements: ‘...’
[13:33:38.482]  length: 0 (resolved future 1)
[13:33:38.482] resolve() on list ... DONE
[13:33:38.482]    - '...' content: [n=0] 
[13:33:38.482] List of 1
[13:33:38.482]  $ ...: list()
[13:33:38.482]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:38.482]  - attr(*, "where")=List of 1
[13:33:38.482]   ..$ ...:<environment: 0x55b94b1c54c0> 
[13:33:38.482]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:38.482]  - attr(*, "resolved")= logi TRUE
[13:33:38.482]  - attr(*, "total_size")= num NA
[13:33:38.485]  - Getting '...' globals ... DONE
[13:33:38.485] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:38.485] List of 2
[13:33:38.485]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:38.485]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:38.485]  $ ...          : list()
[13:33:38.485]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:38.485]  - attr(*, "where")=List of 2
[13:33:38.485]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:38.485]   ..$ ...          :<environment: 0x55b94b1c54c0> 
[13:33:38.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:38.485]  - attr(*, "resolved")= logi FALSE
[13:33:38.485]  - attr(*, "total_size")= num 354224
[13:33:38.488] Packages to be attached in all futures: [n=0] 
[13:33:38.488] getGlobalsAndPackagesXApply() ... DONE
[13:33:38.491] future_lapply() ...
[13:33:38.524] Number of chunks: 2
[13:33:38.524] getGlobalsAndPackagesXApply() ...
[13:33:38.524]  - future.globals: <name-value list> with names ‘list()’
[13:33:38.524]  - use_args: TRUE
[13:33:38.524] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:38.525] List of 2
[13:33:38.525]  $ ...          : list()
[13:33:38.525]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:38.525]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:38.525]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:38.525]  - attr(*, "where")=List of 2
[13:33:38.525]   ..$ ...          :<environment: 0x55b94b1c54c0> 
[13:33:38.525]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:38.525]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:38.525]  - attr(*, "resolved")= logi FALSE
[13:33:38.525]  - attr(*, "total_size")= num NA
[13:33:38.528] Packages to be attached in all futures: [n=0] 
[13:33:38.528] getGlobalsAndPackagesXApply() ... DONE
[13:33:38.528] Number of futures (= number of chunks): 2
[13:33:38.528] Launching 2 futures (chunks) ...
[13:33:38.528] Chunk #1 of 2 ...
[13:33:38.529]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:38.529]  - seeds: <none>
[13:33:38.529]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.529] getGlobalsAndPackages() ...
[13:33:38.529] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.529] Resolving globals: FALSE
[13:33:38.529] Tweak future expression to call with '...' arguments ...
[13:33:38.529] {
[13:33:38.529]     do.call(function(...) {
[13:33:38.529]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.529]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:38.529]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.529]             on.exit(options(oopts), add = TRUE)
[13:33:38.529]         }
[13:33:38.529]         {
[13:33:38.529]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:38.529]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.529]                 ...future.FUN(...future.X_jj, ...)
[13:33:38.529]             })
[13:33:38.529]         }
[13:33:38.529]     }, args = future.call.arguments)
[13:33:38.529] }
[13:33:38.530] Tweak future expression to call with '...' arguments ... DONE
[13:33:38.530] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.530] 
[13:33:38.530] getGlobalsAndPackages() ... DONE
[13:33:38.530] run() for ‘Future’ ...
[13:33:38.531] - state: ‘created’
[13:33:38.531] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:38.544] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:38.544] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:38.544]   - Field: ‘node’
[13:33:38.545]   - Field: ‘label’
[13:33:38.545]   - Field: ‘local’
[13:33:38.545]   - Field: ‘owner’
[13:33:38.545]   - Field: ‘envir’
[13:33:38.545]   - Field: ‘workers’
[13:33:38.545]   - Field: ‘packages’
[13:33:38.545]   - Field: ‘gc’
[13:33:38.545]   - Field: ‘conditions’
[13:33:38.545]   - Field: ‘persistent’
[13:33:38.545]   - Field: ‘expr’
[13:33:38.545]   - Field: ‘uuid’
[13:33:38.546]   - Field: ‘seed’
[13:33:38.546]   - Field: ‘version’
[13:33:38.546]   - Field: ‘result’
[13:33:38.546]   - Field: ‘asynchronous’
[13:33:38.546]   - Field: ‘calls’
[13:33:38.546]   - Field: ‘globals’
[13:33:38.546]   - Field: ‘stdout’
[13:33:38.546]   - Field: ‘earlySignal’
[13:33:38.546]   - Field: ‘lazy’
[13:33:38.546]   - Field: ‘state’
[13:33:38.546] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:38.547] - Launch lazy future ...
[13:33:38.547] Packages needed by the future expression (n = 0): <none>
[13:33:38.547] Packages needed by future strategies (n = 0): <none>
[13:33:38.547] {
[13:33:38.547]     {
[13:33:38.547]         {
[13:33:38.547]             ...future.startTime <- base::Sys.time()
[13:33:38.547]             {
[13:33:38.547]                 {
[13:33:38.547]                   {
[13:33:38.547]                     {
[13:33:38.547]                       base::local({
[13:33:38.547]                         has_future <- base::requireNamespace("future", 
[13:33:38.547]                           quietly = TRUE)
[13:33:38.547]                         if (has_future) {
[13:33:38.547]                           ns <- base::getNamespace("future")
[13:33:38.547]                           version <- ns[[".package"]][["version"]]
[13:33:38.547]                           if (is.null(version)) 
[13:33:38.547]                             version <- utils::packageVersion("future")
[13:33:38.547]                         }
[13:33:38.547]                         else {
[13:33:38.547]                           version <- NULL
[13:33:38.547]                         }
[13:33:38.547]                         if (!has_future || version < "1.8.0") {
[13:33:38.547]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:38.547]                             "", base::R.version$version.string), 
[13:33:38.547]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:38.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:38.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:38.547]                               "release", "version")], collapse = " "), 
[13:33:38.547]                             hostname = base::Sys.info()[["nodename"]])
[13:33:38.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:38.547]                             info)
[13:33:38.547]                           info <- base::paste(info, collapse = "; ")
[13:33:38.547]                           if (!has_future) {
[13:33:38.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:38.547]                               info)
[13:33:38.547]                           }
[13:33:38.547]                           else {
[13:33:38.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:38.547]                               info, version)
[13:33:38.547]                           }
[13:33:38.547]                           base::stop(msg)
[13:33:38.547]                         }
[13:33:38.547]                       })
[13:33:38.547]                     }
[13:33:38.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:38.547]                     base::options(mc.cores = 1L)
[13:33:38.547]                   }
[13:33:38.547]                   ...future.strategy.old <- future::plan("list")
[13:33:38.547]                   options(future.plan = NULL)
[13:33:38.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:38.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:38.547]                 }
[13:33:38.547]                 ...future.workdir <- getwd()
[13:33:38.547]             }
[13:33:38.547]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:38.547]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:38.547]         }
[13:33:38.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:38.547]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:38.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:38.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:38.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:38.547]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:38.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:38.547]             base::names(...future.oldOptions))
[13:33:38.547]     }
[13:33:38.547]     if (FALSE) {
[13:33:38.547]     }
[13:33:38.547]     else {
[13:33:38.547]         if (TRUE) {
[13:33:38.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:38.547]                 open = "w")
[13:33:38.547]         }
[13:33:38.547]         else {
[13:33:38.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:38.547]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:38.547]         }
[13:33:38.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:38.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:38.547]             base::sink(type = "output", split = FALSE)
[13:33:38.547]             base::close(...future.stdout)
[13:33:38.547]         }, add = TRUE)
[13:33:38.547]     }
[13:33:38.547]     ...future.frame <- base::sys.nframe()
[13:33:38.547]     ...future.conditions <- base::list()
[13:33:38.547]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:38.547]     if (FALSE) {
[13:33:38.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:38.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:38.547]     }
[13:33:38.547]     ...future.result <- base::tryCatch({
[13:33:38.547]         base::withCallingHandlers({
[13:33:38.547]             ...future.value <- base::withVisible(base::local({
[13:33:38.547]                 ...future.makeSendCondition <- base::local({
[13:33:38.547]                   sendCondition <- NULL
[13:33:38.547]                   function(frame = 1L) {
[13:33:38.547]                     if (is.function(sendCondition)) 
[13:33:38.547]                       return(sendCondition)
[13:33:38.547]                     ns <- getNamespace("parallel")
[13:33:38.547]                     if (exists("sendData", mode = "function", 
[13:33:38.547]                       envir = ns)) {
[13:33:38.547]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:38.547]                         envir = ns)
[13:33:38.547]                       envir <- sys.frame(frame)
[13:33:38.547]                       master <- NULL
[13:33:38.547]                       while (!identical(envir, .GlobalEnv) && 
[13:33:38.547]                         !identical(envir, emptyenv())) {
[13:33:38.547]                         if (exists("master", mode = "list", envir = envir, 
[13:33:38.547]                           inherits = FALSE)) {
[13:33:38.547]                           master <- get("master", mode = "list", 
[13:33:38.547]                             envir = envir, inherits = FALSE)
[13:33:38.547]                           if (inherits(master, c("SOCKnode", 
[13:33:38.547]                             "SOCK0node"))) {
[13:33:38.547]                             sendCondition <<- function(cond) {
[13:33:38.547]                               data <- list(type = "VALUE", value = cond, 
[13:33:38.547]                                 success = TRUE)
[13:33:38.547]                               parallel_sendData(master, data)
[13:33:38.547]                             }
[13:33:38.547]                             return(sendCondition)
[13:33:38.547]                           }
[13:33:38.547]                         }
[13:33:38.547]                         frame <- frame + 1L
[13:33:38.547]                         envir <- sys.frame(frame)
[13:33:38.547]                       }
[13:33:38.547]                     }
[13:33:38.547]                     sendCondition <<- function(cond) NULL
[13:33:38.547]                   }
[13:33:38.547]                 })
[13:33:38.547]                 withCallingHandlers({
[13:33:38.547]                   {
[13:33:38.547]                     do.call(function(...) {
[13:33:38.547]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.547]                       if (!identical(...future.globals.maxSize.org, 
[13:33:38.547]                         ...future.globals.maxSize)) {
[13:33:38.547]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.547]                         on.exit(options(oopts), add = TRUE)
[13:33:38.547]                       }
[13:33:38.547]                       {
[13:33:38.547]                         lapply(seq_along(...future.elements_ii), 
[13:33:38.547]                           FUN = function(jj) {
[13:33:38.547]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.547]                             ...future.FUN(...future.X_jj, ...)
[13:33:38.547]                           })
[13:33:38.547]                       }
[13:33:38.547]                     }, args = future.call.arguments)
[13:33:38.547]                   }
[13:33:38.547]                 }, immediateCondition = function(cond) {
[13:33:38.547]                   sendCondition <- ...future.makeSendCondition()
[13:33:38.547]                   sendCondition(cond)
[13:33:38.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.547]                   {
[13:33:38.547]                     inherits <- base::inherits
[13:33:38.547]                     invokeRestart <- base::invokeRestart
[13:33:38.547]                     is.null <- base::is.null
[13:33:38.547]                     muffled <- FALSE
[13:33:38.547]                     if (inherits(cond, "message")) {
[13:33:38.547]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:38.547]                       if (muffled) 
[13:33:38.547]                         invokeRestart("muffleMessage")
[13:33:38.547]                     }
[13:33:38.547]                     else if (inherits(cond, "warning")) {
[13:33:38.547]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:38.547]                       if (muffled) 
[13:33:38.547]                         invokeRestart("muffleWarning")
[13:33:38.547]                     }
[13:33:38.547]                     else if (inherits(cond, "condition")) {
[13:33:38.547]                       if (!is.null(pattern)) {
[13:33:38.547]                         computeRestarts <- base::computeRestarts
[13:33:38.547]                         grepl <- base::grepl
[13:33:38.547]                         restarts <- computeRestarts(cond)
[13:33:38.547]                         for (restart in restarts) {
[13:33:38.547]                           name <- restart$name
[13:33:38.547]                           if (is.null(name)) 
[13:33:38.547]                             next
[13:33:38.547]                           if (!grepl(pattern, name)) 
[13:33:38.547]                             next
[13:33:38.547]                           invokeRestart(restart)
[13:33:38.547]                           muffled <- TRUE
[13:33:38.547]                           break
[13:33:38.547]                         }
[13:33:38.547]                       }
[13:33:38.547]                     }
[13:33:38.547]                     invisible(muffled)
[13:33:38.547]                   }
[13:33:38.547]                   muffleCondition(cond)
[13:33:38.547]                 })
[13:33:38.547]             }))
[13:33:38.547]             future::FutureResult(value = ...future.value$value, 
[13:33:38.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:38.547]                   ...future.rng), globalenv = if (FALSE) 
[13:33:38.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:38.547]                     ...future.globalenv.names))
[13:33:38.547]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:38.547]         }, condition = base::local({
[13:33:38.547]             c <- base::c
[13:33:38.547]             inherits <- base::inherits
[13:33:38.547]             invokeRestart <- base::invokeRestart
[13:33:38.547]             length <- base::length
[13:33:38.547]             list <- base::list
[13:33:38.547]             seq.int <- base::seq.int
[13:33:38.547]             signalCondition <- base::signalCondition
[13:33:38.547]             sys.calls <- base::sys.calls
[13:33:38.547]             `[[` <- base::`[[`
[13:33:38.547]             `+` <- base::`+`
[13:33:38.547]             `<<-` <- base::`<<-`
[13:33:38.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:38.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:38.547]                   3L)]
[13:33:38.547]             }
[13:33:38.547]             function(cond) {
[13:33:38.547]                 is_error <- inherits(cond, "error")
[13:33:38.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:38.547]                   NULL)
[13:33:38.547]                 if (is_error) {
[13:33:38.547]                   sessionInformation <- function() {
[13:33:38.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:38.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:38.547]                       search = base::search(), system = base::Sys.info())
[13:33:38.547]                   }
[13:33:38.547]                   ...future.conditions[[length(...future.conditions) + 
[13:33:38.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:38.547]                     cond$call), session = sessionInformation(), 
[13:33:38.547]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:38.547]                   signalCondition(cond)
[13:33:38.547]                 }
[13:33:38.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:38.547]                 "immediateCondition"))) {
[13:33:38.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:38.547]                   ...future.conditions[[length(...future.conditions) + 
[13:33:38.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:38.547]                   if (TRUE && !signal) {
[13:33:38.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.547]                     {
[13:33:38.547]                       inherits <- base::inherits
[13:33:38.547]                       invokeRestart <- base::invokeRestart
[13:33:38.547]                       is.null <- base::is.null
[13:33:38.547]                       muffled <- FALSE
[13:33:38.547]                       if (inherits(cond, "message")) {
[13:33:38.547]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:38.547]                         if (muffled) 
[13:33:38.547]                           invokeRestart("muffleMessage")
[13:33:38.547]                       }
[13:33:38.547]                       else if (inherits(cond, "warning")) {
[13:33:38.547]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:38.547]                         if (muffled) 
[13:33:38.547]                           invokeRestart("muffleWarning")
[13:33:38.547]                       }
[13:33:38.547]                       else if (inherits(cond, "condition")) {
[13:33:38.547]                         if (!is.null(pattern)) {
[13:33:38.547]                           computeRestarts <- base::computeRestarts
[13:33:38.547]                           grepl <- base::grepl
[13:33:38.547]                           restarts <- computeRestarts(cond)
[13:33:38.547]                           for (restart in restarts) {
[13:33:38.547]                             name <- restart$name
[13:33:38.547]                             if (is.null(name)) 
[13:33:38.547]                               next
[13:33:38.547]                             if (!grepl(pattern, name)) 
[13:33:38.547]                               next
[13:33:38.547]                             invokeRestart(restart)
[13:33:38.547]                             muffled <- TRUE
[13:33:38.547]                             break
[13:33:38.547]                           }
[13:33:38.547]                         }
[13:33:38.547]                       }
[13:33:38.547]                       invisible(muffled)
[13:33:38.547]                     }
[13:33:38.547]                     muffleCondition(cond, pattern = "^muffle")
[13:33:38.547]                   }
[13:33:38.547]                 }
[13:33:38.547]                 else {
[13:33:38.547]                   if (TRUE) {
[13:33:38.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.547]                     {
[13:33:38.547]                       inherits <- base::inherits
[13:33:38.547]                       invokeRestart <- base::invokeRestart
[13:33:38.547]                       is.null <- base::is.null
[13:33:38.547]                       muffled <- FALSE
[13:33:38.547]                       if (inherits(cond, "message")) {
[13:33:38.547]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:38.547]                         if (muffled) 
[13:33:38.547]                           invokeRestart("muffleMessage")
[13:33:38.547]                       }
[13:33:38.547]                       else if (inherits(cond, "warning")) {
[13:33:38.547]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:38.547]                         if (muffled) 
[13:33:38.547]                           invokeRestart("muffleWarning")
[13:33:38.547]                       }
[13:33:38.547]                       else if (inherits(cond, "condition")) {
[13:33:38.547]                         if (!is.null(pattern)) {
[13:33:38.547]                           computeRestarts <- base::computeRestarts
[13:33:38.547]                           grepl <- base::grepl
[13:33:38.547]                           restarts <- computeRestarts(cond)
[13:33:38.547]                           for (restart in restarts) {
[13:33:38.547]                             name <- restart$name
[13:33:38.547]                             if (is.null(name)) 
[13:33:38.547]                               next
[13:33:38.547]                             if (!grepl(pattern, name)) 
[13:33:38.547]                               next
[13:33:38.547]                             invokeRestart(restart)
[13:33:38.547]                             muffled <- TRUE
[13:33:38.547]                             break
[13:33:38.547]                           }
[13:33:38.547]                         }
[13:33:38.547]                       }
[13:33:38.547]                       invisible(muffled)
[13:33:38.547]                     }
[13:33:38.547]                     muffleCondition(cond, pattern = "^muffle")
[13:33:38.547]                   }
[13:33:38.547]                 }
[13:33:38.547]             }
[13:33:38.547]         }))
[13:33:38.547]     }, error = function(ex) {
[13:33:38.547]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:38.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:38.547]                 ...future.rng), started = ...future.startTime, 
[13:33:38.547]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:38.547]             version = "1.8"), class = "FutureResult")
[13:33:38.547]     }, finally = {
[13:33:38.547]         if (!identical(...future.workdir, getwd())) 
[13:33:38.547]             setwd(...future.workdir)
[13:33:38.547]         {
[13:33:38.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:38.547]                 ...future.oldOptions$nwarnings <- NULL
[13:33:38.547]             }
[13:33:38.547]             base::options(...future.oldOptions)
[13:33:38.547]             if (.Platform$OS.type == "windows") {
[13:33:38.547]                 old_names <- names(...future.oldEnvVars)
[13:33:38.547]                 envs <- base::Sys.getenv()
[13:33:38.547]                 names <- names(envs)
[13:33:38.547]                 common <- intersect(names, old_names)
[13:33:38.547]                 added <- setdiff(names, old_names)
[13:33:38.547]                 removed <- setdiff(old_names, names)
[13:33:38.547]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:38.547]                   envs[common]]
[13:33:38.547]                 NAMES <- toupper(changed)
[13:33:38.547]                 args <- list()
[13:33:38.547]                 for (kk in seq_along(NAMES)) {
[13:33:38.547]                   name <- changed[[kk]]
[13:33:38.547]                   NAME <- NAMES[[kk]]
[13:33:38.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.547]                     next
[13:33:38.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:38.547]                 }
[13:33:38.547]                 NAMES <- toupper(added)
[13:33:38.547]                 for (kk in seq_along(NAMES)) {
[13:33:38.547]                   name <- added[[kk]]
[13:33:38.547]                   NAME <- NAMES[[kk]]
[13:33:38.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.547]                     next
[13:33:38.547]                   args[[name]] <- ""
[13:33:38.547]                 }
[13:33:38.547]                 NAMES <- toupper(removed)
[13:33:38.547]                 for (kk in seq_along(NAMES)) {
[13:33:38.547]                   name <- removed[[kk]]
[13:33:38.547]                   NAME <- NAMES[[kk]]
[13:33:38.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.547]                     next
[13:33:38.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:38.547]                 }
[13:33:38.547]                 if (length(args) > 0) 
[13:33:38.547]                   base::do.call(base::Sys.setenv, args = args)
[13:33:38.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:38.547]             }
[13:33:38.547]             else {
[13:33:38.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:38.547]             }
[13:33:38.547]             {
[13:33:38.547]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:38.547]                   0L) {
[13:33:38.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:38.547]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:38.547]                   base::options(opts)
[13:33:38.547]                 }
[13:33:38.547]                 {
[13:33:38.547]                   {
[13:33:38.547]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:38.547]                     NULL
[13:33:38.547]                   }
[13:33:38.547]                   options(future.plan = NULL)
[13:33:38.547]                   if (is.na(NA_character_)) 
[13:33:38.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:38.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:38.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:38.547]                     .init = FALSE)
[13:33:38.547]                 }
[13:33:38.547]             }
[13:33:38.547]         }
[13:33:38.547]     })
[13:33:38.547]     if (TRUE) {
[13:33:38.547]         base::sink(type = "output", split = FALSE)
[13:33:38.547]         if (TRUE) {
[13:33:38.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:38.547]         }
[13:33:38.547]         else {
[13:33:38.547]             ...future.result["stdout"] <- base::list(NULL)
[13:33:38.547]         }
[13:33:38.547]         base::close(...future.stdout)
[13:33:38.547]         ...future.stdout <- NULL
[13:33:38.547]     }
[13:33:38.547]     ...future.result$conditions <- ...future.conditions
[13:33:38.547]     ...future.result$finished <- base::Sys.time()
[13:33:38.547]     ...future.result
[13:33:38.547] }
[13:33:38.550] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[13:33:38.551] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:38.551] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:38.551] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[13:33:38.595] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[13:33:38.595] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[13:33:38.595] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[13:33:38.596] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:38.596] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:38.596] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:38.596] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:38.596] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[13:33:38.597] MultisessionFuture started
[13:33:38.597] - Launch lazy future ... done
[13:33:38.597] run() for ‘MultisessionFuture’ ... done
[13:33:38.597] Created future:
[13:33:38.597] MultisessionFuture:
[13:33:38.597] Label: ‘future_apply-1’
[13:33:38.597] Expression:
[13:33:38.597] {
[13:33:38.597]     do.call(function(...) {
[13:33:38.597]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.597]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:38.597]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.597]             on.exit(options(oopts), add = TRUE)
[13:33:38.597]         }
[13:33:38.597]         {
[13:33:38.597]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:38.597]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.597]                 ...future.FUN(...future.X_jj, ...)
[13:33:38.597]             })
[13:33:38.597]         }
[13:33:38.597]     }, args = future.call.arguments)
[13:33:38.597] }
[13:33:38.597] Lazy evaluation: FALSE
[13:33:38.597] Asynchronous evaluation: TRUE
[13:33:38.597] Local evaluation: TRUE
[13:33:38.597] Environment: R_GlobalEnv
[13:33:38.597] Capture standard output: TRUE
[13:33:38.597] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:38.597] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:38.597] Packages: <none>
[13:33:38.597] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:38.597] Resolved: FALSE
[13:33:38.597] Value: <not collected>
[13:33:38.597] Conditions captured: <none>
[13:33:38.597] Early signaling: FALSE
[13:33:38.597] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:38.597] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:38.609] Chunk #1 of 2 ... DONE
[13:33:38.609] Chunk #2 of 2 ...
[13:33:38.609]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:38.610]  - seeds: <none>
[13:33:38.610]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.610] getGlobalsAndPackages() ...
[13:33:38.610] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.610] Resolving globals: FALSE
[13:33:38.610] Tweak future expression to call with '...' arguments ...
[13:33:38.610] {
[13:33:38.610]     do.call(function(...) {
[13:33:38.610]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.610]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:38.610]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.610]             on.exit(options(oopts), add = TRUE)
[13:33:38.610]         }
[13:33:38.610]         {
[13:33:38.610]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:38.610]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.610]                 ...future.FUN(...future.X_jj, ...)
[13:33:38.610]             })
[13:33:38.610]         }
[13:33:38.610]     }, args = future.call.arguments)
[13:33:38.610] }
[13:33:38.610] Tweak future expression to call with '...' arguments ... DONE
[13:33:38.611] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.611] 
[13:33:38.611] getGlobalsAndPackages() ... DONE
[13:33:38.611] run() for ‘Future’ ...
[13:33:38.611] - state: ‘created’
[13:33:38.612] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:38.625] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:38.625] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:38.626]   - Field: ‘node’
[13:33:38.626]   - Field: ‘label’
[13:33:38.626]   - Field: ‘local’
[13:33:38.626]   - Field: ‘owner’
[13:33:38.626]   - Field: ‘envir’
[13:33:38.626]   - Field: ‘workers’
[13:33:38.626]   - Field: ‘packages’
[13:33:38.626]   - Field: ‘gc’
[13:33:38.626]   - Field: ‘conditions’
[13:33:38.626]   - Field: ‘persistent’
[13:33:38.628]   - Field: ‘expr’
[13:33:38.629]   - Field: ‘uuid’
[13:33:38.629]   - Field: ‘seed’
[13:33:38.629]   - Field: ‘version’
[13:33:38.629]   - Field: ‘result’
[13:33:38.629]   - Field: ‘asynchronous’
[13:33:38.629]   - Field: ‘calls’
[13:33:38.629]   - Field: ‘globals’
[13:33:38.629]   - Field: ‘stdout’
[13:33:38.629]   - Field: ‘earlySignal’
[13:33:38.629]   - Field: ‘lazy’
[13:33:38.629]   - Field: ‘state’
[13:33:38.630] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:38.630] - Launch lazy future ...
[13:33:38.630] Packages needed by the future expression (n = 0): <none>
[13:33:38.630] Packages needed by future strategies (n = 0): <none>
[13:33:38.630] {
[13:33:38.630]     {
[13:33:38.630]         {
[13:33:38.630]             ...future.startTime <- base::Sys.time()
[13:33:38.630]             {
[13:33:38.630]                 {
[13:33:38.630]                   {
[13:33:38.630]                     {
[13:33:38.630]                       base::local({
[13:33:38.630]                         has_future <- base::requireNamespace("future", 
[13:33:38.630]                           quietly = TRUE)
[13:33:38.630]                         if (has_future) {
[13:33:38.630]                           ns <- base::getNamespace("future")
[13:33:38.630]                           version <- ns[[".package"]][["version"]]
[13:33:38.630]                           if (is.null(version)) 
[13:33:38.630]                             version <- utils::packageVersion("future")
[13:33:38.630]                         }
[13:33:38.630]                         else {
[13:33:38.630]                           version <- NULL
[13:33:38.630]                         }
[13:33:38.630]                         if (!has_future || version < "1.8.0") {
[13:33:38.630]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:38.630]                             "", base::R.version$version.string), 
[13:33:38.630]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:38.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:38.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:38.630]                               "release", "version")], collapse = " "), 
[13:33:38.630]                             hostname = base::Sys.info()[["nodename"]])
[13:33:38.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:38.630]                             info)
[13:33:38.630]                           info <- base::paste(info, collapse = "; ")
[13:33:38.630]                           if (!has_future) {
[13:33:38.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:38.630]                               info)
[13:33:38.630]                           }
[13:33:38.630]                           else {
[13:33:38.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:38.630]                               info, version)
[13:33:38.630]                           }
[13:33:38.630]                           base::stop(msg)
[13:33:38.630]                         }
[13:33:38.630]                       })
[13:33:38.630]                     }
[13:33:38.630]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:38.630]                     base::options(mc.cores = 1L)
[13:33:38.630]                   }
[13:33:38.630]                   ...future.strategy.old <- future::plan("list")
[13:33:38.630]                   options(future.plan = NULL)
[13:33:38.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:38.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:38.630]                 }
[13:33:38.630]                 ...future.workdir <- getwd()
[13:33:38.630]             }
[13:33:38.630]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:38.630]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:38.630]         }
[13:33:38.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:38.630]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:38.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:38.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:38.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:38.630]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:38.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:38.630]             base::names(...future.oldOptions))
[13:33:38.630]     }
[13:33:38.630]     if (FALSE) {
[13:33:38.630]     }
[13:33:38.630]     else {
[13:33:38.630]         if (TRUE) {
[13:33:38.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:38.630]                 open = "w")
[13:33:38.630]         }
[13:33:38.630]         else {
[13:33:38.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:38.630]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:38.630]         }
[13:33:38.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:38.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:38.630]             base::sink(type = "output", split = FALSE)
[13:33:38.630]             base::close(...future.stdout)
[13:33:38.630]         }, add = TRUE)
[13:33:38.630]     }
[13:33:38.630]     ...future.frame <- base::sys.nframe()
[13:33:38.630]     ...future.conditions <- base::list()
[13:33:38.630]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:38.630]     if (FALSE) {
[13:33:38.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:38.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:38.630]     }
[13:33:38.630]     ...future.result <- base::tryCatch({
[13:33:38.630]         base::withCallingHandlers({
[13:33:38.630]             ...future.value <- base::withVisible(base::local({
[13:33:38.630]                 ...future.makeSendCondition <- base::local({
[13:33:38.630]                   sendCondition <- NULL
[13:33:38.630]                   function(frame = 1L) {
[13:33:38.630]                     if (is.function(sendCondition)) 
[13:33:38.630]                       return(sendCondition)
[13:33:38.630]                     ns <- getNamespace("parallel")
[13:33:38.630]                     if (exists("sendData", mode = "function", 
[13:33:38.630]                       envir = ns)) {
[13:33:38.630]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:38.630]                         envir = ns)
[13:33:38.630]                       envir <- sys.frame(frame)
[13:33:38.630]                       master <- NULL
[13:33:38.630]                       while (!identical(envir, .GlobalEnv) && 
[13:33:38.630]                         !identical(envir, emptyenv())) {
[13:33:38.630]                         if (exists("master", mode = "list", envir = envir, 
[13:33:38.630]                           inherits = FALSE)) {
[13:33:38.630]                           master <- get("master", mode = "list", 
[13:33:38.630]                             envir = envir, inherits = FALSE)
[13:33:38.630]                           if (inherits(master, c("SOCKnode", 
[13:33:38.630]                             "SOCK0node"))) {
[13:33:38.630]                             sendCondition <<- function(cond) {
[13:33:38.630]                               data <- list(type = "VALUE", value = cond, 
[13:33:38.630]                                 success = TRUE)
[13:33:38.630]                               parallel_sendData(master, data)
[13:33:38.630]                             }
[13:33:38.630]                             return(sendCondition)
[13:33:38.630]                           }
[13:33:38.630]                         }
[13:33:38.630]                         frame <- frame + 1L
[13:33:38.630]                         envir <- sys.frame(frame)
[13:33:38.630]                       }
[13:33:38.630]                     }
[13:33:38.630]                     sendCondition <<- function(cond) NULL
[13:33:38.630]                   }
[13:33:38.630]                 })
[13:33:38.630]                 withCallingHandlers({
[13:33:38.630]                   {
[13:33:38.630]                     do.call(function(...) {
[13:33:38.630]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.630]                       if (!identical(...future.globals.maxSize.org, 
[13:33:38.630]                         ...future.globals.maxSize)) {
[13:33:38.630]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.630]                         on.exit(options(oopts), add = TRUE)
[13:33:38.630]                       }
[13:33:38.630]                       {
[13:33:38.630]                         lapply(seq_along(...future.elements_ii), 
[13:33:38.630]                           FUN = function(jj) {
[13:33:38.630]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.630]                             ...future.FUN(...future.X_jj, ...)
[13:33:38.630]                           })
[13:33:38.630]                       }
[13:33:38.630]                     }, args = future.call.arguments)
[13:33:38.630]                   }
[13:33:38.630]                 }, immediateCondition = function(cond) {
[13:33:38.630]                   sendCondition <- ...future.makeSendCondition()
[13:33:38.630]                   sendCondition(cond)
[13:33:38.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.630]                   {
[13:33:38.630]                     inherits <- base::inherits
[13:33:38.630]                     invokeRestart <- base::invokeRestart
[13:33:38.630]                     is.null <- base::is.null
[13:33:38.630]                     muffled <- FALSE
[13:33:38.630]                     if (inherits(cond, "message")) {
[13:33:38.630]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:38.630]                       if (muffled) 
[13:33:38.630]                         invokeRestart("muffleMessage")
[13:33:38.630]                     }
[13:33:38.630]                     else if (inherits(cond, "warning")) {
[13:33:38.630]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:38.630]                       if (muffled) 
[13:33:38.630]                         invokeRestart("muffleWarning")
[13:33:38.630]                     }
[13:33:38.630]                     else if (inherits(cond, "condition")) {
[13:33:38.630]                       if (!is.null(pattern)) {
[13:33:38.630]                         computeRestarts <- base::computeRestarts
[13:33:38.630]                         grepl <- base::grepl
[13:33:38.630]                         restarts <- computeRestarts(cond)
[13:33:38.630]                         for (restart in restarts) {
[13:33:38.630]                           name <- restart$name
[13:33:38.630]                           if (is.null(name)) 
[13:33:38.630]                             next
[13:33:38.630]                           if (!grepl(pattern, name)) 
[13:33:38.630]                             next
[13:33:38.630]                           invokeRestart(restart)
[13:33:38.630]                           muffled <- TRUE
[13:33:38.630]                           break
[13:33:38.630]                         }
[13:33:38.630]                       }
[13:33:38.630]                     }
[13:33:38.630]                     invisible(muffled)
[13:33:38.630]                   }
[13:33:38.630]                   muffleCondition(cond)
[13:33:38.630]                 })
[13:33:38.630]             }))
[13:33:38.630]             future::FutureResult(value = ...future.value$value, 
[13:33:38.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:38.630]                   ...future.rng), globalenv = if (FALSE) 
[13:33:38.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:38.630]                     ...future.globalenv.names))
[13:33:38.630]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:38.630]         }, condition = base::local({
[13:33:38.630]             c <- base::c
[13:33:38.630]             inherits <- base::inherits
[13:33:38.630]             invokeRestart <- base::invokeRestart
[13:33:38.630]             length <- base::length
[13:33:38.630]             list <- base::list
[13:33:38.630]             seq.int <- base::seq.int
[13:33:38.630]             signalCondition <- base::signalCondition
[13:33:38.630]             sys.calls <- base::sys.calls
[13:33:38.630]             `[[` <- base::`[[`
[13:33:38.630]             `+` <- base::`+`
[13:33:38.630]             `<<-` <- base::`<<-`
[13:33:38.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:38.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:38.630]                   3L)]
[13:33:38.630]             }
[13:33:38.630]             function(cond) {
[13:33:38.630]                 is_error <- inherits(cond, "error")
[13:33:38.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:38.630]                   NULL)
[13:33:38.630]                 if (is_error) {
[13:33:38.630]                   sessionInformation <- function() {
[13:33:38.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:38.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:38.630]                       search = base::search(), system = base::Sys.info())
[13:33:38.630]                   }
[13:33:38.630]                   ...future.conditions[[length(...future.conditions) + 
[13:33:38.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:38.630]                     cond$call), session = sessionInformation(), 
[13:33:38.630]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:38.630]                   signalCondition(cond)
[13:33:38.630]                 }
[13:33:38.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:38.630]                 "immediateCondition"))) {
[13:33:38.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:38.630]                   ...future.conditions[[length(...future.conditions) + 
[13:33:38.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:38.630]                   if (TRUE && !signal) {
[13:33:38.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.630]                     {
[13:33:38.630]                       inherits <- base::inherits
[13:33:38.630]                       invokeRestart <- base::invokeRestart
[13:33:38.630]                       is.null <- base::is.null
[13:33:38.630]                       muffled <- FALSE
[13:33:38.630]                       if (inherits(cond, "message")) {
[13:33:38.630]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:38.630]                         if (muffled) 
[13:33:38.630]                           invokeRestart("muffleMessage")
[13:33:38.630]                       }
[13:33:38.630]                       else if (inherits(cond, "warning")) {
[13:33:38.630]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:38.630]                         if (muffled) 
[13:33:38.630]                           invokeRestart("muffleWarning")
[13:33:38.630]                       }
[13:33:38.630]                       else if (inherits(cond, "condition")) {
[13:33:38.630]                         if (!is.null(pattern)) {
[13:33:38.630]                           computeRestarts <- base::computeRestarts
[13:33:38.630]                           grepl <- base::grepl
[13:33:38.630]                           restarts <- computeRestarts(cond)
[13:33:38.630]                           for (restart in restarts) {
[13:33:38.630]                             name <- restart$name
[13:33:38.630]                             if (is.null(name)) 
[13:33:38.630]                               next
[13:33:38.630]                             if (!grepl(pattern, name)) 
[13:33:38.630]                               next
[13:33:38.630]                             invokeRestart(restart)
[13:33:38.630]                             muffled <- TRUE
[13:33:38.630]                             break
[13:33:38.630]                           }
[13:33:38.630]                         }
[13:33:38.630]                       }
[13:33:38.630]                       invisible(muffled)
[13:33:38.630]                     }
[13:33:38.630]                     muffleCondition(cond, pattern = "^muffle")
[13:33:38.630]                   }
[13:33:38.630]                 }
[13:33:38.630]                 else {
[13:33:38.630]                   if (TRUE) {
[13:33:38.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.630]                     {
[13:33:38.630]                       inherits <- base::inherits
[13:33:38.630]                       invokeRestart <- base::invokeRestart
[13:33:38.630]                       is.null <- base::is.null
[13:33:38.630]                       muffled <- FALSE
[13:33:38.630]                       if (inherits(cond, "message")) {
[13:33:38.630]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:38.630]                         if (muffled) 
[13:33:38.630]                           invokeRestart("muffleMessage")
[13:33:38.630]                       }
[13:33:38.630]                       else if (inherits(cond, "warning")) {
[13:33:38.630]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:38.630]                         if (muffled) 
[13:33:38.630]                           invokeRestart("muffleWarning")
[13:33:38.630]                       }
[13:33:38.630]                       else if (inherits(cond, "condition")) {
[13:33:38.630]                         if (!is.null(pattern)) {
[13:33:38.630]                           computeRestarts <- base::computeRestarts
[13:33:38.630]                           grepl <- base::grepl
[13:33:38.630]                           restarts <- computeRestarts(cond)
[13:33:38.630]                           for (restart in restarts) {
[13:33:38.630]                             name <- restart$name
[13:33:38.630]                             if (is.null(name)) 
[13:33:38.630]                               next
[13:33:38.630]                             if (!grepl(pattern, name)) 
[13:33:38.630]                               next
[13:33:38.630]                             invokeRestart(restart)
[13:33:38.630]                             muffled <- TRUE
[13:33:38.630]                             break
[13:33:38.630]                           }
[13:33:38.630]                         }
[13:33:38.630]                       }
[13:33:38.630]                       invisible(muffled)
[13:33:38.630]                     }
[13:33:38.630]                     muffleCondition(cond, pattern = "^muffle")
[13:33:38.630]                   }
[13:33:38.630]                 }
[13:33:38.630]             }
[13:33:38.630]         }))
[13:33:38.630]     }, error = function(ex) {
[13:33:38.630]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:38.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:38.630]                 ...future.rng), started = ...future.startTime, 
[13:33:38.630]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:38.630]             version = "1.8"), class = "FutureResult")
[13:33:38.630]     }, finally = {
[13:33:38.630]         if (!identical(...future.workdir, getwd())) 
[13:33:38.630]             setwd(...future.workdir)
[13:33:38.630]         {
[13:33:38.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:38.630]                 ...future.oldOptions$nwarnings <- NULL
[13:33:38.630]             }
[13:33:38.630]             base::options(...future.oldOptions)
[13:33:38.630]             if (.Platform$OS.type == "windows") {
[13:33:38.630]                 old_names <- names(...future.oldEnvVars)
[13:33:38.630]                 envs <- base::Sys.getenv()
[13:33:38.630]                 names <- names(envs)
[13:33:38.630]                 common <- intersect(names, old_names)
[13:33:38.630]                 added <- setdiff(names, old_names)
[13:33:38.630]                 removed <- setdiff(old_names, names)
[13:33:38.630]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:38.630]                   envs[common]]
[13:33:38.630]                 NAMES <- toupper(changed)
[13:33:38.630]                 args <- list()
[13:33:38.630]                 for (kk in seq_along(NAMES)) {
[13:33:38.630]                   name <- changed[[kk]]
[13:33:38.630]                   NAME <- NAMES[[kk]]
[13:33:38.630]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.630]                     next
[13:33:38.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:38.630]                 }
[13:33:38.630]                 NAMES <- toupper(added)
[13:33:38.630]                 for (kk in seq_along(NAMES)) {
[13:33:38.630]                   name <- added[[kk]]
[13:33:38.630]                   NAME <- NAMES[[kk]]
[13:33:38.630]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.630]                     next
[13:33:38.630]                   args[[name]] <- ""
[13:33:38.630]                 }
[13:33:38.630]                 NAMES <- toupper(removed)
[13:33:38.630]                 for (kk in seq_along(NAMES)) {
[13:33:38.630]                   name <- removed[[kk]]
[13:33:38.630]                   NAME <- NAMES[[kk]]
[13:33:38.630]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.630]                     next
[13:33:38.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:38.630]                 }
[13:33:38.630]                 if (length(args) > 0) 
[13:33:38.630]                   base::do.call(base::Sys.setenv, args = args)
[13:33:38.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:38.630]             }
[13:33:38.630]             else {
[13:33:38.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:38.630]             }
[13:33:38.630]             {
[13:33:38.630]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:38.630]                   0L) {
[13:33:38.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:38.630]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:38.630]                   base::options(opts)
[13:33:38.630]                 }
[13:33:38.630]                 {
[13:33:38.630]                   {
[13:33:38.630]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:38.630]                     NULL
[13:33:38.630]                   }
[13:33:38.630]                   options(future.plan = NULL)
[13:33:38.630]                   if (is.na(NA_character_)) 
[13:33:38.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:38.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:38.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:38.630]                     .init = FALSE)
[13:33:38.630]                 }
[13:33:38.630]             }
[13:33:38.630]         }
[13:33:38.630]     })
[13:33:38.630]     if (TRUE) {
[13:33:38.630]         base::sink(type = "output", split = FALSE)
[13:33:38.630]         if (TRUE) {
[13:33:38.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:38.630]         }
[13:33:38.630]         else {
[13:33:38.630]             ...future.result["stdout"] <- base::list(NULL)
[13:33:38.630]         }
[13:33:38.630]         base::close(...future.stdout)
[13:33:38.630]         ...future.stdout <- NULL
[13:33:38.630]     }
[13:33:38.630]     ...future.result$conditions <- ...future.conditions
[13:33:38.630]     ...future.result$finished <- base::Sys.time()
[13:33:38.630]     ...future.result
[13:33:38.630] }
[13:33:38.683] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[13:33:38.683] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:38.683] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:38.684] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[13:33:38.727] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[13:33:38.727] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[13:33:38.727] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[13:33:38.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:38.728] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:38.728] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:33:38.728] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:33:38.728] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[13:33:38.729] MultisessionFuture started
[13:33:38.729] - Launch lazy future ... done
[13:33:38.729] run() for ‘MultisessionFuture’ ... done
[13:33:38.729] Created future:
[13:33:38.729] MultisessionFuture:
[13:33:38.729] Label: ‘future_apply-2’
[13:33:38.729] Expression:
[13:33:38.729] {
[13:33:38.729]     do.call(function(...) {
[13:33:38.729]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.729]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:38.729]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.729]             on.exit(options(oopts), add = TRUE)
[13:33:38.729]         }
[13:33:38.729]         {
[13:33:38.729]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:38.729]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.729]                 ...future.FUN(...future.X_jj, ...)
[13:33:38.729]             })
[13:33:38.729]         }
[13:33:38.729]     }, args = future.call.arguments)
[13:33:38.729] }
[13:33:38.729] Lazy evaluation: FALSE
[13:33:38.729] Asynchronous evaluation: TRUE
[13:33:38.729] Local evaluation: TRUE
[13:33:38.729] Environment: R_GlobalEnv
[13:33:38.729] Capture standard output: TRUE
[13:33:38.729] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:38.729] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:38.729] Packages: <none>
[13:33:38.729] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:38.729] Resolved: FALSE
[13:33:38.729] Value: <not collected>
[13:33:38.729] Conditions captured: <none>
[13:33:38.729] Early signaling: FALSE
[13:33:38.729] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:38.729] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:38.741] Chunk #2 of 2 ... DONE
[13:33:38.741] Launching 2 futures (chunks) ... DONE
[13:33:38.741] Resolving 2 futures (chunks) ...
[13:33:38.741] resolve() on list ...
[13:33:38.741]  recursive: 0
[13:33:38.741]  length: 2
[13:33:38.741] 
[13:33:38.742] receiveMessageFromWorker() for ClusterFuture ...
[13:33:38.742] - Validating connection of MultisessionFuture
[13:33:38.742] - received message: FutureResult
[13:33:38.742] - Received FutureResult
[13:33:38.742] - Erased future from FutureRegistry
[13:33:38.743] result() for ClusterFuture ...
[13:33:38.743] - result already collected: FutureResult
[13:33:38.743] result() for ClusterFuture ... done
[13:33:38.743] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:38.743] Future #1
[13:33:38.743] result() for ClusterFuture ...
[13:33:38.743] - result already collected: FutureResult
[13:33:38.743] result() for ClusterFuture ... done
[13:33:38.743] result() for ClusterFuture ...
[13:33:38.743] - result already collected: FutureResult
[13:33:38.743] result() for ClusterFuture ... done
[13:33:38.744] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:38.744] - nx: 2
[13:33:38.744] - relay: TRUE
[13:33:38.744] - stdout: TRUE
[13:33:38.744] - signal: TRUE
[13:33:38.744] - resignal: FALSE
[13:33:38.744] - force: TRUE
[13:33:38.744] - relayed: [n=2] FALSE, FALSE
[13:33:38.744] - queued futures: [n=2] FALSE, FALSE
[13:33:38.744]  - until=1
[13:33:38.744]  - relaying element #1
[13:33:38.744] result() for ClusterFuture ...
[13:33:38.745] - result already collected: FutureResult
[13:33:38.745] result() for ClusterFuture ... done
[13:33:38.745] result() for ClusterFuture ...
[13:33:38.745] - result already collected: FutureResult
[13:33:38.745] result() for ClusterFuture ... done
[13:33:38.745] result() for ClusterFuture ...
[13:33:38.745] - result already collected: FutureResult
[13:33:38.745] result() for ClusterFuture ... done
[13:33:38.745] result() for ClusterFuture ...
[13:33:38.745] - result already collected: FutureResult
[13:33:38.745] result() for ClusterFuture ... done
[13:33:38.745] - relayed: [n=2] TRUE, FALSE
[13:33:38.746] - queued futures: [n=2] TRUE, FALSE
[13:33:38.746] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:38.746]  length: 1 (resolved future 1)
[13:33:38.808] receiveMessageFromWorker() for ClusterFuture ...
[13:33:38.808] - Validating connection of MultisessionFuture
[13:33:38.808] - received message: FutureResult
[13:33:38.808] - Received FutureResult
[13:33:38.808] - Erased future from FutureRegistry
[13:33:38.809] result() for ClusterFuture ...
[13:33:38.809] - result already collected: FutureResult
[13:33:38.809] result() for ClusterFuture ... done
[13:33:38.809] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:38.809] Future #2
[13:33:38.809] result() for ClusterFuture ...
[13:33:38.809] - result already collected: FutureResult
[13:33:38.809] result() for ClusterFuture ... done
[13:33:38.809] result() for ClusterFuture ...
[13:33:38.809] - result already collected: FutureResult
[13:33:38.809] result() for ClusterFuture ... done
[13:33:38.810] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:38.810] - nx: 2
[13:33:38.810] - relay: TRUE
[13:33:38.810] - stdout: TRUE
[13:33:38.810] - signal: TRUE
[13:33:38.810] - resignal: FALSE
[13:33:38.810] - force: TRUE
[13:33:38.810] - relayed: [n=2] TRUE, FALSE
[13:33:38.810] - queued futures: [n=2] TRUE, FALSE
[13:33:38.810]  - until=2
[13:33:38.810]  - relaying element #2
[13:33:38.811] result() for ClusterFuture ...
[13:33:38.811] - result already collected: FutureResult
[13:33:38.811] result() for ClusterFuture ... done
[13:33:38.811] result() for ClusterFuture ...
[13:33:38.811] - result already collected: FutureResult
[13:33:38.811] result() for ClusterFuture ... done
[13:33:38.811] result() for ClusterFuture ...
[13:33:38.811] - result already collected: FutureResult
[13:33:38.811] result() for ClusterFuture ... done
[13:33:38.811] result() for ClusterFuture ...
[13:33:38.811] - result already collected: FutureResult
[13:33:38.812] result() for ClusterFuture ... done
[13:33:38.812] - relayed: [n=2] TRUE, TRUE
[13:33:38.812] - queued futures: [n=2] TRUE, TRUE
[13:33:38.812] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:38.812]  length: 0 (resolved future 2)
[13:33:38.812] Relaying remaining futures
[13:33:38.812] signalConditionsASAP(NULL, pos=0) ...
[13:33:38.812] - nx: 2
[13:33:38.812] - relay: TRUE
[13:33:38.812] - stdout: TRUE
[13:33:38.812] - signal: TRUE
[13:33:38.813] - resignal: FALSE
[13:33:38.813] - force: TRUE
[13:33:38.813] - relayed: [n=2] TRUE, TRUE
[13:33:38.813] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:38.813] - relayed: [n=2] TRUE, TRUE
[13:33:38.813] - queued futures: [n=2] TRUE, TRUE
[13:33:38.813] signalConditionsASAP(NULL, pos=0) ... done
[13:33:38.813] resolve() on list ... DONE
[13:33:38.813] result() for ClusterFuture ...
[13:33:38.813] - result already collected: FutureResult
[13:33:38.813] result() for ClusterFuture ... done
[13:33:38.813] result() for ClusterFuture ...
[13:33:38.814] - result already collected: FutureResult
[13:33:38.814] result() for ClusterFuture ... done
[13:33:38.814] result() for ClusterFuture ...
[13:33:38.814] - result already collected: FutureResult
[13:33:38.814] result() for ClusterFuture ... done
[13:33:38.814] result() for ClusterFuture ...
[13:33:38.814] - result already collected: FutureResult
[13:33:38.814] result() for ClusterFuture ... done
[13:33:38.814]  - Number of value chunks collected: 2
[13:33:38.814] Resolving 2 futures (chunks) ... DONE
[13:33:38.815] Reducing values from 2 chunks ...
[13:33:38.815]  - Number of values collected after concatenation: 2
[13:33:38.815]  - Number of values expected: 2
[13:33:38.815] Reducing values from 2 chunks ... DONE
[13:33:38.815] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:33:38.815] getGlobalsAndPackagesXApply() ...
[13:33:38.815]  - future.globals: TRUE
[13:33:38.816] getGlobalsAndPackages() ...
[13:33:38.816] Searching for globals...
[13:33:38.847] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:33:38.847] Searching for globals ... DONE
[13:33:38.847] Resolving globals: FALSE
[13:33:38.849] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:33:38.849] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:33:38.849] - globals: [1] ‘FUN’
[13:33:38.849] 
[13:33:38.849] getGlobalsAndPackages() ... DONE
[13:33:38.849]  - globals found/used: [n=1] ‘FUN’
[13:33:38.850]  - needed namespaces: [n=0] 
[13:33:38.850] Finding globals ... DONE
[13:33:38.850]  - use_args: TRUE
[13:33:38.850]  - Getting '...' globals ...
[13:33:38.850] resolve() on list ...
[13:33:38.850]  recursive: 0
[13:33:38.850]  length: 1
[13:33:38.850]  elements: ‘...’
[13:33:38.851]  length: 0 (resolved future 1)
[13:33:38.851] resolve() on list ... DONE
[13:33:38.851]    - '...' content: [n=0] 
[13:33:38.851] List of 1
[13:33:38.851]  $ ...: list()
[13:33:38.851]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:38.851]  - attr(*, "where")=List of 1
[13:33:38.851]   ..$ ...:<environment: 0x55b949463938> 
[13:33:38.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:38.851]  - attr(*, "resolved")= logi TRUE
[13:33:38.851]  - attr(*, "total_size")= num NA
[13:33:38.853]  - Getting '...' globals ... DONE
[13:33:38.854] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:38.854] List of 2
[13:33:38.854]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:38.854]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:38.854]  $ ...          : list()
[13:33:38.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:38.854]  - attr(*, "where")=List of 2
[13:33:38.854]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:38.854]   ..$ ...          :<environment: 0x55b949463938> 
[13:33:38.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:38.854]  - attr(*, "resolved")= logi FALSE
[13:33:38.854]  - attr(*, "total_size")= num 354224
[13:33:38.856] Packages to be attached in all futures: [n=0] 
[13:33:38.856] getGlobalsAndPackagesXApply() ... DONE
[13:33:38.860] future_lapply() ...
[13:33:38.894] Number of chunks: 2
[13:33:38.895] getGlobalsAndPackagesXApply() ...
[13:33:38.895]  - future.globals: <name-value list> with names ‘list()’
[13:33:38.895]  - use_args: TRUE
[13:33:38.895] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:38.895] List of 2
[13:33:38.895]  $ ...          : list()
[13:33:38.895]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:38.895]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:33:38.895]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:33:38.895]  - attr(*, "where")=List of 2
[13:33:38.895]   ..$ ...          :<environment: 0x55b949463938> 
[13:33:38.895]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:38.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:38.895]  - attr(*, "resolved")= logi FALSE
[13:33:38.895]  - attr(*, "total_size")= num NA
[13:33:38.898] Packages to be attached in all futures: [n=0] 
[13:33:38.898] getGlobalsAndPackagesXApply() ... DONE
[13:33:38.899] Number of futures (= number of chunks): 2
[13:33:38.899] Launching 2 futures (chunks) ...
[13:33:38.899] Chunk #1 of 2 ...
[13:33:38.899]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:38.899]  - seeds: <none>
[13:33:38.899]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.899] getGlobalsAndPackages() ...
[13:33:38.899] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.899] Resolving globals: FALSE
[13:33:38.900] Tweak future expression to call with '...' arguments ...
[13:33:38.900] {
[13:33:38.900]     do.call(function(...) {
[13:33:38.900]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.900]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:38.900]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.900]             on.exit(options(oopts), add = TRUE)
[13:33:38.900]         }
[13:33:38.900]         {
[13:33:38.900]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:38.900]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.900]                 ...future.FUN(...future.X_jj, ...)
[13:33:38.900]             })
[13:33:38.900]         }
[13:33:38.900]     }, args = future.call.arguments)
[13:33:38.900] }
[13:33:38.900] Tweak future expression to call with '...' arguments ... DONE
[13:33:38.900] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.900] 
[13:33:38.900] getGlobalsAndPackages() ... DONE
[13:33:38.901] run() for ‘Future’ ...
[13:33:38.901] - state: ‘created’
[13:33:38.901] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:38.914] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:38.914] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:38.915]   - Field: ‘node’
[13:33:38.915]   - Field: ‘label’
[13:33:38.915]   - Field: ‘local’
[13:33:38.915]   - Field: ‘owner’
[13:33:38.915]   - Field: ‘envir’
[13:33:38.915]   - Field: ‘workers’
[13:33:38.915]   - Field: ‘packages’
[13:33:38.915]   - Field: ‘gc’
[13:33:38.915]   - Field: ‘conditions’
[13:33:38.915]   - Field: ‘persistent’
[13:33:38.915]   - Field: ‘expr’
[13:33:38.916]   - Field: ‘uuid’
[13:33:38.916]   - Field: ‘seed’
[13:33:38.916]   - Field: ‘version’
[13:33:38.916]   - Field: ‘result’
[13:33:38.916]   - Field: ‘asynchronous’
[13:33:38.916]   - Field: ‘calls’
[13:33:38.916]   - Field: ‘globals’
[13:33:38.916]   - Field: ‘stdout’
[13:33:38.916]   - Field: ‘earlySignal’
[13:33:38.916]   - Field: ‘lazy’
[13:33:38.916]   - Field: ‘state’
[13:33:38.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:38.917] - Launch lazy future ...
[13:33:38.917] Packages needed by the future expression (n = 0): <none>
[13:33:38.917] Packages needed by future strategies (n = 0): <none>
[13:33:38.917] {
[13:33:38.917]     {
[13:33:38.917]         {
[13:33:38.917]             ...future.startTime <- base::Sys.time()
[13:33:38.917]             {
[13:33:38.917]                 {
[13:33:38.917]                   {
[13:33:38.917]                     {
[13:33:38.917]                       base::local({
[13:33:38.917]                         has_future <- base::requireNamespace("future", 
[13:33:38.917]                           quietly = TRUE)
[13:33:38.917]                         if (has_future) {
[13:33:38.917]                           ns <- base::getNamespace("future")
[13:33:38.917]                           version <- ns[[".package"]][["version"]]
[13:33:38.917]                           if (is.null(version)) 
[13:33:38.917]                             version <- utils::packageVersion("future")
[13:33:38.917]                         }
[13:33:38.917]                         else {
[13:33:38.917]                           version <- NULL
[13:33:38.917]                         }
[13:33:38.917]                         if (!has_future || version < "1.8.0") {
[13:33:38.917]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:38.917]                             "", base::R.version$version.string), 
[13:33:38.917]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:38.917]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:38.917]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:38.917]                               "release", "version")], collapse = " "), 
[13:33:38.917]                             hostname = base::Sys.info()[["nodename"]])
[13:33:38.917]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:38.917]                             info)
[13:33:38.917]                           info <- base::paste(info, collapse = "; ")
[13:33:38.917]                           if (!has_future) {
[13:33:38.917]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:38.917]                               info)
[13:33:38.917]                           }
[13:33:38.917]                           else {
[13:33:38.917]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:38.917]                               info, version)
[13:33:38.917]                           }
[13:33:38.917]                           base::stop(msg)
[13:33:38.917]                         }
[13:33:38.917]                       })
[13:33:38.917]                     }
[13:33:38.917]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:38.917]                     base::options(mc.cores = 1L)
[13:33:38.917]                   }
[13:33:38.917]                   ...future.strategy.old <- future::plan("list")
[13:33:38.917]                   options(future.plan = NULL)
[13:33:38.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:38.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:38.917]                 }
[13:33:38.917]                 ...future.workdir <- getwd()
[13:33:38.917]             }
[13:33:38.917]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:38.917]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:38.917]         }
[13:33:38.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:38.917]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:38.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:38.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:38.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:38.917]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:38.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:38.917]             base::names(...future.oldOptions))
[13:33:38.917]     }
[13:33:38.917]     if (FALSE) {
[13:33:38.917]     }
[13:33:38.917]     else {
[13:33:38.917]         if (TRUE) {
[13:33:38.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:38.917]                 open = "w")
[13:33:38.917]         }
[13:33:38.917]         else {
[13:33:38.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:38.917]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:38.917]         }
[13:33:38.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:38.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:38.917]             base::sink(type = "output", split = FALSE)
[13:33:38.917]             base::close(...future.stdout)
[13:33:38.917]         }, add = TRUE)
[13:33:38.917]     }
[13:33:38.917]     ...future.frame <- base::sys.nframe()
[13:33:38.917]     ...future.conditions <- base::list()
[13:33:38.917]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:38.917]     if (FALSE) {
[13:33:38.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:38.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:38.917]     }
[13:33:38.917]     ...future.result <- base::tryCatch({
[13:33:38.917]         base::withCallingHandlers({
[13:33:38.917]             ...future.value <- base::withVisible(base::local({
[13:33:38.917]                 ...future.makeSendCondition <- base::local({
[13:33:38.917]                   sendCondition <- NULL
[13:33:38.917]                   function(frame = 1L) {
[13:33:38.917]                     if (is.function(sendCondition)) 
[13:33:38.917]                       return(sendCondition)
[13:33:38.917]                     ns <- getNamespace("parallel")
[13:33:38.917]                     if (exists("sendData", mode = "function", 
[13:33:38.917]                       envir = ns)) {
[13:33:38.917]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:38.917]                         envir = ns)
[13:33:38.917]                       envir <- sys.frame(frame)
[13:33:38.917]                       master <- NULL
[13:33:38.917]                       while (!identical(envir, .GlobalEnv) && 
[13:33:38.917]                         !identical(envir, emptyenv())) {
[13:33:38.917]                         if (exists("master", mode = "list", envir = envir, 
[13:33:38.917]                           inherits = FALSE)) {
[13:33:38.917]                           master <- get("master", mode = "list", 
[13:33:38.917]                             envir = envir, inherits = FALSE)
[13:33:38.917]                           if (inherits(master, c("SOCKnode", 
[13:33:38.917]                             "SOCK0node"))) {
[13:33:38.917]                             sendCondition <<- function(cond) {
[13:33:38.917]                               data <- list(type = "VALUE", value = cond, 
[13:33:38.917]                                 success = TRUE)
[13:33:38.917]                               parallel_sendData(master, data)
[13:33:38.917]                             }
[13:33:38.917]                             return(sendCondition)
[13:33:38.917]                           }
[13:33:38.917]                         }
[13:33:38.917]                         frame <- frame + 1L
[13:33:38.917]                         envir <- sys.frame(frame)
[13:33:38.917]                       }
[13:33:38.917]                     }
[13:33:38.917]                     sendCondition <<- function(cond) NULL
[13:33:38.917]                   }
[13:33:38.917]                 })
[13:33:38.917]                 withCallingHandlers({
[13:33:38.917]                   {
[13:33:38.917]                     do.call(function(...) {
[13:33:38.917]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.917]                       if (!identical(...future.globals.maxSize.org, 
[13:33:38.917]                         ...future.globals.maxSize)) {
[13:33:38.917]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.917]                         on.exit(options(oopts), add = TRUE)
[13:33:38.917]                       }
[13:33:38.917]                       {
[13:33:38.917]                         lapply(seq_along(...future.elements_ii), 
[13:33:38.917]                           FUN = function(jj) {
[13:33:38.917]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.917]                             ...future.FUN(...future.X_jj, ...)
[13:33:38.917]                           })
[13:33:38.917]                       }
[13:33:38.917]                     }, args = future.call.arguments)
[13:33:38.917]                   }
[13:33:38.917]                 }, immediateCondition = function(cond) {
[13:33:38.917]                   sendCondition <- ...future.makeSendCondition()
[13:33:38.917]                   sendCondition(cond)
[13:33:38.917]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.917]                   {
[13:33:38.917]                     inherits <- base::inherits
[13:33:38.917]                     invokeRestart <- base::invokeRestart
[13:33:38.917]                     is.null <- base::is.null
[13:33:38.917]                     muffled <- FALSE
[13:33:38.917]                     if (inherits(cond, "message")) {
[13:33:38.917]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:38.917]                       if (muffled) 
[13:33:38.917]                         invokeRestart("muffleMessage")
[13:33:38.917]                     }
[13:33:38.917]                     else if (inherits(cond, "warning")) {
[13:33:38.917]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:38.917]                       if (muffled) 
[13:33:38.917]                         invokeRestart("muffleWarning")
[13:33:38.917]                     }
[13:33:38.917]                     else if (inherits(cond, "condition")) {
[13:33:38.917]                       if (!is.null(pattern)) {
[13:33:38.917]                         computeRestarts <- base::computeRestarts
[13:33:38.917]                         grepl <- base::grepl
[13:33:38.917]                         restarts <- computeRestarts(cond)
[13:33:38.917]                         for (restart in restarts) {
[13:33:38.917]                           name <- restart$name
[13:33:38.917]                           if (is.null(name)) 
[13:33:38.917]                             next
[13:33:38.917]                           if (!grepl(pattern, name)) 
[13:33:38.917]                             next
[13:33:38.917]                           invokeRestart(restart)
[13:33:38.917]                           muffled <- TRUE
[13:33:38.917]                           break
[13:33:38.917]                         }
[13:33:38.917]                       }
[13:33:38.917]                     }
[13:33:38.917]                     invisible(muffled)
[13:33:38.917]                   }
[13:33:38.917]                   muffleCondition(cond)
[13:33:38.917]                 })
[13:33:38.917]             }))
[13:33:38.917]             future::FutureResult(value = ...future.value$value, 
[13:33:38.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:38.917]                   ...future.rng), globalenv = if (FALSE) 
[13:33:38.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:38.917]                     ...future.globalenv.names))
[13:33:38.917]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:38.917]         }, condition = base::local({
[13:33:38.917]             c <- base::c
[13:33:38.917]             inherits <- base::inherits
[13:33:38.917]             invokeRestart <- base::invokeRestart
[13:33:38.917]             length <- base::length
[13:33:38.917]             list <- base::list
[13:33:38.917]             seq.int <- base::seq.int
[13:33:38.917]             signalCondition <- base::signalCondition
[13:33:38.917]             sys.calls <- base::sys.calls
[13:33:38.917]             `[[` <- base::`[[`
[13:33:38.917]             `+` <- base::`+`
[13:33:38.917]             `<<-` <- base::`<<-`
[13:33:38.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:38.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:38.917]                   3L)]
[13:33:38.917]             }
[13:33:38.917]             function(cond) {
[13:33:38.917]                 is_error <- inherits(cond, "error")
[13:33:38.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:38.917]                   NULL)
[13:33:38.917]                 if (is_error) {
[13:33:38.917]                   sessionInformation <- function() {
[13:33:38.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:38.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:38.917]                       search = base::search(), system = base::Sys.info())
[13:33:38.917]                   }
[13:33:38.917]                   ...future.conditions[[length(...future.conditions) + 
[13:33:38.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:38.917]                     cond$call), session = sessionInformation(), 
[13:33:38.917]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:38.917]                   signalCondition(cond)
[13:33:38.917]                 }
[13:33:38.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:38.917]                 "immediateCondition"))) {
[13:33:38.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:38.917]                   ...future.conditions[[length(...future.conditions) + 
[13:33:38.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:38.917]                   if (TRUE && !signal) {
[13:33:38.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.917]                     {
[13:33:38.917]                       inherits <- base::inherits
[13:33:38.917]                       invokeRestart <- base::invokeRestart
[13:33:38.917]                       is.null <- base::is.null
[13:33:38.917]                       muffled <- FALSE
[13:33:38.917]                       if (inherits(cond, "message")) {
[13:33:38.917]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:38.917]                         if (muffled) 
[13:33:38.917]                           invokeRestart("muffleMessage")
[13:33:38.917]                       }
[13:33:38.917]                       else if (inherits(cond, "warning")) {
[13:33:38.917]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:38.917]                         if (muffled) 
[13:33:38.917]                           invokeRestart("muffleWarning")
[13:33:38.917]                       }
[13:33:38.917]                       else if (inherits(cond, "condition")) {
[13:33:38.917]                         if (!is.null(pattern)) {
[13:33:38.917]                           computeRestarts <- base::computeRestarts
[13:33:38.917]                           grepl <- base::grepl
[13:33:38.917]                           restarts <- computeRestarts(cond)
[13:33:38.917]                           for (restart in restarts) {
[13:33:38.917]                             name <- restart$name
[13:33:38.917]                             if (is.null(name)) 
[13:33:38.917]                               next
[13:33:38.917]                             if (!grepl(pattern, name)) 
[13:33:38.917]                               next
[13:33:38.917]                             invokeRestart(restart)
[13:33:38.917]                             muffled <- TRUE
[13:33:38.917]                             break
[13:33:38.917]                           }
[13:33:38.917]                         }
[13:33:38.917]                       }
[13:33:38.917]                       invisible(muffled)
[13:33:38.917]                     }
[13:33:38.917]                     muffleCondition(cond, pattern = "^muffle")
[13:33:38.917]                   }
[13:33:38.917]                 }
[13:33:38.917]                 else {
[13:33:38.917]                   if (TRUE) {
[13:33:38.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.917]                     {
[13:33:38.917]                       inherits <- base::inherits
[13:33:38.917]                       invokeRestart <- base::invokeRestart
[13:33:38.917]                       is.null <- base::is.null
[13:33:38.917]                       muffled <- FALSE
[13:33:38.917]                       if (inherits(cond, "message")) {
[13:33:38.917]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:38.917]                         if (muffled) 
[13:33:38.917]                           invokeRestart("muffleMessage")
[13:33:38.917]                       }
[13:33:38.917]                       else if (inherits(cond, "warning")) {
[13:33:38.917]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:38.917]                         if (muffled) 
[13:33:38.917]                           invokeRestart("muffleWarning")
[13:33:38.917]                       }
[13:33:38.917]                       else if (inherits(cond, "condition")) {
[13:33:38.917]                         if (!is.null(pattern)) {
[13:33:38.917]                           computeRestarts <- base::computeRestarts
[13:33:38.917]                           grepl <- base::grepl
[13:33:38.917]                           restarts <- computeRestarts(cond)
[13:33:38.917]                           for (restart in restarts) {
[13:33:38.917]                             name <- restart$name
[13:33:38.917]                             if (is.null(name)) 
[13:33:38.917]                               next
[13:33:38.917]                             if (!grepl(pattern, name)) 
[13:33:38.917]                               next
[13:33:38.917]                             invokeRestart(restart)
[13:33:38.917]                             muffled <- TRUE
[13:33:38.917]                             break
[13:33:38.917]                           }
[13:33:38.917]                         }
[13:33:38.917]                       }
[13:33:38.917]                       invisible(muffled)
[13:33:38.917]                     }
[13:33:38.917]                     muffleCondition(cond, pattern = "^muffle")
[13:33:38.917]                   }
[13:33:38.917]                 }
[13:33:38.917]             }
[13:33:38.917]         }))
[13:33:38.917]     }, error = function(ex) {
[13:33:38.917]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:38.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:38.917]                 ...future.rng), started = ...future.startTime, 
[13:33:38.917]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:38.917]             version = "1.8"), class = "FutureResult")
[13:33:38.917]     }, finally = {
[13:33:38.917]         if (!identical(...future.workdir, getwd())) 
[13:33:38.917]             setwd(...future.workdir)
[13:33:38.917]         {
[13:33:38.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:38.917]                 ...future.oldOptions$nwarnings <- NULL
[13:33:38.917]             }
[13:33:38.917]             base::options(...future.oldOptions)
[13:33:38.917]             if (.Platform$OS.type == "windows") {
[13:33:38.917]                 old_names <- names(...future.oldEnvVars)
[13:33:38.917]                 envs <- base::Sys.getenv()
[13:33:38.917]                 names <- names(envs)
[13:33:38.917]                 common <- intersect(names, old_names)
[13:33:38.917]                 added <- setdiff(names, old_names)
[13:33:38.917]                 removed <- setdiff(old_names, names)
[13:33:38.917]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:38.917]                   envs[common]]
[13:33:38.917]                 NAMES <- toupper(changed)
[13:33:38.917]                 args <- list()
[13:33:38.917]                 for (kk in seq_along(NAMES)) {
[13:33:38.917]                   name <- changed[[kk]]
[13:33:38.917]                   NAME <- NAMES[[kk]]
[13:33:38.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.917]                     next
[13:33:38.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:38.917]                 }
[13:33:38.917]                 NAMES <- toupper(added)
[13:33:38.917]                 for (kk in seq_along(NAMES)) {
[13:33:38.917]                   name <- added[[kk]]
[13:33:38.917]                   NAME <- NAMES[[kk]]
[13:33:38.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.917]                     next
[13:33:38.917]                   args[[name]] <- ""
[13:33:38.917]                 }
[13:33:38.917]                 NAMES <- toupper(removed)
[13:33:38.917]                 for (kk in seq_along(NAMES)) {
[13:33:38.917]                   name <- removed[[kk]]
[13:33:38.917]                   NAME <- NAMES[[kk]]
[13:33:38.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.917]                     next
[13:33:38.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:38.917]                 }
[13:33:38.917]                 if (length(args) > 0) 
[13:33:38.917]                   base::do.call(base::Sys.setenv, args = args)
[13:33:38.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:38.917]             }
[13:33:38.917]             else {
[13:33:38.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:38.917]             }
[13:33:38.917]             {
[13:33:38.917]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:38.917]                   0L) {
[13:33:38.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:38.917]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:38.917]                   base::options(opts)
[13:33:38.917]                 }
[13:33:38.917]                 {
[13:33:38.917]                   {
[13:33:38.917]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:38.917]                     NULL
[13:33:38.917]                   }
[13:33:38.917]                   options(future.plan = NULL)
[13:33:38.917]                   if (is.na(NA_character_)) 
[13:33:38.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:38.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:38.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:38.917]                     .init = FALSE)
[13:33:38.917]                 }
[13:33:38.917]             }
[13:33:38.917]         }
[13:33:38.917]     })
[13:33:38.917]     if (TRUE) {
[13:33:38.917]         base::sink(type = "output", split = FALSE)
[13:33:38.917]         if (TRUE) {
[13:33:38.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:38.917]         }
[13:33:38.917]         else {
[13:33:38.917]             ...future.result["stdout"] <- base::list(NULL)
[13:33:38.917]         }
[13:33:38.917]         base::close(...future.stdout)
[13:33:38.917]         ...future.stdout <- NULL
[13:33:38.917]     }
[13:33:38.917]     ...future.result$conditions <- ...future.conditions
[13:33:38.917]     ...future.result$finished <- base::Sys.time()
[13:33:38.917]     ...future.result
[13:33:38.917] }
[13:33:38.920] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[13:33:38.921] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:38.921] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:38.921] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[13:33:38.963] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[13:33:38.963] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[13:33:38.963] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[13:33:38.963] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:38.964] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:38.964] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:38.964] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:38.964] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[13:33:38.965] MultisessionFuture started
[13:33:38.965] - Launch lazy future ... done
[13:33:38.965] run() for ‘MultisessionFuture’ ... done
[13:33:38.965] Created future:
[13:33:38.965] MultisessionFuture:
[13:33:38.965] Label: ‘future_apply-1’
[13:33:38.965] Expression:
[13:33:38.965] {
[13:33:38.965]     do.call(function(...) {
[13:33:38.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:38.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.965]             on.exit(options(oopts), add = TRUE)
[13:33:38.965]         }
[13:33:38.965]         {
[13:33:38.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:38.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.965]                 ...future.FUN(...future.X_jj, ...)
[13:33:38.965]             })
[13:33:38.965]         }
[13:33:38.965]     }, args = future.call.arguments)
[13:33:38.965] }
[13:33:38.965] Lazy evaluation: FALSE
[13:33:38.965] Asynchronous evaluation: TRUE
[13:33:38.965] Local evaluation: TRUE
[13:33:38.965] Environment: R_GlobalEnv
[13:33:38.965] Capture standard output: TRUE
[13:33:38.965] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:38.965] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:38.965] Packages: <none>
[13:33:38.965] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:38.965] Resolved: FALSE
[13:33:38.965] Value: <not collected>
[13:33:38.965] Conditions captured: <none>
[13:33:38.965] Early signaling: FALSE
[13:33:38.965] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:38.965] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:38.977] Chunk #1 of 2 ... DONE
[13:33:38.977] Chunk #2 of 2 ...
[13:33:38.977]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:38.977]  - seeds: <none>
[13:33:38.977]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.977] getGlobalsAndPackages() ...
[13:33:38.977] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.978] Resolving globals: FALSE
[13:33:38.978] Tweak future expression to call with '...' arguments ...
[13:33:38.978] {
[13:33:38.978]     do.call(function(...) {
[13:33:38.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:38.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.978]             on.exit(options(oopts), add = TRUE)
[13:33:38.978]         }
[13:33:38.978]         {
[13:33:38.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:38.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.978]                 ...future.FUN(...future.X_jj, ...)
[13:33:38.978]             })
[13:33:38.978]         }
[13:33:38.978]     }, args = future.call.arguments)
[13:33:38.978] }
[13:33:38.978] Tweak future expression to call with '...' arguments ... DONE
[13:33:38.978] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:38.979] 
[13:33:38.979] getGlobalsAndPackages() ... DONE
[13:33:38.979] run() for ‘Future’ ...
[13:33:38.979] - state: ‘created’
[13:33:38.979] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:38.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:38.993] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:38.993]   - Field: ‘node’
[13:33:38.993]   - Field: ‘label’
[13:33:38.993]   - Field: ‘local’
[13:33:38.993]   - Field: ‘owner’
[13:33:38.993]   - Field: ‘envir’
[13:33:38.993]   - Field: ‘workers’
[13:33:38.993]   - Field: ‘packages’
[13:33:38.993]   - Field: ‘gc’
[13:33:38.994]   - Field: ‘conditions’
[13:33:38.994]   - Field: ‘persistent’
[13:33:38.994]   - Field: ‘expr’
[13:33:38.994]   - Field: ‘uuid’
[13:33:38.994]   - Field: ‘seed’
[13:33:38.994]   - Field: ‘version’
[13:33:38.994]   - Field: ‘result’
[13:33:38.994]   - Field: ‘asynchronous’
[13:33:38.994]   - Field: ‘calls’
[13:33:38.994]   - Field: ‘globals’
[13:33:38.995]   - Field: ‘stdout’
[13:33:38.995]   - Field: ‘earlySignal’
[13:33:38.995]   - Field: ‘lazy’
[13:33:38.995]   - Field: ‘state’
[13:33:38.995] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:38.995] - Launch lazy future ...
[13:33:38.995] Packages needed by the future expression (n = 0): <none>
[13:33:38.995] Packages needed by future strategies (n = 0): <none>
[13:33:38.996] {
[13:33:38.996]     {
[13:33:38.996]         {
[13:33:38.996]             ...future.startTime <- base::Sys.time()
[13:33:38.996]             {
[13:33:38.996]                 {
[13:33:38.996]                   {
[13:33:38.996]                     {
[13:33:38.996]                       base::local({
[13:33:38.996]                         has_future <- base::requireNamespace("future", 
[13:33:38.996]                           quietly = TRUE)
[13:33:38.996]                         if (has_future) {
[13:33:38.996]                           ns <- base::getNamespace("future")
[13:33:38.996]                           version <- ns[[".package"]][["version"]]
[13:33:38.996]                           if (is.null(version)) 
[13:33:38.996]                             version <- utils::packageVersion("future")
[13:33:38.996]                         }
[13:33:38.996]                         else {
[13:33:38.996]                           version <- NULL
[13:33:38.996]                         }
[13:33:38.996]                         if (!has_future || version < "1.8.0") {
[13:33:38.996]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:38.996]                             "", base::R.version$version.string), 
[13:33:38.996]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:38.996]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:38.996]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:38.996]                               "release", "version")], collapse = " "), 
[13:33:38.996]                             hostname = base::Sys.info()[["nodename"]])
[13:33:38.996]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:38.996]                             info)
[13:33:38.996]                           info <- base::paste(info, collapse = "; ")
[13:33:38.996]                           if (!has_future) {
[13:33:38.996]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:38.996]                               info)
[13:33:38.996]                           }
[13:33:38.996]                           else {
[13:33:38.996]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:38.996]                               info, version)
[13:33:38.996]                           }
[13:33:38.996]                           base::stop(msg)
[13:33:38.996]                         }
[13:33:38.996]                       })
[13:33:38.996]                     }
[13:33:38.996]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:38.996]                     base::options(mc.cores = 1L)
[13:33:38.996]                   }
[13:33:38.996]                   ...future.strategy.old <- future::plan("list")
[13:33:38.996]                   options(future.plan = NULL)
[13:33:38.996]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:38.996]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:38.996]                 }
[13:33:38.996]                 ...future.workdir <- getwd()
[13:33:38.996]             }
[13:33:38.996]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:38.996]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:38.996]         }
[13:33:38.996]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:38.996]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:38.996]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:38.996]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:38.996]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:38.996]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:38.996]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:38.996]             base::names(...future.oldOptions))
[13:33:38.996]     }
[13:33:38.996]     if (FALSE) {
[13:33:38.996]     }
[13:33:38.996]     else {
[13:33:38.996]         if (TRUE) {
[13:33:38.996]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:38.996]                 open = "w")
[13:33:38.996]         }
[13:33:38.996]         else {
[13:33:38.996]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:38.996]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:38.996]         }
[13:33:38.996]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:38.996]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:38.996]             base::sink(type = "output", split = FALSE)
[13:33:38.996]             base::close(...future.stdout)
[13:33:38.996]         }, add = TRUE)
[13:33:38.996]     }
[13:33:38.996]     ...future.frame <- base::sys.nframe()
[13:33:38.996]     ...future.conditions <- base::list()
[13:33:38.996]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:38.996]     if (FALSE) {
[13:33:38.996]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:38.996]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:38.996]     }
[13:33:38.996]     ...future.result <- base::tryCatch({
[13:33:38.996]         base::withCallingHandlers({
[13:33:38.996]             ...future.value <- base::withVisible(base::local({
[13:33:38.996]                 ...future.makeSendCondition <- base::local({
[13:33:38.996]                   sendCondition <- NULL
[13:33:38.996]                   function(frame = 1L) {
[13:33:38.996]                     if (is.function(sendCondition)) 
[13:33:38.996]                       return(sendCondition)
[13:33:38.996]                     ns <- getNamespace("parallel")
[13:33:38.996]                     if (exists("sendData", mode = "function", 
[13:33:38.996]                       envir = ns)) {
[13:33:38.996]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:38.996]                         envir = ns)
[13:33:38.996]                       envir <- sys.frame(frame)
[13:33:38.996]                       master <- NULL
[13:33:38.996]                       while (!identical(envir, .GlobalEnv) && 
[13:33:38.996]                         !identical(envir, emptyenv())) {
[13:33:38.996]                         if (exists("master", mode = "list", envir = envir, 
[13:33:38.996]                           inherits = FALSE)) {
[13:33:38.996]                           master <- get("master", mode = "list", 
[13:33:38.996]                             envir = envir, inherits = FALSE)
[13:33:38.996]                           if (inherits(master, c("SOCKnode", 
[13:33:38.996]                             "SOCK0node"))) {
[13:33:38.996]                             sendCondition <<- function(cond) {
[13:33:38.996]                               data <- list(type = "VALUE", value = cond, 
[13:33:38.996]                                 success = TRUE)
[13:33:38.996]                               parallel_sendData(master, data)
[13:33:38.996]                             }
[13:33:38.996]                             return(sendCondition)
[13:33:38.996]                           }
[13:33:38.996]                         }
[13:33:38.996]                         frame <- frame + 1L
[13:33:38.996]                         envir <- sys.frame(frame)
[13:33:38.996]                       }
[13:33:38.996]                     }
[13:33:38.996]                     sendCondition <<- function(cond) NULL
[13:33:38.996]                   }
[13:33:38.996]                 })
[13:33:38.996]                 withCallingHandlers({
[13:33:38.996]                   {
[13:33:38.996]                     do.call(function(...) {
[13:33:38.996]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:38.996]                       if (!identical(...future.globals.maxSize.org, 
[13:33:38.996]                         ...future.globals.maxSize)) {
[13:33:38.996]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:38.996]                         on.exit(options(oopts), add = TRUE)
[13:33:38.996]                       }
[13:33:38.996]                       {
[13:33:38.996]                         lapply(seq_along(...future.elements_ii), 
[13:33:38.996]                           FUN = function(jj) {
[13:33:38.996]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:38.996]                             ...future.FUN(...future.X_jj, ...)
[13:33:38.996]                           })
[13:33:38.996]                       }
[13:33:38.996]                     }, args = future.call.arguments)
[13:33:38.996]                   }
[13:33:38.996]                 }, immediateCondition = function(cond) {
[13:33:38.996]                   sendCondition <- ...future.makeSendCondition()
[13:33:38.996]                   sendCondition(cond)
[13:33:38.996]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.996]                   {
[13:33:38.996]                     inherits <- base::inherits
[13:33:38.996]                     invokeRestart <- base::invokeRestart
[13:33:38.996]                     is.null <- base::is.null
[13:33:38.996]                     muffled <- FALSE
[13:33:38.996]                     if (inherits(cond, "message")) {
[13:33:38.996]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:38.996]                       if (muffled) 
[13:33:38.996]                         invokeRestart("muffleMessage")
[13:33:38.996]                     }
[13:33:38.996]                     else if (inherits(cond, "warning")) {
[13:33:38.996]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:38.996]                       if (muffled) 
[13:33:38.996]                         invokeRestart("muffleWarning")
[13:33:38.996]                     }
[13:33:38.996]                     else if (inherits(cond, "condition")) {
[13:33:38.996]                       if (!is.null(pattern)) {
[13:33:38.996]                         computeRestarts <- base::computeRestarts
[13:33:38.996]                         grepl <- base::grepl
[13:33:38.996]                         restarts <- computeRestarts(cond)
[13:33:38.996]                         for (restart in restarts) {
[13:33:38.996]                           name <- restart$name
[13:33:38.996]                           if (is.null(name)) 
[13:33:38.996]                             next
[13:33:38.996]                           if (!grepl(pattern, name)) 
[13:33:38.996]                             next
[13:33:38.996]                           invokeRestart(restart)
[13:33:38.996]                           muffled <- TRUE
[13:33:38.996]                           break
[13:33:38.996]                         }
[13:33:38.996]                       }
[13:33:38.996]                     }
[13:33:38.996]                     invisible(muffled)
[13:33:38.996]                   }
[13:33:38.996]                   muffleCondition(cond)
[13:33:38.996]                 })
[13:33:38.996]             }))
[13:33:38.996]             future::FutureResult(value = ...future.value$value, 
[13:33:38.996]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:38.996]                   ...future.rng), globalenv = if (FALSE) 
[13:33:38.996]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:38.996]                     ...future.globalenv.names))
[13:33:38.996]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:38.996]         }, condition = base::local({
[13:33:38.996]             c <- base::c
[13:33:38.996]             inherits <- base::inherits
[13:33:38.996]             invokeRestart <- base::invokeRestart
[13:33:38.996]             length <- base::length
[13:33:38.996]             list <- base::list
[13:33:38.996]             seq.int <- base::seq.int
[13:33:38.996]             signalCondition <- base::signalCondition
[13:33:38.996]             sys.calls <- base::sys.calls
[13:33:38.996]             `[[` <- base::`[[`
[13:33:38.996]             `+` <- base::`+`
[13:33:38.996]             `<<-` <- base::`<<-`
[13:33:38.996]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:38.996]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:38.996]                   3L)]
[13:33:38.996]             }
[13:33:38.996]             function(cond) {
[13:33:38.996]                 is_error <- inherits(cond, "error")
[13:33:38.996]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:38.996]                   NULL)
[13:33:38.996]                 if (is_error) {
[13:33:38.996]                   sessionInformation <- function() {
[13:33:38.996]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:38.996]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:38.996]                       search = base::search(), system = base::Sys.info())
[13:33:38.996]                   }
[13:33:38.996]                   ...future.conditions[[length(...future.conditions) + 
[13:33:38.996]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:38.996]                     cond$call), session = sessionInformation(), 
[13:33:38.996]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:38.996]                   signalCondition(cond)
[13:33:38.996]                 }
[13:33:38.996]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:38.996]                 "immediateCondition"))) {
[13:33:38.996]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:38.996]                   ...future.conditions[[length(...future.conditions) + 
[13:33:38.996]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:38.996]                   if (TRUE && !signal) {
[13:33:38.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.996]                     {
[13:33:38.996]                       inherits <- base::inherits
[13:33:38.996]                       invokeRestart <- base::invokeRestart
[13:33:38.996]                       is.null <- base::is.null
[13:33:38.996]                       muffled <- FALSE
[13:33:38.996]                       if (inherits(cond, "message")) {
[13:33:38.996]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:38.996]                         if (muffled) 
[13:33:38.996]                           invokeRestart("muffleMessage")
[13:33:38.996]                       }
[13:33:38.996]                       else if (inherits(cond, "warning")) {
[13:33:38.996]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:38.996]                         if (muffled) 
[13:33:38.996]                           invokeRestart("muffleWarning")
[13:33:38.996]                       }
[13:33:38.996]                       else if (inherits(cond, "condition")) {
[13:33:38.996]                         if (!is.null(pattern)) {
[13:33:38.996]                           computeRestarts <- base::computeRestarts
[13:33:38.996]                           grepl <- base::grepl
[13:33:38.996]                           restarts <- computeRestarts(cond)
[13:33:38.996]                           for (restart in restarts) {
[13:33:38.996]                             name <- restart$name
[13:33:38.996]                             if (is.null(name)) 
[13:33:38.996]                               next
[13:33:38.996]                             if (!grepl(pattern, name)) 
[13:33:38.996]                               next
[13:33:38.996]                             invokeRestart(restart)
[13:33:38.996]                             muffled <- TRUE
[13:33:38.996]                             break
[13:33:38.996]                           }
[13:33:38.996]                         }
[13:33:38.996]                       }
[13:33:38.996]                       invisible(muffled)
[13:33:38.996]                     }
[13:33:38.996]                     muffleCondition(cond, pattern = "^muffle")
[13:33:38.996]                   }
[13:33:38.996]                 }
[13:33:38.996]                 else {
[13:33:38.996]                   if (TRUE) {
[13:33:38.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:38.996]                     {
[13:33:38.996]                       inherits <- base::inherits
[13:33:38.996]                       invokeRestart <- base::invokeRestart
[13:33:38.996]                       is.null <- base::is.null
[13:33:38.996]                       muffled <- FALSE
[13:33:38.996]                       if (inherits(cond, "message")) {
[13:33:38.996]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:38.996]                         if (muffled) 
[13:33:38.996]                           invokeRestart("muffleMessage")
[13:33:38.996]                       }
[13:33:38.996]                       else if (inherits(cond, "warning")) {
[13:33:38.996]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:38.996]                         if (muffled) 
[13:33:38.996]                           invokeRestart("muffleWarning")
[13:33:38.996]                       }
[13:33:38.996]                       else if (inherits(cond, "condition")) {
[13:33:38.996]                         if (!is.null(pattern)) {
[13:33:38.996]                           computeRestarts <- base::computeRestarts
[13:33:38.996]                           grepl <- base::grepl
[13:33:38.996]                           restarts <- computeRestarts(cond)
[13:33:38.996]                           for (restart in restarts) {
[13:33:38.996]                             name <- restart$name
[13:33:38.996]                             if (is.null(name)) 
[13:33:38.996]                               next
[13:33:38.996]                             if (!grepl(pattern, name)) 
[13:33:38.996]                               next
[13:33:38.996]                             invokeRestart(restart)
[13:33:38.996]                             muffled <- TRUE
[13:33:38.996]                             break
[13:33:38.996]                           }
[13:33:38.996]                         }
[13:33:38.996]                       }
[13:33:38.996]                       invisible(muffled)
[13:33:38.996]                     }
[13:33:38.996]                     muffleCondition(cond, pattern = "^muffle")
[13:33:38.996]                   }
[13:33:38.996]                 }
[13:33:38.996]             }
[13:33:38.996]         }))
[13:33:38.996]     }, error = function(ex) {
[13:33:38.996]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:38.996]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:38.996]                 ...future.rng), started = ...future.startTime, 
[13:33:38.996]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:38.996]             version = "1.8"), class = "FutureResult")
[13:33:38.996]     }, finally = {
[13:33:38.996]         if (!identical(...future.workdir, getwd())) 
[13:33:38.996]             setwd(...future.workdir)
[13:33:38.996]         {
[13:33:38.996]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:38.996]                 ...future.oldOptions$nwarnings <- NULL
[13:33:38.996]             }
[13:33:38.996]             base::options(...future.oldOptions)
[13:33:38.996]             if (.Platform$OS.type == "windows") {
[13:33:38.996]                 old_names <- names(...future.oldEnvVars)
[13:33:38.996]                 envs <- base::Sys.getenv()
[13:33:38.996]                 names <- names(envs)
[13:33:38.996]                 common <- intersect(names, old_names)
[13:33:38.996]                 added <- setdiff(names, old_names)
[13:33:38.996]                 removed <- setdiff(old_names, names)
[13:33:38.996]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:38.996]                   envs[common]]
[13:33:38.996]                 NAMES <- toupper(changed)
[13:33:38.996]                 args <- list()
[13:33:38.996]                 for (kk in seq_along(NAMES)) {
[13:33:38.996]                   name <- changed[[kk]]
[13:33:38.996]                   NAME <- NAMES[[kk]]
[13:33:38.996]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.996]                     next
[13:33:38.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:38.996]                 }
[13:33:38.996]                 NAMES <- toupper(added)
[13:33:38.996]                 for (kk in seq_along(NAMES)) {
[13:33:38.996]                   name <- added[[kk]]
[13:33:38.996]                   NAME <- NAMES[[kk]]
[13:33:38.996]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.996]                     next
[13:33:38.996]                   args[[name]] <- ""
[13:33:38.996]                 }
[13:33:38.996]                 NAMES <- toupper(removed)
[13:33:38.996]                 for (kk in seq_along(NAMES)) {
[13:33:38.996]                   name <- removed[[kk]]
[13:33:38.996]                   NAME <- NAMES[[kk]]
[13:33:38.996]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:38.996]                     next
[13:33:38.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:38.996]                 }
[13:33:38.996]                 if (length(args) > 0) 
[13:33:38.996]                   base::do.call(base::Sys.setenv, args = args)
[13:33:38.996]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:38.996]             }
[13:33:38.996]             else {
[13:33:38.996]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:38.996]             }
[13:33:38.996]             {
[13:33:38.996]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:38.996]                   0L) {
[13:33:38.996]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:38.996]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:38.996]                   base::options(opts)
[13:33:38.996]                 }
[13:33:38.996]                 {
[13:33:38.996]                   {
[13:33:38.996]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:38.996]                     NULL
[13:33:38.996]                   }
[13:33:38.996]                   options(future.plan = NULL)
[13:33:38.996]                   if (is.na(NA_character_)) 
[13:33:38.996]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:38.996]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:38.996]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:38.996]                     .init = FALSE)
[13:33:38.996]                 }
[13:33:38.996]             }
[13:33:38.996]         }
[13:33:38.996]     })
[13:33:38.996]     if (TRUE) {
[13:33:38.996]         base::sink(type = "output", split = FALSE)
[13:33:38.996]         if (TRUE) {
[13:33:38.996]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:38.996]         }
[13:33:38.996]         else {
[13:33:38.996]             ...future.result["stdout"] <- base::list(NULL)
[13:33:38.996]         }
[13:33:38.996]         base::close(...future.stdout)
[13:33:38.996]         ...future.stdout <- NULL
[13:33:38.996]     }
[13:33:38.996]     ...future.result$conditions <- ...future.conditions
[13:33:38.996]     ...future.result$finished <- base::Sys.time()
[13:33:38.996]     ...future.result
[13:33:38.996] }
[13:33:38.999] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[13:33:38.999] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:39.003] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.004] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[13:33:39.047] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[13:33:39.047] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[13:33:39.047] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[13:33:39.048] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:39.048] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.048] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:33:39.048] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:33:39.048] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[13:33:39.049] MultisessionFuture started
[13:33:39.049] - Launch lazy future ... done
[13:33:39.049] run() for ‘MultisessionFuture’ ... done
[13:33:39.049] Created future:
[13:33:39.049] MultisessionFuture:
[13:33:39.049] Label: ‘future_apply-2’
[13:33:39.049] Expression:
[13:33:39.049] {
[13:33:39.049]     do.call(function(...) {
[13:33:39.049]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.049]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.049]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.049]             on.exit(options(oopts), add = TRUE)
[13:33:39.049]         }
[13:33:39.049]         {
[13:33:39.049]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.049]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.049]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.049]             })
[13:33:39.049]         }
[13:33:39.049]     }, args = future.call.arguments)
[13:33:39.049] }
[13:33:39.049] Lazy evaluation: FALSE
[13:33:39.049] Asynchronous evaluation: TRUE
[13:33:39.049] Local evaluation: TRUE
[13:33:39.049] Environment: R_GlobalEnv
[13:33:39.049] Capture standard output: TRUE
[13:33:39.049] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.049] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.049] Packages: <none>
[13:33:39.049] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.049] Resolved: FALSE
[13:33:39.049] Value: <not collected>
[13:33:39.049] Conditions captured: <none>
[13:33:39.049] Early signaling: FALSE
[13:33:39.049] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.049] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.061] Chunk #2 of 2 ... DONE
[13:33:39.061] Launching 2 futures (chunks) ... DONE
[13:33:39.061] Resolving 2 futures (chunks) ...
[13:33:39.061] resolve() on list ...
[13:33:39.061]  recursive: 0
[13:33:39.062]  length: 2
[13:33:39.062] 
[13:33:39.062] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.062] - Validating connection of MultisessionFuture
[13:33:39.062] - received message: FutureResult
[13:33:39.063] - Received FutureResult
[13:33:39.063] - Erased future from FutureRegistry
[13:33:39.063] result() for ClusterFuture ...
[13:33:39.063] - result already collected: FutureResult
[13:33:39.063] result() for ClusterFuture ... done
[13:33:39.063] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.063] Future #1
[13:33:39.063] result() for ClusterFuture ...
[13:33:39.063] - result already collected: FutureResult
[13:33:39.063] result() for ClusterFuture ... done
[13:33:39.063] result() for ClusterFuture ...
[13:33:39.064] - result already collected: FutureResult
[13:33:39.064] result() for ClusterFuture ... done
[13:33:39.064] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:39.064] - nx: 2
[13:33:39.064] - relay: TRUE
[13:33:39.064] - stdout: TRUE
[13:33:39.064] - signal: TRUE
[13:33:39.064] - resignal: FALSE
[13:33:39.064] - force: TRUE
[13:33:39.064] - relayed: [n=2] FALSE, FALSE
[13:33:39.064] - queued futures: [n=2] FALSE, FALSE
[13:33:39.065]  - until=1
[13:33:39.065]  - relaying element #1
[13:33:39.065] result() for ClusterFuture ...
[13:33:39.065] - result already collected: FutureResult
[13:33:39.065] result() for ClusterFuture ... done
[13:33:39.065] result() for ClusterFuture ...
[13:33:39.065] - result already collected: FutureResult
[13:33:39.065] result() for ClusterFuture ... done
[13:33:39.065] result() for ClusterFuture ...
[13:33:39.065] - result already collected: FutureResult
[13:33:39.065] result() for ClusterFuture ... done
[13:33:39.066] result() for ClusterFuture ...
[13:33:39.066] - result already collected: FutureResult
[13:33:39.066] result() for ClusterFuture ... done
[13:33:39.066] - relayed: [n=2] TRUE, FALSE
[13:33:39.066] - queued futures: [n=2] TRUE, FALSE
[13:33:39.068] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:39.068]  length: 1 (resolved future 1)
[13:33:39.092] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.092] - Validating connection of MultisessionFuture
[13:33:39.092] - received message: FutureResult
[13:33:39.092] - Received FutureResult
[13:33:39.092] - Erased future from FutureRegistry
[13:33:39.092] result() for ClusterFuture ...
[13:33:39.092] - result already collected: FutureResult
[13:33:39.092] result() for ClusterFuture ... done
[13:33:39.093] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.093] Future #2
[13:33:39.093] result() for ClusterFuture ...
[13:33:39.093] - result already collected: FutureResult
[13:33:39.093] result() for ClusterFuture ... done
[13:33:39.093] result() for ClusterFuture ...
[13:33:39.093] - result already collected: FutureResult
[13:33:39.093] result() for ClusterFuture ... done
[13:33:39.093] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:39.093] - nx: 2
[13:33:39.093] - relay: TRUE
[13:33:39.094] - stdout: TRUE
[13:33:39.094] - signal: TRUE
[13:33:39.094] - resignal: FALSE
[13:33:39.094] - force: TRUE
[13:33:39.094] - relayed: [n=2] TRUE, FALSE
[13:33:39.094] - queued futures: [n=2] TRUE, FALSE
[13:33:39.094]  - until=2
[13:33:39.094]  - relaying element #2
[13:33:39.094] result() for ClusterFuture ...
[13:33:39.094] - result already collected: FutureResult
[13:33:39.094] result() for ClusterFuture ... done
[13:33:39.094] result() for ClusterFuture ...
[13:33:39.095] - result already collected: FutureResult
[13:33:39.095] result() for ClusterFuture ... done
[13:33:39.095] result() for ClusterFuture ...
[13:33:39.095] - result already collected: FutureResult
[13:33:39.095] result() for ClusterFuture ... done
[13:33:39.095] result() for ClusterFuture ...
[13:33:39.095] - result already collected: FutureResult
[13:33:39.095] result() for ClusterFuture ... done
[13:33:39.095] - relayed: [n=2] TRUE, TRUE
[13:33:39.095] - queued futures: [n=2] TRUE, TRUE
[13:33:39.095] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:39.096]  length: 0 (resolved future 2)
[13:33:39.096] Relaying remaining futures
[13:33:39.096] signalConditionsASAP(NULL, pos=0) ...
[13:33:39.096] - nx: 2
[13:33:39.096] - relay: TRUE
[13:33:39.096] - stdout: TRUE
[13:33:39.096] - signal: TRUE
[13:33:39.096] - resignal: FALSE
[13:33:39.096] - force: TRUE
[13:33:39.096] - relayed: [n=2] TRUE, TRUE
[13:33:39.096] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:39.096] - relayed: [n=2] TRUE, TRUE
[13:33:39.097] - queued futures: [n=2] TRUE, TRUE
[13:33:39.097] signalConditionsASAP(NULL, pos=0) ... done
[13:33:39.097] resolve() on list ... DONE
[13:33:39.097] result() for ClusterFuture ...
[13:33:39.097] - result already collected: FutureResult
[13:33:39.097] result() for ClusterFuture ... done
[13:33:39.097] result() for ClusterFuture ...
[13:33:39.097] - result already collected: FutureResult
[13:33:39.097] result() for ClusterFuture ... done
[13:33:39.097] result() for ClusterFuture ...
[13:33:39.097] - result already collected: FutureResult
[13:33:39.098] result() for ClusterFuture ... done
[13:33:39.098] result() for ClusterFuture ...
[13:33:39.098] - result already collected: FutureResult
[13:33:39.098] result() for ClusterFuture ... done
[13:33:39.098]  - Number of value chunks collected: 2
[13:33:39.098] Resolving 2 futures (chunks) ... DONE
[13:33:39.098] Reducing values from 2 chunks ...
[13:33:39.098]  - Number of values collected after concatenation: 2
[13:33:39.098]  - Number of values expected: 2
[13:33:39.098] Reducing values from 2 chunks ... DONE
[13:33:39.098] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:33:39.099] getGlobalsAndPackagesXApply() ...
[13:33:39.100]  - future.globals: TRUE
[13:33:39.100] getGlobalsAndPackages() ...
[13:33:39.100] Searching for globals...
[13:33:39.101] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:39.101] Searching for globals ... DONE
[13:33:39.102] Resolving globals: FALSE
[13:33:39.102] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:39.103] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:39.103] - globals: [1] ‘FUN’
[13:33:39.103] - packages: [1] ‘stats’
[13:33:39.103] getGlobalsAndPackages() ... DONE
[13:33:39.103]  - globals found/used: [n=1] ‘FUN’
[13:33:39.103]  - needed namespaces: [n=1] ‘stats’
[13:33:39.104] Finding globals ... DONE
[13:33:39.104]  - use_args: TRUE
[13:33:39.104]  - Getting '...' globals ...
[13:33:39.104] resolve() on list ...
[13:33:39.104]  recursive: 0
[13:33:39.104]  length: 1
[13:33:39.105]  elements: ‘...’
[13:33:39.105]  length: 0 (resolved future 1)
[13:33:39.105] resolve() on list ... DONE
[13:33:39.105]    - '...' content: [n=0] 
[13:33:39.105] List of 1
[13:33:39.105]  $ ...: list()
[13:33:39.105]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.105]  - attr(*, "where")=List of 1
[13:33:39.105]   ..$ ...:<environment: 0x55b94a354ad8> 
[13:33:39.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.105]  - attr(*, "resolved")= logi TRUE
[13:33:39.105]  - attr(*, "total_size")= num NA
[13:33:39.108]  - Getting '...' globals ... DONE
[13:33:39.108] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:39.108] List of 2
[13:33:39.108]  $ ...future.FUN:function (x, ...)  
[13:33:39.108]  $ ...          : list()
[13:33:39.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.108]  - attr(*, "where")=List of 2
[13:33:39.108]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:39.108]   ..$ ...          :<environment: 0x55b94a354ad8> 
[13:33:39.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.108]  - attr(*, "resolved")= logi FALSE
[13:33:39.108]  - attr(*, "total_size")= num 1248
[13:33:39.111] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:39.111] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.114] future_lapply() ...
[13:33:39.118] Number of chunks: 2
[13:33:39.118] getGlobalsAndPackagesXApply() ...
[13:33:39.118]  - future.globals: <name-value list> with names ‘list()’
[13:33:39.118]  - use_args: TRUE
[13:33:39.118] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:39.118] List of 2
[13:33:39.118]  $ ...          : list()
[13:33:39.118]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.118]  $ ...future.FUN:function (x, ...)  
[13:33:39.118]  - attr(*, "where")=List of 2
[13:33:39.118]   ..$ ...          :<environment: 0x55b94a354ad8> 
[13:33:39.118]   ..$ ...future.FUN:<environment: namespace:stats> 
[13:33:39.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.118]  - attr(*, "resolved")= logi FALSE
[13:33:39.118]  - attr(*, "total_size")= num NA
[13:33:39.121] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:39.121] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.121] Number of futures (= number of chunks): 2
[13:33:39.121] Launching 2 futures (chunks) ...
[13:33:39.122] Chunk #1 of 2 ...
[13:33:39.122]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.122]  - seeds: <none>
[13:33:39.122]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.122] getGlobalsAndPackages() ...
[13:33:39.122] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.122] Resolving globals: FALSE
[13:33:39.122] Tweak future expression to call with '...' arguments ...
[13:33:39.123] {
[13:33:39.123]     do.call(function(...) {
[13:33:39.123]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.123]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.123]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.123]             on.exit(options(oopts), add = TRUE)
[13:33:39.123]         }
[13:33:39.123]         {
[13:33:39.123]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.123]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.123]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.123]             })
[13:33:39.123]         }
[13:33:39.123]     }, args = future.call.arguments)
[13:33:39.123] }
[13:33:39.123] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.123] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.123] - packages: [1] ‘stats’
[13:33:39.123] getGlobalsAndPackages() ... DONE
[13:33:39.124] run() for ‘Future’ ...
[13:33:39.124] - state: ‘created’
[13:33:39.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.137] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.138]   - Field: ‘node’
[13:33:39.138]   - Field: ‘label’
[13:33:39.138]   - Field: ‘local’
[13:33:39.138]   - Field: ‘owner’
[13:33:39.138]   - Field: ‘envir’
[13:33:39.138]   - Field: ‘workers’
[13:33:39.138]   - Field: ‘packages’
[13:33:39.138]   - Field: ‘gc’
[13:33:39.138]   - Field: ‘conditions’
[13:33:39.138]   - Field: ‘persistent’
[13:33:39.139]   - Field: ‘expr’
[13:33:39.139]   - Field: ‘uuid’
[13:33:39.139]   - Field: ‘seed’
[13:33:39.139]   - Field: ‘version’
[13:33:39.139]   - Field: ‘result’
[13:33:39.139]   - Field: ‘asynchronous’
[13:33:39.139]   - Field: ‘calls’
[13:33:39.139]   - Field: ‘globals’
[13:33:39.139]   - Field: ‘stdout’
[13:33:39.139]   - Field: ‘earlySignal’
[13:33:39.139]   - Field: ‘lazy’
[13:33:39.140]   - Field: ‘state’
[13:33:39.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.140] - Launch lazy future ...
[13:33:39.140] Packages needed by the future expression (n = 1): ‘stats’
[13:33:39.140] Packages needed by future strategies (n = 0): <none>
[13:33:39.141] {
[13:33:39.141]     {
[13:33:39.141]         {
[13:33:39.141]             ...future.startTime <- base::Sys.time()
[13:33:39.141]             {
[13:33:39.141]                 {
[13:33:39.141]                   {
[13:33:39.141]                     {
[13:33:39.141]                       {
[13:33:39.141]                         base::local({
[13:33:39.141]                           has_future <- base::requireNamespace("future", 
[13:33:39.141]                             quietly = TRUE)
[13:33:39.141]                           if (has_future) {
[13:33:39.141]                             ns <- base::getNamespace("future")
[13:33:39.141]                             version <- ns[[".package"]][["version"]]
[13:33:39.141]                             if (is.null(version)) 
[13:33:39.141]                               version <- utils::packageVersion("future")
[13:33:39.141]                           }
[13:33:39.141]                           else {
[13:33:39.141]                             version <- NULL
[13:33:39.141]                           }
[13:33:39.141]                           if (!has_future || version < "1.8.0") {
[13:33:39.141]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.141]                               "", base::R.version$version.string), 
[13:33:39.141]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:39.141]                                 base::R.version$platform, 8 * 
[13:33:39.141]                                   base::.Machine$sizeof.pointer), 
[13:33:39.141]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.141]                                 "release", "version")], collapse = " "), 
[13:33:39.141]                               hostname = base::Sys.info()[["nodename"]])
[13:33:39.141]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.141]                               info)
[13:33:39.141]                             info <- base::paste(info, collapse = "; ")
[13:33:39.141]                             if (!has_future) {
[13:33:39.141]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.141]                                 info)
[13:33:39.141]                             }
[13:33:39.141]                             else {
[13:33:39.141]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.141]                                 info, version)
[13:33:39.141]                             }
[13:33:39.141]                             base::stop(msg)
[13:33:39.141]                           }
[13:33:39.141]                         })
[13:33:39.141]                       }
[13:33:39.141]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.141]                       base::options(mc.cores = 1L)
[13:33:39.141]                     }
[13:33:39.141]                     base::local({
[13:33:39.141]                       for (pkg in "stats") {
[13:33:39.141]                         base::loadNamespace(pkg)
[13:33:39.141]                         base::library(pkg, character.only = TRUE)
[13:33:39.141]                       }
[13:33:39.141]                     })
[13:33:39.141]                   }
[13:33:39.141]                   ...future.strategy.old <- future::plan("list")
[13:33:39.141]                   options(future.plan = NULL)
[13:33:39.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.141]                 }
[13:33:39.141]                 ...future.workdir <- getwd()
[13:33:39.141]             }
[13:33:39.141]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.141]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.141]         }
[13:33:39.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.141]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.141]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.141]             base::names(...future.oldOptions))
[13:33:39.141]     }
[13:33:39.141]     if (FALSE) {
[13:33:39.141]     }
[13:33:39.141]     else {
[13:33:39.141]         if (TRUE) {
[13:33:39.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.141]                 open = "w")
[13:33:39.141]         }
[13:33:39.141]         else {
[13:33:39.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.141]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.141]         }
[13:33:39.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.141]             base::sink(type = "output", split = FALSE)
[13:33:39.141]             base::close(...future.stdout)
[13:33:39.141]         }, add = TRUE)
[13:33:39.141]     }
[13:33:39.141]     ...future.frame <- base::sys.nframe()
[13:33:39.141]     ...future.conditions <- base::list()
[13:33:39.141]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.141]     if (FALSE) {
[13:33:39.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.141]     }
[13:33:39.141]     ...future.result <- base::tryCatch({
[13:33:39.141]         base::withCallingHandlers({
[13:33:39.141]             ...future.value <- base::withVisible(base::local({
[13:33:39.141]                 ...future.makeSendCondition <- base::local({
[13:33:39.141]                   sendCondition <- NULL
[13:33:39.141]                   function(frame = 1L) {
[13:33:39.141]                     if (is.function(sendCondition)) 
[13:33:39.141]                       return(sendCondition)
[13:33:39.141]                     ns <- getNamespace("parallel")
[13:33:39.141]                     if (exists("sendData", mode = "function", 
[13:33:39.141]                       envir = ns)) {
[13:33:39.141]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.141]                         envir = ns)
[13:33:39.141]                       envir <- sys.frame(frame)
[13:33:39.141]                       master <- NULL
[13:33:39.141]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.141]                         !identical(envir, emptyenv())) {
[13:33:39.141]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.141]                           inherits = FALSE)) {
[13:33:39.141]                           master <- get("master", mode = "list", 
[13:33:39.141]                             envir = envir, inherits = FALSE)
[13:33:39.141]                           if (inherits(master, c("SOCKnode", 
[13:33:39.141]                             "SOCK0node"))) {
[13:33:39.141]                             sendCondition <<- function(cond) {
[13:33:39.141]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.141]                                 success = TRUE)
[13:33:39.141]                               parallel_sendData(master, data)
[13:33:39.141]                             }
[13:33:39.141]                             return(sendCondition)
[13:33:39.141]                           }
[13:33:39.141]                         }
[13:33:39.141]                         frame <- frame + 1L
[13:33:39.141]                         envir <- sys.frame(frame)
[13:33:39.141]                       }
[13:33:39.141]                     }
[13:33:39.141]                     sendCondition <<- function(cond) NULL
[13:33:39.141]                   }
[13:33:39.141]                 })
[13:33:39.141]                 withCallingHandlers({
[13:33:39.141]                   {
[13:33:39.141]                     do.call(function(...) {
[13:33:39.141]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.141]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.141]                         ...future.globals.maxSize)) {
[13:33:39.141]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.141]                         on.exit(options(oopts), add = TRUE)
[13:33:39.141]                       }
[13:33:39.141]                       {
[13:33:39.141]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.141]                           FUN = function(jj) {
[13:33:39.141]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.141]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.141]                           })
[13:33:39.141]                       }
[13:33:39.141]                     }, args = future.call.arguments)
[13:33:39.141]                   }
[13:33:39.141]                 }, immediateCondition = function(cond) {
[13:33:39.141]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.141]                   sendCondition(cond)
[13:33:39.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.141]                   {
[13:33:39.141]                     inherits <- base::inherits
[13:33:39.141]                     invokeRestart <- base::invokeRestart
[13:33:39.141]                     is.null <- base::is.null
[13:33:39.141]                     muffled <- FALSE
[13:33:39.141]                     if (inherits(cond, "message")) {
[13:33:39.141]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.141]                       if (muffled) 
[13:33:39.141]                         invokeRestart("muffleMessage")
[13:33:39.141]                     }
[13:33:39.141]                     else if (inherits(cond, "warning")) {
[13:33:39.141]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.141]                       if (muffled) 
[13:33:39.141]                         invokeRestart("muffleWarning")
[13:33:39.141]                     }
[13:33:39.141]                     else if (inherits(cond, "condition")) {
[13:33:39.141]                       if (!is.null(pattern)) {
[13:33:39.141]                         computeRestarts <- base::computeRestarts
[13:33:39.141]                         grepl <- base::grepl
[13:33:39.141]                         restarts <- computeRestarts(cond)
[13:33:39.141]                         for (restart in restarts) {
[13:33:39.141]                           name <- restart$name
[13:33:39.141]                           if (is.null(name)) 
[13:33:39.141]                             next
[13:33:39.141]                           if (!grepl(pattern, name)) 
[13:33:39.141]                             next
[13:33:39.141]                           invokeRestart(restart)
[13:33:39.141]                           muffled <- TRUE
[13:33:39.141]                           break
[13:33:39.141]                         }
[13:33:39.141]                       }
[13:33:39.141]                     }
[13:33:39.141]                     invisible(muffled)
[13:33:39.141]                   }
[13:33:39.141]                   muffleCondition(cond)
[13:33:39.141]                 })
[13:33:39.141]             }))
[13:33:39.141]             future::FutureResult(value = ...future.value$value, 
[13:33:39.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.141]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.141]                     ...future.globalenv.names))
[13:33:39.141]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.141]         }, condition = base::local({
[13:33:39.141]             c <- base::c
[13:33:39.141]             inherits <- base::inherits
[13:33:39.141]             invokeRestart <- base::invokeRestart
[13:33:39.141]             length <- base::length
[13:33:39.141]             list <- base::list
[13:33:39.141]             seq.int <- base::seq.int
[13:33:39.141]             signalCondition <- base::signalCondition
[13:33:39.141]             sys.calls <- base::sys.calls
[13:33:39.141]             `[[` <- base::`[[`
[13:33:39.141]             `+` <- base::`+`
[13:33:39.141]             `<<-` <- base::`<<-`
[13:33:39.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.141]                   3L)]
[13:33:39.141]             }
[13:33:39.141]             function(cond) {
[13:33:39.141]                 is_error <- inherits(cond, "error")
[13:33:39.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.141]                   NULL)
[13:33:39.141]                 if (is_error) {
[13:33:39.141]                   sessionInformation <- function() {
[13:33:39.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.141]                       search = base::search(), system = base::Sys.info())
[13:33:39.141]                   }
[13:33:39.141]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.141]                     cond$call), session = sessionInformation(), 
[13:33:39.141]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.141]                   signalCondition(cond)
[13:33:39.141]                 }
[13:33:39.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.141]                 "immediateCondition"))) {
[13:33:39.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.141]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.141]                   if (TRUE && !signal) {
[13:33:39.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.141]                     {
[13:33:39.141]                       inherits <- base::inherits
[13:33:39.141]                       invokeRestart <- base::invokeRestart
[13:33:39.141]                       is.null <- base::is.null
[13:33:39.141]                       muffled <- FALSE
[13:33:39.141]                       if (inherits(cond, "message")) {
[13:33:39.141]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.141]                         if (muffled) 
[13:33:39.141]                           invokeRestart("muffleMessage")
[13:33:39.141]                       }
[13:33:39.141]                       else if (inherits(cond, "warning")) {
[13:33:39.141]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.141]                         if (muffled) 
[13:33:39.141]                           invokeRestart("muffleWarning")
[13:33:39.141]                       }
[13:33:39.141]                       else if (inherits(cond, "condition")) {
[13:33:39.141]                         if (!is.null(pattern)) {
[13:33:39.141]                           computeRestarts <- base::computeRestarts
[13:33:39.141]                           grepl <- base::grepl
[13:33:39.141]                           restarts <- computeRestarts(cond)
[13:33:39.141]                           for (restart in restarts) {
[13:33:39.141]                             name <- restart$name
[13:33:39.141]                             if (is.null(name)) 
[13:33:39.141]                               next
[13:33:39.141]                             if (!grepl(pattern, name)) 
[13:33:39.141]                               next
[13:33:39.141]                             invokeRestart(restart)
[13:33:39.141]                             muffled <- TRUE
[13:33:39.141]                             break
[13:33:39.141]                           }
[13:33:39.141]                         }
[13:33:39.141]                       }
[13:33:39.141]                       invisible(muffled)
[13:33:39.141]                     }
[13:33:39.141]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.141]                   }
[13:33:39.141]                 }
[13:33:39.141]                 else {
[13:33:39.141]                   if (TRUE) {
[13:33:39.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.141]                     {
[13:33:39.141]                       inherits <- base::inherits
[13:33:39.141]                       invokeRestart <- base::invokeRestart
[13:33:39.141]                       is.null <- base::is.null
[13:33:39.141]                       muffled <- FALSE
[13:33:39.141]                       if (inherits(cond, "message")) {
[13:33:39.141]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.141]                         if (muffled) 
[13:33:39.141]                           invokeRestart("muffleMessage")
[13:33:39.141]                       }
[13:33:39.141]                       else if (inherits(cond, "warning")) {
[13:33:39.141]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.141]                         if (muffled) 
[13:33:39.141]                           invokeRestart("muffleWarning")
[13:33:39.141]                       }
[13:33:39.141]                       else if (inherits(cond, "condition")) {
[13:33:39.141]                         if (!is.null(pattern)) {
[13:33:39.141]                           computeRestarts <- base::computeRestarts
[13:33:39.141]                           grepl <- base::grepl
[13:33:39.141]                           restarts <- computeRestarts(cond)
[13:33:39.141]                           for (restart in restarts) {
[13:33:39.141]                             name <- restart$name
[13:33:39.141]                             if (is.null(name)) 
[13:33:39.141]                               next
[13:33:39.141]                             if (!grepl(pattern, name)) 
[13:33:39.141]                               next
[13:33:39.141]                             invokeRestart(restart)
[13:33:39.141]                             muffled <- TRUE
[13:33:39.141]                             break
[13:33:39.141]                           }
[13:33:39.141]                         }
[13:33:39.141]                       }
[13:33:39.141]                       invisible(muffled)
[13:33:39.141]                     }
[13:33:39.141]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.141]                   }
[13:33:39.141]                 }
[13:33:39.141]             }
[13:33:39.141]         }))
[13:33:39.141]     }, error = function(ex) {
[13:33:39.141]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.141]                 ...future.rng), started = ...future.startTime, 
[13:33:39.141]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.141]             version = "1.8"), class = "FutureResult")
[13:33:39.141]     }, finally = {
[13:33:39.141]         if (!identical(...future.workdir, getwd())) 
[13:33:39.141]             setwd(...future.workdir)
[13:33:39.141]         {
[13:33:39.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.141]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.141]             }
[13:33:39.141]             base::options(...future.oldOptions)
[13:33:39.141]             if (.Platform$OS.type == "windows") {
[13:33:39.141]                 old_names <- names(...future.oldEnvVars)
[13:33:39.141]                 envs <- base::Sys.getenv()
[13:33:39.141]                 names <- names(envs)
[13:33:39.141]                 common <- intersect(names, old_names)
[13:33:39.141]                 added <- setdiff(names, old_names)
[13:33:39.141]                 removed <- setdiff(old_names, names)
[13:33:39.141]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.141]                   envs[common]]
[13:33:39.141]                 NAMES <- toupper(changed)
[13:33:39.141]                 args <- list()
[13:33:39.141]                 for (kk in seq_along(NAMES)) {
[13:33:39.141]                   name <- changed[[kk]]
[13:33:39.141]                   NAME <- NAMES[[kk]]
[13:33:39.141]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.141]                     next
[13:33:39.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.141]                 }
[13:33:39.141]                 NAMES <- toupper(added)
[13:33:39.141]                 for (kk in seq_along(NAMES)) {
[13:33:39.141]                   name <- added[[kk]]
[13:33:39.141]                   NAME <- NAMES[[kk]]
[13:33:39.141]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.141]                     next
[13:33:39.141]                   args[[name]] <- ""
[13:33:39.141]                 }
[13:33:39.141]                 NAMES <- toupper(removed)
[13:33:39.141]                 for (kk in seq_along(NAMES)) {
[13:33:39.141]                   name <- removed[[kk]]
[13:33:39.141]                   NAME <- NAMES[[kk]]
[13:33:39.141]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.141]                     next
[13:33:39.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.141]                 }
[13:33:39.141]                 if (length(args) > 0) 
[13:33:39.141]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.141]             }
[13:33:39.141]             else {
[13:33:39.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.141]             }
[13:33:39.141]             {
[13:33:39.141]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.141]                   0L) {
[13:33:39.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.141]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.141]                   base::options(opts)
[13:33:39.141]                 }
[13:33:39.141]                 {
[13:33:39.141]                   {
[13:33:39.141]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.141]                     NULL
[13:33:39.141]                   }
[13:33:39.141]                   options(future.plan = NULL)
[13:33:39.141]                   if (is.na(NA_character_)) 
[13:33:39.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.141]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.141]                     .init = FALSE)
[13:33:39.141]                 }
[13:33:39.141]             }
[13:33:39.141]         }
[13:33:39.141]     })
[13:33:39.141]     if (TRUE) {
[13:33:39.141]         base::sink(type = "output", split = FALSE)
[13:33:39.141]         if (TRUE) {
[13:33:39.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.141]         }
[13:33:39.141]         else {
[13:33:39.141]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.141]         }
[13:33:39.141]         base::close(...future.stdout)
[13:33:39.141]         ...future.stdout <- NULL
[13:33:39.141]     }
[13:33:39.141]     ...future.result$conditions <- ...future.conditions
[13:33:39.141]     ...future.result$finished <- base::Sys.time()
[13:33:39.141]     ...future.result
[13:33:39.141] }
[13:33:39.143] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[13:33:39.144] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:39.144] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.144] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:33:39.144] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:33:39.144] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[13:33:39.145] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[13:33:39.145] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:39.145] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.145] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:39.146] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:39.146] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[13:33:39.146] MultisessionFuture started
[13:33:39.146] - Launch lazy future ... done
[13:33:39.146] run() for ‘MultisessionFuture’ ... done
[13:33:39.147] Created future:
[13:33:39.147] MultisessionFuture:
[13:33:39.147] Label: ‘future_apply-1’
[13:33:39.147] Expression:
[13:33:39.147] {
[13:33:39.147]     do.call(function(...) {
[13:33:39.147]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.147]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.147]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.147]             on.exit(options(oopts), add = TRUE)
[13:33:39.147]         }
[13:33:39.147]         {
[13:33:39.147]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.147]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.147]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.147]             })
[13:33:39.147]         }
[13:33:39.147]     }, args = future.call.arguments)
[13:33:39.147] }
[13:33:39.147] Lazy evaluation: FALSE
[13:33:39.147] Asynchronous evaluation: TRUE
[13:33:39.147] Local evaluation: TRUE
[13:33:39.147] Environment: R_GlobalEnv
[13:33:39.147] Capture standard output: TRUE
[13:33:39.147] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.147] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.147] Packages: 1 packages (‘stats’)
[13:33:39.147] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.147] Resolved: FALSE
[13:33:39.147] Value: <not collected>
[13:33:39.147] Conditions captured: <none>
[13:33:39.147] Early signaling: FALSE
[13:33:39.147] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.147] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.158] Chunk #1 of 2 ... DONE
[13:33:39.158] Chunk #2 of 2 ...
[13:33:39.158]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.159]  - seeds: <none>
[13:33:39.159]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.159] getGlobalsAndPackages() ...
[13:33:39.159] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.159] Resolving globals: FALSE
[13:33:39.159] Tweak future expression to call with '...' arguments ...
[13:33:39.159] {
[13:33:39.159]     do.call(function(...) {
[13:33:39.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.159]             on.exit(options(oopts), add = TRUE)
[13:33:39.159]         }
[13:33:39.159]         {
[13:33:39.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.159]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.159]             })
[13:33:39.159]         }
[13:33:39.159]     }, args = future.call.arguments)
[13:33:39.159] }
[13:33:39.159] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.160] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.160] - packages: [1] ‘stats’
[13:33:39.160] getGlobalsAndPackages() ... DONE
[13:33:39.160] run() for ‘Future’ ...
[13:33:39.160] - state: ‘created’
[13:33:39.161] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.174] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.174]   - Field: ‘node’
[13:33:39.174]   - Field: ‘label’
[13:33:39.174]   - Field: ‘local’
[13:33:39.174]   - Field: ‘owner’
[13:33:39.174]   - Field: ‘envir’
[13:33:39.174]   - Field: ‘workers’
[13:33:39.175]   - Field: ‘packages’
[13:33:39.175]   - Field: ‘gc’
[13:33:39.175]   - Field: ‘conditions’
[13:33:39.175]   - Field: ‘persistent’
[13:33:39.175]   - Field: ‘expr’
[13:33:39.175]   - Field: ‘uuid’
[13:33:39.175]   - Field: ‘seed’
[13:33:39.175]   - Field: ‘version’
[13:33:39.175]   - Field: ‘result’
[13:33:39.175]   - Field: ‘asynchronous’
[13:33:39.175]   - Field: ‘calls’
[13:33:39.176]   - Field: ‘globals’
[13:33:39.176]   - Field: ‘stdout’
[13:33:39.176]   - Field: ‘earlySignal’
[13:33:39.176]   - Field: ‘lazy’
[13:33:39.176]   - Field: ‘state’
[13:33:39.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.176] - Launch lazy future ...
[13:33:39.176] Packages needed by the future expression (n = 1): ‘stats’
[13:33:39.177] Packages needed by future strategies (n = 0): <none>
[13:33:39.177] {
[13:33:39.177]     {
[13:33:39.177]         {
[13:33:39.177]             ...future.startTime <- base::Sys.time()
[13:33:39.177]             {
[13:33:39.177]                 {
[13:33:39.177]                   {
[13:33:39.177]                     {
[13:33:39.177]                       {
[13:33:39.177]                         base::local({
[13:33:39.177]                           has_future <- base::requireNamespace("future", 
[13:33:39.177]                             quietly = TRUE)
[13:33:39.177]                           if (has_future) {
[13:33:39.177]                             ns <- base::getNamespace("future")
[13:33:39.177]                             version <- ns[[".package"]][["version"]]
[13:33:39.177]                             if (is.null(version)) 
[13:33:39.177]                               version <- utils::packageVersion("future")
[13:33:39.177]                           }
[13:33:39.177]                           else {
[13:33:39.177]                             version <- NULL
[13:33:39.177]                           }
[13:33:39.177]                           if (!has_future || version < "1.8.0") {
[13:33:39.177]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.177]                               "", base::R.version$version.string), 
[13:33:39.177]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:39.177]                                 base::R.version$platform, 8 * 
[13:33:39.177]                                   base::.Machine$sizeof.pointer), 
[13:33:39.177]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.177]                                 "release", "version")], collapse = " "), 
[13:33:39.177]                               hostname = base::Sys.info()[["nodename"]])
[13:33:39.177]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.177]                               info)
[13:33:39.177]                             info <- base::paste(info, collapse = "; ")
[13:33:39.177]                             if (!has_future) {
[13:33:39.177]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.177]                                 info)
[13:33:39.177]                             }
[13:33:39.177]                             else {
[13:33:39.177]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.177]                                 info, version)
[13:33:39.177]                             }
[13:33:39.177]                             base::stop(msg)
[13:33:39.177]                           }
[13:33:39.177]                         })
[13:33:39.177]                       }
[13:33:39.177]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.177]                       base::options(mc.cores = 1L)
[13:33:39.177]                     }
[13:33:39.177]                     base::local({
[13:33:39.177]                       for (pkg in "stats") {
[13:33:39.177]                         base::loadNamespace(pkg)
[13:33:39.177]                         base::library(pkg, character.only = TRUE)
[13:33:39.177]                       }
[13:33:39.177]                     })
[13:33:39.177]                   }
[13:33:39.177]                   ...future.strategy.old <- future::plan("list")
[13:33:39.177]                   options(future.plan = NULL)
[13:33:39.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.177]                 }
[13:33:39.177]                 ...future.workdir <- getwd()
[13:33:39.177]             }
[13:33:39.177]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.177]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.177]         }
[13:33:39.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.177]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.177]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.177]             base::names(...future.oldOptions))
[13:33:39.177]     }
[13:33:39.177]     if (FALSE) {
[13:33:39.177]     }
[13:33:39.177]     else {
[13:33:39.177]         if (TRUE) {
[13:33:39.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.177]                 open = "w")
[13:33:39.177]         }
[13:33:39.177]         else {
[13:33:39.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.177]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.177]         }
[13:33:39.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.177]             base::sink(type = "output", split = FALSE)
[13:33:39.177]             base::close(...future.stdout)
[13:33:39.177]         }, add = TRUE)
[13:33:39.177]     }
[13:33:39.177]     ...future.frame <- base::sys.nframe()
[13:33:39.177]     ...future.conditions <- base::list()
[13:33:39.177]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.177]     if (FALSE) {
[13:33:39.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.177]     }
[13:33:39.177]     ...future.result <- base::tryCatch({
[13:33:39.177]         base::withCallingHandlers({
[13:33:39.177]             ...future.value <- base::withVisible(base::local({
[13:33:39.177]                 ...future.makeSendCondition <- base::local({
[13:33:39.177]                   sendCondition <- NULL
[13:33:39.177]                   function(frame = 1L) {
[13:33:39.177]                     if (is.function(sendCondition)) 
[13:33:39.177]                       return(sendCondition)
[13:33:39.177]                     ns <- getNamespace("parallel")
[13:33:39.177]                     if (exists("sendData", mode = "function", 
[13:33:39.177]                       envir = ns)) {
[13:33:39.177]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.177]                         envir = ns)
[13:33:39.177]                       envir <- sys.frame(frame)
[13:33:39.177]                       master <- NULL
[13:33:39.177]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.177]                         !identical(envir, emptyenv())) {
[13:33:39.177]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.177]                           inherits = FALSE)) {
[13:33:39.177]                           master <- get("master", mode = "list", 
[13:33:39.177]                             envir = envir, inherits = FALSE)
[13:33:39.177]                           if (inherits(master, c("SOCKnode", 
[13:33:39.177]                             "SOCK0node"))) {
[13:33:39.177]                             sendCondition <<- function(cond) {
[13:33:39.177]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.177]                                 success = TRUE)
[13:33:39.177]                               parallel_sendData(master, data)
[13:33:39.177]                             }
[13:33:39.177]                             return(sendCondition)
[13:33:39.177]                           }
[13:33:39.177]                         }
[13:33:39.177]                         frame <- frame + 1L
[13:33:39.177]                         envir <- sys.frame(frame)
[13:33:39.177]                       }
[13:33:39.177]                     }
[13:33:39.177]                     sendCondition <<- function(cond) NULL
[13:33:39.177]                   }
[13:33:39.177]                 })
[13:33:39.177]                 withCallingHandlers({
[13:33:39.177]                   {
[13:33:39.177]                     do.call(function(...) {
[13:33:39.177]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.177]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.177]                         ...future.globals.maxSize)) {
[13:33:39.177]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.177]                         on.exit(options(oopts), add = TRUE)
[13:33:39.177]                       }
[13:33:39.177]                       {
[13:33:39.177]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.177]                           FUN = function(jj) {
[13:33:39.177]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.177]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.177]                           })
[13:33:39.177]                       }
[13:33:39.177]                     }, args = future.call.arguments)
[13:33:39.177]                   }
[13:33:39.177]                 }, immediateCondition = function(cond) {
[13:33:39.177]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.177]                   sendCondition(cond)
[13:33:39.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.177]                   {
[13:33:39.177]                     inherits <- base::inherits
[13:33:39.177]                     invokeRestart <- base::invokeRestart
[13:33:39.177]                     is.null <- base::is.null
[13:33:39.177]                     muffled <- FALSE
[13:33:39.177]                     if (inherits(cond, "message")) {
[13:33:39.177]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.177]                       if (muffled) 
[13:33:39.177]                         invokeRestart("muffleMessage")
[13:33:39.177]                     }
[13:33:39.177]                     else if (inherits(cond, "warning")) {
[13:33:39.177]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.177]                       if (muffled) 
[13:33:39.177]                         invokeRestart("muffleWarning")
[13:33:39.177]                     }
[13:33:39.177]                     else if (inherits(cond, "condition")) {
[13:33:39.177]                       if (!is.null(pattern)) {
[13:33:39.177]                         computeRestarts <- base::computeRestarts
[13:33:39.177]                         grepl <- base::grepl
[13:33:39.177]                         restarts <- computeRestarts(cond)
[13:33:39.177]                         for (restart in restarts) {
[13:33:39.177]                           name <- restart$name
[13:33:39.177]                           if (is.null(name)) 
[13:33:39.177]                             next
[13:33:39.177]                           if (!grepl(pattern, name)) 
[13:33:39.177]                             next
[13:33:39.177]                           invokeRestart(restart)
[13:33:39.177]                           muffled <- TRUE
[13:33:39.177]                           break
[13:33:39.177]                         }
[13:33:39.177]                       }
[13:33:39.177]                     }
[13:33:39.177]                     invisible(muffled)
[13:33:39.177]                   }
[13:33:39.177]                   muffleCondition(cond)
[13:33:39.177]                 })
[13:33:39.177]             }))
[13:33:39.177]             future::FutureResult(value = ...future.value$value, 
[13:33:39.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.177]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.177]                     ...future.globalenv.names))
[13:33:39.177]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.177]         }, condition = base::local({
[13:33:39.177]             c <- base::c
[13:33:39.177]             inherits <- base::inherits
[13:33:39.177]             invokeRestart <- base::invokeRestart
[13:33:39.177]             length <- base::length
[13:33:39.177]             list <- base::list
[13:33:39.177]             seq.int <- base::seq.int
[13:33:39.177]             signalCondition <- base::signalCondition
[13:33:39.177]             sys.calls <- base::sys.calls
[13:33:39.177]             `[[` <- base::`[[`
[13:33:39.177]             `+` <- base::`+`
[13:33:39.177]             `<<-` <- base::`<<-`
[13:33:39.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.177]                   3L)]
[13:33:39.177]             }
[13:33:39.177]             function(cond) {
[13:33:39.177]                 is_error <- inherits(cond, "error")
[13:33:39.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.177]                   NULL)
[13:33:39.177]                 if (is_error) {
[13:33:39.177]                   sessionInformation <- function() {
[13:33:39.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.177]                       search = base::search(), system = base::Sys.info())
[13:33:39.177]                   }
[13:33:39.177]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.177]                     cond$call), session = sessionInformation(), 
[13:33:39.177]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.177]                   signalCondition(cond)
[13:33:39.177]                 }
[13:33:39.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.177]                 "immediateCondition"))) {
[13:33:39.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.177]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.177]                   if (TRUE && !signal) {
[13:33:39.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.177]                     {
[13:33:39.177]                       inherits <- base::inherits
[13:33:39.177]                       invokeRestart <- base::invokeRestart
[13:33:39.177]                       is.null <- base::is.null
[13:33:39.177]                       muffled <- FALSE
[13:33:39.177]                       if (inherits(cond, "message")) {
[13:33:39.177]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.177]                         if (muffled) 
[13:33:39.177]                           invokeRestart("muffleMessage")
[13:33:39.177]                       }
[13:33:39.177]                       else if (inherits(cond, "warning")) {
[13:33:39.177]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.177]                         if (muffled) 
[13:33:39.177]                           invokeRestart("muffleWarning")
[13:33:39.177]                       }
[13:33:39.177]                       else if (inherits(cond, "condition")) {
[13:33:39.177]                         if (!is.null(pattern)) {
[13:33:39.177]                           computeRestarts <- base::computeRestarts
[13:33:39.177]                           grepl <- base::grepl
[13:33:39.177]                           restarts <- computeRestarts(cond)
[13:33:39.177]                           for (restart in restarts) {
[13:33:39.177]                             name <- restart$name
[13:33:39.177]                             if (is.null(name)) 
[13:33:39.177]                               next
[13:33:39.177]                             if (!grepl(pattern, name)) 
[13:33:39.177]                               next
[13:33:39.177]                             invokeRestart(restart)
[13:33:39.177]                             muffled <- TRUE
[13:33:39.177]                             break
[13:33:39.177]                           }
[13:33:39.177]                         }
[13:33:39.177]                       }
[13:33:39.177]                       invisible(muffled)
[13:33:39.177]                     }
[13:33:39.177]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.177]                   }
[13:33:39.177]                 }
[13:33:39.177]                 else {
[13:33:39.177]                   if (TRUE) {
[13:33:39.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.177]                     {
[13:33:39.177]                       inherits <- base::inherits
[13:33:39.177]                       invokeRestart <- base::invokeRestart
[13:33:39.177]                       is.null <- base::is.null
[13:33:39.177]                       muffled <- FALSE
[13:33:39.177]                       if (inherits(cond, "message")) {
[13:33:39.177]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.177]                         if (muffled) 
[13:33:39.177]                           invokeRestart("muffleMessage")
[13:33:39.177]                       }
[13:33:39.177]                       else if (inherits(cond, "warning")) {
[13:33:39.177]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.177]                         if (muffled) 
[13:33:39.177]                           invokeRestart("muffleWarning")
[13:33:39.177]                       }
[13:33:39.177]                       else if (inherits(cond, "condition")) {
[13:33:39.177]                         if (!is.null(pattern)) {
[13:33:39.177]                           computeRestarts <- base::computeRestarts
[13:33:39.177]                           grepl <- base::grepl
[13:33:39.177]                           restarts <- computeRestarts(cond)
[13:33:39.177]                           for (restart in restarts) {
[13:33:39.177]                             name <- restart$name
[13:33:39.177]                             if (is.null(name)) 
[13:33:39.177]                               next
[13:33:39.177]                             if (!grepl(pattern, name)) 
[13:33:39.177]                               next
[13:33:39.177]                             invokeRestart(restart)
[13:33:39.177]                             muffled <- TRUE
[13:33:39.177]                             break
[13:33:39.177]                           }
[13:33:39.177]                         }
[13:33:39.177]                       }
[13:33:39.177]                       invisible(muffled)
[13:33:39.177]                     }
[13:33:39.177]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.177]                   }
[13:33:39.177]                 }
[13:33:39.177]             }
[13:33:39.177]         }))
[13:33:39.177]     }, error = function(ex) {
[13:33:39.177]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.177]                 ...future.rng), started = ...future.startTime, 
[13:33:39.177]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.177]             version = "1.8"), class = "FutureResult")
[13:33:39.177]     }, finally = {
[13:33:39.177]         if (!identical(...future.workdir, getwd())) 
[13:33:39.177]             setwd(...future.workdir)
[13:33:39.177]         {
[13:33:39.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.177]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.177]             }
[13:33:39.177]             base::options(...future.oldOptions)
[13:33:39.177]             if (.Platform$OS.type == "windows") {
[13:33:39.177]                 old_names <- names(...future.oldEnvVars)
[13:33:39.177]                 envs <- base::Sys.getenv()
[13:33:39.177]                 names <- names(envs)
[13:33:39.177]                 common <- intersect(names, old_names)
[13:33:39.177]                 added <- setdiff(names, old_names)
[13:33:39.177]                 removed <- setdiff(old_names, names)
[13:33:39.177]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.177]                   envs[common]]
[13:33:39.177]                 NAMES <- toupper(changed)
[13:33:39.177]                 args <- list()
[13:33:39.177]                 for (kk in seq_along(NAMES)) {
[13:33:39.177]                   name <- changed[[kk]]
[13:33:39.177]                   NAME <- NAMES[[kk]]
[13:33:39.177]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.177]                     next
[13:33:39.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.177]                 }
[13:33:39.177]                 NAMES <- toupper(added)
[13:33:39.177]                 for (kk in seq_along(NAMES)) {
[13:33:39.177]                   name <- added[[kk]]
[13:33:39.177]                   NAME <- NAMES[[kk]]
[13:33:39.177]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.177]                     next
[13:33:39.177]                   args[[name]] <- ""
[13:33:39.177]                 }
[13:33:39.177]                 NAMES <- toupper(removed)
[13:33:39.177]                 for (kk in seq_along(NAMES)) {
[13:33:39.177]                   name <- removed[[kk]]
[13:33:39.177]                   NAME <- NAMES[[kk]]
[13:33:39.177]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.177]                     next
[13:33:39.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.177]                 }
[13:33:39.177]                 if (length(args) > 0) 
[13:33:39.177]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.177]             }
[13:33:39.177]             else {
[13:33:39.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.177]             }
[13:33:39.177]             {
[13:33:39.177]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.177]                   0L) {
[13:33:39.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.177]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.177]                   base::options(opts)
[13:33:39.177]                 }
[13:33:39.177]                 {
[13:33:39.177]                   {
[13:33:39.177]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.177]                     NULL
[13:33:39.177]                   }
[13:33:39.177]                   options(future.plan = NULL)
[13:33:39.177]                   if (is.na(NA_character_)) 
[13:33:39.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.177]                     .init = FALSE)
[13:33:39.177]                 }
[13:33:39.177]             }
[13:33:39.177]         }
[13:33:39.177]     })
[13:33:39.177]     if (TRUE) {
[13:33:39.177]         base::sink(type = "output", split = FALSE)
[13:33:39.177]         if (TRUE) {
[13:33:39.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.177]         }
[13:33:39.177]         else {
[13:33:39.177]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.177]         }
[13:33:39.177]         base::close(...future.stdout)
[13:33:39.177]         ...future.stdout <- NULL
[13:33:39.177]     }
[13:33:39.177]     ...future.result$conditions <- ...future.conditions
[13:33:39.177]     ...future.result$finished <- base::Sys.time()
[13:33:39.177]     ...future.result
[13:33:39.177] }
[13:33:39.180] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[13:33:39.180] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:39.180] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.180] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:33:39.181] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:33:39.181] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[13:33:39.181] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[13:33:39.181] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:39.182] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.182] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:33:39.182] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:33:39.182] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[13:33:39.183] MultisessionFuture started
[13:33:39.183] - Launch lazy future ... done
[13:33:39.183] run() for ‘MultisessionFuture’ ... done
[13:33:39.183] Created future:
[13:33:39.183] MultisessionFuture:
[13:33:39.183] Label: ‘future_apply-2’
[13:33:39.183] Expression:
[13:33:39.183] {
[13:33:39.183]     do.call(function(...) {
[13:33:39.183]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.183]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.183]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.183]             on.exit(options(oopts), add = TRUE)
[13:33:39.183]         }
[13:33:39.183]         {
[13:33:39.183]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.183]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.183]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.183]             })
[13:33:39.183]         }
[13:33:39.183]     }, args = future.call.arguments)
[13:33:39.183] }
[13:33:39.183] Lazy evaluation: FALSE
[13:33:39.183] Asynchronous evaluation: TRUE
[13:33:39.183] Local evaluation: TRUE
[13:33:39.183] Environment: R_GlobalEnv
[13:33:39.183] Capture standard output: TRUE
[13:33:39.183] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.183] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.183] Packages: 1 packages (‘stats’)
[13:33:39.183] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.183] Resolved: FALSE
[13:33:39.183] Value: <not collected>
[13:33:39.183] Conditions captured: <none>
[13:33:39.183] Early signaling: FALSE
[13:33:39.183] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.183] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.194] Chunk #2 of 2 ... DONE
[13:33:39.195] Launching 2 futures (chunks) ... DONE
[13:33:39.195] Resolving 2 futures (chunks) ...
[13:33:39.195] resolve() on list ...
[13:33:39.195]  recursive: 0
[13:33:39.195]  length: 2
[13:33:39.195] 
[13:33:39.195] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.196] - Validating connection of MultisessionFuture
[13:33:39.196] - received message: FutureResult
[13:33:39.196] - Received FutureResult
[13:33:39.196] - Erased future from FutureRegistry
[13:33:39.196] result() for ClusterFuture ...
[13:33:39.196] - result already collected: FutureResult
[13:33:39.196] result() for ClusterFuture ... done
[13:33:39.196] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.196] Future #1
[13:33:39.196] result() for ClusterFuture ...
[13:33:39.197] - result already collected: FutureResult
[13:33:39.197] result() for ClusterFuture ... done
[13:33:39.197] result() for ClusterFuture ...
[13:33:39.197] - result already collected: FutureResult
[13:33:39.197] result() for ClusterFuture ... done
[13:33:39.197] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:39.197] - nx: 2
[13:33:39.197] - relay: TRUE
[13:33:39.197] - stdout: TRUE
[13:33:39.197] - signal: TRUE
[13:33:39.197] - resignal: FALSE
[13:33:39.197] - force: TRUE
[13:33:39.198] - relayed: [n=2] FALSE, FALSE
[13:33:39.198] - queued futures: [n=2] FALSE, FALSE
[13:33:39.198]  - until=1
[13:33:39.198]  - relaying element #1
[13:33:39.198] result() for ClusterFuture ...
[13:33:39.198] - result already collected: FutureResult
[13:33:39.198] result() for ClusterFuture ... done
[13:33:39.198] result() for ClusterFuture ...
[13:33:39.198] - result already collected: FutureResult
[13:33:39.198] result() for ClusterFuture ... done
[13:33:39.198] result() for ClusterFuture ...
[13:33:39.199] - result already collected: FutureResult
[13:33:39.199] result() for ClusterFuture ... done
[13:33:39.199] result() for ClusterFuture ...
[13:33:39.199] - result already collected: FutureResult
[13:33:39.199] result() for ClusterFuture ... done
[13:33:39.199] - relayed: [n=2] TRUE, FALSE
[13:33:39.199] - queued futures: [n=2] TRUE, FALSE
[13:33:39.199] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:39.199]  length: 1 (resolved future 1)
[13:33:39.230] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.230] - Validating connection of MultisessionFuture
[13:33:39.230] - received message: FutureResult
[13:33:39.230] - Received FutureResult
[13:33:39.230] - Erased future from FutureRegistry
[13:33:39.231] result() for ClusterFuture ...
[13:33:39.231] - result already collected: FutureResult
[13:33:39.231] result() for ClusterFuture ... done
[13:33:39.231] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.231] Future #2
[13:33:39.231] result() for ClusterFuture ...
[13:33:39.231] - result already collected: FutureResult
[13:33:39.231] result() for ClusterFuture ... done
[13:33:39.231] result() for ClusterFuture ...
[13:33:39.231] - result already collected: FutureResult
[13:33:39.231] result() for ClusterFuture ... done
[13:33:39.232] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:39.232] - nx: 2
[13:33:39.232] - relay: TRUE
[13:33:39.232] - stdout: TRUE
[13:33:39.232] - signal: TRUE
[13:33:39.232] - resignal: FALSE
[13:33:39.232] - force: TRUE
[13:33:39.232] - relayed: [n=2] TRUE, FALSE
[13:33:39.232] - queued futures: [n=2] TRUE, FALSE
[13:33:39.232]  - until=2
[13:33:39.232]  - relaying element #2
[13:33:39.232] result() for ClusterFuture ...
[13:33:39.233] - result already collected: FutureResult
[13:33:39.233] result() for ClusterFuture ... done
[13:33:39.233] result() for ClusterFuture ...
[13:33:39.233] - result already collected: FutureResult
[13:33:39.233] result() for ClusterFuture ... done
[13:33:39.233] result() for ClusterFuture ...
[13:33:39.233] - result already collected: FutureResult
[13:33:39.233] result() for ClusterFuture ... done
[13:33:39.233] result() for ClusterFuture ...
[13:33:39.233] - result already collected: FutureResult
[13:33:39.233] result() for ClusterFuture ... done
[13:33:39.233] - relayed: [n=2] TRUE, TRUE
[13:33:39.234] - queued futures: [n=2] TRUE, TRUE
[13:33:39.234] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:39.234]  length: 0 (resolved future 2)
[13:33:39.234] Relaying remaining futures
[13:33:39.234] signalConditionsASAP(NULL, pos=0) ...
[13:33:39.234] - nx: 2
[13:33:39.234] - relay: TRUE
[13:33:39.234] - stdout: TRUE
[13:33:39.234] - signal: TRUE
[13:33:39.234] - resignal: FALSE
[13:33:39.234] - force: TRUE
[13:33:39.234] - relayed: [n=2] TRUE, TRUE
[13:33:39.235] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:39.235] - relayed: [n=2] TRUE, TRUE
[13:33:39.235] - queued futures: [n=2] TRUE, TRUE
[13:33:39.235] signalConditionsASAP(NULL, pos=0) ... done
[13:33:39.235] resolve() on list ... DONE
[13:33:39.235] result() for ClusterFuture ...
[13:33:39.235] - result already collected: FutureResult
[13:33:39.235] result() for ClusterFuture ... done
[13:33:39.235] result() for ClusterFuture ...
[13:33:39.235] - result already collected: FutureResult
[13:33:39.235] result() for ClusterFuture ... done
[13:33:39.236] result() for ClusterFuture ...
[13:33:39.236] - result already collected: FutureResult
[13:33:39.236] result() for ClusterFuture ... done
[13:33:39.236] result() for ClusterFuture ...
[13:33:39.236] - result already collected: FutureResult
[13:33:39.236] result() for ClusterFuture ... done
[13:33:39.236]  - Number of value chunks collected: 2
[13:33:39.236] Resolving 2 futures (chunks) ... DONE
[13:33:39.236] Reducing values from 2 chunks ...
[13:33:39.236]  - Number of values collected after concatenation: 2
[13:33:39.236]  - Number of values expected: 2
[13:33:39.236] Reducing values from 2 chunks ... DONE
[13:33:39.237] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[13:33:39.237] getGlobalsAndPackagesXApply() ...
[13:33:39.237]  - future.globals: TRUE
[13:33:39.237] getGlobalsAndPackages() ...
[13:33:39.237] Searching for globals...
[13:33:39.238] - globals found: [1] ‘FUN’
[13:33:39.238] Searching for globals ... DONE
[13:33:39.239] Resolving globals: FALSE
[13:33:39.239] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:39.239] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:39.239] - globals: [1] ‘FUN’
[13:33:39.239] 
[13:33:39.239] getGlobalsAndPackages() ... DONE
[13:33:39.240]  - globals found/used: [n=1] ‘FUN’
[13:33:39.240]  - needed namespaces: [n=0] 
[13:33:39.240] Finding globals ... DONE
[13:33:39.240]  - use_args: TRUE
[13:33:39.240]  - Getting '...' globals ...
[13:33:39.240] resolve() on list ...
[13:33:39.240]  recursive: 0
[13:33:39.240]  length: 1
[13:33:39.240]  elements: ‘...’
[13:33:39.241]  length: 0 (resolved future 1)
[13:33:39.241] resolve() on list ... DONE
[13:33:39.241]    - '...' content: [n=0] 
[13:33:39.241] List of 1
[13:33:39.241]  $ ...: list()
[13:33:39.241]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.241]  - attr(*, "where")=List of 1
[13:33:39.241]   ..$ ...:<environment: 0x55b94be63168> 
[13:33:39.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.241]  - attr(*, "resolved")= logi TRUE
[13:33:39.241]  - attr(*, "total_size")= num NA
[13:33:39.243]  - Getting '...' globals ... DONE
[13:33:39.244] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:39.244] List of 2
[13:33:39.244]  $ ...future.FUN:function (x)  
[13:33:39.244]  $ ...          : list()
[13:33:39.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.244]  - attr(*, "where")=List of 2
[13:33:39.244]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:39.244]   ..$ ...          :<environment: 0x55b94be63168> 
[13:33:39.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.244]  - attr(*, "resolved")= logi FALSE
[13:33:39.244]  - attr(*, "total_size")= num 848
[13:33:39.246] Packages to be attached in all futures: [n=0] 
[13:33:39.246] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.252] future_lapply() ...
[13:33:39.255] Number of chunks: 2
[13:33:39.255] getGlobalsAndPackagesXApply() ...
[13:33:39.256]  - future.globals: <name-value list> with names ‘list()’
[13:33:39.256]  - use_args: TRUE
[13:33:39.256] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:39.256] List of 2
[13:33:39.256]  $ ...          : list()
[13:33:39.256]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.256]  $ ...future.FUN:function (x)  
[13:33:39.256]  - attr(*, "where")=List of 2
[13:33:39.256]   ..$ ...          :<environment: 0x55b94be63168> 
[13:33:39.256]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:39.256]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.256]  - attr(*, "resolved")= logi FALSE
[13:33:39.256]  - attr(*, "total_size")= num NA
[13:33:39.259] Packages to be attached in all futures: [n=0] 
[13:33:39.259] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.259] Number of futures (= number of chunks): 2
[13:33:39.259] Launching 2 futures (chunks) ...
[13:33:39.259] Chunk #1 of 2 ...
[13:33:39.260]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.260]  - seeds: <none>
[13:33:39.260]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.260] getGlobalsAndPackages() ...
[13:33:39.260] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.260] Resolving globals: FALSE
[13:33:39.260] Tweak future expression to call with '...' arguments ...
[13:33:39.260] {
[13:33:39.260]     do.call(function(...) {
[13:33:39.260]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.260]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.260]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.260]             on.exit(options(oopts), add = TRUE)
[13:33:39.260]         }
[13:33:39.260]         {
[13:33:39.260]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.260]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.260]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.260]             })
[13:33:39.260]         }
[13:33:39.260]     }, args = future.call.arguments)
[13:33:39.260] }
[13:33:39.261] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.261] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.261] 
[13:33:39.261] getGlobalsAndPackages() ... DONE
[13:33:39.261] run() for ‘Future’ ...
[13:33:39.261] - state: ‘created’
[13:33:39.262] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.275] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.276] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.276]   - Field: ‘node’
[13:33:39.276]   - Field: ‘label’
[13:33:39.276]   - Field: ‘local’
[13:33:39.276]   - Field: ‘owner’
[13:33:39.276]   - Field: ‘envir’
[13:33:39.276]   - Field: ‘workers’
[13:33:39.276]   - Field: ‘packages’
[13:33:39.276]   - Field: ‘gc’
[13:33:39.276]   - Field: ‘conditions’
[13:33:39.276]   - Field: ‘persistent’
[13:33:39.277]   - Field: ‘expr’
[13:33:39.277]   - Field: ‘uuid’
[13:33:39.277]   - Field: ‘seed’
[13:33:39.277]   - Field: ‘version’
[13:33:39.277]   - Field: ‘result’
[13:33:39.277]   - Field: ‘asynchronous’
[13:33:39.277]   - Field: ‘calls’
[13:33:39.277]   - Field: ‘globals’
[13:33:39.277]   - Field: ‘stdout’
[13:33:39.277]   - Field: ‘earlySignal’
[13:33:39.277]   - Field: ‘lazy’
[13:33:39.278]   - Field: ‘state’
[13:33:39.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.278] - Launch lazy future ...
[13:33:39.278] Packages needed by the future expression (n = 0): <none>
[13:33:39.278] Packages needed by future strategies (n = 0): <none>
[13:33:39.279] {
[13:33:39.279]     {
[13:33:39.279]         {
[13:33:39.279]             ...future.startTime <- base::Sys.time()
[13:33:39.279]             {
[13:33:39.279]                 {
[13:33:39.279]                   {
[13:33:39.279]                     {
[13:33:39.279]                       base::local({
[13:33:39.279]                         has_future <- base::requireNamespace("future", 
[13:33:39.279]                           quietly = TRUE)
[13:33:39.279]                         if (has_future) {
[13:33:39.279]                           ns <- base::getNamespace("future")
[13:33:39.279]                           version <- ns[[".package"]][["version"]]
[13:33:39.279]                           if (is.null(version)) 
[13:33:39.279]                             version <- utils::packageVersion("future")
[13:33:39.279]                         }
[13:33:39.279]                         else {
[13:33:39.279]                           version <- NULL
[13:33:39.279]                         }
[13:33:39.279]                         if (!has_future || version < "1.8.0") {
[13:33:39.279]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.279]                             "", base::R.version$version.string), 
[13:33:39.279]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.279]                               "release", "version")], collapse = " "), 
[13:33:39.279]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.279]                             info)
[13:33:39.279]                           info <- base::paste(info, collapse = "; ")
[13:33:39.279]                           if (!has_future) {
[13:33:39.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.279]                               info)
[13:33:39.279]                           }
[13:33:39.279]                           else {
[13:33:39.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.279]                               info, version)
[13:33:39.279]                           }
[13:33:39.279]                           base::stop(msg)
[13:33:39.279]                         }
[13:33:39.279]                       })
[13:33:39.279]                     }
[13:33:39.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.279]                     base::options(mc.cores = 1L)
[13:33:39.279]                   }
[13:33:39.279]                   ...future.strategy.old <- future::plan("list")
[13:33:39.279]                   options(future.plan = NULL)
[13:33:39.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.279]                 }
[13:33:39.279]                 ...future.workdir <- getwd()
[13:33:39.279]             }
[13:33:39.279]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.279]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.279]         }
[13:33:39.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.279]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.279]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.279]             base::names(...future.oldOptions))
[13:33:39.279]     }
[13:33:39.279]     if (FALSE) {
[13:33:39.279]     }
[13:33:39.279]     else {
[13:33:39.279]         if (TRUE) {
[13:33:39.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.279]                 open = "w")
[13:33:39.279]         }
[13:33:39.279]         else {
[13:33:39.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.279]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.279]         }
[13:33:39.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.279]             base::sink(type = "output", split = FALSE)
[13:33:39.279]             base::close(...future.stdout)
[13:33:39.279]         }, add = TRUE)
[13:33:39.279]     }
[13:33:39.279]     ...future.frame <- base::sys.nframe()
[13:33:39.279]     ...future.conditions <- base::list()
[13:33:39.279]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.279]     if (FALSE) {
[13:33:39.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.279]     }
[13:33:39.279]     ...future.result <- base::tryCatch({
[13:33:39.279]         base::withCallingHandlers({
[13:33:39.279]             ...future.value <- base::withVisible(base::local({
[13:33:39.279]                 ...future.makeSendCondition <- base::local({
[13:33:39.279]                   sendCondition <- NULL
[13:33:39.279]                   function(frame = 1L) {
[13:33:39.279]                     if (is.function(sendCondition)) 
[13:33:39.279]                       return(sendCondition)
[13:33:39.279]                     ns <- getNamespace("parallel")
[13:33:39.279]                     if (exists("sendData", mode = "function", 
[13:33:39.279]                       envir = ns)) {
[13:33:39.279]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.279]                         envir = ns)
[13:33:39.279]                       envir <- sys.frame(frame)
[13:33:39.279]                       master <- NULL
[13:33:39.279]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.279]                         !identical(envir, emptyenv())) {
[13:33:39.279]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.279]                           inherits = FALSE)) {
[13:33:39.279]                           master <- get("master", mode = "list", 
[13:33:39.279]                             envir = envir, inherits = FALSE)
[13:33:39.279]                           if (inherits(master, c("SOCKnode", 
[13:33:39.279]                             "SOCK0node"))) {
[13:33:39.279]                             sendCondition <<- function(cond) {
[13:33:39.279]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.279]                                 success = TRUE)
[13:33:39.279]                               parallel_sendData(master, data)
[13:33:39.279]                             }
[13:33:39.279]                             return(sendCondition)
[13:33:39.279]                           }
[13:33:39.279]                         }
[13:33:39.279]                         frame <- frame + 1L
[13:33:39.279]                         envir <- sys.frame(frame)
[13:33:39.279]                       }
[13:33:39.279]                     }
[13:33:39.279]                     sendCondition <<- function(cond) NULL
[13:33:39.279]                   }
[13:33:39.279]                 })
[13:33:39.279]                 withCallingHandlers({
[13:33:39.279]                   {
[13:33:39.279]                     do.call(function(...) {
[13:33:39.279]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.279]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.279]                         ...future.globals.maxSize)) {
[13:33:39.279]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.279]                         on.exit(options(oopts), add = TRUE)
[13:33:39.279]                       }
[13:33:39.279]                       {
[13:33:39.279]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.279]                           FUN = function(jj) {
[13:33:39.279]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.279]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.279]                           })
[13:33:39.279]                       }
[13:33:39.279]                     }, args = future.call.arguments)
[13:33:39.279]                   }
[13:33:39.279]                 }, immediateCondition = function(cond) {
[13:33:39.279]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.279]                   sendCondition(cond)
[13:33:39.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.279]                   {
[13:33:39.279]                     inherits <- base::inherits
[13:33:39.279]                     invokeRestart <- base::invokeRestart
[13:33:39.279]                     is.null <- base::is.null
[13:33:39.279]                     muffled <- FALSE
[13:33:39.279]                     if (inherits(cond, "message")) {
[13:33:39.279]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.279]                       if (muffled) 
[13:33:39.279]                         invokeRestart("muffleMessage")
[13:33:39.279]                     }
[13:33:39.279]                     else if (inherits(cond, "warning")) {
[13:33:39.279]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.279]                       if (muffled) 
[13:33:39.279]                         invokeRestart("muffleWarning")
[13:33:39.279]                     }
[13:33:39.279]                     else if (inherits(cond, "condition")) {
[13:33:39.279]                       if (!is.null(pattern)) {
[13:33:39.279]                         computeRestarts <- base::computeRestarts
[13:33:39.279]                         grepl <- base::grepl
[13:33:39.279]                         restarts <- computeRestarts(cond)
[13:33:39.279]                         for (restart in restarts) {
[13:33:39.279]                           name <- restart$name
[13:33:39.279]                           if (is.null(name)) 
[13:33:39.279]                             next
[13:33:39.279]                           if (!grepl(pattern, name)) 
[13:33:39.279]                             next
[13:33:39.279]                           invokeRestart(restart)
[13:33:39.279]                           muffled <- TRUE
[13:33:39.279]                           break
[13:33:39.279]                         }
[13:33:39.279]                       }
[13:33:39.279]                     }
[13:33:39.279]                     invisible(muffled)
[13:33:39.279]                   }
[13:33:39.279]                   muffleCondition(cond)
[13:33:39.279]                 })
[13:33:39.279]             }))
[13:33:39.279]             future::FutureResult(value = ...future.value$value, 
[13:33:39.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.279]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.279]                     ...future.globalenv.names))
[13:33:39.279]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.279]         }, condition = base::local({
[13:33:39.279]             c <- base::c
[13:33:39.279]             inherits <- base::inherits
[13:33:39.279]             invokeRestart <- base::invokeRestart
[13:33:39.279]             length <- base::length
[13:33:39.279]             list <- base::list
[13:33:39.279]             seq.int <- base::seq.int
[13:33:39.279]             signalCondition <- base::signalCondition
[13:33:39.279]             sys.calls <- base::sys.calls
[13:33:39.279]             `[[` <- base::`[[`
[13:33:39.279]             `+` <- base::`+`
[13:33:39.279]             `<<-` <- base::`<<-`
[13:33:39.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.279]                   3L)]
[13:33:39.279]             }
[13:33:39.279]             function(cond) {
[13:33:39.279]                 is_error <- inherits(cond, "error")
[13:33:39.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.279]                   NULL)
[13:33:39.279]                 if (is_error) {
[13:33:39.279]                   sessionInformation <- function() {
[13:33:39.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.279]                       search = base::search(), system = base::Sys.info())
[13:33:39.279]                   }
[13:33:39.279]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.279]                     cond$call), session = sessionInformation(), 
[13:33:39.279]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.279]                   signalCondition(cond)
[13:33:39.279]                 }
[13:33:39.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.279]                 "immediateCondition"))) {
[13:33:39.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.279]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.279]                   if (TRUE && !signal) {
[13:33:39.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.279]                     {
[13:33:39.279]                       inherits <- base::inherits
[13:33:39.279]                       invokeRestart <- base::invokeRestart
[13:33:39.279]                       is.null <- base::is.null
[13:33:39.279]                       muffled <- FALSE
[13:33:39.279]                       if (inherits(cond, "message")) {
[13:33:39.279]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.279]                         if (muffled) 
[13:33:39.279]                           invokeRestart("muffleMessage")
[13:33:39.279]                       }
[13:33:39.279]                       else if (inherits(cond, "warning")) {
[13:33:39.279]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.279]                         if (muffled) 
[13:33:39.279]                           invokeRestart("muffleWarning")
[13:33:39.279]                       }
[13:33:39.279]                       else if (inherits(cond, "condition")) {
[13:33:39.279]                         if (!is.null(pattern)) {
[13:33:39.279]                           computeRestarts <- base::computeRestarts
[13:33:39.279]                           grepl <- base::grepl
[13:33:39.279]                           restarts <- computeRestarts(cond)
[13:33:39.279]                           for (restart in restarts) {
[13:33:39.279]                             name <- restart$name
[13:33:39.279]                             if (is.null(name)) 
[13:33:39.279]                               next
[13:33:39.279]                             if (!grepl(pattern, name)) 
[13:33:39.279]                               next
[13:33:39.279]                             invokeRestart(restart)
[13:33:39.279]                             muffled <- TRUE
[13:33:39.279]                             break
[13:33:39.279]                           }
[13:33:39.279]                         }
[13:33:39.279]                       }
[13:33:39.279]                       invisible(muffled)
[13:33:39.279]                     }
[13:33:39.279]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.279]                   }
[13:33:39.279]                 }
[13:33:39.279]                 else {
[13:33:39.279]                   if (TRUE) {
[13:33:39.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.279]                     {
[13:33:39.279]                       inherits <- base::inherits
[13:33:39.279]                       invokeRestart <- base::invokeRestart
[13:33:39.279]                       is.null <- base::is.null
[13:33:39.279]                       muffled <- FALSE
[13:33:39.279]                       if (inherits(cond, "message")) {
[13:33:39.279]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.279]                         if (muffled) 
[13:33:39.279]                           invokeRestart("muffleMessage")
[13:33:39.279]                       }
[13:33:39.279]                       else if (inherits(cond, "warning")) {
[13:33:39.279]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.279]                         if (muffled) 
[13:33:39.279]                           invokeRestart("muffleWarning")
[13:33:39.279]                       }
[13:33:39.279]                       else if (inherits(cond, "condition")) {
[13:33:39.279]                         if (!is.null(pattern)) {
[13:33:39.279]                           computeRestarts <- base::computeRestarts
[13:33:39.279]                           grepl <- base::grepl
[13:33:39.279]                           restarts <- computeRestarts(cond)
[13:33:39.279]                           for (restart in restarts) {
[13:33:39.279]                             name <- restart$name
[13:33:39.279]                             if (is.null(name)) 
[13:33:39.279]                               next
[13:33:39.279]                             if (!grepl(pattern, name)) 
[13:33:39.279]                               next
[13:33:39.279]                             invokeRestart(restart)
[13:33:39.279]                             muffled <- TRUE
[13:33:39.279]                             break
[13:33:39.279]                           }
[13:33:39.279]                         }
[13:33:39.279]                       }
[13:33:39.279]                       invisible(muffled)
[13:33:39.279]                     }
[13:33:39.279]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.279]                   }
[13:33:39.279]                 }
[13:33:39.279]             }
[13:33:39.279]         }))
[13:33:39.279]     }, error = function(ex) {
[13:33:39.279]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.279]                 ...future.rng), started = ...future.startTime, 
[13:33:39.279]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.279]             version = "1.8"), class = "FutureResult")
[13:33:39.279]     }, finally = {
[13:33:39.279]         if (!identical(...future.workdir, getwd())) 
[13:33:39.279]             setwd(...future.workdir)
[13:33:39.279]         {
[13:33:39.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.279]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.279]             }
[13:33:39.279]             base::options(...future.oldOptions)
[13:33:39.279]             if (.Platform$OS.type == "windows") {
[13:33:39.279]                 old_names <- names(...future.oldEnvVars)
[13:33:39.279]                 envs <- base::Sys.getenv()
[13:33:39.279]                 names <- names(envs)
[13:33:39.279]                 common <- intersect(names, old_names)
[13:33:39.279]                 added <- setdiff(names, old_names)
[13:33:39.279]                 removed <- setdiff(old_names, names)
[13:33:39.279]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.279]                   envs[common]]
[13:33:39.279]                 NAMES <- toupper(changed)
[13:33:39.279]                 args <- list()
[13:33:39.279]                 for (kk in seq_along(NAMES)) {
[13:33:39.279]                   name <- changed[[kk]]
[13:33:39.279]                   NAME <- NAMES[[kk]]
[13:33:39.279]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.279]                     next
[13:33:39.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.279]                 }
[13:33:39.279]                 NAMES <- toupper(added)
[13:33:39.279]                 for (kk in seq_along(NAMES)) {
[13:33:39.279]                   name <- added[[kk]]
[13:33:39.279]                   NAME <- NAMES[[kk]]
[13:33:39.279]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.279]                     next
[13:33:39.279]                   args[[name]] <- ""
[13:33:39.279]                 }
[13:33:39.279]                 NAMES <- toupper(removed)
[13:33:39.279]                 for (kk in seq_along(NAMES)) {
[13:33:39.279]                   name <- removed[[kk]]
[13:33:39.279]                   NAME <- NAMES[[kk]]
[13:33:39.279]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.279]                     next
[13:33:39.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.279]                 }
[13:33:39.279]                 if (length(args) > 0) 
[13:33:39.279]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.279]             }
[13:33:39.279]             else {
[13:33:39.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.279]             }
[13:33:39.279]             {
[13:33:39.279]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.279]                   0L) {
[13:33:39.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.279]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.279]                   base::options(opts)
[13:33:39.279]                 }
[13:33:39.279]                 {
[13:33:39.279]                   {
[13:33:39.279]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.279]                     NULL
[13:33:39.279]                   }
[13:33:39.279]                   options(future.plan = NULL)
[13:33:39.279]                   if (is.na(NA_character_)) 
[13:33:39.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.279]                     .init = FALSE)
[13:33:39.279]                 }
[13:33:39.279]             }
[13:33:39.279]         }
[13:33:39.279]     })
[13:33:39.279]     if (TRUE) {
[13:33:39.279]         base::sink(type = "output", split = FALSE)
[13:33:39.279]         if (TRUE) {
[13:33:39.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.279]         }
[13:33:39.279]         else {
[13:33:39.279]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.279]         }
[13:33:39.279]         base::close(...future.stdout)
[13:33:39.279]         ...future.stdout <- NULL
[13:33:39.279]     }
[13:33:39.279]     ...future.result$conditions <- ...future.conditions
[13:33:39.279]     ...future.result$finished <- base::Sys.time()
[13:33:39.279]     ...future.result
[13:33:39.279] }
[13:33:39.281] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[13:33:39.282] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:39.282] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.282] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:33:39.282] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:33:39.283] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:33:39.283] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:33:39.283] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:39.283] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.283] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:39.284] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:39.284] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[13:33:39.284] MultisessionFuture started
[13:33:39.284] - Launch lazy future ... done
[13:33:39.284] run() for ‘MultisessionFuture’ ... done
[13:33:39.285] Created future:
[13:33:39.285] MultisessionFuture:
[13:33:39.285] Label: ‘future_apply-1’
[13:33:39.285] Expression:
[13:33:39.285] {
[13:33:39.285]     do.call(function(...) {
[13:33:39.285]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.285]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.285]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.285]             on.exit(options(oopts), add = TRUE)
[13:33:39.285]         }
[13:33:39.285]         {
[13:33:39.285]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.285]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.285]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.285]             })
[13:33:39.285]         }
[13:33:39.285]     }, args = future.call.arguments)
[13:33:39.285] }
[13:33:39.285] Lazy evaluation: FALSE
[13:33:39.285] Asynchronous evaluation: TRUE
[13:33:39.285] Local evaluation: TRUE
[13:33:39.285] Environment: R_GlobalEnv
[13:33:39.285] Capture standard output: TRUE
[13:33:39.285] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.285] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.285] Packages: <none>
[13:33:39.285] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.285] Resolved: FALSE
[13:33:39.285] Value: <not collected>
[13:33:39.285] Conditions captured: <none>
[13:33:39.285] Early signaling: FALSE
[13:33:39.285] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.285] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.296] Chunk #1 of 2 ... DONE
[13:33:39.296] Chunk #2 of 2 ...
[13:33:39.296]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.297]  - seeds: <none>
[13:33:39.297]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.297] getGlobalsAndPackages() ...
[13:33:39.297] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.297] Resolving globals: FALSE
[13:33:39.297] Tweak future expression to call with '...' arguments ...
[13:33:39.297] {
[13:33:39.297]     do.call(function(...) {
[13:33:39.297]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.297]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.297]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.297]             on.exit(options(oopts), add = TRUE)
[13:33:39.297]         }
[13:33:39.297]         {
[13:33:39.297]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.297]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.297]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.297]             })
[13:33:39.297]         }
[13:33:39.297]     }, args = future.call.arguments)
[13:33:39.297] }
[13:33:39.297] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.298] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.298] 
[13:33:39.298] getGlobalsAndPackages() ... DONE
[13:33:39.298] run() for ‘Future’ ...
[13:33:39.298] - state: ‘created’
[13:33:39.299] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.313]   - Field: ‘node’
[13:33:39.313]   - Field: ‘label’
[13:33:39.313]   - Field: ‘local’
[13:33:39.313]   - Field: ‘owner’
[13:33:39.313]   - Field: ‘envir’
[13:33:39.313]   - Field: ‘workers’
[13:33:39.313]   - Field: ‘packages’
[13:33:39.314]   - Field: ‘gc’
[13:33:39.314]   - Field: ‘conditions’
[13:33:39.314]   - Field: ‘persistent’
[13:33:39.314]   - Field: ‘expr’
[13:33:39.314]   - Field: ‘uuid’
[13:33:39.314]   - Field: ‘seed’
[13:33:39.314]   - Field: ‘version’
[13:33:39.314]   - Field: ‘result’
[13:33:39.314]   - Field: ‘asynchronous’
[13:33:39.314]   - Field: ‘calls’
[13:33:39.315]   - Field: ‘globals’
[13:33:39.315]   - Field: ‘stdout’
[13:33:39.315]   - Field: ‘earlySignal’
[13:33:39.315]   - Field: ‘lazy’
[13:33:39.315]   - Field: ‘state’
[13:33:39.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.315] - Launch lazy future ...
[13:33:39.315] Packages needed by the future expression (n = 0): <none>
[13:33:39.316] Packages needed by future strategies (n = 0): <none>
[13:33:39.316] {
[13:33:39.316]     {
[13:33:39.316]         {
[13:33:39.316]             ...future.startTime <- base::Sys.time()
[13:33:39.316]             {
[13:33:39.316]                 {
[13:33:39.316]                   {
[13:33:39.316]                     {
[13:33:39.316]                       base::local({
[13:33:39.316]                         has_future <- base::requireNamespace("future", 
[13:33:39.316]                           quietly = TRUE)
[13:33:39.316]                         if (has_future) {
[13:33:39.316]                           ns <- base::getNamespace("future")
[13:33:39.316]                           version <- ns[[".package"]][["version"]]
[13:33:39.316]                           if (is.null(version)) 
[13:33:39.316]                             version <- utils::packageVersion("future")
[13:33:39.316]                         }
[13:33:39.316]                         else {
[13:33:39.316]                           version <- NULL
[13:33:39.316]                         }
[13:33:39.316]                         if (!has_future || version < "1.8.0") {
[13:33:39.316]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.316]                             "", base::R.version$version.string), 
[13:33:39.316]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.316]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.316]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.316]                               "release", "version")], collapse = " "), 
[13:33:39.316]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.316]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.316]                             info)
[13:33:39.316]                           info <- base::paste(info, collapse = "; ")
[13:33:39.316]                           if (!has_future) {
[13:33:39.316]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.316]                               info)
[13:33:39.316]                           }
[13:33:39.316]                           else {
[13:33:39.316]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.316]                               info, version)
[13:33:39.316]                           }
[13:33:39.316]                           base::stop(msg)
[13:33:39.316]                         }
[13:33:39.316]                       })
[13:33:39.316]                     }
[13:33:39.316]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.316]                     base::options(mc.cores = 1L)
[13:33:39.316]                   }
[13:33:39.316]                   ...future.strategy.old <- future::plan("list")
[13:33:39.316]                   options(future.plan = NULL)
[13:33:39.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.316]                 }
[13:33:39.316]                 ...future.workdir <- getwd()
[13:33:39.316]             }
[13:33:39.316]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.316]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.316]         }
[13:33:39.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.316]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.316]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.316]             base::names(...future.oldOptions))
[13:33:39.316]     }
[13:33:39.316]     if (FALSE) {
[13:33:39.316]     }
[13:33:39.316]     else {
[13:33:39.316]         if (TRUE) {
[13:33:39.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.316]                 open = "w")
[13:33:39.316]         }
[13:33:39.316]         else {
[13:33:39.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.316]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.316]         }
[13:33:39.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.316]             base::sink(type = "output", split = FALSE)
[13:33:39.316]             base::close(...future.stdout)
[13:33:39.316]         }, add = TRUE)
[13:33:39.316]     }
[13:33:39.316]     ...future.frame <- base::sys.nframe()
[13:33:39.316]     ...future.conditions <- base::list()
[13:33:39.316]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.316]     if (FALSE) {
[13:33:39.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.316]     }
[13:33:39.316]     ...future.result <- base::tryCatch({
[13:33:39.316]         base::withCallingHandlers({
[13:33:39.316]             ...future.value <- base::withVisible(base::local({
[13:33:39.316]                 ...future.makeSendCondition <- base::local({
[13:33:39.316]                   sendCondition <- NULL
[13:33:39.316]                   function(frame = 1L) {
[13:33:39.316]                     if (is.function(sendCondition)) 
[13:33:39.316]                       return(sendCondition)
[13:33:39.316]                     ns <- getNamespace("parallel")
[13:33:39.316]                     if (exists("sendData", mode = "function", 
[13:33:39.316]                       envir = ns)) {
[13:33:39.316]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.316]                         envir = ns)
[13:33:39.316]                       envir <- sys.frame(frame)
[13:33:39.316]                       master <- NULL
[13:33:39.316]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.316]                         !identical(envir, emptyenv())) {
[13:33:39.316]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.316]                           inherits = FALSE)) {
[13:33:39.316]                           master <- get("master", mode = "list", 
[13:33:39.316]                             envir = envir, inherits = FALSE)
[13:33:39.316]                           if (inherits(master, c("SOCKnode", 
[13:33:39.316]                             "SOCK0node"))) {
[13:33:39.316]                             sendCondition <<- function(cond) {
[13:33:39.316]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.316]                                 success = TRUE)
[13:33:39.316]                               parallel_sendData(master, data)
[13:33:39.316]                             }
[13:33:39.316]                             return(sendCondition)
[13:33:39.316]                           }
[13:33:39.316]                         }
[13:33:39.316]                         frame <- frame + 1L
[13:33:39.316]                         envir <- sys.frame(frame)
[13:33:39.316]                       }
[13:33:39.316]                     }
[13:33:39.316]                     sendCondition <<- function(cond) NULL
[13:33:39.316]                   }
[13:33:39.316]                 })
[13:33:39.316]                 withCallingHandlers({
[13:33:39.316]                   {
[13:33:39.316]                     do.call(function(...) {
[13:33:39.316]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.316]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.316]                         ...future.globals.maxSize)) {
[13:33:39.316]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.316]                         on.exit(options(oopts), add = TRUE)
[13:33:39.316]                       }
[13:33:39.316]                       {
[13:33:39.316]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.316]                           FUN = function(jj) {
[13:33:39.316]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.316]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.316]                           })
[13:33:39.316]                       }
[13:33:39.316]                     }, args = future.call.arguments)
[13:33:39.316]                   }
[13:33:39.316]                 }, immediateCondition = function(cond) {
[13:33:39.316]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.316]                   sendCondition(cond)
[13:33:39.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.316]                   {
[13:33:39.316]                     inherits <- base::inherits
[13:33:39.316]                     invokeRestart <- base::invokeRestart
[13:33:39.316]                     is.null <- base::is.null
[13:33:39.316]                     muffled <- FALSE
[13:33:39.316]                     if (inherits(cond, "message")) {
[13:33:39.316]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.316]                       if (muffled) 
[13:33:39.316]                         invokeRestart("muffleMessage")
[13:33:39.316]                     }
[13:33:39.316]                     else if (inherits(cond, "warning")) {
[13:33:39.316]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.316]                       if (muffled) 
[13:33:39.316]                         invokeRestart("muffleWarning")
[13:33:39.316]                     }
[13:33:39.316]                     else if (inherits(cond, "condition")) {
[13:33:39.316]                       if (!is.null(pattern)) {
[13:33:39.316]                         computeRestarts <- base::computeRestarts
[13:33:39.316]                         grepl <- base::grepl
[13:33:39.316]                         restarts <- computeRestarts(cond)
[13:33:39.316]                         for (restart in restarts) {
[13:33:39.316]                           name <- restart$name
[13:33:39.316]                           if (is.null(name)) 
[13:33:39.316]                             next
[13:33:39.316]                           if (!grepl(pattern, name)) 
[13:33:39.316]                             next
[13:33:39.316]                           invokeRestart(restart)
[13:33:39.316]                           muffled <- TRUE
[13:33:39.316]                           break
[13:33:39.316]                         }
[13:33:39.316]                       }
[13:33:39.316]                     }
[13:33:39.316]                     invisible(muffled)
[13:33:39.316]                   }
[13:33:39.316]                   muffleCondition(cond)
[13:33:39.316]                 })
[13:33:39.316]             }))
[13:33:39.316]             future::FutureResult(value = ...future.value$value, 
[13:33:39.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.316]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.316]                     ...future.globalenv.names))
[13:33:39.316]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.316]         }, condition = base::local({
[13:33:39.316]             c <- base::c
[13:33:39.316]             inherits <- base::inherits
[13:33:39.316]             invokeRestart <- base::invokeRestart
[13:33:39.316]             length <- base::length
[13:33:39.316]             list <- base::list
[13:33:39.316]             seq.int <- base::seq.int
[13:33:39.316]             signalCondition <- base::signalCondition
[13:33:39.316]             sys.calls <- base::sys.calls
[13:33:39.316]             `[[` <- base::`[[`
[13:33:39.316]             `+` <- base::`+`
[13:33:39.316]             `<<-` <- base::`<<-`
[13:33:39.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.316]                   3L)]
[13:33:39.316]             }
[13:33:39.316]             function(cond) {
[13:33:39.316]                 is_error <- inherits(cond, "error")
[13:33:39.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.316]                   NULL)
[13:33:39.316]                 if (is_error) {
[13:33:39.316]                   sessionInformation <- function() {
[13:33:39.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.316]                       search = base::search(), system = base::Sys.info())
[13:33:39.316]                   }
[13:33:39.316]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.316]                     cond$call), session = sessionInformation(), 
[13:33:39.316]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.316]                   signalCondition(cond)
[13:33:39.316]                 }
[13:33:39.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.316]                 "immediateCondition"))) {
[13:33:39.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.316]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.316]                   if (TRUE && !signal) {
[13:33:39.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.316]                     {
[13:33:39.316]                       inherits <- base::inherits
[13:33:39.316]                       invokeRestart <- base::invokeRestart
[13:33:39.316]                       is.null <- base::is.null
[13:33:39.316]                       muffled <- FALSE
[13:33:39.316]                       if (inherits(cond, "message")) {
[13:33:39.316]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.316]                         if (muffled) 
[13:33:39.316]                           invokeRestart("muffleMessage")
[13:33:39.316]                       }
[13:33:39.316]                       else if (inherits(cond, "warning")) {
[13:33:39.316]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.316]                         if (muffled) 
[13:33:39.316]                           invokeRestart("muffleWarning")
[13:33:39.316]                       }
[13:33:39.316]                       else if (inherits(cond, "condition")) {
[13:33:39.316]                         if (!is.null(pattern)) {
[13:33:39.316]                           computeRestarts <- base::computeRestarts
[13:33:39.316]                           grepl <- base::grepl
[13:33:39.316]                           restarts <- computeRestarts(cond)
[13:33:39.316]                           for (restart in restarts) {
[13:33:39.316]                             name <- restart$name
[13:33:39.316]                             if (is.null(name)) 
[13:33:39.316]                               next
[13:33:39.316]                             if (!grepl(pattern, name)) 
[13:33:39.316]                               next
[13:33:39.316]                             invokeRestart(restart)
[13:33:39.316]                             muffled <- TRUE
[13:33:39.316]                             break
[13:33:39.316]                           }
[13:33:39.316]                         }
[13:33:39.316]                       }
[13:33:39.316]                       invisible(muffled)
[13:33:39.316]                     }
[13:33:39.316]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.316]                   }
[13:33:39.316]                 }
[13:33:39.316]                 else {
[13:33:39.316]                   if (TRUE) {
[13:33:39.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.316]                     {
[13:33:39.316]                       inherits <- base::inherits
[13:33:39.316]                       invokeRestart <- base::invokeRestart
[13:33:39.316]                       is.null <- base::is.null
[13:33:39.316]                       muffled <- FALSE
[13:33:39.316]                       if (inherits(cond, "message")) {
[13:33:39.316]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.316]                         if (muffled) 
[13:33:39.316]                           invokeRestart("muffleMessage")
[13:33:39.316]                       }
[13:33:39.316]                       else if (inherits(cond, "warning")) {
[13:33:39.316]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.316]                         if (muffled) 
[13:33:39.316]                           invokeRestart("muffleWarning")
[13:33:39.316]                       }
[13:33:39.316]                       else if (inherits(cond, "condition")) {
[13:33:39.316]                         if (!is.null(pattern)) {
[13:33:39.316]                           computeRestarts <- base::computeRestarts
[13:33:39.316]                           grepl <- base::grepl
[13:33:39.316]                           restarts <- computeRestarts(cond)
[13:33:39.316]                           for (restart in restarts) {
[13:33:39.316]                             name <- restart$name
[13:33:39.316]                             if (is.null(name)) 
[13:33:39.316]                               next
[13:33:39.316]                             if (!grepl(pattern, name)) 
[13:33:39.316]                               next
[13:33:39.316]                             invokeRestart(restart)
[13:33:39.316]                             muffled <- TRUE
[13:33:39.316]                             break
[13:33:39.316]                           }
[13:33:39.316]                         }
[13:33:39.316]                       }
[13:33:39.316]                       invisible(muffled)
[13:33:39.316]                     }
[13:33:39.316]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.316]                   }
[13:33:39.316]                 }
[13:33:39.316]             }
[13:33:39.316]         }))
[13:33:39.316]     }, error = function(ex) {
[13:33:39.316]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.316]                 ...future.rng), started = ...future.startTime, 
[13:33:39.316]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.316]             version = "1.8"), class = "FutureResult")
[13:33:39.316]     }, finally = {
[13:33:39.316]         if (!identical(...future.workdir, getwd())) 
[13:33:39.316]             setwd(...future.workdir)
[13:33:39.316]         {
[13:33:39.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.316]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.316]             }
[13:33:39.316]             base::options(...future.oldOptions)
[13:33:39.316]             if (.Platform$OS.type == "windows") {
[13:33:39.316]                 old_names <- names(...future.oldEnvVars)
[13:33:39.316]                 envs <- base::Sys.getenv()
[13:33:39.316]                 names <- names(envs)
[13:33:39.316]                 common <- intersect(names, old_names)
[13:33:39.316]                 added <- setdiff(names, old_names)
[13:33:39.316]                 removed <- setdiff(old_names, names)
[13:33:39.316]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.316]                   envs[common]]
[13:33:39.316]                 NAMES <- toupper(changed)
[13:33:39.316]                 args <- list()
[13:33:39.316]                 for (kk in seq_along(NAMES)) {
[13:33:39.316]                   name <- changed[[kk]]
[13:33:39.316]                   NAME <- NAMES[[kk]]
[13:33:39.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.316]                     next
[13:33:39.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.316]                 }
[13:33:39.316]                 NAMES <- toupper(added)
[13:33:39.316]                 for (kk in seq_along(NAMES)) {
[13:33:39.316]                   name <- added[[kk]]
[13:33:39.316]                   NAME <- NAMES[[kk]]
[13:33:39.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.316]                     next
[13:33:39.316]                   args[[name]] <- ""
[13:33:39.316]                 }
[13:33:39.316]                 NAMES <- toupper(removed)
[13:33:39.316]                 for (kk in seq_along(NAMES)) {
[13:33:39.316]                   name <- removed[[kk]]
[13:33:39.316]                   NAME <- NAMES[[kk]]
[13:33:39.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.316]                     next
[13:33:39.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.316]                 }
[13:33:39.316]                 if (length(args) > 0) 
[13:33:39.316]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.316]             }
[13:33:39.316]             else {
[13:33:39.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.316]             }
[13:33:39.316]             {
[13:33:39.316]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.316]                   0L) {
[13:33:39.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.316]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.316]                   base::options(opts)
[13:33:39.316]                 }
[13:33:39.316]                 {
[13:33:39.316]                   {
[13:33:39.316]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.316]                     NULL
[13:33:39.316]                   }
[13:33:39.316]                   options(future.plan = NULL)
[13:33:39.316]                   if (is.na(NA_character_)) 
[13:33:39.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.316]                     .init = FALSE)
[13:33:39.316]                 }
[13:33:39.316]             }
[13:33:39.316]         }
[13:33:39.316]     })
[13:33:39.316]     if (TRUE) {
[13:33:39.316]         base::sink(type = "output", split = FALSE)
[13:33:39.316]         if (TRUE) {
[13:33:39.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.316]         }
[13:33:39.316]         else {
[13:33:39.316]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.316]         }
[13:33:39.316]         base::close(...future.stdout)
[13:33:39.316]         ...future.stdout <- NULL
[13:33:39.316]     }
[13:33:39.316]     ...future.result$conditions <- ...future.conditions
[13:33:39.316]     ...future.result$finished <- base::Sys.time()
[13:33:39.316]     ...future.result
[13:33:39.316] }
[13:33:39.319] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[13:33:39.319] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:39.320] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.320] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:33:39.320] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:33:39.320] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:33:39.321] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:33:39.321] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:39.321] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.321] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:33:39.322] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:33:39.322] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[13:33:39.322] MultisessionFuture started
[13:33:39.322] - Launch lazy future ... done
[13:33:39.323] run() for ‘MultisessionFuture’ ... done
[13:33:39.323] Created future:
[13:33:39.323] MultisessionFuture:
[13:33:39.323] Label: ‘future_apply-2’
[13:33:39.323] Expression:
[13:33:39.323] {
[13:33:39.323]     do.call(function(...) {
[13:33:39.323]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.323]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.323]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.323]             on.exit(options(oopts), add = TRUE)
[13:33:39.323]         }
[13:33:39.323]         {
[13:33:39.323]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.323]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.323]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.323]             })
[13:33:39.323]         }
[13:33:39.323]     }, args = future.call.arguments)
[13:33:39.323] }
[13:33:39.323] Lazy evaluation: FALSE
[13:33:39.323] Asynchronous evaluation: TRUE
[13:33:39.323] Local evaluation: TRUE
[13:33:39.323] Environment: R_GlobalEnv
[13:33:39.323] Capture standard output: TRUE
[13:33:39.323] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.323] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.323] Packages: <none>
[13:33:39.323] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.323] Resolved: FALSE
[13:33:39.323] Value: <not collected>
[13:33:39.323] Conditions captured: <none>
[13:33:39.323] Early signaling: FALSE
[13:33:39.323] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.323] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.334] Chunk #2 of 2 ... DONE
[13:33:39.335] Launching 2 futures (chunks) ... DONE
[13:33:39.335] Resolving 2 futures (chunks) ...
[13:33:39.335] resolve() on list ...
[13:33:39.335]  recursive: 0
[13:33:39.335]  length: 2
[13:33:39.335] 
[13:33:39.336] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.336] - Validating connection of MultisessionFuture
[13:33:39.336] - received message: FutureResult
[13:33:39.336] - Received FutureResult
[13:33:39.336] - Erased future from FutureRegistry
[13:33:39.336] result() for ClusterFuture ...
[13:33:39.336] - result already collected: FutureResult
[13:33:39.336] result() for ClusterFuture ... done
[13:33:39.336] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.337] Future #1
[13:33:39.337] result() for ClusterFuture ...
[13:33:39.337] - result already collected: FutureResult
[13:33:39.337] result() for ClusterFuture ... done
[13:33:39.337] result() for ClusterFuture ...
[13:33:39.337] - result already collected: FutureResult
[13:33:39.337] result() for ClusterFuture ... done
[13:33:39.337] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:39.337] - nx: 2
[13:33:39.337] - relay: TRUE
[13:33:39.337] - stdout: TRUE
[13:33:39.337] - signal: TRUE
[13:33:39.338] - resignal: FALSE
[13:33:39.338] - force: TRUE
[13:33:39.338] - relayed: [n=2] FALSE, FALSE
[13:33:39.338] - queued futures: [n=2] FALSE, FALSE
[13:33:39.338]  - until=1
[13:33:39.338]  - relaying element #1
[13:33:39.338] result() for ClusterFuture ...
[13:33:39.338] - result already collected: FutureResult
[13:33:39.338] result() for ClusterFuture ... done
[13:33:39.338] result() for ClusterFuture ...
[13:33:39.339] - result already collected: FutureResult
[13:33:39.339] result() for ClusterFuture ... done
[13:33:39.339] result() for ClusterFuture ...
[13:33:39.339] - result already collected: FutureResult
[13:33:39.339] result() for ClusterFuture ... done
[13:33:39.339] result() for ClusterFuture ...
[13:33:39.339] - result already collected: FutureResult
[13:33:39.339] result() for ClusterFuture ... done
[13:33:39.339] - relayed: [n=2] TRUE, FALSE
[13:33:39.339] - queued futures: [n=2] TRUE, FALSE
[13:33:39.339] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:39.340]  length: 1 (resolved future 1)
[13:33:39.368] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.368] - Validating connection of MultisessionFuture
[13:33:39.368] - received message: FutureResult
[13:33:39.368] - Received FutureResult
[13:33:39.368] - Erased future from FutureRegistry
[13:33:39.369] result() for ClusterFuture ...
[13:33:39.369] - result already collected: FutureResult
[13:33:39.369] result() for ClusterFuture ... done
[13:33:39.369] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.369] Future #2
[13:33:39.369] result() for ClusterFuture ...
[13:33:39.369] - result already collected: FutureResult
[13:33:39.369] result() for ClusterFuture ... done
[13:33:39.369] result() for ClusterFuture ...
[13:33:39.369] - result already collected: FutureResult
[13:33:39.369] result() for ClusterFuture ... done
[13:33:39.370] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:39.370] - nx: 2
[13:33:39.370] - relay: TRUE
[13:33:39.370] - stdout: TRUE
[13:33:39.370] - signal: TRUE
[13:33:39.370] - resignal: FALSE
[13:33:39.370] - force: TRUE
[13:33:39.370] - relayed: [n=2] TRUE, FALSE
[13:33:39.370] - queued futures: [n=2] TRUE, FALSE
[13:33:39.370]  - until=2
[13:33:39.370]  - relaying element #2
[13:33:39.371] result() for ClusterFuture ...
[13:33:39.371] - result already collected: FutureResult
[13:33:39.371] result() for ClusterFuture ... done
[13:33:39.371] result() for ClusterFuture ...
[13:33:39.371] - result already collected: FutureResult
[13:33:39.371] result() for ClusterFuture ... done
[13:33:39.371] result() for ClusterFuture ...
[13:33:39.371] - result already collected: FutureResult
[13:33:39.371] result() for ClusterFuture ... done
[13:33:39.371] result() for ClusterFuture ...
[13:33:39.371] - result already collected: FutureResult
[13:33:39.372] result() for ClusterFuture ... done
[13:33:39.372] - relayed: [n=2] TRUE, TRUE
[13:33:39.372] - queued futures: [n=2] TRUE, TRUE
[13:33:39.372] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:39.372]  length: 0 (resolved future 2)
[13:33:39.372] Relaying remaining futures
[13:33:39.372] signalConditionsASAP(NULL, pos=0) ...
[13:33:39.372] - nx: 2
[13:33:39.372] - relay: TRUE
[13:33:39.372] - stdout: TRUE
[13:33:39.372] - signal: TRUE
[13:33:39.372] - resignal: FALSE
[13:33:39.373] - force: TRUE
[13:33:39.373] - relayed: [n=2] TRUE, TRUE
[13:33:39.373] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:39.373] - relayed: [n=2] TRUE, TRUE
[13:33:39.373] - queued futures: [n=2] TRUE, TRUE
[13:33:39.373] signalConditionsASAP(NULL, pos=0) ... done
[13:33:39.373] resolve() on list ... DONE
[13:33:39.373] result() for ClusterFuture ...
[13:33:39.373] - result already collected: FutureResult
[13:33:39.373] result() for ClusterFuture ... done
[13:33:39.373] result() for ClusterFuture ...
[13:33:39.374] - result already collected: FutureResult
[13:33:39.374] result() for ClusterFuture ... done
[13:33:39.374] result() for ClusterFuture ...
[13:33:39.374] - result already collected: FutureResult
[13:33:39.374] result() for ClusterFuture ... done
[13:33:39.374] result() for ClusterFuture ...
[13:33:39.374] - result already collected: FutureResult
[13:33:39.374] result() for ClusterFuture ... done
[13:33:39.374]  - Number of value chunks collected: 2
[13:33:39.374] Resolving 2 futures (chunks) ... DONE
[13:33:39.374] Reducing values from 2 chunks ...
[13:33:39.375]  - Number of values collected after concatenation: 2
[13:33:39.375]  - Number of values expected: 2
[13:33:39.375] Reducing values from 2 chunks ... DONE
[13:33:39.375] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[13:33:39.375] getGlobalsAndPackagesXApply() ...
[13:33:39.375]  - future.globals: TRUE
[13:33:39.375] getGlobalsAndPackages() ...
[13:33:39.375] Searching for globals...
[13:33:39.377] - globals found: [1] ‘FUN’
[13:33:39.377] Searching for globals ... DONE
[13:33:39.377] Resolving globals: FALSE
[13:33:39.377] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:39.378] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:39.378] - globals: [1] ‘FUN’
[13:33:39.378] 
[13:33:39.378] getGlobalsAndPackages() ... DONE
[13:33:39.378]  - globals found/used: [n=1] ‘FUN’
[13:33:39.378]  - needed namespaces: [n=0] 
[13:33:39.378] Finding globals ... DONE
[13:33:39.378]  - use_args: TRUE
[13:33:39.378]  - Getting '...' globals ...
[13:33:39.379] resolve() on list ...
[13:33:39.379]  recursive: 0
[13:33:39.379]  length: 1
[13:33:39.379]  elements: ‘...’
[13:33:39.379]  length: 0 (resolved future 1)
[13:33:39.379] resolve() on list ... DONE
[13:33:39.379]    - '...' content: [n=0] 
[13:33:39.379] List of 1
[13:33:39.379]  $ ...: list()
[13:33:39.379]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.379]  - attr(*, "where")=List of 1
[13:33:39.379]   ..$ ...:<environment: 0x55b94b5ba520> 
[13:33:39.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.379]  - attr(*, "resolved")= logi TRUE
[13:33:39.379]  - attr(*, "total_size")= num NA
[13:33:39.382]  - Getting '...' globals ... DONE
[13:33:39.382] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:39.382] List of 2
[13:33:39.382]  $ ...future.FUN:function (x)  
[13:33:39.382]  $ ...          : list()
[13:33:39.382]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.382]  - attr(*, "where")=List of 2
[13:33:39.382]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:39.382]   ..$ ...          :<environment: 0x55b94b5ba520> 
[13:33:39.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.382]  - attr(*, "resolved")= logi FALSE
[13:33:39.382]  - attr(*, "total_size")= num 848
[13:33:39.385] Packages to be attached in all futures: [n=0] 
[13:33:39.385] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.388] future_lapply() ...
[13:33:39.392] Number of chunks: 2
[13:33:39.392] getGlobalsAndPackagesXApply() ...
[13:33:39.392]  - future.globals: <name-value list> with names ‘list()’
[13:33:39.392]  - use_args: TRUE
[13:33:39.392] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:39.393] List of 2
[13:33:39.393]  $ ...          : list()
[13:33:39.393]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.393]  $ ...future.FUN:function (x)  
[13:33:39.393]  - attr(*, "where")=List of 2
[13:33:39.393]   ..$ ...          :<environment: 0x55b94b5ba520> 
[13:33:39.393]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:39.393]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.393]  - attr(*, "resolved")= logi FALSE
[13:33:39.393]  - attr(*, "total_size")= num NA
[13:33:39.396] Packages to be attached in all futures: [n=0] 
[13:33:39.396] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.396] Number of futures (= number of chunks): 2
[13:33:39.396] Launching 2 futures (chunks) ...
[13:33:39.396] Chunk #1 of 2 ...
[13:33:39.397]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.397]  - seeds: <none>
[13:33:39.397]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.397] getGlobalsAndPackages() ...
[13:33:39.397] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.397] Resolving globals: FALSE
[13:33:39.397] Tweak future expression to call with '...' arguments ...
[13:33:39.397] {
[13:33:39.397]     do.call(function(...) {
[13:33:39.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.397]             on.exit(options(oopts), add = TRUE)
[13:33:39.397]         }
[13:33:39.397]         {
[13:33:39.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.397]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.397]             })
[13:33:39.397]         }
[13:33:39.397]     }, args = future.call.arguments)
[13:33:39.397] }
[13:33:39.398] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.398] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.398] 
[13:33:39.398] getGlobalsAndPackages() ... DONE
[13:33:39.398] run() for ‘Future’ ...
[13:33:39.399] - state: ‘created’
[13:33:39.399] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.412] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.412]   - Field: ‘node’
[13:33:39.413]   - Field: ‘label’
[13:33:39.413]   - Field: ‘local’
[13:33:39.413]   - Field: ‘owner’
[13:33:39.413]   - Field: ‘envir’
[13:33:39.413]   - Field: ‘workers’
[13:33:39.413]   - Field: ‘packages’
[13:33:39.413]   - Field: ‘gc’
[13:33:39.413]   - Field: ‘conditions’
[13:33:39.413]   - Field: ‘persistent’
[13:33:39.413]   - Field: ‘expr’
[13:33:39.413]   - Field: ‘uuid’
[13:33:39.414]   - Field: ‘seed’
[13:33:39.414]   - Field: ‘version’
[13:33:39.414]   - Field: ‘result’
[13:33:39.414]   - Field: ‘asynchronous’
[13:33:39.414]   - Field: ‘calls’
[13:33:39.414]   - Field: ‘globals’
[13:33:39.414]   - Field: ‘stdout’
[13:33:39.414]   - Field: ‘earlySignal’
[13:33:39.414]   - Field: ‘lazy’
[13:33:39.414]   - Field: ‘state’
[13:33:39.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.415] - Launch lazy future ...
[13:33:39.415] Packages needed by the future expression (n = 0): <none>
[13:33:39.415] Packages needed by future strategies (n = 0): <none>
[13:33:39.415] {
[13:33:39.415]     {
[13:33:39.415]         {
[13:33:39.415]             ...future.startTime <- base::Sys.time()
[13:33:39.415]             {
[13:33:39.415]                 {
[13:33:39.415]                   {
[13:33:39.415]                     {
[13:33:39.415]                       base::local({
[13:33:39.415]                         has_future <- base::requireNamespace("future", 
[13:33:39.415]                           quietly = TRUE)
[13:33:39.415]                         if (has_future) {
[13:33:39.415]                           ns <- base::getNamespace("future")
[13:33:39.415]                           version <- ns[[".package"]][["version"]]
[13:33:39.415]                           if (is.null(version)) 
[13:33:39.415]                             version <- utils::packageVersion("future")
[13:33:39.415]                         }
[13:33:39.415]                         else {
[13:33:39.415]                           version <- NULL
[13:33:39.415]                         }
[13:33:39.415]                         if (!has_future || version < "1.8.0") {
[13:33:39.415]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.415]                             "", base::R.version$version.string), 
[13:33:39.415]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.415]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.415]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.415]                               "release", "version")], collapse = " "), 
[13:33:39.415]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.415]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.415]                             info)
[13:33:39.415]                           info <- base::paste(info, collapse = "; ")
[13:33:39.415]                           if (!has_future) {
[13:33:39.415]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.415]                               info)
[13:33:39.415]                           }
[13:33:39.415]                           else {
[13:33:39.415]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.415]                               info, version)
[13:33:39.415]                           }
[13:33:39.415]                           base::stop(msg)
[13:33:39.415]                         }
[13:33:39.415]                       })
[13:33:39.415]                     }
[13:33:39.415]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.415]                     base::options(mc.cores = 1L)
[13:33:39.415]                   }
[13:33:39.415]                   ...future.strategy.old <- future::plan("list")
[13:33:39.415]                   options(future.plan = NULL)
[13:33:39.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.415]                 }
[13:33:39.415]                 ...future.workdir <- getwd()
[13:33:39.415]             }
[13:33:39.415]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.415]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.415]         }
[13:33:39.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.415]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.415]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.415]             base::names(...future.oldOptions))
[13:33:39.415]     }
[13:33:39.415]     if (FALSE) {
[13:33:39.415]     }
[13:33:39.415]     else {
[13:33:39.415]         if (TRUE) {
[13:33:39.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.415]                 open = "w")
[13:33:39.415]         }
[13:33:39.415]         else {
[13:33:39.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.415]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.415]         }
[13:33:39.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.415]             base::sink(type = "output", split = FALSE)
[13:33:39.415]             base::close(...future.stdout)
[13:33:39.415]         }, add = TRUE)
[13:33:39.415]     }
[13:33:39.415]     ...future.frame <- base::sys.nframe()
[13:33:39.415]     ...future.conditions <- base::list()
[13:33:39.415]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.415]     if (FALSE) {
[13:33:39.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.415]     }
[13:33:39.415]     ...future.result <- base::tryCatch({
[13:33:39.415]         base::withCallingHandlers({
[13:33:39.415]             ...future.value <- base::withVisible(base::local({
[13:33:39.415]                 ...future.makeSendCondition <- base::local({
[13:33:39.415]                   sendCondition <- NULL
[13:33:39.415]                   function(frame = 1L) {
[13:33:39.415]                     if (is.function(sendCondition)) 
[13:33:39.415]                       return(sendCondition)
[13:33:39.415]                     ns <- getNamespace("parallel")
[13:33:39.415]                     if (exists("sendData", mode = "function", 
[13:33:39.415]                       envir = ns)) {
[13:33:39.415]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.415]                         envir = ns)
[13:33:39.415]                       envir <- sys.frame(frame)
[13:33:39.415]                       master <- NULL
[13:33:39.415]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.415]                         !identical(envir, emptyenv())) {
[13:33:39.415]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.415]                           inherits = FALSE)) {
[13:33:39.415]                           master <- get("master", mode = "list", 
[13:33:39.415]                             envir = envir, inherits = FALSE)
[13:33:39.415]                           if (inherits(master, c("SOCKnode", 
[13:33:39.415]                             "SOCK0node"))) {
[13:33:39.415]                             sendCondition <<- function(cond) {
[13:33:39.415]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.415]                                 success = TRUE)
[13:33:39.415]                               parallel_sendData(master, data)
[13:33:39.415]                             }
[13:33:39.415]                             return(sendCondition)
[13:33:39.415]                           }
[13:33:39.415]                         }
[13:33:39.415]                         frame <- frame + 1L
[13:33:39.415]                         envir <- sys.frame(frame)
[13:33:39.415]                       }
[13:33:39.415]                     }
[13:33:39.415]                     sendCondition <<- function(cond) NULL
[13:33:39.415]                   }
[13:33:39.415]                 })
[13:33:39.415]                 withCallingHandlers({
[13:33:39.415]                   {
[13:33:39.415]                     do.call(function(...) {
[13:33:39.415]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.415]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.415]                         ...future.globals.maxSize)) {
[13:33:39.415]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.415]                         on.exit(options(oopts), add = TRUE)
[13:33:39.415]                       }
[13:33:39.415]                       {
[13:33:39.415]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.415]                           FUN = function(jj) {
[13:33:39.415]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.415]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.415]                           })
[13:33:39.415]                       }
[13:33:39.415]                     }, args = future.call.arguments)
[13:33:39.415]                   }
[13:33:39.415]                 }, immediateCondition = function(cond) {
[13:33:39.415]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.415]                   sendCondition(cond)
[13:33:39.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.415]                   {
[13:33:39.415]                     inherits <- base::inherits
[13:33:39.415]                     invokeRestart <- base::invokeRestart
[13:33:39.415]                     is.null <- base::is.null
[13:33:39.415]                     muffled <- FALSE
[13:33:39.415]                     if (inherits(cond, "message")) {
[13:33:39.415]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.415]                       if (muffled) 
[13:33:39.415]                         invokeRestart("muffleMessage")
[13:33:39.415]                     }
[13:33:39.415]                     else if (inherits(cond, "warning")) {
[13:33:39.415]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.415]                       if (muffled) 
[13:33:39.415]                         invokeRestart("muffleWarning")
[13:33:39.415]                     }
[13:33:39.415]                     else if (inherits(cond, "condition")) {
[13:33:39.415]                       if (!is.null(pattern)) {
[13:33:39.415]                         computeRestarts <- base::computeRestarts
[13:33:39.415]                         grepl <- base::grepl
[13:33:39.415]                         restarts <- computeRestarts(cond)
[13:33:39.415]                         for (restart in restarts) {
[13:33:39.415]                           name <- restart$name
[13:33:39.415]                           if (is.null(name)) 
[13:33:39.415]                             next
[13:33:39.415]                           if (!grepl(pattern, name)) 
[13:33:39.415]                             next
[13:33:39.415]                           invokeRestart(restart)
[13:33:39.415]                           muffled <- TRUE
[13:33:39.415]                           break
[13:33:39.415]                         }
[13:33:39.415]                       }
[13:33:39.415]                     }
[13:33:39.415]                     invisible(muffled)
[13:33:39.415]                   }
[13:33:39.415]                   muffleCondition(cond)
[13:33:39.415]                 })
[13:33:39.415]             }))
[13:33:39.415]             future::FutureResult(value = ...future.value$value, 
[13:33:39.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.415]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.415]                     ...future.globalenv.names))
[13:33:39.415]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.415]         }, condition = base::local({
[13:33:39.415]             c <- base::c
[13:33:39.415]             inherits <- base::inherits
[13:33:39.415]             invokeRestart <- base::invokeRestart
[13:33:39.415]             length <- base::length
[13:33:39.415]             list <- base::list
[13:33:39.415]             seq.int <- base::seq.int
[13:33:39.415]             signalCondition <- base::signalCondition
[13:33:39.415]             sys.calls <- base::sys.calls
[13:33:39.415]             `[[` <- base::`[[`
[13:33:39.415]             `+` <- base::`+`
[13:33:39.415]             `<<-` <- base::`<<-`
[13:33:39.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.415]                   3L)]
[13:33:39.415]             }
[13:33:39.415]             function(cond) {
[13:33:39.415]                 is_error <- inherits(cond, "error")
[13:33:39.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.415]                   NULL)
[13:33:39.415]                 if (is_error) {
[13:33:39.415]                   sessionInformation <- function() {
[13:33:39.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.415]                       search = base::search(), system = base::Sys.info())
[13:33:39.415]                   }
[13:33:39.415]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.415]                     cond$call), session = sessionInformation(), 
[13:33:39.415]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.415]                   signalCondition(cond)
[13:33:39.415]                 }
[13:33:39.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.415]                 "immediateCondition"))) {
[13:33:39.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.415]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.415]                   if (TRUE && !signal) {
[13:33:39.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.415]                     {
[13:33:39.415]                       inherits <- base::inherits
[13:33:39.415]                       invokeRestart <- base::invokeRestart
[13:33:39.415]                       is.null <- base::is.null
[13:33:39.415]                       muffled <- FALSE
[13:33:39.415]                       if (inherits(cond, "message")) {
[13:33:39.415]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.415]                         if (muffled) 
[13:33:39.415]                           invokeRestart("muffleMessage")
[13:33:39.415]                       }
[13:33:39.415]                       else if (inherits(cond, "warning")) {
[13:33:39.415]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.415]                         if (muffled) 
[13:33:39.415]                           invokeRestart("muffleWarning")
[13:33:39.415]                       }
[13:33:39.415]                       else if (inherits(cond, "condition")) {
[13:33:39.415]                         if (!is.null(pattern)) {
[13:33:39.415]                           computeRestarts <- base::computeRestarts
[13:33:39.415]                           grepl <- base::grepl
[13:33:39.415]                           restarts <- computeRestarts(cond)
[13:33:39.415]                           for (restart in restarts) {
[13:33:39.415]                             name <- restart$name
[13:33:39.415]                             if (is.null(name)) 
[13:33:39.415]                               next
[13:33:39.415]                             if (!grepl(pattern, name)) 
[13:33:39.415]                               next
[13:33:39.415]                             invokeRestart(restart)
[13:33:39.415]                             muffled <- TRUE
[13:33:39.415]                             break
[13:33:39.415]                           }
[13:33:39.415]                         }
[13:33:39.415]                       }
[13:33:39.415]                       invisible(muffled)
[13:33:39.415]                     }
[13:33:39.415]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.415]                   }
[13:33:39.415]                 }
[13:33:39.415]                 else {
[13:33:39.415]                   if (TRUE) {
[13:33:39.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.415]                     {
[13:33:39.415]                       inherits <- base::inherits
[13:33:39.415]                       invokeRestart <- base::invokeRestart
[13:33:39.415]                       is.null <- base::is.null
[13:33:39.415]                       muffled <- FALSE
[13:33:39.415]                       if (inherits(cond, "message")) {
[13:33:39.415]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.415]                         if (muffled) 
[13:33:39.415]                           invokeRestart("muffleMessage")
[13:33:39.415]                       }
[13:33:39.415]                       else if (inherits(cond, "warning")) {
[13:33:39.415]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.415]                         if (muffled) 
[13:33:39.415]                           invokeRestart("muffleWarning")
[13:33:39.415]                       }
[13:33:39.415]                       else if (inherits(cond, "condition")) {
[13:33:39.415]                         if (!is.null(pattern)) {
[13:33:39.415]                           computeRestarts <- base::computeRestarts
[13:33:39.415]                           grepl <- base::grepl
[13:33:39.415]                           restarts <- computeRestarts(cond)
[13:33:39.415]                           for (restart in restarts) {
[13:33:39.415]                             name <- restart$name
[13:33:39.415]                             if (is.null(name)) 
[13:33:39.415]                               next
[13:33:39.415]                             if (!grepl(pattern, name)) 
[13:33:39.415]                               next
[13:33:39.415]                             invokeRestart(restart)
[13:33:39.415]                             muffled <- TRUE
[13:33:39.415]                             break
[13:33:39.415]                           }
[13:33:39.415]                         }
[13:33:39.415]                       }
[13:33:39.415]                       invisible(muffled)
[13:33:39.415]                     }
[13:33:39.415]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.415]                   }
[13:33:39.415]                 }
[13:33:39.415]             }
[13:33:39.415]         }))
[13:33:39.415]     }, error = function(ex) {
[13:33:39.415]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.415]                 ...future.rng), started = ...future.startTime, 
[13:33:39.415]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.415]             version = "1.8"), class = "FutureResult")
[13:33:39.415]     }, finally = {
[13:33:39.415]         if (!identical(...future.workdir, getwd())) 
[13:33:39.415]             setwd(...future.workdir)
[13:33:39.415]         {
[13:33:39.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.415]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.415]             }
[13:33:39.415]             base::options(...future.oldOptions)
[13:33:39.415]             if (.Platform$OS.type == "windows") {
[13:33:39.415]                 old_names <- names(...future.oldEnvVars)
[13:33:39.415]                 envs <- base::Sys.getenv()
[13:33:39.415]                 names <- names(envs)
[13:33:39.415]                 common <- intersect(names, old_names)
[13:33:39.415]                 added <- setdiff(names, old_names)
[13:33:39.415]                 removed <- setdiff(old_names, names)
[13:33:39.415]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.415]                   envs[common]]
[13:33:39.415]                 NAMES <- toupper(changed)
[13:33:39.415]                 args <- list()
[13:33:39.415]                 for (kk in seq_along(NAMES)) {
[13:33:39.415]                   name <- changed[[kk]]
[13:33:39.415]                   NAME <- NAMES[[kk]]
[13:33:39.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.415]                     next
[13:33:39.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.415]                 }
[13:33:39.415]                 NAMES <- toupper(added)
[13:33:39.415]                 for (kk in seq_along(NAMES)) {
[13:33:39.415]                   name <- added[[kk]]
[13:33:39.415]                   NAME <- NAMES[[kk]]
[13:33:39.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.415]                     next
[13:33:39.415]                   args[[name]] <- ""
[13:33:39.415]                 }
[13:33:39.415]                 NAMES <- toupper(removed)
[13:33:39.415]                 for (kk in seq_along(NAMES)) {
[13:33:39.415]                   name <- removed[[kk]]
[13:33:39.415]                   NAME <- NAMES[[kk]]
[13:33:39.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.415]                     next
[13:33:39.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.415]                 }
[13:33:39.415]                 if (length(args) > 0) 
[13:33:39.415]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.415]             }
[13:33:39.415]             else {
[13:33:39.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.415]             }
[13:33:39.415]             {
[13:33:39.415]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.415]                   0L) {
[13:33:39.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.415]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.415]                   base::options(opts)
[13:33:39.415]                 }
[13:33:39.415]                 {
[13:33:39.415]                   {
[13:33:39.415]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.415]                     NULL
[13:33:39.415]                   }
[13:33:39.415]                   options(future.plan = NULL)
[13:33:39.415]                   if (is.na(NA_character_)) 
[13:33:39.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.415]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.415]                     .init = FALSE)
[13:33:39.415]                 }
[13:33:39.415]             }
[13:33:39.415]         }
[13:33:39.415]     })
[13:33:39.415]     if (TRUE) {
[13:33:39.415]         base::sink(type = "output", split = FALSE)
[13:33:39.415]         if (TRUE) {
[13:33:39.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.415]         }
[13:33:39.415]         else {
[13:33:39.415]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.415]         }
[13:33:39.415]         base::close(...future.stdout)
[13:33:39.415]         ...future.stdout <- NULL
[13:33:39.415]     }
[13:33:39.415]     ...future.result$conditions <- ...future.conditions
[13:33:39.415]     ...future.result$finished <- base::Sys.time()
[13:33:39.415]     ...future.result
[13:33:39.415] }
[13:33:39.418] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:33:39.419] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:39.419] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.419] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:33:39.420] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:33:39.420] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[13:33:39.420] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[13:33:39.420] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:39.421] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.421] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:39.421] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:39.421] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:33:39.422] MultisessionFuture started
[13:33:39.422] - Launch lazy future ... done
[13:33:39.422] run() for ‘MultisessionFuture’ ... done
[13:33:39.422] Created future:
[13:33:39.422] MultisessionFuture:
[13:33:39.422] Label: ‘future_apply-1’
[13:33:39.422] Expression:
[13:33:39.422] {
[13:33:39.422]     do.call(function(...) {
[13:33:39.422]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.422]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.422]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.422]             on.exit(options(oopts), add = TRUE)
[13:33:39.422]         }
[13:33:39.422]         {
[13:33:39.422]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.422]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.422]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.422]             })
[13:33:39.422]         }
[13:33:39.422]     }, args = future.call.arguments)
[13:33:39.422] }
[13:33:39.422] Lazy evaluation: FALSE
[13:33:39.422] Asynchronous evaluation: TRUE
[13:33:39.422] Local evaluation: TRUE
[13:33:39.422] Environment: R_GlobalEnv
[13:33:39.422] Capture standard output: TRUE
[13:33:39.422] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.422] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.422] Packages: <none>
[13:33:39.422] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.422] Resolved: FALSE
[13:33:39.422] Value: <not collected>
[13:33:39.422] Conditions captured: <none>
[13:33:39.422] Early signaling: FALSE
[13:33:39.422] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.422] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.434] Chunk #1 of 2 ... DONE
[13:33:39.434] Chunk #2 of 2 ...
[13:33:39.434]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.434]  - seeds: <none>
[13:33:39.434]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.435] getGlobalsAndPackages() ...
[13:33:39.435] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.435] Resolving globals: FALSE
[13:33:39.435] Tweak future expression to call with '...' arguments ...
[13:33:39.435] {
[13:33:39.435]     do.call(function(...) {
[13:33:39.435]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.435]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.435]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.435]             on.exit(options(oopts), add = TRUE)
[13:33:39.435]         }
[13:33:39.435]         {
[13:33:39.435]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.435]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.435]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.435]             })
[13:33:39.435]         }
[13:33:39.435]     }, args = future.call.arguments)
[13:33:39.435] }
[13:33:39.435] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.437] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.438] 
[13:33:39.438] getGlobalsAndPackages() ... DONE
[13:33:39.438] run() for ‘Future’ ...
[13:33:39.438] - state: ‘created’
[13:33:39.438] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.452]   - Field: ‘node’
[13:33:39.452]   - Field: ‘label’
[13:33:39.452]   - Field: ‘local’
[13:33:39.452]   - Field: ‘owner’
[13:33:39.452]   - Field: ‘envir’
[13:33:39.452]   - Field: ‘workers’
[13:33:39.452]   - Field: ‘packages’
[13:33:39.452]   - Field: ‘gc’
[13:33:39.453]   - Field: ‘conditions’
[13:33:39.453]   - Field: ‘persistent’
[13:33:39.453]   - Field: ‘expr’
[13:33:39.453]   - Field: ‘uuid’
[13:33:39.453]   - Field: ‘seed’
[13:33:39.453]   - Field: ‘version’
[13:33:39.453]   - Field: ‘result’
[13:33:39.453]   - Field: ‘asynchronous’
[13:33:39.453]   - Field: ‘calls’
[13:33:39.453]   - Field: ‘globals’
[13:33:39.453]   - Field: ‘stdout’
[13:33:39.454]   - Field: ‘earlySignal’
[13:33:39.454]   - Field: ‘lazy’
[13:33:39.454]   - Field: ‘state’
[13:33:39.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.454] - Launch lazy future ...
[13:33:39.454] Packages needed by the future expression (n = 0): <none>
[13:33:39.454] Packages needed by future strategies (n = 0): <none>
[13:33:39.455] {
[13:33:39.455]     {
[13:33:39.455]         {
[13:33:39.455]             ...future.startTime <- base::Sys.time()
[13:33:39.455]             {
[13:33:39.455]                 {
[13:33:39.455]                   {
[13:33:39.455]                     {
[13:33:39.455]                       base::local({
[13:33:39.455]                         has_future <- base::requireNamespace("future", 
[13:33:39.455]                           quietly = TRUE)
[13:33:39.455]                         if (has_future) {
[13:33:39.455]                           ns <- base::getNamespace("future")
[13:33:39.455]                           version <- ns[[".package"]][["version"]]
[13:33:39.455]                           if (is.null(version)) 
[13:33:39.455]                             version <- utils::packageVersion("future")
[13:33:39.455]                         }
[13:33:39.455]                         else {
[13:33:39.455]                           version <- NULL
[13:33:39.455]                         }
[13:33:39.455]                         if (!has_future || version < "1.8.0") {
[13:33:39.455]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.455]                             "", base::R.version$version.string), 
[13:33:39.455]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.455]                               "release", "version")], collapse = " "), 
[13:33:39.455]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.455]                             info)
[13:33:39.455]                           info <- base::paste(info, collapse = "; ")
[13:33:39.455]                           if (!has_future) {
[13:33:39.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.455]                               info)
[13:33:39.455]                           }
[13:33:39.455]                           else {
[13:33:39.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.455]                               info, version)
[13:33:39.455]                           }
[13:33:39.455]                           base::stop(msg)
[13:33:39.455]                         }
[13:33:39.455]                       })
[13:33:39.455]                     }
[13:33:39.455]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.455]                     base::options(mc.cores = 1L)
[13:33:39.455]                   }
[13:33:39.455]                   ...future.strategy.old <- future::plan("list")
[13:33:39.455]                   options(future.plan = NULL)
[13:33:39.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.455]                 }
[13:33:39.455]                 ...future.workdir <- getwd()
[13:33:39.455]             }
[13:33:39.455]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.455]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.455]         }
[13:33:39.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.455]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.455]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.455]             base::names(...future.oldOptions))
[13:33:39.455]     }
[13:33:39.455]     if (FALSE) {
[13:33:39.455]     }
[13:33:39.455]     else {
[13:33:39.455]         if (TRUE) {
[13:33:39.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.455]                 open = "w")
[13:33:39.455]         }
[13:33:39.455]         else {
[13:33:39.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.455]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.455]         }
[13:33:39.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.455]             base::sink(type = "output", split = FALSE)
[13:33:39.455]             base::close(...future.stdout)
[13:33:39.455]         }, add = TRUE)
[13:33:39.455]     }
[13:33:39.455]     ...future.frame <- base::sys.nframe()
[13:33:39.455]     ...future.conditions <- base::list()
[13:33:39.455]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.455]     if (FALSE) {
[13:33:39.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.455]     }
[13:33:39.455]     ...future.result <- base::tryCatch({
[13:33:39.455]         base::withCallingHandlers({
[13:33:39.455]             ...future.value <- base::withVisible(base::local({
[13:33:39.455]                 ...future.makeSendCondition <- base::local({
[13:33:39.455]                   sendCondition <- NULL
[13:33:39.455]                   function(frame = 1L) {
[13:33:39.455]                     if (is.function(sendCondition)) 
[13:33:39.455]                       return(sendCondition)
[13:33:39.455]                     ns <- getNamespace("parallel")
[13:33:39.455]                     if (exists("sendData", mode = "function", 
[13:33:39.455]                       envir = ns)) {
[13:33:39.455]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.455]                         envir = ns)
[13:33:39.455]                       envir <- sys.frame(frame)
[13:33:39.455]                       master <- NULL
[13:33:39.455]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.455]                         !identical(envir, emptyenv())) {
[13:33:39.455]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.455]                           inherits = FALSE)) {
[13:33:39.455]                           master <- get("master", mode = "list", 
[13:33:39.455]                             envir = envir, inherits = FALSE)
[13:33:39.455]                           if (inherits(master, c("SOCKnode", 
[13:33:39.455]                             "SOCK0node"))) {
[13:33:39.455]                             sendCondition <<- function(cond) {
[13:33:39.455]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.455]                                 success = TRUE)
[13:33:39.455]                               parallel_sendData(master, data)
[13:33:39.455]                             }
[13:33:39.455]                             return(sendCondition)
[13:33:39.455]                           }
[13:33:39.455]                         }
[13:33:39.455]                         frame <- frame + 1L
[13:33:39.455]                         envir <- sys.frame(frame)
[13:33:39.455]                       }
[13:33:39.455]                     }
[13:33:39.455]                     sendCondition <<- function(cond) NULL
[13:33:39.455]                   }
[13:33:39.455]                 })
[13:33:39.455]                 withCallingHandlers({
[13:33:39.455]                   {
[13:33:39.455]                     do.call(function(...) {
[13:33:39.455]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.455]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.455]                         ...future.globals.maxSize)) {
[13:33:39.455]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.455]                         on.exit(options(oopts), add = TRUE)
[13:33:39.455]                       }
[13:33:39.455]                       {
[13:33:39.455]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.455]                           FUN = function(jj) {
[13:33:39.455]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.455]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.455]                           })
[13:33:39.455]                       }
[13:33:39.455]                     }, args = future.call.arguments)
[13:33:39.455]                   }
[13:33:39.455]                 }, immediateCondition = function(cond) {
[13:33:39.455]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.455]                   sendCondition(cond)
[13:33:39.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.455]                   {
[13:33:39.455]                     inherits <- base::inherits
[13:33:39.455]                     invokeRestart <- base::invokeRestart
[13:33:39.455]                     is.null <- base::is.null
[13:33:39.455]                     muffled <- FALSE
[13:33:39.455]                     if (inherits(cond, "message")) {
[13:33:39.455]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.455]                       if (muffled) 
[13:33:39.455]                         invokeRestart("muffleMessage")
[13:33:39.455]                     }
[13:33:39.455]                     else if (inherits(cond, "warning")) {
[13:33:39.455]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.455]                       if (muffled) 
[13:33:39.455]                         invokeRestart("muffleWarning")
[13:33:39.455]                     }
[13:33:39.455]                     else if (inherits(cond, "condition")) {
[13:33:39.455]                       if (!is.null(pattern)) {
[13:33:39.455]                         computeRestarts <- base::computeRestarts
[13:33:39.455]                         grepl <- base::grepl
[13:33:39.455]                         restarts <- computeRestarts(cond)
[13:33:39.455]                         for (restart in restarts) {
[13:33:39.455]                           name <- restart$name
[13:33:39.455]                           if (is.null(name)) 
[13:33:39.455]                             next
[13:33:39.455]                           if (!grepl(pattern, name)) 
[13:33:39.455]                             next
[13:33:39.455]                           invokeRestart(restart)
[13:33:39.455]                           muffled <- TRUE
[13:33:39.455]                           break
[13:33:39.455]                         }
[13:33:39.455]                       }
[13:33:39.455]                     }
[13:33:39.455]                     invisible(muffled)
[13:33:39.455]                   }
[13:33:39.455]                   muffleCondition(cond)
[13:33:39.455]                 })
[13:33:39.455]             }))
[13:33:39.455]             future::FutureResult(value = ...future.value$value, 
[13:33:39.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.455]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.455]                     ...future.globalenv.names))
[13:33:39.455]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.455]         }, condition = base::local({
[13:33:39.455]             c <- base::c
[13:33:39.455]             inherits <- base::inherits
[13:33:39.455]             invokeRestart <- base::invokeRestart
[13:33:39.455]             length <- base::length
[13:33:39.455]             list <- base::list
[13:33:39.455]             seq.int <- base::seq.int
[13:33:39.455]             signalCondition <- base::signalCondition
[13:33:39.455]             sys.calls <- base::sys.calls
[13:33:39.455]             `[[` <- base::`[[`
[13:33:39.455]             `+` <- base::`+`
[13:33:39.455]             `<<-` <- base::`<<-`
[13:33:39.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.455]                   3L)]
[13:33:39.455]             }
[13:33:39.455]             function(cond) {
[13:33:39.455]                 is_error <- inherits(cond, "error")
[13:33:39.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.455]                   NULL)
[13:33:39.455]                 if (is_error) {
[13:33:39.455]                   sessionInformation <- function() {
[13:33:39.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.455]                       search = base::search(), system = base::Sys.info())
[13:33:39.455]                   }
[13:33:39.455]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.455]                     cond$call), session = sessionInformation(), 
[13:33:39.455]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.455]                   signalCondition(cond)
[13:33:39.455]                 }
[13:33:39.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.455]                 "immediateCondition"))) {
[13:33:39.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.455]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.455]                   if (TRUE && !signal) {
[13:33:39.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.455]                     {
[13:33:39.455]                       inherits <- base::inherits
[13:33:39.455]                       invokeRestart <- base::invokeRestart
[13:33:39.455]                       is.null <- base::is.null
[13:33:39.455]                       muffled <- FALSE
[13:33:39.455]                       if (inherits(cond, "message")) {
[13:33:39.455]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.455]                         if (muffled) 
[13:33:39.455]                           invokeRestart("muffleMessage")
[13:33:39.455]                       }
[13:33:39.455]                       else if (inherits(cond, "warning")) {
[13:33:39.455]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.455]                         if (muffled) 
[13:33:39.455]                           invokeRestart("muffleWarning")
[13:33:39.455]                       }
[13:33:39.455]                       else if (inherits(cond, "condition")) {
[13:33:39.455]                         if (!is.null(pattern)) {
[13:33:39.455]                           computeRestarts <- base::computeRestarts
[13:33:39.455]                           grepl <- base::grepl
[13:33:39.455]                           restarts <- computeRestarts(cond)
[13:33:39.455]                           for (restart in restarts) {
[13:33:39.455]                             name <- restart$name
[13:33:39.455]                             if (is.null(name)) 
[13:33:39.455]                               next
[13:33:39.455]                             if (!grepl(pattern, name)) 
[13:33:39.455]                               next
[13:33:39.455]                             invokeRestart(restart)
[13:33:39.455]                             muffled <- TRUE
[13:33:39.455]                             break
[13:33:39.455]                           }
[13:33:39.455]                         }
[13:33:39.455]                       }
[13:33:39.455]                       invisible(muffled)
[13:33:39.455]                     }
[13:33:39.455]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.455]                   }
[13:33:39.455]                 }
[13:33:39.455]                 else {
[13:33:39.455]                   if (TRUE) {
[13:33:39.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.455]                     {
[13:33:39.455]                       inherits <- base::inherits
[13:33:39.455]                       invokeRestart <- base::invokeRestart
[13:33:39.455]                       is.null <- base::is.null
[13:33:39.455]                       muffled <- FALSE
[13:33:39.455]                       if (inherits(cond, "message")) {
[13:33:39.455]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.455]                         if (muffled) 
[13:33:39.455]                           invokeRestart("muffleMessage")
[13:33:39.455]                       }
[13:33:39.455]                       else if (inherits(cond, "warning")) {
[13:33:39.455]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.455]                         if (muffled) 
[13:33:39.455]                           invokeRestart("muffleWarning")
[13:33:39.455]                       }
[13:33:39.455]                       else if (inherits(cond, "condition")) {
[13:33:39.455]                         if (!is.null(pattern)) {
[13:33:39.455]                           computeRestarts <- base::computeRestarts
[13:33:39.455]                           grepl <- base::grepl
[13:33:39.455]                           restarts <- computeRestarts(cond)
[13:33:39.455]                           for (restart in restarts) {
[13:33:39.455]                             name <- restart$name
[13:33:39.455]                             if (is.null(name)) 
[13:33:39.455]                               next
[13:33:39.455]                             if (!grepl(pattern, name)) 
[13:33:39.455]                               next
[13:33:39.455]                             invokeRestart(restart)
[13:33:39.455]                             muffled <- TRUE
[13:33:39.455]                             break
[13:33:39.455]                           }
[13:33:39.455]                         }
[13:33:39.455]                       }
[13:33:39.455]                       invisible(muffled)
[13:33:39.455]                     }
[13:33:39.455]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.455]                   }
[13:33:39.455]                 }
[13:33:39.455]             }
[13:33:39.455]         }))
[13:33:39.455]     }, error = function(ex) {
[13:33:39.455]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.455]                 ...future.rng), started = ...future.startTime, 
[13:33:39.455]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.455]             version = "1.8"), class = "FutureResult")
[13:33:39.455]     }, finally = {
[13:33:39.455]         if (!identical(...future.workdir, getwd())) 
[13:33:39.455]             setwd(...future.workdir)
[13:33:39.455]         {
[13:33:39.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.455]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.455]             }
[13:33:39.455]             base::options(...future.oldOptions)
[13:33:39.455]             if (.Platform$OS.type == "windows") {
[13:33:39.455]                 old_names <- names(...future.oldEnvVars)
[13:33:39.455]                 envs <- base::Sys.getenv()
[13:33:39.455]                 names <- names(envs)
[13:33:39.455]                 common <- intersect(names, old_names)
[13:33:39.455]                 added <- setdiff(names, old_names)
[13:33:39.455]                 removed <- setdiff(old_names, names)
[13:33:39.455]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.455]                   envs[common]]
[13:33:39.455]                 NAMES <- toupper(changed)
[13:33:39.455]                 args <- list()
[13:33:39.455]                 for (kk in seq_along(NAMES)) {
[13:33:39.455]                   name <- changed[[kk]]
[13:33:39.455]                   NAME <- NAMES[[kk]]
[13:33:39.455]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.455]                     next
[13:33:39.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.455]                 }
[13:33:39.455]                 NAMES <- toupper(added)
[13:33:39.455]                 for (kk in seq_along(NAMES)) {
[13:33:39.455]                   name <- added[[kk]]
[13:33:39.455]                   NAME <- NAMES[[kk]]
[13:33:39.455]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.455]                     next
[13:33:39.455]                   args[[name]] <- ""
[13:33:39.455]                 }
[13:33:39.455]                 NAMES <- toupper(removed)
[13:33:39.455]                 for (kk in seq_along(NAMES)) {
[13:33:39.455]                   name <- removed[[kk]]
[13:33:39.455]                   NAME <- NAMES[[kk]]
[13:33:39.455]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.455]                     next
[13:33:39.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.455]                 }
[13:33:39.455]                 if (length(args) > 0) 
[13:33:39.455]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.455]             }
[13:33:39.455]             else {
[13:33:39.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.455]             }
[13:33:39.455]             {
[13:33:39.455]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.455]                   0L) {
[13:33:39.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.455]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.455]                   base::options(opts)
[13:33:39.455]                 }
[13:33:39.455]                 {
[13:33:39.455]                   {
[13:33:39.455]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.455]                     NULL
[13:33:39.455]                   }
[13:33:39.455]                   options(future.plan = NULL)
[13:33:39.455]                   if (is.na(NA_character_)) 
[13:33:39.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.455]                     .init = FALSE)
[13:33:39.455]                 }
[13:33:39.455]             }
[13:33:39.455]         }
[13:33:39.455]     })
[13:33:39.455]     if (TRUE) {
[13:33:39.455]         base::sink(type = "output", split = FALSE)
[13:33:39.455]         if (TRUE) {
[13:33:39.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.455]         }
[13:33:39.455]         else {
[13:33:39.455]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.455]         }
[13:33:39.455]         base::close(...future.stdout)
[13:33:39.455]         ...future.stdout <- NULL
[13:33:39.455]     }
[13:33:39.455]     ...future.result$conditions <- ...future.conditions
[13:33:39.455]     ...future.result$finished <- base::Sys.time()
[13:33:39.455]     ...future.result
[13:33:39.455] }
[13:33:39.457] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:33:39.458] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:39.458] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.458] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:33:39.458] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:33:39.459] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[13:33:39.459] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[13:33:39.459] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:39.459] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.459] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:33:39.460] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:33:39.460] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:33:39.460] MultisessionFuture started
[13:33:39.460] - Launch lazy future ... done
[13:33:39.460] run() for ‘MultisessionFuture’ ... done
[13:33:39.461] Created future:
[13:33:39.461] MultisessionFuture:
[13:33:39.461] Label: ‘future_apply-2’
[13:33:39.461] Expression:
[13:33:39.461] {
[13:33:39.461]     do.call(function(...) {
[13:33:39.461]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.461]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.461]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.461]             on.exit(options(oopts), add = TRUE)
[13:33:39.461]         }
[13:33:39.461]         {
[13:33:39.461]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.461]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.461]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.461]             })
[13:33:39.461]         }
[13:33:39.461]     }, args = future.call.arguments)
[13:33:39.461] }
[13:33:39.461] Lazy evaluation: FALSE
[13:33:39.461] Asynchronous evaluation: TRUE
[13:33:39.461] Local evaluation: TRUE
[13:33:39.461] Environment: R_GlobalEnv
[13:33:39.461] Capture standard output: TRUE
[13:33:39.461] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.461] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.461] Packages: <none>
[13:33:39.461] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.461] Resolved: FALSE
[13:33:39.461] Value: <not collected>
[13:33:39.461] Conditions captured: <none>
[13:33:39.461] Early signaling: FALSE
[13:33:39.461] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.461] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.472] Chunk #2 of 2 ... DONE
[13:33:39.472] Launching 2 futures (chunks) ... DONE
[13:33:39.472] Resolving 2 futures (chunks) ...
[13:33:39.472] resolve() on list ...
[13:33:39.472]  recursive: 0
[13:33:39.473]  length: 2
[13:33:39.473] 
[13:33:39.473] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.473] - Validating connection of MultisessionFuture
[13:33:39.473] - received message: FutureResult
[13:33:39.473] - Received FutureResult
[13:33:39.474] - Erased future from FutureRegistry
[13:33:39.474] result() for ClusterFuture ...
[13:33:39.474] - result already collected: FutureResult
[13:33:39.474] result() for ClusterFuture ... done
[13:33:39.474] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.474] Future #1
[13:33:39.474] result() for ClusterFuture ...
[13:33:39.474] - result already collected: FutureResult
[13:33:39.474] result() for ClusterFuture ... done
[13:33:39.474] result() for ClusterFuture ...
[13:33:39.474] - result already collected: FutureResult
[13:33:39.475] result() for ClusterFuture ... done
[13:33:39.475] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:39.475] - nx: 2
[13:33:39.475] - relay: TRUE
[13:33:39.475] - stdout: TRUE
[13:33:39.475] - signal: TRUE
[13:33:39.475] - resignal: FALSE
[13:33:39.475] - force: TRUE
[13:33:39.475] - relayed: [n=2] FALSE, FALSE
[13:33:39.475] - queued futures: [n=2] FALSE, FALSE
[13:33:39.475]  - until=1
[13:33:39.476]  - relaying element #1
[13:33:39.476] result() for ClusterFuture ...
[13:33:39.476] - result already collected: FutureResult
[13:33:39.476] result() for ClusterFuture ... done
[13:33:39.476] result() for ClusterFuture ...
[13:33:39.476] - result already collected: FutureResult
[13:33:39.476] result() for ClusterFuture ... done
[13:33:39.476] result() for ClusterFuture ...
[13:33:39.476] - result already collected: FutureResult
[13:33:39.476] result() for ClusterFuture ... done
[13:33:39.476] result() for ClusterFuture ...
[13:33:39.477] - result already collected: FutureResult
[13:33:39.477] result() for ClusterFuture ... done
[13:33:39.477] - relayed: [n=2] TRUE, FALSE
[13:33:39.477] - queued futures: [n=2] TRUE, FALSE
[13:33:39.477] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:39.477]  length: 1 (resolved future 1)
[13:33:39.504] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.504] - Validating connection of MultisessionFuture
[13:33:39.504] - received message: FutureResult
[13:33:39.504] - Received FutureResult
[13:33:39.504] - Erased future from FutureRegistry
[13:33:39.504] result() for ClusterFuture ...
[13:33:39.504] - result already collected: FutureResult
[13:33:39.505] result() for ClusterFuture ... done
[13:33:39.505] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.505] Future #2
[13:33:39.505] result() for ClusterFuture ...
[13:33:39.505] - result already collected: FutureResult
[13:33:39.505] result() for ClusterFuture ... done
[13:33:39.505] result() for ClusterFuture ...
[13:33:39.505] - result already collected: FutureResult
[13:33:39.505] result() for ClusterFuture ... done
[13:33:39.505] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:39.505] - nx: 2
[13:33:39.506] - relay: TRUE
[13:33:39.506] - stdout: TRUE
[13:33:39.506] - signal: TRUE
[13:33:39.506] - resignal: FALSE
[13:33:39.506] - force: TRUE
[13:33:39.506] - relayed: [n=2] TRUE, FALSE
[13:33:39.506] - queued futures: [n=2] TRUE, FALSE
[13:33:39.506]  - until=2
[13:33:39.506]  - relaying element #2
[13:33:39.506] result() for ClusterFuture ...
[13:33:39.506] - result already collected: FutureResult
[13:33:39.507] result() for ClusterFuture ... done
[13:33:39.507] result() for ClusterFuture ...
[13:33:39.507] - result already collected: FutureResult
[13:33:39.507] result() for ClusterFuture ... done
[13:33:39.507] result() for ClusterFuture ...
[13:33:39.507] - result already collected: FutureResult
[13:33:39.507] result() for ClusterFuture ... done
[13:33:39.507] result() for ClusterFuture ...
[13:33:39.507] - result already collected: FutureResult
[13:33:39.507] result() for ClusterFuture ... done
[13:33:39.507] - relayed: [n=2] TRUE, TRUE
[13:33:39.508] - queued futures: [n=2] TRUE, TRUE
[13:33:39.508] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:39.508]  length: 0 (resolved future 2)
[13:33:39.508] Relaying remaining futures
[13:33:39.508] signalConditionsASAP(NULL, pos=0) ...
[13:33:39.508] - nx: 2
[13:33:39.508] - relay: TRUE
[13:33:39.508] - stdout: TRUE
[13:33:39.508] - signal: TRUE
[13:33:39.508] - resignal: FALSE
[13:33:39.508] - force: TRUE
[13:33:39.508] - relayed: [n=2] TRUE, TRUE
[13:33:39.509] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:39.509] - relayed: [n=2] TRUE, TRUE
[13:33:39.509] - queued futures: [n=2] TRUE, TRUE
[13:33:39.509] signalConditionsASAP(NULL, pos=0) ... done
[13:33:39.509] resolve() on list ... DONE
[13:33:39.509] result() for ClusterFuture ...
[13:33:39.509] - result already collected: FutureResult
[13:33:39.509] result() for ClusterFuture ... done
[13:33:39.509] result() for ClusterFuture ...
[13:33:39.509] - result already collected: FutureResult
[13:33:39.510] result() for ClusterFuture ... done
[13:33:39.510] result() for ClusterFuture ...
[13:33:39.510] - result already collected: FutureResult
[13:33:39.510] result() for ClusterFuture ... done
[13:33:39.510] result() for ClusterFuture ...
[13:33:39.510] - result already collected: FutureResult
[13:33:39.510] result() for ClusterFuture ... done
[13:33:39.510]  - Number of value chunks collected: 2
[13:33:39.510] Resolving 2 futures (chunks) ... DONE
[13:33:39.510] Reducing values from 2 chunks ...
[13:33:39.510]  - Number of values collected after concatenation: 6
[13:33:39.511]  - Number of values expected: 6
[13:33:39.511] Reducing values from 2 chunks ... DONE
[13:33:39.511] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[13:33:39.511] getGlobalsAndPackagesXApply() ...
[13:33:39.511]  - future.globals: TRUE
[13:33:39.511] getGlobalsAndPackages() ...
[13:33:39.512] Searching for globals...
[13:33:39.513] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[13:33:39.513] Searching for globals ... DONE
[13:33:39.513] Resolving globals: FALSE
[13:33:39.513] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[13:33:39.514] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[13:33:39.514] - globals: [1] ‘FUN’
[13:33:39.514] 
[13:33:39.514] getGlobalsAndPackages() ... DONE
[13:33:39.514]  - globals found/used: [n=1] ‘FUN’
[13:33:39.514]  - needed namespaces: [n=0] 
[13:33:39.514] Finding globals ... DONE
[13:33:39.514]  - use_args: TRUE
[13:33:39.515]  - Getting '...' globals ...
[13:33:39.515] resolve() on list ...
[13:33:39.515]  recursive: 0
[13:33:39.515]  length: 1
[13:33:39.515]  elements: ‘...’
[13:33:39.515]  length: 0 (resolved future 1)
[13:33:39.515] resolve() on list ... DONE
[13:33:39.515]    - '...' content: [n=0] 
[13:33:39.516] List of 1
[13:33:39.516]  $ ...: list()
[13:33:39.516]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.516]  - attr(*, "where")=List of 1
[13:33:39.516]   ..$ ...:<environment: 0x55b947e74c38> 
[13:33:39.516]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.516]  - attr(*, "resolved")= logi TRUE
[13:33:39.516]  - attr(*, "total_size")= num NA
[13:33:39.518]  - Getting '...' globals ... DONE
[13:33:39.518] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:39.518] List of 2
[13:33:39.518]  $ ...future.FUN:function (x)  
[13:33:39.518]  $ ...          : list()
[13:33:39.518]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.518]  - attr(*, "where")=List of 2
[13:33:39.518]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:39.518]   ..$ ...          :<environment: 0x55b947e74c38> 
[13:33:39.518]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.518]  - attr(*, "resolved")= logi FALSE
[13:33:39.518]  - attr(*, "total_size")= num 1768
[13:33:39.521] Packages to be attached in all futures: [n=0] 
[13:33:39.521] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.525] future_lapply() ...
[13:33:39.528] Number of chunks: 2
[13:33:39.528] getGlobalsAndPackagesXApply() ...
[13:33:39.528]  - future.globals: <name-value list> with names ‘list()’
[13:33:39.529]  - use_args: TRUE
[13:33:39.529] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:39.529] List of 2
[13:33:39.529]  $ ...          : list()
[13:33:39.529]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.529]  $ ...future.FUN:function (x)  
[13:33:39.529]  - attr(*, "where")=List of 2
[13:33:39.529]   ..$ ...          :<environment: 0x55b947e74c38> 
[13:33:39.529]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:33:39.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.529]  - attr(*, "resolved")= logi FALSE
[13:33:39.529]  - attr(*, "total_size")= num NA
[13:33:39.532] Packages to be attached in all futures: [n=0] 
[13:33:39.532] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.532] Number of futures (= number of chunks): 2
[13:33:39.532] Launching 2 futures (chunks) ...
[13:33:39.532] Chunk #1 of 2 ...
[13:33:39.532]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.532]  - seeds: <none>
[13:33:39.532]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.532] getGlobalsAndPackages() ...
[13:33:39.533] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.533] Resolving globals: FALSE
[13:33:39.533] Tweak future expression to call with '...' arguments ...
[13:33:39.533] {
[13:33:39.533]     do.call(function(...) {
[13:33:39.533]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.533]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.533]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.533]             on.exit(options(oopts), add = TRUE)
[13:33:39.533]         }
[13:33:39.533]         {
[13:33:39.533]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.533]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.533]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.533]             })
[13:33:39.533]         }
[13:33:39.533]     }, args = future.call.arguments)
[13:33:39.533] }
[13:33:39.533] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.533] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.534] 
[13:33:39.534] getGlobalsAndPackages() ... DONE
[13:33:39.534] run() for ‘Future’ ...
[13:33:39.534] - state: ‘created’
[13:33:39.534] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.548] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.548]   - Field: ‘node’
[13:33:39.548]   - Field: ‘label’
[13:33:39.548]   - Field: ‘local’
[13:33:39.548]   - Field: ‘owner’
[13:33:39.548]   - Field: ‘envir’
[13:33:39.548]   - Field: ‘workers’
[13:33:39.549]   - Field: ‘packages’
[13:33:39.549]   - Field: ‘gc’
[13:33:39.549]   - Field: ‘conditions’
[13:33:39.549]   - Field: ‘persistent’
[13:33:39.549]   - Field: ‘expr’
[13:33:39.549]   - Field: ‘uuid’
[13:33:39.549]   - Field: ‘seed’
[13:33:39.549]   - Field: ‘version’
[13:33:39.549]   - Field: ‘result’
[13:33:39.549]   - Field: ‘asynchronous’
[13:33:39.549]   - Field: ‘calls’
[13:33:39.550]   - Field: ‘globals’
[13:33:39.550]   - Field: ‘stdout’
[13:33:39.550]   - Field: ‘earlySignal’
[13:33:39.550]   - Field: ‘lazy’
[13:33:39.550]   - Field: ‘state’
[13:33:39.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.550] - Launch lazy future ...
[13:33:39.550] Packages needed by the future expression (n = 0): <none>
[13:33:39.550] Packages needed by future strategies (n = 0): <none>
[13:33:39.551] {
[13:33:39.551]     {
[13:33:39.551]         {
[13:33:39.551]             ...future.startTime <- base::Sys.time()
[13:33:39.551]             {
[13:33:39.551]                 {
[13:33:39.551]                   {
[13:33:39.551]                     {
[13:33:39.551]                       base::local({
[13:33:39.551]                         has_future <- base::requireNamespace("future", 
[13:33:39.551]                           quietly = TRUE)
[13:33:39.551]                         if (has_future) {
[13:33:39.551]                           ns <- base::getNamespace("future")
[13:33:39.551]                           version <- ns[[".package"]][["version"]]
[13:33:39.551]                           if (is.null(version)) 
[13:33:39.551]                             version <- utils::packageVersion("future")
[13:33:39.551]                         }
[13:33:39.551]                         else {
[13:33:39.551]                           version <- NULL
[13:33:39.551]                         }
[13:33:39.551]                         if (!has_future || version < "1.8.0") {
[13:33:39.551]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.551]                             "", base::R.version$version.string), 
[13:33:39.551]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.551]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.551]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.551]                               "release", "version")], collapse = " "), 
[13:33:39.551]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.551]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.551]                             info)
[13:33:39.551]                           info <- base::paste(info, collapse = "; ")
[13:33:39.551]                           if (!has_future) {
[13:33:39.551]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.551]                               info)
[13:33:39.551]                           }
[13:33:39.551]                           else {
[13:33:39.551]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.551]                               info, version)
[13:33:39.551]                           }
[13:33:39.551]                           base::stop(msg)
[13:33:39.551]                         }
[13:33:39.551]                       })
[13:33:39.551]                     }
[13:33:39.551]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.551]                     base::options(mc.cores = 1L)
[13:33:39.551]                   }
[13:33:39.551]                   ...future.strategy.old <- future::plan("list")
[13:33:39.551]                   options(future.plan = NULL)
[13:33:39.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.551]                 }
[13:33:39.551]                 ...future.workdir <- getwd()
[13:33:39.551]             }
[13:33:39.551]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.551]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.551]         }
[13:33:39.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.551]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.551]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.551]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.551]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.551]             base::names(...future.oldOptions))
[13:33:39.551]     }
[13:33:39.551]     if (FALSE) {
[13:33:39.551]     }
[13:33:39.551]     else {
[13:33:39.551]         if (TRUE) {
[13:33:39.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.551]                 open = "w")
[13:33:39.551]         }
[13:33:39.551]         else {
[13:33:39.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.551]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.551]         }
[13:33:39.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.551]             base::sink(type = "output", split = FALSE)
[13:33:39.551]             base::close(...future.stdout)
[13:33:39.551]         }, add = TRUE)
[13:33:39.551]     }
[13:33:39.551]     ...future.frame <- base::sys.nframe()
[13:33:39.551]     ...future.conditions <- base::list()
[13:33:39.551]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.551]     if (FALSE) {
[13:33:39.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.551]     }
[13:33:39.551]     ...future.result <- base::tryCatch({
[13:33:39.551]         base::withCallingHandlers({
[13:33:39.551]             ...future.value <- base::withVisible(base::local({
[13:33:39.551]                 ...future.makeSendCondition <- base::local({
[13:33:39.551]                   sendCondition <- NULL
[13:33:39.551]                   function(frame = 1L) {
[13:33:39.551]                     if (is.function(sendCondition)) 
[13:33:39.551]                       return(sendCondition)
[13:33:39.551]                     ns <- getNamespace("parallel")
[13:33:39.551]                     if (exists("sendData", mode = "function", 
[13:33:39.551]                       envir = ns)) {
[13:33:39.551]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.551]                         envir = ns)
[13:33:39.551]                       envir <- sys.frame(frame)
[13:33:39.551]                       master <- NULL
[13:33:39.551]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.551]                         !identical(envir, emptyenv())) {
[13:33:39.551]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.551]                           inherits = FALSE)) {
[13:33:39.551]                           master <- get("master", mode = "list", 
[13:33:39.551]                             envir = envir, inherits = FALSE)
[13:33:39.551]                           if (inherits(master, c("SOCKnode", 
[13:33:39.551]                             "SOCK0node"))) {
[13:33:39.551]                             sendCondition <<- function(cond) {
[13:33:39.551]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.551]                                 success = TRUE)
[13:33:39.551]                               parallel_sendData(master, data)
[13:33:39.551]                             }
[13:33:39.551]                             return(sendCondition)
[13:33:39.551]                           }
[13:33:39.551]                         }
[13:33:39.551]                         frame <- frame + 1L
[13:33:39.551]                         envir <- sys.frame(frame)
[13:33:39.551]                       }
[13:33:39.551]                     }
[13:33:39.551]                     sendCondition <<- function(cond) NULL
[13:33:39.551]                   }
[13:33:39.551]                 })
[13:33:39.551]                 withCallingHandlers({
[13:33:39.551]                   {
[13:33:39.551]                     do.call(function(...) {
[13:33:39.551]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.551]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.551]                         ...future.globals.maxSize)) {
[13:33:39.551]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.551]                         on.exit(options(oopts), add = TRUE)
[13:33:39.551]                       }
[13:33:39.551]                       {
[13:33:39.551]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.551]                           FUN = function(jj) {
[13:33:39.551]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.551]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.551]                           })
[13:33:39.551]                       }
[13:33:39.551]                     }, args = future.call.arguments)
[13:33:39.551]                   }
[13:33:39.551]                 }, immediateCondition = function(cond) {
[13:33:39.551]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.551]                   sendCondition(cond)
[13:33:39.551]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.551]                   {
[13:33:39.551]                     inherits <- base::inherits
[13:33:39.551]                     invokeRestart <- base::invokeRestart
[13:33:39.551]                     is.null <- base::is.null
[13:33:39.551]                     muffled <- FALSE
[13:33:39.551]                     if (inherits(cond, "message")) {
[13:33:39.551]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.551]                       if (muffled) 
[13:33:39.551]                         invokeRestart("muffleMessage")
[13:33:39.551]                     }
[13:33:39.551]                     else if (inherits(cond, "warning")) {
[13:33:39.551]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.551]                       if (muffled) 
[13:33:39.551]                         invokeRestart("muffleWarning")
[13:33:39.551]                     }
[13:33:39.551]                     else if (inherits(cond, "condition")) {
[13:33:39.551]                       if (!is.null(pattern)) {
[13:33:39.551]                         computeRestarts <- base::computeRestarts
[13:33:39.551]                         grepl <- base::grepl
[13:33:39.551]                         restarts <- computeRestarts(cond)
[13:33:39.551]                         for (restart in restarts) {
[13:33:39.551]                           name <- restart$name
[13:33:39.551]                           if (is.null(name)) 
[13:33:39.551]                             next
[13:33:39.551]                           if (!grepl(pattern, name)) 
[13:33:39.551]                             next
[13:33:39.551]                           invokeRestart(restart)
[13:33:39.551]                           muffled <- TRUE
[13:33:39.551]                           break
[13:33:39.551]                         }
[13:33:39.551]                       }
[13:33:39.551]                     }
[13:33:39.551]                     invisible(muffled)
[13:33:39.551]                   }
[13:33:39.551]                   muffleCondition(cond)
[13:33:39.551]                 })
[13:33:39.551]             }))
[13:33:39.551]             future::FutureResult(value = ...future.value$value, 
[13:33:39.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.551]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.551]                     ...future.globalenv.names))
[13:33:39.551]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.551]         }, condition = base::local({
[13:33:39.551]             c <- base::c
[13:33:39.551]             inherits <- base::inherits
[13:33:39.551]             invokeRestart <- base::invokeRestart
[13:33:39.551]             length <- base::length
[13:33:39.551]             list <- base::list
[13:33:39.551]             seq.int <- base::seq.int
[13:33:39.551]             signalCondition <- base::signalCondition
[13:33:39.551]             sys.calls <- base::sys.calls
[13:33:39.551]             `[[` <- base::`[[`
[13:33:39.551]             `+` <- base::`+`
[13:33:39.551]             `<<-` <- base::`<<-`
[13:33:39.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.551]                   3L)]
[13:33:39.551]             }
[13:33:39.551]             function(cond) {
[13:33:39.551]                 is_error <- inherits(cond, "error")
[13:33:39.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.551]                   NULL)
[13:33:39.551]                 if (is_error) {
[13:33:39.551]                   sessionInformation <- function() {
[13:33:39.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.551]                       search = base::search(), system = base::Sys.info())
[13:33:39.551]                   }
[13:33:39.551]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.551]                     cond$call), session = sessionInformation(), 
[13:33:39.551]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.551]                   signalCondition(cond)
[13:33:39.551]                 }
[13:33:39.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.551]                 "immediateCondition"))) {
[13:33:39.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.551]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.551]                   if (TRUE && !signal) {
[13:33:39.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.551]                     {
[13:33:39.551]                       inherits <- base::inherits
[13:33:39.551]                       invokeRestart <- base::invokeRestart
[13:33:39.551]                       is.null <- base::is.null
[13:33:39.551]                       muffled <- FALSE
[13:33:39.551]                       if (inherits(cond, "message")) {
[13:33:39.551]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.551]                         if (muffled) 
[13:33:39.551]                           invokeRestart("muffleMessage")
[13:33:39.551]                       }
[13:33:39.551]                       else if (inherits(cond, "warning")) {
[13:33:39.551]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.551]                         if (muffled) 
[13:33:39.551]                           invokeRestart("muffleWarning")
[13:33:39.551]                       }
[13:33:39.551]                       else if (inherits(cond, "condition")) {
[13:33:39.551]                         if (!is.null(pattern)) {
[13:33:39.551]                           computeRestarts <- base::computeRestarts
[13:33:39.551]                           grepl <- base::grepl
[13:33:39.551]                           restarts <- computeRestarts(cond)
[13:33:39.551]                           for (restart in restarts) {
[13:33:39.551]                             name <- restart$name
[13:33:39.551]                             if (is.null(name)) 
[13:33:39.551]                               next
[13:33:39.551]                             if (!grepl(pattern, name)) 
[13:33:39.551]                               next
[13:33:39.551]                             invokeRestart(restart)
[13:33:39.551]                             muffled <- TRUE
[13:33:39.551]                             break
[13:33:39.551]                           }
[13:33:39.551]                         }
[13:33:39.551]                       }
[13:33:39.551]                       invisible(muffled)
[13:33:39.551]                     }
[13:33:39.551]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.551]                   }
[13:33:39.551]                 }
[13:33:39.551]                 else {
[13:33:39.551]                   if (TRUE) {
[13:33:39.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.551]                     {
[13:33:39.551]                       inherits <- base::inherits
[13:33:39.551]                       invokeRestart <- base::invokeRestart
[13:33:39.551]                       is.null <- base::is.null
[13:33:39.551]                       muffled <- FALSE
[13:33:39.551]                       if (inherits(cond, "message")) {
[13:33:39.551]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.551]                         if (muffled) 
[13:33:39.551]                           invokeRestart("muffleMessage")
[13:33:39.551]                       }
[13:33:39.551]                       else if (inherits(cond, "warning")) {
[13:33:39.551]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.551]                         if (muffled) 
[13:33:39.551]                           invokeRestart("muffleWarning")
[13:33:39.551]                       }
[13:33:39.551]                       else if (inherits(cond, "condition")) {
[13:33:39.551]                         if (!is.null(pattern)) {
[13:33:39.551]                           computeRestarts <- base::computeRestarts
[13:33:39.551]                           grepl <- base::grepl
[13:33:39.551]                           restarts <- computeRestarts(cond)
[13:33:39.551]                           for (restart in restarts) {
[13:33:39.551]                             name <- restart$name
[13:33:39.551]                             if (is.null(name)) 
[13:33:39.551]                               next
[13:33:39.551]                             if (!grepl(pattern, name)) 
[13:33:39.551]                               next
[13:33:39.551]                             invokeRestart(restart)
[13:33:39.551]                             muffled <- TRUE
[13:33:39.551]                             break
[13:33:39.551]                           }
[13:33:39.551]                         }
[13:33:39.551]                       }
[13:33:39.551]                       invisible(muffled)
[13:33:39.551]                     }
[13:33:39.551]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.551]                   }
[13:33:39.551]                 }
[13:33:39.551]             }
[13:33:39.551]         }))
[13:33:39.551]     }, error = function(ex) {
[13:33:39.551]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.551]                 ...future.rng), started = ...future.startTime, 
[13:33:39.551]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.551]             version = "1.8"), class = "FutureResult")
[13:33:39.551]     }, finally = {
[13:33:39.551]         if (!identical(...future.workdir, getwd())) 
[13:33:39.551]             setwd(...future.workdir)
[13:33:39.551]         {
[13:33:39.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.551]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.551]             }
[13:33:39.551]             base::options(...future.oldOptions)
[13:33:39.551]             if (.Platform$OS.type == "windows") {
[13:33:39.551]                 old_names <- names(...future.oldEnvVars)
[13:33:39.551]                 envs <- base::Sys.getenv()
[13:33:39.551]                 names <- names(envs)
[13:33:39.551]                 common <- intersect(names, old_names)
[13:33:39.551]                 added <- setdiff(names, old_names)
[13:33:39.551]                 removed <- setdiff(old_names, names)
[13:33:39.551]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.551]                   envs[common]]
[13:33:39.551]                 NAMES <- toupper(changed)
[13:33:39.551]                 args <- list()
[13:33:39.551]                 for (kk in seq_along(NAMES)) {
[13:33:39.551]                   name <- changed[[kk]]
[13:33:39.551]                   NAME <- NAMES[[kk]]
[13:33:39.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.551]                     next
[13:33:39.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.551]                 }
[13:33:39.551]                 NAMES <- toupper(added)
[13:33:39.551]                 for (kk in seq_along(NAMES)) {
[13:33:39.551]                   name <- added[[kk]]
[13:33:39.551]                   NAME <- NAMES[[kk]]
[13:33:39.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.551]                     next
[13:33:39.551]                   args[[name]] <- ""
[13:33:39.551]                 }
[13:33:39.551]                 NAMES <- toupper(removed)
[13:33:39.551]                 for (kk in seq_along(NAMES)) {
[13:33:39.551]                   name <- removed[[kk]]
[13:33:39.551]                   NAME <- NAMES[[kk]]
[13:33:39.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.551]                     next
[13:33:39.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.551]                 }
[13:33:39.551]                 if (length(args) > 0) 
[13:33:39.551]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.551]             }
[13:33:39.551]             else {
[13:33:39.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.551]             }
[13:33:39.551]             {
[13:33:39.551]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.551]                   0L) {
[13:33:39.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.551]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.551]                   base::options(opts)
[13:33:39.551]                 }
[13:33:39.551]                 {
[13:33:39.551]                   {
[13:33:39.551]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.551]                     NULL
[13:33:39.551]                   }
[13:33:39.551]                   options(future.plan = NULL)
[13:33:39.551]                   if (is.na(NA_character_)) 
[13:33:39.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.551]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.551]                     .init = FALSE)
[13:33:39.551]                 }
[13:33:39.551]             }
[13:33:39.551]         }
[13:33:39.551]     })
[13:33:39.551]     if (TRUE) {
[13:33:39.551]         base::sink(type = "output", split = FALSE)
[13:33:39.551]         if (TRUE) {
[13:33:39.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.551]         }
[13:33:39.551]         else {
[13:33:39.551]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.551]         }
[13:33:39.551]         base::close(...future.stdout)
[13:33:39.551]         ...future.stdout <- NULL
[13:33:39.551]     }
[13:33:39.551]     ...future.result$conditions <- ...future.conditions
[13:33:39.551]     ...future.result$finished <- base::Sys.time()
[13:33:39.551]     ...future.result
[13:33:39.551] }
[13:33:39.554] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[13:33:39.554] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:39.554] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.555] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[13:33:39.555] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[13:33:39.555] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[13:33:39.555] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[13:33:39.556] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:39.556] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.556] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:39.556] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:39.557] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[13:33:39.557] MultisessionFuture started
[13:33:39.557] - Launch lazy future ... done
[13:33:39.557] run() for ‘MultisessionFuture’ ... done
[13:33:39.558] Created future:
[13:33:39.558] MultisessionFuture:
[13:33:39.558] Label: ‘future_apply-1’
[13:33:39.558] Expression:
[13:33:39.558] {
[13:33:39.558]     do.call(function(...) {
[13:33:39.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.558]             on.exit(options(oopts), add = TRUE)
[13:33:39.558]         }
[13:33:39.558]         {
[13:33:39.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.558]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.558]             })
[13:33:39.558]         }
[13:33:39.558]     }, args = future.call.arguments)
[13:33:39.558] }
[13:33:39.558] Lazy evaluation: FALSE
[13:33:39.558] Asynchronous evaluation: TRUE
[13:33:39.558] Local evaluation: TRUE
[13:33:39.558] Environment: R_GlobalEnv
[13:33:39.558] Capture standard output: TRUE
[13:33:39.558] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.558] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.558] Packages: <none>
[13:33:39.558] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.558] Resolved: FALSE
[13:33:39.558] Value: <not collected>
[13:33:39.558] Conditions captured: <none>
[13:33:39.558] Early signaling: FALSE
[13:33:39.558] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.558] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.569] Chunk #1 of 2 ... DONE
[13:33:39.569] Chunk #2 of 2 ...
[13:33:39.569]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.570]  - seeds: <none>
[13:33:39.570]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.570] getGlobalsAndPackages() ...
[13:33:39.570] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.570] Resolving globals: FALSE
[13:33:39.570] Tweak future expression to call with '...' arguments ...
[13:33:39.570] {
[13:33:39.570]     do.call(function(...) {
[13:33:39.570]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.570]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.570]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.570]             on.exit(options(oopts), add = TRUE)
[13:33:39.570]         }
[13:33:39.570]         {
[13:33:39.570]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.570]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.570]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.570]             })
[13:33:39.570]         }
[13:33:39.570]     }, args = future.call.arguments)
[13:33:39.570] }
[13:33:39.570] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.571] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.571] 
[13:33:39.571] getGlobalsAndPackages() ... DONE
[13:33:39.571] run() for ‘Future’ ...
[13:33:39.571] - state: ‘created’
[13:33:39.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.585] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.585] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.585]   - Field: ‘node’
[13:33:39.585]   - Field: ‘label’
[13:33:39.585]   - Field: ‘local’
[13:33:39.585]   - Field: ‘owner’
[13:33:39.585]   - Field: ‘envir’
[13:33:39.585]   - Field: ‘workers’
[13:33:39.586]   - Field: ‘packages’
[13:33:39.586]   - Field: ‘gc’
[13:33:39.586]   - Field: ‘conditions’
[13:33:39.586]   - Field: ‘persistent’
[13:33:39.586]   - Field: ‘expr’
[13:33:39.586]   - Field: ‘uuid’
[13:33:39.586]   - Field: ‘seed’
[13:33:39.586]   - Field: ‘version’
[13:33:39.586]   - Field: ‘result’
[13:33:39.586]   - Field: ‘asynchronous’
[13:33:39.586]   - Field: ‘calls’
[13:33:39.587]   - Field: ‘globals’
[13:33:39.587]   - Field: ‘stdout’
[13:33:39.587]   - Field: ‘earlySignal’
[13:33:39.587]   - Field: ‘lazy’
[13:33:39.587]   - Field: ‘state’
[13:33:39.587] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.587] - Launch lazy future ...
[13:33:39.587] Packages needed by the future expression (n = 0): <none>
[13:33:39.587] Packages needed by future strategies (n = 0): <none>
[13:33:39.588] {
[13:33:39.588]     {
[13:33:39.588]         {
[13:33:39.588]             ...future.startTime <- base::Sys.time()
[13:33:39.588]             {
[13:33:39.588]                 {
[13:33:39.588]                   {
[13:33:39.588]                     {
[13:33:39.588]                       base::local({
[13:33:39.588]                         has_future <- base::requireNamespace("future", 
[13:33:39.588]                           quietly = TRUE)
[13:33:39.588]                         if (has_future) {
[13:33:39.588]                           ns <- base::getNamespace("future")
[13:33:39.588]                           version <- ns[[".package"]][["version"]]
[13:33:39.588]                           if (is.null(version)) 
[13:33:39.588]                             version <- utils::packageVersion("future")
[13:33:39.588]                         }
[13:33:39.588]                         else {
[13:33:39.588]                           version <- NULL
[13:33:39.588]                         }
[13:33:39.588]                         if (!has_future || version < "1.8.0") {
[13:33:39.588]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.588]                             "", base::R.version$version.string), 
[13:33:39.588]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.588]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.588]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.588]                               "release", "version")], collapse = " "), 
[13:33:39.588]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.588]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.588]                             info)
[13:33:39.588]                           info <- base::paste(info, collapse = "; ")
[13:33:39.588]                           if (!has_future) {
[13:33:39.588]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.588]                               info)
[13:33:39.588]                           }
[13:33:39.588]                           else {
[13:33:39.588]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.588]                               info, version)
[13:33:39.588]                           }
[13:33:39.588]                           base::stop(msg)
[13:33:39.588]                         }
[13:33:39.588]                       })
[13:33:39.588]                     }
[13:33:39.588]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.588]                     base::options(mc.cores = 1L)
[13:33:39.588]                   }
[13:33:39.588]                   ...future.strategy.old <- future::plan("list")
[13:33:39.588]                   options(future.plan = NULL)
[13:33:39.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.588]                 }
[13:33:39.588]                 ...future.workdir <- getwd()
[13:33:39.588]             }
[13:33:39.588]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.588]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.588]         }
[13:33:39.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.588]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.588]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.588]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.588]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.588]             base::names(...future.oldOptions))
[13:33:39.588]     }
[13:33:39.588]     if (FALSE) {
[13:33:39.588]     }
[13:33:39.588]     else {
[13:33:39.588]         if (TRUE) {
[13:33:39.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.588]                 open = "w")
[13:33:39.588]         }
[13:33:39.588]         else {
[13:33:39.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.588]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.588]         }
[13:33:39.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.588]             base::sink(type = "output", split = FALSE)
[13:33:39.588]             base::close(...future.stdout)
[13:33:39.588]         }, add = TRUE)
[13:33:39.588]     }
[13:33:39.588]     ...future.frame <- base::sys.nframe()
[13:33:39.588]     ...future.conditions <- base::list()
[13:33:39.588]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.588]     if (FALSE) {
[13:33:39.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.588]     }
[13:33:39.588]     ...future.result <- base::tryCatch({
[13:33:39.588]         base::withCallingHandlers({
[13:33:39.588]             ...future.value <- base::withVisible(base::local({
[13:33:39.588]                 ...future.makeSendCondition <- base::local({
[13:33:39.588]                   sendCondition <- NULL
[13:33:39.588]                   function(frame = 1L) {
[13:33:39.588]                     if (is.function(sendCondition)) 
[13:33:39.588]                       return(sendCondition)
[13:33:39.588]                     ns <- getNamespace("parallel")
[13:33:39.588]                     if (exists("sendData", mode = "function", 
[13:33:39.588]                       envir = ns)) {
[13:33:39.588]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.588]                         envir = ns)
[13:33:39.588]                       envir <- sys.frame(frame)
[13:33:39.588]                       master <- NULL
[13:33:39.588]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.588]                         !identical(envir, emptyenv())) {
[13:33:39.588]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.588]                           inherits = FALSE)) {
[13:33:39.588]                           master <- get("master", mode = "list", 
[13:33:39.588]                             envir = envir, inherits = FALSE)
[13:33:39.588]                           if (inherits(master, c("SOCKnode", 
[13:33:39.588]                             "SOCK0node"))) {
[13:33:39.588]                             sendCondition <<- function(cond) {
[13:33:39.588]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.588]                                 success = TRUE)
[13:33:39.588]                               parallel_sendData(master, data)
[13:33:39.588]                             }
[13:33:39.588]                             return(sendCondition)
[13:33:39.588]                           }
[13:33:39.588]                         }
[13:33:39.588]                         frame <- frame + 1L
[13:33:39.588]                         envir <- sys.frame(frame)
[13:33:39.588]                       }
[13:33:39.588]                     }
[13:33:39.588]                     sendCondition <<- function(cond) NULL
[13:33:39.588]                   }
[13:33:39.588]                 })
[13:33:39.588]                 withCallingHandlers({
[13:33:39.588]                   {
[13:33:39.588]                     do.call(function(...) {
[13:33:39.588]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.588]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.588]                         ...future.globals.maxSize)) {
[13:33:39.588]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.588]                         on.exit(options(oopts), add = TRUE)
[13:33:39.588]                       }
[13:33:39.588]                       {
[13:33:39.588]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.588]                           FUN = function(jj) {
[13:33:39.588]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.588]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.588]                           })
[13:33:39.588]                       }
[13:33:39.588]                     }, args = future.call.arguments)
[13:33:39.588]                   }
[13:33:39.588]                 }, immediateCondition = function(cond) {
[13:33:39.588]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.588]                   sendCondition(cond)
[13:33:39.588]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.588]                   {
[13:33:39.588]                     inherits <- base::inherits
[13:33:39.588]                     invokeRestart <- base::invokeRestart
[13:33:39.588]                     is.null <- base::is.null
[13:33:39.588]                     muffled <- FALSE
[13:33:39.588]                     if (inherits(cond, "message")) {
[13:33:39.588]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.588]                       if (muffled) 
[13:33:39.588]                         invokeRestart("muffleMessage")
[13:33:39.588]                     }
[13:33:39.588]                     else if (inherits(cond, "warning")) {
[13:33:39.588]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.588]                       if (muffled) 
[13:33:39.588]                         invokeRestart("muffleWarning")
[13:33:39.588]                     }
[13:33:39.588]                     else if (inherits(cond, "condition")) {
[13:33:39.588]                       if (!is.null(pattern)) {
[13:33:39.588]                         computeRestarts <- base::computeRestarts
[13:33:39.588]                         grepl <- base::grepl
[13:33:39.588]                         restarts <- computeRestarts(cond)
[13:33:39.588]                         for (restart in restarts) {
[13:33:39.588]                           name <- restart$name
[13:33:39.588]                           if (is.null(name)) 
[13:33:39.588]                             next
[13:33:39.588]                           if (!grepl(pattern, name)) 
[13:33:39.588]                             next
[13:33:39.588]                           invokeRestart(restart)
[13:33:39.588]                           muffled <- TRUE
[13:33:39.588]                           break
[13:33:39.588]                         }
[13:33:39.588]                       }
[13:33:39.588]                     }
[13:33:39.588]                     invisible(muffled)
[13:33:39.588]                   }
[13:33:39.588]                   muffleCondition(cond)
[13:33:39.588]                 })
[13:33:39.588]             }))
[13:33:39.588]             future::FutureResult(value = ...future.value$value, 
[13:33:39.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.588]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.588]                     ...future.globalenv.names))
[13:33:39.588]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.588]         }, condition = base::local({
[13:33:39.588]             c <- base::c
[13:33:39.588]             inherits <- base::inherits
[13:33:39.588]             invokeRestart <- base::invokeRestart
[13:33:39.588]             length <- base::length
[13:33:39.588]             list <- base::list
[13:33:39.588]             seq.int <- base::seq.int
[13:33:39.588]             signalCondition <- base::signalCondition
[13:33:39.588]             sys.calls <- base::sys.calls
[13:33:39.588]             `[[` <- base::`[[`
[13:33:39.588]             `+` <- base::`+`
[13:33:39.588]             `<<-` <- base::`<<-`
[13:33:39.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.588]                   3L)]
[13:33:39.588]             }
[13:33:39.588]             function(cond) {
[13:33:39.588]                 is_error <- inherits(cond, "error")
[13:33:39.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.588]                   NULL)
[13:33:39.588]                 if (is_error) {
[13:33:39.588]                   sessionInformation <- function() {
[13:33:39.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.588]                       search = base::search(), system = base::Sys.info())
[13:33:39.588]                   }
[13:33:39.588]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.588]                     cond$call), session = sessionInformation(), 
[13:33:39.588]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.588]                   signalCondition(cond)
[13:33:39.588]                 }
[13:33:39.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.588]                 "immediateCondition"))) {
[13:33:39.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.588]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.588]                   if (TRUE && !signal) {
[13:33:39.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.588]                     {
[13:33:39.588]                       inherits <- base::inherits
[13:33:39.588]                       invokeRestart <- base::invokeRestart
[13:33:39.588]                       is.null <- base::is.null
[13:33:39.588]                       muffled <- FALSE
[13:33:39.588]                       if (inherits(cond, "message")) {
[13:33:39.588]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.588]                         if (muffled) 
[13:33:39.588]                           invokeRestart("muffleMessage")
[13:33:39.588]                       }
[13:33:39.588]                       else if (inherits(cond, "warning")) {
[13:33:39.588]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.588]                         if (muffled) 
[13:33:39.588]                           invokeRestart("muffleWarning")
[13:33:39.588]                       }
[13:33:39.588]                       else if (inherits(cond, "condition")) {
[13:33:39.588]                         if (!is.null(pattern)) {
[13:33:39.588]                           computeRestarts <- base::computeRestarts
[13:33:39.588]                           grepl <- base::grepl
[13:33:39.588]                           restarts <- computeRestarts(cond)
[13:33:39.588]                           for (restart in restarts) {
[13:33:39.588]                             name <- restart$name
[13:33:39.588]                             if (is.null(name)) 
[13:33:39.588]                               next
[13:33:39.588]                             if (!grepl(pattern, name)) 
[13:33:39.588]                               next
[13:33:39.588]                             invokeRestart(restart)
[13:33:39.588]                             muffled <- TRUE
[13:33:39.588]                             break
[13:33:39.588]                           }
[13:33:39.588]                         }
[13:33:39.588]                       }
[13:33:39.588]                       invisible(muffled)
[13:33:39.588]                     }
[13:33:39.588]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.588]                   }
[13:33:39.588]                 }
[13:33:39.588]                 else {
[13:33:39.588]                   if (TRUE) {
[13:33:39.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.588]                     {
[13:33:39.588]                       inherits <- base::inherits
[13:33:39.588]                       invokeRestart <- base::invokeRestart
[13:33:39.588]                       is.null <- base::is.null
[13:33:39.588]                       muffled <- FALSE
[13:33:39.588]                       if (inherits(cond, "message")) {
[13:33:39.588]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.588]                         if (muffled) 
[13:33:39.588]                           invokeRestart("muffleMessage")
[13:33:39.588]                       }
[13:33:39.588]                       else if (inherits(cond, "warning")) {
[13:33:39.588]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.588]                         if (muffled) 
[13:33:39.588]                           invokeRestart("muffleWarning")
[13:33:39.588]                       }
[13:33:39.588]                       else if (inherits(cond, "condition")) {
[13:33:39.588]                         if (!is.null(pattern)) {
[13:33:39.588]                           computeRestarts <- base::computeRestarts
[13:33:39.588]                           grepl <- base::grepl
[13:33:39.588]                           restarts <- computeRestarts(cond)
[13:33:39.588]                           for (restart in restarts) {
[13:33:39.588]                             name <- restart$name
[13:33:39.588]                             if (is.null(name)) 
[13:33:39.588]                               next
[13:33:39.588]                             if (!grepl(pattern, name)) 
[13:33:39.588]                               next
[13:33:39.588]                             invokeRestart(restart)
[13:33:39.588]                             muffled <- TRUE
[13:33:39.588]                             break
[13:33:39.588]                           }
[13:33:39.588]                         }
[13:33:39.588]                       }
[13:33:39.588]                       invisible(muffled)
[13:33:39.588]                     }
[13:33:39.588]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.588]                   }
[13:33:39.588]                 }
[13:33:39.588]             }
[13:33:39.588]         }))
[13:33:39.588]     }, error = function(ex) {
[13:33:39.588]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.588]                 ...future.rng), started = ...future.startTime, 
[13:33:39.588]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.588]             version = "1.8"), class = "FutureResult")
[13:33:39.588]     }, finally = {
[13:33:39.588]         if (!identical(...future.workdir, getwd())) 
[13:33:39.588]             setwd(...future.workdir)
[13:33:39.588]         {
[13:33:39.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.588]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.588]             }
[13:33:39.588]             base::options(...future.oldOptions)
[13:33:39.588]             if (.Platform$OS.type == "windows") {
[13:33:39.588]                 old_names <- names(...future.oldEnvVars)
[13:33:39.588]                 envs <- base::Sys.getenv()
[13:33:39.588]                 names <- names(envs)
[13:33:39.588]                 common <- intersect(names, old_names)
[13:33:39.588]                 added <- setdiff(names, old_names)
[13:33:39.588]                 removed <- setdiff(old_names, names)
[13:33:39.588]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.588]                   envs[common]]
[13:33:39.588]                 NAMES <- toupper(changed)
[13:33:39.588]                 args <- list()
[13:33:39.588]                 for (kk in seq_along(NAMES)) {
[13:33:39.588]                   name <- changed[[kk]]
[13:33:39.588]                   NAME <- NAMES[[kk]]
[13:33:39.588]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.588]                     next
[13:33:39.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.588]                 }
[13:33:39.588]                 NAMES <- toupper(added)
[13:33:39.588]                 for (kk in seq_along(NAMES)) {
[13:33:39.588]                   name <- added[[kk]]
[13:33:39.588]                   NAME <- NAMES[[kk]]
[13:33:39.588]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.588]                     next
[13:33:39.588]                   args[[name]] <- ""
[13:33:39.588]                 }
[13:33:39.588]                 NAMES <- toupper(removed)
[13:33:39.588]                 for (kk in seq_along(NAMES)) {
[13:33:39.588]                   name <- removed[[kk]]
[13:33:39.588]                   NAME <- NAMES[[kk]]
[13:33:39.588]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.588]                     next
[13:33:39.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.588]                 }
[13:33:39.588]                 if (length(args) > 0) 
[13:33:39.588]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.588]             }
[13:33:39.588]             else {
[13:33:39.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.588]             }
[13:33:39.588]             {
[13:33:39.588]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.588]                   0L) {
[13:33:39.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.588]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.588]                   base::options(opts)
[13:33:39.588]                 }
[13:33:39.588]                 {
[13:33:39.588]                   {
[13:33:39.588]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.588]                     NULL
[13:33:39.588]                   }
[13:33:39.588]                   options(future.plan = NULL)
[13:33:39.588]                   if (is.na(NA_character_)) 
[13:33:39.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.588]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.588]                     .init = FALSE)
[13:33:39.588]                 }
[13:33:39.588]             }
[13:33:39.588]         }
[13:33:39.588]     })
[13:33:39.588]     if (TRUE) {
[13:33:39.588]         base::sink(type = "output", split = FALSE)
[13:33:39.588]         if (TRUE) {
[13:33:39.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.588]         }
[13:33:39.588]         else {
[13:33:39.588]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.588]         }
[13:33:39.588]         base::close(...future.stdout)
[13:33:39.588]         ...future.stdout <- NULL
[13:33:39.588]     }
[13:33:39.588]     ...future.result$conditions <- ...future.conditions
[13:33:39.588]     ...future.result$finished <- base::Sys.time()
[13:33:39.588]     ...future.result
[13:33:39.588] }
[13:33:39.591] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[13:33:39.591] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:39.591] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.591] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[13:33:39.592] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[13:33:39.592] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[13:33:39.592] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[13:33:39.592] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:39.593] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.593] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:33:39.593] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:33:39.593] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[13:33:39.594] MultisessionFuture started
[13:33:39.594] - Launch lazy future ... done
[13:33:39.594] run() for ‘MultisessionFuture’ ... done
[13:33:39.594] Created future:
[13:33:39.594] MultisessionFuture:
[13:33:39.594] Label: ‘future_apply-2’
[13:33:39.594] Expression:
[13:33:39.594] {
[13:33:39.594]     do.call(function(...) {
[13:33:39.594]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.594]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.594]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.594]             on.exit(options(oopts), add = TRUE)
[13:33:39.594]         }
[13:33:39.594]         {
[13:33:39.594]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.594]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.594]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.594]             })
[13:33:39.594]         }
[13:33:39.594]     }, args = future.call.arguments)
[13:33:39.594] }
[13:33:39.594] Lazy evaluation: FALSE
[13:33:39.594] Asynchronous evaluation: TRUE
[13:33:39.594] Local evaluation: TRUE
[13:33:39.594] Environment: R_GlobalEnv
[13:33:39.594] Capture standard output: TRUE
[13:33:39.594] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.594] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.594] Packages: <none>
[13:33:39.594] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.594] Resolved: FALSE
[13:33:39.594] Value: <not collected>
[13:33:39.594] Conditions captured: <none>
[13:33:39.594] Early signaling: FALSE
[13:33:39.594] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.594] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.605] Chunk #2 of 2 ... DONE
[13:33:39.605] Launching 2 futures (chunks) ... DONE
[13:33:39.606] Resolving 2 futures (chunks) ...
[13:33:39.606] resolve() on list ...
[13:33:39.606]  recursive: 0
[13:33:39.606]  length: 2
[13:33:39.606] 
[13:33:39.606] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.607] - Validating connection of MultisessionFuture
[13:33:39.607] - received message: FutureResult
[13:33:39.607] - Received FutureResult
[13:33:39.607] - Erased future from FutureRegistry
[13:33:39.607] result() for ClusterFuture ...
[13:33:39.607] - result already collected: FutureResult
[13:33:39.607] result() for ClusterFuture ... done
[13:33:39.607] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.607] Future #1
[13:33:39.607] result() for ClusterFuture ...
[13:33:39.608] - result already collected: FutureResult
[13:33:39.608] result() for ClusterFuture ... done
[13:33:39.608] result() for ClusterFuture ...
[13:33:39.608] - result already collected: FutureResult
[13:33:39.608] result() for ClusterFuture ... done
[13:33:39.608] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:39.608] - nx: 2
[13:33:39.608] - relay: TRUE
[13:33:39.608] - stdout: TRUE
[13:33:39.608] - signal: TRUE
[13:33:39.608] - resignal: FALSE
[13:33:39.609] - force: TRUE
[13:33:39.609] - relayed: [n=2] FALSE, FALSE
[13:33:39.609] - queued futures: [n=2] FALSE, FALSE
[13:33:39.609]  - until=1
[13:33:39.609]  - relaying element #1
[13:33:39.609] result() for ClusterFuture ...
[13:33:39.609] - result already collected: FutureResult
[13:33:39.609] result() for ClusterFuture ... done
[13:33:39.609] result() for ClusterFuture ...
[13:33:39.609] - result already collected: FutureResult
[13:33:39.609] result() for ClusterFuture ... done
[13:33:39.610] result() for ClusterFuture ...
[13:33:39.610] - result already collected: FutureResult
[13:33:39.610] result() for ClusterFuture ... done
[13:33:39.610] result() for ClusterFuture ...
[13:33:39.610] - result already collected: FutureResult
[13:33:39.610] result() for ClusterFuture ... done
[13:33:39.610] - relayed: [n=2] TRUE, FALSE
[13:33:39.610] - queued futures: [n=2] TRUE, FALSE
[13:33:39.610] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:39.610]  length: 1 (resolved future 1)
[13:33:39.636] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.636] - Validating connection of MultisessionFuture
[13:33:39.636] - received message: FutureResult
[13:33:39.636] - Received FutureResult
[13:33:39.636] - Erased future from FutureRegistry
[13:33:39.636] result() for ClusterFuture ...
[13:33:39.636] - result already collected: FutureResult
[13:33:39.637] result() for ClusterFuture ... done
[13:33:39.637] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.637] Future #2
[13:33:39.637] result() for ClusterFuture ...
[13:33:39.637] - result already collected: FutureResult
[13:33:39.637] result() for ClusterFuture ... done
[13:33:39.637] result() for ClusterFuture ...
[13:33:39.637] - result already collected: FutureResult
[13:33:39.637] result() for ClusterFuture ... done
[13:33:39.637] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:39.638] - nx: 2
[13:33:39.638] - relay: TRUE
[13:33:39.638] - stdout: TRUE
[13:33:39.638] - signal: TRUE
[13:33:39.638] - resignal: FALSE
[13:33:39.638] - force: TRUE
[13:33:39.638] - relayed: [n=2] TRUE, FALSE
[13:33:39.640] - queued futures: [n=2] TRUE, FALSE
[13:33:39.640]  - until=2
[13:33:39.641]  - relaying element #2
[13:33:39.641] result() for ClusterFuture ...
[13:33:39.641] - result already collected: FutureResult
[13:33:39.641] result() for ClusterFuture ... done
[13:33:39.641] result() for ClusterFuture ...
[13:33:39.641] - result already collected: FutureResult
[13:33:39.641] result() for ClusterFuture ... done
[13:33:39.641] result() for ClusterFuture ...
[13:33:39.641] - result already collected: FutureResult
[13:33:39.641] result() for ClusterFuture ... done
[13:33:39.641] result() for ClusterFuture ...
[13:33:39.641] - result already collected: FutureResult
[13:33:39.642] result() for ClusterFuture ... done
[13:33:39.642] - relayed: [n=2] TRUE, TRUE
[13:33:39.642] - queued futures: [n=2] TRUE, TRUE
[13:33:39.642] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:39.642]  length: 0 (resolved future 2)
[13:33:39.642] Relaying remaining futures
[13:33:39.642] signalConditionsASAP(NULL, pos=0) ...
[13:33:39.642] - nx: 2
[13:33:39.642] - relay: TRUE
[13:33:39.642] - stdout: TRUE
[13:33:39.642] - signal: TRUE
[13:33:39.643] - resignal: FALSE
[13:33:39.643] - force: TRUE
[13:33:39.643] - relayed: [n=2] TRUE, TRUE
[13:33:39.643] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:39.643] - relayed: [n=2] TRUE, TRUE
[13:33:39.643] - queued futures: [n=2] TRUE, TRUE
[13:33:39.643] signalConditionsASAP(NULL, pos=0) ... done
[13:33:39.643] resolve() on list ... DONE
[13:33:39.643] result() for ClusterFuture ...
[13:33:39.643] - result already collected: FutureResult
[13:33:39.643] result() for ClusterFuture ... done
[13:33:39.644] result() for ClusterFuture ...
[13:33:39.644] - result already collected: FutureResult
[13:33:39.644] result() for ClusterFuture ... done
[13:33:39.644] result() for ClusterFuture ...
[13:33:39.644] - result already collected: FutureResult
[13:33:39.644] result() for ClusterFuture ... done
[13:33:39.644] result() for ClusterFuture ...
[13:33:39.644] - result already collected: FutureResult
[13:33:39.644] result() for ClusterFuture ... done
[13:33:39.644]  - Number of value chunks collected: 2
[13:33:39.644] Resolving 2 futures (chunks) ... DONE
[13:33:39.644] Reducing values from 2 chunks ...
[13:33:39.645]  - Number of values collected after concatenation: 6
[13:33:39.645]  - Number of values expected: 6
[13:33:39.645] Reducing values from 2 chunks ... DONE
[13:33:39.645] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[13:33:39.645] getGlobalsAndPackagesXApply() ...
[13:33:39.645]  - future.globals: TRUE
[13:33:39.645] getGlobalsAndPackages() ...
[13:33:39.645] Searching for globals...
[13:33:39.646] - globals found: [1] ‘FUN’
[13:33:39.647] Searching for globals ... DONE
[13:33:39.647] Resolving globals: FALSE
[13:33:39.647] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:39.647] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:39.647] - globals: [1] ‘FUN’
[13:33:39.647] 
[13:33:39.648] getGlobalsAndPackages() ... DONE
[13:33:39.648]  - globals found/used: [n=1] ‘FUN’
[13:33:39.648]  - needed namespaces: [n=0] 
[13:33:39.648] Finding globals ... DONE
[13:33:39.648]  - use_args: TRUE
[13:33:39.648]  - Getting '...' globals ...
[13:33:39.648] resolve() on list ...
[13:33:39.648]  recursive: 0
[13:33:39.648]  length: 1
[13:33:39.649]  elements: ‘...’
[13:33:39.649]  length: 0 (resolved future 1)
[13:33:39.649] resolve() on list ... DONE
[13:33:39.649]    - '...' content: [n=0] 
[13:33:39.649] List of 1
[13:33:39.649]  $ ...: list()
[13:33:39.649]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.649]  - attr(*, "where")=List of 1
[13:33:39.649]   ..$ ...:<environment: 0x55b94a5e59d0> 
[13:33:39.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.649]  - attr(*, "resolved")= logi TRUE
[13:33:39.649]  - attr(*, "total_size")= num NA
[13:33:39.651]  - Getting '...' globals ... DONE
[13:33:39.652] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:39.652] List of 2
[13:33:39.652]  $ ...future.FUN:function (x)  
[13:33:39.652]  $ ...          : list()
[13:33:39.652]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.652]  - attr(*, "where")=List of 2
[13:33:39.652]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:39.652]   ..$ ...          :<environment: 0x55b94a5e59d0> 
[13:33:39.652]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.652]  - attr(*, "resolved")= logi FALSE
[13:33:39.652]  - attr(*, "total_size")= num 848
[13:33:39.654] Packages to be attached in all futures: [n=0] 
[13:33:39.654] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.658] future_lapply() ...
[13:33:39.661] Number of chunks: 2
[13:33:39.661] getGlobalsAndPackagesXApply() ...
[13:33:39.662]  - future.globals: <name-value list> with names ‘list()’
[13:33:39.662]  - use_args: TRUE
[13:33:39.662] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:39.662] List of 2
[13:33:39.662]  $ ...          : list()
[13:33:39.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.662]  $ ...future.FUN:function (x)  
[13:33:39.662]  - attr(*, "where")=List of 2
[13:33:39.662]   ..$ ...          :<environment: 0x55b94a5e59d0> 
[13:33:39.662]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:39.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.662]  - attr(*, "resolved")= logi FALSE
[13:33:39.662]  - attr(*, "total_size")= num NA
[13:33:39.665] Packages to be attached in all futures: [n=0] 
[13:33:39.665] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.665] Number of futures (= number of chunks): 2
[13:33:39.666] Launching 2 futures (chunks) ...
[13:33:39.666] Chunk #1 of 2 ...
[13:33:39.666]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.666]  - seeds: <none>
[13:33:39.666]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.666] getGlobalsAndPackages() ...
[13:33:39.666] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.666] Resolving globals: FALSE
[13:33:39.667] Tweak future expression to call with '...' arguments ...
[13:33:39.667] {
[13:33:39.667]     do.call(function(...) {
[13:33:39.667]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.667]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.667]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.667]             on.exit(options(oopts), add = TRUE)
[13:33:39.667]         }
[13:33:39.667]         {
[13:33:39.667]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.667]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.667]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.667]             })
[13:33:39.667]         }
[13:33:39.667]     }, args = future.call.arguments)
[13:33:39.667] }
[13:33:39.667] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.667] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.667] 
[13:33:39.668] getGlobalsAndPackages() ... DONE
[13:33:39.668] run() for ‘Future’ ...
[13:33:39.668] - state: ‘created’
[13:33:39.668] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.682] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.682]   - Field: ‘node’
[13:33:39.682]   - Field: ‘label’
[13:33:39.682]   - Field: ‘local’
[13:33:39.682]   - Field: ‘owner’
[13:33:39.682]   - Field: ‘envir’
[13:33:39.682]   - Field: ‘workers’
[13:33:39.683]   - Field: ‘packages’
[13:33:39.683]   - Field: ‘gc’
[13:33:39.683]   - Field: ‘conditions’
[13:33:39.683]   - Field: ‘persistent’
[13:33:39.683]   - Field: ‘expr’
[13:33:39.683]   - Field: ‘uuid’
[13:33:39.683]   - Field: ‘seed’
[13:33:39.683]   - Field: ‘version’
[13:33:39.683]   - Field: ‘result’
[13:33:39.683]   - Field: ‘asynchronous’
[13:33:39.684]   - Field: ‘calls’
[13:33:39.684]   - Field: ‘globals’
[13:33:39.684]   - Field: ‘stdout’
[13:33:39.684]   - Field: ‘earlySignal’
[13:33:39.684]   - Field: ‘lazy’
[13:33:39.684]   - Field: ‘state’
[13:33:39.684] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.684] - Launch lazy future ...
[13:33:39.684] Packages needed by the future expression (n = 0): <none>
[13:33:39.685] Packages needed by future strategies (n = 0): <none>
[13:33:39.685] {
[13:33:39.685]     {
[13:33:39.685]         {
[13:33:39.685]             ...future.startTime <- base::Sys.time()
[13:33:39.685]             {
[13:33:39.685]                 {
[13:33:39.685]                   {
[13:33:39.685]                     {
[13:33:39.685]                       base::local({
[13:33:39.685]                         has_future <- base::requireNamespace("future", 
[13:33:39.685]                           quietly = TRUE)
[13:33:39.685]                         if (has_future) {
[13:33:39.685]                           ns <- base::getNamespace("future")
[13:33:39.685]                           version <- ns[[".package"]][["version"]]
[13:33:39.685]                           if (is.null(version)) 
[13:33:39.685]                             version <- utils::packageVersion("future")
[13:33:39.685]                         }
[13:33:39.685]                         else {
[13:33:39.685]                           version <- NULL
[13:33:39.685]                         }
[13:33:39.685]                         if (!has_future || version < "1.8.0") {
[13:33:39.685]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.685]                             "", base::R.version$version.string), 
[13:33:39.685]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.685]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.685]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.685]                               "release", "version")], collapse = " "), 
[13:33:39.685]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.685]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.685]                             info)
[13:33:39.685]                           info <- base::paste(info, collapse = "; ")
[13:33:39.685]                           if (!has_future) {
[13:33:39.685]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.685]                               info)
[13:33:39.685]                           }
[13:33:39.685]                           else {
[13:33:39.685]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.685]                               info, version)
[13:33:39.685]                           }
[13:33:39.685]                           base::stop(msg)
[13:33:39.685]                         }
[13:33:39.685]                       })
[13:33:39.685]                     }
[13:33:39.685]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.685]                     base::options(mc.cores = 1L)
[13:33:39.685]                   }
[13:33:39.685]                   ...future.strategy.old <- future::plan("list")
[13:33:39.685]                   options(future.plan = NULL)
[13:33:39.685]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.685]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.685]                 }
[13:33:39.685]                 ...future.workdir <- getwd()
[13:33:39.685]             }
[13:33:39.685]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.685]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.685]         }
[13:33:39.685]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.685]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.685]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.685]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.685]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.685]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.685]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.685]             base::names(...future.oldOptions))
[13:33:39.685]     }
[13:33:39.685]     if (FALSE) {
[13:33:39.685]     }
[13:33:39.685]     else {
[13:33:39.685]         if (TRUE) {
[13:33:39.685]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.685]                 open = "w")
[13:33:39.685]         }
[13:33:39.685]         else {
[13:33:39.685]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.685]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.685]         }
[13:33:39.685]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.685]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.685]             base::sink(type = "output", split = FALSE)
[13:33:39.685]             base::close(...future.stdout)
[13:33:39.685]         }, add = TRUE)
[13:33:39.685]     }
[13:33:39.685]     ...future.frame <- base::sys.nframe()
[13:33:39.685]     ...future.conditions <- base::list()
[13:33:39.685]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.685]     if (FALSE) {
[13:33:39.685]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.685]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.685]     }
[13:33:39.685]     ...future.result <- base::tryCatch({
[13:33:39.685]         base::withCallingHandlers({
[13:33:39.685]             ...future.value <- base::withVisible(base::local({
[13:33:39.685]                 ...future.makeSendCondition <- base::local({
[13:33:39.685]                   sendCondition <- NULL
[13:33:39.685]                   function(frame = 1L) {
[13:33:39.685]                     if (is.function(sendCondition)) 
[13:33:39.685]                       return(sendCondition)
[13:33:39.685]                     ns <- getNamespace("parallel")
[13:33:39.685]                     if (exists("sendData", mode = "function", 
[13:33:39.685]                       envir = ns)) {
[13:33:39.685]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.685]                         envir = ns)
[13:33:39.685]                       envir <- sys.frame(frame)
[13:33:39.685]                       master <- NULL
[13:33:39.685]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.685]                         !identical(envir, emptyenv())) {
[13:33:39.685]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.685]                           inherits = FALSE)) {
[13:33:39.685]                           master <- get("master", mode = "list", 
[13:33:39.685]                             envir = envir, inherits = FALSE)
[13:33:39.685]                           if (inherits(master, c("SOCKnode", 
[13:33:39.685]                             "SOCK0node"))) {
[13:33:39.685]                             sendCondition <<- function(cond) {
[13:33:39.685]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.685]                                 success = TRUE)
[13:33:39.685]                               parallel_sendData(master, data)
[13:33:39.685]                             }
[13:33:39.685]                             return(sendCondition)
[13:33:39.685]                           }
[13:33:39.685]                         }
[13:33:39.685]                         frame <- frame + 1L
[13:33:39.685]                         envir <- sys.frame(frame)
[13:33:39.685]                       }
[13:33:39.685]                     }
[13:33:39.685]                     sendCondition <<- function(cond) NULL
[13:33:39.685]                   }
[13:33:39.685]                 })
[13:33:39.685]                 withCallingHandlers({
[13:33:39.685]                   {
[13:33:39.685]                     do.call(function(...) {
[13:33:39.685]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.685]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.685]                         ...future.globals.maxSize)) {
[13:33:39.685]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.685]                         on.exit(options(oopts), add = TRUE)
[13:33:39.685]                       }
[13:33:39.685]                       {
[13:33:39.685]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.685]                           FUN = function(jj) {
[13:33:39.685]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.685]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.685]                           })
[13:33:39.685]                       }
[13:33:39.685]                     }, args = future.call.arguments)
[13:33:39.685]                   }
[13:33:39.685]                 }, immediateCondition = function(cond) {
[13:33:39.685]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.685]                   sendCondition(cond)
[13:33:39.685]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.685]                   {
[13:33:39.685]                     inherits <- base::inherits
[13:33:39.685]                     invokeRestart <- base::invokeRestart
[13:33:39.685]                     is.null <- base::is.null
[13:33:39.685]                     muffled <- FALSE
[13:33:39.685]                     if (inherits(cond, "message")) {
[13:33:39.685]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.685]                       if (muffled) 
[13:33:39.685]                         invokeRestart("muffleMessage")
[13:33:39.685]                     }
[13:33:39.685]                     else if (inherits(cond, "warning")) {
[13:33:39.685]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.685]                       if (muffled) 
[13:33:39.685]                         invokeRestart("muffleWarning")
[13:33:39.685]                     }
[13:33:39.685]                     else if (inherits(cond, "condition")) {
[13:33:39.685]                       if (!is.null(pattern)) {
[13:33:39.685]                         computeRestarts <- base::computeRestarts
[13:33:39.685]                         grepl <- base::grepl
[13:33:39.685]                         restarts <- computeRestarts(cond)
[13:33:39.685]                         for (restart in restarts) {
[13:33:39.685]                           name <- restart$name
[13:33:39.685]                           if (is.null(name)) 
[13:33:39.685]                             next
[13:33:39.685]                           if (!grepl(pattern, name)) 
[13:33:39.685]                             next
[13:33:39.685]                           invokeRestart(restart)
[13:33:39.685]                           muffled <- TRUE
[13:33:39.685]                           break
[13:33:39.685]                         }
[13:33:39.685]                       }
[13:33:39.685]                     }
[13:33:39.685]                     invisible(muffled)
[13:33:39.685]                   }
[13:33:39.685]                   muffleCondition(cond)
[13:33:39.685]                 })
[13:33:39.685]             }))
[13:33:39.685]             future::FutureResult(value = ...future.value$value, 
[13:33:39.685]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.685]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.685]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.685]                     ...future.globalenv.names))
[13:33:39.685]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.685]         }, condition = base::local({
[13:33:39.685]             c <- base::c
[13:33:39.685]             inherits <- base::inherits
[13:33:39.685]             invokeRestart <- base::invokeRestart
[13:33:39.685]             length <- base::length
[13:33:39.685]             list <- base::list
[13:33:39.685]             seq.int <- base::seq.int
[13:33:39.685]             signalCondition <- base::signalCondition
[13:33:39.685]             sys.calls <- base::sys.calls
[13:33:39.685]             `[[` <- base::`[[`
[13:33:39.685]             `+` <- base::`+`
[13:33:39.685]             `<<-` <- base::`<<-`
[13:33:39.685]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.685]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.685]                   3L)]
[13:33:39.685]             }
[13:33:39.685]             function(cond) {
[13:33:39.685]                 is_error <- inherits(cond, "error")
[13:33:39.685]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.685]                   NULL)
[13:33:39.685]                 if (is_error) {
[13:33:39.685]                   sessionInformation <- function() {
[13:33:39.685]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.685]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.685]                       search = base::search(), system = base::Sys.info())
[13:33:39.685]                   }
[13:33:39.685]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.685]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.685]                     cond$call), session = sessionInformation(), 
[13:33:39.685]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.685]                   signalCondition(cond)
[13:33:39.685]                 }
[13:33:39.685]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.685]                 "immediateCondition"))) {
[13:33:39.685]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.685]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.685]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.685]                   if (TRUE && !signal) {
[13:33:39.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.685]                     {
[13:33:39.685]                       inherits <- base::inherits
[13:33:39.685]                       invokeRestart <- base::invokeRestart
[13:33:39.685]                       is.null <- base::is.null
[13:33:39.685]                       muffled <- FALSE
[13:33:39.685]                       if (inherits(cond, "message")) {
[13:33:39.685]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.685]                         if (muffled) 
[13:33:39.685]                           invokeRestart("muffleMessage")
[13:33:39.685]                       }
[13:33:39.685]                       else if (inherits(cond, "warning")) {
[13:33:39.685]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.685]                         if (muffled) 
[13:33:39.685]                           invokeRestart("muffleWarning")
[13:33:39.685]                       }
[13:33:39.685]                       else if (inherits(cond, "condition")) {
[13:33:39.685]                         if (!is.null(pattern)) {
[13:33:39.685]                           computeRestarts <- base::computeRestarts
[13:33:39.685]                           grepl <- base::grepl
[13:33:39.685]                           restarts <- computeRestarts(cond)
[13:33:39.685]                           for (restart in restarts) {
[13:33:39.685]                             name <- restart$name
[13:33:39.685]                             if (is.null(name)) 
[13:33:39.685]                               next
[13:33:39.685]                             if (!grepl(pattern, name)) 
[13:33:39.685]                               next
[13:33:39.685]                             invokeRestart(restart)
[13:33:39.685]                             muffled <- TRUE
[13:33:39.685]                             break
[13:33:39.685]                           }
[13:33:39.685]                         }
[13:33:39.685]                       }
[13:33:39.685]                       invisible(muffled)
[13:33:39.685]                     }
[13:33:39.685]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.685]                   }
[13:33:39.685]                 }
[13:33:39.685]                 else {
[13:33:39.685]                   if (TRUE) {
[13:33:39.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.685]                     {
[13:33:39.685]                       inherits <- base::inherits
[13:33:39.685]                       invokeRestart <- base::invokeRestart
[13:33:39.685]                       is.null <- base::is.null
[13:33:39.685]                       muffled <- FALSE
[13:33:39.685]                       if (inherits(cond, "message")) {
[13:33:39.685]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.685]                         if (muffled) 
[13:33:39.685]                           invokeRestart("muffleMessage")
[13:33:39.685]                       }
[13:33:39.685]                       else if (inherits(cond, "warning")) {
[13:33:39.685]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.685]                         if (muffled) 
[13:33:39.685]                           invokeRestart("muffleWarning")
[13:33:39.685]                       }
[13:33:39.685]                       else if (inherits(cond, "condition")) {
[13:33:39.685]                         if (!is.null(pattern)) {
[13:33:39.685]                           computeRestarts <- base::computeRestarts
[13:33:39.685]                           grepl <- base::grepl
[13:33:39.685]                           restarts <- computeRestarts(cond)
[13:33:39.685]                           for (restart in restarts) {
[13:33:39.685]                             name <- restart$name
[13:33:39.685]                             if (is.null(name)) 
[13:33:39.685]                               next
[13:33:39.685]                             if (!grepl(pattern, name)) 
[13:33:39.685]                               next
[13:33:39.685]                             invokeRestart(restart)
[13:33:39.685]                             muffled <- TRUE
[13:33:39.685]                             break
[13:33:39.685]                           }
[13:33:39.685]                         }
[13:33:39.685]                       }
[13:33:39.685]                       invisible(muffled)
[13:33:39.685]                     }
[13:33:39.685]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.685]                   }
[13:33:39.685]                 }
[13:33:39.685]             }
[13:33:39.685]         }))
[13:33:39.685]     }, error = function(ex) {
[13:33:39.685]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.685]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.685]                 ...future.rng), started = ...future.startTime, 
[13:33:39.685]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.685]             version = "1.8"), class = "FutureResult")
[13:33:39.685]     }, finally = {
[13:33:39.685]         if (!identical(...future.workdir, getwd())) 
[13:33:39.685]             setwd(...future.workdir)
[13:33:39.685]         {
[13:33:39.685]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.685]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.685]             }
[13:33:39.685]             base::options(...future.oldOptions)
[13:33:39.685]             if (.Platform$OS.type == "windows") {
[13:33:39.685]                 old_names <- names(...future.oldEnvVars)
[13:33:39.685]                 envs <- base::Sys.getenv()
[13:33:39.685]                 names <- names(envs)
[13:33:39.685]                 common <- intersect(names, old_names)
[13:33:39.685]                 added <- setdiff(names, old_names)
[13:33:39.685]                 removed <- setdiff(old_names, names)
[13:33:39.685]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.685]                   envs[common]]
[13:33:39.685]                 NAMES <- toupper(changed)
[13:33:39.685]                 args <- list()
[13:33:39.685]                 for (kk in seq_along(NAMES)) {
[13:33:39.685]                   name <- changed[[kk]]
[13:33:39.685]                   NAME <- NAMES[[kk]]
[13:33:39.685]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.685]                     next
[13:33:39.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.685]                 }
[13:33:39.685]                 NAMES <- toupper(added)
[13:33:39.685]                 for (kk in seq_along(NAMES)) {
[13:33:39.685]                   name <- added[[kk]]
[13:33:39.685]                   NAME <- NAMES[[kk]]
[13:33:39.685]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.685]                     next
[13:33:39.685]                   args[[name]] <- ""
[13:33:39.685]                 }
[13:33:39.685]                 NAMES <- toupper(removed)
[13:33:39.685]                 for (kk in seq_along(NAMES)) {
[13:33:39.685]                   name <- removed[[kk]]
[13:33:39.685]                   NAME <- NAMES[[kk]]
[13:33:39.685]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.685]                     next
[13:33:39.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.685]                 }
[13:33:39.685]                 if (length(args) > 0) 
[13:33:39.685]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.685]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.685]             }
[13:33:39.685]             else {
[13:33:39.685]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.685]             }
[13:33:39.685]             {
[13:33:39.685]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.685]                   0L) {
[13:33:39.685]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.685]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.685]                   base::options(opts)
[13:33:39.685]                 }
[13:33:39.685]                 {
[13:33:39.685]                   {
[13:33:39.685]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.685]                     NULL
[13:33:39.685]                   }
[13:33:39.685]                   options(future.plan = NULL)
[13:33:39.685]                   if (is.na(NA_character_)) 
[13:33:39.685]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.685]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.685]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.685]                     .init = FALSE)
[13:33:39.685]                 }
[13:33:39.685]             }
[13:33:39.685]         }
[13:33:39.685]     })
[13:33:39.685]     if (TRUE) {
[13:33:39.685]         base::sink(type = "output", split = FALSE)
[13:33:39.685]         if (TRUE) {
[13:33:39.685]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.685]         }
[13:33:39.685]         else {
[13:33:39.685]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.685]         }
[13:33:39.685]         base::close(...future.stdout)
[13:33:39.685]         ...future.stdout <- NULL
[13:33:39.685]     }
[13:33:39.685]     ...future.result$conditions <- ...future.conditions
[13:33:39.685]     ...future.result$finished <- base::Sys.time()
[13:33:39.685]     ...future.result
[13:33:39.685] }
[13:33:39.688] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[13:33:39.688] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:39.688] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.689] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:33:39.689] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:33:39.689] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:33:39.689] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:33:39.689] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:39.690] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.690] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:39.690] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:39.690] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[13:33:39.691] MultisessionFuture started
[13:33:39.691] - Launch lazy future ... done
[13:33:39.691] run() for ‘MultisessionFuture’ ... done
[13:33:39.691] Created future:
[13:33:39.691] MultisessionFuture:
[13:33:39.691] Label: ‘future_apply-1’
[13:33:39.691] Expression:
[13:33:39.691] {
[13:33:39.691]     do.call(function(...) {
[13:33:39.691]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.691]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.691]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.691]             on.exit(options(oopts), add = TRUE)
[13:33:39.691]         }
[13:33:39.691]         {
[13:33:39.691]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.691]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.691]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.691]             })
[13:33:39.691]         }
[13:33:39.691]     }, args = future.call.arguments)
[13:33:39.691] }
[13:33:39.691] Lazy evaluation: FALSE
[13:33:39.691] Asynchronous evaluation: TRUE
[13:33:39.691] Local evaluation: TRUE
[13:33:39.691] Environment: R_GlobalEnv
[13:33:39.691] Capture standard output: TRUE
[13:33:39.691] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.691] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.691] Packages: <none>
[13:33:39.691] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.691] Resolved: FALSE
[13:33:39.691] Value: <not collected>
[13:33:39.691] Conditions captured: <none>
[13:33:39.691] Early signaling: FALSE
[13:33:39.691] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.691] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.703] Chunk #1 of 2 ... DONE
[13:33:39.703] Chunk #2 of 2 ...
[13:33:39.703]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.703]  - seeds: <none>
[13:33:39.703]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.703] getGlobalsAndPackages() ...
[13:33:39.703] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.703] Resolving globals: FALSE
[13:33:39.703] Tweak future expression to call with '...' arguments ...
[13:33:39.704] {
[13:33:39.704]     do.call(function(...) {
[13:33:39.704]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.704]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.704]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.704]             on.exit(options(oopts), add = TRUE)
[13:33:39.704]         }
[13:33:39.704]         {
[13:33:39.704]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.704]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.704]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.704]             })
[13:33:39.704]         }
[13:33:39.704]     }, args = future.call.arguments)
[13:33:39.704] }
[13:33:39.704] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.704] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.704] 
[13:33:39.704] getGlobalsAndPackages() ... DONE
[13:33:39.705] run() for ‘Future’ ...
[13:33:39.705] - state: ‘created’
[13:33:39.705] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.718] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.719]   - Field: ‘node’
[13:33:39.719]   - Field: ‘label’
[13:33:39.719]   - Field: ‘local’
[13:33:39.719]   - Field: ‘owner’
[13:33:39.719]   - Field: ‘envir’
[13:33:39.719]   - Field: ‘workers’
[13:33:39.719]   - Field: ‘packages’
[13:33:39.719]   - Field: ‘gc’
[13:33:39.719]   - Field: ‘conditions’
[13:33:39.719]   - Field: ‘persistent’
[13:33:39.719]   - Field: ‘expr’
[13:33:39.720]   - Field: ‘uuid’
[13:33:39.720]   - Field: ‘seed’
[13:33:39.720]   - Field: ‘version’
[13:33:39.720]   - Field: ‘result’
[13:33:39.720]   - Field: ‘asynchronous’
[13:33:39.720]   - Field: ‘calls’
[13:33:39.720]   - Field: ‘globals’
[13:33:39.720]   - Field: ‘stdout’
[13:33:39.720]   - Field: ‘earlySignal’
[13:33:39.720]   - Field: ‘lazy’
[13:33:39.720]   - Field: ‘state’
[13:33:39.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.721] - Launch lazy future ...
[13:33:39.721] Packages needed by the future expression (n = 0): <none>
[13:33:39.721] Packages needed by future strategies (n = 0): <none>
[13:33:39.721] {
[13:33:39.721]     {
[13:33:39.721]         {
[13:33:39.721]             ...future.startTime <- base::Sys.time()
[13:33:39.721]             {
[13:33:39.721]                 {
[13:33:39.721]                   {
[13:33:39.721]                     {
[13:33:39.721]                       base::local({
[13:33:39.721]                         has_future <- base::requireNamespace("future", 
[13:33:39.721]                           quietly = TRUE)
[13:33:39.721]                         if (has_future) {
[13:33:39.721]                           ns <- base::getNamespace("future")
[13:33:39.721]                           version <- ns[[".package"]][["version"]]
[13:33:39.721]                           if (is.null(version)) 
[13:33:39.721]                             version <- utils::packageVersion("future")
[13:33:39.721]                         }
[13:33:39.721]                         else {
[13:33:39.721]                           version <- NULL
[13:33:39.721]                         }
[13:33:39.721]                         if (!has_future || version < "1.8.0") {
[13:33:39.721]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.721]                             "", base::R.version$version.string), 
[13:33:39.721]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.721]                               "release", "version")], collapse = " "), 
[13:33:39.721]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.721]                             info)
[13:33:39.721]                           info <- base::paste(info, collapse = "; ")
[13:33:39.721]                           if (!has_future) {
[13:33:39.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.721]                               info)
[13:33:39.721]                           }
[13:33:39.721]                           else {
[13:33:39.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.721]                               info, version)
[13:33:39.721]                           }
[13:33:39.721]                           base::stop(msg)
[13:33:39.721]                         }
[13:33:39.721]                       })
[13:33:39.721]                     }
[13:33:39.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.721]                     base::options(mc.cores = 1L)
[13:33:39.721]                   }
[13:33:39.721]                   ...future.strategy.old <- future::plan("list")
[13:33:39.721]                   options(future.plan = NULL)
[13:33:39.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.721]                 }
[13:33:39.721]                 ...future.workdir <- getwd()
[13:33:39.721]             }
[13:33:39.721]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.721]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.721]         }
[13:33:39.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.721]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.721]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.721]             base::names(...future.oldOptions))
[13:33:39.721]     }
[13:33:39.721]     if (FALSE) {
[13:33:39.721]     }
[13:33:39.721]     else {
[13:33:39.721]         if (TRUE) {
[13:33:39.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.721]                 open = "w")
[13:33:39.721]         }
[13:33:39.721]         else {
[13:33:39.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.721]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.721]         }
[13:33:39.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.721]             base::sink(type = "output", split = FALSE)
[13:33:39.721]             base::close(...future.stdout)
[13:33:39.721]         }, add = TRUE)
[13:33:39.721]     }
[13:33:39.721]     ...future.frame <- base::sys.nframe()
[13:33:39.721]     ...future.conditions <- base::list()
[13:33:39.721]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.721]     if (FALSE) {
[13:33:39.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.721]     }
[13:33:39.721]     ...future.result <- base::tryCatch({
[13:33:39.721]         base::withCallingHandlers({
[13:33:39.721]             ...future.value <- base::withVisible(base::local({
[13:33:39.721]                 ...future.makeSendCondition <- base::local({
[13:33:39.721]                   sendCondition <- NULL
[13:33:39.721]                   function(frame = 1L) {
[13:33:39.721]                     if (is.function(sendCondition)) 
[13:33:39.721]                       return(sendCondition)
[13:33:39.721]                     ns <- getNamespace("parallel")
[13:33:39.721]                     if (exists("sendData", mode = "function", 
[13:33:39.721]                       envir = ns)) {
[13:33:39.721]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.721]                         envir = ns)
[13:33:39.721]                       envir <- sys.frame(frame)
[13:33:39.721]                       master <- NULL
[13:33:39.721]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.721]                         !identical(envir, emptyenv())) {
[13:33:39.721]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.721]                           inherits = FALSE)) {
[13:33:39.721]                           master <- get("master", mode = "list", 
[13:33:39.721]                             envir = envir, inherits = FALSE)
[13:33:39.721]                           if (inherits(master, c("SOCKnode", 
[13:33:39.721]                             "SOCK0node"))) {
[13:33:39.721]                             sendCondition <<- function(cond) {
[13:33:39.721]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.721]                                 success = TRUE)
[13:33:39.721]                               parallel_sendData(master, data)
[13:33:39.721]                             }
[13:33:39.721]                             return(sendCondition)
[13:33:39.721]                           }
[13:33:39.721]                         }
[13:33:39.721]                         frame <- frame + 1L
[13:33:39.721]                         envir <- sys.frame(frame)
[13:33:39.721]                       }
[13:33:39.721]                     }
[13:33:39.721]                     sendCondition <<- function(cond) NULL
[13:33:39.721]                   }
[13:33:39.721]                 })
[13:33:39.721]                 withCallingHandlers({
[13:33:39.721]                   {
[13:33:39.721]                     do.call(function(...) {
[13:33:39.721]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.721]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.721]                         ...future.globals.maxSize)) {
[13:33:39.721]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.721]                         on.exit(options(oopts), add = TRUE)
[13:33:39.721]                       }
[13:33:39.721]                       {
[13:33:39.721]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.721]                           FUN = function(jj) {
[13:33:39.721]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.721]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.721]                           })
[13:33:39.721]                       }
[13:33:39.721]                     }, args = future.call.arguments)
[13:33:39.721]                   }
[13:33:39.721]                 }, immediateCondition = function(cond) {
[13:33:39.721]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.721]                   sendCondition(cond)
[13:33:39.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.721]                   {
[13:33:39.721]                     inherits <- base::inherits
[13:33:39.721]                     invokeRestart <- base::invokeRestart
[13:33:39.721]                     is.null <- base::is.null
[13:33:39.721]                     muffled <- FALSE
[13:33:39.721]                     if (inherits(cond, "message")) {
[13:33:39.721]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.721]                       if (muffled) 
[13:33:39.721]                         invokeRestart("muffleMessage")
[13:33:39.721]                     }
[13:33:39.721]                     else if (inherits(cond, "warning")) {
[13:33:39.721]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.721]                       if (muffled) 
[13:33:39.721]                         invokeRestart("muffleWarning")
[13:33:39.721]                     }
[13:33:39.721]                     else if (inherits(cond, "condition")) {
[13:33:39.721]                       if (!is.null(pattern)) {
[13:33:39.721]                         computeRestarts <- base::computeRestarts
[13:33:39.721]                         grepl <- base::grepl
[13:33:39.721]                         restarts <- computeRestarts(cond)
[13:33:39.721]                         for (restart in restarts) {
[13:33:39.721]                           name <- restart$name
[13:33:39.721]                           if (is.null(name)) 
[13:33:39.721]                             next
[13:33:39.721]                           if (!grepl(pattern, name)) 
[13:33:39.721]                             next
[13:33:39.721]                           invokeRestart(restart)
[13:33:39.721]                           muffled <- TRUE
[13:33:39.721]                           break
[13:33:39.721]                         }
[13:33:39.721]                       }
[13:33:39.721]                     }
[13:33:39.721]                     invisible(muffled)
[13:33:39.721]                   }
[13:33:39.721]                   muffleCondition(cond)
[13:33:39.721]                 })
[13:33:39.721]             }))
[13:33:39.721]             future::FutureResult(value = ...future.value$value, 
[13:33:39.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.721]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.721]                     ...future.globalenv.names))
[13:33:39.721]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.721]         }, condition = base::local({
[13:33:39.721]             c <- base::c
[13:33:39.721]             inherits <- base::inherits
[13:33:39.721]             invokeRestart <- base::invokeRestart
[13:33:39.721]             length <- base::length
[13:33:39.721]             list <- base::list
[13:33:39.721]             seq.int <- base::seq.int
[13:33:39.721]             signalCondition <- base::signalCondition
[13:33:39.721]             sys.calls <- base::sys.calls
[13:33:39.721]             `[[` <- base::`[[`
[13:33:39.721]             `+` <- base::`+`
[13:33:39.721]             `<<-` <- base::`<<-`
[13:33:39.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.721]                   3L)]
[13:33:39.721]             }
[13:33:39.721]             function(cond) {
[13:33:39.721]                 is_error <- inherits(cond, "error")
[13:33:39.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.721]                   NULL)
[13:33:39.721]                 if (is_error) {
[13:33:39.721]                   sessionInformation <- function() {
[13:33:39.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.721]                       search = base::search(), system = base::Sys.info())
[13:33:39.721]                   }
[13:33:39.721]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.721]                     cond$call), session = sessionInformation(), 
[13:33:39.721]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.721]                   signalCondition(cond)
[13:33:39.721]                 }
[13:33:39.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.721]                 "immediateCondition"))) {
[13:33:39.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.721]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.721]                   if (TRUE && !signal) {
[13:33:39.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.721]                     {
[13:33:39.721]                       inherits <- base::inherits
[13:33:39.721]                       invokeRestart <- base::invokeRestart
[13:33:39.721]                       is.null <- base::is.null
[13:33:39.721]                       muffled <- FALSE
[13:33:39.721]                       if (inherits(cond, "message")) {
[13:33:39.721]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.721]                         if (muffled) 
[13:33:39.721]                           invokeRestart("muffleMessage")
[13:33:39.721]                       }
[13:33:39.721]                       else if (inherits(cond, "warning")) {
[13:33:39.721]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.721]                         if (muffled) 
[13:33:39.721]                           invokeRestart("muffleWarning")
[13:33:39.721]                       }
[13:33:39.721]                       else if (inherits(cond, "condition")) {
[13:33:39.721]                         if (!is.null(pattern)) {
[13:33:39.721]                           computeRestarts <- base::computeRestarts
[13:33:39.721]                           grepl <- base::grepl
[13:33:39.721]                           restarts <- computeRestarts(cond)
[13:33:39.721]                           for (restart in restarts) {
[13:33:39.721]                             name <- restart$name
[13:33:39.721]                             if (is.null(name)) 
[13:33:39.721]                               next
[13:33:39.721]                             if (!grepl(pattern, name)) 
[13:33:39.721]                               next
[13:33:39.721]                             invokeRestart(restart)
[13:33:39.721]                             muffled <- TRUE
[13:33:39.721]                             break
[13:33:39.721]                           }
[13:33:39.721]                         }
[13:33:39.721]                       }
[13:33:39.721]                       invisible(muffled)
[13:33:39.721]                     }
[13:33:39.721]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.721]                   }
[13:33:39.721]                 }
[13:33:39.721]                 else {
[13:33:39.721]                   if (TRUE) {
[13:33:39.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.721]                     {
[13:33:39.721]                       inherits <- base::inherits
[13:33:39.721]                       invokeRestart <- base::invokeRestart
[13:33:39.721]                       is.null <- base::is.null
[13:33:39.721]                       muffled <- FALSE
[13:33:39.721]                       if (inherits(cond, "message")) {
[13:33:39.721]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.721]                         if (muffled) 
[13:33:39.721]                           invokeRestart("muffleMessage")
[13:33:39.721]                       }
[13:33:39.721]                       else if (inherits(cond, "warning")) {
[13:33:39.721]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.721]                         if (muffled) 
[13:33:39.721]                           invokeRestart("muffleWarning")
[13:33:39.721]                       }
[13:33:39.721]                       else if (inherits(cond, "condition")) {
[13:33:39.721]                         if (!is.null(pattern)) {
[13:33:39.721]                           computeRestarts <- base::computeRestarts
[13:33:39.721]                           grepl <- base::grepl
[13:33:39.721]                           restarts <- computeRestarts(cond)
[13:33:39.721]                           for (restart in restarts) {
[13:33:39.721]                             name <- restart$name
[13:33:39.721]                             if (is.null(name)) 
[13:33:39.721]                               next
[13:33:39.721]                             if (!grepl(pattern, name)) 
[13:33:39.721]                               next
[13:33:39.721]                             invokeRestart(restart)
[13:33:39.721]                             muffled <- TRUE
[13:33:39.721]                             break
[13:33:39.721]                           }
[13:33:39.721]                         }
[13:33:39.721]                       }
[13:33:39.721]                       invisible(muffled)
[13:33:39.721]                     }
[13:33:39.721]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.721]                   }
[13:33:39.721]                 }
[13:33:39.721]             }
[13:33:39.721]         }))
[13:33:39.721]     }, error = function(ex) {
[13:33:39.721]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.721]                 ...future.rng), started = ...future.startTime, 
[13:33:39.721]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.721]             version = "1.8"), class = "FutureResult")
[13:33:39.721]     }, finally = {
[13:33:39.721]         if (!identical(...future.workdir, getwd())) 
[13:33:39.721]             setwd(...future.workdir)
[13:33:39.721]         {
[13:33:39.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.721]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.721]             }
[13:33:39.721]             base::options(...future.oldOptions)
[13:33:39.721]             if (.Platform$OS.type == "windows") {
[13:33:39.721]                 old_names <- names(...future.oldEnvVars)
[13:33:39.721]                 envs <- base::Sys.getenv()
[13:33:39.721]                 names <- names(envs)
[13:33:39.721]                 common <- intersect(names, old_names)
[13:33:39.721]                 added <- setdiff(names, old_names)
[13:33:39.721]                 removed <- setdiff(old_names, names)
[13:33:39.721]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.721]                   envs[common]]
[13:33:39.721]                 NAMES <- toupper(changed)
[13:33:39.721]                 args <- list()
[13:33:39.721]                 for (kk in seq_along(NAMES)) {
[13:33:39.721]                   name <- changed[[kk]]
[13:33:39.721]                   NAME <- NAMES[[kk]]
[13:33:39.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.721]                     next
[13:33:39.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.721]                 }
[13:33:39.721]                 NAMES <- toupper(added)
[13:33:39.721]                 for (kk in seq_along(NAMES)) {
[13:33:39.721]                   name <- added[[kk]]
[13:33:39.721]                   NAME <- NAMES[[kk]]
[13:33:39.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.721]                     next
[13:33:39.721]                   args[[name]] <- ""
[13:33:39.721]                 }
[13:33:39.721]                 NAMES <- toupper(removed)
[13:33:39.721]                 for (kk in seq_along(NAMES)) {
[13:33:39.721]                   name <- removed[[kk]]
[13:33:39.721]                   NAME <- NAMES[[kk]]
[13:33:39.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.721]                     next
[13:33:39.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.721]                 }
[13:33:39.721]                 if (length(args) > 0) 
[13:33:39.721]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.721]             }
[13:33:39.721]             else {
[13:33:39.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.721]             }
[13:33:39.721]             {
[13:33:39.721]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.721]                   0L) {
[13:33:39.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.721]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.721]                   base::options(opts)
[13:33:39.721]                 }
[13:33:39.721]                 {
[13:33:39.721]                   {
[13:33:39.721]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.721]                     NULL
[13:33:39.721]                   }
[13:33:39.721]                   options(future.plan = NULL)
[13:33:39.721]                   if (is.na(NA_character_)) 
[13:33:39.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.721]                     .init = FALSE)
[13:33:39.721]                 }
[13:33:39.721]             }
[13:33:39.721]         }
[13:33:39.721]     })
[13:33:39.721]     if (TRUE) {
[13:33:39.721]         base::sink(type = "output", split = FALSE)
[13:33:39.721]         if (TRUE) {
[13:33:39.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.721]         }
[13:33:39.721]         else {
[13:33:39.721]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.721]         }
[13:33:39.721]         base::close(...future.stdout)
[13:33:39.721]         ...future.stdout <- NULL
[13:33:39.721]     }
[13:33:39.721]     ...future.result$conditions <- ...future.conditions
[13:33:39.721]     ...future.result$finished <- base::Sys.time()
[13:33:39.721]     ...future.result
[13:33:39.721] }
[13:33:39.724] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[13:33:39.725] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:39.725] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.725] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:33:39.725] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:33:39.726] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:33:39.726] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:33:39.726] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:39.726] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.727] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:33:39.727] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:33:39.727] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[13:33:39.728] MultisessionFuture started
[13:33:39.728] - Launch lazy future ... done
[13:33:39.728] run() for ‘MultisessionFuture’ ... done
[13:33:39.728] Created future:
[13:33:39.728] MultisessionFuture:
[13:33:39.728] Label: ‘future_apply-2’
[13:33:39.728] Expression:
[13:33:39.728] {
[13:33:39.728]     do.call(function(...) {
[13:33:39.728]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.728]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.728]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.728]             on.exit(options(oopts), add = TRUE)
[13:33:39.728]         }
[13:33:39.728]         {
[13:33:39.728]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.728]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.728]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.728]             })
[13:33:39.728]         }
[13:33:39.728]     }, args = future.call.arguments)
[13:33:39.728] }
[13:33:39.728] Lazy evaluation: FALSE
[13:33:39.728] Asynchronous evaluation: TRUE
[13:33:39.728] Local evaluation: TRUE
[13:33:39.728] Environment: R_GlobalEnv
[13:33:39.728] Capture standard output: TRUE
[13:33:39.728] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.728] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.728] Packages: <none>
[13:33:39.728] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.728] Resolved: FALSE
[13:33:39.728] Value: <not collected>
[13:33:39.728] Conditions captured: <none>
[13:33:39.728] Early signaling: FALSE
[13:33:39.728] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.728] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.739] Chunk #2 of 2 ... DONE
[13:33:39.740] Launching 2 futures (chunks) ... DONE
[13:33:39.740] Resolving 2 futures (chunks) ...
[13:33:39.740] resolve() on list ...
[13:33:39.740]  recursive: 0
[13:33:39.740]  length: 2
[13:33:39.740] 
[13:33:39.740] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.741] - Validating connection of MultisessionFuture
[13:33:39.741] - received message: FutureResult
[13:33:39.741] - Received FutureResult
[13:33:39.741] - Erased future from FutureRegistry
[13:33:39.741] result() for ClusterFuture ...
[13:33:39.741] - result already collected: FutureResult
[13:33:39.741] result() for ClusterFuture ... done
[13:33:39.741] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.741] Future #1
[13:33:39.741] result() for ClusterFuture ...
[13:33:39.742] - result already collected: FutureResult
[13:33:39.742] result() for ClusterFuture ... done
[13:33:39.742] result() for ClusterFuture ...
[13:33:39.742] - result already collected: FutureResult
[13:33:39.742] result() for ClusterFuture ... done
[13:33:39.742] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:39.742] - nx: 2
[13:33:39.742] - relay: TRUE
[13:33:39.742] - stdout: TRUE
[13:33:39.742] - signal: TRUE
[13:33:39.742] - resignal: FALSE
[13:33:39.743] - force: TRUE
[13:33:39.743] - relayed: [n=2] FALSE, FALSE
[13:33:39.743] - queued futures: [n=2] FALSE, FALSE
[13:33:39.743]  - until=1
[13:33:39.743]  - relaying element #1
[13:33:39.743] result() for ClusterFuture ...
[13:33:39.743] - result already collected: FutureResult
[13:33:39.743] result() for ClusterFuture ... done
[13:33:39.743] result() for ClusterFuture ...
[13:33:39.743] - result already collected: FutureResult
[13:33:39.743] result() for ClusterFuture ... done
[13:33:39.744] result() for ClusterFuture ...
[13:33:39.744] - result already collected: FutureResult
[13:33:39.744] result() for ClusterFuture ... done
[13:33:39.744] result() for ClusterFuture ...
[13:33:39.744] - result already collected: FutureResult
[13:33:39.744] result() for ClusterFuture ... done
[13:33:39.744] - relayed: [n=2] TRUE, FALSE
[13:33:39.744] - queued futures: [n=2] TRUE, FALSE
[13:33:39.744] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:39.744]  length: 1 (resolved future 1)
[13:33:39.772] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.772] - Validating connection of MultisessionFuture
[13:33:39.772] - received message: FutureResult
[13:33:39.772] - Received FutureResult
[13:33:39.772] - Erased future from FutureRegistry
[13:33:39.772] result() for ClusterFuture ...
[13:33:39.772] - result already collected: FutureResult
[13:33:39.773] result() for ClusterFuture ... done
[13:33:39.773] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.773] Future #2
[13:33:39.773] result() for ClusterFuture ...
[13:33:39.773] - result already collected: FutureResult
[13:33:39.773] result() for ClusterFuture ... done
[13:33:39.773] result() for ClusterFuture ...
[13:33:39.773] - result already collected: FutureResult
[13:33:39.773] result() for ClusterFuture ... done
[13:33:39.773] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:39.773] - nx: 2
[13:33:39.774] - relay: TRUE
[13:33:39.774] - stdout: TRUE
[13:33:39.774] - signal: TRUE
[13:33:39.774] - resignal: FALSE
[13:33:39.774] - force: TRUE
[13:33:39.774] - relayed: [n=2] TRUE, FALSE
[13:33:39.774] - queued futures: [n=2] TRUE, FALSE
[13:33:39.774]  - until=2
[13:33:39.774]  - relaying element #2
[13:33:39.774] result() for ClusterFuture ...
[13:33:39.774] - result already collected: FutureResult
[13:33:39.774] result() for ClusterFuture ... done
[13:33:39.775] result() for ClusterFuture ...
[13:33:39.775] - result already collected: FutureResult
[13:33:39.775] result() for ClusterFuture ... done
[13:33:39.775] result() for ClusterFuture ...
[13:33:39.775] - result already collected: FutureResult
[13:33:39.775] result() for ClusterFuture ... done
[13:33:39.775] result() for ClusterFuture ...
[13:33:39.775] - result already collected: FutureResult
[13:33:39.775] result() for ClusterFuture ... done
[13:33:39.775] - relayed: [n=2] TRUE, TRUE
[13:33:39.775] - queued futures: [n=2] TRUE, TRUE
[13:33:39.776] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:39.776]  length: 0 (resolved future 2)
[13:33:39.776] Relaying remaining futures
[13:33:39.776] signalConditionsASAP(NULL, pos=0) ...
[13:33:39.776] - nx: 2
[13:33:39.776] - relay: TRUE
[13:33:39.776] - stdout: TRUE
[13:33:39.776] - signal: TRUE
[13:33:39.776] - resignal: FALSE
[13:33:39.776] - force: TRUE
[13:33:39.776] - relayed: [n=2] TRUE, TRUE
[13:33:39.776] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:39.777] - relayed: [n=2] TRUE, TRUE
[13:33:39.777] - queued futures: [n=2] TRUE, TRUE
[13:33:39.777] signalConditionsASAP(NULL, pos=0) ... done
[13:33:39.777] resolve() on list ... DONE
[13:33:39.777] result() for ClusterFuture ...
[13:33:39.777] - result already collected: FutureResult
[13:33:39.777] result() for ClusterFuture ... done
[13:33:39.777] result() for ClusterFuture ...
[13:33:39.777] - result already collected: FutureResult
[13:33:39.777] result() for ClusterFuture ... done
[13:33:39.777] result() for ClusterFuture ...
[13:33:39.778] - result already collected: FutureResult
[13:33:39.778] result() for ClusterFuture ... done
[13:33:39.778] result() for ClusterFuture ...
[13:33:39.778] - result already collected: FutureResult
[13:33:39.778] result() for ClusterFuture ... done
[13:33:39.778]  - Number of value chunks collected: 2
[13:33:39.778] Resolving 2 futures (chunks) ... DONE
[13:33:39.778] Reducing values from 2 chunks ...
[13:33:39.778]  - Number of values collected after concatenation: 2
[13:33:39.778]  - Number of values expected: 2
[13:33:39.778] Reducing values from 2 chunks ... DONE
[13:33:39.779] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[13:33:39.779] getGlobalsAndPackagesXApply() ...
[13:33:39.779]  - future.globals: TRUE
[13:33:39.779] getGlobalsAndPackages() ...
[13:33:39.779] Searching for globals...
[13:33:39.780] - globals found: [1] ‘FUN’
[13:33:39.780] Searching for globals ... DONE
[13:33:39.780] Resolving globals: FALSE
[13:33:39.781] The total size of the 1 globals is 848 bytes (848 bytes)
[13:33:39.781] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:33:39.781] - globals: [1] ‘FUN’
[13:33:39.781] 
[13:33:39.781] getGlobalsAndPackages() ... DONE
[13:33:39.781]  - globals found/used: [n=1] ‘FUN’
[13:33:39.781]  - needed namespaces: [n=0] 
[13:33:39.782] Finding globals ... DONE
[13:33:39.782]  - use_args: TRUE
[13:33:39.782]  - Getting '...' globals ...
[13:33:39.782] resolve() on list ...
[13:33:39.782]  recursive: 0
[13:33:39.782]  length: 1
[13:33:39.782]  elements: ‘...’
[13:33:39.782]  length: 0 (resolved future 1)
[13:33:39.783] resolve() on list ... DONE
[13:33:39.783]    - '...' content: [n=0] 
[13:33:39.783] List of 1
[13:33:39.783]  $ ...: list()
[13:33:39.783]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.783]  - attr(*, "where")=List of 1
[13:33:39.783]   ..$ ...:<environment: 0x55b94bc95990> 
[13:33:39.783]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.783]  - attr(*, "resolved")= logi TRUE
[13:33:39.783]  - attr(*, "total_size")= num NA
[13:33:39.785]  - Getting '...' globals ... DONE
[13:33:39.785] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:39.785] List of 2
[13:33:39.785]  $ ...future.FUN:function (x)  
[13:33:39.785]  $ ...          : list()
[13:33:39.785]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.785]  - attr(*, "where")=List of 2
[13:33:39.785]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:39.785]   ..$ ...          :<environment: 0x55b94bc95990> 
[13:33:39.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.785]  - attr(*, "resolved")= logi FALSE
[13:33:39.785]  - attr(*, "total_size")= num 848
[13:33:39.788] Packages to be attached in all futures: [n=0] 
[13:33:39.788] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.792] future_lapply() ...
[13:33:39.795] Number of chunks: 2
[13:33:39.795] getGlobalsAndPackagesXApply() ...
[13:33:39.795]  - future.globals: <name-value list> with names ‘list()’
[13:33:39.796]  - use_args: TRUE
[13:33:39.796] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:39.796] List of 2
[13:33:39.796]  $ ...          : list()
[13:33:39.796]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.796]  $ ...future.FUN:function (x)  
[13:33:39.796]  - attr(*, "where")=List of 2
[13:33:39.796]   ..$ ...          :<environment: 0x55b94bc95990> 
[13:33:39.796]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:39.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.796]  - attr(*, "resolved")= logi FALSE
[13:33:39.796]  - attr(*, "total_size")= num NA
[13:33:39.801] Packages to be attached in all futures: [n=0] 
[13:33:39.801] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.801] Number of futures (= number of chunks): 2
[13:33:39.801] Launching 2 futures (chunks) ...
[13:33:39.801] Chunk #1 of 2 ...
[13:33:39.802]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.802]  - seeds: <none>
[13:33:39.802]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.802] getGlobalsAndPackages() ...
[13:33:39.802] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.802] Resolving globals: FALSE
[13:33:39.802] Tweak future expression to call with '...' arguments ...
[13:33:39.802] {
[13:33:39.802]     do.call(function(...) {
[13:33:39.802]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.802]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.802]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.802]             on.exit(options(oopts), add = TRUE)
[13:33:39.802]         }
[13:33:39.802]         {
[13:33:39.802]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.802]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.802]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.802]             })
[13:33:39.802]         }
[13:33:39.802]     }, args = future.call.arguments)
[13:33:39.802] }
[13:33:39.803] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.803] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.803] 
[13:33:39.803] getGlobalsAndPackages() ... DONE
[13:33:39.803] run() for ‘Future’ ...
[13:33:39.804] - state: ‘created’
[13:33:39.804] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.817] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.817] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.817]   - Field: ‘node’
[13:33:39.817]   - Field: ‘label’
[13:33:39.817]   - Field: ‘local’
[13:33:39.817]   - Field: ‘owner’
[13:33:39.817]   - Field: ‘envir’
[13:33:39.818]   - Field: ‘workers’
[13:33:39.818]   - Field: ‘packages’
[13:33:39.818]   - Field: ‘gc’
[13:33:39.818]   - Field: ‘conditions’
[13:33:39.818]   - Field: ‘persistent’
[13:33:39.818]   - Field: ‘expr’
[13:33:39.818]   - Field: ‘uuid’
[13:33:39.818]   - Field: ‘seed’
[13:33:39.818]   - Field: ‘version’
[13:33:39.818]   - Field: ‘result’
[13:33:39.818]   - Field: ‘asynchronous’
[13:33:39.819]   - Field: ‘calls’
[13:33:39.819]   - Field: ‘globals’
[13:33:39.819]   - Field: ‘stdout’
[13:33:39.819]   - Field: ‘earlySignal’
[13:33:39.819]   - Field: ‘lazy’
[13:33:39.819]   - Field: ‘state’
[13:33:39.819] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.819] - Launch lazy future ...
[13:33:39.819] Packages needed by the future expression (n = 0): <none>
[13:33:39.820] Packages needed by future strategies (n = 0): <none>
[13:33:39.820] {
[13:33:39.820]     {
[13:33:39.820]         {
[13:33:39.820]             ...future.startTime <- base::Sys.time()
[13:33:39.820]             {
[13:33:39.820]                 {
[13:33:39.820]                   {
[13:33:39.820]                     {
[13:33:39.820]                       base::local({
[13:33:39.820]                         has_future <- base::requireNamespace("future", 
[13:33:39.820]                           quietly = TRUE)
[13:33:39.820]                         if (has_future) {
[13:33:39.820]                           ns <- base::getNamespace("future")
[13:33:39.820]                           version <- ns[[".package"]][["version"]]
[13:33:39.820]                           if (is.null(version)) 
[13:33:39.820]                             version <- utils::packageVersion("future")
[13:33:39.820]                         }
[13:33:39.820]                         else {
[13:33:39.820]                           version <- NULL
[13:33:39.820]                         }
[13:33:39.820]                         if (!has_future || version < "1.8.0") {
[13:33:39.820]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.820]                             "", base::R.version$version.string), 
[13:33:39.820]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.820]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.820]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.820]                               "release", "version")], collapse = " "), 
[13:33:39.820]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.820]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.820]                             info)
[13:33:39.820]                           info <- base::paste(info, collapse = "; ")
[13:33:39.820]                           if (!has_future) {
[13:33:39.820]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.820]                               info)
[13:33:39.820]                           }
[13:33:39.820]                           else {
[13:33:39.820]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.820]                               info, version)
[13:33:39.820]                           }
[13:33:39.820]                           base::stop(msg)
[13:33:39.820]                         }
[13:33:39.820]                       })
[13:33:39.820]                     }
[13:33:39.820]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.820]                     base::options(mc.cores = 1L)
[13:33:39.820]                   }
[13:33:39.820]                   ...future.strategy.old <- future::plan("list")
[13:33:39.820]                   options(future.plan = NULL)
[13:33:39.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.820]                 }
[13:33:39.820]                 ...future.workdir <- getwd()
[13:33:39.820]             }
[13:33:39.820]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.820]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.820]         }
[13:33:39.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.820]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.820]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.820]             base::names(...future.oldOptions))
[13:33:39.820]     }
[13:33:39.820]     if (FALSE) {
[13:33:39.820]     }
[13:33:39.820]     else {
[13:33:39.820]         if (TRUE) {
[13:33:39.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.820]                 open = "w")
[13:33:39.820]         }
[13:33:39.820]         else {
[13:33:39.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.820]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.820]         }
[13:33:39.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.820]             base::sink(type = "output", split = FALSE)
[13:33:39.820]             base::close(...future.stdout)
[13:33:39.820]         }, add = TRUE)
[13:33:39.820]     }
[13:33:39.820]     ...future.frame <- base::sys.nframe()
[13:33:39.820]     ...future.conditions <- base::list()
[13:33:39.820]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.820]     if (FALSE) {
[13:33:39.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.820]     }
[13:33:39.820]     ...future.result <- base::tryCatch({
[13:33:39.820]         base::withCallingHandlers({
[13:33:39.820]             ...future.value <- base::withVisible(base::local({
[13:33:39.820]                 ...future.makeSendCondition <- base::local({
[13:33:39.820]                   sendCondition <- NULL
[13:33:39.820]                   function(frame = 1L) {
[13:33:39.820]                     if (is.function(sendCondition)) 
[13:33:39.820]                       return(sendCondition)
[13:33:39.820]                     ns <- getNamespace("parallel")
[13:33:39.820]                     if (exists("sendData", mode = "function", 
[13:33:39.820]                       envir = ns)) {
[13:33:39.820]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.820]                         envir = ns)
[13:33:39.820]                       envir <- sys.frame(frame)
[13:33:39.820]                       master <- NULL
[13:33:39.820]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.820]                         !identical(envir, emptyenv())) {
[13:33:39.820]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.820]                           inherits = FALSE)) {
[13:33:39.820]                           master <- get("master", mode = "list", 
[13:33:39.820]                             envir = envir, inherits = FALSE)
[13:33:39.820]                           if (inherits(master, c("SOCKnode", 
[13:33:39.820]                             "SOCK0node"))) {
[13:33:39.820]                             sendCondition <<- function(cond) {
[13:33:39.820]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.820]                                 success = TRUE)
[13:33:39.820]                               parallel_sendData(master, data)
[13:33:39.820]                             }
[13:33:39.820]                             return(sendCondition)
[13:33:39.820]                           }
[13:33:39.820]                         }
[13:33:39.820]                         frame <- frame + 1L
[13:33:39.820]                         envir <- sys.frame(frame)
[13:33:39.820]                       }
[13:33:39.820]                     }
[13:33:39.820]                     sendCondition <<- function(cond) NULL
[13:33:39.820]                   }
[13:33:39.820]                 })
[13:33:39.820]                 withCallingHandlers({
[13:33:39.820]                   {
[13:33:39.820]                     do.call(function(...) {
[13:33:39.820]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.820]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.820]                         ...future.globals.maxSize)) {
[13:33:39.820]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.820]                         on.exit(options(oopts), add = TRUE)
[13:33:39.820]                       }
[13:33:39.820]                       {
[13:33:39.820]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.820]                           FUN = function(jj) {
[13:33:39.820]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.820]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.820]                           })
[13:33:39.820]                       }
[13:33:39.820]                     }, args = future.call.arguments)
[13:33:39.820]                   }
[13:33:39.820]                 }, immediateCondition = function(cond) {
[13:33:39.820]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.820]                   sendCondition(cond)
[13:33:39.820]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.820]                   {
[13:33:39.820]                     inherits <- base::inherits
[13:33:39.820]                     invokeRestart <- base::invokeRestart
[13:33:39.820]                     is.null <- base::is.null
[13:33:39.820]                     muffled <- FALSE
[13:33:39.820]                     if (inherits(cond, "message")) {
[13:33:39.820]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.820]                       if (muffled) 
[13:33:39.820]                         invokeRestart("muffleMessage")
[13:33:39.820]                     }
[13:33:39.820]                     else if (inherits(cond, "warning")) {
[13:33:39.820]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.820]                       if (muffled) 
[13:33:39.820]                         invokeRestart("muffleWarning")
[13:33:39.820]                     }
[13:33:39.820]                     else if (inherits(cond, "condition")) {
[13:33:39.820]                       if (!is.null(pattern)) {
[13:33:39.820]                         computeRestarts <- base::computeRestarts
[13:33:39.820]                         grepl <- base::grepl
[13:33:39.820]                         restarts <- computeRestarts(cond)
[13:33:39.820]                         for (restart in restarts) {
[13:33:39.820]                           name <- restart$name
[13:33:39.820]                           if (is.null(name)) 
[13:33:39.820]                             next
[13:33:39.820]                           if (!grepl(pattern, name)) 
[13:33:39.820]                             next
[13:33:39.820]                           invokeRestart(restart)
[13:33:39.820]                           muffled <- TRUE
[13:33:39.820]                           break
[13:33:39.820]                         }
[13:33:39.820]                       }
[13:33:39.820]                     }
[13:33:39.820]                     invisible(muffled)
[13:33:39.820]                   }
[13:33:39.820]                   muffleCondition(cond)
[13:33:39.820]                 })
[13:33:39.820]             }))
[13:33:39.820]             future::FutureResult(value = ...future.value$value, 
[13:33:39.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.820]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.820]                     ...future.globalenv.names))
[13:33:39.820]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.820]         }, condition = base::local({
[13:33:39.820]             c <- base::c
[13:33:39.820]             inherits <- base::inherits
[13:33:39.820]             invokeRestart <- base::invokeRestart
[13:33:39.820]             length <- base::length
[13:33:39.820]             list <- base::list
[13:33:39.820]             seq.int <- base::seq.int
[13:33:39.820]             signalCondition <- base::signalCondition
[13:33:39.820]             sys.calls <- base::sys.calls
[13:33:39.820]             `[[` <- base::`[[`
[13:33:39.820]             `+` <- base::`+`
[13:33:39.820]             `<<-` <- base::`<<-`
[13:33:39.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.820]                   3L)]
[13:33:39.820]             }
[13:33:39.820]             function(cond) {
[13:33:39.820]                 is_error <- inherits(cond, "error")
[13:33:39.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.820]                   NULL)
[13:33:39.820]                 if (is_error) {
[13:33:39.820]                   sessionInformation <- function() {
[13:33:39.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.820]                       search = base::search(), system = base::Sys.info())
[13:33:39.820]                   }
[13:33:39.820]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.820]                     cond$call), session = sessionInformation(), 
[13:33:39.820]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.820]                   signalCondition(cond)
[13:33:39.820]                 }
[13:33:39.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.820]                 "immediateCondition"))) {
[13:33:39.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.820]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.820]                   if (TRUE && !signal) {
[13:33:39.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.820]                     {
[13:33:39.820]                       inherits <- base::inherits
[13:33:39.820]                       invokeRestart <- base::invokeRestart
[13:33:39.820]                       is.null <- base::is.null
[13:33:39.820]                       muffled <- FALSE
[13:33:39.820]                       if (inherits(cond, "message")) {
[13:33:39.820]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.820]                         if (muffled) 
[13:33:39.820]                           invokeRestart("muffleMessage")
[13:33:39.820]                       }
[13:33:39.820]                       else if (inherits(cond, "warning")) {
[13:33:39.820]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.820]                         if (muffled) 
[13:33:39.820]                           invokeRestart("muffleWarning")
[13:33:39.820]                       }
[13:33:39.820]                       else if (inherits(cond, "condition")) {
[13:33:39.820]                         if (!is.null(pattern)) {
[13:33:39.820]                           computeRestarts <- base::computeRestarts
[13:33:39.820]                           grepl <- base::grepl
[13:33:39.820]                           restarts <- computeRestarts(cond)
[13:33:39.820]                           for (restart in restarts) {
[13:33:39.820]                             name <- restart$name
[13:33:39.820]                             if (is.null(name)) 
[13:33:39.820]                               next
[13:33:39.820]                             if (!grepl(pattern, name)) 
[13:33:39.820]                               next
[13:33:39.820]                             invokeRestart(restart)
[13:33:39.820]                             muffled <- TRUE
[13:33:39.820]                             break
[13:33:39.820]                           }
[13:33:39.820]                         }
[13:33:39.820]                       }
[13:33:39.820]                       invisible(muffled)
[13:33:39.820]                     }
[13:33:39.820]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.820]                   }
[13:33:39.820]                 }
[13:33:39.820]                 else {
[13:33:39.820]                   if (TRUE) {
[13:33:39.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.820]                     {
[13:33:39.820]                       inherits <- base::inherits
[13:33:39.820]                       invokeRestart <- base::invokeRestart
[13:33:39.820]                       is.null <- base::is.null
[13:33:39.820]                       muffled <- FALSE
[13:33:39.820]                       if (inherits(cond, "message")) {
[13:33:39.820]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.820]                         if (muffled) 
[13:33:39.820]                           invokeRestart("muffleMessage")
[13:33:39.820]                       }
[13:33:39.820]                       else if (inherits(cond, "warning")) {
[13:33:39.820]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.820]                         if (muffled) 
[13:33:39.820]                           invokeRestart("muffleWarning")
[13:33:39.820]                       }
[13:33:39.820]                       else if (inherits(cond, "condition")) {
[13:33:39.820]                         if (!is.null(pattern)) {
[13:33:39.820]                           computeRestarts <- base::computeRestarts
[13:33:39.820]                           grepl <- base::grepl
[13:33:39.820]                           restarts <- computeRestarts(cond)
[13:33:39.820]                           for (restart in restarts) {
[13:33:39.820]                             name <- restart$name
[13:33:39.820]                             if (is.null(name)) 
[13:33:39.820]                               next
[13:33:39.820]                             if (!grepl(pattern, name)) 
[13:33:39.820]                               next
[13:33:39.820]                             invokeRestart(restart)
[13:33:39.820]                             muffled <- TRUE
[13:33:39.820]                             break
[13:33:39.820]                           }
[13:33:39.820]                         }
[13:33:39.820]                       }
[13:33:39.820]                       invisible(muffled)
[13:33:39.820]                     }
[13:33:39.820]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.820]                   }
[13:33:39.820]                 }
[13:33:39.820]             }
[13:33:39.820]         }))
[13:33:39.820]     }, error = function(ex) {
[13:33:39.820]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.820]                 ...future.rng), started = ...future.startTime, 
[13:33:39.820]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.820]             version = "1.8"), class = "FutureResult")
[13:33:39.820]     }, finally = {
[13:33:39.820]         if (!identical(...future.workdir, getwd())) 
[13:33:39.820]             setwd(...future.workdir)
[13:33:39.820]         {
[13:33:39.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.820]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.820]             }
[13:33:39.820]             base::options(...future.oldOptions)
[13:33:39.820]             if (.Platform$OS.type == "windows") {
[13:33:39.820]                 old_names <- names(...future.oldEnvVars)
[13:33:39.820]                 envs <- base::Sys.getenv()
[13:33:39.820]                 names <- names(envs)
[13:33:39.820]                 common <- intersect(names, old_names)
[13:33:39.820]                 added <- setdiff(names, old_names)
[13:33:39.820]                 removed <- setdiff(old_names, names)
[13:33:39.820]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.820]                   envs[common]]
[13:33:39.820]                 NAMES <- toupper(changed)
[13:33:39.820]                 args <- list()
[13:33:39.820]                 for (kk in seq_along(NAMES)) {
[13:33:39.820]                   name <- changed[[kk]]
[13:33:39.820]                   NAME <- NAMES[[kk]]
[13:33:39.820]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.820]                     next
[13:33:39.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.820]                 }
[13:33:39.820]                 NAMES <- toupper(added)
[13:33:39.820]                 for (kk in seq_along(NAMES)) {
[13:33:39.820]                   name <- added[[kk]]
[13:33:39.820]                   NAME <- NAMES[[kk]]
[13:33:39.820]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.820]                     next
[13:33:39.820]                   args[[name]] <- ""
[13:33:39.820]                 }
[13:33:39.820]                 NAMES <- toupper(removed)
[13:33:39.820]                 for (kk in seq_along(NAMES)) {
[13:33:39.820]                   name <- removed[[kk]]
[13:33:39.820]                   NAME <- NAMES[[kk]]
[13:33:39.820]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.820]                     next
[13:33:39.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.820]                 }
[13:33:39.820]                 if (length(args) > 0) 
[13:33:39.820]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.820]             }
[13:33:39.820]             else {
[13:33:39.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.820]             }
[13:33:39.820]             {
[13:33:39.820]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.820]                   0L) {
[13:33:39.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.820]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.820]                   base::options(opts)
[13:33:39.820]                 }
[13:33:39.820]                 {
[13:33:39.820]                   {
[13:33:39.820]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.820]                     NULL
[13:33:39.820]                   }
[13:33:39.820]                   options(future.plan = NULL)
[13:33:39.820]                   if (is.na(NA_character_)) 
[13:33:39.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.820]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.820]                     .init = FALSE)
[13:33:39.820]                 }
[13:33:39.820]             }
[13:33:39.820]         }
[13:33:39.820]     })
[13:33:39.820]     if (TRUE) {
[13:33:39.820]         base::sink(type = "output", split = FALSE)
[13:33:39.820]         if (TRUE) {
[13:33:39.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.820]         }
[13:33:39.820]         else {
[13:33:39.820]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.820]         }
[13:33:39.820]         base::close(...future.stdout)
[13:33:39.820]         ...future.stdout <- NULL
[13:33:39.820]     }
[13:33:39.820]     ...future.result$conditions <- ...future.conditions
[13:33:39.820]     ...future.result$finished <- base::Sys.time()
[13:33:39.820]     ...future.result
[13:33:39.820] }
[13:33:39.823] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[13:33:39.823] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:39.823] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.823] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:33:39.824] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:33:39.824] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[13:33:39.824] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[13:33:39.825] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:39.825] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.825] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:39.825] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:39.825] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[13:33:39.826] MultisessionFuture started
[13:33:39.826] - Launch lazy future ... done
[13:33:39.826] run() for ‘MultisessionFuture’ ... done
[13:33:39.826] Created future:
[13:33:39.827] MultisessionFuture:
[13:33:39.827] Label: ‘future_apply-1’
[13:33:39.827] Expression:
[13:33:39.827] {
[13:33:39.827]     do.call(function(...) {
[13:33:39.827]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.827]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.827]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.827]             on.exit(options(oopts), add = TRUE)
[13:33:39.827]         }
[13:33:39.827]         {
[13:33:39.827]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.827]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.827]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.827]             })
[13:33:39.827]         }
[13:33:39.827]     }, args = future.call.arguments)
[13:33:39.827] }
[13:33:39.827] Lazy evaluation: FALSE
[13:33:39.827] Asynchronous evaluation: TRUE
[13:33:39.827] Local evaluation: TRUE
[13:33:39.827] Environment: R_GlobalEnv
[13:33:39.827] Capture standard output: TRUE
[13:33:39.827] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.827] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.827] Packages: <none>
[13:33:39.827] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.827] Resolved: FALSE
[13:33:39.827] Value: <not collected>
[13:33:39.827] Conditions captured: <none>
[13:33:39.827] Early signaling: FALSE
[13:33:39.827] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.827] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.838] Chunk #1 of 2 ... DONE
[13:33:39.838] Chunk #2 of 2 ...
[13:33:39.838]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.839]  - seeds: <none>
[13:33:39.839]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.839] getGlobalsAndPackages() ...
[13:33:39.839] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.839] Resolving globals: FALSE
[13:33:39.839] Tweak future expression to call with '...' arguments ...
[13:33:39.839] {
[13:33:39.839]     do.call(function(...) {
[13:33:39.839]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.839]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.839]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.839]             on.exit(options(oopts), add = TRUE)
[13:33:39.839]         }
[13:33:39.839]         {
[13:33:39.839]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.839]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.839]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.839]             })
[13:33:39.839]         }
[13:33:39.839]     }, args = future.call.arguments)
[13:33:39.839] }
[13:33:39.840] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.840] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.840] 
[13:33:39.840] getGlobalsAndPackages() ... DONE
[13:33:39.840] run() for ‘Future’ ...
[13:33:39.840] - state: ‘created’
[13:33:39.841] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.854] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.854] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.855]   - Field: ‘node’
[13:33:39.855]   - Field: ‘label’
[13:33:39.855]   - Field: ‘local’
[13:33:39.855]   - Field: ‘owner’
[13:33:39.855]   - Field: ‘envir’
[13:33:39.855]   - Field: ‘workers’
[13:33:39.855]   - Field: ‘packages’
[13:33:39.855]   - Field: ‘gc’
[13:33:39.855]   - Field: ‘conditions’
[13:33:39.855]   - Field: ‘persistent’
[13:33:39.856]   - Field: ‘expr’
[13:33:39.856]   - Field: ‘uuid’
[13:33:39.856]   - Field: ‘seed’
[13:33:39.856]   - Field: ‘version’
[13:33:39.856]   - Field: ‘result’
[13:33:39.856]   - Field: ‘asynchronous’
[13:33:39.856]   - Field: ‘calls’
[13:33:39.856]   - Field: ‘globals’
[13:33:39.856]   - Field: ‘stdout’
[13:33:39.856]   - Field: ‘earlySignal’
[13:33:39.856]   - Field: ‘lazy’
[13:33:39.857]   - Field: ‘state’
[13:33:39.857] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.857] - Launch lazy future ...
[13:33:39.857] Packages needed by the future expression (n = 0): <none>
[13:33:39.857] Packages needed by future strategies (n = 0): <none>
[13:33:39.858] {
[13:33:39.858]     {
[13:33:39.858]         {
[13:33:39.858]             ...future.startTime <- base::Sys.time()
[13:33:39.858]             {
[13:33:39.858]                 {
[13:33:39.858]                   {
[13:33:39.858]                     {
[13:33:39.858]                       base::local({
[13:33:39.858]                         has_future <- base::requireNamespace("future", 
[13:33:39.858]                           quietly = TRUE)
[13:33:39.858]                         if (has_future) {
[13:33:39.858]                           ns <- base::getNamespace("future")
[13:33:39.858]                           version <- ns[[".package"]][["version"]]
[13:33:39.858]                           if (is.null(version)) 
[13:33:39.858]                             version <- utils::packageVersion("future")
[13:33:39.858]                         }
[13:33:39.858]                         else {
[13:33:39.858]                           version <- NULL
[13:33:39.858]                         }
[13:33:39.858]                         if (!has_future || version < "1.8.0") {
[13:33:39.858]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.858]                             "", base::R.version$version.string), 
[13:33:39.858]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.858]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.858]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.858]                               "release", "version")], collapse = " "), 
[13:33:39.858]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.858]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.858]                             info)
[13:33:39.858]                           info <- base::paste(info, collapse = "; ")
[13:33:39.858]                           if (!has_future) {
[13:33:39.858]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.858]                               info)
[13:33:39.858]                           }
[13:33:39.858]                           else {
[13:33:39.858]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.858]                               info, version)
[13:33:39.858]                           }
[13:33:39.858]                           base::stop(msg)
[13:33:39.858]                         }
[13:33:39.858]                       })
[13:33:39.858]                     }
[13:33:39.858]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.858]                     base::options(mc.cores = 1L)
[13:33:39.858]                   }
[13:33:39.858]                   ...future.strategy.old <- future::plan("list")
[13:33:39.858]                   options(future.plan = NULL)
[13:33:39.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.858]                 }
[13:33:39.858]                 ...future.workdir <- getwd()
[13:33:39.858]             }
[13:33:39.858]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.858]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.858]         }
[13:33:39.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.858]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.858]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.858]             base::names(...future.oldOptions))
[13:33:39.858]     }
[13:33:39.858]     if (FALSE) {
[13:33:39.858]     }
[13:33:39.858]     else {
[13:33:39.858]         if (TRUE) {
[13:33:39.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.858]                 open = "w")
[13:33:39.858]         }
[13:33:39.858]         else {
[13:33:39.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.858]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.858]         }
[13:33:39.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.858]             base::sink(type = "output", split = FALSE)
[13:33:39.858]             base::close(...future.stdout)
[13:33:39.858]         }, add = TRUE)
[13:33:39.858]     }
[13:33:39.858]     ...future.frame <- base::sys.nframe()
[13:33:39.858]     ...future.conditions <- base::list()
[13:33:39.858]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.858]     if (FALSE) {
[13:33:39.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.858]     }
[13:33:39.858]     ...future.result <- base::tryCatch({
[13:33:39.858]         base::withCallingHandlers({
[13:33:39.858]             ...future.value <- base::withVisible(base::local({
[13:33:39.858]                 ...future.makeSendCondition <- base::local({
[13:33:39.858]                   sendCondition <- NULL
[13:33:39.858]                   function(frame = 1L) {
[13:33:39.858]                     if (is.function(sendCondition)) 
[13:33:39.858]                       return(sendCondition)
[13:33:39.858]                     ns <- getNamespace("parallel")
[13:33:39.858]                     if (exists("sendData", mode = "function", 
[13:33:39.858]                       envir = ns)) {
[13:33:39.858]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.858]                         envir = ns)
[13:33:39.858]                       envir <- sys.frame(frame)
[13:33:39.858]                       master <- NULL
[13:33:39.858]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.858]                         !identical(envir, emptyenv())) {
[13:33:39.858]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.858]                           inherits = FALSE)) {
[13:33:39.858]                           master <- get("master", mode = "list", 
[13:33:39.858]                             envir = envir, inherits = FALSE)
[13:33:39.858]                           if (inherits(master, c("SOCKnode", 
[13:33:39.858]                             "SOCK0node"))) {
[13:33:39.858]                             sendCondition <<- function(cond) {
[13:33:39.858]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.858]                                 success = TRUE)
[13:33:39.858]                               parallel_sendData(master, data)
[13:33:39.858]                             }
[13:33:39.858]                             return(sendCondition)
[13:33:39.858]                           }
[13:33:39.858]                         }
[13:33:39.858]                         frame <- frame + 1L
[13:33:39.858]                         envir <- sys.frame(frame)
[13:33:39.858]                       }
[13:33:39.858]                     }
[13:33:39.858]                     sendCondition <<- function(cond) NULL
[13:33:39.858]                   }
[13:33:39.858]                 })
[13:33:39.858]                 withCallingHandlers({
[13:33:39.858]                   {
[13:33:39.858]                     do.call(function(...) {
[13:33:39.858]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.858]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.858]                         ...future.globals.maxSize)) {
[13:33:39.858]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.858]                         on.exit(options(oopts), add = TRUE)
[13:33:39.858]                       }
[13:33:39.858]                       {
[13:33:39.858]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.858]                           FUN = function(jj) {
[13:33:39.858]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.858]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.858]                           })
[13:33:39.858]                       }
[13:33:39.858]                     }, args = future.call.arguments)
[13:33:39.858]                   }
[13:33:39.858]                 }, immediateCondition = function(cond) {
[13:33:39.858]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.858]                   sendCondition(cond)
[13:33:39.858]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.858]                   {
[13:33:39.858]                     inherits <- base::inherits
[13:33:39.858]                     invokeRestart <- base::invokeRestart
[13:33:39.858]                     is.null <- base::is.null
[13:33:39.858]                     muffled <- FALSE
[13:33:39.858]                     if (inherits(cond, "message")) {
[13:33:39.858]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.858]                       if (muffled) 
[13:33:39.858]                         invokeRestart("muffleMessage")
[13:33:39.858]                     }
[13:33:39.858]                     else if (inherits(cond, "warning")) {
[13:33:39.858]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.858]                       if (muffled) 
[13:33:39.858]                         invokeRestart("muffleWarning")
[13:33:39.858]                     }
[13:33:39.858]                     else if (inherits(cond, "condition")) {
[13:33:39.858]                       if (!is.null(pattern)) {
[13:33:39.858]                         computeRestarts <- base::computeRestarts
[13:33:39.858]                         grepl <- base::grepl
[13:33:39.858]                         restarts <- computeRestarts(cond)
[13:33:39.858]                         for (restart in restarts) {
[13:33:39.858]                           name <- restart$name
[13:33:39.858]                           if (is.null(name)) 
[13:33:39.858]                             next
[13:33:39.858]                           if (!grepl(pattern, name)) 
[13:33:39.858]                             next
[13:33:39.858]                           invokeRestart(restart)
[13:33:39.858]                           muffled <- TRUE
[13:33:39.858]                           break
[13:33:39.858]                         }
[13:33:39.858]                       }
[13:33:39.858]                     }
[13:33:39.858]                     invisible(muffled)
[13:33:39.858]                   }
[13:33:39.858]                   muffleCondition(cond)
[13:33:39.858]                 })
[13:33:39.858]             }))
[13:33:39.858]             future::FutureResult(value = ...future.value$value, 
[13:33:39.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.858]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.858]                     ...future.globalenv.names))
[13:33:39.858]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.858]         }, condition = base::local({
[13:33:39.858]             c <- base::c
[13:33:39.858]             inherits <- base::inherits
[13:33:39.858]             invokeRestart <- base::invokeRestart
[13:33:39.858]             length <- base::length
[13:33:39.858]             list <- base::list
[13:33:39.858]             seq.int <- base::seq.int
[13:33:39.858]             signalCondition <- base::signalCondition
[13:33:39.858]             sys.calls <- base::sys.calls
[13:33:39.858]             `[[` <- base::`[[`
[13:33:39.858]             `+` <- base::`+`
[13:33:39.858]             `<<-` <- base::`<<-`
[13:33:39.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.858]                   3L)]
[13:33:39.858]             }
[13:33:39.858]             function(cond) {
[13:33:39.858]                 is_error <- inherits(cond, "error")
[13:33:39.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.858]                   NULL)
[13:33:39.858]                 if (is_error) {
[13:33:39.858]                   sessionInformation <- function() {
[13:33:39.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.858]                       search = base::search(), system = base::Sys.info())
[13:33:39.858]                   }
[13:33:39.858]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.858]                     cond$call), session = sessionInformation(), 
[13:33:39.858]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.858]                   signalCondition(cond)
[13:33:39.858]                 }
[13:33:39.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.858]                 "immediateCondition"))) {
[13:33:39.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.858]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.858]                   if (TRUE && !signal) {
[13:33:39.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.858]                     {
[13:33:39.858]                       inherits <- base::inherits
[13:33:39.858]                       invokeRestart <- base::invokeRestart
[13:33:39.858]                       is.null <- base::is.null
[13:33:39.858]                       muffled <- FALSE
[13:33:39.858]                       if (inherits(cond, "message")) {
[13:33:39.858]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.858]                         if (muffled) 
[13:33:39.858]                           invokeRestart("muffleMessage")
[13:33:39.858]                       }
[13:33:39.858]                       else if (inherits(cond, "warning")) {
[13:33:39.858]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.858]                         if (muffled) 
[13:33:39.858]                           invokeRestart("muffleWarning")
[13:33:39.858]                       }
[13:33:39.858]                       else if (inherits(cond, "condition")) {
[13:33:39.858]                         if (!is.null(pattern)) {
[13:33:39.858]                           computeRestarts <- base::computeRestarts
[13:33:39.858]                           grepl <- base::grepl
[13:33:39.858]                           restarts <- computeRestarts(cond)
[13:33:39.858]                           for (restart in restarts) {
[13:33:39.858]                             name <- restart$name
[13:33:39.858]                             if (is.null(name)) 
[13:33:39.858]                               next
[13:33:39.858]                             if (!grepl(pattern, name)) 
[13:33:39.858]                               next
[13:33:39.858]                             invokeRestart(restart)
[13:33:39.858]                             muffled <- TRUE
[13:33:39.858]                             break
[13:33:39.858]                           }
[13:33:39.858]                         }
[13:33:39.858]                       }
[13:33:39.858]                       invisible(muffled)
[13:33:39.858]                     }
[13:33:39.858]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.858]                   }
[13:33:39.858]                 }
[13:33:39.858]                 else {
[13:33:39.858]                   if (TRUE) {
[13:33:39.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.858]                     {
[13:33:39.858]                       inherits <- base::inherits
[13:33:39.858]                       invokeRestart <- base::invokeRestart
[13:33:39.858]                       is.null <- base::is.null
[13:33:39.858]                       muffled <- FALSE
[13:33:39.858]                       if (inherits(cond, "message")) {
[13:33:39.858]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.858]                         if (muffled) 
[13:33:39.858]                           invokeRestart("muffleMessage")
[13:33:39.858]                       }
[13:33:39.858]                       else if (inherits(cond, "warning")) {
[13:33:39.858]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.858]                         if (muffled) 
[13:33:39.858]                           invokeRestart("muffleWarning")
[13:33:39.858]                       }
[13:33:39.858]                       else if (inherits(cond, "condition")) {
[13:33:39.858]                         if (!is.null(pattern)) {
[13:33:39.858]                           computeRestarts <- base::computeRestarts
[13:33:39.858]                           grepl <- base::grepl
[13:33:39.858]                           restarts <- computeRestarts(cond)
[13:33:39.858]                           for (restart in restarts) {
[13:33:39.858]                             name <- restart$name
[13:33:39.858]                             if (is.null(name)) 
[13:33:39.858]                               next
[13:33:39.858]                             if (!grepl(pattern, name)) 
[13:33:39.858]                               next
[13:33:39.858]                             invokeRestart(restart)
[13:33:39.858]                             muffled <- TRUE
[13:33:39.858]                             break
[13:33:39.858]                           }
[13:33:39.858]                         }
[13:33:39.858]                       }
[13:33:39.858]                       invisible(muffled)
[13:33:39.858]                     }
[13:33:39.858]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.858]                   }
[13:33:39.858]                 }
[13:33:39.858]             }
[13:33:39.858]         }))
[13:33:39.858]     }, error = function(ex) {
[13:33:39.858]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.858]                 ...future.rng), started = ...future.startTime, 
[13:33:39.858]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.858]             version = "1.8"), class = "FutureResult")
[13:33:39.858]     }, finally = {
[13:33:39.858]         if (!identical(...future.workdir, getwd())) 
[13:33:39.858]             setwd(...future.workdir)
[13:33:39.858]         {
[13:33:39.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.858]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.858]             }
[13:33:39.858]             base::options(...future.oldOptions)
[13:33:39.858]             if (.Platform$OS.type == "windows") {
[13:33:39.858]                 old_names <- names(...future.oldEnvVars)
[13:33:39.858]                 envs <- base::Sys.getenv()
[13:33:39.858]                 names <- names(envs)
[13:33:39.858]                 common <- intersect(names, old_names)
[13:33:39.858]                 added <- setdiff(names, old_names)
[13:33:39.858]                 removed <- setdiff(old_names, names)
[13:33:39.858]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.858]                   envs[common]]
[13:33:39.858]                 NAMES <- toupper(changed)
[13:33:39.858]                 args <- list()
[13:33:39.858]                 for (kk in seq_along(NAMES)) {
[13:33:39.858]                   name <- changed[[kk]]
[13:33:39.858]                   NAME <- NAMES[[kk]]
[13:33:39.858]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.858]                     next
[13:33:39.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.858]                 }
[13:33:39.858]                 NAMES <- toupper(added)
[13:33:39.858]                 for (kk in seq_along(NAMES)) {
[13:33:39.858]                   name <- added[[kk]]
[13:33:39.858]                   NAME <- NAMES[[kk]]
[13:33:39.858]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.858]                     next
[13:33:39.858]                   args[[name]] <- ""
[13:33:39.858]                 }
[13:33:39.858]                 NAMES <- toupper(removed)
[13:33:39.858]                 for (kk in seq_along(NAMES)) {
[13:33:39.858]                   name <- removed[[kk]]
[13:33:39.858]                   NAME <- NAMES[[kk]]
[13:33:39.858]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.858]                     next
[13:33:39.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.858]                 }
[13:33:39.858]                 if (length(args) > 0) 
[13:33:39.858]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.858]             }
[13:33:39.858]             else {
[13:33:39.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.858]             }
[13:33:39.858]             {
[13:33:39.858]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.858]                   0L) {
[13:33:39.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.858]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.858]                   base::options(opts)
[13:33:39.858]                 }
[13:33:39.858]                 {
[13:33:39.858]                   {
[13:33:39.858]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.858]                     NULL
[13:33:39.858]                   }
[13:33:39.858]                   options(future.plan = NULL)
[13:33:39.858]                   if (is.na(NA_character_)) 
[13:33:39.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.858]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.858]                     .init = FALSE)
[13:33:39.858]                 }
[13:33:39.858]             }
[13:33:39.858]         }
[13:33:39.858]     })
[13:33:39.858]     if (TRUE) {
[13:33:39.858]         base::sink(type = "output", split = FALSE)
[13:33:39.858]         if (TRUE) {
[13:33:39.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.858]         }
[13:33:39.858]         else {
[13:33:39.858]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.858]         }
[13:33:39.858]         base::close(...future.stdout)
[13:33:39.858]         ...future.stdout <- NULL
[13:33:39.858]     }
[13:33:39.858]     ...future.result$conditions <- ...future.conditions
[13:33:39.858]     ...future.result$finished <- base::Sys.time()
[13:33:39.858]     ...future.result
[13:33:39.858] }
[13:33:39.860] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[13:33:39.861] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:39.861] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.861] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:33:39.861] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:33:39.861] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[13:33:39.862] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[13:33:39.862] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:39.862] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:39.862] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:33:39.863] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:33:39.863] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[13:33:39.863] MultisessionFuture started
[13:33:39.863] - Launch lazy future ... done
[13:33:39.863] run() for ‘MultisessionFuture’ ... done
[13:33:39.864] Created future:
[13:33:39.864] MultisessionFuture:
[13:33:39.864] Label: ‘future_apply-2’
[13:33:39.864] Expression:
[13:33:39.864] {
[13:33:39.864]     do.call(function(...) {
[13:33:39.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.864]             on.exit(options(oopts), add = TRUE)
[13:33:39.864]         }
[13:33:39.864]         {
[13:33:39.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.864]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.864]             })
[13:33:39.864]         }
[13:33:39.864]     }, args = future.call.arguments)
[13:33:39.864] }
[13:33:39.864] Lazy evaluation: FALSE
[13:33:39.864] Asynchronous evaluation: TRUE
[13:33:39.864] Local evaluation: TRUE
[13:33:39.864] Environment: R_GlobalEnv
[13:33:39.864] Capture standard output: TRUE
[13:33:39.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.864] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.864] Packages: <none>
[13:33:39.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.864] Resolved: FALSE
[13:33:39.864] Value: <not collected>
[13:33:39.864] Conditions captured: <none>
[13:33:39.864] Early signaling: FALSE
[13:33:39.864] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.864] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.875] Chunk #2 of 2 ... DONE
[13:33:39.875] Launching 2 futures (chunks) ... DONE
[13:33:39.875] Resolving 2 futures (chunks) ...
[13:33:39.875] resolve() on list ...
[13:33:39.875]  recursive: 0
[13:33:39.876]  length: 2
[13:33:39.876] 
[13:33:39.876] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.876] - Validating connection of MultisessionFuture
[13:33:39.876] - received message: FutureResult
[13:33:39.877] - Received FutureResult
[13:33:39.877] - Erased future from FutureRegistry
[13:33:39.877] result() for ClusterFuture ...
[13:33:39.877] - result already collected: FutureResult
[13:33:39.877] result() for ClusterFuture ... done
[13:33:39.877] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.877] Future #1
[13:33:39.877] result() for ClusterFuture ...
[13:33:39.877] - result already collected: FutureResult
[13:33:39.877] result() for ClusterFuture ... done
[13:33:39.877] result() for ClusterFuture ...
[13:33:39.878] - result already collected: FutureResult
[13:33:39.878] result() for ClusterFuture ... done
[13:33:39.878] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:39.878] - nx: 2
[13:33:39.878] - relay: TRUE
[13:33:39.878] - stdout: TRUE
[13:33:39.878] - signal: TRUE
[13:33:39.878] - resignal: FALSE
[13:33:39.878] - force: TRUE
[13:33:39.878] - relayed: [n=2] FALSE, FALSE
[13:33:39.878] - queued futures: [n=2] FALSE, FALSE
[13:33:39.879]  - until=1
[13:33:39.879]  - relaying element #1
[13:33:39.879] result() for ClusterFuture ...
[13:33:39.879] - result already collected: FutureResult
[13:33:39.879] result() for ClusterFuture ... done
[13:33:39.879] result() for ClusterFuture ...
[13:33:39.879] - result already collected: FutureResult
[13:33:39.879] result() for ClusterFuture ... done
[13:33:39.879] result() for ClusterFuture ...
[13:33:39.879] - result already collected: FutureResult
[13:33:39.879] result() for ClusterFuture ... done
[13:33:39.879] result() for ClusterFuture ...
[13:33:39.880] - result already collected: FutureResult
[13:33:39.880] result() for ClusterFuture ... done
[13:33:39.880] - relayed: [n=2] TRUE, FALSE
[13:33:39.880] - queued futures: [n=2] TRUE, FALSE
[13:33:39.880] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:39.880]  length: 1 (resolved future 1)
[13:33:39.908] receiveMessageFromWorker() for ClusterFuture ...
[13:33:39.908] - Validating connection of MultisessionFuture
[13:33:39.908] - received message: FutureResult
[13:33:39.908] - Received FutureResult
[13:33:39.908] - Erased future from FutureRegistry
[13:33:39.909] result() for ClusterFuture ...
[13:33:39.909] - result already collected: FutureResult
[13:33:39.909] result() for ClusterFuture ... done
[13:33:39.909] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:39.909] Future #2
[13:33:39.909] result() for ClusterFuture ...
[13:33:39.909] - result already collected: FutureResult
[13:33:39.909] result() for ClusterFuture ... done
[13:33:39.909] result() for ClusterFuture ...
[13:33:39.909] - result already collected: FutureResult
[13:33:39.909] result() for ClusterFuture ... done
[13:33:39.910] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:39.910] - nx: 2
[13:33:39.910] - relay: TRUE
[13:33:39.910] - stdout: TRUE
[13:33:39.910] - signal: TRUE
[13:33:39.910] - resignal: FALSE
[13:33:39.910] - force: TRUE
[13:33:39.910] - relayed: [n=2] TRUE, FALSE
[13:33:39.910] - queued futures: [n=2] TRUE, FALSE
[13:33:39.910]  - until=2
[13:33:39.910]  - relaying element #2
[13:33:39.911] result() for ClusterFuture ...
[13:33:39.911] - result already collected: FutureResult
[13:33:39.911] result() for ClusterFuture ... done
[13:33:39.911] result() for ClusterFuture ...
[13:33:39.911] - result already collected: FutureResult
[13:33:39.911] result() for ClusterFuture ... done
[13:33:39.911] result() for ClusterFuture ...
[13:33:39.911] - result already collected: FutureResult
[13:33:39.911] result() for ClusterFuture ... done
[13:33:39.911] result() for ClusterFuture ...
[13:33:39.911] - result already collected: FutureResult
[13:33:39.912] result() for ClusterFuture ... done
[13:33:39.912] - relayed: [n=2] TRUE, TRUE
[13:33:39.912] - queued futures: [n=2] TRUE, TRUE
[13:33:39.912] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:39.912]  length: 0 (resolved future 2)
[13:33:39.912] Relaying remaining futures
[13:33:39.912] signalConditionsASAP(NULL, pos=0) ...
[13:33:39.912] - nx: 2
[13:33:39.912] - relay: TRUE
[13:33:39.912] - stdout: TRUE
[13:33:39.912] - signal: TRUE
[13:33:39.913] - resignal: FALSE
[13:33:39.913] - force: TRUE
[13:33:39.913] - relayed: [n=2] TRUE, TRUE
[13:33:39.913] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:39.913] - relayed: [n=2] TRUE, TRUE
[13:33:39.913] - queued futures: [n=2] TRUE, TRUE
[13:33:39.913] signalConditionsASAP(NULL, pos=0) ... done
[13:33:39.913] resolve() on list ... DONE
[13:33:39.913] result() for ClusterFuture ...
[13:33:39.913] - result already collected: FutureResult
[13:33:39.913] result() for ClusterFuture ... done
[13:33:39.914] result() for ClusterFuture ...
[13:33:39.914] - result already collected: FutureResult
[13:33:39.914] result() for ClusterFuture ... done
[13:33:39.914] result() for ClusterFuture ...
[13:33:39.914] - result already collected: FutureResult
[13:33:39.914] result() for ClusterFuture ... done
[13:33:39.914] result() for ClusterFuture ...
[13:33:39.914] - result already collected: FutureResult
[13:33:39.914] result() for ClusterFuture ... done
[13:33:39.914]  - Number of value chunks collected: 2
[13:33:39.914] Resolving 2 futures (chunks) ... DONE
[13:33:39.915] Reducing values from 2 chunks ...
[13:33:39.915]  - Number of values collected after concatenation: 2
[13:33:39.915]  - Number of values expected: 2
[13:33:39.915] Reducing values from 2 chunks ... DONE
[13:33:39.915] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[13:33:39.915] getGlobalsAndPackagesXApply() ...
[13:33:39.915]  - future.globals: TRUE
[13:33:39.915] getGlobalsAndPackages() ...
[13:33:39.916] Searching for globals...
[13:33:39.918] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[13:33:39.918] Searching for globals ... DONE
[13:33:39.918] Resolving globals: FALSE
[13:33:39.919] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[13:33:39.919] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[13:33:39.919] - globals: [1] ‘FUN’
[13:33:39.919] 
[13:33:39.919] getGlobalsAndPackages() ... DONE
[13:33:39.919]  - globals found/used: [n=1] ‘FUN’
[13:33:39.919]  - needed namespaces: [n=0] 
[13:33:39.920] Finding globals ... DONE
[13:33:39.920]  - use_args: TRUE
[13:33:39.920]  - Getting '...' globals ...
[13:33:39.920] resolve() on list ...
[13:33:39.920]  recursive: 0
[13:33:39.920]  length: 1
[13:33:39.920]  elements: ‘...’
[13:33:39.920]  length: 0 (resolved future 1)
[13:33:39.921] resolve() on list ... DONE
[13:33:39.921]    - '...' content: [n=0] 
[13:33:39.921] List of 1
[13:33:39.921]  $ ...: list()
[13:33:39.921]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.921]  - attr(*, "where")=List of 1
[13:33:39.921]   ..$ ...:<environment: 0x55b94b471950> 
[13:33:39.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.921]  - attr(*, "resolved")= logi TRUE
[13:33:39.921]  - attr(*, "total_size")= num NA
[13:33:39.923]  - Getting '...' globals ... DONE
[13:33:39.923] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:39.923] List of 2
[13:33:39.923]  $ ...future.FUN:function (x)  
[13:33:39.923]  $ ...          : list()
[13:33:39.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.923]  - attr(*, "where")=List of 2
[13:33:39.923]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:39.923]   ..$ ...          :<environment: 0x55b94b471950> 
[13:33:39.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.923]  - attr(*, "resolved")= logi FALSE
[13:33:39.923]  - attr(*, "total_size")= num 9888
[13:33:39.926] Packages to be attached in all futures: [n=0] 
[13:33:39.926] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.930] future_lapply() ...
[13:33:39.934] Number of chunks: 2
[13:33:39.934] getGlobalsAndPackagesXApply() ...
[13:33:39.934]  - future.globals: <name-value list> with names ‘list()’
[13:33:39.934]  - use_args: TRUE
[13:33:39.934] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:39.935] List of 2
[13:33:39.935]  $ ...          : list()
[13:33:39.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:39.935]  $ ...future.FUN:function (x)  
[13:33:39.935]  - attr(*, "where")=List of 2
[13:33:39.935]   ..$ ...          :<environment: 0x55b94b471950> 
[13:33:39.935]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:33:39.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:39.935]  - attr(*, "resolved")= logi FALSE
[13:33:39.935]  - attr(*, "total_size")= num NA
[13:33:39.937] Packages to be attached in all futures: [n=0] 
[13:33:39.937] getGlobalsAndPackagesXApply() ... DONE
[13:33:39.937] Number of futures (= number of chunks): 2
[13:33:39.938] Launching 2 futures (chunks) ...
[13:33:39.938] Chunk #1 of 2 ...
[13:33:39.938]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.938]  - seeds: <none>
[13:33:39.938]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.938] getGlobalsAndPackages() ...
[13:33:39.938] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.938] Resolving globals: FALSE
[13:33:39.938] Tweak future expression to call with '...' arguments ...
[13:33:39.939] {
[13:33:39.939]     do.call(function(...) {
[13:33:39.939]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.939]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.939]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.939]             on.exit(options(oopts), add = TRUE)
[13:33:39.939]         }
[13:33:39.939]         {
[13:33:39.939]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.939]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.939]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.939]             })
[13:33:39.939]         }
[13:33:39.939]     }, args = future.call.arguments)
[13:33:39.939] }
[13:33:39.939] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.939] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.939] 
[13:33:39.939] getGlobalsAndPackages() ... DONE
[13:33:39.940] run() for ‘Future’ ...
[13:33:39.940] - state: ‘created’
[13:33:39.940] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.953] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.954]   - Field: ‘node’
[13:33:39.954]   - Field: ‘label’
[13:33:39.954]   - Field: ‘local’
[13:33:39.954]   - Field: ‘owner’
[13:33:39.954]   - Field: ‘envir’
[13:33:39.954]   - Field: ‘workers’
[13:33:39.954]   - Field: ‘packages’
[13:33:39.954]   - Field: ‘gc’
[13:33:39.955]   - Field: ‘conditions’
[13:33:39.955]   - Field: ‘persistent’
[13:33:39.955]   - Field: ‘expr’
[13:33:39.955]   - Field: ‘uuid’
[13:33:39.955]   - Field: ‘seed’
[13:33:39.955]   - Field: ‘version’
[13:33:39.955]   - Field: ‘result’
[13:33:39.955]   - Field: ‘asynchronous’
[13:33:39.955]   - Field: ‘calls’
[13:33:39.955]   - Field: ‘globals’
[13:33:39.955]   - Field: ‘stdout’
[13:33:39.956]   - Field: ‘earlySignal’
[13:33:39.956]   - Field: ‘lazy’
[13:33:39.956]   - Field: ‘state’
[13:33:39.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.956] - Launch lazy future ...
[13:33:39.956] Packages needed by the future expression (n = 0): <none>
[13:33:39.956] Packages needed by future strategies (n = 0): <none>
[13:33:39.957] {
[13:33:39.957]     {
[13:33:39.957]         {
[13:33:39.957]             ...future.startTime <- base::Sys.time()
[13:33:39.957]             {
[13:33:39.957]                 {
[13:33:39.957]                   {
[13:33:39.957]                     {
[13:33:39.957]                       base::local({
[13:33:39.957]                         has_future <- base::requireNamespace("future", 
[13:33:39.957]                           quietly = TRUE)
[13:33:39.957]                         if (has_future) {
[13:33:39.957]                           ns <- base::getNamespace("future")
[13:33:39.957]                           version <- ns[[".package"]][["version"]]
[13:33:39.957]                           if (is.null(version)) 
[13:33:39.957]                             version <- utils::packageVersion("future")
[13:33:39.957]                         }
[13:33:39.957]                         else {
[13:33:39.957]                           version <- NULL
[13:33:39.957]                         }
[13:33:39.957]                         if (!has_future || version < "1.8.0") {
[13:33:39.957]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.957]                             "", base::R.version$version.string), 
[13:33:39.957]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.957]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.957]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.957]                               "release", "version")], collapse = " "), 
[13:33:39.957]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.957]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.957]                             info)
[13:33:39.957]                           info <- base::paste(info, collapse = "; ")
[13:33:39.957]                           if (!has_future) {
[13:33:39.957]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.957]                               info)
[13:33:39.957]                           }
[13:33:39.957]                           else {
[13:33:39.957]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.957]                               info, version)
[13:33:39.957]                           }
[13:33:39.957]                           base::stop(msg)
[13:33:39.957]                         }
[13:33:39.957]                       })
[13:33:39.957]                     }
[13:33:39.957]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.957]                     base::options(mc.cores = 1L)
[13:33:39.957]                   }
[13:33:39.957]                   ...future.strategy.old <- future::plan("list")
[13:33:39.957]                   options(future.plan = NULL)
[13:33:39.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.957]                 }
[13:33:39.957]                 ...future.workdir <- getwd()
[13:33:39.957]             }
[13:33:39.957]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.957]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.957]         }
[13:33:39.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.957]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.957]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.957]             base::names(...future.oldOptions))
[13:33:39.957]     }
[13:33:39.957]     if (FALSE) {
[13:33:39.957]     }
[13:33:39.957]     else {
[13:33:39.957]         if (TRUE) {
[13:33:39.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.957]                 open = "w")
[13:33:39.957]         }
[13:33:39.957]         else {
[13:33:39.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.957]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.957]         }
[13:33:39.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.957]             base::sink(type = "output", split = FALSE)
[13:33:39.957]             base::close(...future.stdout)
[13:33:39.957]         }, add = TRUE)
[13:33:39.957]     }
[13:33:39.957]     ...future.frame <- base::sys.nframe()
[13:33:39.957]     ...future.conditions <- base::list()
[13:33:39.957]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.957]     if (FALSE) {
[13:33:39.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.957]     }
[13:33:39.957]     ...future.result <- base::tryCatch({
[13:33:39.957]         base::withCallingHandlers({
[13:33:39.957]             ...future.value <- base::withVisible(base::local({
[13:33:39.957]                 ...future.makeSendCondition <- base::local({
[13:33:39.957]                   sendCondition <- NULL
[13:33:39.957]                   function(frame = 1L) {
[13:33:39.957]                     if (is.function(sendCondition)) 
[13:33:39.957]                       return(sendCondition)
[13:33:39.957]                     ns <- getNamespace("parallel")
[13:33:39.957]                     if (exists("sendData", mode = "function", 
[13:33:39.957]                       envir = ns)) {
[13:33:39.957]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.957]                         envir = ns)
[13:33:39.957]                       envir <- sys.frame(frame)
[13:33:39.957]                       master <- NULL
[13:33:39.957]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.957]                         !identical(envir, emptyenv())) {
[13:33:39.957]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.957]                           inherits = FALSE)) {
[13:33:39.957]                           master <- get("master", mode = "list", 
[13:33:39.957]                             envir = envir, inherits = FALSE)
[13:33:39.957]                           if (inherits(master, c("SOCKnode", 
[13:33:39.957]                             "SOCK0node"))) {
[13:33:39.957]                             sendCondition <<- function(cond) {
[13:33:39.957]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.957]                                 success = TRUE)
[13:33:39.957]                               parallel_sendData(master, data)
[13:33:39.957]                             }
[13:33:39.957]                             return(sendCondition)
[13:33:39.957]                           }
[13:33:39.957]                         }
[13:33:39.957]                         frame <- frame + 1L
[13:33:39.957]                         envir <- sys.frame(frame)
[13:33:39.957]                       }
[13:33:39.957]                     }
[13:33:39.957]                     sendCondition <<- function(cond) NULL
[13:33:39.957]                   }
[13:33:39.957]                 })
[13:33:39.957]                 withCallingHandlers({
[13:33:39.957]                   {
[13:33:39.957]                     do.call(function(...) {
[13:33:39.957]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.957]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.957]                         ...future.globals.maxSize)) {
[13:33:39.957]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.957]                         on.exit(options(oopts), add = TRUE)
[13:33:39.957]                       }
[13:33:39.957]                       {
[13:33:39.957]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.957]                           FUN = function(jj) {
[13:33:39.957]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.957]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.957]                           })
[13:33:39.957]                       }
[13:33:39.957]                     }, args = future.call.arguments)
[13:33:39.957]                   }
[13:33:39.957]                 }, immediateCondition = function(cond) {
[13:33:39.957]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.957]                   sendCondition(cond)
[13:33:39.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.957]                   {
[13:33:39.957]                     inherits <- base::inherits
[13:33:39.957]                     invokeRestart <- base::invokeRestart
[13:33:39.957]                     is.null <- base::is.null
[13:33:39.957]                     muffled <- FALSE
[13:33:39.957]                     if (inherits(cond, "message")) {
[13:33:39.957]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.957]                       if (muffled) 
[13:33:39.957]                         invokeRestart("muffleMessage")
[13:33:39.957]                     }
[13:33:39.957]                     else if (inherits(cond, "warning")) {
[13:33:39.957]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.957]                       if (muffled) 
[13:33:39.957]                         invokeRestart("muffleWarning")
[13:33:39.957]                     }
[13:33:39.957]                     else if (inherits(cond, "condition")) {
[13:33:39.957]                       if (!is.null(pattern)) {
[13:33:39.957]                         computeRestarts <- base::computeRestarts
[13:33:39.957]                         grepl <- base::grepl
[13:33:39.957]                         restarts <- computeRestarts(cond)
[13:33:39.957]                         for (restart in restarts) {
[13:33:39.957]                           name <- restart$name
[13:33:39.957]                           if (is.null(name)) 
[13:33:39.957]                             next
[13:33:39.957]                           if (!grepl(pattern, name)) 
[13:33:39.957]                             next
[13:33:39.957]                           invokeRestart(restart)
[13:33:39.957]                           muffled <- TRUE
[13:33:39.957]                           break
[13:33:39.957]                         }
[13:33:39.957]                       }
[13:33:39.957]                     }
[13:33:39.957]                     invisible(muffled)
[13:33:39.957]                   }
[13:33:39.957]                   muffleCondition(cond)
[13:33:39.957]                 })
[13:33:39.957]             }))
[13:33:39.957]             future::FutureResult(value = ...future.value$value, 
[13:33:39.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.957]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.957]                     ...future.globalenv.names))
[13:33:39.957]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.957]         }, condition = base::local({
[13:33:39.957]             c <- base::c
[13:33:39.957]             inherits <- base::inherits
[13:33:39.957]             invokeRestart <- base::invokeRestart
[13:33:39.957]             length <- base::length
[13:33:39.957]             list <- base::list
[13:33:39.957]             seq.int <- base::seq.int
[13:33:39.957]             signalCondition <- base::signalCondition
[13:33:39.957]             sys.calls <- base::sys.calls
[13:33:39.957]             `[[` <- base::`[[`
[13:33:39.957]             `+` <- base::`+`
[13:33:39.957]             `<<-` <- base::`<<-`
[13:33:39.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.957]                   3L)]
[13:33:39.957]             }
[13:33:39.957]             function(cond) {
[13:33:39.957]                 is_error <- inherits(cond, "error")
[13:33:39.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.957]                   NULL)
[13:33:39.957]                 if (is_error) {
[13:33:39.957]                   sessionInformation <- function() {
[13:33:39.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.957]                       search = base::search(), system = base::Sys.info())
[13:33:39.957]                   }
[13:33:39.957]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.957]                     cond$call), session = sessionInformation(), 
[13:33:39.957]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.957]                   signalCondition(cond)
[13:33:39.957]                 }
[13:33:39.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.957]                 "immediateCondition"))) {
[13:33:39.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.957]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.957]                   if (TRUE && !signal) {
[13:33:39.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.957]                     {
[13:33:39.957]                       inherits <- base::inherits
[13:33:39.957]                       invokeRestart <- base::invokeRestart
[13:33:39.957]                       is.null <- base::is.null
[13:33:39.957]                       muffled <- FALSE
[13:33:39.957]                       if (inherits(cond, "message")) {
[13:33:39.957]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.957]                         if (muffled) 
[13:33:39.957]                           invokeRestart("muffleMessage")
[13:33:39.957]                       }
[13:33:39.957]                       else if (inherits(cond, "warning")) {
[13:33:39.957]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.957]                         if (muffled) 
[13:33:39.957]                           invokeRestart("muffleWarning")
[13:33:39.957]                       }
[13:33:39.957]                       else if (inherits(cond, "condition")) {
[13:33:39.957]                         if (!is.null(pattern)) {
[13:33:39.957]                           computeRestarts <- base::computeRestarts
[13:33:39.957]                           grepl <- base::grepl
[13:33:39.957]                           restarts <- computeRestarts(cond)
[13:33:39.957]                           for (restart in restarts) {
[13:33:39.957]                             name <- restart$name
[13:33:39.957]                             if (is.null(name)) 
[13:33:39.957]                               next
[13:33:39.957]                             if (!grepl(pattern, name)) 
[13:33:39.957]                               next
[13:33:39.957]                             invokeRestart(restart)
[13:33:39.957]                             muffled <- TRUE
[13:33:39.957]                             break
[13:33:39.957]                           }
[13:33:39.957]                         }
[13:33:39.957]                       }
[13:33:39.957]                       invisible(muffled)
[13:33:39.957]                     }
[13:33:39.957]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.957]                   }
[13:33:39.957]                 }
[13:33:39.957]                 else {
[13:33:39.957]                   if (TRUE) {
[13:33:39.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.957]                     {
[13:33:39.957]                       inherits <- base::inherits
[13:33:39.957]                       invokeRestart <- base::invokeRestart
[13:33:39.957]                       is.null <- base::is.null
[13:33:39.957]                       muffled <- FALSE
[13:33:39.957]                       if (inherits(cond, "message")) {
[13:33:39.957]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.957]                         if (muffled) 
[13:33:39.957]                           invokeRestart("muffleMessage")
[13:33:39.957]                       }
[13:33:39.957]                       else if (inherits(cond, "warning")) {
[13:33:39.957]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.957]                         if (muffled) 
[13:33:39.957]                           invokeRestart("muffleWarning")
[13:33:39.957]                       }
[13:33:39.957]                       else if (inherits(cond, "condition")) {
[13:33:39.957]                         if (!is.null(pattern)) {
[13:33:39.957]                           computeRestarts <- base::computeRestarts
[13:33:39.957]                           grepl <- base::grepl
[13:33:39.957]                           restarts <- computeRestarts(cond)
[13:33:39.957]                           for (restart in restarts) {
[13:33:39.957]                             name <- restart$name
[13:33:39.957]                             if (is.null(name)) 
[13:33:39.957]                               next
[13:33:39.957]                             if (!grepl(pattern, name)) 
[13:33:39.957]                               next
[13:33:39.957]                             invokeRestart(restart)
[13:33:39.957]                             muffled <- TRUE
[13:33:39.957]                             break
[13:33:39.957]                           }
[13:33:39.957]                         }
[13:33:39.957]                       }
[13:33:39.957]                       invisible(muffled)
[13:33:39.957]                     }
[13:33:39.957]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.957]                   }
[13:33:39.957]                 }
[13:33:39.957]             }
[13:33:39.957]         }))
[13:33:39.957]     }, error = function(ex) {
[13:33:39.957]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.957]                 ...future.rng), started = ...future.startTime, 
[13:33:39.957]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.957]             version = "1.8"), class = "FutureResult")
[13:33:39.957]     }, finally = {
[13:33:39.957]         if (!identical(...future.workdir, getwd())) 
[13:33:39.957]             setwd(...future.workdir)
[13:33:39.957]         {
[13:33:39.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.957]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.957]             }
[13:33:39.957]             base::options(...future.oldOptions)
[13:33:39.957]             if (.Platform$OS.type == "windows") {
[13:33:39.957]                 old_names <- names(...future.oldEnvVars)
[13:33:39.957]                 envs <- base::Sys.getenv()
[13:33:39.957]                 names <- names(envs)
[13:33:39.957]                 common <- intersect(names, old_names)
[13:33:39.957]                 added <- setdiff(names, old_names)
[13:33:39.957]                 removed <- setdiff(old_names, names)
[13:33:39.957]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.957]                   envs[common]]
[13:33:39.957]                 NAMES <- toupper(changed)
[13:33:39.957]                 args <- list()
[13:33:39.957]                 for (kk in seq_along(NAMES)) {
[13:33:39.957]                   name <- changed[[kk]]
[13:33:39.957]                   NAME <- NAMES[[kk]]
[13:33:39.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.957]                     next
[13:33:39.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.957]                 }
[13:33:39.957]                 NAMES <- toupper(added)
[13:33:39.957]                 for (kk in seq_along(NAMES)) {
[13:33:39.957]                   name <- added[[kk]]
[13:33:39.957]                   NAME <- NAMES[[kk]]
[13:33:39.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.957]                     next
[13:33:39.957]                   args[[name]] <- ""
[13:33:39.957]                 }
[13:33:39.957]                 NAMES <- toupper(removed)
[13:33:39.957]                 for (kk in seq_along(NAMES)) {
[13:33:39.957]                   name <- removed[[kk]]
[13:33:39.957]                   NAME <- NAMES[[kk]]
[13:33:39.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.957]                     next
[13:33:39.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.957]                 }
[13:33:39.957]                 if (length(args) > 0) 
[13:33:39.957]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.957]             }
[13:33:39.957]             else {
[13:33:39.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.957]             }
[13:33:39.957]             {
[13:33:39.957]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.957]                   0L) {
[13:33:39.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.957]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.957]                   base::options(opts)
[13:33:39.957]                 }
[13:33:39.957]                 {
[13:33:39.957]                   {
[13:33:39.957]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.957]                     NULL
[13:33:39.957]                   }
[13:33:39.957]                   options(future.plan = NULL)
[13:33:39.957]                   if (is.na(NA_character_)) 
[13:33:39.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.957]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.957]                     .init = FALSE)
[13:33:39.957]                 }
[13:33:39.957]             }
[13:33:39.957]         }
[13:33:39.957]     })
[13:33:39.957]     if (TRUE) {
[13:33:39.957]         base::sink(type = "output", split = FALSE)
[13:33:39.957]         if (TRUE) {
[13:33:39.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.957]         }
[13:33:39.957]         else {
[13:33:39.957]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.957]         }
[13:33:39.957]         base::close(...future.stdout)
[13:33:39.957]         ...future.stdout <- NULL
[13:33:39.957]     }
[13:33:39.957]     ...future.result$conditions <- ...future.conditions
[13:33:39.957]     ...future.result$finished <- base::Sys.time()
[13:33:39.957]     ...future.result
[13:33:39.957] }
[13:33:39.960] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[13:33:39.960] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:39.960] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.960] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[13:33:39.961] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[13:33:39.961] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:33:39.961] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:33:39.961] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:39.962] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:39.962] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:39.962] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:39.962] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[13:33:39.963] MultisessionFuture started
[13:33:39.963] - Launch lazy future ... done
[13:33:39.963] run() for ‘MultisessionFuture’ ... done
[13:33:39.963] Created future:
[13:33:39.964] MultisessionFuture:
[13:33:39.964] Label: ‘future_apply-1’
[13:33:39.964] Expression:
[13:33:39.964] {
[13:33:39.964]     do.call(function(...) {
[13:33:39.964]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.964]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.964]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.964]             on.exit(options(oopts), add = TRUE)
[13:33:39.964]         }
[13:33:39.964]         {
[13:33:39.964]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.964]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.964]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.964]             })
[13:33:39.964]         }
[13:33:39.964]     }, args = future.call.arguments)
[13:33:39.964] }
[13:33:39.964] Lazy evaluation: FALSE
[13:33:39.964] Asynchronous evaluation: TRUE
[13:33:39.964] Local evaluation: TRUE
[13:33:39.964] Environment: R_GlobalEnv
[13:33:39.964] Capture standard output: TRUE
[13:33:39.964] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:39.964] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:39.964] Packages: <none>
[13:33:39.964] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:39.964] Resolved: FALSE
[13:33:39.964] Value: <not collected>
[13:33:39.964] Conditions captured: <none>
[13:33:39.964] Early signaling: FALSE
[13:33:39.964] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:39.964] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.975] Chunk #1 of 2 ... DONE
[13:33:39.975] Chunk #2 of 2 ...
[13:33:39.975]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:39.978]  - seeds: <none>
[13:33:39.978]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.978] getGlobalsAndPackages() ...
[13:33:39.978] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.978] Resolving globals: FALSE
[13:33:39.978] Tweak future expression to call with '...' arguments ...
[13:33:39.978] {
[13:33:39.978]     do.call(function(...) {
[13:33:39.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:39.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.978]             on.exit(options(oopts), add = TRUE)
[13:33:39.978]         }
[13:33:39.978]         {
[13:33:39.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:39.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.978]                 ...future.FUN(...future.X_jj, ...)
[13:33:39.978]             })
[13:33:39.978]         }
[13:33:39.978]     }, args = future.call.arguments)
[13:33:39.978] }
[13:33:39.979] Tweak future expression to call with '...' arguments ... DONE
[13:33:39.979] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:39.979] 
[13:33:39.979] getGlobalsAndPackages() ... DONE
[13:33:39.980] run() for ‘Future’ ...
[13:33:39.980] - state: ‘created’
[13:33:39.980] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:39.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:39.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:39.994]   - Field: ‘node’
[13:33:39.994]   - Field: ‘label’
[13:33:39.994]   - Field: ‘local’
[13:33:39.994]   - Field: ‘owner’
[13:33:39.994]   - Field: ‘envir’
[13:33:39.994]   - Field: ‘workers’
[13:33:39.994]   - Field: ‘packages’
[13:33:39.994]   - Field: ‘gc’
[13:33:39.994]   - Field: ‘conditions’
[13:33:39.995]   - Field: ‘persistent’
[13:33:39.995]   - Field: ‘expr’
[13:33:39.995]   - Field: ‘uuid’
[13:33:39.995]   - Field: ‘seed’
[13:33:39.995]   - Field: ‘version’
[13:33:39.995]   - Field: ‘result’
[13:33:39.995]   - Field: ‘asynchronous’
[13:33:39.995]   - Field: ‘calls’
[13:33:39.995]   - Field: ‘globals’
[13:33:39.995]   - Field: ‘stdout’
[13:33:39.995]   - Field: ‘earlySignal’
[13:33:39.996]   - Field: ‘lazy’
[13:33:39.996]   - Field: ‘state’
[13:33:39.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:39.996] - Launch lazy future ...
[13:33:39.996] Packages needed by the future expression (n = 0): <none>
[13:33:39.996] Packages needed by future strategies (n = 0): <none>
[13:33:39.997] {
[13:33:39.997]     {
[13:33:39.997]         {
[13:33:39.997]             ...future.startTime <- base::Sys.time()
[13:33:39.997]             {
[13:33:39.997]                 {
[13:33:39.997]                   {
[13:33:39.997]                     {
[13:33:39.997]                       base::local({
[13:33:39.997]                         has_future <- base::requireNamespace("future", 
[13:33:39.997]                           quietly = TRUE)
[13:33:39.997]                         if (has_future) {
[13:33:39.997]                           ns <- base::getNamespace("future")
[13:33:39.997]                           version <- ns[[".package"]][["version"]]
[13:33:39.997]                           if (is.null(version)) 
[13:33:39.997]                             version <- utils::packageVersion("future")
[13:33:39.997]                         }
[13:33:39.997]                         else {
[13:33:39.997]                           version <- NULL
[13:33:39.997]                         }
[13:33:39.997]                         if (!has_future || version < "1.8.0") {
[13:33:39.997]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:39.997]                             "", base::R.version$version.string), 
[13:33:39.997]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:39.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:39.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:39.997]                               "release", "version")], collapse = " "), 
[13:33:39.997]                             hostname = base::Sys.info()[["nodename"]])
[13:33:39.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:39.997]                             info)
[13:33:39.997]                           info <- base::paste(info, collapse = "; ")
[13:33:39.997]                           if (!has_future) {
[13:33:39.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:39.997]                               info)
[13:33:39.997]                           }
[13:33:39.997]                           else {
[13:33:39.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:39.997]                               info, version)
[13:33:39.997]                           }
[13:33:39.997]                           base::stop(msg)
[13:33:39.997]                         }
[13:33:39.997]                       })
[13:33:39.997]                     }
[13:33:39.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:39.997]                     base::options(mc.cores = 1L)
[13:33:39.997]                   }
[13:33:39.997]                   ...future.strategy.old <- future::plan("list")
[13:33:39.997]                   options(future.plan = NULL)
[13:33:39.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:39.997]                 }
[13:33:39.997]                 ...future.workdir <- getwd()
[13:33:39.997]             }
[13:33:39.997]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:39.997]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:39.997]         }
[13:33:39.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:39.997]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:39.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:39.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:39.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:39.997]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:39.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:39.997]             base::names(...future.oldOptions))
[13:33:39.997]     }
[13:33:39.997]     if (FALSE) {
[13:33:39.997]     }
[13:33:39.997]     else {
[13:33:39.997]         if (TRUE) {
[13:33:39.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:39.997]                 open = "w")
[13:33:39.997]         }
[13:33:39.997]         else {
[13:33:39.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:39.997]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:39.997]         }
[13:33:39.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:39.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:39.997]             base::sink(type = "output", split = FALSE)
[13:33:39.997]             base::close(...future.stdout)
[13:33:39.997]         }, add = TRUE)
[13:33:39.997]     }
[13:33:39.997]     ...future.frame <- base::sys.nframe()
[13:33:39.997]     ...future.conditions <- base::list()
[13:33:39.997]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:39.997]     if (FALSE) {
[13:33:39.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:39.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:39.997]     }
[13:33:39.997]     ...future.result <- base::tryCatch({
[13:33:39.997]         base::withCallingHandlers({
[13:33:39.997]             ...future.value <- base::withVisible(base::local({
[13:33:39.997]                 ...future.makeSendCondition <- base::local({
[13:33:39.997]                   sendCondition <- NULL
[13:33:39.997]                   function(frame = 1L) {
[13:33:39.997]                     if (is.function(sendCondition)) 
[13:33:39.997]                       return(sendCondition)
[13:33:39.997]                     ns <- getNamespace("parallel")
[13:33:39.997]                     if (exists("sendData", mode = "function", 
[13:33:39.997]                       envir = ns)) {
[13:33:39.997]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:39.997]                         envir = ns)
[13:33:39.997]                       envir <- sys.frame(frame)
[13:33:39.997]                       master <- NULL
[13:33:39.997]                       while (!identical(envir, .GlobalEnv) && 
[13:33:39.997]                         !identical(envir, emptyenv())) {
[13:33:39.997]                         if (exists("master", mode = "list", envir = envir, 
[13:33:39.997]                           inherits = FALSE)) {
[13:33:39.997]                           master <- get("master", mode = "list", 
[13:33:39.997]                             envir = envir, inherits = FALSE)
[13:33:39.997]                           if (inherits(master, c("SOCKnode", 
[13:33:39.997]                             "SOCK0node"))) {
[13:33:39.997]                             sendCondition <<- function(cond) {
[13:33:39.997]                               data <- list(type = "VALUE", value = cond, 
[13:33:39.997]                                 success = TRUE)
[13:33:39.997]                               parallel_sendData(master, data)
[13:33:39.997]                             }
[13:33:39.997]                             return(sendCondition)
[13:33:39.997]                           }
[13:33:39.997]                         }
[13:33:39.997]                         frame <- frame + 1L
[13:33:39.997]                         envir <- sys.frame(frame)
[13:33:39.997]                       }
[13:33:39.997]                     }
[13:33:39.997]                     sendCondition <<- function(cond) NULL
[13:33:39.997]                   }
[13:33:39.997]                 })
[13:33:39.997]                 withCallingHandlers({
[13:33:39.997]                   {
[13:33:39.997]                     do.call(function(...) {
[13:33:39.997]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:39.997]                       if (!identical(...future.globals.maxSize.org, 
[13:33:39.997]                         ...future.globals.maxSize)) {
[13:33:39.997]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:39.997]                         on.exit(options(oopts), add = TRUE)
[13:33:39.997]                       }
[13:33:39.997]                       {
[13:33:39.997]                         lapply(seq_along(...future.elements_ii), 
[13:33:39.997]                           FUN = function(jj) {
[13:33:39.997]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:39.997]                             ...future.FUN(...future.X_jj, ...)
[13:33:39.997]                           })
[13:33:39.997]                       }
[13:33:39.997]                     }, args = future.call.arguments)
[13:33:39.997]                   }
[13:33:39.997]                 }, immediateCondition = function(cond) {
[13:33:39.997]                   sendCondition <- ...future.makeSendCondition()
[13:33:39.997]                   sendCondition(cond)
[13:33:39.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.997]                   {
[13:33:39.997]                     inherits <- base::inherits
[13:33:39.997]                     invokeRestart <- base::invokeRestart
[13:33:39.997]                     is.null <- base::is.null
[13:33:39.997]                     muffled <- FALSE
[13:33:39.997]                     if (inherits(cond, "message")) {
[13:33:39.997]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:39.997]                       if (muffled) 
[13:33:39.997]                         invokeRestart("muffleMessage")
[13:33:39.997]                     }
[13:33:39.997]                     else if (inherits(cond, "warning")) {
[13:33:39.997]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:39.997]                       if (muffled) 
[13:33:39.997]                         invokeRestart("muffleWarning")
[13:33:39.997]                     }
[13:33:39.997]                     else if (inherits(cond, "condition")) {
[13:33:39.997]                       if (!is.null(pattern)) {
[13:33:39.997]                         computeRestarts <- base::computeRestarts
[13:33:39.997]                         grepl <- base::grepl
[13:33:39.997]                         restarts <- computeRestarts(cond)
[13:33:39.997]                         for (restart in restarts) {
[13:33:39.997]                           name <- restart$name
[13:33:39.997]                           if (is.null(name)) 
[13:33:39.997]                             next
[13:33:39.997]                           if (!grepl(pattern, name)) 
[13:33:39.997]                             next
[13:33:39.997]                           invokeRestart(restart)
[13:33:39.997]                           muffled <- TRUE
[13:33:39.997]                           break
[13:33:39.997]                         }
[13:33:39.997]                       }
[13:33:39.997]                     }
[13:33:39.997]                     invisible(muffled)
[13:33:39.997]                   }
[13:33:39.997]                   muffleCondition(cond)
[13:33:39.997]                 })
[13:33:39.997]             }))
[13:33:39.997]             future::FutureResult(value = ...future.value$value, 
[13:33:39.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.997]                   ...future.rng), globalenv = if (FALSE) 
[13:33:39.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:39.997]                     ...future.globalenv.names))
[13:33:39.997]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:39.997]         }, condition = base::local({
[13:33:39.997]             c <- base::c
[13:33:39.997]             inherits <- base::inherits
[13:33:39.997]             invokeRestart <- base::invokeRestart
[13:33:39.997]             length <- base::length
[13:33:39.997]             list <- base::list
[13:33:39.997]             seq.int <- base::seq.int
[13:33:39.997]             signalCondition <- base::signalCondition
[13:33:39.997]             sys.calls <- base::sys.calls
[13:33:39.997]             `[[` <- base::`[[`
[13:33:39.997]             `+` <- base::`+`
[13:33:39.997]             `<<-` <- base::`<<-`
[13:33:39.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:39.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:39.997]                   3L)]
[13:33:39.997]             }
[13:33:39.997]             function(cond) {
[13:33:39.997]                 is_error <- inherits(cond, "error")
[13:33:39.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:39.997]                   NULL)
[13:33:39.997]                 if (is_error) {
[13:33:39.997]                   sessionInformation <- function() {
[13:33:39.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:39.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:39.997]                       search = base::search(), system = base::Sys.info())
[13:33:39.997]                   }
[13:33:39.997]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:39.997]                     cond$call), session = sessionInformation(), 
[13:33:39.997]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:39.997]                   signalCondition(cond)
[13:33:39.997]                 }
[13:33:39.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:39.997]                 "immediateCondition"))) {
[13:33:39.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:39.997]                   ...future.conditions[[length(...future.conditions) + 
[13:33:39.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:39.997]                   if (TRUE && !signal) {
[13:33:39.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.997]                     {
[13:33:39.997]                       inherits <- base::inherits
[13:33:39.997]                       invokeRestart <- base::invokeRestart
[13:33:39.997]                       is.null <- base::is.null
[13:33:39.997]                       muffled <- FALSE
[13:33:39.997]                       if (inherits(cond, "message")) {
[13:33:39.997]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.997]                         if (muffled) 
[13:33:39.997]                           invokeRestart("muffleMessage")
[13:33:39.997]                       }
[13:33:39.997]                       else if (inherits(cond, "warning")) {
[13:33:39.997]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.997]                         if (muffled) 
[13:33:39.997]                           invokeRestart("muffleWarning")
[13:33:39.997]                       }
[13:33:39.997]                       else if (inherits(cond, "condition")) {
[13:33:39.997]                         if (!is.null(pattern)) {
[13:33:39.997]                           computeRestarts <- base::computeRestarts
[13:33:39.997]                           grepl <- base::grepl
[13:33:39.997]                           restarts <- computeRestarts(cond)
[13:33:39.997]                           for (restart in restarts) {
[13:33:39.997]                             name <- restart$name
[13:33:39.997]                             if (is.null(name)) 
[13:33:39.997]                               next
[13:33:39.997]                             if (!grepl(pattern, name)) 
[13:33:39.997]                               next
[13:33:39.997]                             invokeRestart(restart)
[13:33:39.997]                             muffled <- TRUE
[13:33:39.997]                             break
[13:33:39.997]                           }
[13:33:39.997]                         }
[13:33:39.997]                       }
[13:33:39.997]                       invisible(muffled)
[13:33:39.997]                     }
[13:33:39.997]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.997]                   }
[13:33:39.997]                 }
[13:33:39.997]                 else {
[13:33:39.997]                   if (TRUE) {
[13:33:39.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:39.997]                     {
[13:33:39.997]                       inherits <- base::inherits
[13:33:39.997]                       invokeRestart <- base::invokeRestart
[13:33:39.997]                       is.null <- base::is.null
[13:33:39.997]                       muffled <- FALSE
[13:33:39.997]                       if (inherits(cond, "message")) {
[13:33:39.997]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:39.997]                         if (muffled) 
[13:33:39.997]                           invokeRestart("muffleMessage")
[13:33:39.997]                       }
[13:33:39.997]                       else if (inherits(cond, "warning")) {
[13:33:39.997]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:39.997]                         if (muffled) 
[13:33:39.997]                           invokeRestart("muffleWarning")
[13:33:39.997]                       }
[13:33:39.997]                       else if (inherits(cond, "condition")) {
[13:33:39.997]                         if (!is.null(pattern)) {
[13:33:39.997]                           computeRestarts <- base::computeRestarts
[13:33:39.997]                           grepl <- base::grepl
[13:33:39.997]                           restarts <- computeRestarts(cond)
[13:33:39.997]                           for (restart in restarts) {
[13:33:39.997]                             name <- restart$name
[13:33:39.997]                             if (is.null(name)) 
[13:33:39.997]                               next
[13:33:39.997]                             if (!grepl(pattern, name)) 
[13:33:39.997]                               next
[13:33:39.997]                             invokeRestart(restart)
[13:33:39.997]                             muffled <- TRUE
[13:33:39.997]                             break
[13:33:39.997]                           }
[13:33:39.997]                         }
[13:33:39.997]                       }
[13:33:39.997]                       invisible(muffled)
[13:33:39.997]                     }
[13:33:39.997]                     muffleCondition(cond, pattern = "^muffle")
[13:33:39.997]                   }
[13:33:39.997]                 }
[13:33:39.997]             }
[13:33:39.997]         }))
[13:33:39.997]     }, error = function(ex) {
[13:33:39.997]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:39.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:39.997]                 ...future.rng), started = ...future.startTime, 
[13:33:39.997]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:39.997]             version = "1.8"), class = "FutureResult")
[13:33:39.997]     }, finally = {
[13:33:39.997]         if (!identical(...future.workdir, getwd())) 
[13:33:39.997]             setwd(...future.workdir)
[13:33:39.997]         {
[13:33:39.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:39.997]                 ...future.oldOptions$nwarnings <- NULL
[13:33:39.997]             }
[13:33:39.997]             base::options(...future.oldOptions)
[13:33:39.997]             if (.Platform$OS.type == "windows") {
[13:33:39.997]                 old_names <- names(...future.oldEnvVars)
[13:33:39.997]                 envs <- base::Sys.getenv()
[13:33:39.997]                 names <- names(envs)
[13:33:39.997]                 common <- intersect(names, old_names)
[13:33:39.997]                 added <- setdiff(names, old_names)
[13:33:39.997]                 removed <- setdiff(old_names, names)
[13:33:39.997]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:39.997]                   envs[common]]
[13:33:39.997]                 NAMES <- toupper(changed)
[13:33:39.997]                 args <- list()
[13:33:39.997]                 for (kk in seq_along(NAMES)) {
[13:33:39.997]                   name <- changed[[kk]]
[13:33:39.997]                   NAME <- NAMES[[kk]]
[13:33:39.997]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.997]                     next
[13:33:39.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.997]                 }
[13:33:39.997]                 NAMES <- toupper(added)
[13:33:39.997]                 for (kk in seq_along(NAMES)) {
[13:33:39.997]                   name <- added[[kk]]
[13:33:39.997]                   NAME <- NAMES[[kk]]
[13:33:39.997]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.997]                     next
[13:33:39.997]                   args[[name]] <- ""
[13:33:39.997]                 }
[13:33:39.997]                 NAMES <- toupper(removed)
[13:33:39.997]                 for (kk in seq_along(NAMES)) {
[13:33:39.997]                   name <- removed[[kk]]
[13:33:39.997]                   NAME <- NAMES[[kk]]
[13:33:39.997]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:39.997]                     next
[13:33:39.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:39.997]                 }
[13:33:39.997]                 if (length(args) > 0) 
[13:33:39.997]                   base::do.call(base::Sys.setenv, args = args)
[13:33:39.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:39.997]             }
[13:33:39.997]             else {
[13:33:39.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:39.997]             }
[13:33:39.997]             {
[13:33:39.997]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:39.997]                   0L) {
[13:33:39.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:39.997]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:39.997]                   base::options(opts)
[13:33:39.997]                 }
[13:33:39.997]                 {
[13:33:39.997]                   {
[13:33:39.997]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:39.997]                     NULL
[13:33:39.997]                   }
[13:33:39.997]                   options(future.plan = NULL)
[13:33:39.997]                   if (is.na(NA_character_)) 
[13:33:39.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:39.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:39.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:39.997]                     .init = FALSE)
[13:33:39.997]                 }
[13:33:39.997]             }
[13:33:39.997]         }
[13:33:39.997]     })
[13:33:39.997]     if (TRUE) {
[13:33:39.997]         base::sink(type = "output", split = FALSE)
[13:33:39.997]         if (TRUE) {
[13:33:39.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:39.997]         }
[13:33:39.997]         else {
[13:33:39.997]             ...future.result["stdout"] <- base::list(NULL)
[13:33:39.997]         }
[13:33:39.997]         base::close(...future.stdout)
[13:33:39.997]         ...future.stdout <- NULL
[13:33:39.997]     }
[13:33:39.997]     ...future.result$conditions <- ...future.conditions
[13:33:39.997]     ...future.result$finished <- base::Sys.time()
[13:33:39.997]     ...future.result
[13:33:39.997] }
[13:33:39.999] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[13:33:40.000] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:40.000] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:40.000] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[13:33:40.000] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[13:33:40.001] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:33:40.001] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:33:40.001] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:40.001] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:40.001] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:33:40.002] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:33:40.002] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[13:33:40.002] MultisessionFuture started
[13:33:40.002] - Launch lazy future ... done
[13:33:40.002] run() for ‘MultisessionFuture’ ... done
[13:33:40.003] Created future:
[13:33:40.004] receiveMessageFromWorker() for ClusterFuture ...
[13:33:40.004] - Validating connection of MultisessionFuture
[13:33:40.004] - received message: FutureResult
[13:33:40.004] - Received FutureResult
[13:33:40.004] - Erased future from FutureRegistry
[13:33:40.005] result() for ClusterFuture ...
[13:33:40.005] - result already collected: FutureResult
[13:33:40.005] result() for ClusterFuture ... done
[13:33:40.005] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:40.003] MultisessionFuture:
[13:33:40.003] Label: ‘future_apply-2’
[13:33:40.003] Expression:
[13:33:40.003] {
[13:33:40.003]     do.call(function(...) {
[13:33:40.003]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.003]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.003]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.003]             on.exit(options(oopts), add = TRUE)
[13:33:40.003]         }
[13:33:40.003]         {
[13:33:40.003]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.003]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.003]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.003]             })
[13:33:40.003]         }
[13:33:40.003]     }, args = future.call.arguments)
[13:33:40.003] }
[13:33:40.003] Lazy evaluation: FALSE
[13:33:40.003] Asynchronous evaluation: TRUE
[13:33:40.003] Local evaluation: TRUE
[13:33:40.003] Environment: R_GlobalEnv
[13:33:40.003] Capture standard output: TRUE
[13:33:40.003] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:40.003] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:40.003] Packages: <none>
[13:33:40.003] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:40.003] Resolved: TRUE
[13:33:40.003] Value: <not collected>
[13:33:40.003] Conditions captured: <none>
[13:33:40.003] Early signaling: FALSE
[13:33:40.003] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:40.003] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:40.005] Chunk #2 of 2 ... DONE
[13:33:40.005] Launching 2 futures (chunks) ... DONE
[13:33:40.005] Resolving 2 futures (chunks) ...
[13:33:40.005] resolve() on list ...
[13:33:40.005]  recursive: 0
[13:33:40.006]  length: 2
[13:33:40.006] 
[13:33:40.008] receiveMessageFromWorker() for ClusterFuture ...
[13:33:40.008] - Validating connection of MultisessionFuture
[13:33:40.008] - received message: FutureResult
[13:33:40.008] - Received FutureResult
[13:33:40.008] - Erased future from FutureRegistry
[13:33:40.008] result() for ClusterFuture ...
[13:33:40.008] - result already collected: FutureResult
[13:33:40.009] result() for ClusterFuture ... done
[13:33:40.009] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:40.009] Future #1
[13:33:40.009] result() for ClusterFuture ...
[13:33:40.009] - result already collected: FutureResult
[13:33:40.009] result() for ClusterFuture ... done
[13:33:40.009] result() for ClusterFuture ...
[13:33:40.009] - result already collected: FutureResult
[13:33:40.009] result() for ClusterFuture ... done
[13:33:40.009] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:40.009] - nx: 2
[13:33:40.010] - relay: TRUE
[13:33:40.010] - stdout: TRUE
[13:33:40.010] - signal: TRUE
[13:33:40.010] - resignal: FALSE
[13:33:40.010] - force: TRUE
[13:33:40.010] - relayed: [n=2] FALSE, FALSE
[13:33:40.010] - queued futures: [n=2] FALSE, FALSE
[13:33:40.010]  - until=1
[13:33:40.010]  - relaying element #1
[13:33:40.010] result() for ClusterFuture ...
[13:33:40.010] - result already collected: FutureResult
[13:33:40.011] result() for ClusterFuture ... done
[13:33:40.011] result() for ClusterFuture ...
[13:33:40.011] - result already collected: FutureResult
[13:33:40.011] result() for ClusterFuture ... done
[13:33:40.011] result() for ClusterFuture ...
[13:33:40.011] - result already collected: FutureResult
[13:33:40.011] result() for ClusterFuture ... done
[13:33:40.011] result() for ClusterFuture ...
[13:33:40.011] - result already collected: FutureResult
[13:33:40.011] result() for ClusterFuture ... done
[13:33:40.011] - relayed: [n=2] TRUE, FALSE
[13:33:40.012] - queued futures: [n=2] TRUE, FALSE
[13:33:40.012] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:40.012]  length: 1 (resolved future 1)
[13:33:40.012] Future #2
[13:33:40.012] result() for ClusterFuture ...
[13:33:40.012] - result already collected: FutureResult
[13:33:40.012] result() for ClusterFuture ... done
[13:33:40.012] result() for ClusterFuture ...
[13:33:40.012] - result already collected: FutureResult
[13:33:40.012] result() for ClusterFuture ... done
[13:33:40.012] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:40.013] - nx: 2
[13:33:40.013] - relay: TRUE
[13:33:40.013] - stdout: TRUE
[13:33:40.013] - signal: TRUE
[13:33:40.013] - resignal: FALSE
[13:33:40.013] - force: TRUE
[13:33:40.013] - relayed: [n=2] TRUE, FALSE
[13:33:40.013] - queued futures: [n=2] TRUE, FALSE
[13:33:40.013]  - until=2
[13:33:40.013]  - relaying element #2
[13:33:40.013] result() for ClusterFuture ...
[13:33:40.013] - result already collected: FutureResult
[13:33:40.014] result() for ClusterFuture ... done
[13:33:40.014] result() for ClusterFuture ...
[13:33:40.014] - result already collected: FutureResult
[13:33:40.014] result() for ClusterFuture ... done
[13:33:40.014] result() for ClusterFuture ...
[13:33:40.014] - result already collected: FutureResult
[13:33:40.014] result() for ClusterFuture ... done
[13:33:40.014] result() for ClusterFuture ...
[13:33:40.014] - result already collected: FutureResult
[13:33:40.014] result() for ClusterFuture ... done
[13:33:40.015] - relayed: [n=2] TRUE, TRUE
[13:33:40.015] - queued futures: [n=2] TRUE, TRUE
[13:33:40.015] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:40.015]  length: 0 (resolved future 2)
[13:33:40.015] Relaying remaining futures
[13:33:40.015] signalConditionsASAP(NULL, pos=0) ...
[13:33:40.015] - nx: 2
[13:33:40.015] - relay: TRUE
[13:33:40.015] - stdout: TRUE
[13:33:40.015] - signal: TRUE
[13:33:40.015] - resignal: FALSE
[13:33:40.015] - force: TRUE
[13:33:40.016] - relayed: [n=2] TRUE, TRUE
[13:33:40.016] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:40.016] - relayed: [n=2] TRUE, TRUE
[13:33:40.016] - queued futures: [n=2] TRUE, TRUE
[13:33:40.016] signalConditionsASAP(NULL, pos=0) ... done
[13:33:40.016] resolve() on list ... DONE
[13:33:40.016] result() for ClusterFuture ...
[13:33:40.016] - result already collected: FutureResult
[13:33:40.016] result() for ClusterFuture ... done
[13:33:40.016] result() for ClusterFuture ...
[13:33:40.016] - result already collected: FutureResult
[13:33:40.017] result() for ClusterFuture ... done
[13:33:40.017] result() for ClusterFuture ...
[13:33:40.017] - result already collected: FutureResult
[13:33:40.017] result() for ClusterFuture ... done
[13:33:40.017] result() for ClusterFuture ...
[13:33:40.017] - result already collected: FutureResult
[13:33:40.017] result() for ClusterFuture ... done
[13:33:40.017]  - Number of value chunks collected: 2
[13:33:40.017] Resolving 2 futures (chunks) ... DONE
[13:33:40.017] Reducing values from 2 chunks ...
[13:33:40.017]  - Number of values collected after concatenation: 2
[13:33:40.018]  - Number of values expected: 2
[13:33:40.018] Reducing values from 2 chunks ... DONE
[13:33:40.018] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[13:33:40.018] getGlobalsAndPackagesXApply() ...
[13:33:40.018]  - future.globals: TRUE
[13:33:40.018] getGlobalsAndPackages() ...
[13:33:40.018] Searching for globals...
[13:33:40.021] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[13:33:40.021] Searching for globals ... DONE
[13:33:40.021] Resolving globals: FALSE
[13:33:40.022] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[13:33:40.022] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[13:33:40.022] - globals: [1] ‘FUN’
[13:33:40.022] 
[13:33:40.023] getGlobalsAndPackages() ... DONE
[13:33:40.023]  - globals found/used: [n=1] ‘FUN’
[13:33:40.023]  - needed namespaces: [n=0] 
[13:33:40.023] Finding globals ... DONE
[13:33:40.023]  - use_args: TRUE
[13:33:40.023]  - Getting '...' globals ...
[13:33:40.023] resolve() on list ...
[13:33:40.023]  recursive: 0
[13:33:40.023]  length: 1
[13:33:40.024]  elements: ‘...’
[13:33:40.024]  length: 0 (resolved future 1)
[13:33:40.024] resolve() on list ... DONE
[13:33:40.024]    - '...' content: [n=0] 
[13:33:40.024] List of 1
[13:33:40.024]  $ ...: list()
[13:33:40.024]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.024]  - attr(*, "where")=List of 1
[13:33:40.024]   ..$ ...:<environment: 0x55b94ab2b470> 
[13:33:40.024]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.024]  - attr(*, "resolved")= logi TRUE
[13:33:40.024]  - attr(*, "total_size")= num NA
[13:33:40.026]  - Getting '...' globals ... DONE
[13:33:40.027] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:40.027] List of 2
[13:33:40.027]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:33:40.027]  $ ...          : list()
[13:33:40.027]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.027]  - attr(*, "where")=List of 2
[13:33:40.027]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:40.027]   ..$ ...          :<environment: 0x55b94ab2b470> 
[13:33:40.027]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.027]  - attr(*, "resolved")= logi FALSE
[13:33:40.027]  - attr(*, "total_size")= num 36296
[13:33:40.029] Packages to be attached in all futures: [n=0] 
[13:33:40.029] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.033] future_lapply() ...
[13:33:40.035] Generating random seeds ...
[13:33:40.035] Generating random seed streams for 2 elements ...
[13:33:40.035] Generating random seed streams for 2 elements ... DONE
[13:33:40.035] Generating random seeds ... DONE
[13:33:40.035] Will set RNG state on exit: 10407, -688074440, 1284083722, 254759596, -2028330292, -1786185751, 1617632684
[13:33:40.038] Number of chunks: 2
[13:33:40.038] getGlobalsAndPackagesXApply() ...
[13:33:40.039]  - future.globals: <name-value list> with names ‘list()’
[13:33:40.039]  - use_args: TRUE
[13:33:40.039] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:33:40.039] List of 2
[13:33:40.039]  $ ...          : list()
[13:33:40.039]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.039]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:33:40.039]  - attr(*, "where")=List of 2
[13:33:40.039]   ..$ ...          :<environment: 0x55b94ab2b470> 
[13:33:40.039]   ..$ ...future.FUN:<environment: namespace:base> 
[13:33:40.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.039]  - attr(*, "resolved")= logi FALSE
[13:33:40.039]  - attr(*, "total_size")= num NA
[13:33:40.042] Packages to be attached in all futures: [n=0] 
[13:33:40.042] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.043] Number of futures (= number of chunks): 2
[13:33:40.043] Launching 2 futures (chunks) ...
[13:33:40.043] Chunk #1 of 2 ...
[13:33:40.043]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:40.043]  - seeds: [1] <seeds>
[13:33:40.043]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.043] getGlobalsAndPackages() ...
[13:33:40.043] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.043] Resolving globals: FALSE
[13:33:40.043] Tweak future expression to call with '...' arguments ...
[13:33:40.044] {
[13:33:40.044]     do.call(function(...) {
[13:33:40.044]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.044]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.044]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.044]             on.exit(options(oopts), add = TRUE)
[13:33:40.044]         }
[13:33:40.044]         {
[13:33:40.044]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.044]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.044]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:40.044]                   envir = globalenv(), inherits = FALSE)
[13:33:40.044]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.044]             })
[13:33:40.044]         }
[13:33:40.044]     }, args = future.call.arguments)
[13:33:40.044] }
[13:33:40.044] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.044] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.044] 
[13:33:40.044] getGlobalsAndPackages() ... DONE
[13:33:40.045] run() for ‘Future’ ...
[13:33:40.045] - state: ‘created’
[13:33:40.045] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:40.058] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:40.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:40.059]   - Field: ‘node’
[13:33:40.059]   - Field: ‘label’
[13:33:40.059]   - Field: ‘local’
[13:33:40.059]   - Field: ‘owner’
[13:33:40.059]   - Field: ‘envir’
[13:33:40.059]   - Field: ‘workers’
[13:33:40.059]   - Field: ‘packages’
[13:33:40.059]   - Field: ‘gc’
[13:33:40.059]   - Field: ‘conditions’
[13:33:40.059]   - Field: ‘persistent’
[13:33:40.060]   - Field: ‘expr’
[13:33:40.060]   - Field: ‘uuid’
[13:33:40.060]   - Field: ‘seed’
[13:33:40.060]   - Field: ‘version’
[13:33:40.060]   - Field: ‘result’
[13:33:40.060]   - Field: ‘asynchronous’
[13:33:40.060]   - Field: ‘calls’
[13:33:40.060]   - Field: ‘globals’
[13:33:40.060]   - Field: ‘stdout’
[13:33:40.060]   - Field: ‘earlySignal’
[13:33:40.060]   - Field: ‘lazy’
[13:33:40.061]   - Field: ‘state’
[13:33:40.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:40.061] - Launch lazy future ...
[13:33:40.061] Packages needed by the future expression (n = 0): <none>
[13:33:40.061] Packages needed by future strategies (n = 0): <none>
[13:33:40.061] {
[13:33:40.061]     {
[13:33:40.061]         {
[13:33:40.061]             ...future.startTime <- base::Sys.time()
[13:33:40.061]             {
[13:33:40.061]                 {
[13:33:40.061]                   {
[13:33:40.061]                     {
[13:33:40.061]                       base::local({
[13:33:40.061]                         has_future <- base::requireNamespace("future", 
[13:33:40.061]                           quietly = TRUE)
[13:33:40.061]                         if (has_future) {
[13:33:40.061]                           ns <- base::getNamespace("future")
[13:33:40.061]                           version <- ns[[".package"]][["version"]]
[13:33:40.061]                           if (is.null(version)) 
[13:33:40.061]                             version <- utils::packageVersion("future")
[13:33:40.061]                         }
[13:33:40.061]                         else {
[13:33:40.061]                           version <- NULL
[13:33:40.061]                         }
[13:33:40.061]                         if (!has_future || version < "1.8.0") {
[13:33:40.061]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.061]                             "", base::R.version$version.string), 
[13:33:40.061]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:40.061]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.061]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.061]                               "release", "version")], collapse = " "), 
[13:33:40.061]                             hostname = base::Sys.info()[["nodename"]])
[13:33:40.061]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.061]                             info)
[13:33:40.061]                           info <- base::paste(info, collapse = "; ")
[13:33:40.061]                           if (!has_future) {
[13:33:40.061]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.061]                               info)
[13:33:40.061]                           }
[13:33:40.061]                           else {
[13:33:40.061]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.061]                               info, version)
[13:33:40.061]                           }
[13:33:40.061]                           base::stop(msg)
[13:33:40.061]                         }
[13:33:40.061]                       })
[13:33:40.061]                     }
[13:33:40.061]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:40.061]                     base::options(mc.cores = 1L)
[13:33:40.061]                   }
[13:33:40.061]                   ...future.strategy.old <- future::plan("list")
[13:33:40.061]                   options(future.plan = NULL)
[13:33:40.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.061]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.061]                 }
[13:33:40.061]                 ...future.workdir <- getwd()
[13:33:40.061]             }
[13:33:40.061]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.061]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.061]         }
[13:33:40.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.061]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:40.061]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.061]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.061]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.061]             base::names(...future.oldOptions))
[13:33:40.061]     }
[13:33:40.061]     if (FALSE) {
[13:33:40.061]     }
[13:33:40.061]     else {
[13:33:40.061]         if (TRUE) {
[13:33:40.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.061]                 open = "w")
[13:33:40.061]         }
[13:33:40.061]         else {
[13:33:40.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.061]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.061]         }
[13:33:40.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.061]             base::sink(type = "output", split = FALSE)
[13:33:40.061]             base::close(...future.stdout)
[13:33:40.061]         }, add = TRUE)
[13:33:40.061]     }
[13:33:40.061]     ...future.frame <- base::sys.nframe()
[13:33:40.061]     ...future.conditions <- base::list()
[13:33:40.061]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.061]     if (FALSE) {
[13:33:40.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.061]     }
[13:33:40.061]     ...future.result <- base::tryCatch({
[13:33:40.061]         base::withCallingHandlers({
[13:33:40.061]             ...future.value <- base::withVisible(base::local({
[13:33:40.061]                 ...future.makeSendCondition <- base::local({
[13:33:40.061]                   sendCondition <- NULL
[13:33:40.061]                   function(frame = 1L) {
[13:33:40.061]                     if (is.function(sendCondition)) 
[13:33:40.061]                       return(sendCondition)
[13:33:40.061]                     ns <- getNamespace("parallel")
[13:33:40.061]                     if (exists("sendData", mode = "function", 
[13:33:40.061]                       envir = ns)) {
[13:33:40.061]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:40.061]                         envir = ns)
[13:33:40.061]                       envir <- sys.frame(frame)
[13:33:40.061]                       master <- NULL
[13:33:40.061]                       while (!identical(envir, .GlobalEnv) && 
[13:33:40.061]                         !identical(envir, emptyenv())) {
[13:33:40.061]                         if (exists("master", mode = "list", envir = envir, 
[13:33:40.061]                           inherits = FALSE)) {
[13:33:40.061]                           master <- get("master", mode = "list", 
[13:33:40.061]                             envir = envir, inherits = FALSE)
[13:33:40.061]                           if (inherits(master, c("SOCKnode", 
[13:33:40.061]                             "SOCK0node"))) {
[13:33:40.061]                             sendCondition <<- function(cond) {
[13:33:40.061]                               data <- list(type = "VALUE", value = cond, 
[13:33:40.061]                                 success = TRUE)
[13:33:40.061]                               parallel_sendData(master, data)
[13:33:40.061]                             }
[13:33:40.061]                             return(sendCondition)
[13:33:40.061]                           }
[13:33:40.061]                         }
[13:33:40.061]                         frame <- frame + 1L
[13:33:40.061]                         envir <- sys.frame(frame)
[13:33:40.061]                       }
[13:33:40.061]                     }
[13:33:40.061]                     sendCondition <<- function(cond) NULL
[13:33:40.061]                   }
[13:33:40.061]                 })
[13:33:40.061]                 withCallingHandlers({
[13:33:40.061]                   {
[13:33:40.061]                     do.call(function(...) {
[13:33:40.061]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.061]                       if (!identical(...future.globals.maxSize.org, 
[13:33:40.061]                         ...future.globals.maxSize)) {
[13:33:40.061]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.061]                         on.exit(options(oopts), add = TRUE)
[13:33:40.061]                       }
[13:33:40.061]                       {
[13:33:40.061]                         lapply(seq_along(...future.elements_ii), 
[13:33:40.061]                           FUN = function(jj) {
[13:33:40.061]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.061]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:40.061]                               envir = globalenv(), inherits = FALSE)
[13:33:40.061]                             ...future.FUN(...future.X_jj, ...)
[13:33:40.061]                           })
[13:33:40.061]                       }
[13:33:40.061]                     }, args = future.call.arguments)
[13:33:40.061]                   }
[13:33:40.061]                 }, immediateCondition = function(cond) {
[13:33:40.061]                   sendCondition <- ...future.makeSendCondition()
[13:33:40.061]                   sendCondition(cond)
[13:33:40.061]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.061]                   {
[13:33:40.061]                     inherits <- base::inherits
[13:33:40.061]                     invokeRestart <- base::invokeRestart
[13:33:40.061]                     is.null <- base::is.null
[13:33:40.061]                     muffled <- FALSE
[13:33:40.061]                     if (inherits(cond, "message")) {
[13:33:40.061]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:40.061]                       if (muffled) 
[13:33:40.061]                         invokeRestart("muffleMessage")
[13:33:40.061]                     }
[13:33:40.061]                     else if (inherits(cond, "warning")) {
[13:33:40.061]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:40.061]                       if (muffled) 
[13:33:40.061]                         invokeRestart("muffleWarning")
[13:33:40.061]                     }
[13:33:40.061]                     else if (inherits(cond, "condition")) {
[13:33:40.061]                       if (!is.null(pattern)) {
[13:33:40.061]                         computeRestarts <- base::computeRestarts
[13:33:40.061]                         grepl <- base::grepl
[13:33:40.061]                         restarts <- computeRestarts(cond)
[13:33:40.061]                         for (restart in restarts) {
[13:33:40.061]                           name <- restart$name
[13:33:40.061]                           if (is.null(name)) 
[13:33:40.061]                             next
[13:33:40.061]                           if (!grepl(pattern, name)) 
[13:33:40.061]                             next
[13:33:40.061]                           invokeRestart(restart)
[13:33:40.061]                           muffled <- TRUE
[13:33:40.061]                           break
[13:33:40.061]                         }
[13:33:40.061]                       }
[13:33:40.061]                     }
[13:33:40.061]                     invisible(muffled)
[13:33:40.061]                   }
[13:33:40.061]                   muffleCondition(cond)
[13:33:40.061]                 })
[13:33:40.061]             }))
[13:33:40.061]             future::FutureResult(value = ...future.value$value, 
[13:33:40.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.061]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.061]                     ...future.globalenv.names))
[13:33:40.061]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.061]         }, condition = base::local({
[13:33:40.061]             c <- base::c
[13:33:40.061]             inherits <- base::inherits
[13:33:40.061]             invokeRestart <- base::invokeRestart
[13:33:40.061]             length <- base::length
[13:33:40.061]             list <- base::list
[13:33:40.061]             seq.int <- base::seq.int
[13:33:40.061]             signalCondition <- base::signalCondition
[13:33:40.061]             sys.calls <- base::sys.calls
[13:33:40.061]             `[[` <- base::`[[`
[13:33:40.061]             `+` <- base::`+`
[13:33:40.061]             `<<-` <- base::`<<-`
[13:33:40.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.061]                   3L)]
[13:33:40.061]             }
[13:33:40.061]             function(cond) {
[13:33:40.061]                 is_error <- inherits(cond, "error")
[13:33:40.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.061]                   NULL)
[13:33:40.061]                 if (is_error) {
[13:33:40.061]                   sessionInformation <- function() {
[13:33:40.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.061]                       search = base::search(), system = base::Sys.info())
[13:33:40.061]                   }
[13:33:40.061]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.061]                     cond$call), session = sessionInformation(), 
[13:33:40.061]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.061]                   signalCondition(cond)
[13:33:40.061]                 }
[13:33:40.061]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:33:40.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.061]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.061]                   if (TRUE && !signal) {
[13:33:40.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.061]                     {
[13:33:40.061]                       inherits <- base::inherits
[13:33:40.061]                       invokeRestart <- base::invokeRestart
[13:33:40.061]                       is.null <- base::is.null
[13:33:40.061]                       muffled <- FALSE
[13:33:40.061]                       if (inherits(cond, "message")) {
[13:33:40.061]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.061]                         if (muffled) 
[13:33:40.061]                           invokeRestart("muffleMessage")
[13:33:40.061]                       }
[13:33:40.061]                       else if (inherits(cond, "warning")) {
[13:33:40.061]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.061]                         if (muffled) 
[13:33:40.061]                           invokeRestart("muffleWarning")
[13:33:40.061]                       }
[13:33:40.061]                       else if (inherits(cond, "condition")) {
[13:33:40.061]                         if (!is.null(pattern)) {
[13:33:40.061]                           computeRestarts <- base::computeRestarts
[13:33:40.061]                           grepl <- base::grepl
[13:33:40.061]                           restarts <- computeRestarts(cond)
[13:33:40.061]                           for (restart in restarts) {
[13:33:40.061]                             name <- restart$name
[13:33:40.061]                             if (is.null(name)) 
[13:33:40.061]                               next
[13:33:40.061]                             if (!grepl(pattern, name)) 
[13:33:40.061]                               next
[13:33:40.061]                             invokeRestart(restart)
[13:33:40.061]                             muffled <- TRUE
[13:33:40.061]                             break
[13:33:40.061]                           }
[13:33:40.061]                         }
[13:33:40.061]                       }
[13:33:40.061]                       invisible(muffled)
[13:33:40.061]                     }
[13:33:40.061]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.061]                   }
[13:33:40.061]                 }
[13:33:40.061]                 else {
[13:33:40.061]                   if (TRUE) {
[13:33:40.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.061]                     {
[13:33:40.061]                       inherits <- base::inherits
[13:33:40.061]                       invokeRestart <- base::invokeRestart
[13:33:40.061]                       is.null <- base::is.null
[13:33:40.061]                       muffled <- FALSE
[13:33:40.061]                       if (inherits(cond, "message")) {
[13:33:40.061]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.061]                         if (muffled) 
[13:33:40.061]                           invokeRestart("muffleMessage")
[13:33:40.061]                       }
[13:33:40.061]                       else if (inherits(cond, "warning")) {
[13:33:40.061]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.061]                         if (muffled) 
[13:33:40.061]                           invokeRestart("muffleWarning")
[13:33:40.061]                       }
[13:33:40.061]                       else if (inherits(cond, "condition")) {
[13:33:40.061]                         if (!is.null(pattern)) {
[13:33:40.061]                           computeRestarts <- base::computeRestarts
[13:33:40.061]                           grepl <- base::grepl
[13:33:40.061]                           restarts <- computeRestarts(cond)
[13:33:40.061]                           for (restart in restarts) {
[13:33:40.061]                             name <- restart$name
[13:33:40.061]                             if (is.null(name)) 
[13:33:40.061]                               next
[13:33:40.061]                             if (!grepl(pattern, name)) 
[13:33:40.061]                               next
[13:33:40.061]                             invokeRestart(restart)
[13:33:40.061]                             muffled <- TRUE
[13:33:40.061]                             break
[13:33:40.061]                           }
[13:33:40.061]                         }
[13:33:40.061]                       }
[13:33:40.061]                       invisible(muffled)
[13:33:40.061]                     }
[13:33:40.061]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.061]                   }
[13:33:40.061]                 }
[13:33:40.061]             }
[13:33:40.061]         }))
[13:33:40.061]     }, error = function(ex) {
[13:33:40.061]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.061]                 ...future.rng), started = ...future.startTime, 
[13:33:40.061]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.061]             version = "1.8"), class = "FutureResult")
[13:33:40.061]     }, finally = {
[13:33:40.061]         if (!identical(...future.workdir, getwd())) 
[13:33:40.061]             setwd(...future.workdir)
[13:33:40.061]         {
[13:33:40.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.061]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.061]             }
[13:33:40.061]             base::options(...future.oldOptions)
[13:33:40.061]             if (.Platform$OS.type == "windows") {
[13:33:40.061]                 old_names <- names(...future.oldEnvVars)
[13:33:40.061]                 envs <- base::Sys.getenv()
[13:33:40.061]                 names <- names(envs)
[13:33:40.061]                 common <- intersect(names, old_names)
[13:33:40.061]                 added <- setdiff(names, old_names)
[13:33:40.061]                 removed <- setdiff(old_names, names)
[13:33:40.061]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.061]                   envs[common]]
[13:33:40.061]                 NAMES <- toupper(changed)
[13:33:40.061]                 args <- list()
[13:33:40.061]                 for (kk in seq_along(NAMES)) {
[13:33:40.061]                   name <- changed[[kk]]
[13:33:40.061]                   NAME <- NAMES[[kk]]
[13:33:40.061]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.061]                     next
[13:33:40.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.061]                 }
[13:33:40.061]                 NAMES <- toupper(added)
[13:33:40.061]                 for (kk in seq_along(NAMES)) {
[13:33:40.061]                   name <- added[[kk]]
[13:33:40.061]                   NAME <- NAMES[[kk]]
[13:33:40.061]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.061]                     next
[13:33:40.061]                   args[[name]] <- ""
[13:33:40.061]                 }
[13:33:40.061]                 NAMES <- toupper(removed)
[13:33:40.061]                 for (kk in seq_along(NAMES)) {
[13:33:40.061]                   name <- removed[[kk]]
[13:33:40.061]                   NAME <- NAMES[[kk]]
[13:33:40.061]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.061]                     next
[13:33:40.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.061]                 }
[13:33:40.061]                 if (length(args) > 0) 
[13:33:40.061]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.061]             }
[13:33:40.061]             else {
[13:33:40.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.061]             }
[13:33:40.061]             {
[13:33:40.061]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.061]                   0L) {
[13:33:40.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.061]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.061]                   base::options(opts)
[13:33:40.061]                 }
[13:33:40.061]                 {
[13:33:40.061]                   {
[13:33:40.061]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:40.061]                     NULL
[13:33:40.061]                   }
[13:33:40.061]                   options(future.plan = NULL)
[13:33:40.061]                   if (is.na(NA_character_)) 
[13:33:40.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.061]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.061]                     .init = FALSE)
[13:33:40.061]                 }
[13:33:40.061]             }
[13:33:40.061]         }
[13:33:40.061]     })
[13:33:40.061]     if (TRUE) {
[13:33:40.061]         base::sink(type = "output", split = FALSE)
[13:33:40.061]         if (TRUE) {
[13:33:40.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.061]         }
[13:33:40.061]         else {
[13:33:40.061]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.061]         }
[13:33:40.061]         base::close(...future.stdout)
[13:33:40.061]         ...future.stdout <- NULL
[13:33:40.061]     }
[13:33:40.061]     ...future.result$conditions <- ...future.conditions
[13:33:40.061]     ...future.result$finished <- base::Sys.time()
[13:33:40.061]     ...future.result
[13:33:40.061] }
[13:33:40.064] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[13:33:40.065] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:40.065] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:40.065] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[13:33:40.106] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[13:33:40.107] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:33:40.107] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:33:40.107] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[13:33:40.108] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[13:33:40.108] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:40.108] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:40.108] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[13:33:40.109] MultisessionFuture started
[13:33:40.109] - Launch lazy future ... done
[13:33:40.109] run() for ‘MultisessionFuture’ ... done
[13:33:40.109] Created future:
[13:33:40.111] receiveMessageFromWorker() for ClusterFuture ...
[13:33:40.111] - Validating connection of MultisessionFuture
[13:33:40.111] - received message: FutureResult
[13:33:40.111] - Received FutureResult
[13:33:40.111] - Erased future from FutureRegistry
[13:33:40.112] result() for ClusterFuture ...
[13:33:40.112] - result already collected: FutureResult
[13:33:40.112] result() for ClusterFuture ... done
[13:33:40.112] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:40.109] MultisessionFuture:
[13:33:40.109] Label: ‘future_apply-1’
[13:33:40.109] Expression:
[13:33:40.109] {
[13:33:40.109]     do.call(function(...) {
[13:33:40.109]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.109]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.109]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.109]             on.exit(options(oopts), add = TRUE)
[13:33:40.109]         }
[13:33:40.109]         {
[13:33:40.109]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.109]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.109]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:40.109]                   envir = globalenv(), inherits = FALSE)
[13:33:40.109]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.109]             })
[13:33:40.109]         }
[13:33:40.109]     }, args = future.call.arguments)
[13:33:40.109] }
[13:33:40.109] Lazy evaluation: FALSE
[13:33:40.109] Asynchronous evaluation: TRUE
[13:33:40.109] Local evaluation: TRUE
[13:33:40.109] Environment: R_GlobalEnv
[13:33:40.109] Capture standard output: TRUE
[13:33:40.109] Capture condition classes: <none>
[13:33:40.109] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:40.109] Packages: <none>
[13:33:40.109] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:33:40.109] Resolved: TRUE
[13:33:40.109] Value: <not collected>
[13:33:40.109] Conditions captured: <none>
[13:33:40.109] Early signaling: FALSE
[13:33:40.109] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:40.109] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:40.112] Chunk #1 of 2 ... DONE
[13:33:40.112] Chunk #2 of 2 ...
[13:33:40.112]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:33:40.112]  - seeds: [1] <seeds>
[13:33:40.113]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.113] getGlobalsAndPackages() ...
[13:33:40.113] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.113] Resolving globals: FALSE
[13:33:40.113] Tweak future expression to call with '...' arguments ...
[13:33:40.113] {
[13:33:40.113]     do.call(function(...) {
[13:33:40.113]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.113]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.113]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.113]             on.exit(options(oopts), add = TRUE)
[13:33:40.113]         }
[13:33:40.113]         {
[13:33:40.113]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.113]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.113]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:40.113]                   envir = globalenv(), inherits = FALSE)
[13:33:40.113]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.113]             })
[13:33:40.113]         }
[13:33:40.113]     }, args = future.call.arguments)
[13:33:40.113] }
[13:33:40.113] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.114] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.114] 
[13:33:40.114] getGlobalsAndPackages() ... DONE
[13:33:40.114] run() for ‘Future’ ...
[13:33:40.114] - state: ‘created’
[13:33:40.114] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:40.128] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:40.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:40.128]   - Field: ‘node’
[13:33:40.128]   - Field: ‘label’
[13:33:40.128]   - Field: ‘local’
[13:33:40.128]   - Field: ‘owner’
[13:33:40.128]   - Field: ‘envir’
[13:33:40.129]   - Field: ‘workers’
[13:33:40.129]   - Field: ‘packages’
[13:33:40.129]   - Field: ‘gc’
[13:33:40.129]   - Field: ‘conditions’
[13:33:40.129]   - Field: ‘persistent’
[13:33:40.129]   - Field: ‘expr’
[13:33:40.129]   - Field: ‘uuid’
[13:33:40.129]   - Field: ‘seed’
[13:33:40.129]   - Field: ‘version’
[13:33:40.129]   - Field: ‘result’
[13:33:40.129]   - Field: ‘asynchronous’
[13:33:40.130]   - Field: ‘calls’
[13:33:40.130]   - Field: ‘globals’
[13:33:40.130]   - Field: ‘stdout’
[13:33:40.130]   - Field: ‘earlySignal’
[13:33:40.130]   - Field: ‘lazy’
[13:33:40.130]   - Field: ‘state’
[13:33:40.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:40.130] - Launch lazy future ...
[13:33:40.130] Packages needed by the future expression (n = 0): <none>
[13:33:40.131] Packages needed by future strategies (n = 0): <none>
[13:33:40.131] {
[13:33:40.131]     {
[13:33:40.131]         {
[13:33:40.131]             ...future.startTime <- base::Sys.time()
[13:33:40.131]             {
[13:33:40.131]                 {
[13:33:40.131]                   {
[13:33:40.131]                     {
[13:33:40.131]                       base::local({
[13:33:40.131]                         has_future <- base::requireNamespace("future", 
[13:33:40.131]                           quietly = TRUE)
[13:33:40.131]                         if (has_future) {
[13:33:40.131]                           ns <- base::getNamespace("future")
[13:33:40.131]                           version <- ns[[".package"]][["version"]]
[13:33:40.131]                           if (is.null(version)) 
[13:33:40.131]                             version <- utils::packageVersion("future")
[13:33:40.131]                         }
[13:33:40.131]                         else {
[13:33:40.131]                           version <- NULL
[13:33:40.131]                         }
[13:33:40.131]                         if (!has_future || version < "1.8.0") {
[13:33:40.131]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.131]                             "", base::R.version$version.string), 
[13:33:40.131]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:40.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.131]                               "release", "version")], collapse = " "), 
[13:33:40.131]                             hostname = base::Sys.info()[["nodename"]])
[13:33:40.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.131]                             info)
[13:33:40.131]                           info <- base::paste(info, collapse = "; ")
[13:33:40.131]                           if (!has_future) {
[13:33:40.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.131]                               info)
[13:33:40.131]                           }
[13:33:40.131]                           else {
[13:33:40.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.131]                               info, version)
[13:33:40.131]                           }
[13:33:40.131]                           base::stop(msg)
[13:33:40.131]                         }
[13:33:40.131]                       })
[13:33:40.131]                     }
[13:33:40.131]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:40.131]                     base::options(mc.cores = 1L)
[13:33:40.131]                   }
[13:33:40.131]                   ...future.strategy.old <- future::plan("list")
[13:33:40.131]                   options(future.plan = NULL)
[13:33:40.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.131]                 }
[13:33:40.131]                 ...future.workdir <- getwd()
[13:33:40.131]             }
[13:33:40.131]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.131]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.131]         }
[13:33:40.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.131]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:33:40.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.131]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.131]             base::names(...future.oldOptions))
[13:33:40.131]     }
[13:33:40.131]     if (FALSE) {
[13:33:40.131]     }
[13:33:40.131]     else {
[13:33:40.131]         if (TRUE) {
[13:33:40.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.131]                 open = "w")
[13:33:40.131]         }
[13:33:40.131]         else {
[13:33:40.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.131]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.131]         }
[13:33:40.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.131]             base::sink(type = "output", split = FALSE)
[13:33:40.131]             base::close(...future.stdout)
[13:33:40.131]         }, add = TRUE)
[13:33:40.131]     }
[13:33:40.131]     ...future.frame <- base::sys.nframe()
[13:33:40.131]     ...future.conditions <- base::list()
[13:33:40.131]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.131]     if (FALSE) {
[13:33:40.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.131]     }
[13:33:40.131]     ...future.result <- base::tryCatch({
[13:33:40.131]         base::withCallingHandlers({
[13:33:40.131]             ...future.value <- base::withVisible(base::local({
[13:33:40.131]                 ...future.makeSendCondition <- base::local({
[13:33:40.131]                   sendCondition <- NULL
[13:33:40.131]                   function(frame = 1L) {
[13:33:40.131]                     if (is.function(sendCondition)) 
[13:33:40.131]                       return(sendCondition)
[13:33:40.131]                     ns <- getNamespace("parallel")
[13:33:40.131]                     if (exists("sendData", mode = "function", 
[13:33:40.131]                       envir = ns)) {
[13:33:40.131]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:40.131]                         envir = ns)
[13:33:40.131]                       envir <- sys.frame(frame)
[13:33:40.131]                       master <- NULL
[13:33:40.131]                       while (!identical(envir, .GlobalEnv) && 
[13:33:40.131]                         !identical(envir, emptyenv())) {
[13:33:40.131]                         if (exists("master", mode = "list", envir = envir, 
[13:33:40.131]                           inherits = FALSE)) {
[13:33:40.131]                           master <- get("master", mode = "list", 
[13:33:40.131]                             envir = envir, inherits = FALSE)
[13:33:40.131]                           if (inherits(master, c("SOCKnode", 
[13:33:40.131]                             "SOCK0node"))) {
[13:33:40.131]                             sendCondition <<- function(cond) {
[13:33:40.131]                               data <- list(type = "VALUE", value = cond, 
[13:33:40.131]                                 success = TRUE)
[13:33:40.131]                               parallel_sendData(master, data)
[13:33:40.131]                             }
[13:33:40.131]                             return(sendCondition)
[13:33:40.131]                           }
[13:33:40.131]                         }
[13:33:40.131]                         frame <- frame + 1L
[13:33:40.131]                         envir <- sys.frame(frame)
[13:33:40.131]                       }
[13:33:40.131]                     }
[13:33:40.131]                     sendCondition <<- function(cond) NULL
[13:33:40.131]                   }
[13:33:40.131]                 })
[13:33:40.131]                 withCallingHandlers({
[13:33:40.131]                   {
[13:33:40.131]                     do.call(function(...) {
[13:33:40.131]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.131]                       if (!identical(...future.globals.maxSize.org, 
[13:33:40.131]                         ...future.globals.maxSize)) {
[13:33:40.131]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.131]                         on.exit(options(oopts), add = TRUE)
[13:33:40.131]                       }
[13:33:40.131]                       {
[13:33:40.131]                         lapply(seq_along(...future.elements_ii), 
[13:33:40.131]                           FUN = function(jj) {
[13:33:40.131]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.131]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:40.131]                               envir = globalenv(), inherits = FALSE)
[13:33:40.131]                             ...future.FUN(...future.X_jj, ...)
[13:33:40.131]                           })
[13:33:40.131]                       }
[13:33:40.131]                     }, args = future.call.arguments)
[13:33:40.131]                   }
[13:33:40.131]                 }, immediateCondition = function(cond) {
[13:33:40.131]                   sendCondition <- ...future.makeSendCondition()
[13:33:40.131]                   sendCondition(cond)
[13:33:40.131]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.131]                   {
[13:33:40.131]                     inherits <- base::inherits
[13:33:40.131]                     invokeRestart <- base::invokeRestart
[13:33:40.131]                     is.null <- base::is.null
[13:33:40.131]                     muffled <- FALSE
[13:33:40.131]                     if (inherits(cond, "message")) {
[13:33:40.131]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:40.131]                       if (muffled) 
[13:33:40.131]                         invokeRestart("muffleMessage")
[13:33:40.131]                     }
[13:33:40.131]                     else if (inherits(cond, "warning")) {
[13:33:40.131]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:40.131]                       if (muffled) 
[13:33:40.131]                         invokeRestart("muffleWarning")
[13:33:40.131]                     }
[13:33:40.131]                     else if (inherits(cond, "condition")) {
[13:33:40.131]                       if (!is.null(pattern)) {
[13:33:40.131]                         computeRestarts <- base::computeRestarts
[13:33:40.131]                         grepl <- base::grepl
[13:33:40.131]                         restarts <- computeRestarts(cond)
[13:33:40.131]                         for (restart in restarts) {
[13:33:40.131]                           name <- restart$name
[13:33:40.131]                           if (is.null(name)) 
[13:33:40.131]                             next
[13:33:40.131]                           if (!grepl(pattern, name)) 
[13:33:40.131]                             next
[13:33:40.131]                           invokeRestart(restart)
[13:33:40.131]                           muffled <- TRUE
[13:33:40.131]                           break
[13:33:40.131]                         }
[13:33:40.131]                       }
[13:33:40.131]                     }
[13:33:40.131]                     invisible(muffled)
[13:33:40.131]                   }
[13:33:40.131]                   muffleCondition(cond)
[13:33:40.131]                 })
[13:33:40.131]             }))
[13:33:40.131]             future::FutureResult(value = ...future.value$value, 
[13:33:40.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.131]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.131]                     ...future.globalenv.names))
[13:33:40.131]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.131]         }, condition = base::local({
[13:33:40.131]             c <- base::c
[13:33:40.131]             inherits <- base::inherits
[13:33:40.131]             invokeRestart <- base::invokeRestart
[13:33:40.131]             length <- base::length
[13:33:40.131]             list <- base::list
[13:33:40.131]             seq.int <- base::seq.int
[13:33:40.131]             signalCondition <- base::signalCondition
[13:33:40.131]             sys.calls <- base::sys.calls
[13:33:40.131]             `[[` <- base::`[[`
[13:33:40.131]             `+` <- base::`+`
[13:33:40.131]             `<<-` <- base::`<<-`
[13:33:40.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.131]                   3L)]
[13:33:40.131]             }
[13:33:40.131]             function(cond) {
[13:33:40.131]                 is_error <- inherits(cond, "error")
[13:33:40.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.131]                   NULL)
[13:33:40.131]                 if (is_error) {
[13:33:40.131]                   sessionInformation <- function() {
[13:33:40.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.131]                       search = base::search(), system = base::Sys.info())
[13:33:40.131]                   }
[13:33:40.131]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.131]                     cond$call), session = sessionInformation(), 
[13:33:40.131]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.131]                   signalCondition(cond)
[13:33:40.131]                 }
[13:33:40.131]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:33:40.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.131]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.131]                   if (TRUE && !signal) {
[13:33:40.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.131]                     {
[13:33:40.131]                       inherits <- base::inherits
[13:33:40.131]                       invokeRestart <- base::invokeRestart
[13:33:40.131]                       is.null <- base::is.null
[13:33:40.131]                       muffled <- FALSE
[13:33:40.131]                       if (inherits(cond, "message")) {
[13:33:40.131]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.131]                         if (muffled) 
[13:33:40.131]                           invokeRestart("muffleMessage")
[13:33:40.131]                       }
[13:33:40.131]                       else if (inherits(cond, "warning")) {
[13:33:40.131]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.131]                         if (muffled) 
[13:33:40.131]                           invokeRestart("muffleWarning")
[13:33:40.131]                       }
[13:33:40.131]                       else if (inherits(cond, "condition")) {
[13:33:40.131]                         if (!is.null(pattern)) {
[13:33:40.131]                           computeRestarts <- base::computeRestarts
[13:33:40.131]                           grepl <- base::grepl
[13:33:40.131]                           restarts <- computeRestarts(cond)
[13:33:40.131]                           for (restart in restarts) {
[13:33:40.131]                             name <- restart$name
[13:33:40.131]                             if (is.null(name)) 
[13:33:40.131]                               next
[13:33:40.131]                             if (!grepl(pattern, name)) 
[13:33:40.131]                               next
[13:33:40.131]                             invokeRestart(restart)
[13:33:40.131]                             muffled <- TRUE
[13:33:40.131]                             break
[13:33:40.131]                           }
[13:33:40.131]                         }
[13:33:40.131]                       }
[13:33:40.131]                       invisible(muffled)
[13:33:40.131]                     }
[13:33:40.131]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.131]                   }
[13:33:40.131]                 }
[13:33:40.131]                 else {
[13:33:40.131]                   if (TRUE) {
[13:33:40.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.131]                     {
[13:33:40.131]                       inherits <- base::inherits
[13:33:40.131]                       invokeRestart <- base::invokeRestart
[13:33:40.131]                       is.null <- base::is.null
[13:33:40.131]                       muffled <- FALSE
[13:33:40.131]                       if (inherits(cond, "message")) {
[13:33:40.131]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.131]                         if (muffled) 
[13:33:40.131]                           invokeRestart("muffleMessage")
[13:33:40.131]                       }
[13:33:40.131]                       else if (inherits(cond, "warning")) {
[13:33:40.131]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.131]                         if (muffled) 
[13:33:40.131]                           invokeRestart("muffleWarning")
[13:33:40.131]                       }
[13:33:40.131]                       else if (inherits(cond, "condition")) {
[13:33:40.131]                         if (!is.null(pattern)) {
[13:33:40.131]                           computeRestarts <- base::computeRestarts
[13:33:40.131]                           grepl <- base::grepl
[13:33:40.131]                           restarts <- computeRestarts(cond)
[13:33:40.131]                           for (restart in restarts) {
[13:33:40.131]                             name <- restart$name
[13:33:40.131]                             if (is.null(name)) 
[13:33:40.131]                               next
[13:33:40.131]                             if (!grepl(pattern, name)) 
[13:33:40.131]                               next
[13:33:40.131]                             invokeRestart(restart)
[13:33:40.131]                             muffled <- TRUE
[13:33:40.131]                             break
[13:33:40.131]                           }
[13:33:40.131]                         }
[13:33:40.131]                       }
[13:33:40.131]                       invisible(muffled)
[13:33:40.131]                     }
[13:33:40.131]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.131]                   }
[13:33:40.131]                 }
[13:33:40.131]             }
[13:33:40.131]         }))
[13:33:40.131]     }, error = function(ex) {
[13:33:40.131]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.131]                 ...future.rng), started = ...future.startTime, 
[13:33:40.131]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.131]             version = "1.8"), class = "FutureResult")
[13:33:40.131]     }, finally = {
[13:33:40.131]         if (!identical(...future.workdir, getwd())) 
[13:33:40.131]             setwd(...future.workdir)
[13:33:40.131]         {
[13:33:40.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.131]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.131]             }
[13:33:40.131]             base::options(...future.oldOptions)
[13:33:40.131]             if (.Platform$OS.type == "windows") {
[13:33:40.131]                 old_names <- names(...future.oldEnvVars)
[13:33:40.131]                 envs <- base::Sys.getenv()
[13:33:40.131]                 names <- names(envs)
[13:33:40.131]                 common <- intersect(names, old_names)
[13:33:40.131]                 added <- setdiff(names, old_names)
[13:33:40.131]                 removed <- setdiff(old_names, names)
[13:33:40.131]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.131]                   envs[common]]
[13:33:40.131]                 NAMES <- toupper(changed)
[13:33:40.131]                 args <- list()
[13:33:40.131]                 for (kk in seq_along(NAMES)) {
[13:33:40.131]                   name <- changed[[kk]]
[13:33:40.131]                   NAME <- NAMES[[kk]]
[13:33:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.131]                     next
[13:33:40.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.131]                 }
[13:33:40.131]                 NAMES <- toupper(added)
[13:33:40.131]                 for (kk in seq_along(NAMES)) {
[13:33:40.131]                   name <- added[[kk]]
[13:33:40.131]                   NAME <- NAMES[[kk]]
[13:33:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.131]                     next
[13:33:40.131]                   args[[name]] <- ""
[13:33:40.131]                 }
[13:33:40.131]                 NAMES <- toupper(removed)
[13:33:40.131]                 for (kk in seq_along(NAMES)) {
[13:33:40.131]                   name <- removed[[kk]]
[13:33:40.131]                   NAME <- NAMES[[kk]]
[13:33:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.131]                     next
[13:33:40.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.131]                 }
[13:33:40.131]                 if (length(args) > 0) 
[13:33:40.131]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.131]             }
[13:33:40.131]             else {
[13:33:40.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.131]             }
[13:33:40.131]             {
[13:33:40.131]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.131]                   0L) {
[13:33:40.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.131]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.131]                   base::options(opts)
[13:33:40.131]                 }
[13:33:40.131]                 {
[13:33:40.131]                   {
[13:33:40.131]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:40.131]                     NULL
[13:33:40.131]                   }
[13:33:40.131]                   options(future.plan = NULL)
[13:33:40.131]                   if (is.na(NA_character_)) 
[13:33:40.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.131]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.131]                     .init = FALSE)
[13:33:40.131]                 }
[13:33:40.131]             }
[13:33:40.131]         }
[13:33:40.131]     })
[13:33:40.131]     if (TRUE) {
[13:33:40.131]         base::sink(type = "output", split = FALSE)
[13:33:40.131]         if (TRUE) {
[13:33:40.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.131]         }
[13:33:40.131]         else {
[13:33:40.131]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.131]         }
[13:33:40.131]         base::close(...future.stdout)
[13:33:40.131]         ...future.stdout <- NULL
[13:33:40.131]     }
[13:33:40.131]     ...future.result$conditions <- ...future.conditions
[13:33:40.131]     ...future.result$finished <- base::Sys.time()
[13:33:40.131]     ...future.result
[13:33:40.131] }
[13:33:40.134] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[13:33:40.134] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:40.134] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:40.134] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[13:33:40.178] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[13:33:40.179] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:33:40.179] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:33:40.179] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[13:33:40.180] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[13:33:40.180] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:33:40.180] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:33:40.180] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[13:33:40.181] MultisessionFuture started
[13:33:40.181] - Launch lazy future ... done
[13:33:40.181] run() for ‘MultisessionFuture’ ... done
[13:33:40.181] Created future:
[13:33:40.181] MultisessionFuture:
[13:33:40.181] Label: ‘future_apply-2’
[13:33:40.181] Expression:
[13:33:40.181] {
[13:33:40.181]     do.call(function(...) {
[13:33:40.181]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.181]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.181]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.181]             on.exit(options(oopts), add = TRUE)
[13:33:40.181]         }
[13:33:40.181]         {
[13:33:40.181]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.181]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.181]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:33:40.181]                   envir = globalenv(), inherits = FALSE)
[13:33:40.181]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.181]             })
[13:33:40.181]         }
[13:33:40.181]     }, args = future.call.arguments)
[13:33:40.181] }
[13:33:40.181] Lazy evaluation: FALSE
[13:33:40.181] Asynchronous evaluation: TRUE
[13:33:40.181] Local evaluation: TRUE
[13:33:40.181] Environment: R_GlobalEnv
[13:33:40.181] Capture standard output: TRUE
[13:33:40.181] Capture condition classes: <none>
[13:33:40.181] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:33:40.181] Packages: <none>
[13:33:40.181] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:33:40.181] Resolved: FALSE
[13:33:40.181] Value: <not collected>
[13:33:40.181] Conditions captured: <none>
[13:33:40.181] Early signaling: FALSE
[13:33:40.181] Owner process: 4ab88642-a84e-4223-ee54-a994fec86053
[13:33:40.181] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:40.192] Chunk #2 of 2 ... DONE
[13:33:40.192] Launching 2 futures (chunks) ... DONE
[13:33:40.193] Resolving 2 futures (chunks) ...
[13:33:40.193] resolve() on list ...
[13:33:40.193]  recursive: 0
[13:33:40.193]  length: 2
[13:33:40.193] 
[13:33:40.195] Future #1
[13:33:40.195] result() for ClusterFuture ...
[13:33:40.195] - result already collected: FutureResult
[13:33:40.196] result() for ClusterFuture ... done
[13:33:40.196] result() for ClusterFuture ...
[13:33:40.196] - result already collected: FutureResult
[13:33:40.196] result() for ClusterFuture ... done
[13:33:40.196] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:40.196] - nx: 2
[13:33:40.196] - relay: TRUE
[13:33:40.196] - stdout: TRUE
[13:33:40.196] - signal: TRUE
[13:33:40.196] - resignal: FALSE
[13:33:40.196] - force: TRUE
[13:33:40.196] - relayed: [n=2] FALSE, FALSE
[13:33:40.197] - queued futures: [n=2] FALSE, FALSE
[13:33:40.197]  - until=1
[13:33:40.197]  - relaying element #1
[13:33:40.197] result() for ClusterFuture ...
[13:33:40.197] - result already collected: FutureResult
[13:33:40.197] result() for ClusterFuture ... done
[13:33:40.197] result() for ClusterFuture ...
[13:33:40.197] - result already collected: FutureResult
[13:33:40.197] result() for ClusterFuture ... done
[13:33:40.197] result() for ClusterFuture ...
[13:33:40.197] - result already collected: FutureResult
[13:33:40.198] result() for ClusterFuture ... done
[13:33:40.198] result() for ClusterFuture ...
[13:33:40.198] - result already collected: FutureResult
[13:33:40.198] result() for ClusterFuture ... done
[13:33:40.198] - relayed: [n=2] TRUE, FALSE
[13:33:40.198] - queued futures: [n=2] TRUE, FALSE
[13:33:40.198] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:40.198]  length: 1 (resolved future 1)
[13:33:40.223] receiveMessageFromWorker() for ClusterFuture ...
[13:33:40.224] - Validating connection of MultisessionFuture
[13:33:40.224] - received message: FutureResult
[13:33:40.224] - Received FutureResult
[13:33:40.224] - Erased future from FutureRegistry
[13:33:40.224] result() for ClusterFuture ...
[13:33:40.224] - result already collected: FutureResult
[13:33:40.224] result() for ClusterFuture ... done
[13:33:40.225] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:40.225] Future #2
[13:33:40.225] result() for ClusterFuture ...
[13:33:40.225] - result already collected: FutureResult
[13:33:40.225] result() for ClusterFuture ... done
[13:33:40.225] result() for ClusterFuture ...
[13:33:40.225] - result already collected: FutureResult
[13:33:40.225] result() for ClusterFuture ... done
[13:33:40.225] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:40.225] - nx: 2
[13:33:40.225] - relay: TRUE
[13:33:40.225] - stdout: TRUE
[13:33:40.226] - signal: TRUE
[13:33:40.226] - resignal: FALSE
[13:33:40.226] - force: TRUE
[13:33:40.226] - relayed: [n=2] TRUE, FALSE
[13:33:40.226] - queued futures: [n=2] TRUE, FALSE
[13:33:40.226]  - until=2
[13:33:40.226]  - relaying element #2
[13:33:40.226] result() for ClusterFuture ...
[13:33:40.226] - result already collected: FutureResult
[13:33:40.226] result() for ClusterFuture ... done
[13:33:40.226] result() for ClusterFuture ...
[13:33:40.227] - result already collected: FutureResult
[13:33:40.227] result() for ClusterFuture ... done
[13:33:40.227] result() for ClusterFuture ...
[13:33:40.227] - result already collected: FutureResult
[13:33:40.227] result() for ClusterFuture ... done
[13:33:40.227] result() for ClusterFuture ...
[13:33:40.227] - result already collected: FutureResult
[13:33:40.227] result() for ClusterFuture ... done
[13:33:40.227] - relayed: [n=2] TRUE, TRUE
[13:33:40.227] - queued futures: [n=2] TRUE, TRUE
[13:33:40.227] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:40.228]  length: 0 (resolved future 2)
[13:33:40.228] Relaying remaining futures
[13:33:40.228] signalConditionsASAP(NULL, pos=0) ...
[13:33:40.228] - nx: 2
[13:33:40.228] - relay: TRUE
[13:33:40.228] - stdout: TRUE
[13:33:40.228] - signal: TRUE
[13:33:40.228] - resignal: FALSE
[13:33:40.228] - force: TRUE
[13:33:40.228] - relayed: [n=2] TRUE, TRUE
[13:33:40.228] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:40.228] - relayed: [n=2] TRUE, TRUE
[13:33:40.229] - queued futures: [n=2] TRUE, TRUE
[13:33:40.229] signalConditionsASAP(NULL, pos=0) ... done
[13:33:40.229] resolve() on list ... DONE
[13:33:40.229] result() for ClusterFuture ...
[13:33:40.229] - result already collected: FutureResult
[13:33:40.229] result() for ClusterFuture ... done
[13:33:40.229] result() for ClusterFuture ...
[13:33:40.229] - result already collected: FutureResult
[13:33:40.229] result() for ClusterFuture ... done
[13:33:40.229] result() for ClusterFuture ...
[13:33:40.229] - result already collected: FutureResult
[13:33:40.229] result() for ClusterFuture ... done
[13:33:40.230] result() for ClusterFuture ...
[13:33:40.230] - result already collected: FutureResult
[13:33:40.230] result() for ClusterFuture ... done
[13:33:40.230]  - Number of value chunks collected: 2
[13:33:40.230] Resolving 2 futures (chunks) ... DONE
[13:33:40.230] Reducing values from 2 chunks ...
[13:33:40.230]  - Number of values collected after concatenation: 2
[13:33:40.230]  - Number of values expected: 2
[13:33:40.230] Reducing values from 2 chunks ... DONE
[13:33:40.230] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[13:33:40.231] plan(): Setting new future strategy stack:
[13:33:40.231] List of future strategies:
[13:33:40.231] 1. sequential:
[13:33:40.231]    - args: function (..., envir = parent.frame())
[13:33:40.231]    - tweaked: FALSE
[13:33:40.231]    - call: plan(sequential)
[13:33:40.231] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[13:33:40.233] plan(): Setting new future strategy stack:
[13:33:40.233] List of future strategies:
[13:33:40.233] 1. FutureStrategy:
[13:33:40.233]    - args: function (..., envir = parent.frame())
[13:33:40.233]    - tweaked: FALSE
[13:33:40.233]    - call: future::plan(oplan)
[13:33:40.234] plan(): nbrOfWorkers() = 1
> 
