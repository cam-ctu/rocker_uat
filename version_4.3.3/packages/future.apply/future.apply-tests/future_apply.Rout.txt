
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:17:41.279] plan(): Setting new future strategy stack:
[16:17:41.280] List of future strategies:
[16:17:41.280] 1. sequential:
[16:17:41.280]    - args: function (..., envir = parent.frame())
[16:17:41.280]    - tweaked: FALSE
[16:17:41.280]    - call: future::plan("sequential")
[16:17:41.293] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:17:41.349] plan(): Setting new future strategy stack:
[16:17:41.350] List of future strategies:
[16:17:41.350] 1. sequential:
[16:17:41.350]    - args: function (..., envir = parent.frame())
[16:17:41.350]    - tweaked: FALSE
[16:17:41.350]    - call: plan(strategy)
[16:17:41.360] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[16:17:41.361] getGlobalsAndPackagesXApply() ...
[16:17:41.361]  - future.globals: TRUE
[16:17:41.362] getGlobalsAndPackages() ...
[16:17:41.362] Searching for globals...
[16:17:41.400] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:17:41.401] Searching for globals ... DONE
[16:17:41.401] Resolving globals: FALSE
[16:17:41.403] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:17:41.403] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:17:41.404] - globals: [1] ‘FUN’
[16:17:41.404] 
[16:17:41.404] getGlobalsAndPackages() ... DONE
[16:17:41.404]  - globals found/used: [n=1] ‘FUN’
[16:17:41.404]  - needed namespaces: [n=0] 
[16:17:41.404] Finding globals ... DONE
[16:17:41.404]  - use_args: TRUE
[16:17:41.404]  - Getting '...' globals ...
[16:17:41.405] resolve() on list ...
[16:17:41.405]  recursive: 0
[16:17:41.406]  length: 1
[16:17:41.406]  elements: ‘...’
[16:17:41.406]  length: 0 (resolved future 1)
[16:17:41.406] resolve() on list ... DONE
[16:17:41.406]    - '...' content: [n=0] 
[16:17:41.406] List of 1
[16:17:41.406]  $ ...: list()
[16:17:41.406]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.406]  - attr(*, "where")=List of 1
[16:17:41.406]   ..$ ...:<environment: 0x555be21adf38> 
[16:17:41.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.406]  - attr(*, "resolved")= logi TRUE
[16:17:41.406]  - attr(*, "total_size")= num NA
[16:17:41.411]  - Getting '...' globals ... DONE
[16:17:41.411] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.411] List of 2
[16:17:41.411]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:41.411]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:41.411]  $ ...          : list()
[16:17:41.411]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.411]  - attr(*, "where")=List of 2
[16:17:41.411]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.411]   ..$ ...          :<environment: 0x555be21adf38> 
[16:17:41.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.411]  - attr(*, "resolved")= logi FALSE
[16:17:41.411]  - attr(*, "total_size")= num 354224
[16:17:41.414] Packages to be attached in all futures: [n=0] 
[16:17:41.414] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.414] future_lapply() ...
[16:17:41.450] Number of chunks: 1
[16:17:41.450] getGlobalsAndPackagesXApply() ...
[16:17:41.450]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.451]  - use_args: TRUE
[16:17:41.451] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.451] List of 2
[16:17:41.451]  $ ...          : list()
[16:17:41.451]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.451]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:41.451]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:41.451]  - attr(*, "where")=List of 2
[16:17:41.451]   ..$ ...          :<environment: 0x555be21adf38> 
[16:17:41.451]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:41.451]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.451]  - attr(*, "resolved")= logi FALSE
[16:17:41.451]  - attr(*, "total_size")= num NA
[16:17:41.456] Packages to be attached in all futures: [n=0] 
[16:17:41.456] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.456] Number of futures (= number of chunks): 1
[16:17:41.457] Launching 1 futures (chunks) ...
[16:17:41.457] Chunk #1 of 1 ...
[16:17:41.457]  - seeds: <none>
[16:17:41.457]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.458] getGlobalsAndPackages() ...
[16:17:41.458] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.458] Resolving globals: FALSE
[16:17:41.458] Tweak future expression to call with '...' arguments ...
[16:17:41.458] {
[16:17:41.458]     do.call(function(...) {
[16:17:41.458]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.458]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.458]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.458]             on.exit(options(oopts), add = TRUE)
[16:17:41.458]         }
[16:17:41.458]         {
[16:17:41.458]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.458]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.458]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.458]             })
[16:17:41.458]         }
[16:17:41.458]     }, args = future.call.arguments)
[16:17:41.458] }
[16:17:41.459] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.459] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.459] 
[16:17:41.460] getGlobalsAndPackages() ... DONE
[16:17:41.461] run() for ‘Future’ ...
[16:17:41.461] - state: ‘created’
[16:17:41.461] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:41.462] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:41.462]   - Field: ‘label’
[16:17:41.462]   - Field: ‘local’
[16:17:41.462]   - Field: ‘owner’
[16:17:41.462]   - Field: ‘envir’
[16:17:41.463]   - Field: ‘packages’
[16:17:41.463]   - Field: ‘gc’
[16:17:41.463]   - Field: ‘conditions’
[16:17:41.463]   - Field: ‘expr’
[16:17:41.463]   - Field: ‘uuid’
[16:17:41.463]   - Field: ‘seed’
[16:17:41.463]   - Field: ‘version’
[16:17:41.464]   - Field: ‘result’
[16:17:41.464]   - Field: ‘asynchronous’
[16:17:41.464]   - Field: ‘calls’
[16:17:41.464]   - Field: ‘globals’
[16:17:41.464]   - Field: ‘stdout’
[16:17:41.464]   - Field: ‘earlySignal’
[16:17:41.464]   - Field: ‘lazy’
[16:17:41.465]   - Field: ‘state’
[16:17:41.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:41.465] - Launch lazy future ...
[16:17:41.466] Packages needed by the future expression (n = 0): <none>
[16:17:41.466] Packages needed by future strategies (n = 0): <none>
[16:17:41.467] {
[16:17:41.467]     {
[16:17:41.467]         {
[16:17:41.467]             ...future.startTime <- base::Sys.time()
[16:17:41.467]             {
[16:17:41.467]                 {
[16:17:41.467]                   {
[16:17:41.467]                     base::local({
[16:17:41.467]                       has_future <- base::requireNamespace("future", 
[16:17:41.467]                         quietly = TRUE)
[16:17:41.467]                       if (has_future) {
[16:17:41.467]                         ns <- base::getNamespace("future")
[16:17:41.467]                         version <- ns[[".package"]][["version"]]
[16:17:41.467]                         if (is.null(version)) 
[16:17:41.467]                           version <- utils::packageVersion("future")
[16:17:41.467]                       }
[16:17:41.467]                       else {
[16:17:41.467]                         version <- NULL
[16:17:41.467]                       }
[16:17:41.467]                       if (!has_future || version < "1.8.0") {
[16:17:41.467]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:41.467]                           "", base::R.version$version.string), 
[16:17:41.467]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:41.467]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:41.467]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:41.467]                             "release", "version")], collapse = " "), 
[16:17:41.467]                           hostname = base::Sys.info()[["nodename"]])
[16:17:41.467]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:41.467]                           info)
[16:17:41.467]                         info <- base::paste(info, collapse = "; ")
[16:17:41.467]                         if (!has_future) {
[16:17:41.467]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:41.467]                             info)
[16:17:41.467]                         }
[16:17:41.467]                         else {
[16:17:41.467]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:41.467]                             info, version)
[16:17:41.467]                         }
[16:17:41.467]                         base::stop(msg)
[16:17:41.467]                       }
[16:17:41.467]                     })
[16:17:41.467]                   }
[16:17:41.467]                   ...future.strategy.old <- future::plan("list")
[16:17:41.467]                   options(future.plan = NULL)
[16:17:41.467]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.467]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:41.467]                 }
[16:17:41.467]                 ...future.workdir <- getwd()
[16:17:41.467]             }
[16:17:41.467]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:41.467]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:41.467]         }
[16:17:41.467]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:41.467]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:41.467]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:41.467]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:41.467]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:41.467]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:41.467]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:41.467]             base::names(...future.oldOptions))
[16:17:41.467]     }
[16:17:41.467]     if (FALSE) {
[16:17:41.467]     }
[16:17:41.467]     else {
[16:17:41.467]         if (TRUE) {
[16:17:41.467]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:41.467]                 open = "w")
[16:17:41.467]         }
[16:17:41.467]         else {
[16:17:41.467]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:41.467]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:41.467]         }
[16:17:41.467]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:41.467]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:41.467]             base::sink(type = "output", split = FALSE)
[16:17:41.467]             base::close(...future.stdout)
[16:17:41.467]         }, add = TRUE)
[16:17:41.467]     }
[16:17:41.467]     ...future.frame <- base::sys.nframe()
[16:17:41.467]     ...future.conditions <- base::list()
[16:17:41.467]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:41.467]     if (FALSE) {
[16:17:41.467]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:41.467]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:41.467]     }
[16:17:41.467]     ...future.result <- base::tryCatch({
[16:17:41.467]         base::withCallingHandlers({
[16:17:41.467]             ...future.value <- base::withVisible(base::local({
[16:17:41.467]                 do.call(function(...) {
[16:17:41.467]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.467]                   if (!identical(...future.globals.maxSize.org, 
[16:17:41.467]                     ...future.globals.maxSize)) {
[16:17:41.467]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.467]                     on.exit(options(oopts), add = TRUE)
[16:17:41.467]                   }
[16:17:41.467]                   {
[16:17:41.467]                     lapply(seq_along(...future.elements_ii), 
[16:17:41.467]                       FUN = function(jj) {
[16:17:41.467]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.467]                         ...future.FUN(...future.X_jj, ...)
[16:17:41.467]                       })
[16:17:41.467]                   }
[16:17:41.467]                 }, args = future.call.arguments)
[16:17:41.467]             }))
[16:17:41.467]             future::FutureResult(value = ...future.value$value, 
[16:17:41.467]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.467]                   ...future.rng), globalenv = if (FALSE) 
[16:17:41.467]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:41.467]                     ...future.globalenv.names))
[16:17:41.467]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:41.467]         }, condition = base::local({
[16:17:41.467]             c <- base::c
[16:17:41.467]             inherits <- base::inherits
[16:17:41.467]             invokeRestart <- base::invokeRestart
[16:17:41.467]             length <- base::length
[16:17:41.467]             list <- base::list
[16:17:41.467]             seq.int <- base::seq.int
[16:17:41.467]             signalCondition <- base::signalCondition
[16:17:41.467]             sys.calls <- base::sys.calls
[16:17:41.467]             `[[` <- base::`[[`
[16:17:41.467]             `+` <- base::`+`
[16:17:41.467]             `<<-` <- base::`<<-`
[16:17:41.467]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:41.467]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:41.467]                   3L)]
[16:17:41.467]             }
[16:17:41.467]             function(cond) {
[16:17:41.467]                 is_error <- inherits(cond, "error")
[16:17:41.467]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:41.467]                   NULL)
[16:17:41.467]                 if (is_error) {
[16:17:41.467]                   sessionInformation <- function() {
[16:17:41.467]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:41.467]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:41.467]                       search = base::search(), system = base::Sys.info())
[16:17:41.467]                   }
[16:17:41.467]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.467]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:41.467]                     cond$call), session = sessionInformation(), 
[16:17:41.467]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:41.467]                   signalCondition(cond)
[16:17:41.467]                 }
[16:17:41.467]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:41.467]                 "immediateCondition"))) {
[16:17:41.467]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:41.467]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.467]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:41.467]                   if (TRUE && !signal) {
[16:17:41.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.467]                     {
[16:17:41.467]                       inherits <- base::inherits
[16:17:41.467]                       invokeRestart <- base::invokeRestart
[16:17:41.467]                       is.null <- base::is.null
[16:17:41.467]                       muffled <- FALSE
[16:17:41.467]                       if (inherits(cond, "message")) {
[16:17:41.467]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.467]                         if (muffled) 
[16:17:41.467]                           invokeRestart("muffleMessage")
[16:17:41.467]                       }
[16:17:41.467]                       else if (inherits(cond, "warning")) {
[16:17:41.467]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.467]                         if (muffled) 
[16:17:41.467]                           invokeRestart("muffleWarning")
[16:17:41.467]                       }
[16:17:41.467]                       else if (inherits(cond, "condition")) {
[16:17:41.467]                         if (!is.null(pattern)) {
[16:17:41.467]                           computeRestarts <- base::computeRestarts
[16:17:41.467]                           grepl <- base::grepl
[16:17:41.467]                           restarts <- computeRestarts(cond)
[16:17:41.467]                           for (restart in restarts) {
[16:17:41.467]                             name <- restart$name
[16:17:41.467]                             if (is.null(name)) 
[16:17:41.467]                               next
[16:17:41.467]                             if (!grepl(pattern, name)) 
[16:17:41.467]                               next
[16:17:41.467]                             invokeRestart(restart)
[16:17:41.467]                             muffled <- TRUE
[16:17:41.467]                             break
[16:17:41.467]                           }
[16:17:41.467]                         }
[16:17:41.467]                       }
[16:17:41.467]                       invisible(muffled)
[16:17:41.467]                     }
[16:17:41.467]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.467]                   }
[16:17:41.467]                 }
[16:17:41.467]                 else {
[16:17:41.467]                   if (TRUE) {
[16:17:41.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.467]                     {
[16:17:41.467]                       inherits <- base::inherits
[16:17:41.467]                       invokeRestart <- base::invokeRestart
[16:17:41.467]                       is.null <- base::is.null
[16:17:41.467]                       muffled <- FALSE
[16:17:41.467]                       if (inherits(cond, "message")) {
[16:17:41.467]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.467]                         if (muffled) 
[16:17:41.467]                           invokeRestart("muffleMessage")
[16:17:41.467]                       }
[16:17:41.467]                       else if (inherits(cond, "warning")) {
[16:17:41.467]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.467]                         if (muffled) 
[16:17:41.467]                           invokeRestart("muffleWarning")
[16:17:41.467]                       }
[16:17:41.467]                       else if (inherits(cond, "condition")) {
[16:17:41.467]                         if (!is.null(pattern)) {
[16:17:41.467]                           computeRestarts <- base::computeRestarts
[16:17:41.467]                           grepl <- base::grepl
[16:17:41.467]                           restarts <- computeRestarts(cond)
[16:17:41.467]                           for (restart in restarts) {
[16:17:41.467]                             name <- restart$name
[16:17:41.467]                             if (is.null(name)) 
[16:17:41.467]                               next
[16:17:41.467]                             if (!grepl(pattern, name)) 
[16:17:41.467]                               next
[16:17:41.467]                             invokeRestart(restart)
[16:17:41.467]                             muffled <- TRUE
[16:17:41.467]                             break
[16:17:41.467]                           }
[16:17:41.467]                         }
[16:17:41.467]                       }
[16:17:41.467]                       invisible(muffled)
[16:17:41.467]                     }
[16:17:41.467]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.467]                   }
[16:17:41.467]                 }
[16:17:41.467]             }
[16:17:41.467]         }))
[16:17:41.467]     }, error = function(ex) {
[16:17:41.467]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:41.467]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.467]                 ...future.rng), started = ...future.startTime, 
[16:17:41.467]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:41.467]             version = "1.8"), class = "FutureResult")
[16:17:41.467]     }, finally = {
[16:17:41.467]         if (!identical(...future.workdir, getwd())) 
[16:17:41.467]             setwd(...future.workdir)
[16:17:41.467]         {
[16:17:41.467]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:41.467]                 ...future.oldOptions$nwarnings <- NULL
[16:17:41.467]             }
[16:17:41.467]             base::options(...future.oldOptions)
[16:17:41.467]             if (.Platform$OS.type == "windows") {
[16:17:41.467]                 old_names <- names(...future.oldEnvVars)
[16:17:41.467]                 envs <- base::Sys.getenv()
[16:17:41.467]                 names <- names(envs)
[16:17:41.467]                 common <- intersect(names, old_names)
[16:17:41.467]                 added <- setdiff(names, old_names)
[16:17:41.467]                 removed <- setdiff(old_names, names)
[16:17:41.467]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:41.467]                   envs[common]]
[16:17:41.467]                 NAMES <- toupper(changed)
[16:17:41.467]                 args <- list()
[16:17:41.467]                 for (kk in seq_along(NAMES)) {
[16:17:41.467]                   name <- changed[[kk]]
[16:17:41.467]                   NAME <- NAMES[[kk]]
[16:17:41.467]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.467]                     next
[16:17:41.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.467]                 }
[16:17:41.467]                 NAMES <- toupper(added)
[16:17:41.467]                 for (kk in seq_along(NAMES)) {
[16:17:41.467]                   name <- added[[kk]]
[16:17:41.467]                   NAME <- NAMES[[kk]]
[16:17:41.467]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.467]                     next
[16:17:41.467]                   args[[name]] <- ""
[16:17:41.467]                 }
[16:17:41.467]                 NAMES <- toupper(removed)
[16:17:41.467]                 for (kk in seq_along(NAMES)) {
[16:17:41.467]                   name <- removed[[kk]]
[16:17:41.467]                   NAME <- NAMES[[kk]]
[16:17:41.467]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.467]                     next
[16:17:41.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.467]                 }
[16:17:41.467]                 if (length(args) > 0) 
[16:17:41.467]                   base::do.call(base::Sys.setenv, args = args)
[16:17:41.467]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:41.467]             }
[16:17:41.467]             else {
[16:17:41.467]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:41.467]             }
[16:17:41.467]             {
[16:17:41.467]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:41.467]                   0L) {
[16:17:41.467]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:41.467]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:41.467]                   base::options(opts)
[16:17:41.467]                 }
[16:17:41.467]                 {
[16:17:41.467]                   {
[16:17:41.467]                     NULL
[16:17:41.467]                     RNGkind("Mersenne-Twister")
[16:17:41.467]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:41.467]                       inherits = FALSE)
[16:17:41.467]                   }
[16:17:41.467]                   options(future.plan = NULL)
[16:17:41.467]                   if (is.na(NA_character_)) 
[16:17:41.467]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.467]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:41.467]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:41.467]                     .init = FALSE)
[16:17:41.467]                 }
[16:17:41.467]             }
[16:17:41.467]         }
[16:17:41.467]     })
[16:17:41.467]     if (TRUE) {
[16:17:41.467]         base::sink(type = "output", split = FALSE)
[16:17:41.467]         if (TRUE) {
[16:17:41.467]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:41.467]         }
[16:17:41.467]         else {
[16:17:41.467]             ...future.result["stdout"] <- base::list(NULL)
[16:17:41.467]         }
[16:17:41.467]         base::close(...future.stdout)
[16:17:41.467]         ...future.stdout <- NULL
[16:17:41.467]     }
[16:17:41.467]     ...future.result$conditions <- ...future.conditions
[16:17:41.467]     ...future.result$finished <- base::Sys.time()
[16:17:41.467]     ...future.result
[16:17:41.467] }
[16:17:41.470] assign_globals() ...
[16:17:41.470] List of 5
[16:17:41.470]  $ future.call.arguments    : list()
[16:17:41.470]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.470]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:41.470]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:41.470]  $ ...future.elements_ii    :List of 2
[16:17:41.470]   ..$ : num [1:4] 1 3 1 7
[16:17:41.470]   ..$ : num [1:4] 2 4 6 8
[16:17:41.470]  $ ...future.seeds_ii       : NULL
[16:17:41.470]  $ ...future.globals.maxSize: num Inf
[16:17:41.470]  - attr(*, "resolved")= logi FALSE
[16:17:41.470]  - attr(*, "total_size")= num NA
[16:17:41.470]  - attr(*, "where")=List of 5
[16:17:41.470]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:41.470]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:41.470]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:41.470]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:41.470]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:41.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.470]  - attr(*, "already-done")= logi TRUE
[16:17:41.477] - copied ‘future.call.arguments’ to environment
[16:17:41.478] - copied ‘...future.FUN’ to environment
[16:17:41.478] - copied ‘...future.elements_ii’ to environment
[16:17:41.478] - copied ‘...future.seeds_ii’ to environment
[16:17:41.478] - copied ‘...future.globals.maxSize’ to environment
[16:17:41.478] assign_globals() ... done
[16:17:41.479] plan(): Setting new future strategy stack:
[16:17:41.479] List of future strategies:
[16:17:41.479] 1. sequential:
[16:17:41.479]    - args: function (..., envir = parent.frame())
[16:17:41.479]    - tweaked: FALSE
[16:17:41.479]    - call: NULL
[16:17:41.479] plan(): nbrOfWorkers() = 1
[16:17:41.481] plan(): Setting new future strategy stack:
[16:17:41.481] List of future strategies:
[16:17:41.481] 1. sequential:
[16:17:41.481]    - args: function (..., envir = parent.frame())
[16:17:41.481]    - tweaked: FALSE
[16:17:41.481]    - call: plan(strategy)
[16:17:41.481] plan(): nbrOfWorkers() = 1
[16:17:41.481] SequentialFuture started (and completed)
[16:17:41.482] - Launch lazy future ... done
[16:17:41.482] run() for ‘SequentialFuture’ ... done
[16:17:41.482] Created future:
[16:17:41.482] SequentialFuture:
[16:17:41.482] Label: ‘future_apply-1’
[16:17:41.482] Expression:
[16:17:41.482] {
[16:17:41.482]     do.call(function(...) {
[16:17:41.482]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.482]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.482]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.482]             on.exit(options(oopts), add = TRUE)
[16:17:41.482]         }
[16:17:41.482]         {
[16:17:41.482]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.482]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.482]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.482]             })
[16:17:41.482]         }
[16:17:41.482]     }, args = future.call.arguments)
[16:17:41.482] }
[16:17:41.482] Lazy evaluation: FALSE
[16:17:41.482] Asynchronous evaluation: FALSE
[16:17:41.482] Local evaluation: TRUE
[16:17:41.482] Environment: R_GlobalEnv
[16:17:41.482] Capture standard output: TRUE
[16:17:41.482] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:41.482] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:41.482] Packages: <none>
[16:17:41.482] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:41.482] Resolved: TRUE
[16:17:41.482] Value: 2.21 KiB of class ‘list’
[16:17:41.482] Early signaling: FALSE
[16:17:41.482] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:41.482] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.486] Chunk #1 of 1 ... DONE
[16:17:41.486] Launching 1 futures (chunks) ... DONE
[16:17:41.486] Resolving 1 futures (chunks) ...
[16:17:41.486] resolve() on list ...
[16:17:41.486]  recursive: 0
[16:17:41.486]  length: 1
[16:17:41.486] 
[16:17:41.486] resolved() for ‘SequentialFuture’ ...
[16:17:41.487] - state: ‘finished’
[16:17:41.487] - run: TRUE
[16:17:41.487] - result: ‘FutureResult’
[16:17:41.487] resolved() for ‘SequentialFuture’ ... done
[16:17:41.487] Future #1
[16:17:41.487] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:41.487] - nx: 1
[16:17:41.488] - relay: TRUE
[16:17:41.488] - stdout: TRUE
[16:17:41.488] - signal: TRUE
[16:17:41.488] - resignal: FALSE
[16:17:41.488] - force: TRUE
[16:17:41.488] - relayed: [n=1] FALSE
[16:17:41.488] - queued futures: [n=1] FALSE
[16:17:41.488]  - until=1
[16:17:41.488]  - relaying element #1
[16:17:41.488] - relayed: [n=1] TRUE
[16:17:41.488] - queued futures: [n=1] TRUE
[16:17:41.489] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:41.489]  length: 0 (resolved future 1)
[16:17:41.489] Relaying remaining futures
[16:17:41.489] signalConditionsASAP(NULL, pos=0) ...
[16:17:41.489] - nx: 1
[16:17:41.489] - relay: TRUE
[16:17:41.489] - stdout: TRUE
[16:17:41.489] - signal: TRUE
[16:17:41.489] - resignal: FALSE
[16:17:41.489] - force: TRUE
[16:17:41.490] - relayed: [n=1] TRUE
[16:17:41.490] - queued futures: [n=1] TRUE
 - flush all
[16:17:41.490] - relayed: [n=1] TRUE
[16:17:41.490] - queued futures: [n=1] TRUE
[16:17:41.490] signalConditionsASAP(NULL, pos=0) ... done
[16:17:41.490] resolve() on list ... DONE
[16:17:41.490]  - Number of value chunks collected: 1
[16:17:41.490] Resolving 1 futures (chunks) ... DONE
[16:17:41.490] Reducing values from 1 chunks ...
[16:17:41.490]  - Number of values collected after concatenation: 2
[16:17:41.491]  - Number of values expected: 2
[16:17:41.491] Reducing values from 1 chunks ... DONE
[16:17:41.491] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:17:41.492] getGlobalsAndPackagesXApply() ...
[16:17:41.492]  - future.globals: TRUE
[16:17:41.492] getGlobalsAndPackages() ...
[16:17:41.492] Searching for globals...
[16:17:41.524] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:17:41.524] Searching for globals ... DONE
[16:17:41.525] Resolving globals: FALSE
[16:17:41.526] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:17:41.526] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:17:41.527] - globals: [1] ‘FUN’
[16:17:41.527] 
[16:17:41.527] getGlobalsAndPackages() ... DONE
[16:17:41.527]  - globals found/used: [n=1] ‘FUN’
[16:17:41.527]  - needed namespaces: [n=0] 
[16:17:41.527] Finding globals ... DONE
[16:17:41.527]  - use_args: TRUE
[16:17:41.527]  - Getting '...' globals ...
[16:17:41.528] resolve() on list ...
[16:17:41.528]  recursive: 0
[16:17:41.528]  length: 1
[16:17:41.528]  elements: ‘...’
[16:17:41.528]  length: 0 (resolved future 1)
[16:17:41.528] resolve() on list ... DONE
[16:17:41.528]    - '...' content: [n=0] 
[16:17:41.528] List of 1
[16:17:41.528]  $ ...: list()
[16:17:41.528]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.528]  - attr(*, "where")=List of 1
[16:17:41.528]   ..$ ...:<environment: 0x555be01cc5d8> 
[16:17:41.528]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.528]  - attr(*, "resolved")= logi TRUE
[16:17:41.528]  - attr(*, "total_size")= num NA
[16:17:41.531]  - Getting '...' globals ... DONE
[16:17:41.531] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.531] List of 2
[16:17:41.531]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:41.531]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:41.531]  $ ...          : list()
[16:17:41.531]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.531]  - attr(*, "where")=List of 2
[16:17:41.531]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.531]   ..$ ...          :<environment: 0x555be01cc5d8> 
[16:17:41.531]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.531]  - attr(*, "resolved")= logi FALSE
[16:17:41.531]  - attr(*, "total_size")= num 354224
[16:17:41.533] Packages to be attached in all futures: [n=0] 
[16:17:41.533] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.534] future_lapply() ...
[16:17:41.563] Number of chunks: 1
[16:17:41.563] getGlobalsAndPackagesXApply() ...
[16:17:41.563]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.563]  - use_args: TRUE
[16:17:41.563] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.563] List of 2
[16:17:41.563]  $ ...          : list()
[16:17:41.563]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.563]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:41.563]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:41.563]  - attr(*, "where")=List of 2
[16:17:41.563]   ..$ ...          :<environment: 0x555be01cc5d8> 
[16:17:41.563]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:41.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.563]  - attr(*, "resolved")= logi FALSE
[16:17:41.563]  - attr(*, "total_size")= num NA
[16:17:41.566] Packages to be attached in all futures: [n=0] 
[16:17:41.566] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.567] Number of futures (= number of chunks): 1
[16:17:41.567] Launching 1 futures (chunks) ...
[16:17:41.567] Chunk #1 of 1 ...
[16:17:41.567]  - seeds: <none>
[16:17:41.567]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.567] getGlobalsAndPackages() ...
[16:17:41.567] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.567] Resolving globals: FALSE
[16:17:41.567] Tweak future expression to call with '...' arguments ...
[16:17:41.568] {
[16:17:41.568]     do.call(function(...) {
[16:17:41.568]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.568]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.568]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.568]             on.exit(options(oopts), add = TRUE)
[16:17:41.568]         }
[16:17:41.568]         {
[16:17:41.568]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.568]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.568]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.568]             })
[16:17:41.568]         }
[16:17:41.568]     }, args = future.call.arguments)
[16:17:41.568] }
[16:17:41.568] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.568] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.568] 
[16:17:41.568] getGlobalsAndPackages() ... DONE
[16:17:41.569] run() for ‘Future’ ...
[16:17:41.569] - state: ‘created’
[16:17:41.569] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:41.569] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.569] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:41.569]   - Field: ‘label’
[16:17:41.569]   - Field: ‘local’
[16:17:41.569]   - Field: ‘owner’
[16:17:41.570]   - Field: ‘envir’
[16:17:41.570]   - Field: ‘packages’
[16:17:41.570]   - Field: ‘gc’
[16:17:41.570]   - Field: ‘conditions’
[16:17:41.570]   - Field: ‘expr’
[16:17:41.570]   - Field: ‘uuid’
[16:17:41.570]   - Field: ‘seed’
[16:17:41.570]   - Field: ‘version’
[16:17:41.570]   - Field: ‘result’
[16:17:41.570]   - Field: ‘asynchronous’
[16:17:41.570]   - Field: ‘calls’
[16:17:41.571]   - Field: ‘globals’
[16:17:41.571]   - Field: ‘stdout’
[16:17:41.571]   - Field: ‘earlySignal’
[16:17:41.571]   - Field: ‘lazy’
[16:17:41.571]   - Field: ‘state’
[16:17:41.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:41.571] - Launch lazy future ...
[16:17:41.571] Packages needed by the future expression (n = 0): <none>
[16:17:41.571] Packages needed by future strategies (n = 0): <none>
[16:17:41.572] {
[16:17:41.572]     {
[16:17:41.572]         {
[16:17:41.572]             ...future.startTime <- base::Sys.time()
[16:17:41.572]             {
[16:17:41.572]                 {
[16:17:41.572]                   {
[16:17:41.572]                     base::local({
[16:17:41.572]                       has_future <- base::requireNamespace("future", 
[16:17:41.572]                         quietly = TRUE)
[16:17:41.572]                       if (has_future) {
[16:17:41.572]                         ns <- base::getNamespace("future")
[16:17:41.572]                         version <- ns[[".package"]][["version"]]
[16:17:41.572]                         if (is.null(version)) 
[16:17:41.572]                           version <- utils::packageVersion("future")
[16:17:41.572]                       }
[16:17:41.572]                       else {
[16:17:41.572]                         version <- NULL
[16:17:41.572]                       }
[16:17:41.572]                       if (!has_future || version < "1.8.0") {
[16:17:41.572]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:41.572]                           "", base::R.version$version.string), 
[16:17:41.572]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:41.572]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:41.572]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:41.572]                             "release", "version")], collapse = " "), 
[16:17:41.572]                           hostname = base::Sys.info()[["nodename"]])
[16:17:41.572]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:41.572]                           info)
[16:17:41.572]                         info <- base::paste(info, collapse = "; ")
[16:17:41.572]                         if (!has_future) {
[16:17:41.572]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:41.572]                             info)
[16:17:41.572]                         }
[16:17:41.572]                         else {
[16:17:41.572]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:41.572]                             info, version)
[16:17:41.572]                         }
[16:17:41.572]                         base::stop(msg)
[16:17:41.572]                       }
[16:17:41.572]                     })
[16:17:41.572]                   }
[16:17:41.572]                   ...future.strategy.old <- future::plan("list")
[16:17:41.572]                   options(future.plan = NULL)
[16:17:41.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:41.572]                 }
[16:17:41.572]                 ...future.workdir <- getwd()
[16:17:41.572]             }
[16:17:41.572]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:41.572]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:41.572]         }
[16:17:41.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:41.572]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:41.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:41.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:41.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:41.572]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:41.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:41.572]             base::names(...future.oldOptions))
[16:17:41.572]     }
[16:17:41.572]     if (FALSE) {
[16:17:41.572]     }
[16:17:41.572]     else {
[16:17:41.572]         if (TRUE) {
[16:17:41.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:41.572]                 open = "w")
[16:17:41.572]         }
[16:17:41.572]         else {
[16:17:41.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:41.572]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:41.572]         }
[16:17:41.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:41.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:41.572]             base::sink(type = "output", split = FALSE)
[16:17:41.572]             base::close(...future.stdout)
[16:17:41.572]         }, add = TRUE)
[16:17:41.572]     }
[16:17:41.572]     ...future.frame <- base::sys.nframe()
[16:17:41.572]     ...future.conditions <- base::list()
[16:17:41.572]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:41.572]     if (FALSE) {
[16:17:41.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:41.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:41.572]     }
[16:17:41.572]     ...future.result <- base::tryCatch({
[16:17:41.572]         base::withCallingHandlers({
[16:17:41.572]             ...future.value <- base::withVisible(base::local({
[16:17:41.572]                 do.call(function(...) {
[16:17:41.572]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.572]                   if (!identical(...future.globals.maxSize.org, 
[16:17:41.572]                     ...future.globals.maxSize)) {
[16:17:41.572]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.572]                     on.exit(options(oopts), add = TRUE)
[16:17:41.572]                   }
[16:17:41.572]                   {
[16:17:41.572]                     lapply(seq_along(...future.elements_ii), 
[16:17:41.572]                       FUN = function(jj) {
[16:17:41.572]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.572]                         ...future.FUN(...future.X_jj, ...)
[16:17:41.572]                       })
[16:17:41.572]                   }
[16:17:41.572]                 }, args = future.call.arguments)
[16:17:41.572]             }))
[16:17:41.572]             future::FutureResult(value = ...future.value$value, 
[16:17:41.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.572]                   ...future.rng), globalenv = if (FALSE) 
[16:17:41.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:41.572]                     ...future.globalenv.names))
[16:17:41.572]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:41.572]         }, condition = base::local({
[16:17:41.572]             c <- base::c
[16:17:41.572]             inherits <- base::inherits
[16:17:41.572]             invokeRestart <- base::invokeRestart
[16:17:41.572]             length <- base::length
[16:17:41.572]             list <- base::list
[16:17:41.572]             seq.int <- base::seq.int
[16:17:41.572]             signalCondition <- base::signalCondition
[16:17:41.572]             sys.calls <- base::sys.calls
[16:17:41.572]             `[[` <- base::`[[`
[16:17:41.572]             `+` <- base::`+`
[16:17:41.572]             `<<-` <- base::`<<-`
[16:17:41.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:41.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:41.572]                   3L)]
[16:17:41.572]             }
[16:17:41.572]             function(cond) {
[16:17:41.572]                 is_error <- inherits(cond, "error")
[16:17:41.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:41.572]                   NULL)
[16:17:41.572]                 if (is_error) {
[16:17:41.572]                   sessionInformation <- function() {
[16:17:41.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:41.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:41.572]                       search = base::search(), system = base::Sys.info())
[16:17:41.572]                   }
[16:17:41.572]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:41.572]                     cond$call), session = sessionInformation(), 
[16:17:41.572]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:41.572]                   signalCondition(cond)
[16:17:41.572]                 }
[16:17:41.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:41.572]                 "immediateCondition"))) {
[16:17:41.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:41.572]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:41.572]                   if (TRUE && !signal) {
[16:17:41.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.572]                     {
[16:17:41.572]                       inherits <- base::inherits
[16:17:41.572]                       invokeRestart <- base::invokeRestart
[16:17:41.572]                       is.null <- base::is.null
[16:17:41.572]                       muffled <- FALSE
[16:17:41.572]                       if (inherits(cond, "message")) {
[16:17:41.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.572]                         if (muffled) 
[16:17:41.572]                           invokeRestart("muffleMessage")
[16:17:41.572]                       }
[16:17:41.572]                       else if (inherits(cond, "warning")) {
[16:17:41.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.572]                         if (muffled) 
[16:17:41.572]                           invokeRestart("muffleWarning")
[16:17:41.572]                       }
[16:17:41.572]                       else if (inherits(cond, "condition")) {
[16:17:41.572]                         if (!is.null(pattern)) {
[16:17:41.572]                           computeRestarts <- base::computeRestarts
[16:17:41.572]                           grepl <- base::grepl
[16:17:41.572]                           restarts <- computeRestarts(cond)
[16:17:41.572]                           for (restart in restarts) {
[16:17:41.572]                             name <- restart$name
[16:17:41.572]                             if (is.null(name)) 
[16:17:41.572]                               next
[16:17:41.572]                             if (!grepl(pattern, name)) 
[16:17:41.572]                               next
[16:17:41.572]                             invokeRestart(restart)
[16:17:41.572]                             muffled <- TRUE
[16:17:41.572]                             break
[16:17:41.572]                           }
[16:17:41.572]                         }
[16:17:41.572]                       }
[16:17:41.572]                       invisible(muffled)
[16:17:41.572]                     }
[16:17:41.572]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.572]                   }
[16:17:41.572]                 }
[16:17:41.572]                 else {
[16:17:41.572]                   if (TRUE) {
[16:17:41.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.572]                     {
[16:17:41.572]                       inherits <- base::inherits
[16:17:41.572]                       invokeRestart <- base::invokeRestart
[16:17:41.572]                       is.null <- base::is.null
[16:17:41.572]                       muffled <- FALSE
[16:17:41.572]                       if (inherits(cond, "message")) {
[16:17:41.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.572]                         if (muffled) 
[16:17:41.572]                           invokeRestart("muffleMessage")
[16:17:41.572]                       }
[16:17:41.572]                       else if (inherits(cond, "warning")) {
[16:17:41.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.572]                         if (muffled) 
[16:17:41.572]                           invokeRestart("muffleWarning")
[16:17:41.572]                       }
[16:17:41.572]                       else if (inherits(cond, "condition")) {
[16:17:41.572]                         if (!is.null(pattern)) {
[16:17:41.572]                           computeRestarts <- base::computeRestarts
[16:17:41.572]                           grepl <- base::grepl
[16:17:41.572]                           restarts <- computeRestarts(cond)
[16:17:41.572]                           for (restart in restarts) {
[16:17:41.572]                             name <- restart$name
[16:17:41.572]                             if (is.null(name)) 
[16:17:41.572]                               next
[16:17:41.572]                             if (!grepl(pattern, name)) 
[16:17:41.572]                               next
[16:17:41.572]                             invokeRestart(restart)
[16:17:41.572]                             muffled <- TRUE
[16:17:41.572]                             break
[16:17:41.572]                           }
[16:17:41.572]                         }
[16:17:41.572]                       }
[16:17:41.572]                       invisible(muffled)
[16:17:41.572]                     }
[16:17:41.572]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.572]                   }
[16:17:41.572]                 }
[16:17:41.572]             }
[16:17:41.572]         }))
[16:17:41.572]     }, error = function(ex) {
[16:17:41.572]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:41.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.572]                 ...future.rng), started = ...future.startTime, 
[16:17:41.572]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:41.572]             version = "1.8"), class = "FutureResult")
[16:17:41.572]     }, finally = {
[16:17:41.572]         if (!identical(...future.workdir, getwd())) 
[16:17:41.572]             setwd(...future.workdir)
[16:17:41.572]         {
[16:17:41.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:41.572]                 ...future.oldOptions$nwarnings <- NULL
[16:17:41.572]             }
[16:17:41.572]             base::options(...future.oldOptions)
[16:17:41.572]             if (.Platform$OS.type == "windows") {
[16:17:41.572]                 old_names <- names(...future.oldEnvVars)
[16:17:41.572]                 envs <- base::Sys.getenv()
[16:17:41.572]                 names <- names(envs)
[16:17:41.572]                 common <- intersect(names, old_names)
[16:17:41.572]                 added <- setdiff(names, old_names)
[16:17:41.572]                 removed <- setdiff(old_names, names)
[16:17:41.572]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:41.572]                   envs[common]]
[16:17:41.572]                 NAMES <- toupper(changed)
[16:17:41.572]                 args <- list()
[16:17:41.572]                 for (kk in seq_along(NAMES)) {
[16:17:41.572]                   name <- changed[[kk]]
[16:17:41.572]                   NAME <- NAMES[[kk]]
[16:17:41.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.572]                     next
[16:17:41.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.572]                 }
[16:17:41.572]                 NAMES <- toupper(added)
[16:17:41.572]                 for (kk in seq_along(NAMES)) {
[16:17:41.572]                   name <- added[[kk]]
[16:17:41.572]                   NAME <- NAMES[[kk]]
[16:17:41.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.572]                     next
[16:17:41.572]                   args[[name]] <- ""
[16:17:41.572]                 }
[16:17:41.572]                 NAMES <- toupper(removed)
[16:17:41.572]                 for (kk in seq_along(NAMES)) {
[16:17:41.572]                   name <- removed[[kk]]
[16:17:41.572]                   NAME <- NAMES[[kk]]
[16:17:41.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.572]                     next
[16:17:41.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.572]                 }
[16:17:41.572]                 if (length(args) > 0) 
[16:17:41.572]                   base::do.call(base::Sys.setenv, args = args)
[16:17:41.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:41.572]             }
[16:17:41.572]             else {
[16:17:41.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:41.572]             }
[16:17:41.572]             {
[16:17:41.572]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:41.572]                   0L) {
[16:17:41.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:41.572]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:41.572]                   base::options(opts)
[16:17:41.572]                 }
[16:17:41.572]                 {
[16:17:41.572]                   {
[16:17:41.572]                     NULL
[16:17:41.572]                     RNGkind("Mersenne-Twister")
[16:17:41.572]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:41.572]                       inherits = FALSE)
[16:17:41.572]                   }
[16:17:41.572]                   options(future.plan = NULL)
[16:17:41.572]                   if (is.na(NA_character_)) 
[16:17:41.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:41.572]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:41.572]                     .init = FALSE)
[16:17:41.572]                 }
[16:17:41.572]             }
[16:17:41.572]         }
[16:17:41.572]     })
[16:17:41.572]     if (TRUE) {
[16:17:41.572]         base::sink(type = "output", split = FALSE)
[16:17:41.572]         if (TRUE) {
[16:17:41.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:41.572]         }
[16:17:41.572]         else {
[16:17:41.572]             ...future.result["stdout"] <- base::list(NULL)
[16:17:41.572]         }
[16:17:41.572]         base::close(...future.stdout)
[16:17:41.572]         ...future.stdout <- NULL
[16:17:41.572]     }
[16:17:41.572]     ...future.result$conditions <- ...future.conditions
[16:17:41.572]     ...future.result$finished <- base::Sys.time()
[16:17:41.572]     ...future.result
[16:17:41.572] }
[16:17:41.573] assign_globals() ...
[16:17:41.573] List of 5
[16:17:41.573]  $ future.call.arguments    : list()
[16:17:41.573]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.573]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:41.573]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:41.573]  $ ...future.elements_ii    :List of 2
[16:17:41.573]   ..$ : num [1:4] 1 3 1 7
[16:17:41.573]   ..$ : num [1:4] 2 4 6 8
[16:17:41.573]  $ ...future.seeds_ii       : NULL
[16:17:41.573]  $ ...future.globals.maxSize: num Inf
[16:17:41.573]  - attr(*, "resolved")= logi FALSE
[16:17:41.573]  - attr(*, "total_size")= num NA
[16:17:41.573]  - attr(*, "where")=List of 5
[16:17:41.573]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:41.573]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:41.573]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:41.573]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:41.573]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:41.573]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.573]  - attr(*, "already-done")= logi TRUE
[16:17:41.579] - copied ‘future.call.arguments’ to environment
[16:17:41.579] - copied ‘...future.FUN’ to environment
[16:17:41.579] - copied ‘...future.elements_ii’ to environment
[16:17:41.579] - copied ‘...future.seeds_ii’ to environment
[16:17:41.579] - copied ‘...future.globals.maxSize’ to environment
[16:17:41.579] assign_globals() ... done
[16:17:41.580] plan(): Setting new future strategy stack:
[16:17:41.580] List of future strategies:
[16:17:41.580] 1. sequential:
[16:17:41.580]    - args: function (..., envir = parent.frame())
[16:17:41.580]    - tweaked: FALSE
[16:17:41.580]    - call: NULL
[16:17:41.580] plan(): nbrOfWorkers() = 1
[16:17:41.581] plan(): Setting new future strategy stack:
[16:17:41.581] List of future strategies:
[16:17:41.581] 1. sequential:
[16:17:41.581]    - args: function (..., envir = parent.frame())
[16:17:41.581]    - tweaked: FALSE
[16:17:41.581]    - call: plan(strategy)
[16:17:41.581] plan(): nbrOfWorkers() = 1
[16:17:41.582] SequentialFuture started (and completed)
[16:17:41.582] - Launch lazy future ... done
[16:17:41.582] run() for ‘SequentialFuture’ ... done
[16:17:41.582] Created future:
[16:17:41.582] SequentialFuture:
[16:17:41.582] Label: ‘future_apply-1’
[16:17:41.582] Expression:
[16:17:41.582] {
[16:17:41.582]     do.call(function(...) {
[16:17:41.582]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.582]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.582]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.582]             on.exit(options(oopts), add = TRUE)
[16:17:41.582]         }
[16:17:41.582]         {
[16:17:41.582]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.582]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.582]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.582]             })
[16:17:41.582]         }
[16:17:41.582]     }, args = future.call.arguments)
[16:17:41.582] }
[16:17:41.582] Lazy evaluation: FALSE
[16:17:41.582] Asynchronous evaluation: FALSE
[16:17:41.582] Local evaluation: TRUE
[16:17:41.582] Environment: R_GlobalEnv
[16:17:41.582] Capture standard output: TRUE
[16:17:41.582] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:41.582] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:41.582] Packages: <none>
[16:17:41.582] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:41.582] Resolved: TRUE
[16:17:41.582] Value: 2.21 KiB of class ‘list’
[16:17:41.582] Early signaling: FALSE
[16:17:41.582] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:41.582] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.583] Chunk #1 of 1 ... DONE
[16:17:41.583] Launching 1 futures (chunks) ... DONE
[16:17:41.583] Resolving 1 futures (chunks) ...
[16:17:41.583] resolve() on list ...
[16:17:41.583]  recursive: 0
[16:17:41.583]  length: 1
[16:17:41.583] 
[16:17:41.584] resolved() for ‘SequentialFuture’ ...
[16:17:41.584] - state: ‘finished’
[16:17:41.584] - run: TRUE
[16:17:41.584] - result: ‘FutureResult’
[16:17:41.584] resolved() for ‘SequentialFuture’ ... done
[16:17:41.584] Future #1
[16:17:41.584] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:41.584] - nx: 1
[16:17:41.584] - relay: TRUE
[16:17:41.584] - stdout: TRUE
[16:17:41.585] - signal: TRUE
[16:17:41.585] - resignal: FALSE
[16:17:41.585] - force: TRUE
[16:17:41.585] - relayed: [n=1] FALSE
[16:17:41.585] - queued futures: [n=1] FALSE
[16:17:41.585]  - until=1
[16:17:41.585]  - relaying element #1
[16:17:41.585] - relayed: [n=1] TRUE
[16:17:41.585] - queued futures: [n=1] TRUE
[16:17:41.585] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:41.585]  length: 0 (resolved future 1)
[16:17:41.586] Relaying remaining futures
[16:17:41.586] signalConditionsASAP(NULL, pos=0) ...
[16:17:41.586] - nx: 1
[16:17:41.586] - relay: TRUE
[16:17:41.586] - stdout: TRUE
[16:17:41.586] - signal: TRUE
[16:17:41.586] - resignal: FALSE
[16:17:41.586] - force: TRUE
[16:17:41.586] - relayed: [n=1] TRUE
[16:17:41.586] - queued futures: [n=1] TRUE
 - flush all
[16:17:41.586] - relayed: [n=1] TRUE
[16:17:41.586] - queued futures: [n=1] TRUE
[16:17:41.587] signalConditionsASAP(NULL, pos=0) ... done
[16:17:41.587] resolve() on list ... DONE
[16:17:41.587]  - Number of value chunks collected: 1
[16:17:41.587] Resolving 1 futures (chunks) ... DONE
[16:17:41.587] Reducing values from 1 chunks ...
[16:17:41.587]  - Number of values collected after concatenation: 2
[16:17:41.587]  - Number of values expected: 2
[16:17:41.587] Reducing values from 1 chunks ... DONE
[16:17:41.587] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:17:41.590] getGlobalsAndPackagesXApply() ...
[16:17:41.590]  - future.globals: TRUE
[16:17:41.590] getGlobalsAndPackages() ...
[16:17:41.590] Searching for globals...
[16:17:41.591] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:41.591] Searching for globals ... DONE
[16:17:41.591] Resolving globals: FALSE
[16:17:41.591] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:41.592] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:41.592] - globals: [1] ‘FUN’
[16:17:41.592] - packages: [1] ‘stats’
[16:17:41.592] getGlobalsAndPackages() ... DONE
[16:17:41.592]  - globals found/used: [n=1] ‘FUN’
[16:17:41.592]  - needed namespaces: [n=1] ‘stats’
[16:17:41.592] Finding globals ... DONE
[16:17:41.592]  - use_args: TRUE
[16:17:41.592]  - Getting '...' globals ...
[16:17:41.593] resolve() on list ...
[16:17:41.593]  recursive: 0
[16:17:41.593]  length: 1
[16:17:41.593]  elements: ‘...’
[16:17:41.593]  length: 0 (resolved future 1)
[16:17:41.593] resolve() on list ... DONE
[16:17:41.593]    - '...' content: [n=0] 
[16:17:41.593] List of 1
[16:17:41.593]  $ ...: list()
[16:17:41.593]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.593]  - attr(*, "where")=List of 1
[16:17:41.593]   ..$ ...:<environment: 0x555be20c8dd0> 
[16:17:41.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.593]  - attr(*, "resolved")= logi TRUE
[16:17:41.593]  - attr(*, "total_size")= num NA
[16:17:41.596]  - Getting '...' globals ... DONE
[16:17:41.596] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.596] List of 2
[16:17:41.596]  $ ...future.FUN:function (x, ...)  
[16:17:41.596]  $ ...          : list()
[16:17:41.596]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.596]  - attr(*, "where")=List of 2
[16:17:41.596]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.596]   ..$ ...          :<environment: 0x555be20c8dd0> 
[16:17:41.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.596]  - attr(*, "resolved")= logi FALSE
[16:17:41.596]  - attr(*, "total_size")= num 1248
[16:17:41.598] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:41.599] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.599] future_lapply() ...
[16:17:41.600] Number of chunks: 1
[16:17:41.600] getGlobalsAndPackagesXApply() ...
[16:17:41.600]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.600]  - use_args: TRUE
[16:17:41.600] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.601] List of 2
[16:17:41.601]  $ ...          : list()
[16:17:41.601]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.601]  $ ...future.FUN:function (x, ...)  
[16:17:41.601]  - attr(*, "where")=List of 2
[16:17:41.601]   ..$ ...          :<environment: 0x555be20c8dd0> 
[16:17:41.601]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:17:41.601]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.601]  - attr(*, "resolved")= logi FALSE
[16:17:41.601]  - attr(*, "total_size")= num NA
[16:17:41.603] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:41.603] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.603] Number of futures (= number of chunks): 1
[16:17:41.603] Launching 1 futures (chunks) ...
[16:17:41.604] Chunk #1 of 1 ...
[16:17:41.604]  - seeds: <none>
[16:17:41.604]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.604] getGlobalsAndPackages() ...
[16:17:41.604] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.604] Resolving globals: FALSE
[16:17:41.604] Tweak future expression to call with '...' arguments ...
[16:17:41.604] {
[16:17:41.604]     do.call(function(...) {
[16:17:41.604]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.604]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.604]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.604]             on.exit(options(oopts), add = TRUE)
[16:17:41.604]         }
[16:17:41.604]         {
[16:17:41.604]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.604]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.604]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.604]             })
[16:17:41.604]         }
[16:17:41.604]     }, args = future.call.arguments)
[16:17:41.604] }
[16:17:41.605] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.605] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.605] - packages: [1] ‘stats’
[16:17:41.605] getGlobalsAndPackages() ... DONE
[16:17:41.605] run() for ‘Future’ ...
[16:17:41.606] - state: ‘created’
[16:17:41.606] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:41.606] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:41.606]   - Field: ‘label’
[16:17:41.606]   - Field: ‘local’
[16:17:41.606]   - Field: ‘owner’
[16:17:41.606]   - Field: ‘envir’
[16:17:41.606]   - Field: ‘packages’
[16:17:41.607]   - Field: ‘gc’
[16:17:41.607]   - Field: ‘conditions’
[16:17:41.607]   - Field: ‘expr’
[16:17:41.607]   - Field: ‘uuid’
[16:17:41.607]   - Field: ‘seed’
[16:17:41.607]   - Field: ‘version’
[16:17:41.607]   - Field: ‘result’
[16:17:41.607]   - Field: ‘asynchronous’
[16:17:41.607]   - Field: ‘calls’
[16:17:41.607]   - Field: ‘globals’
[16:17:41.607]   - Field: ‘stdout’
[16:17:41.607]   - Field: ‘earlySignal’
[16:17:41.608]   - Field: ‘lazy’
[16:17:41.608]   - Field: ‘state’
[16:17:41.608] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:41.608] - Launch lazy future ...
[16:17:41.608] Packages needed by the future expression (n = 1): ‘stats’
[16:17:41.608] Packages needed by future strategies (n = 0): <none>
[16:17:41.609] {
[16:17:41.609]     {
[16:17:41.609]         {
[16:17:41.609]             ...future.startTime <- base::Sys.time()
[16:17:41.609]             {
[16:17:41.609]                 {
[16:17:41.609]                   {
[16:17:41.609]                     {
[16:17:41.609]                       base::local({
[16:17:41.609]                         has_future <- base::requireNamespace("future", 
[16:17:41.609]                           quietly = TRUE)
[16:17:41.609]                         if (has_future) {
[16:17:41.609]                           ns <- base::getNamespace("future")
[16:17:41.609]                           version <- ns[[".package"]][["version"]]
[16:17:41.609]                           if (is.null(version)) 
[16:17:41.609]                             version <- utils::packageVersion("future")
[16:17:41.609]                         }
[16:17:41.609]                         else {
[16:17:41.609]                           version <- NULL
[16:17:41.609]                         }
[16:17:41.609]                         if (!has_future || version < "1.8.0") {
[16:17:41.609]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:41.609]                             "", base::R.version$version.string), 
[16:17:41.609]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:41.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:41.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:41.609]                               "release", "version")], collapse = " "), 
[16:17:41.609]                             hostname = base::Sys.info()[["nodename"]])
[16:17:41.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:41.609]                             info)
[16:17:41.609]                           info <- base::paste(info, collapse = "; ")
[16:17:41.609]                           if (!has_future) {
[16:17:41.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:41.609]                               info)
[16:17:41.609]                           }
[16:17:41.609]                           else {
[16:17:41.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:41.609]                               info, version)
[16:17:41.609]                           }
[16:17:41.609]                           base::stop(msg)
[16:17:41.609]                         }
[16:17:41.609]                       })
[16:17:41.609]                     }
[16:17:41.609]                     base::local({
[16:17:41.609]                       for (pkg in "stats") {
[16:17:41.609]                         base::loadNamespace(pkg)
[16:17:41.609]                         base::library(pkg, character.only = TRUE)
[16:17:41.609]                       }
[16:17:41.609]                     })
[16:17:41.609]                   }
[16:17:41.609]                   ...future.strategy.old <- future::plan("list")
[16:17:41.609]                   options(future.plan = NULL)
[16:17:41.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:41.609]                 }
[16:17:41.609]                 ...future.workdir <- getwd()
[16:17:41.609]             }
[16:17:41.609]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:41.609]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:41.609]         }
[16:17:41.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:41.609]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:41.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:41.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:41.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:41.609]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:41.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:41.609]             base::names(...future.oldOptions))
[16:17:41.609]     }
[16:17:41.609]     if (FALSE) {
[16:17:41.609]     }
[16:17:41.609]     else {
[16:17:41.609]         if (TRUE) {
[16:17:41.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:41.609]                 open = "w")
[16:17:41.609]         }
[16:17:41.609]         else {
[16:17:41.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:41.609]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:41.609]         }
[16:17:41.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:41.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:41.609]             base::sink(type = "output", split = FALSE)
[16:17:41.609]             base::close(...future.stdout)
[16:17:41.609]         }, add = TRUE)
[16:17:41.609]     }
[16:17:41.609]     ...future.frame <- base::sys.nframe()
[16:17:41.609]     ...future.conditions <- base::list()
[16:17:41.609]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:41.609]     if (FALSE) {
[16:17:41.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:41.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:41.609]     }
[16:17:41.609]     ...future.result <- base::tryCatch({
[16:17:41.609]         base::withCallingHandlers({
[16:17:41.609]             ...future.value <- base::withVisible(base::local({
[16:17:41.609]                 do.call(function(...) {
[16:17:41.609]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.609]                   if (!identical(...future.globals.maxSize.org, 
[16:17:41.609]                     ...future.globals.maxSize)) {
[16:17:41.609]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.609]                     on.exit(options(oopts), add = TRUE)
[16:17:41.609]                   }
[16:17:41.609]                   {
[16:17:41.609]                     lapply(seq_along(...future.elements_ii), 
[16:17:41.609]                       FUN = function(jj) {
[16:17:41.609]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.609]                         ...future.FUN(...future.X_jj, ...)
[16:17:41.609]                       })
[16:17:41.609]                   }
[16:17:41.609]                 }, args = future.call.arguments)
[16:17:41.609]             }))
[16:17:41.609]             future::FutureResult(value = ...future.value$value, 
[16:17:41.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.609]                   ...future.rng), globalenv = if (FALSE) 
[16:17:41.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:41.609]                     ...future.globalenv.names))
[16:17:41.609]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:41.609]         }, condition = base::local({
[16:17:41.609]             c <- base::c
[16:17:41.609]             inherits <- base::inherits
[16:17:41.609]             invokeRestart <- base::invokeRestart
[16:17:41.609]             length <- base::length
[16:17:41.609]             list <- base::list
[16:17:41.609]             seq.int <- base::seq.int
[16:17:41.609]             signalCondition <- base::signalCondition
[16:17:41.609]             sys.calls <- base::sys.calls
[16:17:41.609]             `[[` <- base::`[[`
[16:17:41.609]             `+` <- base::`+`
[16:17:41.609]             `<<-` <- base::`<<-`
[16:17:41.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:41.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:41.609]                   3L)]
[16:17:41.609]             }
[16:17:41.609]             function(cond) {
[16:17:41.609]                 is_error <- inherits(cond, "error")
[16:17:41.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:41.609]                   NULL)
[16:17:41.609]                 if (is_error) {
[16:17:41.609]                   sessionInformation <- function() {
[16:17:41.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:41.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:41.609]                       search = base::search(), system = base::Sys.info())
[16:17:41.609]                   }
[16:17:41.609]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:41.609]                     cond$call), session = sessionInformation(), 
[16:17:41.609]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:41.609]                   signalCondition(cond)
[16:17:41.609]                 }
[16:17:41.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:41.609]                 "immediateCondition"))) {
[16:17:41.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:41.609]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:41.609]                   if (TRUE && !signal) {
[16:17:41.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.609]                     {
[16:17:41.609]                       inherits <- base::inherits
[16:17:41.609]                       invokeRestart <- base::invokeRestart
[16:17:41.609]                       is.null <- base::is.null
[16:17:41.609]                       muffled <- FALSE
[16:17:41.609]                       if (inherits(cond, "message")) {
[16:17:41.609]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.609]                         if (muffled) 
[16:17:41.609]                           invokeRestart("muffleMessage")
[16:17:41.609]                       }
[16:17:41.609]                       else if (inherits(cond, "warning")) {
[16:17:41.609]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.609]                         if (muffled) 
[16:17:41.609]                           invokeRestart("muffleWarning")
[16:17:41.609]                       }
[16:17:41.609]                       else if (inherits(cond, "condition")) {
[16:17:41.609]                         if (!is.null(pattern)) {
[16:17:41.609]                           computeRestarts <- base::computeRestarts
[16:17:41.609]                           grepl <- base::grepl
[16:17:41.609]                           restarts <- computeRestarts(cond)
[16:17:41.609]                           for (restart in restarts) {
[16:17:41.609]                             name <- restart$name
[16:17:41.609]                             if (is.null(name)) 
[16:17:41.609]                               next
[16:17:41.609]                             if (!grepl(pattern, name)) 
[16:17:41.609]                               next
[16:17:41.609]                             invokeRestart(restart)
[16:17:41.609]                             muffled <- TRUE
[16:17:41.609]                             break
[16:17:41.609]                           }
[16:17:41.609]                         }
[16:17:41.609]                       }
[16:17:41.609]                       invisible(muffled)
[16:17:41.609]                     }
[16:17:41.609]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.609]                   }
[16:17:41.609]                 }
[16:17:41.609]                 else {
[16:17:41.609]                   if (TRUE) {
[16:17:41.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.609]                     {
[16:17:41.609]                       inherits <- base::inherits
[16:17:41.609]                       invokeRestart <- base::invokeRestart
[16:17:41.609]                       is.null <- base::is.null
[16:17:41.609]                       muffled <- FALSE
[16:17:41.609]                       if (inherits(cond, "message")) {
[16:17:41.609]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.609]                         if (muffled) 
[16:17:41.609]                           invokeRestart("muffleMessage")
[16:17:41.609]                       }
[16:17:41.609]                       else if (inherits(cond, "warning")) {
[16:17:41.609]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.609]                         if (muffled) 
[16:17:41.609]                           invokeRestart("muffleWarning")
[16:17:41.609]                       }
[16:17:41.609]                       else if (inherits(cond, "condition")) {
[16:17:41.609]                         if (!is.null(pattern)) {
[16:17:41.609]                           computeRestarts <- base::computeRestarts
[16:17:41.609]                           grepl <- base::grepl
[16:17:41.609]                           restarts <- computeRestarts(cond)
[16:17:41.609]                           for (restart in restarts) {
[16:17:41.609]                             name <- restart$name
[16:17:41.609]                             if (is.null(name)) 
[16:17:41.609]                               next
[16:17:41.609]                             if (!grepl(pattern, name)) 
[16:17:41.609]                               next
[16:17:41.609]                             invokeRestart(restart)
[16:17:41.609]                             muffled <- TRUE
[16:17:41.609]                             break
[16:17:41.609]                           }
[16:17:41.609]                         }
[16:17:41.609]                       }
[16:17:41.609]                       invisible(muffled)
[16:17:41.609]                     }
[16:17:41.609]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.609]                   }
[16:17:41.609]                 }
[16:17:41.609]             }
[16:17:41.609]         }))
[16:17:41.609]     }, error = function(ex) {
[16:17:41.609]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:41.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.609]                 ...future.rng), started = ...future.startTime, 
[16:17:41.609]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:41.609]             version = "1.8"), class = "FutureResult")
[16:17:41.609]     }, finally = {
[16:17:41.609]         if (!identical(...future.workdir, getwd())) 
[16:17:41.609]             setwd(...future.workdir)
[16:17:41.609]         {
[16:17:41.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:41.609]                 ...future.oldOptions$nwarnings <- NULL
[16:17:41.609]             }
[16:17:41.609]             base::options(...future.oldOptions)
[16:17:41.609]             if (.Platform$OS.type == "windows") {
[16:17:41.609]                 old_names <- names(...future.oldEnvVars)
[16:17:41.609]                 envs <- base::Sys.getenv()
[16:17:41.609]                 names <- names(envs)
[16:17:41.609]                 common <- intersect(names, old_names)
[16:17:41.609]                 added <- setdiff(names, old_names)
[16:17:41.609]                 removed <- setdiff(old_names, names)
[16:17:41.609]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:41.609]                   envs[common]]
[16:17:41.609]                 NAMES <- toupper(changed)
[16:17:41.609]                 args <- list()
[16:17:41.609]                 for (kk in seq_along(NAMES)) {
[16:17:41.609]                   name <- changed[[kk]]
[16:17:41.609]                   NAME <- NAMES[[kk]]
[16:17:41.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.609]                     next
[16:17:41.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.609]                 }
[16:17:41.609]                 NAMES <- toupper(added)
[16:17:41.609]                 for (kk in seq_along(NAMES)) {
[16:17:41.609]                   name <- added[[kk]]
[16:17:41.609]                   NAME <- NAMES[[kk]]
[16:17:41.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.609]                     next
[16:17:41.609]                   args[[name]] <- ""
[16:17:41.609]                 }
[16:17:41.609]                 NAMES <- toupper(removed)
[16:17:41.609]                 for (kk in seq_along(NAMES)) {
[16:17:41.609]                   name <- removed[[kk]]
[16:17:41.609]                   NAME <- NAMES[[kk]]
[16:17:41.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.609]                     next
[16:17:41.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.609]                 }
[16:17:41.609]                 if (length(args) > 0) 
[16:17:41.609]                   base::do.call(base::Sys.setenv, args = args)
[16:17:41.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:41.609]             }
[16:17:41.609]             else {
[16:17:41.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:41.609]             }
[16:17:41.609]             {
[16:17:41.609]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:41.609]                   0L) {
[16:17:41.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:41.609]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:41.609]                   base::options(opts)
[16:17:41.609]                 }
[16:17:41.609]                 {
[16:17:41.609]                   {
[16:17:41.609]                     NULL
[16:17:41.609]                     RNGkind("Mersenne-Twister")
[16:17:41.609]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:41.609]                       inherits = FALSE)
[16:17:41.609]                   }
[16:17:41.609]                   options(future.plan = NULL)
[16:17:41.609]                   if (is.na(NA_character_)) 
[16:17:41.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:41.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:41.609]                     .init = FALSE)
[16:17:41.609]                 }
[16:17:41.609]             }
[16:17:41.609]         }
[16:17:41.609]     })
[16:17:41.609]     if (TRUE) {
[16:17:41.609]         base::sink(type = "output", split = FALSE)
[16:17:41.609]         if (TRUE) {
[16:17:41.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:41.609]         }
[16:17:41.609]         else {
[16:17:41.609]             ...future.result["stdout"] <- base::list(NULL)
[16:17:41.609]         }
[16:17:41.609]         base::close(...future.stdout)
[16:17:41.609]         ...future.stdout <- NULL
[16:17:41.609]     }
[16:17:41.609]     ...future.result$conditions <- ...future.conditions
[16:17:41.609]     ...future.result$finished <- base::Sys.time()
[16:17:41.609]     ...future.result
[16:17:41.609] }
[16:17:41.610] assign_globals() ...
[16:17:41.610] List of 5
[16:17:41.610]  $ future.call.arguments    : list()
[16:17:41.610]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.610]  $ ...future.FUN            :function (x, ...)  
[16:17:41.610]  $ ...future.elements_ii    :List of 2
[16:17:41.610]   ..$ : num [1:4] 1 3 1 7
[16:17:41.610]   ..$ : num [1:4] 2 4 6 8
[16:17:41.610]  $ ...future.seeds_ii       : NULL
[16:17:41.610]  $ ...future.globals.maxSize: num Inf
[16:17:41.610]  - attr(*, "resolved")= logi FALSE
[16:17:41.610]  - attr(*, "total_size")= num NA
[16:17:41.610]  - attr(*, "where")=List of 5
[16:17:41.610]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:41.610]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:41.610]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:41.610]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:41.610]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:41.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.610]  - attr(*, "already-done")= logi TRUE
[16:17:41.615] - copied ‘future.call.arguments’ to environment
[16:17:41.615] - copied ‘...future.FUN’ to environment
[16:17:41.615] - copied ‘...future.elements_ii’ to environment
[16:17:41.615] - copied ‘...future.seeds_ii’ to environment
[16:17:41.615] - copied ‘...future.globals.maxSize’ to environment
[16:17:41.615] assign_globals() ... done
[16:17:41.616] plan(): Setting new future strategy stack:
[16:17:41.616] List of future strategies:
[16:17:41.616] 1. sequential:
[16:17:41.616]    - args: function (..., envir = parent.frame())
[16:17:41.616]    - tweaked: FALSE
[16:17:41.616]    - call: NULL
[16:17:41.616] plan(): nbrOfWorkers() = 1
[16:17:41.617] plan(): Setting new future strategy stack:
[16:17:41.617] List of future strategies:
[16:17:41.617] 1. sequential:
[16:17:41.617]    - args: function (..., envir = parent.frame())
[16:17:41.617]    - tweaked: FALSE
[16:17:41.617]    - call: plan(strategy)
[16:17:41.618] plan(): nbrOfWorkers() = 1
[16:17:41.618] SequentialFuture started (and completed)
[16:17:41.618] - Launch lazy future ... done
[16:17:41.618] run() for ‘SequentialFuture’ ... done
[16:17:41.618] Created future:
[16:17:41.618] SequentialFuture:
[16:17:41.618] Label: ‘future_apply-1’
[16:17:41.618] Expression:
[16:17:41.618] {
[16:17:41.618]     do.call(function(...) {
[16:17:41.618]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.618]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.618]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.618]             on.exit(options(oopts), add = TRUE)
[16:17:41.618]         }
[16:17:41.618]         {
[16:17:41.618]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.618]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.618]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.618]             })
[16:17:41.618]         }
[16:17:41.618]     }, args = future.call.arguments)
[16:17:41.618] }
[16:17:41.618] Lazy evaluation: FALSE
[16:17:41.618] Asynchronous evaluation: FALSE
[16:17:41.618] Local evaluation: TRUE
[16:17:41.618] Environment: R_GlobalEnv
[16:17:41.618] Capture standard output: TRUE
[16:17:41.618] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:41.618] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:41.618] Packages: 1 packages (‘stats’)
[16:17:41.618] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:41.618] Resolved: TRUE
[16:17:41.618] Value: 1.14 KiB of class ‘list’
[16:17:41.618] Early signaling: FALSE
[16:17:41.618] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:41.618] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.619] Chunk #1 of 1 ... DONE
[16:17:41.619] Launching 1 futures (chunks) ... DONE
[16:17:41.619] Resolving 1 futures (chunks) ...
[16:17:41.619] resolve() on list ...
[16:17:41.619]  recursive: 0
[16:17:41.620]  length: 1
[16:17:41.620] 
[16:17:41.620] resolved() for ‘SequentialFuture’ ...
[16:17:41.620] - state: ‘finished’
[16:17:41.620] - run: TRUE
[16:17:41.620] - result: ‘FutureResult’
[16:17:41.620] resolved() for ‘SequentialFuture’ ... done
[16:17:41.620] Future #1
[16:17:41.620] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:41.620] - nx: 1
[16:17:41.621] - relay: TRUE
[16:17:41.621] - stdout: TRUE
[16:17:41.621] - signal: TRUE
[16:17:41.622] - resignal: FALSE
[16:17:41.622] - force: TRUE
[16:17:41.622] - relayed: [n=1] FALSE
[16:17:41.622] - queued futures: [n=1] FALSE
[16:17:41.622]  - until=1
[16:17:41.622]  - relaying element #1
[16:17:41.622] - relayed: [n=1] TRUE
[16:17:41.622] - queued futures: [n=1] TRUE
[16:17:41.622] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:41.622]  length: 0 (resolved future 1)
[16:17:41.623] Relaying remaining futures
[16:17:41.623] signalConditionsASAP(NULL, pos=0) ...
[16:17:41.623] - nx: 1
[16:17:41.623] - relay: TRUE
[16:17:41.623] - stdout: TRUE
[16:17:41.623] - signal: TRUE
[16:17:41.623] - resignal: FALSE
[16:17:41.623] - force: TRUE
[16:17:41.623] - relayed: [n=1] TRUE
[16:17:41.623] - queued futures: [n=1] TRUE
 - flush all
[16:17:41.623] - relayed: [n=1] TRUE
[16:17:41.623] - queued futures: [n=1] TRUE
[16:17:41.624] signalConditionsASAP(NULL, pos=0) ... done
[16:17:41.624] resolve() on list ... DONE
[16:17:41.624]  - Number of value chunks collected: 1
[16:17:41.624] Resolving 1 futures (chunks) ... DONE
[16:17:41.624] Reducing values from 1 chunks ...
[16:17:41.624]  - Number of values collected after concatenation: 2
[16:17:41.624]  - Number of values expected: 2
[16:17:41.624] Reducing values from 1 chunks ... DONE
[16:17:41.624] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:17:41.625] getGlobalsAndPackagesXApply() ...
[16:17:41.625]  - future.globals: TRUE
[16:17:41.625] getGlobalsAndPackages() ...
[16:17:41.625] Searching for globals...
[16:17:41.626] - globals found: [1] ‘FUN’
[16:17:41.626] Searching for globals ... DONE
[16:17:41.626] Resolving globals: FALSE
[16:17:41.627] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:41.627] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:41.627] - globals: [1] ‘FUN’
[16:17:41.627] 
[16:17:41.627] getGlobalsAndPackages() ... DONE
[16:17:41.627]  - globals found/used: [n=1] ‘FUN’
[16:17:41.627]  - needed namespaces: [n=0] 
[16:17:41.628] Finding globals ... DONE
[16:17:41.628]  - use_args: TRUE
[16:17:41.628]  - Getting '...' globals ...
[16:17:41.628] resolve() on list ...
[16:17:41.628]  recursive: 0
[16:17:41.628]  length: 1
[16:17:41.628]  elements: ‘...’
[16:17:41.628]  length: 0 (resolved future 1)
[16:17:41.629] resolve() on list ... DONE
[16:17:41.629]    - '...' content: [n=0] 
[16:17:41.629] List of 1
[16:17:41.629]  $ ...: list()
[16:17:41.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.629]  - attr(*, "where")=List of 1
[16:17:41.629]   ..$ ...:<environment: 0x555be0ac1590> 
[16:17:41.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.629]  - attr(*, "resolved")= logi TRUE
[16:17:41.629]  - attr(*, "total_size")= num NA
[16:17:41.631]  - Getting '...' globals ... DONE
[16:17:41.631] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.631] List of 2
[16:17:41.631]  $ ...future.FUN:function (x)  
[16:17:41.631]  $ ...          : list()
[16:17:41.631]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.631]  - attr(*, "where")=List of 2
[16:17:41.631]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.631]   ..$ ...          :<environment: 0x555be0ac1590> 
[16:17:41.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.631]  - attr(*, "resolved")= logi FALSE
[16:17:41.631]  - attr(*, "total_size")= num 848
[16:17:41.634] Packages to be attached in all futures: [n=0] 
[16:17:41.634] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.634] future_lapply() ...
[16:17:41.634] Number of chunks: 1
[16:17:41.634] getGlobalsAndPackagesXApply() ...
[16:17:41.635]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.635]  - use_args: TRUE
[16:17:41.635] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.635] List of 2
[16:17:41.635]  $ ...          : list()
[16:17:41.635]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.635]  $ ...future.FUN:function (x)  
[16:17:41.635]  - attr(*, "where")=List of 2
[16:17:41.635]   ..$ ...          :<environment: 0x555be0ac1590> 
[16:17:41.635]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:41.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.635]  - attr(*, "resolved")= logi FALSE
[16:17:41.635]  - attr(*, "total_size")= num NA
[16:17:41.638] Packages to be attached in all futures: [n=0] 
[16:17:41.638] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.638] Number of futures (= number of chunks): 1
[16:17:41.638] Launching 1 futures (chunks) ...
[16:17:41.638] Chunk #1 of 1 ...
[16:17:41.638]  - seeds: <none>
[16:17:41.638]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.639] getGlobalsAndPackages() ...
[16:17:41.639] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.639] Resolving globals: FALSE
[16:17:41.639] Tweak future expression to call with '...' arguments ...
[16:17:41.639] {
[16:17:41.639]     do.call(function(...) {
[16:17:41.639]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.639]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.639]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.639]             on.exit(options(oopts), add = TRUE)
[16:17:41.639]         }
[16:17:41.639]         {
[16:17:41.639]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.639]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.639]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.639]             })
[16:17:41.639]         }
[16:17:41.639]     }, args = future.call.arguments)
[16:17:41.639] }
[16:17:41.639] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.640] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.640] 
[16:17:41.640] getGlobalsAndPackages() ... DONE
[16:17:41.640] run() for ‘Future’ ...
[16:17:41.640] - state: ‘created’
[16:17:41.640] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:41.641] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:41.641]   - Field: ‘label’
[16:17:41.641]   - Field: ‘local’
[16:17:41.641]   - Field: ‘owner’
[16:17:41.641]   - Field: ‘envir’
[16:17:41.642]   - Field: ‘packages’
[16:17:41.642]   - Field: ‘gc’
[16:17:41.642]   - Field: ‘conditions’
[16:17:41.642]   - Field: ‘expr’
[16:17:41.642]   - Field: ‘uuid’
[16:17:41.642]   - Field: ‘seed’
[16:17:41.643]   - Field: ‘version’
[16:17:41.643]   - Field: ‘result’
[16:17:41.643]   - Field: ‘asynchronous’
[16:17:41.643]   - Field: ‘calls’
[16:17:41.643]   - Field: ‘globals’
[16:17:41.643]   - Field: ‘stdout’
[16:17:41.643]   - Field: ‘earlySignal’
[16:17:41.643]   - Field: ‘lazy’
[16:17:41.643]   - Field: ‘state’
[16:17:41.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:41.643] - Launch lazy future ...
[16:17:41.644] Packages needed by the future expression (n = 0): <none>
[16:17:41.644] Packages needed by future strategies (n = 0): <none>
[16:17:41.644] {
[16:17:41.644]     {
[16:17:41.644]         {
[16:17:41.644]             ...future.startTime <- base::Sys.time()
[16:17:41.644]             {
[16:17:41.644]                 {
[16:17:41.644]                   {
[16:17:41.644]                     base::local({
[16:17:41.644]                       has_future <- base::requireNamespace("future", 
[16:17:41.644]                         quietly = TRUE)
[16:17:41.644]                       if (has_future) {
[16:17:41.644]                         ns <- base::getNamespace("future")
[16:17:41.644]                         version <- ns[[".package"]][["version"]]
[16:17:41.644]                         if (is.null(version)) 
[16:17:41.644]                           version <- utils::packageVersion("future")
[16:17:41.644]                       }
[16:17:41.644]                       else {
[16:17:41.644]                         version <- NULL
[16:17:41.644]                       }
[16:17:41.644]                       if (!has_future || version < "1.8.0") {
[16:17:41.644]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:41.644]                           "", base::R.version$version.string), 
[16:17:41.644]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:41.644]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:41.644]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:41.644]                             "release", "version")], collapse = " "), 
[16:17:41.644]                           hostname = base::Sys.info()[["nodename"]])
[16:17:41.644]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:41.644]                           info)
[16:17:41.644]                         info <- base::paste(info, collapse = "; ")
[16:17:41.644]                         if (!has_future) {
[16:17:41.644]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:41.644]                             info)
[16:17:41.644]                         }
[16:17:41.644]                         else {
[16:17:41.644]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:41.644]                             info, version)
[16:17:41.644]                         }
[16:17:41.644]                         base::stop(msg)
[16:17:41.644]                       }
[16:17:41.644]                     })
[16:17:41.644]                   }
[16:17:41.644]                   ...future.strategy.old <- future::plan("list")
[16:17:41.644]                   options(future.plan = NULL)
[16:17:41.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:41.644]                 }
[16:17:41.644]                 ...future.workdir <- getwd()
[16:17:41.644]             }
[16:17:41.644]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:41.644]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:41.644]         }
[16:17:41.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:41.644]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:41.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:41.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:41.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:41.644]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:41.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:41.644]             base::names(...future.oldOptions))
[16:17:41.644]     }
[16:17:41.644]     if (FALSE) {
[16:17:41.644]     }
[16:17:41.644]     else {
[16:17:41.644]         if (TRUE) {
[16:17:41.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:41.644]                 open = "w")
[16:17:41.644]         }
[16:17:41.644]         else {
[16:17:41.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:41.644]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:41.644]         }
[16:17:41.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:41.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:41.644]             base::sink(type = "output", split = FALSE)
[16:17:41.644]             base::close(...future.stdout)
[16:17:41.644]         }, add = TRUE)
[16:17:41.644]     }
[16:17:41.644]     ...future.frame <- base::sys.nframe()
[16:17:41.644]     ...future.conditions <- base::list()
[16:17:41.644]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:41.644]     if (FALSE) {
[16:17:41.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:41.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:41.644]     }
[16:17:41.644]     ...future.result <- base::tryCatch({
[16:17:41.644]         base::withCallingHandlers({
[16:17:41.644]             ...future.value <- base::withVisible(base::local({
[16:17:41.644]                 do.call(function(...) {
[16:17:41.644]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.644]                   if (!identical(...future.globals.maxSize.org, 
[16:17:41.644]                     ...future.globals.maxSize)) {
[16:17:41.644]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.644]                     on.exit(options(oopts), add = TRUE)
[16:17:41.644]                   }
[16:17:41.644]                   {
[16:17:41.644]                     lapply(seq_along(...future.elements_ii), 
[16:17:41.644]                       FUN = function(jj) {
[16:17:41.644]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.644]                         ...future.FUN(...future.X_jj, ...)
[16:17:41.644]                       })
[16:17:41.644]                   }
[16:17:41.644]                 }, args = future.call.arguments)
[16:17:41.644]             }))
[16:17:41.644]             future::FutureResult(value = ...future.value$value, 
[16:17:41.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.644]                   ...future.rng), globalenv = if (FALSE) 
[16:17:41.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:41.644]                     ...future.globalenv.names))
[16:17:41.644]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:41.644]         }, condition = base::local({
[16:17:41.644]             c <- base::c
[16:17:41.644]             inherits <- base::inherits
[16:17:41.644]             invokeRestart <- base::invokeRestart
[16:17:41.644]             length <- base::length
[16:17:41.644]             list <- base::list
[16:17:41.644]             seq.int <- base::seq.int
[16:17:41.644]             signalCondition <- base::signalCondition
[16:17:41.644]             sys.calls <- base::sys.calls
[16:17:41.644]             `[[` <- base::`[[`
[16:17:41.644]             `+` <- base::`+`
[16:17:41.644]             `<<-` <- base::`<<-`
[16:17:41.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:41.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:41.644]                   3L)]
[16:17:41.644]             }
[16:17:41.644]             function(cond) {
[16:17:41.644]                 is_error <- inherits(cond, "error")
[16:17:41.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:41.644]                   NULL)
[16:17:41.644]                 if (is_error) {
[16:17:41.644]                   sessionInformation <- function() {
[16:17:41.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:41.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:41.644]                       search = base::search(), system = base::Sys.info())
[16:17:41.644]                   }
[16:17:41.644]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:41.644]                     cond$call), session = sessionInformation(), 
[16:17:41.644]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:41.644]                   signalCondition(cond)
[16:17:41.644]                 }
[16:17:41.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:41.644]                 "immediateCondition"))) {
[16:17:41.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:41.644]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:41.644]                   if (TRUE && !signal) {
[16:17:41.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.644]                     {
[16:17:41.644]                       inherits <- base::inherits
[16:17:41.644]                       invokeRestart <- base::invokeRestart
[16:17:41.644]                       is.null <- base::is.null
[16:17:41.644]                       muffled <- FALSE
[16:17:41.644]                       if (inherits(cond, "message")) {
[16:17:41.644]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.644]                         if (muffled) 
[16:17:41.644]                           invokeRestart("muffleMessage")
[16:17:41.644]                       }
[16:17:41.644]                       else if (inherits(cond, "warning")) {
[16:17:41.644]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.644]                         if (muffled) 
[16:17:41.644]                           invokeRestart("muffleWarning")
[16:17:41.644]                       }
[16:17:41.644]                       else if (inherits(cond, "condition")) {
[16:17:41.644]                         if (!is.null(pattern)) {
[16:17:41.644]                           computeRestarts <- base::computeRestarts
[16:17:41.644]                           grepl <- base::grepl
[16:17:41.644]                           restarts <- computeRestarts(cond)
[16:17:41.644]                           for (restart in restarts) {
[16:17:41.644]                             name <- restart$name
[16:17:41.644]                             if (is.null(name)) 
[16:17:41.644]                               next
[16:17:41.644]                             if (!grepl(pattern, name)) 
[16:17:41.644]                               next
[16:17:41.644]                             invokeRestart(restart)
[16:17:41.644]                             muffled <- TRUE
[16:17:41.644]                             break
[16:17:41.644]                           }
[16:17:41.644]                         }
[16:17:41.644]                       }
[16:17:41.644]                       invisible(muffled)
[16:17:41.644]                     }
[16:17:41.644]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.644]                   }
[16:17:41.644]                 }
[16:17:41.644]                 else {
[16:17:41.644]                   if (TRUE) {
[16:17:41.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.644]                     {
[16:17:41.644]                       inherits <- base::inherits
[16:17:41.644]                       invokeRestart <- base::invokeRestart
[16:17:41.644]                       is.null <- base::is.null
[16:17:41.644]                       muffled <- FALSE
[16:17:41.644]                       if (inherits(cond, "message")) {
[16:17:41.644]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.644]                         if (muffled) 
[16:17:41.644]                           invokeRestart("muffleMessage")
[16:17:41.644]                       }
[16:17:41.644]                       else if (inherits(cond, "warning")) {
[16:17:41.644]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.644]                         if (muffled) 
[16:17:41.644]                           invokeRestart("muffleWarning")
[16:17:41.644]                       }
[16:17:41.644]                       else if (inherits(cond, "condition")) {
[16:17:41.644]                         if (!is.null(pattern)) {
[16:17:41.644]                           computeRestarts <- base::computeRestarts
[16:17:41.644]                           grepl <- base::grepl
[16:17:41.644]                           restarts <- computeRestarts(cond)
[16:17:41.644]                           for (restart in restarts) {
[16:17:41.644]                             name <- restart$name
[16:17:41.644]                             if (is.null(name)) 
[16:17:41.644]                               next
[16:17:41.644]                             if (!grepl(pattern, name)) 
[16:17:41.644]                               next
[16:17:41.644]                             invokeRestart(restart)
[16:17:41.644]                             muffled <- TRUE
[16:17:41.644]                             break
[16:17:41.644]                           }
[16:17:41.644]                         }
[16:17:41.644]                       }
[16:17:41.644]                       invisible(muffled)
[16:17:41.644]                     }
[16:17:41.644]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.644]                   }
[16:17:41.644]                 }
[16:17:41.644]             }
[16:17:41.644]         }))
[16:17:41.644]     }, error = function(ex) {
[16:17:41.644]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:41.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.644]                 ...future.rng), started = ...future.startTime, 
[16:17:41.644]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:41.644]             version = "1.8"), class = "FutureResult")
[16:17:41.644]     }, finally = {
[16:17:41.644]         if (!identical(...future.workdir, getwd())) 
[16:17:41.644]             setwd(...future.workdir)
[16:17:41.644]         {
[16:17:41.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:41.644]                 ...future.oldOptions$nwarnings <- NULL
[16:17:41.644]             }
[16:17:41.644]             base::options(...future.oldOptions)
[16:17:41.644]             if (.Platform$OS.type == "windows") {
[16:17:41.644]                 old_names <- names(...future.oldEnvVars)
[16:17:41.644]                 envs <- base::Sys.getenv()
[16:17:41.644]                 names <- names(envs)
[16:17:41.644]                 common <- intersect(names, old_names)
[16:17:41.644]                 added <- setdiff(names, old_names)
[16:17:41.644]                 removed <- setdiff(old_names, names)
[16:17:41.644]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:41.644]                   envs[common]]
[16:17:41.644]                 NAMES <- toupper(changed)
[16:17:41.644]                 args <- list()
[16:17:41.644]                 for (kk in seq_along(NAMES)) {
[16:17:41.644]                   name <- changed[[kk]]
[16:17:41.644]                   NAME <- NAMES[[kk]]
[16:17:41.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.644]                     next
[16:17:41.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.644]                 }
[16:17:41.644]                 NAMES <- toupper(added)
[16:17:41.644]                 for (kk in seq_along(NAMES)) {
[16:17:41.644]                   name <- added[[kk]]
[16:17:41.644]                   NAME <- NAMES[[kk]]
[16:17:41.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.644]                     next
[16:17:41.644]                   args[[name]] <- ""
[16:17:41.644]                 }
[16:17:41.644]                 NAMES <- toupper(removed)
[16:17:41.644]                 for (kk in seq_along(NAMES)) {
[16:17:41.644]                   name <- removed[[kk]]
[16:17:41.644]                   NAME <- NAMES[[kk]]
[16:17:41.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.644]                     next
[16:17:41.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.644]                 }
[16:17:41.644]                 if (length(args) > 0) 
[16:17:41.644]                   base::do.call(base::Sys.setenv, args = args)
[16:17:41.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:41.644]             }
[16:17:41.644]             else {
[16:17:41.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:41.644]             }
[16:17:41.644]             {
[16:17:41.644]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:41.644]                   0L) {
[16:17:41.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:41.644]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:41.644]                   base::options(opts)
[16:17:41.644]                 }
[16:17:41.644]                 {
[16:17:41.644]                   {
[16:17:41.644]                     NULL
[16:17:41.644]                     RNGkind("Mersenne-Twister")
[16:17:41.644]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:41.644]                       inherits = FALSE)
[16:17:41.644]                   }
[16:17:41.644]                   options(future.plan = NULL)
[16:17:41.644]                   if (is.na(NA_character_)) 
[16:17:41.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:41.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:41.644]                     .init = FALSE)
[16:17:41.644]                 }
[16:17:41.644]             }
[16:17:41.644]         }
[16:17:41.644]     })
[16:17:41.644]     if (TRUE) {
[16:17:41.644]         base::sink(type = "output", split = FALSE)
[16:17:41.644]         if (TRUE) {
[16:17:41.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:41.644]         }
[16:17:41.644]         else {
[16:17:41.644]             ...future.result["stdout"] <- base::list(NULL)
[16:17:41.644]         }
[16:17:41.644]         base::close(...future.stdout)
[16:17:41.644]         ...future.stdout <- NULL
[16:17:41.644]     }
[16:17:41.644]     ...future.result$conditions <- ...future.conditions
[16:17:41.644]     ...future.result$finished <- base::Sys.time()
[16:17:41.644]     ...future.result
[16:17:41.644] }
[16:17:41.646] assign_globals() ...
[16:17:41.646] List of 5
[16:17:41.646]  $ future.call.arguments    : list()
[16:17:41.646]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.646]  $ ...future.FUN            :function (x)  
[16:17:41.646]  $ ...future.elements_ii    :List of 2
[16:17:41.646]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:17:41.646]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:17:41.646]  $ ...future.seeds_ii       : NULL
[16:17:41.646]  $ ...future.globals.maxSize: num Inf
[16:17:41.646]  - attr(*, "resolved")= logi FALSE
[16:17:41.646]  - attr(*, "total_size")= num NA
[16:17:41.646]  - attr(*, "where")=List of 5
[16:17:41.646]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:41.646]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:41.646]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:41.646]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:41.646]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:41.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.646]  - attr(*, "already-done")= logi TRUE
[16:17:41.651] - copied ‘future.call.arguments’ to environment
[16:17:41.651] - copied ‘...future.FUN’ to environment
[16:17:41.651] - copied ‘...future.elements_ii’ to environment
[16:17:41.651] - copied ‘...future.seeds_ii’ to environment
[16:17:41.651] - copied ‘...future.globals.maxSize’ to environment
[16:17:41.651] assign_globals() ... done
[16:17:41.651] plan(): Setting new future strategy stack:
[16:17:41.651] List of future strategies:
[16:17:41.651] 1. sequential:
[16:17:41.651]    - args: function (..., envir = parent.frame())
[16:17:41.651]    - tweaked: FALSE
[16:17:41.651]    - call: NULL
[16:17:41.652] plan(): nbrOfWorkers() = 1
[16:17:41.652] plan(): Setting new future strategy stack:
[16:17:41.652] List of future strategies:
[16:17:41.652] 1. sequential:
[16:17:41.652]    - args: function (..., envir = parent.frame())
[16:17:41.652]    - tweaked: FALSE
[16:17:41.652]    - call: plan(strategy)
[16:17:41.653] plan(): nbrOfWorkers() = 1
[16:17:41.653] SequentialFuture started (and completed)
[16:17:41.653] - Launch lazy future ... done
[16:17:41.653] run() for ‘SequentialFuture’ ... done
[16:17:41.653] Created future:
[16:17:41.653] SequentialFuture:
[16:17:41.653] Label: ‘future_apply-1’
[16:17:41.653] Expression:
[16:17:41.653] {
[16:17:41.653]     do.call(function(...) {
[16:17:41.653]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.653]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.653]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.653]             on.exit(options(oopts), add = TRUE)
[16:17:41.653]         }
[16:17:41.653]         {
[16:17:41.653]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.653]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.653]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.653]             })
[16:17:41.653]         }
[16:17:41.653]     }, args = future.call.arguments)
[16:17:41.653] }
[16:17:41.653] Lazy evaluation: FALSE
[16:17:41.653] Asynchronous evaluation: FALSE
[16:17:41.653] Local evaluation: TRUE
[16:17:41.653] Environment: R_GlobalEnv
[16:17:41.653] Capture standard output: TRUE
[16:17:41.653] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:41.653] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:41.653] Packages: <none>
[16:17:41.653] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:41.653] Resolved: TRUE
[16:17:41.653] Value: 224 bytes of class ‘list’
[16:17:41.653] Early signaling: FALSE
[16:17:41.653] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:41.653] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.654] Chunk #1 of 1 ... DONE
[16:17:41.654] Launching 1 futures (chunks) ... DONE
[16:17:41.654] Resolving 1 futures (chunks) ...
[16:17:41.654] resolve() on list ...
[16:17:41.655]  recursive: 0
[16:17:41.655]  length: 1
[16:17:41.655] 
[16:17:41.655] resolved() for ‘SequentialFuture’ ...
[16:17:41.655] - state: ‘finished’
[16:17:41.655] - run: TRUE
[16:17:41.655] - result: ‘FutureResult’
[16:17:41.655] resolved() for ‘SequentialFuture’ ... done
[16:17:41.655] Future #1
[16:17:41.655] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:41.656] - nx: 1
[16:17:41.656] - relay: TRUE
[16:17:41.656] - stdout: TRUE
[16:17:41.656] - signal: TRUE
[16:17:41.656] - resignal: FALSE
[16:17:41.656] - force: TRUE
[16:17:41.656] - relayed: [n=1] FALSE
[16:17:41.656] - queued futures: [n=1] FALSE
[16:17:41.656]  - until=1
[16:17:41.656]  - relaying element #1
[16:17:41.656] - relayed: [n=1] TRUE
[16:17:41.657] - queued futures: [n=1] TRUE
[16:17:41.657] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:41.657]  length: 0 (resolved future 1)
[16:17:41.657] Relaying remaining futures
[16:17:41.657] signalConditionsASAP(NULL, pos=0) ...
[16:17:41.657] - nx: 1
[16:17:41.657] - relay: TRUE
[16:17:41.657] - stdout: TRUE
[16:17:41.657] - signal: TRUE
[16:17:41.657] - resignal: FALSE
[16:17:41.657] - force: TRUE
[16:17:41.657] - relayed: [n=1] TRUE
[16:17:41.657] - queued futures: [n=1] TRUE
 - flush all
[16:17:41.658] - relayed: [n=1] TRUE
[16:17:41.658] - queued futures: [n=1] TRUE
[16:17:41.658] signalConditionsASAP(NULL, pos=0) ... done
[16:17:41.658] resolve() on list ... DONE
[16:17:41.658]  - Number of value chunks collected: 1
[16:17:41.658] Resolving 1 futures (chunks) ... DONE
[16:17:41.658] Reducing values from 1 chunks ...
[16:17:41.658]  - Number of values collected after concatenation: 2
[16:17:41.658]  - Number of values expected: 2
[16:17:41.658] Reducing values from 1 chunks ... DONE
[16:17:41.658] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:17:41.659] getGlobalsAndPackagesXApply() ...
[16:17:41.659]  - future.globals: TRUE
[16:17:41.659] getGlobalsAndPackages() ...
[16:17:41.659] Searching for globals...
[16:17:41.660] - globals found: [1] ‘FUN’
[16:17:41.660] Searching for globals ... DONE
[16:17:41.660] Resolving globals: FALSE
[16:17:41.660] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:41.661] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:41.661] - globals: [1] ‘FUN’
[16:17:41.661] 
[16:17:41.661] getGlobalsAndPackages() ... DONE
[16:17:41.661]  - globals found/used: [n=1] ‘FUN’
[16:17:41.661]  - needed namespaces: [n=0] 
[16:17:41.661] Finding globals ... DONE
[16:17:41.661]  - use_args: TRUE
[16:17:41.662]  - Getting '...' globals ...
[16:17:41.662] resolve() on list ...
[16:17:41.662]  recursive: 0
[16:17:41.662]  length: 1
[16:17:41.662]  elements: ‘...’
[16:17:41.662]  length: 0 (resolved future 1)
[16:17:41.662] resolve() on list ... DONE
[16:17:41.662]    - '...' content: [n=0] 
[16:17:41.662] List of 1
[16:17:41.662]  $ ...: list()
[16:17:41.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.662]  - attr(*, "where")=List of 1
[16:17:41.662]   ..$ ...:<environment: 0x555be26413e8> 
[16:17:41.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.662]  - attr(*, "resolved")= logi TRUE
[16:17:41.662]  - attr(*, "total_size")= num NA
[16:17:41.666]  - Getting '...' globals ... DONE
[16:17:41.666] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.666] List of 2
[16:17:41.666]  $ ...future.FUN:function (x)  
[16:17:41.666]  $ ...          : list()
[16:17:41.666]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.666]  - attr(*, "where")=List of 2
[16:17:41.666]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.666]   ..$ ...          :<environment: 0x555be26413e8> 
[16:17:41.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.666]  - attr(*, "resolved")= logi FALSE
[16:17:41.666]  - attr(*, "total_size")= num 848
[16:17:41.668] Packages to be attached in all futures: [n=0] 
[16:17:41.668] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.669] future_lapply() ...
[16:17:41.669] Number of chunks: 1
[16:17:41.669] getGlobalsAndPackagesXApply() ...
[16:17:41.669]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.669]  - use_args: TRUE
[16:17:41.669] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.670] List of 2
[16:17:41.670]  $ ...          : list()
[16:17:41.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.670]  $ ...future.FUN:function (x)  
[16:17:41.670]  - attr(*, "where")=List of 2
[16:17:41.670]   ..$ ...          :<environment: 0x555be26413e8> 
[16:17:41.670]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:41.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.670]  - attr(*, "resolved")= logi FALSE
[16:17:41.670]  - attr(*, "total_size")= num NA
[16:17:41.672] Packages to be attached in all futures: [n=0] 
[16:17:41.672] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.673] Number of futures (= number of chunks): 1
[16:17:41.673] Launching 1 futures (chunks) ...
[16:17:41.673] Chunk #1 of 1 ...
[16:17:41.673]  - seeds: <none>
[16:17:41.673]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.673] getGlobalsAndPackages() ...
[16:17:41.673] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.673] Resolving globals: FALSE
[16:17:41.673] Tweak future expression to call with '...' arguments ...
[16:17:41.674] {
[16:17:41.674]     do.call(function(...) {
[16:17:41.674]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.674]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.674]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.674]             on.exit(options(oopts), add = TRUE)
[16:17:41.674]         }
[16:17:41.674]         {
[16:17:41.674]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.674]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.674]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.674]             })
[16:17:41.674]         }
[16:17:41.674]     }, args = future.call.arguments)
[16:17:41.674] }
[16:17:41.674] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.674] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.674] 
[16:17:41.674] getGlobalsAndPackages() ... DONE
[16:17:41.675] run() for ‘Future’ ...
[16:17:41.675] - state: ‘created’
[16:17:41.675] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:41.675] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:41.675]   - Field: ‘label’
[16:17:41.675]   - Field: ‘local’
[16:17:41.675]   - Field: ‘owner’
[16:17:41.676]   - Field: ‘envir’
[16:17:41.676]   - Field: ‘packages’
[16:17:41.676]   - Field: ‘gc’
[16:17:41.676]   - Field: ‘conditions’
[16:17:41.676]   - Field: ‘expr’
[16:17:41.676]   - Field: ‘uuid’
[16:17:41.676]   - Field: ‘seed’
[16:17:41.676]   - Field: ‘version’
[16:17:41.676]   - Field: ‘result’
[16:17:41.676]   - Field: ‘asynchronous’
[16:17:41.676]   - Field: ‘calls’
[16:17:41.677]   - Field: ‘globals’
[16:17:41.677]   - Field: ‘stdout’
[16:17:41.677]   - Field: ‘earlySignal’
[16:17:41.677]   - Field: ‘lazy’
[16:17:41.677]   - Field: ‘state’
[16:17:41.677] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:41.677] - Launch lazy future ...
[16:17:41.677] Packages needed by the future expression (n = 0): <none>
[16:17:41.677] Packages needed by future strategies (n = 0): <none>
[16:17:41.678] {
[16:17:41.678]     {
[16:17:41.678]         {
[16:17:41.678]             ...future.startTime <- base::Sys.time()
[16:17:41.678]             {
[16:17:41.678]                 {
[16:17:41.678]                   {
[16:17:41.678]                     base::local({
[16:17:41.678]                       has_future <- base::requireNamespace("future", 
[16:17:41.678]                         quietly = TRUE)
[16:17:41.678]                       if (has_future) {
[16:17:41.678]                         ns <- base::getNamespace("future")
[16:17:41.678]                         version <- ns[[".package"]][["version"]]
[16:17:41.678]                         if (is.null(version)) 
[16:17:41.678]                           version <- utils::packageVersion("future")
[16:17:41.678]                       }
[16:17:41.678]                       else {
[16:17:41.678]                         version <- NULL
[16:17:41.678]                       }
[16:17:41.678]                       if (!has_future || version < "1.8.0") {
[16:17:41.678]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:41.678]                           "", base::R.version$version.string), 
[16:17:41.678]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:41.678]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:41.678]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:41.678]                             "release", "version")], collapse = " "), 
[16:17:41.678]                           hostname = base::Sys.info()[["nodename"]])
[16:17:41.678]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:41.678]                           info)
[16:17:41.678]                         info <- base::paste(info, collapse = "; ")
[16:17:41.678]                         if (!has_future) {
[16:17:41.678]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:41.678]                             info)
[16:17:41.678]                         }
[16:17:41.678]                         else {
[16:17:41.678]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:41.678]                             info, version)
[16:17:41.678]                         }
[16:17:41.678]                         base::stop(msg)
[16:17:41.678]                       }
[16:17:41.678]                     })
[16:17:41.678]                   }
[16:17:41.678]                   ...future.strategy.old <- future::plan("list")
[16:17:41.678]                   options(future.plan = NULL)
[16:17:41.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:41.678]                 }
[16:17:41.678]                 ...future.workdir <- getwd()
[16:17:41.678]             }
[16:17:41.678]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:41.678]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:41.678]         }
[16:17:41.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:41.678]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:41.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:41.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:41.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:41.678]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:41.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:41.678]             base::names(...future.oldOptions))
[16:17:41.678]     }
[16:17:41.678]     if (FALSE) {
[16:17:41.678]     }
[16:17:41.678]     else {
[16:17:41.678]         if (TRUE) {
[16:17:41.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:41.678]                 open = "w")
[16:17:41.678]         }
[16:17:41.678]         else {
[16:17:41.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:41.678]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:41.678]         }
[16:17:41.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:41.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:41.678]             base::sink(type = "output", split = FALSE)
[16:17:41.678]             base::close(...future.stdout)
[16:17:41.678]         }, add = TRUE)
[16:17:41.678]     }
[16:17:41.678]     ...future.frame <- base::sys.nframe()
[16:17:41.678]     ...future.conditions <- base::list()
[16:17:41.678]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:41.678]     if (FALSE) {
[16:17:41.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:41.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:41.678]     }
[16:17:41.678]     ...future.result <- base::tryCatch({
[16:17:41.678]         base::withCallingHandlers({
[16:17:41.678]             ...future.value <- base::withVisible(base::local({
[16:17:41.678]                 do.call(function(...) {
[16:17:41.678]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.678]                   if (!identical(...future.globals.maxSize.org, 
[16:17:41.678]                     ...future.globals.maxSize)) {
[16:17:41.678]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.678]                     on.exit(options(oopts), add = TRUE)
[16:17:41.678]                   }
[16:17:41.678]                   {
[16:17:41.678]                     lapply(seq_along(...future.elements_ii), 
[16:17:41.678]                       FUN = function(jj) {
[16:17:41.678]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.678]                         ...future.FUN(...future.X_jj, ...)
[16:17:41.678]                       })
[16:17:41.678]                   }
[16:17:41.678]                 }, args = future.call.arguments)
[16:17:41.678]             }))
[16:17:41.678]             future::FutureResult(value = ...future.value$value, 
[16:17:41.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.678]                   ...future.rng), globalenv = if (FALSE) 
[16:17:41.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:41.678]                     ...future.globalenv.names))
[16:17:41.678]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:41.678]         }, condition = base::local({
[16:17:41.678]             c <- base::c
[16:17:41.678]             inherits <- base::inherits
[16:17:41.678]             invokeRestart <- base::invokeRestart
[16:17:41.678]             length <- base::length
[16:17:41.678]             list <- base::list
[16:17:41.678]             seq.int <- base::seq.int
[16:17:41.678]             signalCondition <- base::signalCondition
[16:17:41.678]             sys.calls <- base::sys.calls
[16:17:41.678]             `[[` <- base::`[[`
[16:17:41.678]             `+` <- base::`+`
[16:17:41.678]             `<<-` <- base::`<<-`
[16:17:41.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:41.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:41.678]                   3L)]
[16:17:41.678]             }
[16:17:41.678]             function(cond) {
[16:17:41.678]                 is_error <- inherits(cond, "error")
[16:17:41.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:41.678]                   NULL)
[16:17:41.678]                 if (is_error) {
[16:17:41.678]                   sessionInformation <- function() {
[16:17:41.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:41.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:41.678]                       search = base::search(), system = base::Sys.info())
[16:17:41.678]                   }
[16:17:41.678]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:41.678]                     cond$call), session = sessionInformation(), 
[16:17:41.678]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:41.678]                   signalCondition(cond)
[16:17:41.678]                 }
[16:17:41.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:41.678]                 "immediateCondition"))) {
[16:17:41.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:41.678]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:41.678]                   if (TRUE && !signal) {
[16:17:41.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.678]                     {
[16:17:41.678]                       inherits <- base::inherits
[16:17:41.678]                       invokeRestart <- base::invokeRestart
[16:17:41.678]                       is.null <- base::is.null
[16:17:41.678]                       muffled <- FALSE
[16:17:41.678]                       if (inherits(cond, "message")) {
[16:17:41.678]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.678]                         if (muffled) 
[16:17:41.678]                           invokeRestart("muffleMessage")
[16:17:41.678]                       }
[16:17:41.678]                       else if (inherits(cond, "warning")) {
[16:17:41.678]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.678]                         if (muffled) 
[16:17:41.678]                           invokeRestart("muffleWarning")
[16:17:41.678]                       }
[16:17:41.678]                       else if (inherits(cond, "condition")) {
[16:17:41.678]                         if (!is.null(pattern)) {
[16:17:41.678]                           computeRestarts <- base::computeRestarts
[16:17:41.678]                           grepl <- base::grepl
[16:17:41.678]                           restarts <- computeRestarts(cond)
[16:17:41.678]                           for (restart in restarts) {
[16:17:41.678]                             name <- restart$name
[16:17:41.678]                             if (is.null(name)) 
[16:17:41.678]                               next
[16:17:41.678]                             if (!grepl(pattern, name)) 
[16:17:41.678]                               next
[16:17:41.678]                             invokeRestart(restart)
[16:17:41.678]                             muffled <- TRUE
[16:17:41.678]                             break
[16:17:41.678]                           }
[16:17:41.678]                         }
[16:17:41.678]                       }
[16:17:41.678]                       invisible(muffled)
[16:17:41.678]                     }
[16:17:41.678]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.678]                   }
[16:17:41.678]                 }
[16:17:41.678]                 else {
[16:17:41.678]                   if (TRUE) {
[16:17:41.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.678]                     {
[16:17:41.678]                       inherits <- base::inherits
[16:17:41.678]                       invokeRestart <- base::invokeRestart
[16:17:41.678]                       is.null <- base::is.null
[16:17:41.678]                       muffled <- FALSE
[16:17:41.678]                       if (inherits(cond, "message")) {
[16:17:41.678]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.678]                         if (muffled) 
[16:17:41.678]                           invokeRestart("muffleMessage")
[16:17:41.678]                       }
[16:17:41.678]                       else if (inherits(cond, "warning")) {
[16:17:41.678]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.678]                         if (muffled) 
[16:17:41.678]                           invokeRestart("muffleWarning")
[16:17:41.678]                       }
[16:17:41.678]                       else if (inherits(cond, "condition")) {
[16:17:41.678]                         if (!is.null(pattern)) {
[16:17:41.678]                           computeRestarts <- base::computeRestarts
[16:17:41.678]                           grepl <- base::grepl
[16:17:41.678]                           restarts <- computeRestarts(cond)
[16:17:41.678]                           for (restart in restarts) {
[16:17:41.678]                             name <- restart$name
[16:17:41.678]                             if (is.null(name)) 
[16:17:41.678]                               next
[16:17:41.678]                             if (!grepl(pattern, name)) 
[16:17:41.678]                               next
[16:17:41.678]                             invokeRestart(restart)
[16:17:41.678]                             muffled <- TRUE
[16:17:41.678]                             break
[16:17:41.678]                           }
[16:17:41.678]                         }
[16:17:41.678]                       }
[16:17:41.678]                       invisible(muffled)
[16:17:41.678]                     }
[16:17:41.678]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.678]                   }
[16:17:41.678]                 }
[16:17:41.678]             }
[16:17:41.678]         }))
[16:17:41.678]     }, error = function(ex) {
[16:17:41.678]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:41.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.678]                 ...future.rng), started = ...future.startTime, 
[16:17:41.678]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:41.678]             version = "1.8"), class = "FutureResult")
[16:17:41.678]     }, finally = {
[16:17:41.678]         if (!identical(...future.workdir, getwd())) 
[16:17:41.678]             setwd(...future.workdir)
[16:17:41.678]         {
[16:17:41.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:41.678]                 ...future.oldOptions$nwarnings <- NULL
[16:17:41.678]             }
[16:17:41.678]             base::options(...future.oldOptions)
[16:17:41.678]             if (.Platform$OS.type == "windows") {
[16:17:41.678]                 old_names <- names(...future.oldEnvVars)
[16:17:41.678]                 envs <- base::Sys.getenv()
[16:17:41.678]                 names <- names(envs)
[16:17:41.678]                 common <- intersect(names, old_names)
[16:17:41.678]                 added <- setdiff(names, old_names)
[16:17:41.678]                 removed <- setdiff(old_names, names)
[16:17:41.678]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:41.678]                   envs[common]]
[16:17:41.678]                 NAMES <- toupper(changed)
[16:17:41.678]                 args <- list()
[16:17:41.678]                 for (kk in seq_along(NAMES)) {
[16:17:41.678]                   name <- changed[[kk]]
[16:17:41.678]                   NAME <- NAMES[[kk]]
[16:17:41.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.678]                     next
[16:17:41.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.678]                 }
[16:17:41.678]                 NAMES <- toupper(added)
[16:17:41.678]                 for (kk in seq_along(NAMES)) {
[16:17:41.678]                   name <- added[[kk]]
[16:17:41.678]                   NAME <- NAMES[[kk]]
[16:17:41.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.678]                     next
[16:17:41.678]                   args[[name]] <- ""
[16:17:41.678]                 }
[16:17:41.678]                 NAMES <- toupper(removed)
[16:17:41.678]                 for (kk in seq_along(NAMES)) {
[16:17:41.678]                   name <- removed[[kk]]
[16:17:41.678]                   NAME <- NAMES[[kk]]
[16:17:41.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.678]                     next
[16:17:41.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.678]                 }
[16:17:41.678]                 if (length(args) > 0) 
[16:17:41.678]                   base::do.call(base::Sys.setenv, args = args)
[16:17:41.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:41.678]             }
[16:17:41.678]             else {
[16:17:41.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:41.678]             }
[16:17:41.678]             {
[16:17:41.678]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:41.678]                   0L) {
[16:17:41.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:41.678]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:41.678]                   base::options(opts)
[16:17:41.678]                 }
[16:17:41.678]                 {
[16:17:41.678]                   {
[16:17:41.678]                     NULL
[16:17:41.678]                     RNGkind("Mersenne-Twister")
[16:17:41.678]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:41.678]                       inherits = FALSE)
[16:17:41.678]                   }
[16:17:41.678]                   options(future.plan = NULL)
[16:17:41.678]                   if (is.na(NA_character_)) 
[16:17:41.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:41.678]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:41.678]                     .init = FALSE)
[16:17:41.678]                 }
[16:17:41.678]             }
[16:17:41.678]         }
[16:17:41.678]     })
[16:17:41.678]     if (TRUE) {
[16:17:41.678]         base::sink(type = "output", split = FALSE)
[16:17:41.678]         if (TRUE) {
[16:17:41.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:41.678]         }
[16:17:41.678]         else {
[16:17:41.678]             ...future.result["stdout"] <- base::list(NULL)
[16:17:41.678]         }
[16:17:41.678]         base::close(...future.stdout)
[16:17:41.678]         ...future.stdout <- NULL
[16:17:41.678]     }
[16:17:41.678]     ...future.result$conditions <- ...future.conditions
[16:17:41.678]     ...future.result$finished <- base::Sys.time()
[16:17:41.678]     ...future.result
[16:17:41.678] }
[16:17:41.679] assign_globals() ...
[16:17:41.679] List of 5
[16:17:41.679]  $ future.call.arguments    : list()
[16:17:41.679]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.679]  $ ...future.FUN            :function (x)  
[16:17:41.679]  $ ...future.elements_ii    :List of 6
[16:17:41.679]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:17:41.679]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:17:41.679]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:17:41.679]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:17:41.679]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:17:41.679]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:17:41.679]  $ ...future.seeds_ii       : NULL
[16:17:41.679]  $ ...future.globals.maxSize: num Inf
[16:17:41.679]  - attr(*, "resolved")= logi FALSE
[16:17:41.679]  - attr(*, "total_size")= num NA
[16:17:41.679]  - attr(*, "where")=List of 5
[16:17:41.679]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:41.679]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:41.679]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:41.679]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:41.679]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:41.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.679]  - attr(*, "already-done")= logi TRUE
[16:17:41.687] - copied ‘future.call.arguments’ to environment
[16:17:41.687] - copied ‘...future.FUN’ to environment
[16:17:41.687] - copied ‘...future.elements_ii’ to environment
[16:17:41.687] - copied ‘...future.seeds_ii’ to environment
[16:17:41.687] - copied ‘...future.globals.maxSize’ to environment
[16:17:41.687] assign_globals() ... done
[16:17:41.687] plan(): Setting new future strategy stack:
[16:17:41.688] List of future strategies:
[16:17:41.688] 1. sequential:
[16:17:41.688]    - args: function (..., envir = parent.frame())
[16:17:41.688]    - tweaked: FALSE
[16:17:41.688]    - call: NULL
[16:17:41.688] plan(): nbrOfWorkers() = 1
[16:17:41.689] plan(): Setting new future strategy stack:
[16:17:41.689] List of future strategies:
[16:17:41.689] 1. sequential:
[16:17:41.689]    - args: function (..., envir = parent.frame())
[16:17:41.689]    - tweaked: FALSE
[16:17:41.689]    - call: plan(strategy)
[16:17:41.689] plan(): nbrOfWorkers() = 1
[16:17:41.689] SequentialFuture started (and completed)
[16:17:41.689] - Launch lazy future ... done
[16:17:41.689] run() for ‘SequentialFuture’ ... done
[16:17:41.690] Created future:
[16:17:41.690] SequentialFuture:
[16:17:41.690] Label: ‘future_apply-1’
[16:17:41.690] Expression:
[16:17:41.690] {
[16:17:41.690]     do.call(function(...) {
[16:17:41.690]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.690]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.690]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.690]             on.exit(options(oopts), add = TRUE)
[16:17:41.690]         }
[16:17:41.690]         {
[16:17:41.690]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.690]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.690]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.690]             })
[16:17:41.690]         }
[16:17:41.690]     }, args = future.call.arguments)
[16:17:41.690] }
[16:17:41.690] Lazy evaluation: FALSE
[16:17:41.690] Asynchronous evaluation: FALSE
[16:17:41.690] Local evaluation: TRUE
[16:17:41.690] Environment: R_GlobalEnv
[16:17:41.690] Capture standard output: TRUE
[16:17:41.690] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:41.690] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:41.690] Packages: <none>
[16:17:41.690] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:41.690] Resolved: TRUE
[16:17:41.690] Value: 672 bytes of class ‘list’
[16:17:41.690] Early signaling: FALSE
[16:17:41.690] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:41.690] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.691] Chunk #1 of 1 ... DONE
[16:17:41.691] Launching 1 futures (chunks) ... DONE
[16:17:41.691] Resolving 1 futures (chunks) ...
[16:17:41.691] resolve() on list ...
[16:17:41.691]  recursive: 0
[16:17:41.691]  length: 1
[16:17:41.691] 
[16:17:41.691] resolved() for ‘SequentialFuture’ ...
[16:17:41.691] - state: ‘finished’
[16:17:41.691] - run: TRUE
[16:17:41.692] - result: ‘FutureResult’
[16:17:41.692] resolved() for ‘SequentialFuture’ ... done
[16:17:41.692] Future #1
[16:17:41.692] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:41.692] - nx: 1
[16:17:41.692] - relay: TRUE
[16:17:41.692] - stdout: TRUE
[16:17:41.692] - signal: TRUE
[16:17:41.692] - resignal: FALSE
[16:17:41.692] - force: TRUE
[16:17:41.693] - relayed: [n=1] FALSE
[16:17:41.693] - queued futures: [n=1] FALSE
[16:17:41.693]  - until=1
[16:17:41.693]  - relaying element #1
[16:17:41.693] - relayed: [n=1] TRUE
[16:17:41.693] - queued futures: [n=1] TRUE
[16:17:41.693] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:41.693]  length: 0 (resolved future 1)
[16:17:41.693] Relaying remaining futures
[16:17:41.694] signalConditionsASAP(NULL, pos=0) ...
[16:17:41.694] - nx: 1
[16:17:41.694] - relay: TRUE
[16:17:41.694] - stdout: TRUE
[16:17:41.694] - signal: TRUE
[16:17:41.694] - resignal: FALSE
[16:17:41.694] - force: TRUE
[16:17:41.694] - relayed: [n=1] TRUE
[16:17:41.694] - queued futures: [n=1] TRUE
 - flush all
[16:17:41.694] - relayed: [n=1] TRUE
[16:17:41.694] - queued futures: [n=1] TRUE
[16:17:41.695] signalConditionsASAP(NULL, pos=0) ... done
[16:17:41.695] resolve() on list ... DONE
[16:17:41.695]  - Number of value chunks collected: 1
[16:17:41.695] Resolving 1 futures (chunks) ... DONE
[16:17:41.695] Reducing values from 1 chunks ...
[16:17:41.695]  - Number of values collected after concatenation: 6
[16:17:41.695]  - Number of values expected: 6
[16:17:41.695] Reducing values from 1 chunks ... DONE
[16:17:41.695] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:17:41.696] getGlobalsAndPackagesXApply() ...
[16:17:41.696]  - future.globals: TRUE
[16:17:41.696] getGlobalsAndPackages() ...
[16:17:41.696] Searching for globals...
[16:17:41.697] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:17:41.697] Searching for globals ... DONE
[16:17:41.698] Resolving globals: FALSE
[16:17:41.698] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:17:41.698] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:17:41.698] - globals: [1] ‘FUN’
[16:17:41.699] 
[16:17:41.699] getGlobalsAndPackages() ... DONE
[16:17:41.699]  - globals found/used: [n=1] ‘FUN’
[16:17:41.699]  - needed namespaces: [n=0] 
[16:17:41.699] Finding globals ... DONE
[16:17:41.699]  - use_args: TRUE
[16:17:41.699]  - Getting '...' globals ...
[16:17:41.699] resolve() on list ...
[16:17:41.699]  recursive: 0
[16:17:41.700]  length: 1
[16:17:41.700]  elements: ‘...’
[16:17:41.700]  length: 0 (resolved future 1)
[16:17:41.700] resolve() on list ... DONE
[16:17:41.700]    - '...' content: [n=0] 
[16:17:41.700] List of 1
[16:17:41.700]  $ ...: list()
[16:17:41.700]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.700]  - attr(*, "where")=List of 1
[16:17:41.700]   ..$ ...:<environment: 0x555be216f4e8> 
[16:17:41.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.700]  - attr(*, "resolved")= logi TRUE
[16:17:41.700]  - attr(*, "total_size")= num NA
[16:17:41.702]  - Getting '...' globals ... DONE
[16:17:41.703] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.703] List of 2
[16:17:41.703]  $ ...future.FUN:function (x)  
[16:17:41.703]  $ ...          : list()
[16:17:41.703]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.703]  - attr(*, "where")=List of 2
[16:17:41.703]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.703]   ..$ ...          :<environment: 0x555be216f4e8> 
[16:17:41.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.703]  - attr(*, "resolved")= logi FALSE
[16:17:41.703]  - attr(*, "total_size")= num 1768
[16:17:41.707] Packages to be attached in all futures: [n=0] 
[16:17:41.707] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.707] future_lapply() ...
[16:17:41.708] Number of chunks: 1
[16:17:41.708] getGlobalsAndPackagesXApply() ...
[16:17:41.708]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.708]  - use_args: TRUE
[16:17:41.708] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.708] List of 2
[16:17:41.708]  $ ...          : list()
[16:17:41.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.708]  $ ...future.FUN:function (x)  
[16:17:41.708]  - attr(*, "where")=List of 2
[16:17:41.708]   ..$ ...          :<environment: 0x555be216f4e8> 
[16:17:41.708]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:17:41.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.708]  - attr(*, "resolved")= logi FALSE
[16:17:41.708]  - attr(*, "total_size")= num NA
[16:17:41.711] Packages to be attached in all futures: [n=0] 
[16:17:41.711] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.711] Number of futures (= number of chunks): 1
[16:17:41.711] Launching 1 futures (chunks) ...
[16:17:41.711] Chunk #1 of 1 ...
[16:17:41.712]  - seeds: <none>
[16:17:41.712]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.712] getGlobalsAndPackages() ...
[16:17:41.712] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.712] Resolving globals: FALSE
[16:17:41.712] Tweak future expression to call with '...' arguments ...
[16:17:41.712] {
[16:17:41.712]     do.call(function(...) {
[16:17:41.712]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.712]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.712]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.712]             on.exit(options(oopts), add = TRUE)
[16:17:41.712]         }
[16:17:41.712]         {
[16:17:41.712]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.712]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.712]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.712]             })
[16:17:41.712]         }
[16:17:41.712]     }, args = future.call.arguments)
[16:17:41.712] }
[16:17:41.712] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.713] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.713] 
[16:17:41.713] getGlobalsAndPackages() ... DONE
[16:17:41.713] run() for ‘Future’ ...
[16:17:41.713] - state: ‘created’
[16:17:41.713] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:41.714] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.714] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:41.714]   - Field: ‘label’
[16:17:41.714]   - Field: ‘local’
[16:17:41.714]   - Field: ‘owner’
[16:17:41.714]   - Field: ‘envir’
[16:17:41.714]   - Field: ‘packages’
[16:17:41.715]   - Field: ‘gc’
[16:17:41.715]   - Field: ‘conditions’
[16:17:41.715]   - Field: ‘expr’
[16:17:41.715]   - Field: ‘uuid’
[16:17:41.715]   - Field: ‘seed’
[16:17:41.715]   - Field: ‘version’
[16:17:41.715]   - Field: ‘result’
[16:17:41.715]   - Field: ‘asynchronous’
[16:17:41.715]   - Field: ‘calls’
[16:17:41.715]   - Field: ‘globals’
[16:17:41.715]   - Field: ‘stdout’
[16:17:41.715]   - Field: ‘earlySignal’
[16:17:41.716]   - Field: ‘lazy’
[16:17:41.716]   - Field: ‘state’
[16:17:41.716] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:41.716] - Launch lazy future ...
[16:17:41.716] Packages needed by the future expression (n = 0): <none>
[16:17:41.716] Packages needed by future strategies (n = 0): <none>
[16:17:41.717] {
[16:17:41.717]     {
[16:17:41.717]         {
[16:17:41.717]             ...future.startTime <- base::Sys.time()
[16:17:41.717]             {
[16:17:41.717]                 {
[16:17:41.717]                   {
[16:17:41.717]                     base::local({
[16:17:41.717]                       has_future <- base::requireNamespace("future", 
[16:17:41.717]                         quietly = TRUE)
[16:17:41.717]                       if (has_future) {
[16:17:41.717]                         ns <- base::getNamespace("future")
[16:17:41.717]                         version <- ns[[".package"]][["version"]]
[16:17:41.717]                         if (is.null(version)) 
[16:17:41.717]                           version <- utils::packageVersion("future")
[16:17:41.717]                       }
[16:17:41.717]                       else {
[16:17:41.717]                         version <- NULL
[16:17:41.717]                       }
[16:17:41.717]                       if (!has_future || version < "1.8.0") {
[16:17:41.717]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:41.717]                           "", base::R.version$version.string), 
[16:17:41.717]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:41.717]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:41.717]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:41.717]                             "release", "version")], collapse = " "), 
[16:17:41.717]                           hostname = base::Sys.info()[["nodename"]])
[16:17:41.717]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:41.717]                           info)
[16:17:41.717]                         info <- base::paste(info, collapse = "; ")
[16:17:41.717]                         if (!has_future) {
[16:17:41.717]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:41.717]                             info)
[16:17:41.717]                         }
[16:17:41.717]                         else {
[16:17:41.717]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:41.717]                             info, version)
[16:17:41.717]                         }
[16:17:41.717]                         base::stop(msg)
[16:17:41.717]                       }
[16:17:41.717]                     })
[16:17:41.717]                   }
[16:17:41.717]                   ...future.strategy.old <- future::plan("list")
[16:17:41.717]                   options(future.plan = NULL)
[16:17:41.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:41.717]                 }
[16:17:41.717]                 ...future.workdir <- getwd()
[16:17:41.717]             }
[16:17:41.717]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:41.717]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:41.717]         }
[16:17:41.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:41.717]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:41.717]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:41.717]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:41.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:41.717]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:41.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:41.717]             base::names(...future.oldOptions))
[16:17:41.717]     }
[16:17:41.717]     if (FALSE) {
[16:17:41.717]     }
[16:17:41.717]     else {
[16:17:41.717]         if (TRUE) {
[16:17:41.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:41.717]                 open = "w")
[16:17:41.717]         }
[16:17:41.717]         else {
[16:17:41.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:41.717]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:41.717]         }
[16:17:41.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:41.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:41.717]             base::sink(type = "output", split = FALSE)
[16:17:41.717]             base::close(...future.stdout)
[16:17:41.717]         }, add = TRUE)
[16:17:41.717]     }
[16:17:41.717]     ...future.frame <- base::sys.nframe()
[16:17:41.717]     ...future.conditions <- base::list()
[16:17:41.717]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:41.717]     if (FALSE) {
[16:17:41.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:41.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:41.717]     }
[16:17:41.717]     ...future.result <- base::tryCatch({
[16:17:41.717]         base::withCallingHandlers({
[16:17:41.717]             ...future.value <- base::withVisible(base::local({
[16:17:41.717]                 do.call(function(...) {
[16:17:41.717]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.717]                   if (!identical(...future.globals.maxSize.org, 
[16:17:41.717]                     ...future.globals.maxSize)) {
[16:17:41.717]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.717]                     on.exit(options(oopts), add = TRUE)
[16:17:41.717]                   }
[16:17:41.717]                   {
[16:17:41.717]                     lapply(seq_along(...future.elements_ii), 
[16:17:41.717]                       FUN = function(jj) {
[16:17:41.717]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.717]                         ...future.FUN(...future.X_jj, ...)
[16:17:41.717]                       })
[16:17:41.717]                   }
[16:17:41.717]                 }, args = future.call.arguments)
[16:17:41.717]             }))
[16:17:41.717]             future::FutureResult(value = ...future.value$value, 
[16:17:41.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.717]                   ...future.rng), globalenv = if (FALSE) 
[16:17:41.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:41.717]                     ...future.globalenv.names))
[16:17:41.717]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:41.717]         }, condition = base::local({
[16:17:41.717]             c <- base::c
[16:17:41.717]             inherits <- base::inherits
[16:17:41.717]             invokeRestart <- base::invokeRestart
[16:17:41.717]             length <- base::length
[16:17:41.717]             list <- base::list
[16:17:41.717]             seq.int <- base::seq.int
[16:17:41.717]             signalCondition <- base::signalCondition
[16:17:41.717]             sys.calls <- base::sys.calls
[16:17:41.717]             `[[` <- base::`[[`
[16:17:41.717]             `+` <- base::`+`
[16:17:41.717]             `<<-` <- base::`<<-`
[16:17:41.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:41.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:41.717]                   3L)]
[16:17:41.717]             }
[16:17:41.717]             function(cond) {
[16:17:41.717]                 is_error <- inherits(cond, "error")
[16:17:41.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:41.717]                   NULL)
[16:17:41.717]                 if (is_error) {
[16:17:41.717]                   sessionInformation <- function() {
[16:17:41.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:41.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:41.717]                       search = base::search(), system = base::Sys.info())
[16:17:41.717]                   }
[16:17:41.717]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:41.717]                     cond$call), session = sessionInformation(), 
[16:17:41.717]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:41.717]                   signalCondition(cond)
[16:17:41.717]                 }
[16:17:41.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:41.717]                 "immediateCondition"))) {
[16:17:41.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:41.717]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:41.717]                   if (TRUE && !signal) {
[16:17:41.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.717]                     {
[16:17:41.717]                       inherits <- base::inherits
[16:17:41.717]                       invokeRestart <- base::invokeRestart
[16:17:41.717]                       is.null <- base::is.null
[16:17:41.717]                       muffled <- FALSE
[16:17:41.717]                       if (inherits(cond, "message")) {
[16:17:41.717]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.717]                         if (muffled) 
[16:17:41.717]                           invokeRestart("muffleMessage")
[16:17:41.717]                       }
[16:17:41.717]                       else if (inherits(cond, "warning")) {
[16:17:41.717]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.717]                         if (muffled) 
[16:17:41.717]                           invokeRestart("muffleWarning")
[16:17:41.717]                       }
[16:17:41.717]                       else if (inherits(cond, "condition")) {
[16:17:41.717]                         if (!is.null(pattern)) {
[16:17:41.717]                           computeRestarts <- base::computeRestarts
[16:17:41.717]                           grepl <- base::grepl
[16:17:41.717]                           restarts <- computeRestarts(cond)
[16:17:41.717]                           for (restart in restarts) {
[16:17:41.717]                             name <- restart$name
[16:17:41.717]                             if (is.null(name)) 
[16:17:41.717]                               next
[16:17:41.717]                             if (!grepl(pattern, name)) 
[16:17:41.717]                               next
[16:17:41.717]                             invokeRestart(restart)
[16:17:41.717]                             muffled <- TRUE
[16:17:41.717]                             break
[16:17:41.717]                           }
[16:17:41.717]                         }
[16:17:41.717]                       }
[16:17:41.717]                       invisible(muffled)
[16:17:41.717]                     }
[16:17:41.717]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.717]                   }
[16:17:41.717]                 }
[16:17:41.717]                 else {
[16:17:41.717]                   if (TRUE) {
[16:17:41.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.717]                     {
[16:17:41.717]                       inherits <- base::inherits
[16:17:41.717]                       invokeRestart <- base::invokeRestart
[16:17:41.717]                       is.null <- base::is.null
[16:17:41.717]                       muffled <- FALSE
[16:17:41.717]                       if (inherits(cond, "message")) {
[16:17:41.717]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.717]                         if (muffled) 
[16:17:41.717]                           invokeRestart("muffleMessage")
[16:17:41.717]                       }
[16:17:41.717]                       else if (inherits(cond, "warning")) {
[16:17:41.717]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.717]                         if (muffled) 
[16:17:41.717]                           invokeRestart("muffleWarning")
[16:17:41.717]                       }
[16:17:41.717]                       else if (inherits(cond, "condition")) {
[16:17:41.717]                         if (!is.null(pattern)) {
[16:17:41.717]                           computeRestarts <- base::computeRestarts
[16:17:41.717]                           grepl <- base::grepl
[16:17:41.717]                           restarts <- computeRestarts(cond)
[16:17:41.717]                           for (restart in restarts) {
[16:17:41.717]                             name <- restart$name
[16:17:41.717]                             if (is.null(name)) 
[16:17:41.717]                               next
[16:17:41.717]                             if (!grepl(pattern, name)) 
[16:17:41.717]                               next
[16:17:41.717]                             invokeRestart(restart)
[16:17:41.717]                             muffled <- TRUE
[16:17:41.717]                             break
[16:17:41.717]                           }
[16:17:41.717]                         }
[16:17:41.717]                       }
[16:17:41.717]                       invisible(muffled)
[16:17:41.717]                     }
[16:17:41.717]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.717]                   }
[16:17:41.717]                 }
[16:17:41.717]             }
[16:17:41.717]         }))
[16:17:41.717]     }, error = function(ex) {
[16:17:41.717]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:41.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.717]                 ...future.rng), started = ...future.startTime, 
[16:17:41.717]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:41.717]             version = "1.8"), class = "FutureResult")
[16:17:41.717]     }, finally = {
[16:17:41.717]         if (!identical(...future.workdir, getwd())) 
[16:17:41.717]             setwd(...future.workdir)
[16:17:41.717]         {
[16:17:41.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:41.717]                 ...future.oldOptions$nwarnings <- NULL
[16:17:41.717]             }
[16:17:41.717]             base::options(...future.oldOptions)
[16:17:41.717]             if (.Platform$OS.type == "windows") {
[16:17:41.717]                 old_names <- names(...future.oldEnvVars)
[16:17:41.717]                 envs <- base::Sys.getenv()
[16:17:41.717]                 names <- names(envs)
[16:17:41.717]                 common <- intersect(names, old_names)
[16:17:41.717]                 added <- setdiff(names, old_names)
[16:17:41.717]                 removed <- setdiff(old_names, names)
[16:17:41.717]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:41.717]                   envs[common]]
[16:17:41.717]                 NAMES <- toupper(changed)
[16:17:41.717]                 args <- list()
[16:17:41.717]                 for (kk in seq_along(NAMES)) {
[16:17:41.717]                   name <- changed[[kk]]
[16:17:41.717]                   NAME <- NAMES[[kk]]
[16:17:41.717]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.717]                     next
[16:17:41.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.717]                 }
[16:17:41.717]                 NAMES <- toupper(added)
[16:17:41.717]                 for (kk in seq_along(NAMES)) {
[16:17:41.717]                   name <- added[[kk]]
[16:17:41.717]                   NAME <- NAMES[[kk]]
[16:17:41.717]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.717]                     next
[16:17:41.717]                   args[[name]] <- ""
[16:17:41.717]                 }
[16:17:41.717]                 NAMES <- toupper(removed)
[16:17:41.717]                 for (kk in seq_along(NAMES)) {
[16:17:41.717]                   name <- removed[[kk]]
[16:17:41.717]                   NAME <- NAMES[[kk]]
[16:17:41.717]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.717]                     next
[16:17:41.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.717]                 }
[16:17:41.717]                 if (length(args) > 0) 
[16:17:41.717]                   base::do.call(base::Sys.setenv, args = args)
[16:17:41.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:41.717]             }
[16:17:41.717]             else {
[16:17:41.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:41.717]             }
[16:17:41.717]             {
[16:17:41.717]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:41.717]                   0L) {
[16:17:41.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:41.717]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:41.717]                   base::options(opts)
[16:17:41.717]                 }
[16:17:41.717]                 {
[16:17:41.717]                   {
[16:17:41.717]                     NULL
[16:17:41.717]                     RNGkind("Mersenne-Twister")
[16:17:41.717]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:41.717]                       inherits = FALSE)
[16:17:41.717]                   }
[16:17:41.717]                   options(future.plan = NULL)
[16:17:41.717]                   if (is.na(NA_character_)) 
[16:17:41.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:41.717]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:41.717]                     .init = FALSE)
[16:17:41.717]                 }
[16:17:41.717]             }
[16:17:41.717]         }
[16:17:41.717]     })
[16:17:41.717]     if (TRUE) {
[16:17:41.717]         base::sink(type = "output", split = FALSE)
[16:17:41.717]         if (TRUE) {
[16:17:41.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:41.717]         }
[16:17:41.717]         else {
[16:17:41.717]             ...future.result["stdout"] <- base::list(NULL)
[16:17:41.717]         }
[16:17:41.717]         base::close(...future.stdout)
[16:17:41.717]         ...future.stdout <- NULL
[16:17:41.717]     }
[16:17:41.717]     ...future.result$conditions <- ...future.conditions
[16:17:41.717]     ...future.result$finished <- base::Sys.time()
[16:17:41.717]     ...future.result
[16:17:41.717] }
[16:17:41.718] assign_globals() ...
[16:17:41.718] List of 5
[16:17:41.718]  $ future.call.arguments    : list()
[16:17:41.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.718]  $ ...future.FUN            :function (x)  
[16:17:41.718]  $ ...future.elements_ii    :List of 6
[16:17:41.718]   ..$ : int [1:4] 1 7 13 19
[16:17:41.718]   ..$ : int [1:4] 2 8 14 20
[16:17:41.718]   ..$ : int [1:4] 3 9 15 21
[16:17:41.718]   ..$ : int [1:4] 4 10 16 22
[16:17:41.718]   ..$ : int [1:4] 5 11 17 23
[16:17:41.718]   ..$ : int [1:4] 6 12 18 24
[16:17:41.718]  $ ...future.seeds_ii       : NULL
[16:17:41.718]  $ ...future.globals.maxSize: num Inf
[16:17:41.718]  - attr(*, "resolved")= logi FALSE
[16:17:41.718]  - attr(*, "total_size")= num NA
[16:17:41.718]  - attr(*, "where")=List of 5
[16:17:41.718]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:41.718]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:41.718]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:41.718]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:41.718]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:41.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.718]  - attr(*, "already-done")= logi TRUE
[16:17:41.724] - copied ‘future.call.arguments’ to environment
[16:17:41.724] - reassign environment for ‘...future.FUN’
[16:17:41.725] - copied ‘...future.FUN’ to environment
[16:17:41.725] - copied ‘...future.elements_ii’ to environment
[16:17:41.725] - copied ‘...future.seeds_ii’ to environment
[16:17:41.725] - copied ‘...future.globals.maxSize’ to environment
[16:17:41.725] assign_globals() ... done
[16:17:41.725] plan(): Setting new future strategy stack:
[16:17:41.725] List of future strategies:
[16:17:41.725] 1. sequential:
[16:17:41.725]    - args: function (..., envir = parent.frame())
[16:17:41.725]    - tweaked: FALSE
[16:17:41.725]    - call: NULL
[16:17:41.726] plan(): nbrOfWorkers() = 1
[16:17:41.726] plan(): Setting new future strategy stack:
[16:17:41.726] List of future strategies:
[16:17:41.726] 1. sequential:
[16:17:41.726]    - args: function (..., envir = parent.frame())
[16:17:41.726]    - tweaked: FALSE
[16:17:41.726]    - call: plan(strategy)
[16:17:41.750] plan(): nbrOfWorkers() = 1
[16:17:41.750] SequentialFuture started (and completed)
[16:17:41.750] - Launch lazy future ... done
[16:17:41.751] run() for ‘SequentialFuture’ ... done
[16:17:41.751] Created future:
[16:17:41.751] SequentialFuture:
[16:17:41.751] Label: ‘future_apply-1’
[16:17:41.751] Expression:
[16:17:41.751] {
[16:17:41.751]     do.call(function(...) {
[16:17:41.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.751]             on.exit(options(oopts), add = TRUE)
[16:17:41.751]         }
[16:17:41.751]         {
[16:17:41.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.751]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.751]             })
[16:17:41.751]         }
[16:17:41.751]     }, args = future.call.arguments)
[16:17:41.751] }
[16:17:41.751] Lazy evaluation: FALSE
[16:17:41.751] Asynchronous evaluation: FALSE
[16:17:41.751] Local evaluation: TRUE
[16:17:41.751] Environment: R_GlobalEnv
[16:17:41.751] Capture standard output: TRUE
[16:17:41.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:41.751] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:41.751] Packages: <none>
[16:17:41.751] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:41.751] Resolved: TRUE
[16:17:41.751] Value: 1.03 KiB of class ‘list’
[16:17:41.751] Early signaling: FALSE
[16:17:41.751] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:41.751] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.752] Chunk #1 of 1 ... DONE
[16:17:41.752] Launching 1 futures (chunks) ... DONE
[16:17:41.752] Resolving 1 futures (chunks) ...
[16:17:41.752] resolve() on list ...
[16:17:41.752]  recursive: 0
[16:17:41.752]  length: 1
[16:17:41.752] 
[16:17:41.753] resolved() for ‘SequentialFuture’ ...
[16:17:41.753] - state: ‘finished’
[16:17:41.753] - run: TRUE
[16:17:41.753] - result: ‘FutureResult’
[16:17:41.753] resolved() for ‘SequentialFuture’ ... done
[16:17:41.753] Future #1
[16:17:41.753] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:41.753] - nx: 1
[16:17:41.753] - relay: TRUE
[16:17:41.753] - stdout: TRUE
[16:17:41.754] - signal: TRUE
[16:17:41.754] - resignal: FALSE
[16:17:41.754] - force: TRUE
[16:17:41.754] - relayed: [n=1] FALSE
[16:17:41.754] - queued futures: [n=1] FALSE
[16:17:41.754]  - until=1
[16:17:41.754]  - relaying element #1
[16:17:41.754] - relayed: [n=1] TRUE
[16:17:41.754] - queued futures: [n=1] TRUE
[16:17:41.754] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:41.755]  length: 0 (resolved future 1)
[16:17:41.755] Relaying remaining futures
[16:17:41.755] signalConditionsASAP(NULL, pos=0) ...
[16:17:41.755] - nx: 1
[16:17:41.755] - relay: TRUE
[16:17:41.755] - stdout: TRUE
[16:17:41.755] - signal: TRUE
[16:17:41.755] - resignal: FALSE
[16:17:41.755] - force: TRUE
[16:17:41.755] - relayed: [n=1] TRUE
[16:17:41.755] - queued futures: [n=1] TRUE
 - flush all
[16:17:41.755] - relayed: [n=1] TRUE
[16:17:41.756] - queued futures: [n=1] TRUE
[16:17:41.756] signalConditionsASAP(NULL, pos=0) ... done
[16:17:41.756] resolve() on list ... DONE
[16:17:41.756]  - Number of value chunks collected: 1
[16:17:41.756] Resolving 1 futures (chunks) ... DONE
[16:17:41.756] Reducing values from 1 chunks ...
[16:17:41.756]  - Number of values collected after concatenation: 6
[16:17:41.756]  - Number of values expected: 6
[16:17:41.756] Reducing values from 1 chunks ... DONE
[16:17:41.756] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:17:41.757] getGlobalsAndPackagesXApply() ...
[16:17:41.757]  - future.globals: TRUE
[16:17:41.757] getGlobalsAndPackages() ...
[16:17:41.757] Searching for globals...
[16:17:41.758] - globals found: [1] ‘FUN’
[16:17:41.758] Searching for globals ... DONE
[16:17:41.758] Resolving globals: FALSE
[16:17:41.758] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:41.759] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:41.759] - globals: [1] ‘FUN’
[16:17:41.759] 
[16:17:41.759] getGlobalsAndPackages() ... DONE
[16:17:41.759]  - globals found/used: [n=1] ‘FUN’
[16:17:41.759]  - needed namespaces: [n=0] 
[16:17:41.759] Finding globals ... DONE
[16:17:41.759]  - use_args: TRUE
[16:17:41.759]  - Getting '...' globals ...
[16:17:41.760] resolve() on list ...
[16:17:41.760]  recursive: 0
[16:17:41.760]  length: 1
[16:17:41.760]  elements: ‘...’
[16:17:41.760]  length: 0 (resolved future 1)
[16:17:41.760] resolve() on list ... DONE
[16:17:41.760]    - '...' content: [n=0] 
[16:17:41.760] List of 1
[16:17:41.760]  $ ...: list()
[16:17:41.760]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.760]  - attr(*, "where")=List of 1
[16:17:41.760]   ..$ ...:<environment: 0x555be0144880> 
[16:17:41.760]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.760]  - attr(*, "resolved")= logi TRUE
[16:17:41.760]  - attr(*, "total_size")= num NA
[16:17:41.763]  - Getting '...' globals ... DONE
[16:17:41.763] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.763] List of 2
[16:17:41.763]  $ ...future.FUN:function (x)  
[16:17:41.763]  $ ...          : list()
[16:17:41.763]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.763]  - attr(*, "where")=List of 2
[16:17:41.763]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.763]   ..$ ...          :<environment: 0x555be0144880> 
[16:17:41.763]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.763]  - attr(*, "resolved")= logi FALSE
[16:17:41.763]  - attr(*, "total_size")= num 848
[16:17:41.766] Packages to be attached in all futures: [n=0] 
[16:17:41.766] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.766] future_lapply() ...
[16:17:41.766] Number of chunks: 1
[16:17:41.767] getGlobalsAndPackagesXApply() ...
[16:17:41.767]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.767]  - use_args: TRUE
[16:17:41.767] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.767] List of 2
[16:17:41.767]  $ ...          : list()
[16:17:41.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.767]  $ ...future.FUN:function (x)  
[16:17:41.767]  - attr(*, "where")=List of 2
[16:17:41.767]   ..$ ...          :<environment: 0x555be0144880> 
[16:17:41.767]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:41.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.767]  - attr(*, "resolved")= logi FALSE
[16:17:41.767]  - attr(*, "total_size")= num NA
[16:17:41.770] Packages to be attached in all futures: [n=0] 
[16:17:41.770] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.770] Number of futures (= number of chunks): 1
[16:17:41.770] Launching 1 futures (chunks) ...
[16:17:41.770] Chunk #1 of 1 ...
[16:17:41.771]  - seeds: <none>
[16:17:41.771]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.771] getGlobalsAndPackages() ...
[16:17:41.771] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.771] Resolving globals: FALSE
[16:17:41.771] Tweak future expression to call with '...' arguments ...
[16:17:41.771] {
[16:17:41.771]     do.call(function(...) {
[16:17:41.771]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.771]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.771]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.771]             on.exit(options(oopts), add = TRUE)
[16:17:41.771]         }
[16:17:41.771]         {
[16:17:41.771]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.771]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.771]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.771]             })
[16:17:41.771]         }
[16:17:41.771]     }, args = future.call.arguments)
[16:17:41.771] }
[16:17:41.772] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.772] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.773] 
[16:17:41.773] getGlobalsAndPackages() ... DONE
[16:17:41.773] run() for ‘Future’ ...
[16:17:41.773] - state: ‘created’
[16:17:41.773] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:41.774] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.774] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:41.774]   - Field: ‘label’
[16:17:41.774]   - Field: ‘local’
[16:17:41.774]   - Field: ‘owner’
[16:17:41.774]   - Field: ‘envir’
[16:17:41.774]   - Field: ‘packages’
[16:17:41.774]   - Field: ‘gc’
[16:17:41.774]   - Field: ‘conditions’
[16:17:41.774]   - Field: ‘expr’
[16:17:41.774]   - Field: ‘uuid’
[16:17:41.775]   - Field: ‘seed’
[16:17:41.775]   - Field: ‘version’
[16:17:41.775]   - Field: ‘result’
[16:17:41.775]   - Field: ‘asynchronous’
[16:17:41.775]   - Field: ‘calls’
[16:17:41.775]   - Field: ‘globals’
[16:17:41.775]   - Field: ‘stdout’
[16:17:41.775]   - Field: ‘earlySignal’
[16:17:41.775]   - Field: ‘lazy’
[16:17:41.775]   - Field: ‘state’
[16:17:41.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:41.776] - Launch lazy future ...
[16:17:41.776] Packages needed by the future expression (n = 0): <none>
[16:17:41.776] Packages needed by future strategies (n = 0): <none>
[16:17:41.776] {
[16:17:41.776]     {
[16:17:41.776]         {
[16:17:41.776]             ...future.startTime <- base::Sys.time()
[16:17:41.776]             {
[16:17:41.776]                 {
[16:17:41.776]                   {
[16:17:41.776]                     base::local({
[16:17:41.776]                       has_future <- base::requireNamespace("future", 
[16:17:41.776]                         quietly = TRUE)
[16:17:41.776]                       if (has_future) {
[16:17:41.776]                         ns <- base::getNamespace("future")
[16:17:41.776]                         version <- ns[[".package"]][["version"]]
[16:17:41.776]                         if (is.null(version)) 
[16:17:41.776]                           version <- utils::packageVersion("future")
[16:17:41.776]                       }
[16:17:41.776]                       else {
[16:17:41.776]                         version <- NULL
[16:17:41.776]                       }
[16:17:41.776]                       if (!has_future || version < "1.8.0") {
[16:17:41.776]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:41.776]                           "", base::R.version$version.string), 
[16:17:41.776]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:41.776]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:41.776]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:41.776]                             "release", "version")], collapse = " "), 
[16:17:41.776]                           hostname = base::Sys.info()[["nodename"]])
[16:17:41.776]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:41.776]                           info)
[16:17:41.776]                         info <- base::paste(info, collapse = "; ")
[16:17:41.776]                         if (!has_future) {
[16:17:41.776]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:41.776]                             info)
[16:17:41.776]                         }
[16:17:41.776]                         else {
[16:17:41.776]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:41.776]                             info, version)
[16:17:41.776]                         }
[16:17:41.776]                         base::stop(msg)
[16:17:41.776]                       }
[16:17:41.776]                     })
[16:17:41.776]                   }
[16:17:41.776]                   ...future.strategy.old <- future::plan("list")
[16:17:41.776]                   options(future.plan = NULL)
[16:17:41.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:41.776]                 }
[16:17:41.776]                 ...future.workdir <- getwd()
[16:17:41.776]             }
[16:17:41.776]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:41.776]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:41.776]         }
[16:17:41.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:41.776]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:41.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:41.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:41.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:41.776]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:41.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:41.776]             base::names(...future.oldOptions))
[16:17:41.776]     }
[16:17:41.776]     if (FALSE) {
[16:17:41.776]     }
[16:17:41.776]     else {
[16:17:41.776]         if (TRUE) {
[16:17:41.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:41.776]                 open = "w")
[16:17:41.776]         }
[16:17:41.776]         else {
[16:17:41.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:41.776]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:41.776]         }
[16:17:41.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:41.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:41.776]             base::sink(type = "output", split = FALSE)
[16:17:41.776]             base::close(...future.stdout)
[16:17:41.776]         }, add = TRUE)
[16:17:41.776]     }
[16:17:41.776]     ...future.frame <- base::sys.nframe()
[16:17:41.776]     ...future.conditions <- base::list()
[16:17:41.776]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:41.776]     if (FALSE) {
[16:17:41.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:41.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:41.776]     }
[16:17:41.776]     ...future.result <- base::tryCatch({
[16:17:41.776]         base::withCallingHandlers({
[16:17:41.776]             ...future.value <- base::withVisible(base::local({
[16:17:41.776]                 do.call(function(...) {
[16:17:41.776]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.776]                   if (!identical(...future.globals.maxSize.org, 
[16:17:41.776]                     ...future.globals.maxSize)) {
[16:17:41.776]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.776]                     on.exit(options(oopts), add = TRUE)
[16:17:41.776]                   }
[16:17:41.776]                   {
[16:17:41.776]                     lapply(seq_along(...future.elements_ii), 
[16:17:41.776]                       FUN = function(jj) {
[16:17:41.776]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.776]                         ...future.FUN(...future.X_jj, ...)
[16:17:41.776]                       })
[16:17:41.776]                   }
[16:17:41.776]                 }, args = future.call.arguments)
[16:17:41.776]             }))
[16:17:41.776]             future::FutureResult(value = ...future.value$value, 
[16:17:41.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.776]                   ...future.rng), globalenv = if (FALSE) 
[16:17:41.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:41.776]                     ...future.globalenv.names))
[16:17:41.776]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:41.776]         }, condition = base::local({
[16:17:41.776]             c <- base::c
[16:17:41.776]             inherits <- base::inherits
[16:17:41.776]             invokeRestart <- base::invokeRestart
[16:17:41.776]             length <- base::length
[16:17:41.776]             list <- base::list
[16:17:41.776]             seq.int <- base::seq.int
[16:17:41.776]             signalCondition <- base::signalCondition
[16:17:41.776]             sys.calls <- base::sys.calls
[16:17:41.776]             `[[` <- base::`[[`
[16:17:41.776]             `+` <- base::`+`
[16:17:41.776]             `<<-` <- base::`<<-`
[16:17:41.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:41.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:41.776]                   3L)]
[16:17:41.776]             }
[16:17:41.776]             function(cond) {
[16:17:41.776]                 is_error <- inherits(cond, "error")
[16:17:41.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:41.776]                   NULL)
[16:17:41.776]                 if (is_error) {
[16:17:41.776]                   sessionInformation <- function() {
[16:17:41.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:41.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:41.776]                       search = base::search(), system = base::Sys.info())
[16:17:41.776]                   }
[16:17:41.776]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:41.776]                     cond$call), session = sessionInformation(), 
[16:17:41.776]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:41.776]                   signalCondition(cond)
[16:17:41.776]                 }
[16:17:41.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:41.776]                 "immediateCondition"))) {
[16:17:41.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:41.776]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:41.776]                   if (TRUE && !signal) {
[16:17:41.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.776]                     {
[16:17:41.776]                       inherits <- base::inherits
[16:17:41.776]                       invokeRestart <- base::invokeRestart
[16:17:41.776]                       is.null <- base::is.null
[16:17:41.776]                       muffled <- FALSE
[16:17:41.776]                       if (inherits(cond, "message")) {
[16:17:41.776]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.776]                         if (muffled) 
[16:17:41.776]                           invokeRestart("muffleMessage")
[16:17:41.776]                       }
[16:17:41.776]                       else if (inherits(cond, "warning")) {
[16:17:41.776]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.776]                         if (muffled) 
[16:17:41.776]                           invokeRestart("muffleWarning")
[16:17:41.776]                       }
[16:17:41.776]                       else if (inherits(cond, "condition")) {
[16:17:41.776]                         if (!is.null(pattern)) {
[16:17:41.776]                           computeRestarts <- base::computeRestarts
[16:17:41.776]                           grepl <- base::grepl
[16:17:41.776]                           restarts <- computeRestarts(cond)
[16:17:41.776]                           for (restart in restarts) {
[16:17:41.776]                             name <- restart$name
[16:17:41.776]                             if (is.null(name)) 
[16:17:41.776]                               next
[16:17:41.776]                             if (!grepl(pattern, name)) 
[16:17:41.776]                               next
[16:17:41.776]                             invokeRestart(restart)
[16:17:41.776]                             muffled <- TRUE
[16:17:41.776]                             break
[16:17:41.776]                           }
[16:17:41.776]                         }
[16:17:41.776]                       }
[16:17:41.776]                       invisible(muffled)
[16:17:41.776]                     }
[16:17:41.776]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.776]                   }
[16:17:41.776]                 }
[16:17:41.776]                 else {
[16:17:41.776]                   if (TRUE) {
[16:17:41.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.776]                     {
[16:17:41.776]                       inherits <- base::inherits
[16:17:41.776]                       invokeRestart <- base::invokeRestart
[16:17:41.776]                       is.null <- base::is.null
[16:17:41.776]                       muffled <- FALSE
[16:17:41.776]                       if (inherits(cond, "message")) {
[16:17:41.776]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.776]                         if (muffled) 
[16:17:41.776]                           invokeRestart("muffleMessage")
[16:17:41.776]                       }
[16:17:41.776]                       else if (inherits(cond, "warning")) {
[16:17:41.776]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.776]                         if (muffled) 
[16:17:41.776]                           invokeRestart("muffleWarning")
[16:17:41.776]                       }
[16:17:41.776]                       else if (inherits(cond, "condition")) {
[16:17:41.776]                         if (!is.null(pattern)) {
[16:17:41.776]                           computeRestarts <- base::computeRestarts
[16:17:41.776]                           grepl <- base::grepl
[16:17:41.776]                           restarts <- computeRestarts(cond)
[16:17:41.776]                           for (restart in restarts) {
[16:17:41.776]                             name <- restart$name
[16:17:41.776]                             if (is.null(name)) 
[16:17:41.776]                               next
[16:17:41.776]                             if (!grepl(pattern, name)) 
[16:17:41.776]                               next
[16:17:41.776]                             invokeRestart(restart)
[16:17:41.776]                             muffled <- TRUE
[16:17:41.776]                             break
[16:17:41.776]                           }
[16:17:41.776]                         }
[16:17:41.776]                       }
[16:17:41.776]                       invisible(muffled)
[16:17:41.776]                     }
[16:17:41.776]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.776]                   }
[16:17:41.776]                 }
[16:17:41.776]             }
[16:17:41.776]         }))
[16:17:41.776]     }, error = function(ex) {
[16:17:41.776]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:41.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.776]                 ...future.rng), started = ...future.startTime, 
[16:17:41.776]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:41.776]             version = "1.8"), class = "FutureResult")
[16:17:41.776]     }, finally = {
[16:17:41.776]         if (!identical(...future.workdir, getwd())) 
[16:17:41.776]             setwd(...future.workdir)
[16:17:41.776]         {
[16:17:41.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:41.776]                 ...future.oldOptions$nwarnings <- NULL
[16:17:41.776]             }
[16:17:41.776]             base::options(...future.oldOptions)
[16:17:41.776]             if (.Platform$OS.type == "windows") {
[16:17:41.776]                 old_names <- names(...future.oldEnvVars)
[16:17:41.776]                 envs <- base::Sys.getenv()
[16:17:41.776]                 names <- names(envs)
[16:17:41.776]                 common <- intersect(names, old_names)
[16:17:41.776]                 added <- setdiff(names, old_names)
[16:17:41.776]                 removed <- setdiff(old_names, names)
[16:17:41.776]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:41.776]                   envs[common]]
[16:17:41.776]                 NAMES <- toupper(changed)
[16:17:41.776]                 args <- list()
[16:17:41.776]                 for (kk in seq_along(NAMES)) {
[16:17:41.776]                   name <- changed[[kk]]
[16:17:41.776]                   NAME <- NAMES[[kk]]
[16:17:41.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.776]                     next
[16:17:41.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.776]                 }
[16:17:41.776]                 NAMES <- toupper(added)
[16:17:41.776]                 for (kk in seq_along(NAMES)) {
[16:17:41.776]                   name <- added[[kk]]
[16:17:41.776]                   NAME <- NAMES[[kk]]
[16:17:41.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.776]                     next
[16:17:41.776]                   args[[name]] <- ""
[16:17:41.776]                 }
[16:17:41.776]                 NAMES <- toupper(removed)
[16:17:41.776]                 for (kk in seq_along(NAMES)) {
[16:17:41.776]                   name <- removed[[kk]]
[16:17:41.776]                   NAME <- NAMES[[kk]]
[16:17:41.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.776]                     next
[16:17:41.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.776]                 }
[16:17:41.776]                 if (length(args) > 0) 
[16:17:41.776]                   base::do.call(base::Sys.setenv, args = args)
[16:17:41.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:41.776]             }
[16:17:41.776]             else {
[16:17:41.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:41.776]             }
[16:17:41.776]             {
[16:17:41.776]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:41.776]                   0L) {
[16:17:41.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:41.776]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:41.776]                   base::options(opts)
[16:17:41.776]                 }
[16:17:41.776]                 {
[16:17:41.776]                   {
[16:17:41.776]                     NULL
[16:17:41.776]                     RNGkind("Mersenne-Twister")
[16:17:41.776]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:41.776]                       inherits = FALSE)
[16:17:41.776]                   }
[16:17:41.776]                   options(future.plan = NULL)
[16:17:41.776]                   if (is.na(NA_character_)) 
[16:17:41.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:41.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:41.776]                     .init = FALSE)
[16:17:41.776]                 }
[16:17:41.776]             }
[16:17:41.776]         }
[16:17:41.776]     })
[16:17:41.776]     if (TRUE) {
[16:17:41.776]         base::sink(type = "output", split = FALSE)
[16:17:41.776]         if (TRUE) {
[16:17:41.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:41.776]         }
[16:17:41.776]         else {
[16:17:41.776]             ...future.result["stdout"] <- base::list(NULL)
[16:17:41.776]         }
[16:17:41.776]         base::close(...future.stdout)
[16:17:41.776]         ...future.stdout <- NULL
[16:17:41.776]     }
[16:17:41.776]     ...future.result$conditions <- ...future.conditions
[16:17:41.776]     ...future.result$finished <- base::Sys.time()
[16:17:41.776]     ...future.result
[16:17:41.776] }
[16:17:41.778] assign_globals() ...
[16:17:41.778] List of 5
[16:17:41.778]  $ future.call.arguments    : list()
[16:17:41.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.778]  $ ...future.FUN            :function (x)  
[16:17:41.778]  $ ...future.elements_ii    :List of 2
[16:17:41.778]   ..$ : int 1
[16:17:41.778]   ..$ : int 2
[16:17:41.778]  $ ...future.seeds_ii       : NULL
[16:17:41.778]  $ ...future.globals.maxSize: num Inf
[16:17:41.778]  - attr(*, "resolved")= logi FALSE
[16:17:41.778]  - attr(*, "total_size")= num NA
[16:17:41.778]  - attr(*, "where")=List of 5
[16:17:41.778]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:41.778]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:41.778]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:41.778]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:41.778]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:41.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.778]  - attr(*, "already-done")= logi TRUE
[16:17:41.783] - copied ‘future.call.arguments’ to environment
[16:17:41.783] - copied ‘...future.FUN’ to environment
[16:17:41.783] - copied ‘...future.elements_ii’ to environment
[16:17:41.783] - copied ‘...future.seeds_ii’ to environment
[16:17:41.783] - copied ‘...future.globals.maxSize’ to environment
[16:17:41.783] assign_globals() ... done
[16:17:41.783] plan(): Setting new future strategy stack:
[16:17:41.784] List of future strategies:
[16:17:41.784] 1. sequential:
[16:17:41.784]    - args: function (..., envir = parent.frame())
[16:17:41.784]    - tweaked: FALSE
[16:17:41.784]    - call: NULL
[16:17:41.784] plan(): nbrOfWorkers() = 1
[16:17:41.785] plan(): Setting new future strategy stack:
[16:17:41.785] List of future strategies:
[16:17:41.785] 1. sequential:
[16:17:41.785]    - args: function (..., envir = parent.frame())
[16:17:41.785]    - tweaked: FALSE
[16:17:41.785]    - call: plan(strategy)
[16:17:41.785] plan(): nbrOfWorkers() = 1
[16:17:41.785] SequentialFuture started (and completed)
[16:17:41.785] - Launch lazy future ... done
[16:17:41.785] run() for ‘SequentialFuture’ ... done
[16:17:41.785] Created future:
[16:17:41.786] SequentialFuture:
[16:17:41.786] Label: ‘future_apply-1’
[16:17:41.786] Expression:
[16:17:41.786] {
[16:17:41.786]     do.call(function(...) {
[16:17:41.786]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.786]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.786]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.786]             on.exit(options(oopts), add = TRUE)
[16:17:41.786]         }
[16:17:41.786]         {
[16:17:41.786]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.786]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.786]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.786]             })
[16:17:41.786]         }
[16:17:41.786]     }, args = future.call.arguments)
[16:17:41.786] }
[16:17:41.786] Lazy evaluation: FALSE
[16:17:41.786] Asynchronous evaluation: FALSE
[16:17:41.786] Local evaluation: TRUE
[16:17:41.786] Environment: R_GlobalEnv
[16:17:41.786] Capture standard output: TRUE
[16:17:41.786] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:41.786] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:41.786] Packages: <none>
[16:17:41.786] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:41.786] Resolved: TRUE
[16:17:41.786] Value: 112 bytes of class ‘list’
[16:17:41.786] Early signaling: FALSE
[16:17:41.786] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:41.786] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.786] Chunk #1 of 1 ... DONE
[16:17:41.787] Launching 1 futures (chunks) ... DONE
[16:17:41.787] Resolving 1 futures (chunks) ...
[16:17:41.787] resolve() on list ...
[16:17:41.787]  recursive: 0
[16:17:41.787]  length: 1
[16:17:41.787] 
[16:17:41.787] resolved() for ‘SequentialFuture’ ...
[16:17:41.787] - state: ‘finished’
[16:17:41.787] - run: TRUE
[16:17:41.787] - result: ‘FutureResult’
[16:17:41.787] resolved() for ‘SequentialFuture’ ... done
[16:17:41.787] Future #1
[16:17:41.788] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:41.788] - nx: 1
[16:17:41.788] - relay: TRUE
[16:17:41.788] - stdout: TRUE
[16:17:41.788] - signal: TRUE
[16:17:41.788] - resignal: FALSE
[16:17:41.788] - force: TRUE
[16:17:41.788] - relayed: [n=1] FALSE
[16:17:41.788] - queued futures: [n=1] FALSE
[16:17:41.788]  - until=1
[16:17:41.788]  - relaying element #1
[16:17:41.789] - relayed: [n=1] TRUE
[16:17:41.789] - queued futures: [n=1] TRUE
[16:17:41.789] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:41.789]  length: 0 (resolved future 1)
[16:17:41.789] Relaying remaining futures
[16:17:41.789] signalConditionsASAP(NULL, pos=0) ...
[16:17:41.789] - nx: 1
[16:17:41.789] - relay: TRUE
[16:17:41.789] - stdout: TRUE
[16:17:41.789] - signal: TRUE
[16:17:41.789] - resignal: FALSE
[16:17:41.790] - force: TRUE
[16:17:41.790] - relayed: [n=1] TRUE
[16:17:41.790] - queued futures: [n=1] TRUE
 - flush all
[16:17:41.790] - relayed: [n=1] TRUE
[16:17:41.790] - queued futures: [n=1] TRUE
[16:17:41.790] signalConditionsASAP(NULL, pos=0) ... done
[16:17:41.790] resolve() on list ... DONE
[16:17:41.790]  - Number of value chunks collected: 1
[16:17:41.790] Resolving 1 futures (chunks) ... DONE
[16:17:41.790] Reducing values from 1 chunks ...
[16:17:41.790]  - Number of values collected after concatenation: 2
[16:17:41.791]  - Number of values expected: 2
[16:17:41.791] Reducing values from 1 chunks ... DONE
[16:17:41.791] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:17:41.791] getGlobalsAndPackagesXApply() ...
[16:17:41.791]  - future.globals: TRUE
[16:17:41.791] getGlobalsAndPackages() ...
[16:17:41.791] Searching for globals...
[16:17:41.792] - globals found: [1] ‘FUN’
[16:17:41.792] Searching for globals ... DONE
[16:17:41.792] Resolving globals: FALSE
[16:17:41.793] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:41.793] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:41.793] - globals: [1] ‘FUN’
[16:17:41.793] 
[16:17:41.793] getGlobalsAndPackages() ... DONE
[16:17:41.793]  - globals found/used: [n=1] ‘FUN’
[16:17:41.793]  - needed namespaces: [n=0] 
[16:17:41.793] Finding globals ... DONE
[16:17:41.794]  - use_args: TRUE
[16:17:41.794]  - Getting '...' globals ...
[16:17:41.794] resolve() on list ...
[16:17:41.794]  recursive: 0
[16:17:41.794]  length: 1
[16:17:41.794]  elements: ‘...’
[16:17:41.794]  length: 0 (resolved future 1)
[16:17:41.794] resolve() on list ... DONE
[16:17:41.794]    - '...' content: [n=0] 
[16:17:41.795] List of 1
[16:17:41.795]  $ ...: list()
[16:17:41.795]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.795]  - attr(*, "where")=List of 1
[16:17:41.795]   ..$ ...:<environment: 0x555be2690af8> 
[16:17:41.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.795]  - attr(*, "resolved")= logi TRUE
[16:17:41.795]  - attr(*, "total_size")= num NA
[16:17:41.798]  - Getting '...' globals ... DONE
[16:17:41.798] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.798] List of 2
[16:17:41.798]  $ ...future.FUN:function (x)  
[16:17:41.798]  $ ...          : list()
[16:17:41.798]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.798]  - attr(*, "where")=List of 2
[16:17:41.798]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.798]   ..$ ...          :<environment: 0x555be2690af8> 
[16:17:41.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.798]  - attr(*, "resolved")= logi FALSE
[16:17:41.798]  - attr(*, "total_size")= num 848
[16:17:41.800] Packages to be attached in all futures: [n=0] 
[16:17:41.801] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.801] future_lapply() ...
[16:17:41.801] Number of chunks: 1
[16:17:41.801] getGlobalsAndPackagesXApply() ...
[16:17:41.801]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.801]  - use_args: TRUE
[16:17:41.802] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.802] List of 2
[16:17:41.802]  $ ...          : list()
[16:17:41.802]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.802]  $ ...future.FUN:function (x)  
[16:17:41.802]  - attr(*, "where")=List of 2
[16:17:41.802]   ..$ ...          :<environment: 0x555be2690af8> 
[16:17:41.802]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:41.802]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.802]  - attr(*, "resolved")= logi FALSE
[16:17:41.802]  - attr(*, "total_size")= num NA
[16:17:41.805] Packages to be attached in all futures: [n=0] 
[16:17:41.805] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.805] Number of futures (= number of chunks): 1
[16:17:41.805] Launching 1 futures (chunks) ...
[16:17:41.805] Chunk #1 of 1 ...
[16:17:41.805]  - seeds: <none>
[16:17:41.805]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.805] getGlobalsAndPackages() ...
[16:17:41.805] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.806] Resolving globals: FALSE
[16:17:41.806] Tweak future expression to call with '...' arguments ...
[16:17:41.806] {
[16:17:41.806]     do.call(function(...) {
[16:17:41.806]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.806]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.806]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.806]             on.exit(options(oopts), add = TRUE)
[16:17:41.806]         }
[16:17:41.806]         {
[16:17:41.806]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.806]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.806]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.806]             })
[16:17:41.806]         }
[16:17:41.806]     }, args = future.call.arguments)
[16:17:41.806] }
[16:17:41.806] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.806] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.806] 
[16:17:41.807] getGlobalsAndPackages() ... DONE
[16:17:41.807] run() for ‘Future’ ...
[16:17:41.807] - state: ‘created’
[16:17:41.807] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:41.807] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.807] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:41.807]   - Field: ‘label’
[16:17:41.808]   - Field: ‘local’
[16:17:41.808]   - Field: ‘owner’
[16:17:41.808]   - Field: ‘envir’
[16:17:41.808]   - Field: ‘packages’
[16:17:41.808]   - Field: ‘gc’
[16:17:41.808]   - Field: ‘conditions’
[16:17:41.808]   - Field: ‘expr’
[16:17:41.808]   - Field: ‘uuid’
[16:17:41.808]   - Field: ‘seed’
[16:17:41.808]   - Field: ‘version’
[16:17:41.808]   - Field: ‘result’
[16:17:41.809]   - Field: ‘asynchronous’
[16:17:41.809]   - Field: ‘calls’
[16:17:41.809]   - Field: ‘globals’
[16:17:41.809]   - Field: ‘stdout’
[16:17:41.809]   - Field: ‘earlySignal’
[16:17:41.809]   - Field: ‘lazy’
[16:17:41.809]   - Field: ‘state’
[16:17:41.809] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:41.809] - Launch lazy future ...
[16:17:41.809] Packages needed by the future expression (n = 0): <none>
[16:17:41.809] Packages needed by future strategies (n = 0): <none>
[16:17:41.810] {
[16:17:41.810]     {
[16:17:41.810]         {
[16:17:41.810]             ...future.startTime <- base::Sys.time()
[16:17:41.810]             {
[16:17:41.810]                 {
[16:17:41.810]                   {
[16:17:41.810]                     base::local({
[16:17:41.810]                       has_future <- base::requireNamespace("future", 
[16:17:41.810]                         quietly = TRUE)
[16:17:41.810]                       if (has_future) {
[16:17:41.810]                         ns <- base::getNamespace("future")
[16:17:41.810]                         version <- ns[[".package"]][["version"]]
[16:17:41.810]                         if (is.null(version)) 
[16:17:41.810]                           version <- utils::packageVersion("future")
[16:17:41.810]                       }
[16:17:41.810]                       else {
[16:17:41.810]                         version <- NULL
[16:17:41.810]                       }
[16:17:41.810]                       if (!has_future || version < "1.8.0") {
[16:17:41.810]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:41.810]                           "", base::R.version$version.string), 
[16:17:41.810]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:41.810]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:41.810]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:41.810]                             "release", "version")], collapse = " "), 
[16:17:41.810]                           hostname = base::Sys.info()[["nodename"]])
[16:17:41.810]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:41.810]                           info)
[16:17:41.810]                         info <- base::paste(info, collapse = "; ")
[16:17:41.810]                         if (!has_future) {
[16:17:41.810]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:41.810]                             info)
[16:17:41.810]                         }
[16:17:41.810]                         else {
[16:17:41.810]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:41.810]                             info, version)
[16:17:41.810]                         }
[16:17:41.810]                         base::stop(msg)
[16:17:41.810]                       }
[16:17:41.810]                     })
[16:17:41.810]                   }
[16:17:41.810]                   ...future.strategy.old <- future::plan("list")
[16:17:41.810]                   options(future.plan = NULL)
[16:17:41.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:41.810]                 }
[16:17:41.810]                 ...future.workdir <- getwd()
[16:17:41.810]             }
[16:17:41.810]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:41.810]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:41.810]         }
[16:17:41.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:41.810]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:41.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:41.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:41.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:41.810]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:41.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:41.810]             base::names(...future.oldOptions))
[16:17:41.810]     }
[16:17:41.810]     if (FALSE) {
[16:17:41.810]     }
[16:17:41.810]     else {
[16:17:41.810]         if (TRUE) {
[16:17:41.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:41.810]                 open = "w")
[16:17:41.810]         }
[16:17:41.810]         else {
[16:17:41.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:41.810]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:41.810]         }
[16:17:41.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:41.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:41.810]             base::sink(type = "output", split = FALSE)
[16:17:41.810]             base::close(...future.stdout)
[16:17:41.810]         }, add = TRUE)
[16:17:41.810]     }
[16:17:41.810]     ...future.frame <- base::sys.nframe()
[16:17:41.810]     ...future.conditions <- base::list()
[16:17:41.810]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:41.810]     if (FALSE) {
[16:17:41.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:41.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:41.810]     }
[16:17:41.810]     ...future.result <- base::tryCatch({
[16:17:41.810]         base::withCallingHandlers({
[16:17:41.810]             ...future.value <- base::withVisible(base::local({
[16:17:41.810]                 do.call(function(...) {
[16:17:41.810]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.810]                   if (!identical(...future.globals.maxSize.org, 
[16:17:41.810]                     ...future.globals.maxSize)) {
[16:17:41.810]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.810]                     on.exit(options(oopts), add = TRUE)
[16:17:41.810]                   }
[16:17:41.810]                   {
[16:17:41.810]                     lapply(seq_along(...future.elements_ii), 
[16:17:41.810]                       FUN = function(jj) {
[16:17:41.810]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.810]                         ...future.FUN(...future.X_jj, ...)
[16:17:41.810]                       })
[16:17:41.810]                   }
[16:17:41.810]                 }, args = future.call.arguments)
[16:17:41.810]             }))
[16:17:41.810]             future::FutureResult(value = ...future.value$value, 
[16:17:41.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.810]                   ...future.rng), globalenv = if (FALSE) 
[16:17:41.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:41.810]                     ...future.globalenv.names))
[16:17:41.810]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:41.810]         }, condition = base::local({
[16:17:41.810]             c <- base::c
[16:17:41.810]             inherits <- base::inherits
[16:17:41.810]             invokeRestart <- base::invokeRestart
[16:17:41.810]             length <- base::length
[16:17:41.810]             list <- base::list
[16:17:41.810]             seq.int <- base::seq.int
[16:17:41.810]             signalCondition <- base::signalCondition
[16:17:41.810]             sys.calls <- base::sys.calls
[16:17:41.810]             `[[` <- base::`[[`
[16:17:41.810]             `+` <- base::`+`
[16:17:41.810]             `<<-` <- base::`<<-`
[16:17:41.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:41.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:41.810]                   3L)]
[16:17:41.810]             }
[16:17:41.810]             function(cond) {
[16:17:41.810]                 is_error <- inherits(cond, "error")
[16:17:41.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:41.810]                   NULL)
[16:17:41.810]                 if (is_error) {
[16:17:41.810]                   sessionInformation <- function() {
[16:17:41.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:41.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:41.810]                       search = base::search(), system = base::Sys.info())
[16:17:41.810]                   }
[16:17:41.810]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:41.810]                     cond$call), session = sessionInformation(), 
[16:17:41.810]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:41.810]                   signalCondition(cond)
[16:17:41.810]                 }
[16:17:41.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:41.810]                 "immediateCondition"))) {
[16:17:41.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:41.810]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:41.810]                   if (TRUE && !signal) {
[16:17:41.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.810]                     {
[16:17:41.810]                       inherits <- base::inherits
[16:17:41.810]                       invokeRestart <- base::invokeRestart
[16:17:41.810]                       is.null <- base::is.null
[16:17:41.810]                       muffled <- FALSE
[16:17:41.810]                       if (inherits(cond, "message")) {
[16:17:41.810]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.810]                         if (muffled) 
[16:17:41.810]                           invokeRestart("muffleMessage")
[16:17:41.810]                       }
[16:17:41.810]                       else if (inherits(cond, "warning")) {
[16:17:41.810]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.810]                         if (muffled) 
[16:17:41.810]                           invokeRestart("muffleWarning")
[16:17:41.810]                       }
[16:17:41.810]                       else if (inherits(cond, "condition")) {
[16:17:41.810]                         if (!is.null(pattern)) {
[16:17:41.810]                           computeRestarts <- base::computeRestarts
[16:17:41.810]                           grepl <- base::grepl
[16:17:41.810]                           restarts <- computeRestarts(cond)
[16:17:41.810]                           for (restart in restarts) {
[16:17:41.810]                             name <- restart$name
[16:17:41.810]                             if (is.null(name)) 
[16:17:41.810]                               next
[16:17:41.810]                             if (!grepl(pattern, name)) 
[16:17:41.810]                               next
[16:17:41.810]                             invokeRestart(restart)
[16:17:41.810]                             muffled <- TRUE
[16:17:41.810]                             break
[16:17:41.810]                           }
[16:17:41.810]                         }
[16:17:41.810]                       }
[16:17:41.810]                       invisible(muffled)
[16:17:41.810]                     }
[16:17:41.810]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.810]                   }
[16:17:41.810]                 }
[16:17:41.810]                 else {
[16:17:41.810]                   if (TRUE) {
[16:17:41.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.810]                     {
[16:17:41.810]                       inherits <- base::inherits
[16:17:41.810]                       invokeRestart <- base::invokeRestart
[16:17:41.810]                       is.null <- base::is.null
[16:17:41.810]                       muffled <- FALSE
[16:17:41.810]                       if (inherits(cond, "message")) {
[16:17:41.810]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.810]                         if (muffled) 
[16:17:41.810]                           invokeRestart("muffleMessage")
[16:17:41.810]                       }
[16:17:41.810]                       else if (inherits(cond, "warning")) {
[16:17:41.810]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.810]                         if (muffled) 
[16:17:41.810]                           invokeRestart("muffleWarning")
[16:17:41.810]                       }
[16:17:41.810]                       else if (inherits(cond, "condition")) {
[16:17:41.810]                         if (!is.null(pattern)) {
[16:17:41.810]                           computeRestarts <- base::computeRestarts
[16:17:41.810]                           grepl <- base::grepl
[16:17:41.810]                           restarts <- computeRestarts(cond)
[16:17:41.810]                           for (restart in restarts) {
[16:17:41.810]                             name <- restart$name
[16:17:41.810]                             if (is.null(name)) 
[16:17:41.810]                               next
[16:17:41.810]                             if (!grepl(pattern, name)) 
[16:17:41.810]                               next
[16:17:41.810]                             invokeRestart(restart)
[16:17:41.810]                             muffled <- TRUE
[16:17:41.810]                             break
[16:17:41.810]                           }
[16:17:41.810]                         }
[16:17:41.810]                       }
[16:17:41.810]                       invisible(muffled)
[16:17:41.810]                     }
[16:17:41.810]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.810]                   }
[16:17:41.810]                 }
[16:17:41.810]             }
[16:17:41.810]         }))
[16:17:41.810]     }, error = function(ex) {
[16:17:41.810]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:41.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.810]                 ...future.rng), started = ...future.startTime, 
[16:17:41.810]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:41.810]             version = "1.8"), class = "FutureResult")
[16:17:41.810]     }, finally = {
[16:17:41.810]         if (!identical(...future.workdir, getwd())) 
[16:17:41.810]             setwd(...future.workdir)
[16:17:41.810]         {
[16:17:41.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:41.810]                 ...future.oldOptions$nwarnings <- NULL
[16:17:41.810]             }
[16:17:41.810]             base::options(...future.oldOptions)
[16:17:41.810]             if (.Platform$OS.type == "windows") {
[16:17:41.810]                 old_names <- names(...future.oldEnvVars)
[16:17:41.810]                 envs <- base::Sys.getenv()
[16:17:41.810]                 names <- names(envs)
[16:17:41.810]                 common <- intersect(names, old_names)
[16:17:41.810]                 added <- setdiff(names, old_names)
[16:17:41.810]                 removed <- setdiff(old_names, names)
[16:17:41.810]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:41.810]                   envs[common]]
[16:17:41.810]                 NAMES <- toupper(changed)
[16:17:41.810]                 args <- list()
[16:17:41.810]                 for (kk in seq_along(NAMES)) {
[16:17:41.810]                   name <- changed[[kk]]
[16:17:41.810]                   NAME <- NAMES[[kk]]
[16:17:41.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.810]                     next
[16:17:41.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.810]                 }
[16:17:41.810]                 NAMES <- toupper(added)
[16:17:41.810]                 for (kk in seq_along(NAMES)) {
[16:17:41.810]                   name <- added[[kk]]
[16:17:41.810]                   NAME <- NAMES[[kk]]
[16:17:41.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.810]                     next
[16:17:41.810]                   args[[name]] <- ""
[16:17:41.810]                 }
[16:17:41.810]                 NAMES <- toupper(removed)
[16:17:41.810]                 for (kk in seq_along(NAMES)) {
[16:17:41.810]                   name <- removed[[kk]]
[16:17:41.810]                   NAME <- NAMES[[kk]]
[16:17:41.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.810]                     next
[16:17:41.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.810]                 }
[16:17:41.810]                 if (length(args) > 0) 
[16:17:41.810]                   base::do.call(base::Sys.setenv, args = args)
[16:17:41.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:41.810]             }
[16:17:41.810]             else {
[16:17:41.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:41.810]             }
[16:17:41.810]             {
[16:17:41.810]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:41.810]                   0L) {
[16:17:41.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:41.810]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:41.810]                   base::options(opts)
[16:17:41.810]                 }
[16:17:41.810]                 {
[16:17:41.810]                   {
[16:17:41.810]                     NULL
[16:17:41.810]                     RNGkind("Mersenne-Twister")
[16:17:41.810]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:41.810]                       inherits = FALSE)
[16:17:41.810]                   }
[16:17:41.810]                   options(future.plan = NULL)
[16:17:41.810]                   if (is.na(NA_character_)) 
[16:17:41.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:41.810]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:41.810]                     .init = FALSE)
[16:17:41.810]                 }
[16:17:41.810]             }
[16:17:41.810]         }
[16:17:41.810]     })
[16:17:41.810]     if (TRUE) {
[16:17:41.810]         base::sink(type = "output", split = FALSE)
[16:17:41.810]         if (TRUE) {
[16:17:41.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:41.810]         }
[16:17:41.810]         else {
[16:17:41.810]             ...future.result["stdout"] <- base::list(NULL)
[16:17:41.810]         }
[16:17:41.810]         base::close(...future.stdout)
[16:17:41.810]         ...future.stdout <- NULL
[16:17:41.810]     }
[16:17:41.810]     ...future.result$conditions <- ...future.conditions
[16:17:41.810]     ...future.result$finished <- base::Sys.time()
[16:17:41.810]     ...future.result
[16:17:41.810] }
[16:17:41.812] assign_globals() ...
[16:17:41.812] List of 5
[16:17:41.812]  $ future.call.arguments    : list()
[16:17:41.812]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.812]  $ ...future.FUN            :function (x)  
[16:17:41.812]  $ ...future.elements_ii    :List of 2
[16:17:41.812]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[16:17:41.812]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[16:17:41.812]  $ ...future.seeds_ii       : NULL
[16:17:41.812]  $ ...future.globals.maxSize: num Inf
[16:17:41.812]  - attr(*, "resolved")= logi FALSE
[16:17:41.812]  - attr(*, "total_size")= num NA
[16:17:41.812]  - attr(*, "where")=List of 5
[16:17:41.812]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:41.812]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:41.812]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:41.812]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:41.812]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:41.812]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.812]  - attr(*, "already-done")= logi TRUE
[16:17:41.816] - copied ‘future.call.arguments’ to environment
[16:17:41.817] - copied ‘...future.FUN’ to environment
[16:17:41.817] - copied ‘...future.elements_ii’ to environment
[16:17:41.817] - copied ‘...future.seeds_ii’ to environment
[16:17:41.817] - copied ‘...future.globals.maxSize’ to environment
[16:17:41.817] assign_globals() ... done
[16:17:41.818] plan(): Setting new future strategy stack:
[16:17:41.818] List of future strategies:
[16:17:41.818] 1. sequential:
[16:17:41.818]    - args: function (..., envir = parent.frame())
[16:17:41.818]    - tweaked: FALSE
[16:17:41.818]    - call: NULL
[16:17:41.818] plan(): nbrOfWorkers() = 1
[16:17:41.819] plan(): Setting new future strategy stack:
[16:17:41.819] List of future strategies:
[16:17:41.819] 1. sequential:
[16:17:41.819]    - args: function (..., envir = parent.frame())
[16:17:41.819]    - tweaked: FALSE
[16:17:41.819]    - call: plan(strategy)
[16:17:41.819] plan(): nbrOfWorkers() = 1
[16:17:41.820] SequentialFuture started (and completed)
[16:17:41.820] - Launch lazy future ... done
[16:17:41.820] run() for ‘SequentialFuture’ ... done
[16:17:41.820] Created future:
[16:17:41.820] SequentialFuture:
[16:17:41.820] Label: ‘future_apply-1’
[16:17:41.820] Expression:
[16:17:41.820] {
[16:17:41.820]     do.call(function(...) {
[16:17:41.820]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.820]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.820]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.820]             on.exit(options(oopts), add = TRUE)
[16:17:41.820]         }
[16:17:41.820]         {
[16:17:41.820]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.820]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.820]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.820]             })
[16:17:41.820]         }
[16:17:41.820]     }, args = future.call.arguments)
[16:17:41.820] }
[16:17:41.820] Lazy evaluation: FALSE
[16:17:41.820] Asynchronous evaluation: FALSE
[16:17:41.820] Local evaluation: TRUE
[16:17:41.820] Environment: R_GlobalEnv
[16:17:41.820] Capture standard output: TRUE
[16:17:41.820] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:41.820] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:41.820] Packages: <none>
[16:17:41.820] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:41.820] Resolved: TRUE
[16:17:41.820] Value: 496 bytes of class ‘list’
[16:17:41.820] Early signaling: FALSE
[16:17:41.820] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:41.820] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.821] Chunk #1 of 1 ... DONE
[16:17:41.821] Launching 1 futures (chunks) ... DONE
[16:17:41.821] Resolving 1 futures (chunks) ...
[16:17:41.821] resolve() on list ...
[16:17:41.821]  recursive: 0
[16:17:41.821]  length: 1
[16:17:41.822] 
[16:17:41.822] resolved() for ‘SequentialFuture’ ...
[16:17:41.822] - state: ‘finished’
[16:17:41.822] - run: TRUE
[16:17:41.822] - result: ‘FutureResult’
[16:17:41.822] resolved() for ‘SequentialFuture’ ... done
[16:17:41.822] Future #1
[16:17:41.822] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:41.822] - nx: 1
[16:17:41.822] - relay: TRUE
[16:17:41.822] - stdout: TRUE
[16:17:41.823] - signal: TRUE
[16:17:41.823] - resignal: FALSE
[16:17:41.823] - force: TRUE
[16:17:41.823] - relayed: [n=1] FALSE
[16:17:41.823] - queued futures: [n=1] FALSE
[16:17:41.823]  - until=1
[16:17:41.823]  - relaying element #1
[16:17:41.823] - relayed: [n=1] TRUE
[16:17:41.823] - queued futures: [n=1] TRUE
[16:17:41.823] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:41.823]  length: 0 (resolved future 1)
[16:17:41.824] Relaying remaining futures
[16:17:41.824] signalConditionsASAP(NULL, pos=0) ...
[16:17:41.824] - nx: 1
[16:17:41.824] - relay: TRUE
[16:17:41.824] - stdout: TRUE
[16:17:41.824] - signal: TRUE
[16:17:41.824] - resignal: FALSE
[16:17:41.824] - force: TRUE
[16:17:41.824] - relayed: [n=1] TRUE
[16:17:41.824] - queued futures: [n=1] TRUE
 - flush all
[16:17:41.824] - relayed: [n=1] TRUE
[16:17:41.824] - queued futures: [n=1] TRUE
[16:17:41.825] signalConditionsASAP(NULL, pos=0) ... done
[16:17:41.825] resolve() on list ... DONE
[16:17:41.825]  - Number of value chunks collected: 1
[16:17:41.825] Resolving 1 futures (chunks) ... DONE
[16:17:41.825] Reducing values from 1 chunks ...
[16:17:41.825]  - Number of values collected after concatenation: 2
[16:17:41.825]  - Number of values expected: 2
[16:17:41.825] Reducing values from 1 chunks ... DONE
[16:17:41.825] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:17:41.826] getGlobalsAndPackagesXApply() ...
[16:17:41.826]  - future.globals: TRUE
[16:17:41.826] getGlobalsAndPackages() ...
[16:17:41.826] Searching for globals...
[16:17:41.828] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:17:41.828] Searching for globals ... DONE
[16:17:41.828] Resolving globals: FALSE
[16:17:41.829] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:17:41.829] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:17:41.829] - globals: [1] ‘FUN’
[16:17:41.829] 
[16:17:41.829] getGlobalsAndPackages() ... DONE
[16:17:41.830]  - globals found/used: [n=1] ‘FUN’
[16:17:41.830]  - needed namespaces: [n=0] 
[16:17:41.830] Finding globals ... DONE
[16:17:41.830]  - use_args: TRUE
[16:17:41.830]  - Getting '...' globals ...
[16:17:41.830] resolve() on list ...
[16:17:41.830]  recursive: 0
[16:17:41.830]  length: 1
[16:17:41.830]  elements: ‘...’
[16:17:41.831]  length: 0 (resolved future 1)
[16:17:41.831] resolve() on list ... DONE
[16:17:41.831]    - '...' content: [n=0] 
[16:17:41.831] List of 1
[16:17:41.831]  $ ...: list()
[16:17:41.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.831]  - attr(*, "where")=List of 1
[16:17:41.831]   ..$ ...:<environment: 0x555be048f928> 
[16:17:41.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.831]  - attr(*, "resolved")= logi TRUE
[16:17:41.831]  - attr(*, "total_size")= num NA
[16:17:41.833]  - Getting '...' globals ... DONE
[16:17:41.833] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.833] List of 2
[16:17:41.833]  $ ...future.FUN:function (x)  
[16:17:41.833]  $ ...          : list()
[16:17:41.833]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.833]  - attr(*, "where")=List of 2
[16:17:41.833]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.833]   ..$ ...          :<environment: 0x555be048f928> 
[16:17:41.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.833]  - attr(*, "resolved")= logi FALSE
[16:17:41.833]  - attr(*, "total_size")= num 9888
[16:17:41.836] Packages to be attached in all futures: [n=0] 
[16:17:41.836] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.836] future_lapply() ...
[16:17:41.837] Number of chunks: 1
[16:17:41.837] getGlobalsAndPackagesXApply() ...
[16:17:41.838]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.838]  - use_args: TRUE
[16:17:41.839] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.839] List of 2
[16:17:41.839]  $ ...          : list()
[16:17:41.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.839]  $ ...future.FUN:function (x)  
[16:17:41.839]  - attr(*, "where")=List of 2
[16:17:41.839]   ..$ ...          :<environment: 0x555be048f928> 
[16:17:41.839]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:17:41.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.839]  - attr(*, "resolved")= logi FALSE
[16:17:41.839]  - attr(*, "total_size")= num NA
[16:17:41.841] Packages to be attached in all futures: [n=0] 
[16:17:41.841] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.842] Number of futures (= number of chunks): 1
[16:17:41.842] Launching 1 futures (chunks) ...
[16:17:41.842] Chunk #1 of 1 ...
[16:17:41.842]  - seeds: <none>
[16:17:41.842]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.842] getGlobalsAndPackages() ...
[16:17:41.842] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.842] Resolving globals: FALSE
[16:17:41.842] Tweak future expression to call with '...' arguments ...
[16:17:41.843] {
[16:17:41.843]     do.call(function(...) {
[16:17:41.843]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.843]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.843]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.843]             on.exit(options(oopts), add = TRUE)
[16:17:41.843]         }
[16:17:41.843]         {
[16:17:41.843]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.843]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.843]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.843]             })
[16:17:41.843]         }
[16:17:41.843]     }, args = future.call.arguments)
[16:17:41.843] }
[16:17:41.843] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.843] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.843] 
[16:17:41.843] getGlobalsAndPackages() ... DONE
[16:17:41.844] run() for ‘Future’ ...
[16:17:41.844] - state: ‘created’
[16:17:41.844] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:41.844] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.844] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:41.844]   - Field: ‘label’
[16:17:41.844]   - Field: ‘local’
[16:17:41.844]   - Field: ‘owner’
[16:17:41.845]   - Field: ‘envir’
[16:17:41.845]   - Field: ‘packages’
[16:17:41.845]   - Field: ‘gc’
[16:17:41.845]   - Field: ‘conditions’
[16:17:41.845]   - Field: ‘expr’
[16:17:41.845]   - Field: ‘uuid’
[16:17:41.845]   - Field: ‘seed’
[16:17:41.845]   - Field: ‘version’
[16:17:41.845]   - Field: ‘result’
[16:17:41.845]   - Field: ‘asynchronous’
[16:17:41.845]   - Field: ‘calls’
[16:17:41.846]   - Field: ‘globals’
[16:17:41.846]   - Field: ‘stdout’
[16:17:41.846]   - Field: ‘earlySignal’
[16:17:41.846]   - Field: ‘lazy’
[16:17:41.846]   - Field: ‘state’
[16:17:41.846] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:41.846] - Launch lazy future ...
[16:17:41.846] Packages needed by the future expression (n = 0): <none>
[16:17:41.846] Packages needed by future strategies (n = 0): <none>
[16:17:41.847] {
[16:17:41.847]     {
[16:17:41.847]         {
[16:17:41.847]             ...future.startTime <- base::Sys.time()
[16:17:41.847]             {
[16:17:41.847]                 {
[16:17:41.847]                   {
[16:17:41.847]                     base::local({
[16:17:41.847]                       has_future <- base::requireNamespace("future", 
[16:17:41.847]                         quietly = TRUE)
[16:17:41.847]                       if (has_future) {
[16:17:41.847]                         ns <- base::getNamespace("future")
[16:17:41.847]                         version <- ns[[".package"]][["version"]]
[16:17:41.847]                         if (is.null(version)) 
[16:17:41.847]                           version <- utils::packageVersion("future")
[16:17:41.847]                       }
[16:17:41.847]                       else {
[16:17:41.847]                         version <- NULL
[16:17:41.847]                       }
[16:17:41.847]                       if (!has_future || version < "1.8.0") {
[16:17:41.847]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:41.847]                           "", base::R.version$version.string), 
[16:17:41.847]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:41.847]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:41.847]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:41.847]                             "release", "version")], collapse = " "), 
[16:17:41.847]                           hostname = base::Sys.info()[["nodename"]])
[16:17:41.847]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:41.847]                           info)
[16:17:41.847]                         info <- base::paste(info, collapse = "; ")
[16:17:41.847]                         if (!has_future) {
[16:17:41.847]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:41.847]                             info)
[16:17:41.847]                         }
[16:17:41.847]                         else {
[16:17:41.847]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:41.847]                             info, version)
[16:17:41.847]                         }
[16:17:41.847]                         base::stop(msg)
[16:17:41.847]                       }
[16:17:41.847]                     })
[16:17:41.847]                   }
[16:17:41.847]                   ...future.strategy.old <- future::plan("list")
[16:17:41.847]                   options(future.plan = NULL)
[16:17:41.847]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.847]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:41.847]                 }
[16:17:41.847]                 ...future.workdir <- getwd()
[16:17:41.847]             }
[16:17:41.847]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:41.847]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:41.847]         }
[16:17:41.847]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:41.847]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:41.847]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:41.847]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:41.847]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:41.847]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:41.847]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:41.847]             base::names(...future.oldOptions))
[16:17:41.847]     }
[16:17:41.847]     if (FALSE) {
[16:17:41.847]     }
[16:17:41.847]     else {
[16:17:41.847]         if (TRUE) {
[16:17:41.847]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:41.847]                 open = "w")
[16:17:41.847]         }
[16:17:41.847]         else {
[16:17:41.847]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:41.847]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:41.847]         }
[16:17:41.847]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:41.847]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:41.847]             base::sink(type = "output", split = FALSE)
[16:17:41.847]             base::close(...future.stdout)
[16:17:41.847]         }, add = TRUE)
[16:17:41.847]     }
[16:17:41.847]     ...future.frame <- base::sys.nframe()
[16:17:41.847]     ...future.conditions <- base::list()
[16:17:41.847]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:41.847]     if (FALSE) {
[16:17:41.847]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:41.847]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:41.847]     }
[16:17:41.847]     ...future.result <- base::tryCatch({
[16:17:41.847]         base::withCallingHandlers({
[16:17:41.847]             ...future.value <- base::withVisible(base::local({
[16:17:41.847]                 do.call(function(...) {
[16:17:41.847]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.847]                   if (!identical(...future.globals.maxSize.org, 
[16:17:41.847]                     ...future.globals.maxSize)) {
[16:17:41.847]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.847]                     on.exit(options(oopts), add = TRUE)
[16:17:41.847]                   }
[16:17:41.847]                   {
[16:17:41.847]                     lapply(seq_along(...future.elements_ii), 
[16:17:41.847]                       FUN = function(jj) {
[16:17:41.847]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.847]                         ...future.FUN(...future.X_jj, ...)
[16:17:41.847]                       })
[16:17:41.847]                   }
[16:17:41.847]                 }, args = future.call.arguments)
[16:17:41.847]             }))
[16:17:41.847]             future::FutureResult(value = ...future.value$value, 
[16:17:41.847]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.847]                   ...future.rng), globalenv = if (FALSE) 
[16:17:41.847]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:41.847]                     ...future.globalenv.names))
[16:17:41.847]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:41.847]         }, condition = base::local({
[16:17:41.847]             c <- base::c
[16:17:41.847]             inherits <- base::inherits
[16:17:41.847]             invokeRestart <- base::invokeRestart
[16:17:41.847]             length <- base::length
[16:17:41.847]             list <- base::list
[16:17:41.847]             seq.int <- base::seq.int
[16:17:41.847]             signalCondition <- base::signalCondition
[16:17:41.847]             sys.calls <- base::sys.calls
[16:17:41.847]             `[[` <- base::`[[`
[16:17:41.847]             `+` <- base::`+`
[16:17:41.847]             `<<-` <- base::`<<-`
[16:17:41.847]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:41.847]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:41.847]                   3L)]
[16:17:41.847]             }
[16:17:41.847]             function(cond) {
[16:17:41.847]                 is_error <- inherits(cond, "error")
[16:17:41.847]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:41.847]                   NULL)
[16:17:41.847]                 if (is_error) {
[16:17:41.847]                   sessionInformation <- function() {
[16:17:41.847]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:41.847]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:41.847]                       search = base::search(), system = base::Sys.info())
[16:17:41.847]                   }
[16:17:41.847]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.847]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:41.847]                     cond$call), session = sessionInformation(), 
[16:17:41.847]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:41.847]                   signalCondition(cond)
[16:17:41.847]                 }
[16:17:41.847]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:41.847]                 "immediateCondition"))) {
[16:17:41.847]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:41.847]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.847]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:41.847]                   if (TRUE && !signal) {
[16:17:41.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.847]                     {
[16:17:41.847]                       inherits <- base::inherits
[16:17:41.847]                       invokeRestart <- base::invokeRestart
[16:17:41.847]                       is.null <- base::is.null
[16:17:41.847]                       muffled <- FALSE
[16:17:41.847]                       if (inherits(cond, "message")) {
[16:17:41.847]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.847]                         if (muffled) 
[16:17:41.847]                           invokeRestart("muffleMessage")
[16:17:41.847]                       }
[16:17:41.847]                       else if (inherits(cond, "warning")) {
[16:17:41.847]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.847]                         if (muffled) 
[16:17:41.847]                           invokeRestart("muffleWarning")
[16:17:41.847]                       }
[16:17:41.847]                       else if (inherits(cond, "condition")) {
[16:17:41.847]                         if (!is.null(pattern)) {
[16:17:41.847]                           computeRestarts <- base::computeRestarts
[16:17:41.847]                           grepl <- base::grepl
[16:17:41.847]                           restarts <- computeRestarts(cond)
[16:17:41.847]                           for (restart in restarts) {
[16:17:41.847]                             name <- restart$name
[16:17:41.847]                             if (is.null(name)) 
[16:17:41.847]                               next
[16:17:41.847]                             if (!grepl(pattern, name)) 
[16:17:41.847]                               next
[16:17:41.847]                             invokeRestart(restart)
[16:17:41.847]                             muffled <- TRUE
[16:17:41.847]                             break
[16:17:41.847]                           }
[16:17:41.847]                         }
[16:17:41.847]                       }
[16:17:41.847]                       invisible(muffled)
[16:17:41.847]                     }
[16:17:41.847]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.847]                   }
[16:17:41.847]                 }
[16:17:41.847]                 else {
[16:17:41.847]                   if (TRUE) {
[16:17:41.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.847]                     {
[16:17:41.847]                       inherits <- base::inherits
[16:17:41.847]                       invokeRestart <- base::invokeRestart
[16:17:41.847]                       is.null <- base::is.null
[16:17:41.847]                       muffled <- FALSE
[16:17:41.847]                       if (inherits(cond, "message")) {
[16:17:41.847]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.847]                         if (muffled) 
[16:17:41.847]                           invokeRestart("muffleMessage")
[16:17:41.847]                       }
[16:17:41.847]                       else if (inherits(cond, "warning")) {
[16:17:41.847]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.847]                         if (muffled) 
[16:17:41.847]                           invokeRestart("muffleWarning")
[16:17:41.847]                       }
[16:17:41.847]                       else if (inherits(cond, "condition")) {
[16:17:41.847]                         if (!is.null(pattern)) {
[16:17:41.847]                           computeRestarts <- base::computeRestarts
[16:17:41.847]                           grepl <- base::grepl
[16:17:41.847]                           restarts <- computeRestarts(cond)
[16:17:41.847]                           for (restart in restarts) {
[16:17:41.847]                             name <- restart$name
[16:17:41.847]                             if (is.null(name)) 
[16:17:41.847]                               next
[16:17:41.847]                             if (!grepl(pattern, name)) 
[16:17:41.847]                               next
[16:17:41.847]                             invokeRestart(restart)
[16:17:41.847]                             muffled <- TRUE
[16:17:41.847]                             break
[16:17:41.847]                           }
[16:17:41.847]                         }
[16:17:41.847]                       }
[16:17:41.847]                       invisible(muffled)
[16:17:41.847]                     }
[16:17:41.847]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.847]                   }
[16:17:41.847]                 }
[16:17:41.847]             }
[16:17:41.847]         }))
[16:17:41.847]     }, error = function(ex) {
[16:17:41.847]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:41.847]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.847]                 ...future.rng), started = ...future.startTime, 
[16:17:41.847]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:41.847]             version = "1.8"), class = "FutureResult")
[16:17:41.847]     }, finally = {
[16:17:41.847]         if (!identical(...future.workdir, getwd())) 
[16:17:41.847]             setwd(...future.workdir)
[16:17:41.847]         {
[16:17:41.847]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:41.847]                 ...future.oldOptions$nwarnings <- NULL
[16:17:41.847]             }
[16:17:41.847]             base::options(...future.oldOptions)
[16:17:41.847]             if (.Platform$OS.type == "windows") {
[16:17:41.847]                 old_names <- names(...future.oldEnvVars)
[16:17:41.847]                 envs <- base::Sys.getenv()
[16:17:41.847]                 names <- names(envs)
[16:17:41.847]                 common <- intersect(names, old_names)
[16:17:41.847]                 added <- setdiff(names, old_names)
[16:17:41.847]                 removed <- setdiff(old_names, names)
[16:17:41.847]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:41.847]                   envs[common]]
[16:17:41.847]                 NAMES <- toupper(changed)
[16:17:41.847]                 args <- list()
[16:17:41.847]                 for (kk in seq_along(NAMES)) {
[16:17:41.847]                   name <- changed[[kk]]
[16:17:41.847]                   NAME <- NAMES[[kk]]
[16:17:41.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.847]                     next
[16:17:41.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.847]                 }
[16:17:41.847]                 NAMES <- toupper(added)
[16:17:41.847]                 for (kk in seq_along(NAMES)) {
[16:17:41.847]                   name <- added[[kk]]
[16:17:41.847]                   NAME <- NAMES[[kk]]
[16:17:41.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.847]                     next
[16:17:41.847]                   args[[name]] <- ""
[16:17:41.847]                 }
[16:17:41.847]                 NAMES <- toupper(removed)
[16:17:41.847]                 for (kk in seq_along(NAMES)) {
[16:17:41.847]                   name <- removed[[kk]]
[16:17:41.847]                   NAME <- NAMES[[kk]]
[16:17:41.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.847]                     next
[16:17:41.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.847]                 }
[16:17:41.847]                 if (length(args) > 0) 
[16:17:41.847]                   base::do.call(base::Sys.setenv, args = args)
[16:17:41.847]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:41.847]             }
[16:17:41.847]             else {
[16:17:41.847]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:41.847]             }
[16:17:41.847]             {
[16:17:41.847]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:41.847]                   0L) {
[16:17:41.847]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:41.847]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:41.847]                   base::options(opts)
[16:17:41.847]                 }
[16:17:41.847]                 {
[16:17:41.847]                   {
[16:17:41.847]                     NULL
[16:17:41.847]                     RNGkind("Mersenne-Twister")
[16:17:41.847]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:41.847]                       inherits = FALSE)
[16:17:41.847]                   }
[16:17:41.847]                   options(future.plan = NULL)
[16:17:41.847]                   if (is.na(NA_character_)) 
[16:17:41.847]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.847]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:41.847]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:41.847]                     .init = FALSE)
[16:17:41.847]                 }
[16:17:41.847]             }
[16:17:41.847]         }
[16:17:41.847]     })
[16:17:41.847]     if (TRUE) {
[16:17:41.847]         base::sink(type = "output", split = FALSE)
[16:17:41.847]         if (TRUE) {
[16:17:41.847]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:41.847]         }
[16:17:41.847]         else {
[16:17:41.847]             ...future.result["stdout"] <- base::list(NULL)
[16:17:41.847]         }
[16:17:41.847]         base::close(...future.stdout)
[16:17:41.847]         ...future.stdout <- NULL
[16:17:41.847]     }
[16:17:41.847]     ...future.result$conditions <- ...future.conditions
[16:17:41.847]     ...future.result$finished <- base::Sys.time()
[16:17:41.847]     ...future.result
[16:17:41.847] }
[16:17:41.848] assign_globals() ...
[16:17:41.848] List of 5
[16:17:41.848]  $ future.call.arguments    : list()
[16:17:41.848]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.848]  $ ...future.FUN            :function (x)  
[16:17:41.848]  $ ...future.elements_ii    :List of 2
[16:17:41.848]   ..$ : int [1:2] 1 3
[16:17:41.848]   ..$ : int [1:2] 2 4
[16:17:41.848]  $ ...future.seeds_ii       : NULL
[16:17:41.848]  $ ...future.globals.maxSize: num Inf
[16:17:41.848]  - attr(*, "resolved")= logi FALSE
[16:17:41.848]  - attr(*, "total_size")= num NA
[16:17:41.848]  - attr(*, "where")=List of 5
[16:17:41.848]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:41.848]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:41.848]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:41.848]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:41.848]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:41.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.848]  - attr(*, "already-done")= logi TRUE
[16:17:41.853] - copied ‘future.call.arguments’ to environment
[16:17:41.853] - reassign environment for ‘...future.FUN’
[16:17:41.853] - copied ‘...future.FUN’ to environment
[16:17:41.853] - copied ‘...future.elements_ii’ to environment
[16:17:41.853] - copied ‘...future.seeds_ii’ to environment
[16:17:41.854] - copied ‘...future.globals.maxSize’ to environment
[16:17:41.854] assign_globals() ... done
[16:17:41.854] plan(): Setting new future strategy stack:
[16:17:41.854] List of future strategies:
[16:17:41.854] 1. sequential:
[16:17:41.854]    - args: function (..., envir = parent.frame())
[16:17:41.854]    - tweaked: FALSE
[16:17:41.854]    - call: NULL
[16:17:41.854] plan(): nbrOfWorkers() = 1
[16:17:41.855] plan(): Setting new future strategy stack:
[16:17:41.855] List of future strategies:
[16:17:41.855] 1. sequential:
[16:17:41.855]    - args: function (..., envir = parent.frame())
[16:17:41.855]    - tweaked: FALSE
[16:17:41.855]    - call: plan(strategy)
[16:17:41.855] plan(): nbrOfWorkers() = 1
[16:17:41.856] SequentialFuture started (and completed)
[16:17:41.856] - Launch lazy future ... done
[16:17:41.856] run() for ‘SequentialFuture’ ... done
[16:17:41.856] Created future:
[16:17:41.856] SequentialFuture:
[16:17:41.856] Label: ‘future_apply-1’
[16:17:41.856] Expression:
[16:17:41.856] {
[16:17:41.856]     do.call(function(...) {
[16:17:41.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.856]             on.exit(options(oopts), add = TRUE)
[16:17:41.856]         }
[16:17:41.856]         {
[16:17:41.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.856]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.856]             })
[16:17:41.856]         }
[16:17:41.856]     }, args = future.call.arguments)
[16:17:41.856] }
[16:17:41.856] Lazy evaluation: FALSE
[16:17:41.856] Asynchronous evaluation: FALSE
[16:17:41.856] Local evaluation: TRUE
[16:17:41.856] Environment: R_GlobalEnv
[16:17:41.856] Capture standard output: TRUE
[16:17:41.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:41.856] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:41.856] Packages: <none>
[16:17:41.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:41.856] Resolved: TRUE
[16:17:41.856] Value: 400 bytes of class ‘list’
[16:17:41.856] Early signaling: FALSE
[16:17:41.856] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:41.856] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.857] Chunk #1 of 1 ... DONE
[16:17:41.857] Launching 1 futures (chunks) ... DONE
[16:17:41.857] Resolving 1 futures (chunks) ...
[16:17:41.857] resolve() on list ...
[16:17:41.857]  recursive: 0
[16:17:41.857]  length: 1
[16:17:41.857] 
[16:17:41.858] resolved() for ‘SequentialFuture’ ...
[16:17:41.858] - state: ‘finished’
[16:17:41.858] - run: TRUE
[16:17:41.858] - result: ‘FutureResult’
[16:17:41.858] resolved() for ‘SequentialFuture’ ... done
[16:17:41.858] Future #1
[16:17:41.858] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:41.858] - nx: 1
[16:17:41.858] - relay: TRUE
[16:17:41.858] - stdout: TRUE
[16:17:41.858] - signal: TRUE
[16:17:41.858] - resignal: FALSE
[16:17:41.859] - force: TRUE
[16:17:41.859] - relayed: [n=1] FALSE
[16:17:41.859] - queued futures: [n=1] FALSE
[16:17:41.859]  - until=1
[16:17:41.859]  - relaying element #1
[16:17:41.859] - relayed: [n=1] TRUE
[16:17:41.859] - queued futures: [n=1] TRUE
[16:17:41.859] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:41.859]  length: 0 (resolved future 1)
[16:17:41.859] Relaying remaining futures
[16:17:41.860] signalConditionsASAP(NULL, pos=0) ...
[16:17:41.860] - nx: 1
[16:17:41.860] - relay: TRUE
[16:17:41.860] - stdout: TRUE
[16:17:41.860] - signal: TRUE
[16:17:41.861] - resignal: FALSE
[16:17:41.861] - force: TRUE
[16:17:41.861] - relayed: [n=1] TRUE
[16:17:41.861] - queued futures: [n=1] TRUE
 - flush all
[16:17:41.861] - relayed: [n=1] TRUE
[16:17:41.861] - queued futures: [n=1] TRUE
[16:17:41.861] signalConditionsASAP(NULL, pos=0) ... done
[16:17:41.862] resolve() on list ... DONE
[16:17:41.862]  - Number of value chunks collected: 1
[16:17:41.862] Resolving 1 futures (chunks) ... DONE
[16:17:41.862] Reducing values from 1 chunks ...
[16:17:41.862]  - Number of values collected after concatenation: 2
[16:17:41.862]  - Number of values expected: 2
[16:17:41.862] Reducing values from 1 chunks ... DONE
[16:17:41.862] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:17:41.863] getGlobalsAndPackagesXApply() ...
[16:17:41.863]  - future.globals: TRUE
[16:17:41.863] getGlobalsAndPackages() ...
[16:17:41.863] Searching for globals...
[16:17:41.865] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:17:41.866] Searching for globals ... DONE
[16:17:41.866] Resolving globals: FALSE
[16:17:41.866] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:17:41.866] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:17:41.867] - globals: [1] ‘FUN’
[16:17:41.867] 
[16:17:41.867] getGlobalsAndPackages() ... DONE
[16:17:41.867]  - globals found/used: [n=1] ‘FUN’
[16:17:41.867]  - needed namespaces: [n=0] 
[16:17:41.867] Finding globals ... DONE
[16:17:41.867]  - use_args: TRUE
[16:17:41.867]  - Getting '...' globals ...
[16:17:41.868] resolve() on list ...
[16:17:41.868]  recursive: 0
[16:17:41.868]  length: 1
[16:17:41.868]  elements: ‘...’
[16:17:41.868]  length: 0 (resolved future 1)
[16:17:41.868] resolve() on list ... DONE
[16:17:41.868]    - '...' content: [n=0] 
[16:17:41.868] List of 1
[16:17:41.868]  $ ...: list()
[16:17:41.868]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.868]  - attr(*, "where")=List of 1
[16:17:41.868]   ..$ ...:<environment: 0x555be193f6a8> 
[16:17:41.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.868]  - attr(*, "resolved")= logi TRUE
[16:17:41.868]  - attr(*, "total_size")= num NA
[16:17:41.870]  - Getting '...' globals ... DONE
[16:17:41.871] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.871] List of 2
[16:17:41.871]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:17:41.871]  $ ...          : list()
[16:17:41.871]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.871]  - attr(*, "where")=List of 2
[16:17:41.871]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.871]   ..$ ...          :<environment: 0x555be193f6a8> 
[16:17:41.871]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.871]  - attr(*, "resolved")= logi FALSE
[16:17:41.871]  - attr(*, "total_size")= num 36296
[16:17:41.873] Packages to be attached in all futures: [n=0] 
[16:17:41.873] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.873] future_lapply() ...
[16:17:41.875] Generating random seeds ...
[16:17:41.875] Generating random seed streams for 2 elements ...
[16:17:41.876] Generating random seed streams for 2 elements ... DONE
[16:17:41.876] Generating random seeds ... DONE
[16:17:41.876] Will set RNG state on exit: 10407, 451644702, -1991366488, 1316158302, 988014573, 1680547178, 720603801
[16:17:41.876] Number of chunks: 1
[16:17:41.876] getGlobalsAndPackagesXApply() ...
[16:17:41.876]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.876]  - use_args: TRUE
[16:17:41.876] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.877] List of 2
[16:17:41.877]  $ ...          : list()
[16:17:41.877]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.877]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:17:41.877]  - attr(*, "where")=List of 2
[16:17:41.877]   ..$ ...          :<environment: 0x555be193f6a8> 
[16:17:41.877]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:41.877]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.877]  - attr(*, "resolved")= logi FALSE
[16:17:41.877]  - attr(*, "total_size")= num NA
[16:17:41.879] Packages to be attached in all futures: [n=0] 
[16:17:41.880] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.880] Number of futures (= number of chunks): 1
[16:17:41.880] Launching 1 futures (chunks) ...
[16:17:41.880] Chunk #1 of 1 ...
[16:17:41.880]  - seeds: [2] <seeds>
[16:17:41.880]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.881] getGlobalsAndPackages() ...
[16:17:41.881] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.881] Resolving globals: FALSE
[16:17:41.881] Tweak future expression to call with '...' arguments ...
[16:17:41.881] {
[16:17:41.881]     do.call(function(...) {
[16:17:41.881]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.881]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.881]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.881]             on.exit(options(oopts), add = TRUE)
[16:17:41.881]         }
[16:17:41.881]         {
[16:17:41.881]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.881]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.881]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:41.881]                   envir = globalenv(), inherits = FALSE)
[16:17:41.881]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.881]             })
[16:17:41.881]         }
[16:17:41.881]     }, args = future.call.arguments)
[16:17:41.881] }
[16:17:41.882] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.882] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.882] 
[16:17:41.882] getGlobalsAndPackages() ... DONE
[16:17:41.883] run() for ‘Future’ ...
[16:17:41.883] - state: ‘created’
[16:17:41.883] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:41.883] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.883] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:41.883]   - Field: ‘label’
[16:17:41.883]   - Field: ‘local’
[16:17:41.883]   - Field: ‘owner’
[16:17:41.884]   - Field: ‘envir’
[16:17:41.884]   - Field: ‘packages’
[16:17:41.884]   - Field: ‘gc’
[16:17:41.884]   - Field: ‘conditions’
[16:17:41.884]   - Field: ‘expr’
[16:17:41.884]   - Field: ‘uuid’
[16:17:41.884]   - Field: ‘seed’
[16:17:41.884]   - Field: ‘version’
[16:17:41.884]   - Field: ‘result’
[16:17:41.884]   - Field: ‘asynchronous’
[16:17:41.884]   - Field: ‘calls’
[16:17:41.885]   - Field: ‘globals’
[16:17:41.885]   - Field: ‘stdout’
[16:17:41.885]   - Field: ‘earlySignal’
[16:17:41.885]   - Field: ‘lazy’
[16:17:41.885]   - Field: ‘state’
[16:17:41.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:41.885] - Launch lazy future ...
[16:17:41.885] Packages needed by the future expression (n = 0): <none>
[16:17:41.885] Packages needed by future strategies (n = 0): <none>
[16:17:41.886] {
[16:17:41.886]     {
[16:17:41.886]         {
[16:17:41.886]             ...future.startTime <- base::Sys.time()
[16:17:41.886]             {
[16:17:41.886]                 {
[16:17:41.886]                   {
[16:17:41.886]                     base::local({
[16:17:41.886]                       has_future <- base::requireNamespace("future", 
[16:17:41.886]                         quietly = TRUE)
[16:17:41.886]                       if (has_future) {
[16:17:41.886]                         ns <- base::getNamespace("future")
[16:17:41.886]                         version <- ns[[".package"]][["version"]]
[16:17:41.886]                         if (is.null(version)) 
[16:17:41.886]                           version <- utils::packageVersion("future")
[16:17:41.886]                       }
[16:17:41.886]                       else {
[16:17:41.886]                         version <- NULL
[16:17:41.886]                       }
[16:17:41.886]                       if (!has_future || version < "1.8.0") {
[16:17:41.886]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:41.886]                           "", base::R.version$version.string), 
[16:17:41.886]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:41.886]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:41.886]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:41.886]                             "release", "version")], collapse = " "), 
[16:17:41.886]                           hostname = base::Sys.info()[["nodename"]])
[16:17:41.886]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:41.886]                           info)
[16:17:41.886]                         info <- base::paste(info, collapse = "; ")
[16:17:41.886]                         if (!has_future) {
[16:17:41.886]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:41.886]                             info)
[16:17:41.886]                         }
[16:17:41.886]                         else {
[16:17:41.886]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:41.886]                             info, version)
[16:17:41.886]                         }
[16:17:41.886]                         base::stop(msg)
[16:17:41.886]                       }
[16:17:41.886]                     })
[16:17:41.886]                   }
[16:17:41.886]                   ...future.strategy.old <- future::plan("list")
[16:17:41.886]                   options(future.plan = NULL)
[16:17:41.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:41.886]                 }
[16:17:41.886]                 ...future.workdir <- getwd()
[16:17:41.886]             }
[16:17:41.886]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:41.886]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:41.886]         }
[16:17:41.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:41.886]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:41.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:41.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:41.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:41.886]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:41.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:41.886]             base::names(...future.oldOptions))
[16:17:41.886]     }
[16:17:41.886]     if (FALSE) {
[16:17:41.886]     }
[16:17:41.886]     else {
[16:17:41.886]         if (TRUE) {
[16:17:41.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:41.886]                 open = "w")
[16:17:41.886]         }
[16:17:41.886]         else {
[16:17:41.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:41.886]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:41.886]         }
[16:17:41.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:41.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:41.886]             base::sink(type = "output", split = FALSE)
[16:17:41.886]             base::close(...future.stdout)
[16:17:41.886]         }, add = TRUE)
[16:17:41.886]     }
[16:17:41.886]     ...future.frame <- base::sys.nframe()
[16:17:41.886]     ...future.conditions <- base::list()
[16:17:41.886]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:41.886]     if (FALSE) {
[16:17:41.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:41.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:41.886]     }
[16:17:41.886]     ...future.result <- base::tryCatch({
[16:17:41.886]         base::withCallingHandlers({
[16:17:41.886]             ...future.value <- base::withVisible(base::local({
[16:17:41.886]                 do.call(function(...) {
[16:17:41.886]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.886]                   if (!identical(...future.globals.maxSize.org, 
[16:17:41.886]                     ...future.globals.maxSize)) {
[16:17:41.886]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.886]                     on.exit(options(oopts), add = TRUE)
[16:17:41.886]                   }
[16:17:41.886]                   {
[16:17:41.886]                     lapply(seq_along(...future.elements_ii), 
[16:17:41.886]                       FUN = function(jj) {
[16:17:41.886]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.886]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:41.886]                           envir = globalenv(), inherits = FALSE)
[16:17:41.886]                         ...future.FUN(...future.X_jj, ...)
[16:17:41.886]                       })
[16:17:41.886]                   }
[16:17:41.886]                 }, args = future.call.arguments)
[16:17:41.886]             }))
[16:17:41.886]             future::FutureResult(value = ...future.value$value, 
[16:17:41.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.886]                   ...future.rng), globalenv = if (FALSE) 
[16:17:41.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:41.886]                     ...future.globalenv.names))
[16:17:41.886]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:41.886]         }, condition = base::local({
[16:17:41.886]             c <- base::c
[16:17:41.886]             inherits <- base::inherits
[16:17:41.886]             invokeRestart <- base::invokeRestart
[16:17:41.886]             length <- base::length
[16:17:41.886]             list <- base::list
[16:17:41.886]             seq.int <- base::seq.int
[16:17:41.886]             signalCondition <- base::signalCondition
[16:17:41.886]             sys.calls <- base::sys.calls
[16:17:41.886]             `[[` <- base::`[[`
[16:17:41.886]             `+` <- base::`+`
[16:17:41.886]             `<<-` <- base::`<<-`
[16:17:41.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:41.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:41.886]                   3L)]
[16:17:41.886]             }
[16:17:41.886]             function(cond) {
[16:17:41.886]                 is_error <- inherits(cond, "error")
[16:17:41.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:41.886]                   NULL)
[16:17:41.886]                 if (is_error) {
[16:17:41.886]                   sessionInformation <- function() {
[16:17:41.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:41.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:41.886]                       search = base::search(), system = base::Sys.info())
[16:17:41.886]                   }
[16:17:41.886]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:41.886]                     cond$call), session = sessionInformation(), 
[16:17:41.886]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:41.886]                   signalCondition(cond)
[16:17:41.886]                 }
[16:17:41.886]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[16:17:41.886]                   signal <- TRUE && inherits(cond, character(0))
[16:17:41.886]                   ...future.conditions[[length(...future.conditions) + 
[16:17:41.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:41.886]                   if (TRUE && !signal) {
[16:17:41.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.886]                     {
[16:17:41.886]                       inherits <- base::inherits
[16:17:41.886]                       invokeRestart <- base::invokeRestart
[16:17:41.886]                       is.null <- base::is.null
[16:17:41.886]                       muffled <- FALSE
[16:17:41.886]                       if (inherits(cond, "message")) {
[16:17:41.886]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.886]                         if (muffled) 
[16:17:41.886]                           invokeRestart("muffleMessage")
[16:17:41.886]                       }
[16:17:41.886]                       else if (inherits(cond, "warning")) {
[16:17:41.886]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.886]                         if (muffled) 
[16:17:41.886]                           invokeRestart("muffleWarning")
[16:17:41.886]                       }
[16:17:41.886]                       else if (inherits(cond, "condition")) {
[16:17:41.886]                         if (!is.null(pattern)) {
[16:17:41.886]                           computeRestarts <- base::computeRestarts
[16:17:41.886]                           grepl <- base::grepl
[16:17:41.886]                           restarts <- computeRestarts(cond)
[16:17:41.886]                           for (restart in restarts) {
[16:17:41.886]                             name <- restart$name
[16:17:41.886]                             if (is.null(name)) 
[16:17:41.886]                               next
[16:17:41.886]                             if (!grepl(pattern, name)) 
[16:17:41.886]                               next
[16:17:41.886]                             invokeRestart(restart)
[16:17:41.886]                             muffled <- TRUE
[16:17:41.886]                             break
[16:17:41.886]                           }
[16:17:41.886]                         }
[16:17:41.886]                       }
[16:17:41.886]                       invisible(muffled)
[16:17:41.886]                     }
[16:17:41.886]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.886]                   }
[16:17:41.886]                 }
[16:17:41.886]                 else {
[16:17:41.886]                   if (FALSE) {
[16:17:41.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:41.886]                     {
[16:17:41.886]                       inherits <- base::inherits
[16:17:41.886]                       invokeRestart <- base::invokeRestart
[16:17:41.886]                       is.null <- base::is.null
[16:17:41.886]                       muffled <- FALSE
[16:17:41.886]                       if (inherits(cond, "message")) {
[16:17:41.886]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:41.886]                         if (muffled) 
[16:17:41.886]                           invokeRestart("muffleMessage")
[16:17:41.886]                       }
[16:17:41.886]                       else if (inherits(cond, "warning")) {
[16:17:41.886]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:41.886]                         if (muffled) 
[16:17:41.886]                           invokeRestart("muffleWarning")
[16:17:41.886]                       }
[16:17:41.886]                       else if (inherits(cond, "condition")) {
[16:17:41.886]                         if (!is.null(pattern)) {
[16:17:41.886]                           computeRestarts <- base::computeRestarts
[16:17:41.886]                           grepl <- base::grepl
[16:17:41.886]                           restarts <- computeRestarts(cond)
[16:17:41.886]                           for (restart in restarts) {
[16:17:41.886]                             name <- restart$name
[16:17:41.886]                             if (is.null(name)) 
[16:17:41.886]                               next
[16:17:41.886]                             if (!grepl(pattern, name)) 
[16:17:41.886]                               next
[16:17:41.886]                             invokeRestart(restart)
[16:17:41.886]                             muffled <- TRUE
[16:17:41.886]                             break
[16:17:41.886]                           }
[16:17:41.886]                         }
[16:17:41.886]                       }
[16:17:41.886]                       invisible(muffled)
[16:17:41.886]                     }
[16:17:41.886]                     muffleCondition(cond, pattern = "^muffle")
[16:17:41.886]                   }
[16:17:41.886]                 }
[16:17:41.886]             }
[16:17:41.886]         }))
[16:17:41.886]     }, error = function(ex) {
[16:17:41.886]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:41.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:41.886]                 ...future.rng), started = ...future.startTime, 
[16:17:41.886]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:41.886]             version = "1.8"), class = "FutureResult")
[16:17:41.886]     }, finally = {
[16:17:41.886]         if (!identical(...future.workdir, getwd())) 
[16:17:41.886]             setwd(...future.workdir)
[16:17:41.886]         {
[16:17:41.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:41.886]                 ...future.oldOptions$nwarnings <- NULL
[16:17:41.886]             }
[16:17:41.886]             base::options(...future.oldOptions)
[16:17:41.886]             if (.Platform$OS.type == "windows") {
[16:17:41.886]                 old_names <- names(...future.oldEnvVars)
[16:17:41.886]                 envs <- base::Sys.getenv()
[16:17:41.886]                 names <- names(envs)
[16:17:41.886]                 common <- intersect(names, old_names)
[16:17:41.886]                 added <- setdiff(names, old_names)
[16:17:41.886]                 removed <- setdiff(old_names, names)
[16:17:41.886]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:41.886]                   envs[common]]
[16:17:41.886]                 NAMES <- toupper(changed)
[16:17:41.886]                 args <- list()
[16:17:41.886]                 for (kk in seq_along(NAMES)) {
[16:17:41.886]                   name <- changed[[kk]]
[16:17:41.886]                   NAME <- NAMES[[kk]]
[16:17:41.886]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.886]                     next
[16:17:41.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.886]                 }
[16:17:41.886]                 NAMES <- toupper(added)
[16:17:41.886]                 for (kk in seq_along(NAMES)) {
[16:17:41.886]                   name <- added[[kk]]
[16:17:41.886]                   NAME <- NAMES[[kk]]
[16:17:41.886]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.886]                     next
[16:17:41.886]                   args[[name]] <- ""
[16:17:41.886]                 }
[16:17:41.886]                 NAMES <- toupper(removed)
[16:17:41.886]                 for (kk in seq_along(NAMES)) {
[16:17:41.886]                   name <- removed[[kk]]
[16:17:41.886]                   NAME <- NAMES[[kk]]
[16:17:41.886]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:41.886]                     next
[16:17:41.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:41.886]                 }
[16:17:41.886]                 if (length(args) > 0) 
[16:17:41.886]                   base::do.call(base::Sys.setenv, args = args)
[16:17:41.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:41.886]             }
[16:17:41.886]             else {
[16:17:41.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:41.886]             }
[16:17:41.886]             {
[16:17:41.886]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:41.886]                   0L) {
[16:17:41.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:41.886]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:41.886]                   base::options(opts)
[16:17:41.886]                 }
[16:17:41.886]                 {
[16:17:41.886]                   {
[16:17:41.886]                     base::assign(".Random.seed", c(10407L, 451644702L, 
[16:17:41.886]                     -1991366488L, 1316158302L, 988014573L, 1680547178L, 
[16:17:41.886]                     720603801L), envir = base::globalenv(), inherits = FALSE)
[16:17:41.886]                     NULL
[16:17:41.886]                   }
[16:17:41.886]                   options(future.plan = NULL)
[16:17:41.886]                   if (is.na(NA_character_)) 
[16:17:41.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:41.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:41.886]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:41.886]                     .init = FALSE)
[16:17:41.886]                 }
[16:17:41.886]             }
[16:17:41.886]         }
[16:17:41.886]     })
[16:17:41.886]     if (TRUE) {
[16:17:41.886]         base::sink(type = "output", split = FALSE)
[16:17:41.886]         if (TRUE) {
[16:17:41.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:41.886]         }
[16:17:41.886]         else {
[16:17:41.886]             ...future.result["stdout"] <- base::list(NULL)
[16:17:41.886]         }
[16:17:41.886]         base::close(...future.stdout)
[16:17:41.886]         ...future.stdout <- NULL
[16:17:41.886]     }
[16:17:41.886]     ...future.result$conditions <- ...future.conditions
[16:17:41.886]     ...future.result$finished <- base::Sys.time()
[16:17:41.886]     ...future.result
[16:17:41.886] }
[16:17:41.887] assign_globals() ...
[16:17:41.887] List of 5
[16:17:41.887]  $ future.call.arguments    : list()
[16:17:41.887]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.887]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:17:41.887]  $ ...future.elements_ii    :List of 2
[16:17:41.887]   ..$ : int [1:2] 1 3
[16:17:41.887]   ..$ : int [1:2] 2 4
[16:17:41.887]  $ ...future.seeds_ii       :List of 2
[16:17:41.887]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:17:41.887]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:17:41.887]  $ ...future.globals.maxSize: num Inf
[16:17:41.887]  - attr(*, "resolved")= logi FALSE
[16:17:41.887]  - attr(*, "total_size")= num NA
[16:17:41.887]  - attr(*, "where")=List of 5
[16:17:41.887]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:41.887]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:41.887]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:41.887]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:41.887]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:41.887]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.887]  - attr(*, "already-done")= logi TRUE
[16:17:41.893] - copied ‘future.call.arguments’ to environment
[16:17:41.893] - copied ‘...future.FUN’ to environment
[16:17:41.893] - copied ‘...future.elements_ii’ to environment
[16:17:41.893] - copied ‘...future.seeds_ii’ to environment
[16:17:41.893] - copied ‘...future.globals.maxSize’ to environment
[16:17:41.893] assign_globals() ... done
[16:17:41.894] plan(): Setting new future strategy stack:
[16:17:41.894] List of future strategies:
[16:17:41.894] 1. sequential:
[16:17:41.894]    - args: function (..., envir = parent.frame())
[16:17:41.894]    - tweaked: FALSE
[16:17:41.894]    - call: NULL
[16:17:41.894] plan(): nbrOfWorkers() = 1
[16:17:41.895] plan(): Setting new future strategy stack:
[16:17:41.895] List of future strategies:
[16:17:41.895] 1. sequential:
[16:17:41.895]    - args: function (..., envir = parent.frame())
[16:17:41.895]    - tweaked: FALSE
[16:17:41.895]    - call: plan(strategy)
[16:17:41.895] plan(): nbrOfWorkers() = 1
[16:17:41.895] SequentialFuture started (and completed)
[16:17:41.896] - Launch lazy future ... done
[16:17:41.896] run() for ‘SequentialFuture’ ... done
[16:17:41.896] Created future:
[16:17:41.896] SequentialFuture:
[16:17:41.896] Label: ‘future_apply-1’
[16:17:41.896] Expression:
[16:17:41.896] {
[16:17:41.896]     do.call(function(...) {
[16:17:41.896]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.896]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.896]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.896]             on.exit(options(oopts), add = TRUE)
[16:17:41.896]         }
[16:17:41.896]         {
[16:17:41.896]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.896]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.896]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:41.896]                   envir = globalenv(), inherits = FALSE)
[16:17:41.896]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.896]             })
[16:17:41.896]         }
[16:17:41.896]     }, args = future.call.arguments)
[16:17:41.896] }
[16:17:41.896] Lazy evaluation: FALSE
[16:17:41.896] Asynchronous evaluation: FALSE
[16:17:41.896] Local evaluation: TRUE
[16:17:41.896] Environment: R_GlobalEnv
[16:17:41.896] Capture standard output: TRUE
[16:17:41.896] Capture condition classes: <none>
[16:17:41.896] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:41.896] Packages: <none>
[16:17:41.896] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:17:41.896] Resolved: TRUE
[16:17:41.896] Value: 112 bytes of class ‘list’
[16:17:41.896] Early signaling: FALSE
[16:17:41.896] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:41.896] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:41.897] Chunk #1 of 1 ... DONE
[16:17:41.897] Launching 1 futures (chunks) ... DONE
[16:17:41.897] Resolving 1 futures (chunks) ...
[16:17:41.897] resolve() on list ...
[16:17:41.897]  recursive: 0
[16:17:41.897]  length: 1
[16:17:41.897] 
[16:17:41.898] resolved() for ‘SequentialFuture’ ...
[16:17:41.898] - state: ‘finished’
[16:17:41.898] - run: TRUE
[16:17:41.898] - result: ‘FutureResult’
[16:17:41.898] resolved() for ‘SequentialFuture’ ... done
[16:17:41.898] Future #1
[16:17:41.898] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:41.898] - nx: 1
[16:17:41.898] - relay: TRUE
[16:17:41.898] - stdout: TRUE
[16:17:41.898] - signal: TRUE
[16:17:41.899] - resignal: FALSE
[16:17:41.899] - force: TRUE
[16:17:41.899] - relayed: [n=1] FALSE
[16:17:41.899] - queued futures: [n=1] FALSE
[16:17:41.899]  - until=1
[16:17:41.899]  - relaying element #1
[16:17:41.899] - relayed: [n=1] TRUE
[16:17:41.899] - queued futures: [n=1] TRUE
[16:17:41.899] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:41.899]  length: 0 (resolved future 1)
[16:17:41.900] Relaying remaining futures
[16:17:41.900] signalConditionsASAP(NULL, pos=0) ...
[16:17:41.900] - nx: 1
[16:17:41.900] - relay: TRUE
[16:17:41.900] - stdout: TRUE
[16:17:41.900] - signal: TRUE
[16:17:41.900] - resignal: FALSE
[16:17:41.900] - force: TRUE
[16:17:41.900] - relayed: [n=1] TRUE
[16:17:41.900] - queued futures: [n=1] TRUE
 - flush all
[16:17:41.900] - relayed: [n=1] TRUE
[16:17:41.901] - queued futures: [n=1] TRUE
[16:17:41.901] signalConditionsASAP(NULL, pos=0) ... done
[16:17:41.901] resolve() on list ... DONE
[16:17:41.901]  - Number of value chunks collected: 1
[16:17:41.901] Resolving 1 futures (chunks) ... DONE
[16:17:41.901] Reducing values from 1 chunks ...
[16:17:41.901]  - Number of values collected after concatenation: 2
[16:17:41.901]  - Number of values expected: 2
[16:17:41.901] Reducing values from 1 chunks ... DONE
[16:17:41.901] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:17:41.902] plan(): Setting new future strategy stack:
[16:17:41.902] List of future strategies:
[16:17:41.902] 1. sequential:
[16:17:41.902]    - args: function (..., envir = parent.frame())
[16:17:41.902]    - tweaked: FALSE
[16:17:41.902]    - call: plan(sequential)
[16:17:41.902] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:17:41.902] plan(): Setting new future strategy stack:
[16:17:41.903] List of future strategies:
[16:17:41.903] 1. multicore:
[16:17:41.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:41.903]    - tweaked: FALSE
[16:17:41.903]    - call: plan(strategy)
[16:17:41.908] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[16:17:41.908] getGlobalsAndPackagesXApply() ...
[16:17:41.908]  - future.globals: TRUE
[16:17:41.909] getGlobalsAndPackages() ...
[16:17:41.909] Searching for globals...
[16:17:41.940] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:17:41.941] Searching for globals ... DONE
[16:17:41.941] Resolving globals: FALSE
[16:17:41.942] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:17:41.943] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:17:41.943] - globals: [1] ‘FUN’
[16:17:41.943] 
[16:17:41.943] getGlobalsAndPackages() ... DONE
[16:17:41.943]  - globals found/used: [n=1] ‘FUN’
[16:17:41.943]  - needed namespaces: [n=0] 
[16:17:41.943] Finding globals ... DONE
[16:17:41.943]  - use_args: TRUE
[16:17:41.943]  - Getting '...' globals ...
[16:17:41.944] resolve() on list ...
[16:17:41.944]  recursive: 0
[16:17:41.944]  length: 1
[16:17:41.944]  elements: ‘...’
[16:17:41.944]  length: 0 (resolved future 1)
[16:17:41.944] resolve() on list ... DONE
[16:17:41.944]    - '...' content: [n=0] 
[16:17:41.944] List of 1
[16:17:41.944]  $ ...: list()
[16:17:41.944]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.944]  - attr(*, "where")=List of 1
[16:17:41.944]   ..$ ...:<environment: 0x555be29e4e68> 
[16:17:41.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.944]  - attr(*, "resolved")= logi TRUE
[16:17:41.944]  - attr(*, "total_size")= num NA
[16:17:41.947]  - Getting '...' globals ... DONE
[16:17:41.947] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:41.947] List of 2
[16:17:41.947]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:41.947]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:41.947]  $ ...          : list()
[16:17:41.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.947]  - attr(*, "where")=List of 2
[16:17:41.947]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:41.947]   ..$ ...          :<environment: 0x555be29e4e68> 
[16:17:41.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.947]  - attr(*, "resolved")= logi FALSE
[16:17:41.947]  - attr(*, "total_size")= num 354224
[16:17:41.949] Packages to be attached in all futures: [n=0] 
[16:17:41.950] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.953] future_lapply() ...
[16:17:41.988] Number of chunks: 2
[16:17:41.988] getGlobalsAndPackagesXApply() ...
[16:17:41.988]  - future.globals: <name-value list> with names ‘list()’
[16:17:41.989]  - use_args: TRUE
[16:17:41.989] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:41.989] List of 2
[16:17:41.989]  $ ...          : list()
[16:17:41.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:41.989]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:41.989]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:41.989]  - attr(*, "where")=List of 2
[16:17:41.989]   ..$ ...          :<environment: 0x555be29e4e68> 
[16:17:41.989]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:41.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:41.989]  - attr(*, "resolved")= logi FALSE
[16:17:41.989]  - attr(*, "total_size")= num NA
[16:17:41.992] Packages to be attached in all futures: [n=0] 
[16:17:41.992] getGlobalsAndPackagesXApply() ... DONE
[16:17:41.992] Number of futures (= number of chunks): 2
[16:17:41.992] Launching 2 futures (chunks) ...
[16:17:41.993] Chunk #1 of 2 ...
[16:17:41.993]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:41.993]  - seeds: <none>
[16:17:41.993]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.993] getGlobalsAndPackages() ...
[16:17:41.993] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.993] Resolving globals: FALSE
[16:17:41.993] Tweak future expression to call with '...' arguments ...
[16:17:41.993] {
[16:17:41.993]     do.call(function(...) {
[16:17:41.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:41.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:41.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:41.993]             on.exit(options(oopts), add = TRUE)
[16:17:41.993]         }
[16:17:41.993]         {
[16:17:41.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:41.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:41.993]                 ...future.FUN(...future.X_jj, ...)
[16:17:41.993]             })
[16:17:41.993]         }
[16:17:41.993]     }, args = future.call.arguments)
[16:17:41.993] }
[16:17:41.994] Tweak future expression to call with '...' arguments ... DONE
[16:17:41.994] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:41.994] 
[16:17:41.994] getGlobalsAndPackages() ... DONE
[16:17:41.995] run() for ‘Future’ ...
[16:17:41.995] - state: ‘created’
[16:17:41.995] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:41.998] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:41.998] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:41.998]   - Field: ‘label’
[16:17:41.999]   - Field: ‘local’
[16:17:41.999]   - Field: ‘owner’
[16:17:41.999]   - Field: ‘envir’
[16:17:41.999]   - Field: ‘workers’
[16:17:41.999]   - Field: ‘packages’
[16:17:41.999]   - Field: ‘gc’
[16:17:41.999]   - Field: ‘job’
[16:17:41.999]   - Field: ‘conditions’
[16:17:41.999]   - Field: ‘expr’
[16:17:41.999]   - Field: ‘uuid’
[16:17:41.999]   - Field: ‘seed’
[16:17:42.000]   - Field: ‘version’
[16:17:42.000]   - Field: ‘result’
[16:17:42.000]   - Field: ‘asynchronous’
[16:17:42.000]   - Field: ‘calls’
[16:17:42.000]   - Field: ‘globals’
[16:17:42.000]   - Field: ‘stdout’
[16:17:42.000]   - Field: ‘earlySignal’
[16:17:42.000]   - Field: ‘lazy’
[16:17:42.000]   - Field: ‘state’
[16:17:42.000] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.001] - Launch lazy future ...
[16:17:42.002] Packages needed by the future expression (n = 0): <none>
[16:17:42.002] Packages needed by future strategies (n = 0): <none>
[16:17:42.002] {
[16:17:42.002]     {
[16:17:42.002]         {
[16:17:42.002]             ...future.startTime <- base::Sys.time()
[16:17:42.002]             {
[16:17:42.002]                 {
[16:17:42.002]                   {
[16:17:42.002]                     {
[16:17:42.002]                       base::local({
[16:17:42.002]                         has_future <- base::requireNamespace("future", 
[16:17:42.002]                           quietly = TRUE)
[16:17:42.002]                         if (has_future) {
[16:17:42.002]                           ns <- base::getNamespace("future")
[16:17:42.002]                           version <- ns[[".package"]][["version"]]
[16:17:42.002]                           if (is.null(version)) 
[16:17:42.002]                             version <- utils::packageVersion("future")
[16:17:42.002]                         }
[16:17:42.002]                         else {
[16:17:42.002]                           version <- NULL
[16:17:42.002]                         }
[16:17:42.002]                         if (!has_future || version < "1.8.0") {
[16:17:42.002]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.002]                             "", base::R.version$version.string), 
[16:17:42.002]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.002]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.002]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.002]                               "release", "version")], collapse = " "), 
[16:17:42.002]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.002]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.002]                             info)
[16:17:42.002]                           info <- base::paste(info, collapse = "; ")
[16:17:42.002]                           if (!has_future) {
[16:17:42.002]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.002]                               info)
[16:17:42.002]                           }
[16:17:42.002]                           else {
[16:17:42.002]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.002]                               info, version)
[16:17:42.002]                           }
[16:17:42.002]                           base::stop(msg)
[16:17:42.002]                         }
[16:17:42.002]                       })
[16:17:42.002]                     }
[16:17:42.002]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.002]                     base::options(mc.cores = 1L)
[16:17:42.002]                   }
[16:17:42.002]                   ...future.strategy.old <- future::plan("list")
[16:17:42.002]                   options(future.plan = NULL)
[16:17:42.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.002]                 }
[16:17:42.002]                 ...future.workdir <- getwd()
[16:17:42.002]             }
[16:17:42.002]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.002]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.002]         }
[16:17:42.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.002]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.002]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.002]             base::names(...future.oldOptions))
[16:17:42.002]     }
[16:17:42.002]     if (FALSE) {
[16:17:42.002]     }
[16:17:42.002]     else {
[16:17:42.002]         if (TRUE) {
[16:17:42.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.002]                 open = "w")
[16:17:42.002]         }
[16:17:42.002]         else {
[16:17:42.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.002]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.002]         }
[16:17:42.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.002]             base::sink(type = "output", split = FALSE)
[16:17:42.002]             base::close(...future.stdout)
[16:17:42.002]         }, add = TRUE)
[16:17:42.002]     }
[16:17:42.002]     ...future.frame <- base::sys.nframe()
[16:17:42.002]     ...future.conditions <- base::list()
[16:17:42.002]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.002]     if (FALSE) {
[16:17:42.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.002]     }
[16:17:42.002]     ...future.result <- base::tryCatch({
[16:17:42.002]         base::withCallingHandlers({
[16:17:42.002]             ...future.value <- base::withVisible(base::local({
[16:17:42.002]                 withCallingHandlers({
[16:17:42.002]                   {
[16:17:42.002]                     do.call(function(...) {
[16:17:42.002]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.002]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.002]                         ...future.globals.maxSize)) {
[16:17:42.002]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.002]                         on.exit(options(oopts), add = TRUE)
[16:17:42.002]                       }
[16:17:42.002]                       {
[16:17:42.002]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.002]                           FUN = function(jj) {
[16:17:42.002]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.002]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.002]                           })
[16:17:42.002]                       }
[16:17:42.002]                     }, args = future.call.arguments)
[16:17:42.002]                   }
[16:17:42.002]                 }, immediateCondition = function(cond) {
[16:17:42.002]                   save_rds <- function (object, pathname, ...) 
[16:17:42.002]                   {
[16:17:42.002]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.002]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.002]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.002]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.002]                         fi_tmp[["mtime"]])
[16:17:42.002]                     }
[16:17:42.002]                     tryCatch({
[16:17:42.002]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.002]                     }, error = function(ex) {
[16:17:42.002]                       msg <- conditionMessage(ex)
[16:17:42.002]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.002]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.002]                         fi_tmp[["mtime"]], msg)
[16:17:42.002]                       ex$message <- msg
[16:17:42.002]                       stop(ex)
[16:17:42.002]                     })
[16:17:42.002]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.002]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.002]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.002]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.002]                       fi <- file.info(pathname)
[16:17:42.002]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.002]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.002]                         fi[["size"]], fi[["mtime"]])
[16:17:42.002]                       stop(msg)
[16:17:42.002]                     }
[16:17:42.002]                     invisible(pathname)
[16:17:42.002]                   }
[16:17:42.002]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.002]                     rootPath = tempdir()) 
[16:17:42.002]                   {
[16:17:42.002]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.002]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.002]                       tmpdir = path, fileext = ".rds")
[16:17:42.002]                     save_rds(obj, file)
[16:17:42.002]                   }
[16:17:42.002]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.002]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.002]                   {
[16:17:42.002]                     inherits <- base::inherits
[16:17:42.002]                     invokeRestart <- base::invokeRestart
[16:17:42.002]                     is.null <- base::is.null
[16:17:42.002]                     muffled <- FALSE
[16:17:42.002]                     if (inherits(cond, "message")) {
[16:17:42.002]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.002]                       if (muffled) 
[16:17:42.002]                         invokeRestart("muffleMessage")
[16:17:42.002]                     }
[16:17:42.002]                     else if (inherits(cond, "warning")) {
[16:17:42.002]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.002]                       if (muffled) 
[16:17:42.002]                         invokeRestart("muffleWarning")
[16:17:42.002]                     }
[16:17:42.002]                     else if (inherits(cond, "condition")) {
[16:17:42.002]                       if (!is.null(pattern)) {
[16:17:42.002]                         computeRestarts <- base::computeRestarts
[16:17:42.002]                         grepl <- base::grepl
[16:17:42.002]                         restarts <- computeRestarts(cond)
[16:17:42.002]                         for (restart in restarts) {
[16:17:42.002]                           name <- restart$name
[16:17:42.002]                           if (is.null(name)) 
[16:17:42.002]                             next
[16:17:42.002]                           if (!grepl(pattern, name)) 
[16:17:42.002]                             next
[16:17:42.002]                           invokeRestart(restart)
[16:17:42.002]                           muffled <- TRUE
[16:17:42.002]                           break
[16:17:42.002]                         }
[16:17:42.002]                       }
[16:17:42.002]                     }
[16:17:42.002]                     invisible(muffled)
[16:17:42.002]                   }
[16:17:42.002]                   muffleCondition(cond)
[16:17:42.002]                 })
[16:17:42.002]             }))
[16:17:42.002]             future::FutureResult(value = ...future.value$value, 
[16:17:42.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.002]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.002]                     ...future.globalenv.names))
[16:17:42.002]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.002]         }, condition = base::local({
[16:17:42.002]             c <- base::c
[16:17:42.002]             inherits <- base::inherits
[16:17:42.002]             invokeRestart <- base::invokeRestart
[16:17:42.002]             length <- base::length
[16:17:42.002]             list <- base::list
[16:17:42.002]             seq.int <- base::seq.int
[16:17:42.002]             signalCondition <- base::signalCondition
[16:17:42.002]             sys.calls <- base::sys.calls
[16:17:42.002]             `[[` <- base::`[[`
[16:17:42.002]             `+` <- base::`+`
[16:17:42.002]             `<<-` <- base::`<<-`
[16:17:42.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.002]                   3L)]
[16:17:42.002]             }
[16:17:42.002]             function(cond) {
[16:17:42.002]                 is_error <- inherits(cond, "error")
[16:17:42.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.002]                   NULL)
[16:17:42.002]                 if (is_error) {
[16:17:42.002]                   sessionInformation <- function() {
[16:17:42.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.002]                       search = base::search(), system = base::Sys.info())
[16:17:42.002]                   }
[16:17:42.002]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.002]                     cond$call), session = sessionInformation(), 
[16:17:42.002]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.002]                   signalCondition(cond)
[16:17:42.002]                 }
[16:17:42.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.002]                 "immediateCondition"))) {
[16:17:42.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.002]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.002]                   if (TRUE && !signal) {
[16:17:42.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.002]                     {
[16:17:42.002]                       inherits <- base::inherits
[16:17:42.002]                       invokeRestart <- base::invokeRestart
[16:17:42.002]                       is.null <- base::is.null
[16:17:42.002]                       muffled <- FALSE
[16:17:42.002]                       if (inherits(cond, "message")) {
[16:17:42.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.002]                         if (muffled) 
[16:17:42.002]                           invokeRestart("muffleMessage")
[16:17:42.002]                       }
[16:17:42.002]                       else if (inherits(cond, "warning")) {
[16:17:42.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.002]                         if (muffled) 
[16:17:42.002]                           invokeRestart("muffleWarning")
[16:17:42.002]                       }
[16:17:42.002]                       else if (inherits(cond, "condition")) {
[16:17:42.002]                         if (!is.null(pattern)) {
[16:17:42.002]                           computeRestarts <- base::computeRestarts
[16:17:42.002]                           grepl <- base::grepl
[16:17:42.002]                           restarts <- computeRestarts(cond)
[16:17:42.002]                           for (restart in restarts) {
[16:17:42.002]                             name <- restart$name
[16:17:42.002]                             if (is.null(name)) 
[16:17:42.002]                               next
[16:17:42.002]                             if (!grepl(pattern, name)) 
[16:17:42.002]                               next
[16:17:42.002]                             invokeRestart(restart)
[16:17:42.002]                             muffled <- TRUE
[16:17:42.002]                             break
[16:17:42.002]                           }
[16:17:42.002]                         }
[16:17:42.002]                       }
[16:17:42.002]                       invisible(muffled)
[16:17:42.002]                     }
[16:17:42.002]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.002]                   }
[16:17:42.002]                 }
[16:17:42.002]                 else {
[16:17:42.002]                   if (TRUE) {
[16:17:42.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.002]                     {
[16:17:42.002]                       inherits <- base::inherits
[16:17:42.002]                       invokeRestart <- base::invokeRestart
[16:17:42.002]                       is.null <- base::is.null
[16:17:42.002]                       muffled <- FALSE
[16:17:42.002]                       if (inherits(cond, "message")) {
[16:17:42.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.002]                         if (muffled) 
[16:17:42.002]                           invokeRestart("muffleMessage")
[16:17:42.002]                       }
[16:17:42.002]                       else if (inherits(cond, "warning")) {
[16:17:42.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.002]                         if (muffled) 
[16:17:42.002]                           invokeRestart("muffleWarning")
[16:17:42.002]                       }
[16:17:42.002]                       else if (inherits(cond, "condition")) {
[16:17:42.002]                         if (!is.null(pattern)) {
[16:17:42.002]                           computeRestarts <- base::computeRestarts
[16:17:42.002]                           grepl <- base::grepl
[16:17:42.002]                           restarts <- computeRestarts(cond)
[16:17:42.002]                           for (restart in restarts) {
[16:17:42.002]                             name <- restart$name
[16:17:42.002]                             if (is.null(name)) 
[16:17:42.002]                               next
[16:17:42.002]                             if (!grepl(pattern, name)) 
[16:17:42.002]                               next
[16:17:42.002]                             invokeRestart(restart)
[16:17:42.002]                             muffled <- TRUE
[16:17:42.002]                             break
[16:17:42.002]                           }
[16:17:42.002]                         }
[16:17:42.002]                       }
[16:17:42.002]                       invisible(muffled)
[16:17:42.002]                     }
[16:17:42.002]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.002]                   }
[16:17:42.002]                 }
[16:17:42.002]             }
[16:17:42.002]         }))
[16:17:42.002]     }, error = function(ex) {
[16:17:42.002]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.002]                 ...future.rng), started = ...future.startTime, 
[16:17:42.002]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.002]             version = "1.8"), class = "FutureResult")
[16:17:42.002]     }, finally = {
[16:17:42.002]         if (!identical(...future.workdir, getwd())) 
[16:17:42.002]             setwd(...future.workdir)
[16:17:42.002]         {
[16:17:42.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.002]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.002]             }
[16:17:42.002]             base::options(...future.oldOptions)
[16:17:42.002]             if (.Platform$OS.type == "windows") {
[16:17:42.002]                 old_names <- names(...future.oldEnvVars)
[16:17:42.002]                 envs <- base::Sys.getenv()
[16:17:42.002]                 names <- names(envs)
[16:17:42.002]                 common <- intersect(names, old_names)
[16:17:42.002]                 added <- setdiff(names, old_names)
[16:17:42.002]                 removed <- setdiff(old_names, names)
[16:17:42.002]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.002]                   envs[common]]
[16:17:42.002]                 NAMES <- toupper(changed)
[16:17:42.002]                 args <- list()
[16:17:42.002]                 for (kk in seq_along(NAMES)) {
[16:17:42.002]                   name <- changed[[kk]]
[16:17:42.002]                   NAME <- NAMES[[kk]]
[16:17:42.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.002]                     next
[16:17:42.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.002]                 }
[16:17:42.002]                 NAMES <- toupper(added)
[16:17:42.002]                 for (kk in seq_along(NAMES)) {
[16:17:42.002]                   name <- added[[kk]]
[16:17:42.002]                   NAME <- NAMES[[kk]]
[16:17:42.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.002]                     next
[16:17:42.002]                   args[[name]] <- ""
[16:17:42.002]                 }
[16:17:42.002]                 NAMES <- toupper(removed)
[16:17:42.002]                 for (kk in seq_along(NAMES)) {
[16:17:42.002]                   name <- removed[[kk]]
[16:17:42.002]                   NAME <- NAMES[[kk]]
[16:17:42.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.002]                     next
[16:17:42.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.002]                 }
[16:17:42.002]                 if (length(args) > 0) 
[16:17:42.002]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.002]             }
[16:17:42.002]             else {
[16:17:42.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.002]             }
[16:17:42.002]             {
[16:17:42.002]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.002]                   0L) {
[16:17:42.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.002]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.002]                   base::options(opts)
[16:17:42.002]                 }
[16:17:42.002]                 {
[16:17:42.002]                   {
[16:17:42.002]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.002]                     NULL
[16:17:42.002]                   }
[16:17:42.002]                   options(future.plan = NULL)
[16:17:42.002]                   if (is.na(NA_character_)) 
[16:17:42.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.002]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.002]                     .init = FALSE)
[16:17:42.002]                 }
[16:17:42.002]             }
[16:17:42.002]         }
[16:17:42.002]     })
[16:17:42.002]     if (TRUE) {
[16:17:42.002]         base::sink(type = "output", split = FALSE)
[16:17:42.002]         if (TRUE) {
[16:17:42.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.002]         }
[16:17:42.002]         else {
[16:17:42.002]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.002]         }
[16:17:42.002]         base::close(...future.stdout)
[16:17:42.002]         ...future.stdout <- NULL
[16:17:42.002]     }
[16:17:42.002]     ...future.result$conditions <- ...future.conditions
[16:17:42.002]     ...future.result$finished <- base::Sys.time()
[16:17:42.002]     ...future.result
[16:17:42.002] }
[16:17:42.004] assign_globals() ...
[16:17:42.005] List of 5
[16:17:42.005]  $ future.call.arguments    : list()
[16:17:42.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.005]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:42.005]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:42.005]  $ ...future.elements_ii    :List of 1
[16:17:42.005]   ..$ : num [1:4] 1 3 1 7
[16:17:42.005]  $ ...future.seeds_ii       : NULL
[16:17:42.005]  $ ...future.globals.maxSize: num Inf
[16:17:42.005]  - attr(*, "resolved")= logi FALSE
[16:17:42.005]  - attr(*, "total_size")= num NA
[16:17:42.005]  - attr(*, "where")=List of 5
[16:17:42.005]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.005]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.005]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.005]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.005]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.005]  - attr(*, "already-done")= logi TRUE
[16:17:42.010] - copied ‘future.call.arguments’ to environment
[16:17:42.010] - copied ‘...future.FUN’ to environment
[16:17:42.011] - copied ‘...future.elements_ii’ to environment
[16:17:42.011] - copied ‘...future.seeds_ii’ to environment
[16:17:42.011] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.011] assign_globals() ... done
[16:17:42.011] requestCore(): workers = 2
[16:17:42.014] MulticoreFuture started
[16:17:42.015] - Launch lazy future ... done
[16:17:42.015] plan(): Setting new future strategy stack:
[16:17:42.015] run() for ‘MulticoreFuture’ ... done
[16:17:42.016] Created future:
[16:17:42.015] List of future strategies:
[16:17:42.015] 1. sequential:
[16:17:42.015]    - args: function (..., envir = parent.frame())
[16:17:42.015]    - tweaked: FALSE
[16:17:42.015]    - call: NULL
[16:17:42.016] plan(): nbrOfWorkers() = 1
[16:17:42.019] plan(): Setting new future strategy stack:
[16:17:42.019] List of future strategies:
[16:17:42.019] 1. multicore:
[16:17:42.019]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.019]    - tweaked: FALSE
[16:17:42.019]    - call: plan(strategy)
[16:17:42.024] plan(): nbrOfWorkers() = 2
[16:17:42.016] MulticoreFuture:
[16:17:42.016] Label: ‘future_apply-1’
[16:17:42.016] Expression:
[16:17:42.016] {
[16:17:42.016]     do.call(function(...) {
[16:17:42.016]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.016]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.016]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.016]             on.exit(options(oopts), add = TRUE)
[16:17:42.016]         }
[16:17:42.016]         {
[16:17:42.016]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.016]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.016]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.016]             })
[16:17:42.016]         }
[16:17:42.016]     }, args = future.call.arguments)
[16:17:42.016] }
[16:17:42.016] Lazy evaluation: FALSE
[16:17:42.016] Asynchronous evaluation: TRUE
[16:17:42.016] Local evaluation: TRUE
[16:17:42.016] Environment: R_GlobalEnv
[16:17:42.016] Capture standard output: TRUE
[16:17:42.016] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.016] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.016] Packages: <none>
[16:17:42.016] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.016] Resolved: TRUE
[16:17:42.016] Value: <not collected>
[16:17:42.016] Conditions captured: <none>
[16:17:42.016] Early signaling: FALSE
[16:17:42.016] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.016] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.025] Chunk #1 of 2 ... DONE
[16:17:42.025] Chunk #2 of 2 ...
[16:17:42.026]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.026]  - seeds: <none>
[16:17:42.026]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.026] getGlobalsAndPackages() ...
[16:17:42.026] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.027] Resolving globals: FALSE
[16:17:42.027] Tweak future expression to call with '...' arguments ...
[16:17:42.027] {
[16:17:42.027]     do.call(function(...) {
[16:17:42.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.027]             on.exit(options(oopts), add = TRUE)
[16:17:42.027]         }
[16:17:42.027]         {
[16:17:42.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.027]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.027]             })
[16:17:42.027]         }
[16:17:42.027]     }, args = future.call.arguments)
[16:17:42.027] }
[16:17:42.027] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.028] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.029] 
[16:17:42.029] getGlobalsAndPackages() ... DONE
[16:17:42.030] run() for ‘Future’ ...
[16:17:42.030] - state: ‘created’
[16:17:42.030] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.035] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.035] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.035]   - Field: ‘label’
[16:17:42.035]   - Field: ‘local’
[16:17:42.035]   - Field: ‘owner’
[16:17:42.036]   - Field: ‘envir’
[16:17:42.036]   - Field: ‘workers’
[16:17:42.036]   - Field: ‘packages’
[16:17:42.036]   - Field: ‘gc’
[16:17:42.036]   - Field: ‘job’
[16:17:42.036]   - Field: ‘conditions’
[16:17:42.036]   - Field: ‘expr’
[16:17:42.037]   - Field: ‘uuid’
[16:17:42.037]   - Field: ‘seed’
[16:17:42.037]   - Field: ‘version’
[16:17:42.037]   - Field: ‘result’
[16:17:42.037]   - Field: ‘asynchronous’
[16:17:42.037]   - Field: ‘calls’
[16:17:42.038]   - Field: ‘globals’
[16:17:42.038]   - Field: ‘stdout’
[16:17:42.038]   - Field: ‘earlySignal’
[16:17:42.038]   - Field: ‘lazy’
[16:17:42.038]   - Field: ‘state’
[16:17:42.038] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.039] - Launch lazy future ...
[16:17:42.039] Packages needed by the future expression (n = 0): <none>
[16:17:42.039] Packages needed by future strategies (n = 0): <none>
[16:17:42.040] {
[16:17:42.040]     {
[16:17:42.040]         {
[16:17:42.040]             ...future.startTime <- base::Sys.time()
[16:17:42.040]             {
[16:17:42.040]                 {
[16:17:42.040]                   {
[16:17:42.040]                     {
[16:17:42.040]                       base::local({
[16:17:42.040]                         has_future <- base::requireNamespace("future", 
[16:17:42.040]                           quietly = TRUE)
[16:17:42.040]                         if (has_future) {
[16:17:42.040]                           ns <- base::getNamespace("future")
[16:17:42.040]                           version <- ns[[".package"]][["version"]]
[16:17:42.040]                           if (is.null(version)) 
[16:17:42.040]                             version <- utils::packageVersion("future")
[16:17:42.040]                         }
[16:17:42.040]                         else {
[16:17:42.040]                           version <- NULL
[16:17:42.040]                         }
[16:17:42.040]                         if (!has_future || version < "1.8.0") {
[16:17:42.040]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.040]                             "", base::R.version$version.string), 
[16:17:42.040]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.040]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.040]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.040]                               "release", "version")], collapse = " "), 
[16:17:42.040]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.040]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.040]                             info)
[16:17:42.040]                           info <- base::paste(info, collapse = "; ")
[16:17:42.040]                           if (!has_future) {
[16:17:42.040]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.040]                               info)
[16:17:42.040]                           }
[16:17:42.040]                           else {
[16:17:42.040]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.040]                               info, version)
[16:17:42.040]                           }
[16:17:42.040]                           base::stop(msg)
[16:17:42.040]                         }
[16:17:42.040]                       })
[16:17:42.040]                     }
[16:17:42.040]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.040]                     base::options(mc.cores = 1L)
[16:17:42.040]                   }
[16:17:42.040]                   ...future.strategy.old <- future::plan("list")
[16:17:42.040]                   options(future.plan = NULL)
[16:17:42.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.040]                 }
[16:17:42.040]                 ...future.workdir <- getwd()
[16:17:42.040]             }
[16:17:42.040]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.040]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.040]         }
[16:17:42.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.040]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.040]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.040]             base::names(...future.oldOptions))
[16:17:42.040]     }
[16:17:42.040]     if (FALSE) {
[16:17:42.040]     }
[16:17:42.040]     else {
[16:17:42.040]         if (TRUE) {
[16:17:42.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.040]                 open = "w")
[16:17:42.040]         }
[16:17:42.040]         else {
[16:17:42.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.040]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.040]         }
[16:17:42.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.040]             base::sink(type = "output", split = FALSE)
[16:17:42.040]             base::close(...future.stdout)
[16:17:42.040]         }, add = TRUE)
[16:17:42.040]     }
[16:17:42.040]     ...future.frame <- base::sys.nframe()
[16:17:42.040]     ...future.conditions <- base::list()
[16:17:42.040]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.040]     if (FALSE) {
[16:17:42.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.040]     }
[16:17:42.040]     ...future.result <- base::tryCatch({
[16:17:42.040]         base::withCallingHandlers({
[16:17:42.040]             ...future.value <- base::withVisible(base::local({
[16:17:42.040]                 withCallingHandlers({
[16:17:42.040]                   {
[16:17:42.040]                     do.call(function(...) {
[16:17:42.040]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.040]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.040]                         ...future.globals.maxSize)) {
[16:17:42.040]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.040]                         on.exit(options(oopts), add = TRUE)
[16:17:42.040]                       }
[16:17:42.040]                       {
[16:17:42.040]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.040]                           FUN = function(jj) {
[16:17:42.040]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.040]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.040]                           })
[16:17:42.040]                       }
[16:17:42.040]                     }, args = future.call.arguments)
[16:17:42.040]                   }
[16:17:42.040]                 }, immediateCondition = function(cond) {
[16:17:42.040]                   save_rds <- function (object, pathname, ...) 
[16:17:42.040]                   {
[16:17:42.040]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.040]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.040]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.040]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.040]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.040]                         fi_tmp[["mtime"]])
[16:17:42.040]                     }
[16:17:42.040]                     tryCatch({
[16:17:42.040]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.040]                     }, error = function(ex) {
[16:17:42.040]                       msg <- conditionMessage(ex)
[16:17:42.040]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.040]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.040]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.040]                         fi_tmp[["mtime"]], msg)
[16:17:42.040]                       ex$message <- msg
[16:17:42.040]                       stop(ex)
[16:17:42.040]                     })
[16:17:42.040]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.040]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.040]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.040]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.040]                       fi <- file.info(pathname)
[16:17:42.040]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.040]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.040]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.040]                         fi[["size"]], fi[["mtime"]])
[16:17:42.040]                       stop(msg)
[16:17:42.040]                     }
[16:17:42.040]                     invisible(pathname)
[16:17:42.040]                   }
[16:17:42.040]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.040]                     rootPath = tempdir()) 
[16:17:42.040]                   {
[16:17:42.040]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.040]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.040]                       tmpdir = path, fileext = ".rds")
[16:17:42.040]                     save_rds(obj, file)
[16:17:42.040]                   }
[16:17:42.040]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.040]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.040]                   {
[16:17:42.040]                     inherits <- base::inherits
[16:17:42.040]                     invokeRestart <- base::invokeRestart
[16:17:42.040]                     is.null <- base::is.null
[16:17:42.040]                     muffled <- FALSE
[16:17:42.040]                     if (inherits(cond, "message")) {
[16:17:42.040]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.040]                       if (muffled) 
[16:17:42.040]                         invokeRestart("muffleMessage")
[16:17:42.040]                     }
[16:17:42.040]                     else if (inherits(cond, "warning")) {
[16:17:42.040]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.040]                       if (muffled) 
[16:17:42.040]                         invokeRestart("muffleWarning")
[16:17:42.040]                     }
[16:17:42.040]                     else if (inherits(cond, "condition")) {
[16:17:42.040]                       if (!is.null(pattern)) {
[16:17:42.040]                         computeRestarts <- base::computeRestarts
[16:17:42.040]                         grepl <- base::grepl
[16:17:42.040]                         restarts <- computeRestarts(cond)
[16:17:42.040]                         for (restart in restarts) {
[16:17:42.040]                           name <- restart$name
[16:17:42.040]                           if (is.null(name)) 
[16:17:42.040]                             next
[16:17:42.040]                           if (!grepl(pattern, name)) 
[16:17:42.040]                             next
[16:17:42.040]                           invokeRestart(restart)
[16:17:42.040]                           muffled <- TRUE
[16:17:42.040]                           break
[16:17:42.040]                         }
[16:17:42.040]                       }
[16:17:42.040]                     }
[16:17:42.040]                     invisible(muffled)
[16:17:42.040]                   }
[16:17:42.040]                   muffleCondition(cond)
[16:17:42.040]                 })
[16:17:42.040]             }))
[16:17:42.040]             future::FutureResult(value = ...future.value$value, 
[16:17:42.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.040]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.040]                     ...future.globalenv.names))
[16:17:42.040]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.040]         }, condition = base::local({
[16:17:42.040]             c <- base::c
[16:17:42.040]             inherits <- base::inherits
[16:17:42.040]             invokeRestart <- base::invokeRestart
[16:17:42.040]             length <- base::length
[16:17:42.040]             list <- base::list
[16:17:42.040]             seq.int <- base::seq.int
[16:17:42.040]             signalCondition <- base::signalCondition
[16:17:42.040]             sys.calls <- base::sys.calls
[16:17:42.040]             `[[` <- base::`[[`
[16:17:42.040]             `+` <- base::`+`
[16:17:42.040]             `<<-` <- base::`<<-`
[16:17:42.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.040]                   3L)]
[16:17:42.040]             }
[16:17:42.040]             function(cond) {
[16:17:42.040]                 is_error <- inherits(cond, "error")
[16:17:42.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.040]                   NULL)
[16:17:42.040]                 if (is_error) {
[16:17:42.040]                   sessionInformation <- function() {
[16:17:42.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.040]                       search = base::search(), system = base::Sys.info())
[16:17:42.040]                   }
[16:17:42.040]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.040]                     cond$call), session = sessionInformation(), 
[16:17:42.040]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.040]                   signalCondition(cond)
[16:17:42.040]                 }
[16:17:42.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.040]                 "immediateCondition"))) {
[16:17:42.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.040]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.040]                   if (TRUE && !signal) {
[16:17:42.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.040]                     {
[16:17:42.040]                       inherits <- base::inherits
[16:17:42.040]                       invokeRestart <- base::invokeRestart
[16:17:42.040]                       is.null <- base::is.null
[16:17:42.040]                       muffled <- FALSE
[16:17:42.040]                       if (inherits(cond, "message")) {
[16:17:42.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.040]                         if (muffled) 
[16:17:42.040]                           invokeRestart("muffleMessage")
[16:17:42.040]                       }
[16:17:42.040]                       else if (inherits(cond, "warning")) {
[16:17:42.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.040]                         if (muffled) 
[16:17:42.040]                           invokeRestart("muffleWarning")
[16:17:42.040]                       }
[16:17:42.040]                       else if (inherits(cond, "condition")) {
[16:17:42.040]                         if (!is.null(pattern)) {
[16:17:42.040]                           computeRestarts <- base::computeRestarts
[16:17:42.040]                           grepl <- base::grepl
[16:17:42.040]                           restarts <- computeRestarts(cond)
[16:17:42.040]                           for (restart in restarts) {
[16:17:42.040]                             name <- restart$name
[16:17:42.040]                             if (is.null(name)) 
[16:17:42.040]                               next
[16:17:42.040]                             if (!grepl(pattern, name)) 
[16:17:42.040]                               next
[16:17:42.040]                             invokeRestart(restart)
[16:17:42.040]                             muffled <- TRUE
[16:17:42.040]                             break
[16:17:42.040]                           }
[16:17:42.040]                         }
[16:17:42.040]                       }
[16:17:42.040]                       invisible(muffled)
[16:17:42.040]                     }
[16:17:42.040]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.040]                   }
[16:17:42.040]                 }
[16:17:42.040]                 else {
[16:17:42.040]                   if (TRUE) {
[16:17:42.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.040]                     {
[16:17:42.040]                       inherits <- base::inherits
[16:17:42.040]                       invokeRestart <- base::invokeRestart
[16:17:42.040]                       is.null <- base::is.null
[16:17:42.040]                       muffled <- FALSE
[16:17:42.040]                       if (inherits(cond, "message")) {
[16:17:42.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.040]                         if (muffled) 
[16:17:42.040]                           invokeRestart("muffleMessage")
[16:17:42.040]                       }
[16:17:42.040]                       else if (inherits(cond, "warning")) {
[16:17:42.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.040]                         if (muffled) 
[16:17:42.040]                           invokeRestart("muffleWarning")
[16:17:42.040]                       }
[16:17:42.040]                       else if (inherits(cond, "condition")) {
[16:17:42.040]                         if (!is.null(pattern)) {
[16:17:42.040]                           computeRestarts <- base::computeRestarts
[16:17:42.040]                           grepl <- base::grepl
[16:17:42.040]                           restarts <- computeRestarts(cond)
[16:17:42.040]                           for (restart in restarts) {
[16:17:42.040]                             name <- restart$name
[16:17:42.040]                             if (is.null(name)) 
[16:17:42.040]                               next
[16:17:42.040]                             if (!grepl(pattern, name)) 
[16:17:42.040]                               next
[16:17:42.040]                             invokeRestart(restart)
[16:17:42.040]                             muffled <- TRUE
[16:17:42.040]                             break
[16:17:42.040]                           }
[16:17:42.040]                         }
[16:17:42.040]                       }
[16:17:42.040]                       invisible(muffled)
[16:17:42.040]                     }
[16:17:42.040]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.040]                   }
[16:17:42.040]                 }
[16:17:42.040]             }
[16:17:42.040]         }))
[16:17:42.040]     }, error = function(ex) {
[16:17:42.040]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.040]                 ...future.rng), started = ...future.startTime, 
[16:17:42.040]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.040]             version = "1.8"), class = "FutureResult")
[16:17:42.040]     }, finally = {
[16:17:42.040]         if (!identical(...future.workdir, getwd())) 
[16:17:42.040]             setwd(...future.workdir)
[16:17:42.040]         {
[16:17:42.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.040]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.040]             }
[16:17:42.040]             base::options(...future.oldOptions)
[16:17:42.040]             if (.Platform$OS.type == "windows") {
[16:17:42.040]                 old_names <- names(...future.oldEnvVars)
[16:17:42.040]                 envs <- base::Sys.getenv()
[16:17:42.040]                 names <- names(envs)
[16:17:42.040]                 common <- intersect(names, old_names)
[16:17:42.040]                 added <- setdiff(names, old_names)
[16:17:42.040]                 removed <- setdiff(old_names, names)
[16:17:42.040]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.040]                   envs[common]]
[16:17:42.040]                 NAMES <- toupper(changed)
[16:17:42.040]                 args <- list()
[16:17:42.040]                 for (kk in seq_along(NAMES)) {
[16:17:42.040]                   name <- changed[[kk]]
[16:17:42.040]                   NAME <- NAMES[[kk]]
[16:17:42.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.040]                     next
[16:17:42.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.040]                 }
[16:17:42.040]                 NAMES <- toupper(added)
[16:17:42.040]                 for (kk in seq_along(NAMES)) {
[16:17:42.040]                   name <- added[[kk]]
[16:17:42.040]                   NAME <- NAMES[[kk]]
[16:17:42.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.040]                     next
[16:17:42.040]                   args[[name]] <- ""
[16:17:42.040]                 }
[16:17:42.040]                 NAMES <- toupper(removed)
[16:17:42.040]                 for (kk in seq_along(NAMES)) {
[16:17:42.040]                   name <- removed[[kk]]
[16:17:42.040]                   NAME <- NAMES[[kk]]
[16:17:42.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.040]                     next
[16:17:42.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.040]                 }
[16:17:42.040]                 if (length(args) > 0) 
[16:17:42.040]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.040]             }
[16:17:42.040]             else {
[16:17:42.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.040]             }
[16:17:42.040]             {
[16:17:42.040]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.040]                   0L) {
[16:17:42.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.040]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.040]                   base::options(opts)
[16:17:42.040]                 }
[16:17:42.040]                 {
[16:17:42.040]                   {
[16:17:42.040]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.040]                     NULL
[16:17:42.040]                   }
[16:17:42.040]                   options(future.plan = NULL)
[16:17:42.040]                   if (is.na(NA_character_)) 
[16:17:42.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.040]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.040]                     .init = FALSE)
[16:17:42.040]                 }
[16:17:42.040]             }
[16:17:42.040]         }
[16:17:42.040]     })
[16:17:42.040]     if (TRUE) {
[16:17:42.040]         base::sink(type = "output", split = FALSE)
[16:17:42.040]         if (TRUE) {
[16:17:42.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.040]         }
[16:17:42.040]         else {
[16:17:42.040]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.040]         }
[16:17:42.040]         base::close(...future.stdout)
[16:17:42.040]         ...future.stdout <- NULL
[16:17:42.040]     }
[16:17:42.040]     ...future.result$conditions <- ...future.conditions
[16:17:42.040]     ...future.result$finished <- base::Sys.time()
[16:17:42.040]     ...future.result
[16:17:42.040] }
[16:17:42.043] assign_globals() ...
[16:17:42.043] List of 5
[16:17:42.043]  $ future.call.arguments    : list()
[16:17:42.043]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.043]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:42.043]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:42.043]  $ ...future.elements_ii    :List of 1
[16:17:42.043]   ..$ : num [1:4] 2 4 6 8
[16:17:42.043]  $ ...future.seeds_ii       : NULL
[16:17:42.043]  $ ...future.globals.maxSize: num Inf
[16:17:42.043]  - attr(*, "resolved")= logi FALSE
[16:17:42.043]  - attr(*, "total_size")= num NA
[16:17:42.043]  - attr(*, "where")=List of 5
[16:17:42.043]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.043]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.043]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.043]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.043]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.043]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.043]  - attr(*, "already-done")= logi TRUE
[16:17:42.050] - copied ‘future.call.arguments’ to environment
[16:17:42.050] - copied ‘...future.FUN’ to environment
[16:17:42.051] - copied ‘...future.elements_ii’ to environment
[16:17:42.051] - copied ‘...future.seeds_ii’ to environment
[16:17:42.053] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.053] assign_globals() ... done
[16:17:42.054] requestCore(): workers = 2
[16:17:42.061] MulticoreFuture started
[16:17:42.061] - Launch lazy future ... done
[16:17:42.061] run() for ‘MulticoreFuture’ ... done
[16:17:42.062] Created future:
[16:17:42.062] plan(): Setting new future strategy stack:
[16:17:42.062] List of future strategies:
[16:17:42.062] 1. sequential:
[16:17:42.062]    - args: function (..., envir = parent.frame())
[16:17:42.062]    - tweaked: FALSE
[16:17:42.062]    - call: NULL
[16:17:42.063] plan(): nbrOfWorkers() = 1
[16:17:42.066] plan(): Setting new future strategy stack:
[16:17:42.066] List of future strategies:
[16:17:42.066] 1. multicore:
[16:17:42.066]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.066]    - tweaked: FALSE
[16:17:42.066]    - call: plan(strategy)
[16:17:42.072] plan(): nbrOfWorkers() = 2
[16:17:42.062] MulticoreFuture:
[16:17:42.062] Label: ‘future_apply-2’
[16:17:42.062] Expression:
[16:17:42.062] {
[16:17:42.062]     do.call(function(...) {
[16:17:42.062]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.062]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.062]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.062]             on.exit(options(oopts), add = TRUE)
[16:17:42.062]         }
[16:17:42.062]         {
[16:17:42.062]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.062]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.062]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.062]             })
[16:17:42.062]         }
[16:17:42.062]     }, args = future.call.arguments)
[16:17:42.062] }
[16:17:42.062] Lazy evaluation: FALSE
[16:17:42.062] Asynchronous evaluation: TRUE
[16:17:42.062] Local evaluation: TRUE
[16:17:42.062] Environment: R_GlobalEnv
[16:17:42.062] Capture standard output: TRUE
[16:17:42.062] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.062] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.062] Packages: <none>
[16:17:42.062] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.062] Resolved: TRUE
[16:17:42.062] Value: <not collected>
[16:17:42.062] Conditions captured: <none>
[16:17:42.062] Early signaling: FALSE
[16:17:42.062] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.062] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.073] Chunk #2 of 2 ... DONE
[16:17:42.073] Launching 2 futures (chunks) ... DONE
[16:17:42.074] Resolving 2 futures (chunks) ...
[16:17:42.074] resolve() on list ...
[16:17:42.074]  recursive: 0
[16:17:42.074]  length: 2
[16:17:42.074] 
[16:17:42.075] Future #1
[16:17:42.075] result() for MulticoreFuture ...
[16:17:42.077] result() for MulticoreFuture ...
[16:17:42.077] result() for MulticoreFuture ... done
[16:17:42.078] result() for MulticoreFuture ... done
[16:17:42.078] result() for MulticoreFuture ...
[16:17:42.078] result() for MulticoreFuture ... done
[16:17:42.078] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:42.078] - nx: 2
[16:17:42.079] - relay: TRUE
[16:17:42.079] - stdout: TRUE
[16:17:42.079] - signal: TRUE
[16:17:42.079] - resignal: FALSE
[16:17:42.079] - force: TRUE
[16:17:42.079] - relayed: [n=2] FALSE, FALSE
[16:17:42.079] - queued futures: [n=2] FALSE, FALSE
[16:17:42.080]  - until=1
[16:17:42.080]  - relaying element #1
[16:17:42.080] result() for MulticoreFuture ...
[16:17:42.080] result() for MulticoreFuture ... done
[16:17:42.080] result() for MulticoreFuture ...
[16:17:42.080] result() for MulticoreFuture ... done
[16:17:42.081] result() for MulticoreFuture ...
[16:17:42.081] result() for MulticoreFuture ... done
[16:17:42.081] result() for MulticoreFuture ...
[16:17:42.081] result() for MulticoreFuture ... done
[16:17:42.081] - relayed: [n=2] TRUE, FALSE
[16:17:42.081] - queued futures: [n=2] TRUE, FALSE
[16:17:42.082] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:42.082]  length: 1 (resolved future 1)
[16:17:42.082] Future #2
[16:17:42.082] result() for MulticoreFuture ...
[16:17:42.083] result() for MulticoreFuture ...
[16:17:42.083] result() for MulticoreFuture ... done
[16:17:42.083] result() for MulticoreFuture ... done
[16:17:42.083] result() for MulticoreFuture ...
[16:17:42.083] result() for MulticoreFuture ... done
[16:17:42.084] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:42.084] - nx: 2
[16:17:42.084] - relay: TRUE
[16:17:42.084] - stdout: TRUE
[16:17:42.084] - signal: TRUE
[16:17:42.084] - resignal: FALSE
[16:17:42.084] - force: TRUE
[16:17:42.085] - relayed: [n=2] TRUE, FALSE
[16:17:42.085] - queued futures: [n=2] TRUE, FALSE
[16:17:42.085]  - until=2
[16:17:42.085]  - relaying element #2
[16:17:42.085] result() for MulticoreFuture ...
[16:17:42.085] result() for MulticoreFuture ... done
[16:17:42.085] result() for MulticoreFuture ...
[16:17:42.085] result() for MulticoreFuture ... done
[16:17:42.086] result() for MulticoreFuture ...
[16:17:42.086] result() for MulticoreFuture ... done
[16:17:42.086] result() for MulticoreFuture ...
[16:17:42.086] result() for MulticoreFuture ... done
[16:17:42.086] - relayed: [n=2] TRUE, TRUE
[16:17:42.086] - queued futures: [n=2] TRUE, TRUE
[16:17:42.086] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:42.086]  length: 0 (resolved future 2)
[16:17:42.086] Relaying remaining futures
[16:17:42.087] signalConditionsASAP(NULL, pos=0) ...
[16:17:42.087] - nx: 2
[16:17:42.087] - relay: TRUE
[16:17:42.087] - stdout: TRUE
[16:17:42.087] - signal: TRUE
[16:17:42.087] - resignal: FALSE
[16:17:42.087] - force: TRUE
[16:17:42.087] - relayed: [n=2] TRUE, TRUE
[16:17:42.087] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:42.088] - relayed: [n=2] TRUE, TRUE
[16:17:42.088] - queued futures: [n=2] TRUE, TRUE
[16:17:42.088] signalConditionsASAP(NULL, pos=0) ... done
[16:17:42.088] resolve() on list ... DONE
[16:17:42.088] result() for MulticoreFuture ...
[16:17:42.088] result() for MulticoreFuture ... done
[16:17:42.088] result() for MulticoreFuture ...
[16:17:42.088] result() for MulticoreFuture ... done
[16:17:42.089] result() for MulticoreFuture ...
[16:17:42.089] result() for MulticoreFuture ... done
[16:17:42.089] result() for MulticoreFuture ...
[16:17:42.089] result() for MulticoreFuture ... done
[16:17:42.089]  - Number of value chunks collected: 2
[16:17:42.089] Resolving 2 futures (chunks) ... DONE
[16:17:42.089] Reducing values from 2 chunks ...
[16:17:42.089]  - Number of values collected after concatenation: 2
[16:17:42.089]  - Number of values expected: 2
[16:17:42.090] Reducing values from 2 chunks ... DONE
[16:17:42.090] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:17:42.090] getGlobalsAndPackagesXApply() ...
[16:17:42.090]  - future.globals: TRUE
[16:17:42.091] getGlobalsAndPackages() ...
[16:17:42.091] Searching for globals...
[16:17:42.129] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:17:42.129] Searching for globals ... DONE
[16:17:42.129] Resolving globals: FALSE
[16:17:42.131] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:17:42.133] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:17:42.133] - globals: [1] ‘FUN’
[16:17:42.134] 
[16:17:42.134] getGlobalsAndPackages() ... DONE
[16:17:42.134]  - globals found/used: [n=1] ‘FUN’
[16:17:42.134]  - needed namespaces: [n=0] 
[16:17:42.134] Finding globals ... DONE
[16:17:42.134]  - use_args: TRUE
[16:17:42.134]  - Getting '...' globals ...
[16:17:42.135] resolve() on list ...
[16:17:42.135]  recursive: 0
[16:17:42.135]  length: 1
[16:17:42.135]  elements: ‘...’
[16:17:42.135]  length: 0 (resolved future 1)
[16:17:42.135] resolve() on list ... DONE
[16:17:42.135]    - '...' content: [n=0] 
[16:17:42.135] List of 1
[16:17:42.135]  $ ...: list()
[16:17:42.135]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.135]  - attr(*, "where")=List of 1
[16:17:42.135]   ..$ ...:<environment: 0x555be24ff6b0> 
[16:17:42.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.135]  - attr(*, "resolved")= logi TRUE
[16:17:42.135]  - attr(*, "total_size")= num NA
[16:17:42.138]  - Getting '...' globals ... DONE
[16:17:42.138] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:42.138] List of 2
[16:17:42.138]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:42.138]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:42.138]  $ ...          : list()
[16:17:42.138]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.138]  - attr(*, "where")=List of 2
[16:17:42.138]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:42.138]   ..$ ...          :<environment: 0x555be24ff6b0> 
[16:17:42.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.138]  - attr(*, "resolved")= logi FALSE
[16:17:42.138]  - attr(*, "total_size")= num 354224
[16:17:42.141] Packages to be attached in all futures: [n=0] 
[16:17:42.141] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.145] future_lapply() ...
[16:17:42.182] Number of chunks: 2
[16:17:42.182] getGlobalsAndPackagesXApply() ...
[16:17:42.182]  - future.globals: <name-value list> with names ‘list()’
[16:17:42.182]  - use_args: TRUE
[16:17:42.182] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:42.182] List of 2
[16:17:42.182]  $ ...          : list()
[16:17:42.182]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.182]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:42.182]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:42.182]  - attr(*, "where")=List of 2
[16:17:42.182]   ..$ ...          :<environment: 0x555be24ff6b0> 
[16:17:42.182]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:42.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.182]  - attr(*, "resolved")= logi FALSE
[16:17:42.182]  - attr(*, "total_size")= num NA
[16:17:42.185] Packages to be attached in all futures: [n=0] 
[16:17:42.186] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.186] Number of futures (= number of chunks): 2
[16:17:42.186] Launching 2 futures (chunks) ...
[16:17:42.186] Chunk #1 of 2 ...
[16:17:42.186]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.186]  - seeds: <none>
[16:17:42.186]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.186] getGlobalsAndPackages() ...
[16:17:42.187] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.187] Resolving globals: FALSE
[16:17:42.187] Tweak future expression to call with '...' arguments ...
[16:17:42.187] {
[16:17:42.187]     do.call(function(...) {
[16:17:42.187]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.187]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.187]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.187]             on.exit(options(oopts), add = TRUE)
[16:17:42.187]         }
[16:17:42.187]         {
[16:17:42.187]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.187]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.187]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.187]             })
[16:17:42.187]         }
[16:17:42.187]     }, args = future.call.arguments)
[16:17:42.187] }
[16:17:42.187] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.188] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.188] 
[16:17:42.188] getGlobalsAndPackages() ... DONE
[16:17:42.188] run() for ‘Future’ ...
[16:17:42.188] - state: ‘created’
[16:17:42.188] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.192] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.192] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.192]   - Field: ‘label’
[16:17:42.192]   - Field: ‘local’
[16:17:42.192]   - Field: ‘owner’
[16:17:42.192]   - Field: ‘envir’
[16:17:42.192]   - Field: ‘workers’
[16:17:42.192]   - Field: ‘packages’
[16:17:42.193]   - Field: ‘gc’
[16:17:42.193]   - Field: ‘job’
[16:17:42.193]   - Field: ‘conditions’
[16:17:42.193]   - Field: ‘expr’
[16:17:42.193]   - Field: ‘uuid’
[16:17:42.193]   - Field: ‘seed’
[16:17:42.193]   - Field: ‘version’
[16:17:42.193]   - Field: ‘result’
[16:17:42.193]   - Field: ‘asynchronous’
[16:17:42.194]   - Field: ‘calls’
[16:17:42.194]   - Field: ‘globals’
[16:17:42.194]   - Field: ‘stdout’
[16:17:42.195]   - Field: ‘earlySignal’
[16:17:42.195]   - Field: ‘lazy’
[16:17:42.195]   - Field: ‘state’
[16:17:42.195] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.195] - Launch lazy future ...
[16:17:42.195] Packages needed by the future expression (n = 0): <none>
[16:17:42.195] Packages needed by future strategies (n = 0): <none>
[16:17:42.196] {
[16:17:42.196]     {
[16:17:42.196]         {
[16:17:42.196]             ...future.startTime <- base::Sys.time()
[16:17:42.196]             {
[16:17:42.196]                 {
[16:17:42.196]                   {
[16:17:42.196]                     {
[16:17:42.196]                       base::local({
[16:17:42.196]                         has_future <- base::requireNamespace("future", 
[16:17:42.196]                           quietly = TRUE)
[16:17:42.196]                         if (has_future) {
[16:17:42.196]                           ns <- base::getNamespace("future")
[16:17:42.196]                           version <- ns[[".package"]][["version"]]
[16:17:42.196]                           if (is.null(version)) 
[16:17:42.196]                             version <- utils::packageVersion("future")
[16:17:42.196]                         }
[16:17:42.196]                         else {
[16:17:42.196]                           version <- NULL
[16:17:42.196]                         }
[16:17:42.196]                         if (!has_future || version < "1.8.0") {
[16:17:42.196]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.196]                             "", base::R.version$version.string), 
[16:17:42.196]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.196]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.196]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.196]                               "release", "version")], collapse = " "), 
[16:17:42.196]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.196]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.196]                             info)
[16:17:42.196]                           info <- base::paste(info, collapse = "; ")
[16:17:42.196]                           if (!has_future) {
[16:17:42.196]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.196]                               info)
[16:17:42.196]                           }
[16:17:42.196]                           else {
[16:17:42.196]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.196]                               info, version)
[16:17:42.196]                           }
[16:17:42.196]                           base::stop(msg)
[16:17:42.196]                         }
[16:17:42.196]                       })
[16:17:42.196]                     }
[16:17:42.196]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.196]                     base::options(mc.cores = 1L)
[16:17:42.196]                   }
[16:17:42.196]                   ...future.strategy.old <- future::plan("list")
[16:17:42.196]                   options(future.plan = NULL)
[16:17:42.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.196]                 }
[16:17:42.196]                 ...future.workdir <- getwd()
[16:17:42.196]             }
[16:17:42.196]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.196]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.196]         }
[16:17:42.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.196]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.196]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.196]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.196]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.196]             base::names(...future.oldOptions))
[16:17:42.196]     }
[16:17:42.196]     if (FALSE) {
[16:17:42.196]     }
[16:17:42.196]     else {
[16:17:42.196]         if (TRUE) {
[16:17:42.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.196]                 open = "w")
[16:17:42.196]         }
[16:17:42.196]         else {
[16:17:42.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.196]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.196]         }
[16:17:42.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.196]             base::sink(type = "output", split = FALSE)
[16:17:42.196]             base::close(...future.stdout)
[16:17:42.196]         }, add = TRUE)
[16:17:42.196]     }
[16:17:42.196]     ...future.frame <- base::sys.nframe()
[16:17:42.196]     ...future.conditions <- base::list()
[16:17:42.196]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.196]     if (FALSE) {
[16:17:42.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.196]     }
[16:17:42.196]     ...future.result <- base::tryCatch({
[16:17:42.196]         base::withCallingHandlers({
[16:17:42.196]             ...future.value <- base::withVisible(base::local({
[16:17:42.196]                 withCallingHandlers({
[16:17:42.196]                   {
[16:17:42.196]                     do.call(function(...) {
[16:17:42.196]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.196]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.196]                         ...future.globals.maxSize)) {
[16:17:42.196]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.196]                         on.exit(options(oopts), add = TRUE)
[16:17:42.196]                       }
[16:17:42.196]                       {
[16:17:42.196]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.196]                           FUN = function(jj) {
[16:17:42.196]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.196]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.196]                           })
[16:17:42.196]                       }
[16:17:42.196]                     }, args = future.call.arguments)
[16:17:42.196]                   }
[16:17:42.196]                 }, immediateCondition = function(cond) {
[16:17:42.196]                   save_rds <- function (object, pathname, ...) 
[16:17:42.196]                   {
[16:17:42.196]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.196]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.196]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.196]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.196]                         fi_tmp[["mtime"]])
[16:17:42.196]                     }
[16:17:42.196]                     tryCatch({
[16:17:42.196]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.196]                     }, error = function(ex) {
[16:17:42.196]                       msg <- conditionMessage(ex)
[16:17:42.196]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.196]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.196]                         fi_tmp[["mtime"]], msg)
[16:17:42.196]                       ex$message <- msg
[16:17:42.196]                       stop(ex)
[16:17:42.196]                     })
[16:17:42.196]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.196]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.196]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.196]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.196]                       fi <- file.info(pathname)
[16:17:42.196]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.196]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.196]                         fi[["size"]], fi[["mtime"]])
[16:17:42.196]                       stop(msg)
[16:17:42.196]                     }
[16:17:42.196]                     invisible(pathname)
[16:17:42.196]                   }
[16:17:42.196]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.196]                     rootPath = tempdir()) 
[16:17:42.196]                   {
[16:17:42.196]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.196]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.196]                       tmpdir = path, fileext = ".rds")
[16:17:42.196]                     save_rds(obj, file)
[16:17:42.196]                   }
[16:17:42.196]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.196]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.196]                   {
[16:17:42.196]                     inherits <- base::inherits
[16:17:42.196]                     invokeRestart <- base::invokeRestart
[16:17:42.196]                     is.null <- base::is.null
[16:17:42.196]                     muffled <- FALSE
[16:17:42.196]                     if (inherits(cond, "message")) {
[16:17:42.196]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.196]                       if (muffled) 
[16:17:42.196]                         invokeRestart("muffleMessage")
[16:17:42.196]                     }
[16:17:42.196]                     else if (inherits(cond, "warning")) {
[16:17:42.196]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.196]                       if (muffled) 
[16:17:42.196]                         invokeRestart("muffleWarning")
[16:17:42.196]                     }
[16:17:42.196]                     else if (inherits(cond, "condition")) {
[16:17:42.196]                       if (!is.null(pattern)) {
[16:17:42.196]                         computeRestarts <- base::computeRestarts
[16:17:42.196]                         grepl <- base::grepl
[16:17:42.196]                         restarts <- computeRestarts(cond)
[16:17:42.196]                         for (restart in restarts) {
[16:17:42.196]                           name <- restart$name
[16:17:42.196]                           if (is.null(name)) 
[16:17:42.196]                             next
[16:17:42.196]                           if (!grepl(pattern, name)) 
[16:17:42.196]                             next
[16:17:42.196]                           invokeRestart(restart)
[16:17:42.196]                           muffled <- TRUE
[16:17:42.196]                           break
[16:17:42.196]                         }
[16:17:42.196]                       }
[16:17:42.196]                     }
[16:17:42.196]                     invisible(muffled)
[16:17:42.196]                   }
[16:17:42.196]                   muffleCondition(cond)
[16:17:42.196]                 })
[16:17:42.196]             }))
[16:17:42.196]             future::FutureResult(value = ...future.value$value, 
[16:17:42.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.196]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.196]                     ...future.globalenv.names))
[16:17:42.196]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.196]         }, condition = base::local({
[16:17:42.196]             c <- base::c
[16:17:42.196]             inherits <- base::inherits
[16:17:42.196]             invokeRestart <- base::invokeRestart
[16:17:42.196]             length <- base::length
[16:17:42.196]             list <- base::list
[16:17:42.196]             seq.int <- base::seq.int
[16:17:42.196]             signalCondition <- base::signalCondition
[16:17:42.196]             sys.calls <- base::sys.calls
[16:17:42.196]             `[[` <- base::`[[`
[16:17:42.196]             `+` <- base::`+`
[16:17:42.196]             `<<-` <- base::`<<-`
[16:17:42.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.196]                   3L)]
[16:17:42.196]             }
[16:17:42.196]             function(cond) {
[16:17:42.196]                 is_error <- inherits(cond, "error")
[16:17:42.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.196]                   NULL)
[16:17:42.196]                 if (is_error) {
[16:17:42.196]                   sessionInformation <- function() {
[16:17:42.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.196]                       search = base::search(), system = base::Sys.info())
[16:17:42.196]                   }
[16:17:42.196]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.196]                     cond$call), session = sessionInformation(), 
[16:17:42.196]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.196]                   signalCondition(cond)
[16:17:42.196]                 }
[16:17:42.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.196]                 "immediateCondition"))) {
[16:17:42.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.196]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.196]                   if (TRUE && !signal) {
[16:17:42.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.196]                     {
[16:17:42.196]                       inherits <- base::inherits
[16:17:42.196]                       invokeRestart <- base::invokeRestart
[16:17:42.196]                       is.null <- base::is.null
[16:17:42.196]                       muffled <- FALSE
[16:17:42.196]                       if (inherits(cond, "message")) {
[16:17:42.196]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.196]                         if (muffled) 
[16:17:42.196]                           invokeRestart("muffleMessage")
[16:17:42.196]                       }
[16:17:42.196]                       else if (inherits(cond, "warning")) {
[16:17:42.196]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.196]                         if (muffled) 
[16:17:42.196]                           invokeRestart("muffleWarning")
[16:17:42.196]                       }
[16:17:42.196]                       else if (inherits(cond, "condition")) {
[16:17:42.196]                         if (!is.null(pattern)) {
[16:17:42.196]                           computeRestarts <- base::computeRestarts
[16:17:42.196]                           grepl <- base::grepl
[16:17:42.196]                           restarts <- computeRestarts(cond)
[16:17:42.196]                           for (restart in restarts) {
[16:17:42.196]                             name <- restart$name
[16:17:42.196]                             if (is.null(name)) 
[16:17:42.196]                               next
[16:17:42.196]                             if (!grepl(pattern, name)) 
[16:17:42.196]                               next
[16:17:42.196]                             invokeRestart(restart)
[16:17:42.196]                             muffled <- TRUE
[16:17:42.196]                             break
[16:17:42.196]                           }
[16:17:42.196]                         }
[16:17:42.196]                       }
[16:17:42.196]                       invisible(muffled)
[16:17:42.196]                     }
[16:17:42.196]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.196]                   }
[16:17:42.196]                 }
[16:17:42.196]                 else {
[16:17:42.196]                   if (TRUE) {
[16:17:42.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.196]                     {
[16:17:42.196]                       inherits <- base::inherits
[16:17:42.196]                       invokeRestart <- base::invokeRestart
[16:17:42.196]                       is.null <- base::is.null
[16:17:42.196]                       muffled <- FALSE
[16:17:42.196]                       if (inherits(cond, "message")) {
[16:17:42.196]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.196]                         if (muffled) 
[16:17:42.196]                           invokeRestart("muffleMessage")
[16:17:42.196]                       }
[16:17:42.196]                       else if (inherits(cond, "warning")) {
[16:17:42.196]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.196]                         if (muffled) 
[16:17:42.196]                           invokeRestart("muffleWarning")
[16:17:42.196]                       }
[16:17:42.196]                       else if (inherits(cond, "condition")) {
[16:17:42.196]                         if (!is.null(pattern)) {
[16:17:42.196]                           computeRestarts <- base::computeRestarts
[16:17:42.196]                           grepl <- base::grepl
[16:17:42.196]                           restarts <- computeRestarts(cond)
[16:17:42.196]                           for (restart in restarts) {
[16:17:42.196]                             name <- restart$name
[16:17:42.196]                             if (is.null(name)) 
[16:17:42.196]                               next
[16:17:42.196]                             if (!grepl(pattern, name)) 
[16:17:42.196]                               next
[16:17:42.196]                             invokeRestart(restart)
[16:17:42.196]                             muffled <- TRUE
[16:17:42.196]                             break
[16:17:42.196]                           }
[16:17:42.196]                         }
[16:17:42.196]                       }
[16:17:42.196]                       invisible(muffled)
[16:17:42.196]                     }
[16:17:42.196]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.196]                   }
[16:17:42.196]                 }
[16:17:42.196]             }
[16:17:42.196]         }))
[16:17:42.196]     }, error = function(ex) {
[16:17:42.196]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.196]                 ...future.rng), started = ...future.startTime, 
[16:17:42.196]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.196]             version = "1.8"), class = "FutureResult")
[16:17:42.196]     }, finally = {
[16:17:42.196]         if (!identical(...future.workdir, getwd())) 
[16:17:42.196]             setwd(...future.workdir)
[16:17:42.196]         {
[16:17:42.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.196]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.196]             }
[16:17:42.196]             base::options(...future.oldOptions)
[16:17:42.196]             if (.Platform$OS.type == "windows") {
[16:17:42.196]                 old_names <- names(...future.oldEnvVars)
[16:17:42.196]                 envs <- base::Sys.getenv()
[16:17:42.196]                 names <- names(envs)
[16:17:42.196]                 common <- intersect(names, old_names)
[16:17:42.196]                 added <- setdiff(names, old_names)
[16:17:42.196]                 removed <- setdiff(old_names, names)
[16:17:42.196]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.196]                   envs[common]]
[16:17:42.196]                 NAMES <- toupper(changed)
[16:17:42.196]                 args <- list()
[16:17:42.196]                 for (kk in seq_along(NAMES)) {
[16:17:42.196]                   name <- changed[[kk]]
[16:17:42.196]                   NAME <- NAMES[[kk]]
[16:17:42.196]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.196]                     next
[16:17:42.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.196]                 }
[16:17:42.196]                 NAMES <- toupper(added)
[16:17:42.196]                 for (kk in seq_along(NAMES)) {
[16:17:42.196]                   name <- added[[kk]]
[16:17:42.196]                   NAME <- NAMES[[kk]]
[16:17:42.196]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.196]                     next
[16:17:42.196]                   args[[name]] <- ""
[16:17:42.196]                 }
[16:17:42.196]                 NAMES <- toupper(removed)
[16:17:42.196]                 for (kk in seq_along(NAMES)) {
[16:17:42.196]                   name <- removed[[kk]]
[16:17:42.196]                   NAME <- NAMES[[kk]]
[16:17:42.196]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.196]                     next
[16:17:42.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.196]                 }
[16:17:42.196]                 if (length(args) > 0) 
[16:17:42.196]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.196]             }
[16:17:42.196]             else {
[16:17:42.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.196]             }
[16:17:42.196]             {
[16:17:42.196]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.196]                   0L) {
[16:17:42.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.196]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.196]                   base::options(opts)
[16:17:42.196]                 }
[16:17:42.196]                 {
[16:17:42.196]                   {
[16:17:42.196]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.196]                     NULL
[16:17:42.196]                   }
[16:17:42.196]                   options(future.plan = NULL)
[16:17:42.196]                   if (is.na(NA_character_)) 
[16:17:42.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.196]                     .init = FALSE)
[16:17:42.196]                 }
[16:17:42.196]             }
[16:17:42.196]         }
[16:17:42.196]     })
[16:17:42.196]     if (TRUE) {
[16:17:42.196]         base::sink(type = "output", split = FALSE)
[16:17:42.196]         if (TRUE) {
[16:17:42.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.196]         }
[16:17:42.196]         else {
[16:17:42.196]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.196]         }
[16:17:42.196]         base::close(...future.stdout)
[16:17:42.196]         ...future.stdout <- NULL
[16:17:42.196]     }
[16:17:42.196]     ...future.result$conditions <- ...future.conditions
[16:17:42.196]     ...future.result$finished <- base::Sys.time()
[16:17:42.196]     ...future.result
[16:17:42.196] }
[16:17:42.198] assign_globals() ...
[16:17:42.198] List of 5
[16:17:42.198]  $ future.call.arguments    : list()
[16:17:42.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.198]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:42.198]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:42.198]  $ ...future.elements_ii    :List of 1
[16:17:42.198]   ..$ : num [1:4] 1 3 1 7
[16:17:42.198]  $ ...future.seeds_ii       : NULL
[16:17:42.198]  $ ...future.globals.maxSize: num Inf
[16:17:42.198]  - attr(*, "resolved")= logi FALSE
[16:17:42.198]  - attr(*, "total_size")= num NA
[16:17:42.198]  - attr(*, "where")=List of 5
[16:17:42.198]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.198]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.198]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.198]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.198]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.198]  - attr(*, "already-done")= logi TRUE
[16:17:42.203] - copied ‘future.call.arguments’ to environment
[16:17:42.203] - copied ‘...future.FUN’ to environment
[16:17:42.203] - copied ‘...future.elements_ii’ to environment
[16:17:42.203] - copied ‘...future.seeds_ii’ to environment
[16:17:42.203] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.203] assign_globals() ... done
[16:17:42.203] requestCore(): workers = 2
[16:17:42.205] MulticoreFuture started
[16:17:42.206] - Launch lazy future ... done
[16:17:42.206] run() for ‘MulticoreFuture’ ... done
[16:17:42.206] Created future:
[16:17:42.207] plan(): Setting new future strategy stack:
[16:17:42.207] List of future strategies:
[16:17:42.207] 1. sequential:
[16:17:42.207]    - args: function (..., envir = parent.frame())
[16:17:42.207]    - tweaked: FALSE
[16:17:42.207]    - call: NULL
[16:17:42.208] plan(): nbrOfWorkers() = 1
[16:17:42.210] plan(): Setting new future strategy stack:
[16:17:42.210] List of future strategies:
[16:17:42.210] 1. multicore:
[16:17:42.210]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.210]    - tweaked: FALSE
[16:17:42.210]    - call: plan(strategy)
[16:17:42.215] plan(): nbrOfWorkers() = 2
[16:17:42.206] MulticoreFuture:
[16:17:42.206] Label: ‘future_apply-1’
[16:17:42.206] Expression:
[16:17:42.206] {
[16:17:42.206]     do.call(function(...) {
[16:17:42.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.206]             on.exit(options(oopts), add = TRUE)
[16:17:42.206]         }
[16:17:42.206]         {
[16:17:42.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.206]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.206]             })
[16:17:42.206]         }
[16:17:42.206]     }, args = future.call.arguments)
[16:17:42.206] }
[16:17:42.206] Lazy evaluation: FALSE
[16:17:42.206] Asynchronous evaluation: TRUE
[16:17:42.206] Local evaluation: TRUE
[16:17:42.206] Environment: R_GlobalEnv
[16:17:42.206] Capture standard output: TRUE
[16:17:42.206] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.206] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.206] Packages: <none>
[16:17:42.206] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.206] Resolved: TRUE
[16:17:42.206] Value: <not collected>
[16:17:42.206] Conditions captured: <none>
[16:17:42.206] Early signaling: FALSE
[16:17:42.206] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.206] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.216] Chunk #1 of 2 ... DONE
[16:17:42.216] Chunk #2 of 2 ...
[16:17:42.217]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.217]  - seeds: <none>
[16:17:42.217]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.217] getGlobalsAndPackages() ...
[16:17:42.217] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.218] Resolving globals: FALSE
[16:17:42.218] Tweak future expression to call with '...' arguments ...
[16:17:42.218] {
[16:17:42.218]     do.call(function(...) {
[16:17:42.218]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.218]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.218]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.218]             on.exit(options(oopts), add = TRUE)
[16:17:42.218]         }
[16:17:42.218]         {
[16:17:42.218]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.218]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.218]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.218]             })
[16:17:42.218]         }
[16:17:42.218]     }, args = future.call.arguments)
[16:17:42.218] }
[16:17:42.218] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.219] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.219] 
[16:17:42.219] getGlobalsAndPackages() ... DONE
[16:17:42.220] run() for ‘Future’ ...
[16:17:42.220] - state: ‘created’
[16:17:42.220] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.225] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.225] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.225]   - Field: ‘label’
[16:17:42.225]   - Field: ‘local’
[16:17:42.225]   - Field: ‘owner’
[16:17:42.225]   - Field: ‘envir’
[16:17:42.226]   - Field: ‘workers’
[16:17:42.226]   - Field: ‘packages’
[16:17:42.226]   - Field: ‘gc’
[16:17:42.226]   - Field: ‘job’
[16:17:42.226]   - Field: ‘conditions’
[16:17:42.226]   - Field: ‘expr’
[16:17:42.226]   - Field: ‘uuid’
[16:17:42.227]   - Field: ‘seed’
[16:17:42.227]   - Field: ‘version’
[16:17:42.227]   - Field: ‘result’
[16:17:42.227]   - Field: ‘asynchronous’
[16:17:42.227]   - Field: ‘calls’
[16:17:42.227]   - Field: ‘globals’
[16:17:42.227]   - Field: ‘stdout’
[16:17:42.228]   - Field: ‘earlySignal’
[16:17:42.228]   - Field: ‘lazy’
[16:17:42.228]   - Field: ‘state’
[16:17:42.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.228] - Launch lazy future ...
[16:17:42.229] Packages needed by the future expression (n = 0): <none>
[16:17:42.229] Packages needed by future strategies (n = 0): <none>
[16:17:42.229] {
[16:17:42.229]     {
[16:17:42.229]         {
[16:17:42.229]             ...future.startTime <- base::Sys.time()
[16:17:42.229]             {
[16:17:42.229]                 {
[16:17:42.229]                   {
[16:17:42.229]                     {
[16:17:42.229]                       base::local({
[16:17:42.229]                         has_future <- base::requireNamespace("future", 
[16:17:42.229]                           quietly = TRUE)
[16:17:42.229]                         if (has_future) {
[16:17:42.229]                           ns <- base::getNamespace("future")
[16:17:42.229]                           version <- ns[[".package"]][["version"]]
[16:17:42.229]                           if (is.null(version)) 
[16:17:42.229]                             version <- utils::packageVersion("future")
[16:17:42.229]                         }
[16:17:42.229]                         else {
[16:17:42.229]                           version <- NULL
[16:17:42.229]                         }
[16:17:42.229]                         if (!has_future || version < "1.8.0") {
[16:17:42.229]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.229]                             "", base::R.version$version.string), 
[16:17:42.229]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.229]                               "release", "version")], collapse = " "), 
[16:17:42.229]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.229]                             info)
[16:17:42.229]                           info <- base::paste(info, collapse = "; ")
[16:17:42.229]                           if (!has_future) {
[16:17:42.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.229]                               info)
[16:17:42.229]                           }
[16:17:42.229]                           else {
[16:17:42.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.229]                               info, version)
[16:17:42.229]                           }
[16:17:42.229]                           base::stop(msg)
[16:17:42.229]                         }
[16:17:42.229]                       })
[16:17:42.229]                     }
[16:17:42.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.229]                     base::options(mc.cores = 1L)
[16:17:42.229]                   }
[16:17:42.229]                   ...future.strategy.old <- future::plan("list")
[16:17:42.229]                   options(future.plan = NULL)
[16:17:42.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.229]                 }
[16:17:42.229]                 ...future.workdir <- getwd()
[16:17:42.229]             }
[16:17:42.229]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.229]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.229]         }
[16:17:42.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.229]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.229]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.229]             base::names(...future.oldOptions))
[16:17:42.229]     }
[16:17:42.229]     if (FALSE) {
[16:17:42.229]     }
[16:17:42.229]     else {
[16:17:42.229]         if (TRUE) {
[16:17:42.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.229]                 open = "w")
[16:17:42.229]         }
[16:17:42.229]         else {
[16:17:42.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.229]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.229]         }
[16:17:42.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.229]             base::sink(type = "output", split = FALSE)
[16:17:42.229]             base::close(...future.stdout)
[16:17:42.229]         }, add = TRUE)
[16:17:42.229]     }
[16:17:42.229]     ...future.frame <- base::sys.nframe()
[16:17:42.229]     ...future.conditions <- base::list()
[16:17:42.229]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.229]     if (FALSE) {
[16:17:42.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.229]     }
[16:17:42.229]     ...future.result <- base::tryCatch({
[16:17:42.229]         base::withCallingHandlers({
[16:17:42.229]             ...future.value <- base::withVisible(base::local({
[16:17:42.229]                 withCallingHandlers({
[16:17:42.229]                   {
[16:17:42.229]                     do.call(function(...) {
[16:17:42.229]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.229]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.229]                         ...future.globals.maxSize)) {
[16:17:42.229]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.229]                         on.exit(options(oopts), add = TRUE)
[16:17:42.229]                       }
[16:17:42.229]                       {
[16:17:42.229]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.229]                           FUN = function(jj) {
[16:17:42.229]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.229]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.229]                           })
[16:17:42.229]                       }
[16:17:42.229]                     }, args = future.call.arguments)
[16:17:42.229]                   }
[16:17:42.229]                 }, immediateCondition = function(cond) {
[16:17:42.229]                   save_rds <- function (object, pathname, ...) 
[16:17:42.229]                   {
[16:17:42.229]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.229]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.229]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.229]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.229]                         fi_tmp[["mtime"]])
[16:17:42.229]                     }
[16:17:42.229]                     tryCatch({
[16:17:42.229]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.229]                     }, error = function(ex) {
[16:17:42.229]                       msg <- conditionMessage(ex)
[16:17:42.229]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.229]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.229]                         fi_tmp[["mtime"]], msg)
[16:17:42.229]                       ex$message <- msg
[16:17:42.229]                       stop(ex)
[16:17:42.229]                     })
[16:17:42.229]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.229]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.229]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.229]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.229]                       fi <- file.info(pathname)
[16:17:42.229]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.229]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.229]                         fi[["size"]], fi[["mtime"]])
[16:17:42.229]                       stop(msg)
[16:17:42.229]                     }
[16:17:42.229]                     invisible(pathname)
[16:17:42.229]                   }
[16:17:42.229]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.229]                     rootPath = tempdir()) 
[16:17:42.229]                   {
[16:17:42.229]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.229]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.229]                       tmpdir = path, fileext = ".rds")
[16:17:42.229]                     save_rds(obj, file)
[16:17:42.229]                   }
[16:17:42.229]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.229]                   {
[16:17:42.229]                     inherits <- base::inherits
[16:17:42.229]                     invokeRestart <- base::invokeRestart
[16:17:42.229]                     is.null <- base::is.null
[16:17:42.229]                     muffled <- FALSE
[16:17:42.229]                     if (inherits(cond, "message")) {
[16:17:42.229]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.229]                       if (muffled) 
[16:17:42.229]                         invokeRestart("muffleMessage")
[16:17:42.229]                     }
[16:17:42.229]                     else if (inherits(cond, "warning")) {
[16:17:42.229]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.229]                       if (muffled) 
[16:17:42.229]                         invokeRestart("muffleWarning")
[16:17:42.229]                     }
[16:17:42.229]                     else if (inherits(cond, "condition")) {
[16:17:42.229]                       if (!is.null(pattern)) {
[16:17:42.229]                         computeRestarts <- base::computeRestarts
[16:17:42.229]                         grepl <- base::grepl
[16:17:42.229]                         restarts <- computeRestarts(cond)
[16:17:42.229]                         for (restart in restarts) {
[16:17:42.229]                           name <- restart$name
[16:17:42.229]                           if (is.null(name)) 
[16:17:42.229]                             next
[16:17:42.229]                           if (!grepl(pattern, name)) 
[16:17:42.229]                             next
[16:17:42.229]                           invokeRestart(restart)
[16:17:42.229]                           muffled <- TRUE
[16:17:42.229]                           break
[16:17:42.229]                         }
[16:17:42.229]                       }
[16:17:42.229]                     }
[16:17:42.229]                     invisible(muffled)
[16:17:42.229]                   }
[16:17:42.229]                   muffleCondition(cond)
[16:17:42.229]                 })
[16:17:42.229]             }))
[16:17:42.229]             future::FutureResult(value = ...future.value$value, 
[16:17:42.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.229]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.229]                     ...future.globalenv.names))
[16:17:42.229]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.229]         }, condition = base::local({
[16:17:42.229]             c <- base::c
[16:17:42.229]             inherits <- base::inherits
[16:17:42.229]             invokeRestart <- base::invokeRestart
[16:17:42.229]             length <- base::length
[16:17:42.229]             list <- base::list
[16:17:42.229]             seq.int <- base::seq.int
[16:17:42.229]             signalCondition <- base::signalCondition
[16:17:42.229]             sys.calls <- base::sys.calls
[16:17:42.229]             `[[` <- base::`[[`
[16:17:42.229]             `+` <- base::`+`
[16:17:42.229]             `<<-` <- base::`<<-`
[16:17:42.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.229]                   3L)]
[16:17:42.229]             }
[16:17:42.229]             function(cond) {
[16:17:42.229]                 is_error <- inherits(cond, "error")
[16:17:42.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.229]                   NULL)
[16:17:42.229]                 if (is_error) {
[16:17:42.229]                   sessionInformation <- function() {
[16:17:42.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.229]                       search = base::search(), system = base::Sys.info())
[16:17:42.229]                   }
[16:17:42.229]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.229]                     cond$call), session = sessionInformation(), 
[16:17:42.229]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.229]                   signalCondition(cond)
[16:17:42.229]                 }
[16:17:42.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.229]                 "immediateCondition"))) {
[16:17:42.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.229]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.229]                   if (TRUE && !signal) {
[16:17:42.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.229]                     {
[16:17:42.229]                       inherits <- base::inherits
[16:17:42.229]                       invokeRestart <- base::invokeRestart
[16:17:42.229]                       is.null <- base::is.null
[16:17:42.229]                       muffled <- FALSE
[16:17:42.229]                       if (inherits(cond, "message")) {
[16:17:42.229]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.229]                         if (muffled) 
[16:17:42.229]                           invokeRestart("muffleMessage")
[16:17:42.229]                       }
[16:17:42.229]                       else if (inherits(cond, "warning")) {
[16:17:42.229]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.229]                         if (muffled) 
[16:17:42.229]                           invokeRestart("muffleWarning")
[16:17:42.229]                       }
[16:17:42.229]                       else if (inherits(cond, "condition")) {
[16:17:42.229]                         if (!is.null(pattern)) {
[16:17:42.229]                           computeRestarts <- base::computeRestarts
[16:17:42.229]                           grepl <- base::grepl
[16:17:42.229]                           restarts <- computeRestarts(cond)
[16:17:42.229]                           for (restart in restarts) {
[16:17:42.229]                             name <- restart$name
[16:17:42.229]                             if (is.null(name)) 
[16:17:42.229]                               next
[16:17:42.229]                             if (!grepl(pattern, name)) 
[16:17:42.229]                               next
[16:17:42.229]                             invokeRestart(restart)
[16:17:42.229]                             muffled <- TRUE
[16:17:42.229]                             break
[16:17:42.229]                           }
[16:17:42.229]                         }
[16:17:42.229]                       }
[16:17:42.229]                       invisible(muffled)
[16:17:42.229]                     }
[16:17:42.229]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.229]                   }
[16:17:42.229]                 }
[16:17:42.229]                 else {
[16:17:42.229]                   if (TRUE) {
[16:17:42.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.229]                     {
[16:17:42.229]                       inherits <- base::inherits
[16:17:42.229]                       invokeRestart <- base::invokeRestart
[16:17:42.229]                       is.null <- base::is.null
[16:17:42.229]                       muffled <- FALSE
[16:17:42.229]                       if (inherits(cond, "message")) {
[16:17:42.229]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.229]                         if (muffled) 
[16:17:42.229]                           invokeRestart("muffleMessage")
[16:17:42.229]                       }
[16:17:42.229]                       else if (inherits(cond, "warning")) {
[16:17:42.229]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.229]                         if (muffled) 
[16:17:42.229]                           invokeRestart("muffleWarning")
[16:17:42.229]                       }
[16:17:42.229]                       else if (inherits(cond, "condition")) {
[16:17:42.229]                         if (!is.null(pattern)) {
[16:17:42.229]                           computeRestarts <- base::computeRestarts
[16:17:42.229]                           grepl <- base::grepl
[16:17:42.229]                           restarts <- computeRestarts(cond)
[16:17:42.229]                           for (restart in restarts) {
[16:17:42.229]                             name <- restart$name
[16:17:42.229]                             if (is.null(name)) 
[16:17:42.229]                               next
[16:17:42.229]                             if (!grepl(pattern, name)) 
[16:17:42.229]                               next
[16:17:42.229]                             invokeRestart(restart)
[16:17:42.229]                             muffled <- TRUE
[16:17:42.229]                             break
[16:17:42.229]                           }
[16:17:42.229]                         }
[16:17:42.229]                       }
[16:17:42.229]                       invisible(muffled)
[16:17:42.229]                     }
[16:17:42.229]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.229]                   }
[16:17:42.229]                 }
[16:17:42.229]             }
[16:17:42.229]         }))
[16:17:42.229]     }, error = function(ex) {
[16:17:42.229]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.229]                 ...future.rng), started = ...future.startTime, 
[16:17:42.229]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.229]             version = "1.8"), class = "FutureResult")
[16:17:42.229]     }, finally = {
[16:17:42.229]         if (!identical(...future.workdir, getwd())) 
[16:17:42.229]             setwd(...future.workdir)
[16:17:42.229]         {
[16:17:42.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.229]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.229]             }
[16:17:42.229]             base::options(...future.oldOptions)
[16:17:42.229]             if (.Platform$OS.type == "windows") {
[16:17:42.229]                 old_names <- names(...future.oldEnvVars)
[16:17:42.229]                 envs <- base::Sys.getenv()
[16:17:42.229]                 names <- names(envs)
[16:17:42.229]                 common <- intersect(names, old_names)
[16:17:42.229]                 added <- setdiff(names, old_names)
[16:17:42.229]                 removed <- setdiff(old_names, names)
[16:17:42.229]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.229]                   envs[common]]
[16:17:42.229]                 NAMES <- toupper(changed)
[16:17:42.229]                 args <- list()
[16:17:42.229]                 for (kk in seq_along(NAMES)) {
[16:17:42.229]                   name <- changed[[kk]]
[16:17:42.229]                   NAME <- NAMES[[kk]]
[16:17:42.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.229]                     next
[16:17:42.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.229]                 }
[16:17:42.229]                 NAMES <- toupper(added)
[16:17:42.229]                 for (kk in seq_along(NAMES)) {
[16:17:42.229]                   name <- added[[kk]]
[16:17:42.229]                   NAME <- NAMES[[kk]]
[16:17:42.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.229]                     next
[16:17:42.229]                   args[[name]] <- ""
[16:17:42.229]                 }
[16:17:42.229]                 NAMES <- toupper(removed)
[16:17:42.229]                 for (kk in seq_along(NAMES)) {
[16:17:42.229]                   name <- removed[[kk]]
[16:17:42.229]                   NAME <- NAMES[[kk]]
[16:17:42.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.229]                     next
[16:17:42.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.229]                 }
[16:17:42.229]                 if (length(args) > 0) 
[16:17:42.229]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.229]             }
[16:17:42.229]             else {
[16:17:42.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.229]             }
[16:17:42.229]             {
[16:17:42.229]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.229]                   0L) {
[16:17:42.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.229]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.229]                   base::options(opts)
[16:17:42.229]                 }
[16:17:42.229]                 {
[16:17:42.229]                   {
[16:17:42.229]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.229]                     NULL
[16:17:42.229]                   }
[16:17:42.229]                   options(future.plan = NULL)
[16:17:42.229]                   if (is.na(NA_character_)) 
[16:17:42.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.229]                     .init = FALSE)
[16:17:42.229]                 }
[16:17:42.229]             }
[16:17:42.229]         }
[16:17:42.229]     })
[16:17:42.229]     if (TRUE) {
[16:17:42.229]         base::sink(type = "output", split = FALSE)
[16:17:42.229]         if (TRUE) {
[16:17:42.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.229]         }
[16:17:42.229]         else {
[16:17:42.229]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.229]         }
[16:17:42.229]         base::close(...future.stdout)
[16:17:42.229]         ...future.stdout <- NULL
[16:17:42.229]     }
[16:17:42.229]     ...future.result$conditions <- ...future.conditions
[16:17:42.229]     ...future.result$finished <- base::Sys.time()
[16:17:42.229]     ...future.result
[16:17:42.229] }
[16:17:42.233] assign_globals() ...
[16:17:42.233] List of 5
[16:17:42.233]  $ future.call.arguments    : list()
[16:17:42.233]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.233]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:42.233]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:42.233]  $ ...future.elements_ii    :List of 1
[16:17:42.233]   ..$ : num [1:4] 2 4 6 8
[16:17:42.233]  $ ...future.seeds_ii       : NULL
[16:17:42.233]  $ ...future.globals.maxSize: num Inf
[16:17:42.233]  - attr(*, "resolved")= logi FALSE
[16:17:42.233]  - attr(*, "total_size")= num NA
[16:17:42.233]  - attr(*, "where")=List of 5
[16:17:42.233]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.233]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.233]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.233]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.233]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.233]  - attr(*, "already-done")= logi TRUE
[16:17:42.244] - copied ‘future.call.arguments’ to environment
[16:17:42.244] - copied ‘...future.FUN’ to environment
[16:17:42.244] - copied ‘...future.elements_ii’ to environment
[16:17:42.244] - copied ‘...future.seeds_ii’ to environment
[16:17:42.245] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.245] assign_globals() ... done
[16:17:42.245] requestCore(): workers = 2
[16:17:42.247] MulticoreFuture started
[16:17:42.248] - Launch lazy future ... done
[16:17:42.248] run() for ‘MulticoreFuture’ ... done
[16:17:42.248] Created future:
[16:17:42.249] plan(): Setting new future strategy stack:
[16:17:42.249] List of future strategies:
[16:17:42.249] 1. sequential:
[16:17:42.249]    - args: function (..., envir = parent.frame())
[16:17:42.249]    - tweaked: FALSE
[16:17:42.249]    - call: NULL
[16:17:42.250] plan(): nbrOfWorkers() = 1
[16:17:42.253] plan(): Setting new future strategy stack:
[16:17:42.253] List of future strategies:
[16:17:42.253] 1. multicore:
[16:17:42.253]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.253]    - tweaked: FALSE
[16:17:42.253]    - call: plan(strategy)
[16:17:42.258] plan(): nbrOfWorkers() = 2
[16:17:42.249] MulticoreFuture:
[16:17:42.249] Label: ‘future_apply-2’
[16:17:42.249] Expression:
[16:17:42.249] {
[16:17:42.249]     do.call(function(...) {
[16:17:42.249]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.249]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.249]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.249]             on.exit(options(oopts), add = TRUE)
[16:17:42.249]         }
[16:17:42.249]         {
[16:17:42.249]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.249]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.249]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.249]             })
[16:17:42.249]         }
[16:17:42.249]     }, args = future.call.arguments)
[16:17:42.249] }
[16:17:42.249] Lazy evaluation: FALSE
[16:17:42.249] Asynchronous evaluation: TRUE
[16:17:42.249] Local evaluation: TRUE
[16:17:42.249] Environment: R_GlobalEnv
[16:17:42.249] Capture standard output: TRUE
[16:17:42.249] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.249] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.249] Packages: <none>
[16:17:42.249] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.249] Resolved: TRUE
[16:17:42.249] Value: <not collected>
[16:17:42.249] Conditions captured: <none>
[16:17:42.249] Early signaling: FALSE
[16:17:42.249] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.249] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.260] Chunk #2 of 2 ... DONE
[16:17:42.260] Launching 2 futures (chunks) ... DONE
[16:17:42.260] Resolving 2 futures (chunks) ...
[16:17:42.260] resolve() on list ...
[16:17:42.260]  recursive: 0
[16:17:42.260]  length: 2
[16:17:42.261] 
[16:17:42.261] Future #1
[16:17:42.261] result() for MulticoreFuture ...
[16:17:42.262] result() for MulticoreFuture ...
[16:17:42.262] result() for MulticoreFuture ... done
[16:17:42.262] result() for MulticoreFuture ... done
[16:17:42.263] result() for MulticoreFuture ...
[16:17:42.263] result() for MulticoreFuture ... done
[16:17:42.263] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:42.263] - nx: 2
[16:17:42.263] - relay: TRUE
[16:17:42.263] - stdout: TRUE
[16:17:42.264] - signal: TRUE
[16:17:42.264] - resignal: FALSE
[16:17:42.264] - force: TRUE
[16:17:42.264] - relayed: [n=2] FALSE, FALSE
[16:17:42.264] - queued futures: [n=2] FALSE, FALSE
[16:17:42.264]  - until=1
[16:17:42.264]  - relaying element #1
[16:17:42.265] result() for MulticoreFuture ...
[16:17:42.265] result() for MulticoreFuture ... done
[16:17:42.265] result() for MulticoreFuture ...
[16:17:42.265] result() for MulticoreFuture ... done
[16:17:42.265] result() for MulticoreFuture ...
[16:17:42.265] result() for MulticoreFuture ... done
[16:17:42.266] result() for MulticoreFuture ...
[16:17:42.266] result() for MulticoreFuture ... done
[16:17:42.266] - relayed: [n=2] TRUE, FALSE
[16:17:42.266] - queued futures: [n=2] TRUE, FALSE
[16:17:42.266] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:42.266]  length: 1 (resolved future 1)
[16:17:42.267] Future #2
[16:17:42.267] result() for MulticoreFuture ...
[16:17:42.268] result() for MulticoreFuture ...
[16:17:42.268] result() for MulticoreFuture ... done
[16:17:42.268] result() for MulticoreFuture ... done
[16:17:42.268] result() for MulticoreFuture ...
[16:17:42.268] result() for MulticoreFuture ... done
[16:17:42.268] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:42.269] - nx: 2
[16:17:42.269] - relay: TRUE
[16:17:42.269] - stdout: TRUE
[16:17:42.269] - signal: TRUE
[16:17:42.269] - resignal: FALSE
[16:17:42.269] - force: TRUE
[16:17:42.269] - relayed: [n=2] TRUE, FALSE
[16:17:42.269] - queued futures: [n=2] TRUE, FALSE
[16:17:42.270]  - until=2
[16:17:42.270]  - relaying element #2
[16:17:42.270] result() for MulticoreFuture ...
[16:17:42.270] result() for MulticoreFuture ... done
[16:17:42.270] result() for MulticoreFuture ...
[16:17:42.270] result() for MulticoreFuture ... done
[16:17:42.270] result() for MulticoreFuture ...
[16:17:42.270] result() for MulticoreFuture ... done
[16:17:42.271] result() for MulticoreFuture ...
[16:17:42.271] result() for MulticoreFuture ... done
[16:17:42.271] - relayed: [n=2] TRUE, TRUE
[16:17:42.271] - queued futures: [n=2] TRUE, TRUE
[16:17:42.271] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:42.271]  length: 0 (resolved future 2)
[16:17:42.271] Relaying remaining futures
[16:17:42.271] signalConditionsASAP(NULL, pos=0) ...
[16:17:42.271] - nx: 2
[16:17:42.272] - relay: TRUE
[16:17:42.272] - stdout: TRUE
[16:17:42.272] - signal: TRUE
[16:17:42.272] - resignal: FALSE
[16:17:42.272] - force: TRUE
[16:17:42.272] - relayed: [n=2] TRUE, TRUE
[16:17:42.272] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:42.273] - relayed: [n=2] TRUE, TRUE
[16:17:42.273] - queued futures: [n=2] TRUE, TRUE
[16:17:42.273] signalConditionsASAP(NULL, pos=0) ... done
[16:17:42.273] resolve() on list ... DONE
[16:17:42.273] result() for MulticoreFuture ...
[16:17:42.273] result() for MulticoreFuture ... done
[16:17:42.273] result() for MulticoreFuture ...
[16:17:42.273] result() for MulticoreFuture ... done
[16:17:42.273] result() for MulticoreFuture ...
[16:17:42.274] result() for MulticoreFuture ... done
[16:17:42.274] result() for MulticoreFuture ...
[16:17:42.274] result() for MulticoreFuture ... done
[16:17:42.274]  - Number of value chunks collected: 2
[16:17:42.274] Resolving 2 futures (chunks) ... DONE
[16:17:42.274] Reducing values from 2 chunks ...
[16:17:42.274]  - Number of values collected after concatenation: 2
[16:17:42.274]  - Number of values expected: 2
[16:17:42.274] Reducing values from 2 chunks ... DONE
[16:17:42.275] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:17:42.276] getGlobalsAndPackagesXApply() ...
[16:17:42.276]  - future.globals: TRUE
[16:17:42.276] getGlobalsAndPackages() ...
[16:17:42.276] Searching for globals...
[16:17:42.277] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:42.278] Searching for globals ... DONE
[16:17:42.278] Resolving globals: FALSE
[16:17:42.278] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:42.279] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:42.279] - globals: [1] ‘FUN’
[16:17:42.279] - packages: [1] ‘stats’
[16:17:42.279] getGlobalsAndPackages() ... DONE
[16:17:42.279]  - globals found/used: [n=1] ‘FUN’
[16:17:42.279]  - needed namespaces: [n=1] ‘stats’
[16:17:42.279] Finding globals ... DONE
[16:17:42.279]  - use_args: TRUE
[16:17:42.280]  - Getting '...' globals ...
[16:17:42.280] resolve() on list ...
[16:17:42.280]  recursive: 0
[16:17:42.280]  length: 1
[16:17:42.280]  elements: ‘...’
[16:17:42.280]  length: 0 (resolved future 1)
[16:17:42.281] resolve() on list ... DONE
[16:17:42.281]    - '...' content: [n=0] 
[16:17:42.281] List of 1
[16:17:42.281]  $ ...: list()
[16:17:42.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.281]  - attr(*, "where")=List of 1
[16:17:42.281]   ..$ ...:<environment: 0x555be25030c8> 
[16:17:42.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.281]  - attr(*, "resolved")= logi TRUE
[16:17:42.281]  - attr(*, "total_size")= num NA
[16:17:42.288]  - Getting '...' globals ... DONE
[16:17:42.288] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:42.288] List of 2
[16:17:42.288]  $ ...future.FUN:function (x, ...)  
[16:17:42.288]  $ ...          : list()
[16:17:42.288]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.288]  - attr(*, "where")=List of 2
[16:17:42.288]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:42.288]   ..$ ...          :<environment: 0x555be25030c8> 
[16:17:42.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.288]  - attr(*, "resolved")= logi FALSE
[16:17:42.288]  - attr(*, "total_size")= num 1248
[16:17:42.291] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:42.291] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.295] future_lapply() ...
[16:17:42.298] Number of chunks: 2
[16:17:42.299] getGlobalsAndPackagesXApply() ...
[16:17:42.299]  - future.globals: <name-value list> with names ‘list()’
[16:17:42.299]  - use_args: TRUE
[16:17:42.299] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:42.299] List of 2
[16:17:42.299]  $ ...          : list()
[16:17:42.299]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.299]  $ ...future.FUN:function (x, ...)  
[16:17:42.299]  - attr(*, "where")=List of 2
[16:17:42.299]   ..$ ...          :<environment: 0x555be25030c8> 
[16:17:42.299]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:17:42.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.299]  - attr(*, "resolved")= logi FALSE
[16:17:42.299]  - attr(*, "total_size")= num NA
[16:17:42.302] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:42.302] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.302] Number of futures (= number of chunks): 2
[16:17:42.302] Launching 2 futures (chunks) ...
[16:17:42.302] Chunk #1 of 2 ...
[16:17:42.302]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.303]  - seeds: <none>
[16:17:42.303]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.303] getGlobalsAndPackages() ...
[16:17:42.303] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.303] Resolving globals: FALSE
[16:17:42.303] Tweak future expression to call with '...' arguments ...
[16:17:42.303] {
[16:17:42.303]     do.call(function(...) {
[16:17:42.303]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.303]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.303]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.303]             on.exit(options(oopts), add = TRUE)
[16:17:42.303]         }
[16:17:42.303]         {
[16:17:42.303]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.303]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.303]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.303]             })
[16:17:42.303]         }
[16:17:42.303]     }, args = future.call.arguments)
[16:17:42.303] }
[16:17:42.303] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.304] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.304] - packages: [1] ‘stats’
[16:17:42.304] getGlobalsAndPackages() ... DONE
[16:17:42.304] run() for ‘Future’ ...
[16:17:42.305] - state: ‘created’
[16:17:42.305] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.308] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.308]   - Field: ‘label’
[16:17:42.308]   - Field: ‘local’
[16:17:42.309]   - Field: ‘owner’
[16:17:42.309]   - Field: ‘envir’
[16:17:42.309]   - Field: ‘workers’
[16:17:42.309]   - Field: ‘packages’
[16:17:42.309]   - Field: ‘gc’
[16:17:42.309]   - Field: ‘job’
[16:17:42.309]   - Field: ‘conditions’
[16:17:42.309]   - Field: ‘expr’
[16:17:42.309]   - Field: ‘uuid’
[16:17:42.309]   - Field: ‘seed’
[16:17:42.309]   - Field: ‘version’
[16:17:42.310]   - Field: ‘result’
[16:17:42.310]   - Field: ‘asynchronous’
[16:17:42.310]   - Field: ‘calls’
[16:17:42.310]   - Field: ‘globals’
[16:17:42.310]   - Field: ‘stdout’
[16:17:42.310]   - Field: ‘earlySignal’
[16:17:42.310]   - Field: ‘lazy’
[16:17:42.310]   - Field: ‘state’
[16:17:42.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.310] - Launch lazy future ...
[16:17:42.311] Packages needed by the future expression (n = 1): ‘stats’
[16:17:42.311] Packages needed by future strategies (n = 0): <none>
[16:17:42.311] {
[16:17:42.311]     {
[16:17:42.311]         {
[16:17:42.311]             ...future.startTime <- base::Sys.time()
[16:17:42.311]             {
[16:17:42.311]                 {
[16:17:42.311]                   {
[16:17:42.311]                     {
[16:17:42.311]                       {
[16:17:42.311]                         base::local({
[16:17:42.311]                           has_future <- base::requireNamespace("future", 
[16:17:42.311]                             quietly = TRUE)
[16:17:42.311]                           if (has_future) {
[16:17:42.311]                             ns <- base::getNamespace("future")
[16:17:42.311]                             version <- ns[[".package"]][["version"]]
[16:17:42.311]                             if (is.null(version)) 
[16:17:42.311]                               version <- utils::packageVersion("future")
[16:17:42.311]                           }
[16:17:42.311]                           else {
[16:17:42.311]                             version <- NULL
[16:17:42.311]                           }
[16:17:42.311]                           if (!has_future || version < "1.8.0") {
[16:17:42.311]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.311]                               "", base::R.version$version.string), 
[16:17:42.311]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:42.311]                                 base::R.version$platform, 8 * 
[16:17:42.311]                                   base::.Machine$sizeof.pointer), 
[16:17:42.311]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.311]                                 "release", "version")], collapse = " "), 
[16:17:42.311]                               hostname = base::Sys.info()[["nodename"]])
[16:17:42.311]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.311]                               info)
[16:17:42.311]                             info <- base::paste(info, collapse = "; ")
[16:17:42.311]                             if (!has_future) {
[16:17:42.311]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.311]                                 info)
[16:17:42.311]                             }
[16:17:42.311]                             else {
[16:17:42.311]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.311]                                 info, version)
[16:17:42.311]                             }
[16:17:42.311]                             base::stop(msg)
[16:17:42.311]                           }
[16:17:42.311]                         })
[16:17:42.311]                       }
[16:17:42.311]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.311]                       base::options(mc.cores = 1L)
[16:17:42.311]                     }
[16:17:42.311]                     base::local({
[16:17:42.311]                       for (pkg in "stats") {
[16:17:42.311]                         base::loadNamespace(pkg)
[16:17:42.311]                         base::library(pkg, character.only = TRUE)
[16:17:42.311]                       }
[16:17:42.311]                     })
[16:17:42.311]                   }
[16:17:42.311]                   ...future.strategy.old <- future::plan("list")
[16:17:42.311]                   options(future.plan = NULL)
[16:17:42.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.311]                 }
[16:17:42.311]                 ...future.workdir <- getwd()
[16:17:42.311]             }
[16:17:42.311]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.311]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.311]         }
[16:17:42.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.311]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.311]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.311]             base::names(...future.oldOptions))
[16:17:42.311]     }
[16:17:42.311]     if (FALSE) {
[16:17:42.311]     }
[16:17:42.311]     else {
[16:17:42.311]         if (TRUE) {
[16:17:42.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.311]                 open = "w")
[16:17:42.311]         }
[16:17:42.311]         else {
[16:17:42.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.311]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.311]         }
[16:17:42.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.311]             base::sink(type = "output", split = FALSE)
[16:17:42.311]             base::close(...future.stdout)
[16:17:42.311]         }, add = TRUE)
[16:17:42.311]     }
[16:17:42.311]     ...future.frame <- base::sys.nframe()
[16:17:42.311]     ...future.conditions <- base::list()
[16:17:42.311]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.311]     if (FALSE) {
[16:17:42.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.311]     }
[16:17:42.311]     ...future.result <- base::tryCatch({
[16:17:42.311]         base::withCallingHandlers({
[16:17:42.311]             ...future.value <- base::withVisible(base::local({
[16:17:42.311]                 withCallingHandlers({
[16:17:42.311]                   {
[16:17:42.311]                     do.call(function(...) {
[16:17:42.311]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.311]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.311]                         ...future.globals.maxSize)) {
[16:17:42.311]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.311]                         on.exit(options(oopts), add = TRUE)
[16:17:42.311]                       }
[16:17:42.311]                       {
[16:17:42.311]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.311]                           FUN = function(jj) {
[16:17:42.311]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.311]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.311]                           })
[16:17:42.311]                       }
[16:17:42.311]                     }, args = future.call.arguments)
[16:17:42.311]                   }
[16:17:42.311]                 }, immediateCondition = function(cond) {
[16:17:42.311]                   save_rds <- function (object, pathname, ...) 
[16:17:42.311]                   {
[16:17:42.311]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.311]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.311]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.311]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.311]                         fi_tmp[["mtime"]])
[16:17:42.311]                     }
[16:17:42.311]                     tryCatch({
[16:17:42.311]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.311]                     }, error = function(ex) {
[16:17:42.311]                       msg <- conditionMessage(ex)
[16:17:42.311]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.311]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.311]                         fi_tmp[["mtime"]], msg)
[16:17:42.311]                       ex$message <- msg
[16:17:42.311]                       stop(ex)
[16:17:42.311]                     })
[16:17:42.311]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.311]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.311]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.311]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.311]                       fi <- file.info(pathname)
[16:17:42.311]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.311]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.311]                         fi[["size"]], fi[["mtime"]])
[16:17:42.311]                       stop(msg)
[16:17:42.311]                     }
[16:17:42.311]                     invisible(pathname)
[16:17:42.311]                   }
[16:17:42.311]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.311]                     rootPath = tempdir()) 
[16:17:42.311]                   {
[16:17:42.311]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.311]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.311]                       tmpdir = path, fileext = ".rds")
[16:17:42.311]                     save_rds(obj, file)
[16:17:42.311]                   }
[16:17:42.311]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.311]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.311]                   {
[16:17:42.311]                     inherits <- base::inherits
[16:17:42.311]                     invokeRestart <- base::invokeRestart
[16:17:42.311]                     is.null <- base::is.null
[16:17:42.311]                     muffled <- FALSE
[16:17:42.311]                     if (inherits(cond, "message")) {
[16:17:42.311]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.311]                       if (muffled) 
[16:17:42.311]                         invokeRestart("muffleMessage")
[16:17:42.311]                     }
[16:17:42.311]                     else if (inherits(cond, "warning")) {
[16:17:42.311]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.311]                       if (muffled) 
[16:17:42.311]                         invokeRestart("muffleWarning")
[16:17:42.311]                     }
[16:17:42.311]                     else if (inherits(cond, "condition")) {
[16:17:42.311]                       if (!is.null(pattern)) {
[16:17:42.311]                         computeRestarts <- base::computeRestarts
[16:17:42.311]                         grepl <- base::grepl
[16:17:42.311]                         restarts <- computeRestarts(cond)
[16:17:42.311]                         for (restart in restarts) {
[16:17:42.311]                           name <- restart$name
[16:17:42.311]                           if (is.null(name)) 
[16:17:42.311]                             next
[16:17:42.311]                           if (!grepl(pattern, name)) 
[16:17:42.311]                             next
[16:17:42.311]                           invokeRestart(restart)
[16:17:42.311]                           muffled <- TRUE
[16:17:42.311]                           break
[16:17:42.311]                         }
[16:17:42.311]                       }
[16:17:42.311]                     }
[16:17:42.311]                     invisible(muffled)
[16:17:42.311]                   }
[16:17:42.311]                   muffleCondition(cond)
[16:17:42.311]                 })
[16:17:42.311]             }))
[16:17:42.311]             future::FutureResult(value = ...future.value$value, 
[16:17:42.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.311]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.311]                     ...future.globalenv.names))
[16:17:42.311]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.311]         }, condition = base::local({
[16:17:42.311]             c <- base::c
[16:17:42.311]             inherits <- base::inherits
[16:17:42.311]             invokeRestart <- base::invokeRestart
[16:17:42.311]             length <- base::length
[16:17:42.311]             list <- base::list
[16:17:42.311]             seq.int <- base::seq.int
[16:17:42.311]             signalCondition <- base::signalCondition
[16:17:42.311]             sys.calls <- base::sys.calls
[16:17:42.311]             `[[` <- base::`[[`
[16:17:42.311]             `+` <- base::`+`
[16:17:42.311]             `<<-` <- base::`<<-`
[16:17:42.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.311]                   3L)]
[16:17:42.311]             }
[16:17:42.311]             function(cond) {
[16:17:42.311]                 is_error <- inherits(cond, "error")
[16:17:42.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.311]                   NULL)
[16:17:42.311]                 if (is_error) {
[16:17:42.311]                   sessionInformation <- function() {
[16:17:42.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.311]                       search = base::search(), system = base::Sys.info())
[16:17:42.311]                   }
[16:17:42.311]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.311]                     cond$call), session = sessionInformation(), 
[16:17:42.311]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.311]                   signalCondition(cond)
[16:17:42.311]                 }
[16:17:42.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.311]                 "immediateCondition"))) {
[16:17:42.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.311]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.311]                   if (TRUE && !signal) {
[16:17:42.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.311]                     {
[16:17:42.311]                       inherits <- base::inherits
[16:17:42.311]                       invokeRestart <- base::invokeRestart
[16:17:42.311]                       is.null <- base::is.null
[16:17:42.311]                       muffled <- FALSE
[16:17:42.311]                       if (inherits(cond, "message")) {
[16:17:42.311]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.311]                         if (muffled) 
[16:17:42.311]                           invokeRestart("muffleMessage")
[16:17:42.311]                       }
[16:17:42.311]                       else if (inherits(cond, "warning")) {
[16:17:42.311]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.311]                         if (muffled) 
[16:17:42.311]                           invokeRestart("muffleWarning")
[16:17:42.311]                       }
[16:17:42.311]                       else if (inherits(cond, "condition")) {
[16:17:42.311]                         if (!is.null(pattern)) {
[16:17:42.311]                           computeRestarts <- base::computeRestarts
[16:17:42.311]                           grepl <- base::grepl
[16:17:42.311]                           restarts <- computeRestarts(cond)
[16:17:42.311]                           for (restart in restarts) {
[16:17:42.311]                             name <- restart$name
[16:17:42.311]                             if (is.null(name)) 
[16:17:42.311]                               next
[16:17:42.311]                             if (!grepl(pattern, name)) 
[16:17:42.311]                               next
[16:17:42.311]                             invokeRestart(restart)
[16:17:42.311]                             muffled <- TRUE
[16:17:42.311]                             break
[16:17:42.311]                           }
[16:17:42.311]                         }
[16:17:42.311]                       }
[16:17:42.311]                       invisible(muffled)
[16:17:42.311]                     }
[16:17:42.311]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.311]                   }
[16:17:42.311]                 }
[16:17:42.311]                 else {
[16:17:42.311]                   if (TRUE) {
[16:17:42.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.311]                     {
[16:17:42.311]                       inherits <- base::inherits
[16:17:42.311]                       invokeRestart <- base::invokeRestart
[16:17:42.311]                       is.null <- base::is.null
[16:17:42.311]                       muffled <- FALSE
[16:17:42.311]                       if (inherits(cond, "message")) {
[16:17:42.311]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.311]                         if (muffled) 
[16:17:42.311]                           invokeRestart("muffleMessage")
[16:17:42.311]                       }
[16:17:42.311]                       else if (inherits(cond, "warning")) {
[16:17:42.311]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.311]                         if (muffled) 
[16:17:42.311]                           invokeRestart("muffleWarning")
[16:17:42.311]                       }
[16:17:42.311]                       else if (inherits(cond, "condition")) {
[16:17:42.311]                         if (!is.null(pattern)) {
[16:17:42.311]                           computeRestarts <- base::computeRestarts
[16:17:42.311]                           grepl <- base::grepl
[16:17:42.311]                           restarts <- computeRestarts(cond)
[16:17:42.311]                           for (restart in restarts) {
[16:17:42.311]                             name <- restart$name
[16:17:42.311]                             if (is.null(name)) 
[16:17:42.311]                               next
[16:17:42.311]                             if (!grepl(pattern, name)) 
[16:17:42.311]                               next
[16:17:42.311]                             invokeRestart(restart)
[16:17:42.311]                             muffled <- TRUE
[16:17:42.311]                             break
[16:17:42.311]                           }
[16:17:42.311]                         }
[16:17:42.311]                       }
[16:17:42.311]                       invisible(muffled)
[16:17:42.311]                     }
[16:17:42.311]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.311]                   }
[16:17:42.311]                 }
[16:17:42.311]             }
[16:17:42.311]         }))
[16:17:42.311]     }, error = function(ex) {
[16:17:42.311]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.311]                 ...future.rng), started = ...future.startTime, 
[16:17:42.311]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.311]             version = "1.8"), class = "FutureResult")
[16:17:42.311]     }, finally = {
[16:17:42.311]         if (!identical(...future.workdir, getwd())) 
[16:17:42.311]             setwd(...future.workdir)
[16:17:42.311]         {
[16:17:42.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.311]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.311]             }
[16:17:42.311]             base::options(...future.oldOptions)
[16:17:42.311]             if (.Platform$OS.type == "windows") {
[16:17:42.311]                 old_names <- names(...future.oldEnvVars)
[16:17:42.311]                 envs <- base::Sys.getenv()
[16:17:42.311]                 names <- names(envs)
[16:17:42.311]                 common <- intersect(names, old_names)
[16:17:42.311]                 added <- setdiff(names, old_names)
[16:17:42.311]                 removed <- setdiff(old_names, names)
[16:17:42.311]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.311]                   envs[common]]
[16:17:42.311]                 NAMES <- toupper(changed)
[16:17:42.311]                 args <- list()
[16:17:42.311]                 for (kk in seq_along(NAMES)) {
[16:17:42.311]                   name <- changed[[kk]]
[16:17:42.311]                   NAME <- NAMES[[kk]]
[16:17:42.311]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.311]                     next
[16:17:42.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.311]                 }
[16:17:42.311]                 NAMES <- toupper(added)
[16:17:42.311]                 for (kk in seq_along(NAMES)) {
[16:17:42.311]                   name <- added[[kk]]
[16:17:42.311]                   NAME <- NAMES[[kk]]
[16:17:42.311]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.311]                     next
[16:17:42.311]                   args[[name]] <- ""
[16:17:42.311]                 }
[16:17:42.311]                 NAMES <- toupper(removed)
[16:17:42.311]                 for (kk in seq_along(NAMES)) {
[16:17:42.311]                   name <- removed[[kk]]
[16:17:42.311]                   NAME <- NAMES[[kk]]
[16:17:42.311]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.311]                     next
[16:17:42.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.311]                 }
[16:17:42.311]                 if (length(args) > 0) 
[16:17:42.311]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.311]             }
[16:17:42.311]             else {
[16:17:42.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.311]             }
[16:17:42.311]             {
[16:17:42.311]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.311]                   0L) {
[16:17:42.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.311]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.311]                   base::options(opts)
[16:17:42.311]                 }
[16:17:42.311]                 {
[16:17:42.311]                   {
[16:17:42.311]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.311]                     NULL
[16:17:42.311]                   }
[16:17:42.311]                   options(future.plan = NULL)
[16:17:42.311]                   if (is.na(NA_character_)) 
[16:17:42.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.311]                     .init = FALSE)
[16:17:42.311]                 }
[16:17:42.311]             }
[16:17:42.311]         }
[16:17:42.311]     })
[16:17:42.311]     if (TRUE) {
[16:17:42.311]         base::sink(type = "output", split = FALSE)
[16:17:42.311]         if (TRUE) {
[16:17:42.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.311]         }
[16:17:42.311]         else {
[16:17:42.311]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.311]         }
[16:17:42.311]         base::close(...future.stdout)
[16:17:42.311]         ...future.stdout <- NULL
[16:17:42.311]     }
[16:17:42.311]     ...future.result$conditions <- ...future.conditions
[16:17:42.311]     ...future.result$finished <- base::Sys.time()
[16:17:42.311]     ...future.result
[16:17:42.311] }
[16:17:42.314] assign_globals() ...
[16:17:42.314] List of 5
[16:17:42.314]  $ future.call.arguments    : list()
[16:17:42.314]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.314]  $ ...future.FUN            :function (x, ...)  
[16:17:42.314]  $ ...future.elements_ii    :List of 1
[16:17:42.314]   ..$ : num [1:4] 1 3 1 7
[16:17:42.314]  $ ...future.seeds_ii       : NULL
[16:17:42.314]  $ ...future.globals.maxSize: num Inf
[16:17:42.314]  - attr(*, "resolved")= logi FALSE
[16:17:42.314]  - attr(*, "total_size")= num NA
[16:17:42.314]  - attr(*, "where")=List of 5
[16:17:42.314]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.314]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.314]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.314]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.314]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.314]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.314]  - attr(*, "already-done")= logi TRUE
[16:17:42.320] - copied ‘future.call.arguments’ to environment
[16:17:42.320] - copied ‘...future.FUN’ to environment
[16:17:42.320] - copied ‘...future.elements_ii’ to environment
[16:17:42.320] - copied ‘...future.seeds_ii’ to environment
[16:17:42.320] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.320] assign_globals() ... done
[16:17:42.321] requestCore(): workers = 2
[16:17:42.323] MulticoreFuture started
[16:17:42.323] - Launch lazy future ... done
[16:17:42.323] run() for ‘MulticoreFuture’ ... done
[16:17:42.324] Created future:
[16:17:42.324] plan(): Setting new future strategy stack:
[16:17:42.325] List of future strategies:
[16:17:42.325] 1. sequential:
[16:17:42.325]    - args: function (..., envir = parent.frame())
[16:17:42.325]    - tweaked: FALSE
[16:17:42.325]    - call: NULL
[16:17:42.325] plan(): nbrOfWorkers() = 1
[16:17:42.328] plan(): Setting new future strategy stack:
[16:17:42.329] List of future strategies:
[16:17:42.329] 1. multicore:
[16:17:42.329]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.329]    - tweaked: FALSE
[16:17:42.329]    - call: plan(strategy)
[16:17:42.334] plan(): nbrOfWorkers() = 2
[16:17:42.324] MulticoreFuture:
[16:17:42.324] Label: ‘future_apply-1’
[16:17:42.324] Expression:
[16:17:42.324] {
[16:17:42.324]     do.call(function(...) {
[16:17:42.324]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.324]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.324]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.324]             on.exit(options(oopts), add = TRUE)
[16:17:42.324]         }
[16:17:42.324]         {
[16:17:42.324]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.324]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.324]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.324]             })
[16:17:42.324]         }
[16:17:42.324]     }, args = future.call.arguments)
[16:17:42.324] }
[16:17:42.324] Lazy evaluation: FALSE
[16:17:42.324] Asynchronous evaluation: TRUE
[16:17:42.324] Local evaluation: TRUE
[16:17:42.324] Environment: R_GlobalEnv
[16:17:42.324] Capture standard output: TRUE
[16:17:42.324] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.324] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.324] Packages: 1 packages (‘stats’)
[16:17:42.324] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.324] Resolved: TRUE
[16:17:42.324] Value: <not collected>
[16:17:42.324] Conditions captured: <none>
[16:17:42.324] Early signaling: FALSE
[16:17:42.324] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.324] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.335] Chunk #1 of 2 ... DONE
[16:17:42.335] Chunk #2 of 2 ...
[16:17:42.335]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.335]  - seeds: <none>
[16:17:42.335]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.336] getGlobalsAndPackages() ...
[16:17:42.336] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.336] Resolving globals: FALSE
[16:17:42.336] Tweak future expression to call with '...' arguments ...
[16:17:42.336] {
[16:17:42.336]     do.call(function(...) {
[16:17:42.336]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.336]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.336]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.336]             on.exit(options(oopts), add = TRUE)
[16:17:42.336]         }
[16:17:42.336]         {
[16:17:42.336]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.336]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.336]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.336]             })
[16:17:42.336]         }
[16:17:42.336]     }, args = future.call.arguments)
[16:17:42.336] }
[16:17:42.337] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.338] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.338] - packages: [1] ‘stats’
[16:17:42.338] getGlobalsAndPackages() ... DONE
[16:17:42.338] run() for ‘Future’ ...
[16:17:42.339] - state: ‘created’
[16:17:42.339] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.343] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.344] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.344]   - Field: ‘label’
[16:17:42.344]   - Field: ‘local’
[16:17:42.344]   - Field: ‘owner’
[16:17:42.344]   - Field: ‘envir’
[16:17:42.344]   - Field: ‘workers’
[16:17:42.345]   - Field: ‘packages’
[16:17:42.345]   - Field: ‘gc’
[16:17:42.345]   - Field: ‘job’
[16:17:42.345]   - Field: ‘conditions’
[16:17:42.345]   - Field: ‘expr’
[16:17:42.345]   - Field: ‘uuid’
[16:17:42.345]   - Field: ‘seed’
[16:17:42.346]   - Field: ‘version’
[16:17:42.346]   - Field: ‘result’
[16:17:42.346]   - Field: ‘asynchronous’
[16:17:42.346]   - Field: ‘calls’
[16:17:42.346]   - Field: ‘globals’
[16:17:42.346]   - Field: ‘stdout’
[16:17:42.346]   - Field: ‘earlySignal’
[16:17:42.347]   - Field: ‘lazy’
[16:17:42.347]   - Field: ‘state’
[16:17:42.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.347] - Launch lazy future ...
[16:17:42.347] Packages needed by the future expression (n = 1): ‘stats’
[16:17:42.348] Packages needed by future strategies (n = 0): <none>
[16:17:42.348] {
[16:17:42.348]     {
[16:17:42.348]         {
[16:17:42.348]             ...future.startTime <- base::Sys.time()
[16:17:42.348]             {
[16:17:42.348]                 {
[16:17:42.348]                   {
[16:17:42.348]                     {
[16:17:42.348]                       {
[16:17:42.348]                         base::local({
[16:17:42.348]                           has_future <- base::requireNamespace("future", 
[16:17:42.348]                             quietly = TRUE)
[16:17:42.348]                           if (has_future) {
[16:17:42.348]                             ns <- base::getNamespace("future")
[16:17:42.348]                             version <- ns[[".package"]][["version"]]
[16:17:42.348]                             if (is.null(version)) 
[16:17:42.348]                               version <- utils::packageVersion("future")
[16:17:42.348]                           }
[16:17:42.348]                           else {
[16:17:42.348]                             version <- NULL
[16:17:42.348]                           }
[16:17:42.348]                           if (!has_future || version < "1.8.0") {
[16:17:42.348]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.348]                               "", base::R.version$version.string), 
[16:17:42.348]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:42.348]                                 base::R.version$platform, 8 * 
[16:17:42.348]                                   base::.Machine$sizeof.pointer), 
[16:17:42.348]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.348]                                 "release", "version")], collapse = " "), 
[16:17:42.348]                               hostname = base::Sys.info()[["nodename"]])
[16:17:42.348]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.348]                               info)
[16:17:42.348]                             info <- base::paste(info, collapse = "; ")
[16:17:42.348]                             if (!has_future) {
[16:17:42.348]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.348]                                 info)
[16:17:42.348]                             }
[16:17:42.348]                             else {
[16:17:42.348]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.348]                                 info, version)
[16:17:42.348]                             }
[16:17:42.348]                             base::stop(msg)
[16:17:42.348]                           }
[16:17:42.348]                         })
[16:17:42.348]                       }
[16:17:42.348]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.348]                       base::options(mc.cores = 1L)
[16:17:42.348]                     }
[16:17:42.348]                     base::local({
[16:17:42.348]                       for (pkg in "stats") {
[16:17:42.348]                         base::loadNamespace(pkg)
[16:17:42.348]                         base::library(pkg, character.only = TRUE)
[16:17:42.348]                       }
[16:17:42.348]                     })
[16:17:42.348]                   }
[16:17:42.348]                   ...future.strategy.old <- future::plan("list")
[16:17:42.348]                   options(future.plan = NULL)
[16:17:42.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.348]                 }
[16:17:42.348]                 ...future.workdir <- getwd()
[16:17:42.348]             }
[16:17:42.348]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.348]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.348]         }
[16:17:42.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.348]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.348]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.348]             base::names(...future.oldOptions))
[16:17:42.348]     }
[16:17:42.348]     if (FALSE) {
[16:17:42.348]     }
[16:17:42.348]     else {
[16:17:42.348]         if (TRUE) {
[16:17:42.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.348]                 open = "w")
[16:17:42.348]         }
[16:17:42.348]         else {
[16:17:42.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.348]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.348]         }
[16:17:42.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.348]             base::sink(type = "output", split = FALSE)
[16:17:42.348]             base::close(...future.stdout)
[16:17:42.348]         }, add = TRUE)
[16:17:42.348]     }
[16:17:42.348]     ...future.frame <- base::sys.nframe()
[16:17:42.348]     ...future.conditions <- base::list()
[16:17:42.348]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.348]     if (FALSE) {
[16:17:42.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.348]     }
[16:17:42.348]     ...future.result <- base::tryCatch({
[16:17:42.348]         base::withCallingHandlers({
[16:17:42.348]             ...future.value <- base::withVisible(base::local({
[16:17:42.348]                 withCallingHandlers({
[16:17:42.348]                   {
[16:17:42.348]                     do.call(function(...) {
[16:17:42.348]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.348]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.348]                         ...future.globals.maxSize)) {
[16:17:42.348]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.348]                         on.exit(options(oopts), add = TRUE)
[16:17:42.348]                       }
[16:17:42.348]                       {
[16:17:42.348]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.348]                           FUN = function(jj) {
[16:17:42.348]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.348]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.348]                           })
[16:17:42.348]                       }
[16:17:42.348]                     }, args = future.call.arguments)
[16:17:42.348]                   }
[16:17:42.348]                 }, immediateCondition = function(cond) {
[16:17:42.348]                   save_rds <- function (object, pathname, ...) 
[16:17:42.348]                   {
[16:17:42.348]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.348]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.348]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.348]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.348]                         fi_tmp[["mtime"]])
[16:17:42.348]                     }
[16:17:42.348]                     tryCatch({
[16:17:42.348]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.348]                     }, error = function(ex) {
[16:17:42.348]                       msg <- conditionMessage(ex)
[16:17:42.348]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.348]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.348]                         fi_tmp[["mtime"]], msg)
[16:17:42.348]                       ex$message <- msg
[16:17:42.348]                       stop(ex)
[16:17:42.348]                     })
[16:17:42.348]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.348]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.348]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.348]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.348]                       fi <- file.info(pathname)
[16:17:42.348]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.348]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.348]                         fi[["size"]], fi[["mtime"]])
[16:17:42.348]                       stop(msg)
[16:17:42.348]                     }
[16:17:42.348]                     invisible(pathname)
[16:17:42.348]                   }
[16:17:42.348]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.348]                     rootPath = tempdir()) 
[16:17:42.348]                   {
[16:17:42.348]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.348]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.348]                       tmpdir = path, fileext = ".rds")
[16:17:42.348]                     save_rds(obj, file)
[16:17:42.348]                   }
[16:17:42.348]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.348]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.348]                   {
[16:17:42.348]                     inherits <- base::inherits
[16:17:42.348]                     invokeRestart <- base::invokeRestart
[16:17:42.348]                     is.null <- base::is.null
[16:17:42.348]                     muffled <- FALSE
[16:17:42.348]                     if (inherits(cond, "message")) {
[16:17:42.348]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.348]                       if (muffled) 
[16:17:42.348]                         invokeRestart("muffleMessage")
[16:17:42.348]                     }
[16:17:42.348]                     else if (inherits(cond, "warning")) {
[16:17:42.348]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.348]                       if (muffled) 
[16:17:42.348]                         invokeRestart("muffleWarning")
[16:17:42.348]                     }
[16:17:42.348]                     else if (inherits(cond, "condition")) {
[16:17:42.348]                       if (!is.null(pattern)) {
[16:17:42.348]                         computeRestarts <- base::computeRestarts
[16:17:42.348]                         grepl <- base::grepl
[16:17:42.348]                         restarts <- computeRestarts(cond)
[16:17:42.348]                         for (restart in restarts) {
[16:17:42.348]                           name <- restart$name
[16:17:42.348]                           if (is.null(name)) 
[16:17:42.348]                             next
[16:17:42.348]                           if (!grepl(pattern, name)) 
[16:17:42.348]                             next
[16:17:42.348]                           invokeRestart(restart)
[16:17:42.348]                           muffled <- TRUE
[16:17:42.348]                           break
[16:17:42.348]                         }
[16:17:42.348]                       }
[16:17:42.348]                     }
[16:17:42.348]                     invisible(muffled)
[16:17:42.348]                   }
[16:17:42.348]                   muffleCondition(cond)
[16:17:42.348]                 })
[16:17:42.348]             }))
[16:17:42.348]             future::FutureResult(value = ...future.value$value, 
[16:17:42.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.348]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.348]                     ...future.globalenv.names))
[16:17:42.348]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.348]         }, condition = base::local({
[16:17:42.348]             c <- base::c
[16:17:42.348]             inherits <- base::inherits
[16:17:42.348]             invokeRestart <- base::invokeRestart
[16:17:42.348]             length <- base::length
[16:17:42.348]             list <- base::list
[16:17:42.348]             seq.int <- base::seq.int
[16:17:42.348]             signalCondition <- base::signalCondition
[16:17:42.348]             sys.calls <- base::sys.calls
[16:17:42.348]             `[[` <- base::`[[`
[16:17:42.348]             `+` <- base::`+`
[16:17:42.348]             `<<-` <- base::`<<-`
[16:17:42.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.348]                   3L)]
[16:17:42.348]             }
[16:17:42.348]             function(cond) {
[16:17:42.348]                 is_error <- inherits(cond, "error")
[16:17:42.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.348]                   NULL)
[16:17:42.348]                 if (is_error) {
[16:17:42.348]                   sessionInformation <- function() {
[16:17:42.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.348]                       search = base::search(), system = base::Sys.info())
[16:17:42.348]                   }
[16:17:42.348]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.348]                     cond$call), session = sessionInformation(), 
[16:17:42.348]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.348]                   signalCondition(cond)
[16:17:42.348]                 }
[16:17:42.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.348]                 "immediateCondition"))) {
[16:17:42.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.348]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.348]                   if (TRUE && !signal) {
[16:17:42.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.348]                     {
[16:17:42.348]                       inherits <- base::inherits
[16:17:42.348]                       invokeRestart <- base::invokeRestart
[16:17:42.348]                       is.null <- base::is.null
[16:17:42.348]                       muffled <- FALSE
[16:17:42.348]                       if (inherits(cond, "message")) {
[16:17:42.348]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.348]                         if (muffled) 
[16:17:42.348]                           invokeRestart("muffleMessage")
[16:17:42.348]                       }
[16:17:42.348]                       else if (inherits(cond, "warning")) {
[16:17:42.348]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.348]                         if (muffled) 
[16:17:42.348]                           invokeRestart("muffleWarning")
[16:17:42.348]                       }
[16:17:42.348]                       else if (inherits(cond, "condition")) {
[16:17:42.348]                         if (!is.null(pattern)) {
[16:17:42.348]                           computeRestarts <- base::computeRestarts
[16:17:42.348]                           grepl <- base::grepl
[16:17:42.348]                           restarts <- computeRestarts(cond)
[16:17:42.348]                           for (restart in restarts) {
[16:17:42.348]                             name <- restart$name
[16:17:42.348]                             if (is.null(name)) 
[16:17:42.348]                               next
[16:17:42.348]                             if (!grepl(pattern, name)) 
[16:17:42.348]                               next
[16:17:42.348]                             invokeRestart(restart)
[16:17:42.348]                             muffled <- TRUE
[16:17:42.348]                             break
[16:17:42.348]                           }
[16:17:42.348]                         }
[16:17:42.348]                       }
[16:17:42.348]                       invisible(muffled)
[16:17:42.348]                     }
[16:17:42.348]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.348]                   }
[16:17:42.348]                 }
[16:17:42.348]                 else {
[16:17:42.348]                   if (TRUE) {
[16:17:42.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.348]                     {
[16:17:42.348]                       inherits <- base::inherits
[16:17:42.348]                       invokeRestart <- base::invokeRestart
[16:17:42.348]                       is.null <- base::is.null
[16:17:42.348]                       muffled <- FALSE
[16:17:42.348]                       if (inherits(cond, "message")) {
[16:17:42.348]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.348]                         if (muffled) 
[16:17:42.348]                           invokeRestart("muffleMessage")
[16:17:42.348]                       }
[16:17:42.348]                       else if (inherits(cond, "warning")) {
[16:17:42.348]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.348]                         if (muffled) 
[16:17:42.348]                           invokeRestart("muffleWarning")
[16:17:42.348]                       }
[16:17:42.348]                       else if (inherits(cond, "condition")) {
[16:17:42.348]                         if (!is.null(pattern)) {
[16:17:42.348]                           computeRestarts <- base::computeRestarts
[16:17:42.348]                           grepl <- base::grepl
[16:17:42.348]                           restarts <- computeRestarts(cond)
[16:17:42.348]                           for (restart in restarts) {
[16:17:42.348]                             name <- restart$name
[16:17:42.348]                             if (is.null(name)) 
[16:17:42.348]                               next
[16:17:42.348]                             if (!grepl(pattern, name)) 
[16:17:42.348]                               next
[16:17:42.348]                             invokeRestart(restart)
[16:17:42.348]                             muffled <- TRUE
[16:17:42.348]                             break
[16:17:42.348]                           }
[16:17:42.348]                         }
[16:17:42.348]                       }
[16:17:42.348]                       invisible(muffled)
[16:17:42.348]                     }
[16:17:42.348]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.348]                   }
[16:17:42.348]                 }
[16:17:42.348]             }
[16:17:42.348]         }))
[16:17:42.348]     }, error = function(ex) {
[16:17:42.348]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.348]                 ...future.rng), started = ...future.startTime, 
[16:17:42.348]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.348]             version = "1.8"), class = "FutureResult")
[16:17:42.348]     }, finally = {
[16:17:42.348]         if (!identical(...future.workdir, getwd())) 
[16:17:42.348]             setwd(...future.workdir)
[16:17:42.348]         {
[16:17:42.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.348]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.348]             }
[16:17:42.348]             base::options(...future.oldOptions)
[16:17:42.348]             if (.Platform$OS.type == "windows") {
[16:17:42.348]                 old_names <- names(...future.oldEnvVars)
[16:17:42.348]                 envs <- base::Sys.getenv()
[16:17:42.348]                 names <- names(envs)
[16:17:42.348]                 common <- intersect(names, old_names)
[16:17:42.348]                 added <- setdiff(names, old_names)
[16:17:42.348]                 removed <- setdiff(old_names, names)
[16:17:42.348]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.348]                   envs[common]]
[16:17:42.348]                 NAMES <- toupper(changed)
[16:17:42.348]                 args <- list()
[16:17:42.348]                 for (kk in seq_along(NAMES)) {
[16:17:42.348]                   name <- changed[[kk]]
[16:17:42.348]                   NAME <- NAMES[[kk]]
[16:17:42.348]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.348]                     next
[16:17:42.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.348]                 }
[16:17:42.348]                 NAMES <- toupper(added)
[16:17:42.348]                 for (kk in seq_along(NAMES)) {
[16:17:42.348]                   name <- added[[kk]]
[16:17:42.348]                   NAME <- NAMES[[kk]]
[16:17:42.348]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.348]                     next
[16:17:42.348]                   args[[name]] <- ""
[16:17:42.348]                 }
[16:17:42.348]                 NAMES <- toupper(removed)
[16:17:42.348]                 for (kk in seq_along(NAMES)) {
[16:17:42.348]                   name <- removed[[kk]]
[16:17:42.348]                   NAME <- NAMES[[kk]]
[16:17:42.348]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.348]                     next
[16:17:42.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.348]                 }
[16:17:42.348]                 if (length(args) > 0) 
[16:17:42.348]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.348]             }
[16:17:42.348]             else {
[16:17:42.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.348]             }
[16:17:42.348]             {
[16:17:42.348]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.348]                   0L) {
[16:17:42.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.348]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.348]                   base::options(opts)
[16:17:42.348]                 }
[16:17:42.348]                 {
[16:17:42.348]                   {
[16:17:42.348]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.348]                     NULL
[16:17:42.348]                   }
[16:17:42.348]                   options(future.plan = NULL)
[16:17:42.348]                   if (is.na(NA_character_)) 
[16:17:42.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.348]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.348]                     .init = FALSE)
[16:17:42.348]                 }
[16:17:42.348]             }
[16:17:42.348]         }
[16:17:42.348]     })
[16:17:42.348]     if (TRUE) {
[16:17:42.348]         base::sink(type = "output", split = FALSE)
[16:17:42.348]         if (TRUE) {
[16:17:42.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.348]         }
[16:17:42.348]         else {
[16:17:42.348]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.348]         }
[16:17:42.348]         base::close(...future.stdout)
[16:17:42.348]         ...future.stdout <- NULL
[16:17:42.348]     }
[16:17:42.348]     ...future.result$conditions <- ...future.conditions
[16:17:42.348]     ...future.result$finished <- base::Sys.time()
[16:17:42.348]     ...future.result
[16:17:42.348] }
[16:17:42.352] assign_globals() ...
[16:17:42.352] List of 5
[16:17:42.352]  $ future.call.arguments    : list()
[16:17:42.352]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.352]  $ ...future.FUN            :function (x, ...)  
[16:17:42.352]  $ ...future.elements_ii    :List of 1
[16:17:42.352]   ..$ : num [1:4] 2 4 6 8
[16:17:42.352]  $ ...future.seeds_ii       : NULL
[16:17:42.352]  $ ...future.globals.maxSize: num Inf
[16:17:42.352]  - attr(*, "resolved")= logi FALSE
[16:17:42.352]  - attr(*, "total_size")= num NA
[16:17:42.352]  - attr(*, "where")=List of 5
[16:17:42.352]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.352]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.352]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.352]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.352]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.352]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.352]  - attr(*, "already-done")= logi TRUE
[16:17:42.359] - copied ‘future.call.arguments’ to environment
[16:17:42.359] - copied ‘...future.FUN’ to environment
[16:17:42.360] - copied ‘...future.elements_ii’ to environment
[16:17:42.360] - copied ‘...future.seeds_ii’ to environment
[16:17:42.360] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.360] assign_globals() ... done
[16:17:42.360] requestCore(): workers = 2
[16:17:42.362] MulticoreFuture started
[16:17:42.363] - Launch lazy future ... done
[16:17:42.363] run() for ‘MulticoreFuture’ ... done
[16:17:42.363] Created future:
[16:17:42.364] plan(): Setting new future strategy stack:
[16:17:42.364] List of future strategies:
[16:17:42.364] 1. sequential:
[16:17:42.364]    - args: function (..., envir = parent.frame())
[16:17:42.364]    - tweaked: FALSE
[16:17:42.364]    - call: NULL
[16:17:42.365] plan(): nbrOfWorkers() = 1
[16:17:42.371] plan(): Setting new future strategy stack:
[16:17:42.372] List of future strategies:
[16:17:42.372] 1. multicore:
[16:17:42.372]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.372]    - tweaked: FALSE
[16:17:42.372]    - call: plan(strategy)
[16:17:42.379] plan(): nbrOfWorkers() = 2
[16:17:42.363] MulticoreFuture:
[16:17:42.363] Label: ‘future_apply-2’
[16:17:42.363] Expression:
[16:17:42.363] {
[16:17:42.363]     do.call(function(...) {
[16:17:42.363]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.363]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.363]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.363]             on.exit(options(oopts), add = TRUE)
[16:17:42.363]         }
[16:17:42.363]         {
[16:17:42.363]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.363]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.363]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.363]             })
[16:17:42.363]         }
[16:17:42.363]     }, args = future.call.arguments)
[16:17:42.363] }
[16:17:42.363] Lazy evaluation: FALSE
[16:17:42.363] Asynchronous evaluation: TRUE
[16:17:42.363] Local evaluation: TRUE
[16:17:42.363] Environment: R_GlobalEnv
[16:17:42.363] Capture standard output: TRUE
[16:17:42.363] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.363] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.363] Packages: 1 packages (‘stats’)
[16:17:42.363] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.363] Resolved: TRUE
[16:17:42.363] Value: <not collected>
[16:17:42.363] Conditions captured: <none>
[16:17:42.363] Early signaling: FALSE
[16:17:42.363] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.363] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.380] Chunk #2 of 2 ... DONE
[16:17:42.381] Launching 2 futures (chunks) ... DONE
[16:17:42.381] Resolving 2 futures (chunks) ...
[16:17:42.381] resolve() on list ...
[16:17:42.382]  recursive: 0
[16:17:42.382]  length: 2
[16:17:42.382] 
[16:17:42.382] Future #1
[16:17:42.383] result() for MulticoreFuture ...
[16:17:42.384] result() for MulticoreFuture ...
[16:17:42.384] result() for MulticoreFuture ... done
[16:17:42.385] result() for MulticoreFuture ... done
[16:17:42.385] result() for MulticoreFuture ...
[16:17:42.385] result() for MulticoreFuture ... done
[16:17:42.386] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:42.386] - nx: 2
[16:17:42.386] - relay: TRUE
[16:17:42.387] - stdout: TRUE
[16:17:42.387] - signal: TRUE
[16:17:42.387] - resignal: FALSE
[16:17:42.387] - force: TRUE
[16:17:42.388] - relayed: [n=2] FALSE, FALSE
[16:17:42.388] - queued futures: [n=2] FALSE, FALSE
[16:17:42.388]  - until=1
[16:17:42.388]  - relaying element #1
[16:17:42.389] result() for MulticoreFuture ...
[16:17:42.389] result() for MulticoreFuture ... done
[16:17:42.389] result() for MulticoreFuture ...
[16:17:42.389] result() for MulticoreFuture ... done
[16:17:42.389] result() for MulticoreFuture ...
[16:17:42.389] result() for MulticoreFuture ... done
[16:17:42.389] result() for MulticoreFuture ...
[16:17:42.390] result() for MulticoreFuture ... done
[16:17:42.390] - relayed: [n=2] TRUE, FALSE
[16:17:42.390] - queued futures: [n=2] TRUE, FALSE
[16:17:42.390] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:42.390]  length: 1 (resolved future 1)
[16:17:42.391] Future #2
[16:17:42.391] result() for MulticoreFuture ...
[16:17:42.392] result() for MulticoreFuture ...
[16:17:42.392] result() for MulticoreFuture ... done
[16:17:42.392] result() for MulticoreFuture ... done
[16:17:42.392] result() for MulticoreFuture ...
[16:17:42.392] result() for MulticoreFuture ... done
[16:17:42.393] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:42.393] - nx: 2
[16:17:42.393] - relay: TRUE
[16:17:42.393] - stdout: TRUE
[16:17:42.393] - signal: TRUE
[16:17:42.393] - resignal: FALSE
[16:17:42.393] - force: TRUE
[16:17:42.393] - relayed: [n=2] TRUE, FALSE
[16:17:42.394] - queued futures: [n=2] TRUE, FALSE
[16:17:42.394]  - until=2
[16:17:42.394]  - relaying element #2
[16:17:42.394] result() for MulticoreFuture ...
[16:17:42.394] result() for MulticoreFuture ... done
[16:17:42.394] result() for MulticoreFuture ...
[16:17:42.394] result() for MulticoreFuture ... done
[16:17:42.394] result() for MulticoreFuture ...
[16:17:42.394] result() for MulticoreFuture ... done
[16:17:42.395] result() for MulticoreFuture ...
[16:17:42.395] result() for MulticoreFuture ... done
[16:17:42.395] - relayed: [n=2] TRUE, TRUE
[16:17:42.395] - queued futures: [n=2] TRUE, TRUE
[16:17:42.395] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:42.395]  length: 0 (resolved future 2)
[16:17:42.395] Relaying remaining futures
[16:17:42.395] signalConditionsASAP(NULL, pos=0) ...
[16:17:42.395] - nx: 2
[16:17:42.396] - relay: TRUE
[16:17:42.396] - stdout: TRUE
[16:17:42.396] - signal: TRUE
[16:17:42.396] - resignal: FALSE
[16:17:42.396] - force: TRUE
[16:17:42.396] - relayed: [n=2] TRUE, TRUE
[16:17:42.396] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:42.396] - relayed: [n=2] TRUE, TRUE
[16:17:42.396] - queued futures: [n=2] TRUE, TRUE
[16:17:42.397] signalConditionsASAP(NULL, pos=0) ... done
[16:17:42.397] resolve() on list ... DONE
[16:17:42.397] result() for MulticoreFuture ...
[16:17:42.397] result() for MulticoreFuture ... done
[16:17:42.397] result() for MulticoreFuture ...
[16:17:42.397] result() for MulticoreFuture ... done
[16:17:42.397] result() for MulticoreFuture ...
[16:17:42.397] result() for MulticoreFuture ... done
[16:17:42.397] result() for MulticoreFuture ...
[16:17:42.398] result() for MulticoreFuture ... done
[16:17:42.398]  - Number of value chunks collected: 2
[16:17:42.398] Resolving 2 futures (chunks) ... DONE
[16:17:42.398] Reducing values from 2 chunks ...
[16:17:42.398]  - Number of values collected after concatenation: 2
[16:17:42.398]  - Number of values expected: 2
[16:17:42.398] Reducing values from 2 chunks ... DONE
[16:17:42.398] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:17:42.399] getGlobalsAndPackagesXApply() ...
[16:17:42.399]  - future.globals: TRUE
[16:17:42.399] getGlobalsAndPackages() ...
[16:17:42.399] Searching for globals...
[16:17:42.401] - globals found: [1] ‘FUN’
[16:17:42.401] Searching for globals ... DONE
[16:17:42.401] Resolving globals: FALSE
[16:17:42.401] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:42.402] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:42.402] - globals: [1] ‘FUN’
[16:17:42.402] 
[16:17:42.402] getGlobalsAndPackages() ... DONE
[16:17:42.402]  - globals found/used: [n=1] ‘FUN’
[16:17:42.402]  - needed namespaces: [n=0] 
[16:17:42.402] Finding globals ... DONE
[16:17:42.402]  - use_args: TRUE
[16:17:42.403]  - Getting '...' globals ...
[16:17:42.403] resolve() on list ...
[16:17:42.403]  recursive: 0
[16:17:42.403]  length: 1
[16:17:42.403]  elements: ‘...’
[16:17:42.403]  length: 0 (resolved future 1)
[16:17:42.404] resolve() on list ... DONE
[16:17:42.404]    - '...' content: [n=0] 
[16:17:42.404] List of 1
[16:17:42.404]  $ ...: list()
[16:17:42.404]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.404]  - attr(*, "where")=List of 1
[16:17:42.404]   ..$ ...:<environment: 0x555be0c85800> 
[16:17:42.404]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.404]  - attr(*, "resolved")= logi TRUE
[16:17:42.404]  - attr(*, "total_size")= num NA
[16:17:42.406]  - Getting '...' globals ... DONE
[16:17:42.407] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:42.407] List of 2
[16:17:42.407]  $ ...future.FUN:function (x)  
[16:17:42.407]  $ ...          : list()
[16:17:42.407]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.407]  - attr(*, "where")=List of 2
[16:17:42.407]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:42.407]   ..$ ...          :<environment: 0x555be0c85800> 
[16:17:42.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.407]  - attr(*, "resolved")= logi FALSE
[16:17:42.407]  - attr(*, "total_size")= num 848
[16:17:42.411] Packages to be attached in all futures: [n=0] 
[16:17:42.412] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.415] future_lapply() ...
[16:17:42.419] Number of chunks: 2
[16:17:42.419] getGlobalsAndPackagesXApply() ...
[16:17:42.420]  - future.globals: <name-value list> with names ‘list()’
[16:17:42.420]  - use_args: TRUE
[16:17:42.420] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:42.420] List of 2
[16:17:42.420]  $ ...          : list()
[16:17:42.420]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.420]  $ ...future.FUN:function (x)  
[16:17:42.420]  - attr(*, "where")=List of 2
[16:17:42.420]   ..$ ...          :<environment: 0x555be0c85800> 
[16:17:42.420]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:42.420]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.420]  - attr(*, "resolved")= logi FALSE
[16:17:42.420]  - attr(*, "total_size")= num NA
[16:17:42.423] Packages to be attached in all futures: [n=0] 
[16:17:42.423] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.424] Number of futures (= number of chunks): 2
[16:17:42.424] Launching 2 futures (chunks) ...
[16:17:42.424] Chunk #1 of 2 ...
[16:17:42.424]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.424]  - seeds: <none>
[16:17:42.424]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.424] getGlobalsAndPackages() ...
[16:17:42.424] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.424] Resolving globals: FALSE
[16:17:42.425] Tweak future expression to call with '...' arguments ...
[16:17:42.425] {
[16:17:42.425]     do.call(function(...) {
[16:17:42.425]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.425]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.425]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.425]             on.exit(options(oopts), add = TRUE)
[16:17:42.425]         }
[16:17:42.425]         {
[16:17:42.425]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.425]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.425]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.425]             })
[16:17:42.425]         }
[16:17:42.425]     }, args = future.call.arguments)
[16:17:42.425] }
[16:17:42.425] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.425] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.425] 
[16:17:42.426] getGlobalsAndPackages() ... DONE
[16:17:42.426] run() for ‘Future’ ...
[16:17:42.426] - state: ‘created’
[16:17:42.426] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.429] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.430]   - Field: ‘label’
[16:17:42.430]   - Field: ‘local’
[16:17:42.430]   - Field: ‘owner’
[16:17:42.430]   - Field: ‘envir’
[16:17:42.430]   - Field: ‘workers’
[16:17:42.430]   - Field: ‘packages’
[16:17:42.430]   - Field: ‘gc’
[16:17:42.430]   - Field: ‘job’
[16:17:42.430]   - Field: ‘conditions’
[16:17:42.430]   - Field: ‘expr’
[16:17:42.431]   - Field: ‘uuid’
[16:17:42.431]   - Field: ‘seed’
[16:17:42.431]   - Field: ‘version’
[16:17:42.431]   - Field: ‘result’
[16:17:42.431]   - Field: ‘asynchronous’
[16:17:42.431]   - Field: ‘calls’
[16:17:42.431]   - Field: ‘globals’
[16:17:42.431]   - Field: ‘stdout’
[16:17:42.431]   - Field: ‘earlySignal’
[16:17:42.431]   - Field: ‘lazy’
[16:17:42.431]   - Field: ‘state’
[16:17:42.432] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.432] - Launch lazy future ...
[16:17:42.432] Packages needed by the future expression (n = 0): <none>
[16:17:42.432] Packages needed by future strategies (n = 0): <none>
[16:17:42.433] {
[16:17:42.433]     {
[16:17:42.433]         {
[16:17:42.433]             ...future.startTime <- base::Sys.time()
[16:17:42.433]             {
[16:17:42.433]                 {
[16:17:42.433]                   {
[16:17:42.433]                     {
[16:17:42.433]                       base::local({
[16:17:42.433]                         has_future <- base::requireNamespace("future", 
[16:17:42.433]                           quietly = TRUE)
[16:17:42.433]                         if (has_future) {
[16:17:42.433]                           ns <- base::getNamespace("future")
[16:17:42.433]                           version <- ns[[".package"]][["version"]]
[16:17:42.433]                           if (is.null(version)) 
[16:17:42.433]                             version <- utils::packageVersion("future")
[16:17:42.433]                         }
[16:17:42.433]                         else {
[16:17:42.433]                           version <- NULL
[16:17:42.433]                         }
[16:17:42.433]                         if (!has_future || version < "1.8.0") {
[16:17:42.433]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.433]                             "", base::R.version$version.string), 
[16:17:42.433]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.433]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.433]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.433]                               "release", "version")], collapse = " "), 
[16:17:42.433]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.433]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.433]                             info)
[16:17:42.433]                           info <- base::paste(info, collapse = "; ")
[16:17:42.433]                           if (!has_future) {
[16:17:42.433]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.433]                               info)
[16:17:42.433]                           }
[16:17:42.433]                           else {
[16:17:42.433]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.433]                               info, version)
[16:17:42.433]                           }
[16:17:42.433]                           base::stop(msg)
[16:17:42.433]                         }
[16:17:42.433]                       })
[16:17:42.433]                     }
[16:17:42.433]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.433]                     base::options(mc.cores = 1L)
[16:17:42.433]                   }
[16:17:42.433]                   ...future.strategy.old <- future::plan("list")
[16:17:42.433]                   options(future.plan = NULL)
[16:17:42.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.433]                 }
[16:17:42.433]                 ...future.workdir <- getwd()
[16:17:42.433]             }
[16:17:42.433]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.433]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.433]         }
[16:17:42.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.433]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.433]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.433]             base::names(...future.oldOptions))
[16:17:42.433]     }
[16:17:42.433]     if (FALSE) {
[16:17:42.433]     }
[16:17:42.433]     else {
[16:17:42.433]         if (TRUE) {
[16:17:42.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.433]                 open = "w")
[16:17:42.433]         }
[16:17:42.433]         else {
[16:17:42.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.433]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.433]         }
[16:17:42.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.433]             base::sink(type = "output", split = FALSE)
[16:17:42.433]             base::close(...future.stdout)
[16:17:42.433]         }, add = TRUE)
[16:17:42.433]     }
[16:17:42.433]     ...future.frame <- base::sys.nframe()
[16:17:42.433]     ...future.conditions <- base::list()
[16:17:42.433]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.433]     if (FALSE) {
[16:17:42.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.433]     }
[16:17:42.433]     ...future.result <- base::tryCatch({
[16:17:42.433]         base::withCallingHandlers({
[16:17:42.433]             ...future.value <- base::withVisible(base::local({
[16:17:42.433]                 withCallingHandlers({
[16:17:42.433]                   {
[16:17:42.433]                     do.call(function(...) {
[16:17:42.433]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.433]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.433]                         ...future.globals.maxSize)) {
[16:17:42.433]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.433]                         on.exit(options(oopts), add = TRUE)
[16:17:42.433]                       }
[16:17:42.433]                       {
[16:17:42.433]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.433]                           FUN = function(jj) {
[16:17:42.433]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.433]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.433]                           })
[16:17:42.433]                       }
[16:17:42.433]                     }, args = future.call.arguments)
[16:17:42.433]                   }
[16:17:42.433]                 }, immediateCondition = function(cond) {
[16:17:42.433]                   save_rds <- function (object, pathname, ...) 
[16:17:42.433]                   {
[16:17:42.433]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.433]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.433]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.433]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.433]                         fi_tmp[["mtime"]])
[16:17:42.433]                     }
[16:17:42.433]                     tryCatch({
[16:17:42.433]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.433]                     }, error = function(ex) {
[16:17:42.433]                       msg <- conditionMessage(ex)
[16:17:42.433]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.433]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.433]                         fi_tmp[["mtime"]], msg)
[16:17:42.433]                       ex$message <- msg
[16:17:42.433]                       stop(ex)
[16:17:42.433]                     })
[16:17:42.433]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.433]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.433]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.433]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.433]                       fi <- file.info(pathname)
[16:17:42.433]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.433]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.433]                         fi[["size"]], fi[["mtime"]])
[16:17:42.433]                       stop(msg)
[16:17:42.433]                     }
[16:17:42.433]                     invisible(pathname)
[16:17:42.433]                   }
[16:17:42.433]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.433]                     rootPath = tempdir()) 
[16:17:42.433]                   {
[16:17:42.433]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.433]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.433]                       tmpdir = path, fileext = ".rds")
[16:17:42.433]                     save_rds(obj, file)
[16:17:42.433]                   }
[16:17:42.433]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.433]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.433]                   {
[16:17:42.433]                     inherits <- base::inherits
[16:17:42.433]                     invokeRestart <- base::invokeRestart
[16:17:42.433]                     is.null <- base::is.null
[16:17:42.433]                     muffled <- FALSE
[16:17:42.433]                     if (inherits(cond, "message")) {
[16:17:42.433]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.433]                       if (muffled) 
[16:17:42.433]                         invokeRestart("muffleMessage")
[16:17:42.433]                     }
[16:17:42.433]                     else if (inherits(cond, "warning")) {
[16:17:42.433]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.433]                       if (muffled) 
[16:17:42.433]                         invokeRestart("muffleWarning")
[16:17:42.433]                     }
[16:17:42.433]                     else if (inherits(cond, "condition")) {
[16:17:42.433]                       if (!is.null(pattern)) {
[16:17:42.433]                         computeRestarts <- base::computeRestarts
[16:17:42.433]                         grepl <- base::grepl
[16:17:42.433]                         restarts <- computeRestarts(cond)
[16:17:42.433]                         for (restart in restarts) {
[16:17:42.433]                           name <- restart$name
[16:17:42.433]                           if (is.null(name)) 
[16:17:42.433]                             next
[16:17:42.433]                           if (!grepl(pattern, name)) 
[16:17:42.433]                             next
[16:17:42.433]                           invokeRestart(restart)
[16:17:42.433]                           muffled <- TRUE
[16:17:42.433]                           break
[16:17:42.433]                         }
[16:17:42.433]                       }
[16:17:42.433]                     }
[16:17:42.433]                     invisible(muffled)
[16:17:42.433]                   }
[16:17:42.433]                   muffleCondition(cond)
[16:17:42.433]                 })
[16:17:42.433]             }))
[16:17:42.433]             future::FutureResult(value = ...future.value$value, 
[16:17:42.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.433]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.433]                     ...future.globalenv.names))
[16:17:42.433]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.433]         }, condition = base::local({
[16:17:42.433]             c <- base::c
[16:17:42.433]             inherits <- base::inherits
[16:17:42.433]             invokeRestart <- base::invokeRestart
[16:17:42.433]             length <- base::length
[16:17:42.433]             list <- base::list
[16:17:42.433]             seq.int <- base::seq.int
[16:17:42.433]             signalCondition <- base::signalCondition
[16:17:42.433]             sys.calls <- base::sys.calls
[16:17:42.433]             `[[` <- base::`[[`
[16:17:42.433]             `+` <- base::`+`
[16:17:42.433]             `<<-` <- base::`<<-`
[16:17:42.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.433]                   3L)]
[16:17:42.433]             }
[16:17:42.433]             function(cond) {
[16:17:42.433]                 is_error <- inherits(cond, "error")
[16:17:42.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.433]                   NULL)
[16:17:42.433]                 if (is_error) {
[16:17:42.433]                   sessionInformation <- function() {
[16:17:42.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.433]                       search = base::search(), system = base::Sys.info())
[16:17:42.433]                   }
[16:17:42.433]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.433]                     cond$call), session = sessionInformation(), 
[16:17:42.433]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.433]                   signalCondition(cond)
[16:17:42.433]                 }
[16:17:42.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.433]                 "immediateCondition"))) {
[16:17:42.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.433]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.433]                   if (TRUE && !signal) {
[16:17:42.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.433]                     {
[16:17:42.433]                       inherits <- base::inherits
[16:17:42.433]                       invokeRestart <- base::invokeRestart
[16:17:42.433]                       is.null <- base::is.null
[16:17:42.433]                       muffled <- FALSE
[16:17:42.433]                       if (inherits(cond, "message")) {
[16:17:42.433]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.433]                         if (muffled) 
[16:17:42.433]                           invokeRestart("muffleMessage")
[16:17:42.433]                       }
[16:17:42.433]                       else if (inherits(cond, "warning")) {
[16:17:42.433]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.433]                         if (muffled) 
[16:17:42.433]                           invokeRestart("muffleWarning")
[16:17:42.433]                       }
[16:17:42.433]                       else if (inherits(cond, "condition")) {
[16:17:42.433]                         if (!is.null(pattern)) {
[16:17:42.433]                           computeRestarts <- base::computeRestarts
[16:17:42.433]                           grepl <- base::grepl
[16:17:42.433]                           restarts <- computeRestarts(cond)
[16:17:42.433]                           for (restart in restarts) {
[16:17:42.433]                             name <- restart$name
[16:17:42.433]                             if (is.null(name)) 
[16:17:42.433]                               next
[16:17:42.433]                             if (!grepl(pattern, name)) 
[16:17:42.433]                               next
[16:17:42.433]                             invokeRestart(restart)
[16:17:42.433]                             muffled <- TRUE
[16:17:42.433]                             break
[16:17:42.433]                           }
[16:17:42.433]                         }
[16:17:42.433]                       }
[16:17:42.433]                       invisible(muffled)
[16:17:42.433]                     }
[16:17:42.433]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.433]                   }
[16:17:42.433]                 }
[16:17:42.433]                 else {
[16:17:42.433]                   if (TRUE) {
[16:17:42.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.433]                     {
[16:17:42.433]                       inherits <- base::inherits
[16:17:42.433]                       invokeRestart <- base::invokeRestart
[16:17:42.433]                       is.null <- base::is.null
[16:17:42.433]                       muffled <- FALSE
[16:17:42.433]                       if (inherits(cond, "message")) {
[16:17:42.433]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.433]                         if (muffled) 
[16:17:42.433]                           invokeRestart("muffleMessage")
[16:17:42.433]                       }
[16:17:42.433]                       else if (inherits(cond, "warning")) {
[16:17:42.433]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.433]                         if (muffled) 
[16:17:42.433]                           invokeRestart("muffleWarning")
[16:17:42.433]                       }
[16:17:42.433]                       else if (inherits(cond, "condition")) {
[16:17:42.433]                         if (!is.null(pattern)) {
[16:17:42.433]                           computeRestarts <- base::computeRestarts
[16:17:42.433]                           grepl <- base::grepl
[16:17:42.433]                           restarts <- computeRestarts(cond)
[16:17:42.433]                           for (restart in restarts) {
[16:17:42.433]                             name <- restart$name
[16:17:42.433]                             if (is.null(name)) 
[16:17:42.433]                               next
[16:17:42.433]                             if (!grepl(pattern, name)) 
[16:17:42.433]                               next
[16:17:42.433]                             invokeRestart(restart)
[16:17:42.433]                             muffled <- TRUE
[16:17:42.433]                             break
[16:17:42.433]                           }
[16:17:42.433]                         }
[16:17:42.433]                       }
[16:17:42.433]                       invisible(muffled)
[16:17:42.433]                     }
[16:17:42.433]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.433]                   }
[16:17:42.433]                 }
[16:17:42.433]             }
[16:17:42.433]         }))
[16:17:42.433]     }, error = function(ex) {
[16:17:42.433]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.433]                 ...future.rng), started = ...future.startTime, 
[16:17:42.433]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.433]             version = "1.8"), class = "FutureResult")
[16:17:42.433]     }, finally = {
[16:17:42.433]         if (!identical(...future.workdir, getwd())) 
[16:17:42.433]             setwd(...future.workdir)
[16:17:42.433]         {
[16:17:42.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.433]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.433]             }
[16:17:42.433]             base::options(...future.oldOptions)
[16:17:42.433]             if (.Platform$OS.type == "windows") {
[16:17:42.433]                 old_names <- names(...future.oldEnvVars)
[16:17:42.433]                 envs <- base::Sys.getenv()
[16:17:42.433]                 names <- names(envs)
[16:17:42.433]                 common <- intersect(names, old_names)
[16:17:42.433]                 added <- setdiff(names, old_names)
[16:17:42.433]                 removed <- setdiff(old_names, names)
[16:17:42.433]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.433]                   envs[common]]
[16:17:42.433]                 NAMES <- toupper(changed)
[16:17:42.433]                 args <- list()
[16:17:42.433]                 for (kk in seq_along(NAMES)) {
[16:17:42.433]                   name <- changed[[kk]]
[16:17:42.433]                   NAME <- NAMES[[kk]]
[16:17:42.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.433]                     next
[16:17:42.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.433]                 }
[16:17:42.433]                 NAMES <- toupper(added)
[16:17:42.433]                 for (kk in seq_along(NAMES)) {
[16:17:42.433]                   name <- added[[kk]]
[16:17:42.433]                   NAME <- NAMES[[kk]]
[16:17:42.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.433]                     next
[16:17:42.433]                   args[[name]] <- ""
[16:17:42.433]                 }
[16:17:42.433]                 NAMES <- toupper(removed)
[16:17:42.433]                 for (kk in seq_along(NAMES)) {
[16:17:42.433]                   name <- removed[[kk]]
[16:17:42.433]                   NAME <- NAMES[[kk]]
[16:17:42.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.433]                     next
[16:17:42.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.433]                 }
[16:17:42.433]                 if (length(args) > 0) 
[16:17:42.433]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.433]             }
[16:17:42.433]             else {
[16:17:42.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.433]             }
[16:17:42.433]             {
[16:17:42.433]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.433]                   0L) {
[16:17:42.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.433]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.433]                   base::options(opts)
[16:17:42.433]                 }
[16:17:42.433]                 {
[16:17:42.433]                   {
[16:17:42.433]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.433]                     NULL
[16:17:42.433]                   }
[16:17:42.433]                   options(future.plan = NULL)
[16:17:42.433]                   if (is.na(NA_character_)) 
[16:17:42.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.433]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.433]                     .init = FALSE)
[16:17:42.433]                 }
[16:17:42.433]             }
[16:17:42.433]         }
[16:17:42.433]     })
[16:17:42.433]     if (TRUE) {
[16:17:42.433]         base::sink(type = "output", split = FALSE)
[16:17:42.433]         if (TRUE) {
[16:17:42.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.433]         }
[16:17:42.433]         else {
[16:17:42.433]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.433]         }
[16:17:42.433]         base::close(...future.stdout)
[16:17:42.433]         ...future.stdout <- NULL
[16:17:42.433]     }
[16:17:42.433]     ...future.result$conditions <- ...future.conditions
[16:17:42.433]     ...future.result$finished <- base::Sys.time()
[16:17:42.433]     ...future.result
[16:17:42.433] }
[16:17:42.435] assign_globals() ...
[16:17:42.435] List of 5
[16:17:42.435]  $ future.call.arguments    : list()
[16:17:42.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.435]  $ ...future.FUN            :function (x)  
[16:17:42.435]  $ ...future.elements_ii    :List of 1
[16:17:42.435]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:17:42.435]  $ ...future.seeds_ii       : NULL
[16:17:42.435]  $ ...future.globals.maxSize: num Inf
[16:17:42.435]  - attr(*, "resolved")= logi FALSE
[16:17:42.435]  - attr(*, "total_size")= num NA
[16:17:42.435]  - attr(*, "where")=List of 5
[16:17:42.435]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.435]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.435]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.435]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.435]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.435]  - attr(*, "already-done")= logi TRUE
[16:17:42.439] - copied ‘future.call.arguments’ to environment
[16:17:42.440] - copied ‘...future.FUN’ to environment
[16:17:42.440] - copied ‘...future.elements_ii’ to environment
[16:17:42.440] - copied ‘...future.seeds_ii’ to environment
[16:17:42.440] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.440] assign_globals() ... done
[16:17:42.440] requestCore(): workers = 2
[16:17:42.442] MulticoreFuture started
[16:17:42.446] - Launch lazy future ... done
[16:17:42.447] plan(): Setting new future strategy stack:
[16:17:42.447] run() for ‘MulticoreFuture’ ... done
[16:17:42.448] Created future:
[16:17:42.447] List of future strategies:
[16:17:42.447] 1. sequential:
[16:17:42.447]    - args: function (..., envir = parent.frame())
[16:17:42.447]    - tweaked: FALSE
[16:17:42.447]    - call: NULL
[16:17:42.449] plan(): nbrOfWorkers() = 1
[16:17:42.451] plan(): Setting new future strategy stack:
[16:17:42.451] List of future strategies:
[16:17:42.451] 1. multicore:
[16:17:42.451]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.451]    - tweaked: FALSE
[16:17:42.451]    - call: plan(strategy)
[16:17:42.458] plan(): nbrOfWorkers() = 2
[16:17:42.448] MulticoreFuture:
[16:17:42.448] Label: ‘future_apply-1’
[16:17:42.448] Expression:
[16:17:42.448] {
[16:17:42.448]     do.call(function(...) {
[16:17:42.448]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.448]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.448]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.448]             on.exit(options(oopts), add = TRUE)
[16:17:42.448]         }
[16:17:42.448]         {
[16:17:42.448]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.448]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.448]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.448]             })
[16:17:42.448]         }
[16:17:42.448]     }, args = future.call.arguments)
[16:17:42.448] }
[16:17:42.448] Lazy evaluation: FALSE
[16:17:42.448] Asynchronous evaluation: TRUE
[16:17:42.448] Local evaluation: TRUE
[16:17:42.448] Environment: R_GlobalEnv
[16:17:42.448] Capture standard output: TRUE
[16:17:42.448] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.448] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.448] Packages: <none>
[16:17:42.448] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.448] Resolved: TRUE
[16:17:42.448] Value: <not collected>
[16:17:42.448] Conditions captured: <none>
[16:17:42.448] Early signaling: FALSE
[16:17:42.448] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.448] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.459] Chunk #1 of 2 ... DONE
[16:17:42.459] Chunk #2 of 2 ...
[16:17:42.460]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.460]  - seeds: <none>
[16:17:42.460]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.460] getGlobalsAndPackages() ...
[16:17:42.461] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.461] Resolving globals: FALSE
[16:17:42.461] Tweak future expression to call with '...' arguments ...
[16:17:42.461] {
[16:17:42.461]     do.call(function(...) {
[16:17:42.461]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.461]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.461]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.461]             on.exit(options(oopts), add = TRUE)
[16:17:42.461]         }
[16:17:42.461]         {
[16:17:42.461]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.461]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.461]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.461]             })
[16:17:42.461]         }
[16:17:42.461]     }, args = future.call.arguments)
[16:17:42.461] }
[16:17:42.462] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.463] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.463] 
[16:17:42.463] getGlobalsAndPackages() ... DONE
[16:17:42.463] run() for ‘Future’ ...
[16:17:42.464] - state: ‘created’
[16:17:42.464] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.469] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.469]   - Field: ‘label’
[16:17:42.469]   - Field: ‘local’
[16:17:42.469]   - Field: ‘owner’
[16:17:42.470]   - Field: ‘envir’
[16:17:42.470]   - Field: ‘workers’
[16:17:42.470]   - Field: ‘packages’
[16:17:42.470]   - Field: ‘gc’
[16:17:42.470]   - Field: ‘job’
[16:17:42.470]   - Field: ‘conditions’
[16:17:42.471]   - Field: ‘expr’
[16:17:42.471]   - Field: ‘uuid’
[16:17:42.471]   - Field: ‘seed’
[16:17:42.471]   - Field: ‘version’
[16:17:42.471]   - Field: ‘result’
[16:17:42.471]   - Field: ‘asynchronous’
[16:17:42.471]   - Field: ‘calls’
[16:17:42.472]   - Field: ‘globals’
[16:17:42.472]   - Field: ‘stdout’
[16:17:42.472]   - Field: ‘earlySignal’
[16:17:42.472]   - Field: ‘lazy’
[16:17:42.472]   - Field: ‘state’
[16:17:42.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.473] - Launch lazy future ...
[16:17:42.473] Packages needed by the future expression (n = 0): <none>
[16:17:42.473] Packages needed by future strategies (n = 0): <none>
[16:17:42.474] {
[16:17:42.474]     {
[16:17:42.474]         {
[16:17:42.474]             ...future.startTime <- base::Sys.time()
[16:17:42.474]             {
[16:17:42.474]                 {
[16:17:42.474]                   {
[16:17:42.474]                     {
[16:17:42.474]                       base::local({
[16:17:42.474]                         has_future <- base::requireNamespace("future", 
[16:17:42.474]                           quietly = TRUE)
[16:17:42.474]                         if (has_future) {
[16:17:42.474]                           ns <- base::getNamespace("future")
[16:17:42.474]                           version <- ns[[".package"]][["version"]]
[16:17:42.474]                           if (is.null(version)) 
[16:17:42.474]                             version <- utils::packageVersion("future")
[16:17:42.474]                         }
[16:17:42.474]                         else {
[16:17:42.474]                           version <- NULL
[16:17:42.474]                         }
[16:17:42.474]                         if (!has_future || version < "1.8.0") {
[16:17:42.474]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.474]                             "", base::R.version$version.string), 
[16:17:42.474]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.474]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.474]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.474]                               "release", "version")], collapse = " "), 
[16:17:42.474]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.474]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.474]                             info)
[16:17:42.474]                           info <- base::paste(info, collapse = "; ")
[16:17:42.474]                           if (!has_future) {
[16:17:42.474]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.474]                               info)
[16:17:42.474]                           }
[16:17:42.474]                           else {
[16:17:42.474]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.474]                               info, version)
[16:17:42.474]                           }
[16:17:42.474]                           base::stop(msg)
[16:17:42.474]                         }
[16:17:42.474]                       })
[16:17:42.474]                     }
[16:17:42.474]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.474]                     base::options(mc.cores = 1L)
[16:17:42.474]                   }
[16:17:42.474]                   ...future.strategy.old <- future::plan("list")
[16:17:42.474]                   options(future.plan = NULL)
[16:17:42.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.474]                 }
[16:17:42.474]                 ...future.workdir <- getwd()
[16:17:42.474]             }
[16:17:42.474]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.474]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.474]         }
[16:17:42.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.474]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.474]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.474]             base::names(...future.oldOptions))
[16:17:42.474]     }
[16:17:42.474]     if (FALSE) {
[16:17:42.474]     }
[16:17:42.474]     else {
[16:17:42.474]         if (TRUE) {
[16:17:42.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.474]                 open = "w")
[16:17:42.474]         }
[16:17:42.474]         else {
[16:17:42.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.474]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.474]         }
[16:17:42.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.474]             base::sink(type = "output", split = FALSE)
[16:17:42.474]             base::close(...future.stdout)
[16:17:42.474]         }, add = TRUE)
[16:17:42.474]     }
[16:17:42.474]     ...future.frame <- base::sys.nframe()
[16:17:42.474]     ...future.conditions <- base::list()
[16:17:42.474]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.474]     if (FALSE) {
[16:17:42.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.474]     }
[16:17:42.474]     ...future.result <- base::tryCatch({
[16:17:42.474]         base::withCallingHandlers({
[16:17:42.474]             ...future.value <- base::withVisible(base::local({
[16:17:42.474]                 withCallingHandlers({
[16:17:42.474]                   {
[16:17:42.474]                     do.call(function(...) {
[16:17:42.474]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.474]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.474]                         ...future.globals.maxSize)) {
[16:17:42.474]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.474]                         on.exit(options(oopts), add = TRUE)
[16:17:42.474]                       }
[16:17:42.474]                       {
[16:17:42.474]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.474]                           FUN = function(jj) {
[16:17:42.474]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.474]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.474]                           })
[16:17:42.474]                       }
[16:17:42.474]                     }, args = future.call.arguments)
[16:17:42.474]                   }
[16:17:42.474]                 }, immediateCondition = function(cond) {
[16:17:42.474]                   save_rds <- function (object, pathname, ...) 
[16:17:42.474]                   {
[16:17:42.474]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.474]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.474]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.474]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.474]                         fi_tmp[["mtime"]])
[16:17:42.474]                     }
[16:17:42.474]                     tryCatch({
[16:17:42.474]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.474]                     }, error = function(ex) {
[16:17:42.474]                       msg <- conditionMessage(ex)
[16:17:42.474]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.474]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.474]                         fi_tmp[["mtime"]], msg)
[16:17:42.474]                       ex$message <- msg
[16:17:42.474]                       stop(ex)
[16:17:42.474]                     })
[16:17:42.474]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.474]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.474]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.474]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.474]                       fi <- file.info(pathname)
[16:17:42.474]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.474]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.474]                         fi[["size"]], fi[["mtime"]])
[16:17:42.474]                       stop(msg)
[16:17:42.474]                     }
[16:17:42.474]                     invisible(pathname)
[16:17:42.474]                   }
[16:17:42.474]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.474]                     rootPath = tempdir()) 
[16:17:42.474]                   {
[16:17:42.474]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.474]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.474]                       tmpdir = path, fileext = ".rds")
[16:17:42.474]                     save_rds(obj, file)
[16:17:42.474]                   }
[16:17:42.474]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.474]                   {
[16:17:42.474]                     inherits <- base::inherits
[16:17:42.474]                     invokeRestart <- base::invokeRestart
[16:17:42.474]                     is.null <- base::is.null
[16:17:42.474]                     muffled <- FALSE
[16:17:42.474]                     if (inherits(cond, "message")) {
[16:17:42.474]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.474]                       if (muffled) 
[16:17:42.474]                         invokeRestart("muffleMessage")
[16:17:42.474]                     }
[16:17:42.474]                     else if (inherits(cond, "warning")) {
[16:17:42.474]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.474]                       if (muffled) 
[16:17:42.474]                         invokeRestart("muffleWarning")
[16:17:42.474]                     }
[16:17:42.474]                     else if (inherits(cond, "condition")) {
[16:17:42.474]                       if (!is.null(pattern)) {
[16:17:42.474]                         computeRestarts <- base::computeRestarts
[16:17:42.474]                         grepl <- base::grepl
[16:17:42.474]                         restarts <- computeRestarts(cond)
[16:17:42.474]                         for (restart in restarts) {
[16:17:42.474]                           name <- restart$name
[16:17:42.474]                           if (is.null(name)) 
[16:17:42.474]                             next
[16:17:42.474]                           if (!grepl(pattern, name)) 
[16:17:42.474]                             next
[16:17:42.474]                           invokeRestart(restart)
[16:17:42.474]                           muffled <- TRUE
[16:17:42.474]                           break
[16:17:42.474]                         }
[16:17:42.474]                       }
[16:17:42.474]                     }
[16:17:42.474]                     invisible(muffled)
[16:17:42.474]                   }
[16:17:42.474]                   muffleCondition(cond)
[16:17:42.474]                 })
[16:17:42.474]             }))
[16:17:42.474]             future::FutureResult(value = ...future.value$value, 
[16:17:42.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.474]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.474]                     ...future.globalenv.names))
[16:17:42.474]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.474]         }, condition = base::local({
[16:17:42.474]             c <- base::c
[16:17:42.474]             inherits <- base::inherits
[16:17:42.474]             invokeRestart <- base::invokeRestart
[16:17:42.474]             length <- base::length
[16:17:42.474]             list <- base::list
[16:17:42.474]             seq.int <- base::seq.int
[16:17:42.474]             signalCondition <- base::signalCondition
[16:17:42.474]             sys.calls <- base::sys.calls
[16:17:42.474]             `[[` <- base::`[[`
[16:17:42.474]             `+` <- base::`+`
[16:17:42.474]             `<<-` <- base::`<<-`
[16:17:42.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.474]                   3L)]
[16:17:42.474]             }
[16:17:42.474]             function(cond) {
[16:17:42.474]                 is_error <- inherits(cond, "error")
[16:17:42.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.474]                   NULL)
[16:17:42.474]                 if (is_error) {
[16:17:42.474]                   sessionInformation <- function() {
[16:17:42.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.474]                       search = base::search(), system = base::Sys.info())
[16:17:42.474]                   }
[16:17:42.474]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.474]                     cond$call), session = sessionInformation(), 
[16:17:42.474]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.474]                   signalCondition(cond)
[16:17:42.474]                 }
[16:17:42.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.474]                 "immediateCondition"))) {
[16:17:42.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.474]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.474]                   if (TRUE && !signal) {
[16:17:42.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.474]                     {
[16:17:42.474]                       inherits <- base::inherits
[16:17:42.474]                       invokeRestart <- base::invokeRestart
[16:17:42.474]                       is.null <- base::is.null
[16:17:42.474]                       muffled <- FALSE
[16:17:42.474]                       if (inherits(cond, "message")) {
[16:17:42.474]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.474]                         if (muffled) 
[16:17:42.474]                           invokeRestart("muffleMessage")
[16:17:42.474]                       }
[16:17:42.474]                       else if (inherits(cond, "warning")) {
[16:17:42.474]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.474]                         if (muffled) 
[16:17:42.474]                           invokeRestart("muffleWarning")
[16:17:42.474]                       }
[16:17:42.474]                       else if (inherits(cond, "condition")) {
[16:17:42.474]                         if (!is.null(pattern)) {
[16:17:42.474]                           computeRestarts <- base::computeRestarts
[16:17:42.474]                           grepl <- base::grepl
[16:17:42.474]                           restarts <- computeRestarts(cond)
[16:17:42.474]                           for (restart in restarts) {
[16:17:42.474]                             name <- restart$name
[16:17:42.474]                             if (is.null(name)) 
[16:17:42.474]                               next
[16:17:42.474]                             if (!grepl(pattern, name)) 
[16:17:42.474]                               next
[16:17:42.474]                             invokeRestart(restart)
[16:17:42.474]                             muffled <- TRUE
[16:17:42.474]                             break
[16:17:42.474]                           }
[16:17:42.474]                         }
[16:17:42.474]                       }
[16:17:42.474]                       invisible(muffled)
[16:17:42.474]                     }
[16:17:42.474]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.474]                   }
[16:17:42.474]                 }
[16:17:42.474]                 else {
[16:17:42.474]                   if (TRUE) {
[16:17:42.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.474]                     {
[16:17:42.474]                       inherits <- base::inherits
[16:17:42.474]                       invokeRestart <- base::invokeRestart
[16:17:42.474]                       is.null <- base::is.null
[16:17:42.474]                       muffled <- FALSE
[16:17:42.474]                       if (inherits(cond, "message")) {
[16:17:42.474]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.474]                         if (muffled) 
[16:17:42.474]                           invokeRestart("muffleMessage")
[16:17:42.474]                       }
[16:17:42.474]                       else if (inherits(cond, "warning")) {
[16:17:42.474]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.474]                         if (muffled) 
[16:17:42.474]                           invokeRestart("muffleWarning")
[16:17:42.474]                       }
[16:17:42.474]                       else if (inherits(cond, "condition")) {
[16:17:42.474]                         if (!is.null(pattern)) {
[16:17:42.474]                           computeRestarts <- base::computeRestarts
[16:17:42.474]                           grepl <- base::grepl
[16:17:42.474]                           restarts <- computeRestarts(cond)
[16:17:42.474]                           for (restart in restarts) {
[16:17:42.474]                             name <- restart$name
[16:17:42.474]                             if (is.null(name)) 
[16:17:42.474]                               next
[16:17:42.474]                             if (!grepl(pattern, name)) 
[16:17:42.474]                               next
[16:17:42.474]                             invokeRestart(restart)
[16:17:42.474]                             muffled <- TRUE
[16:17:42.474]                             break
[16:17:42.474]                           }
[16:17:42.474]                         }
[16:17:42.474]                       }
[16:17:42.474]                       invisible(muffled)
[16:17:42.474]                     }
[16:17:42.474]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.474]                   }
[16:17:42.474]                 }
[16:17:42.474]             }
[16:17:42.474]         }))
[16:17:42.474]     }, error = function(ex) {
[16:17:42.474]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.474]                 ...future.rng), started = ...future.startTime, 
[16:17:42.474]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.474]             version = "1.8"), class = "FutureResult")
[16:17:42.474]     }, finally = {
[16:17:42.474]         if (!identical(...future.workdir, getwd())) 
[16:17:42.474]             setwd(...future.workdir)
[16:17:42.474]         {
[16:17:42.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.474]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.474]             }
[16:17:42.474]             base::options(...future.oldOptions)
[16:17:42.474]             if (.Platform$OS.type == "windows") {
[16:17:42.474]                 old_names <- names(...future.oldEnvVars)
[16:17:42.474]                 envs <- base::Sys.getenv()
[16:17:42.474]                 names <- names(envs)
[16:17:42.474]                 common <- intersect(names, old_names)
[16:17:42.474]                 added <- setdiff(names, old_names)
[16:17:42.474]                 removed <- setdiff(old_names, names)
[16:17:42.474]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.474]                   envs[common]]
[16:17:42.474]                 NAMES <- toupper(changed)
[16:17:42.474]                 args <- list()
[16:17:42.474]                 for (kk in seq_along(NAMES)) {
[16:17:42.474]                   name <- changed[[kk]]
[16:17:42.474]                   NAME <- NAMES[[kk]]
[16:17:42.474]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.474]                     next
[16:17:42.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.474]                 }
[16:17:42.474]                 NAMES <- toupper(added)
[16:17:42.474]                 for (kk in seq_along(NAMES)) {
[16:17:42.474]                   name <- added[[kk]]
[16:17:42.474]                   NAME <- NAMES[[kk]]
[16:17:42.474]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.474]                     next
[16:17:42.474]                   args[[name]] <- ""
[16:17:42.474]                 }
[16:17:42.474]                 NAMES <- toupper(removed)
[16:17:42.474]                 for (kk in seq_along(NAMES)) {
[16:17:42.474]                   name <- removed[[kk]]
[16:17:42.474]                   NAME <- NAMES[[kk]]
[16:17:42.474]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.474]                     next
[16:17:42.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.474]                 }
[16:17:42.474]                 if (length(args) > 0) 
[16:17:42.474]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.474]             }
[16:17:42.474]             else {
[16:17:42.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.474]             }
[16:17:42.474]             {
[16:17:42.474]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.474]                   0L) {
[16:17:42.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.474]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.474]                   base::options(opts)
[16:17:42.474]                 }
[16:17:42.474]                 {
[16:17:42.474]                   {
[16:17:42.474]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.474]                     NULL
[16:17:42.474]                   }
[16:17:42.474]                   options(future.plan = NULL)
[16:17:42.474]                   if (is.na(NA_character_)) 
[16:17:42.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.474]                     .init = FALSE)
[16:17:42.474]                 }
[16:17:42.474]             }
[16:17:42.474]         }
[16:17:42.474]     })
[16:17:42.474]     if (TRUE) {
[16:17:42.474]         base::sink(type = "output", split = FALSE)
[16:17:42.474]         if (TRUE) {
[16:17:42.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.474]         }
[16:17:42.474]         else {
[16:17:42.474]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.474]         }
[16:17:42.474]         base::close(...future.stdout)
[16:17:42.474]         ...future.stdout <- NULL
[16:17:42.474]     }
[16:17:42.474]     ...future.result$conditions <- ...future.conditions
[16:17:42.474]     ...future.result$finished <- base::Sys.time()
[16:17:42.474]     ...future.result
[16:17:42.474] }
[16:17:42.476] assign_globals() ...
[16:17:42.476] List of 5
[16:17:42.476]  $ future.call.arguments    : list()
[16:17:42.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.476]  $ ...future.FUN            :function (x)  
[16:17:42.476]  $ ...future.elements_ii    :List of 1
[16:17:42.476]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:17:42.476]  $ ...future.seeds_ii       : NULL
[16:17:42.476]  $ ...future.globals.maxSize: num Inf
[16:17:42.476]  - attr(*, "resolved")= logi FALSE
[16:17:42.476]  - attr(*, "total_size")= num NA
[16:17:42.476]  - attr(*, "where")=List of 5
[16:17:42.476]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.476]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.476]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.476]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.476]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.476]  - attr(*, "already-done")= logi TRUE
[16:17:42.483] - copied ‘future.call.arguments’ to environment
[16:17:42.483] - copied ‘...future.FUN’ to environment
[16:17:42.483] - copied ‘...future.elements_ii’ to environment
[16:17:42.483] - copied ‘...future.seeds_ii’ to environment
[16:17:42.483] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.483] assign_globals() ... done
[16:17:42.483] requestCore(): workers = 2
[16:17:42.486] MulticoreFuture started
[16:17:42.486] - Launch lazy future ... done
[16:17:42.486] run() for ‘MulticoreFuture’ ... done
[16:17:42.487] Created future:
[16:17:42.487] plan(): Setting new future strategy stack:
[16:17:42.487] List of future strategies:
[16:17:42.487] 1. sequential:
[16:17:42.487]    - args: function (..., envir = parent.frame())
[16:17:42.487]    - tweaked: FALSE
[16:17:42.487]    - call: NULL
[16:17:42.488] plan(): nbrOfWorkers() = 1
[16:17:42.490] plan(): Setting new future strategy stack:
[16:17:42.490] List of future strategies:
[16:17:42.490] 1. multicore:
[16:17:42.490]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.490]    - tweaked: FALSE
[16:17:42.490]    - call: plan(strategy)
[16:17:42.495] plan(): nbrOfWorkers() = 2
[16:17:42.487] MulticoreFuture:
[16:17:42.487] Label: ‘future_apply-2’
[16:17:42.487] Expression:
[16:17:42.487] {
[16:17:42.487]     do.call(function(...) {
[16:17:42.487]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.487]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.487]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.487]             on.exit(options(oopts), add = TRUE)
[16:17:42.487]         }
[16:17:42.487]         {
[16:17:42.487]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.487]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.487]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.487]             })
[16:17:42.487]         }
[16:17:42.487]     }, args = future.call.arguments)
[16:17:42.487] }
[16:17:42.487] Lazy evaluation: FALSE
[16:17:42.487] Asynchronous evaluation: TRUE
[16:17:42.487] Local evaluation: TRUE
[16:17:42.487] Environment: R_GlobalEnv
[16:17:42.487] Capture standard output: TRUE
[16:17:42.487] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.487] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.487] Packages: <none>
[16:17:42.487] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.487] Resolved: TRUE
[16:17:42.487] Value: <not collected>
[16:17:42.487] Conditions captured: <none>
[16:17:42.487] Early signaling: FALSE
[16:17:42.487] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.487] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.496] Chunk #2 of 2 ... DONE
[16:17:42.496] Launching 2 futures (chunks) ... DONE
[16:17:42.496] Resolving 2 futures (chunks) ...
[16:17:42.497] resolve() on list ...
[16:17:42.497]  recursive: 0
[16:17:42.497]  length: 2
[16:17:42.497] 
[16:17:42.497] Future #1
[16:17:42.497] result() for MulticoreFuture ...
[16:17:42.498] result() for MulticoreFuture ...
[16:17:42.498] result() for MulticoreFuture ... done
[16:17:42.499] result() for MulticoreFuture ... done
[16:17:42.499] result() for MulticoreFuture ...
[16:17:42.499] result() for MulticoreFuture ... done
[16:17:42.499] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:42.499] - nx: 2
[16:17:42.499] - relay: TRUE
[16:17:42.500] - stdout: TRUE
[16:17:42.500] - signal: TRUE
[16:17:42.500] - resignal: FALSE
[16:17:42.500] - force: TRUE
[16:17:42.500] - relayed: [n=2] FALSE, FALSE
[16:17:42.500] - queued futures: [n=2] FALSE, FALSE
[16:17:42.500]  - until=1
[16:17:42.500]  - relaying element #1
[16:17:42.501] result() for MulticoreFuture ...
[16:17:42.501] result() for MulticoreFuture ... done
[16:17:42.501] result() for MulticoreFuture ...
[16:17:42.501] result() for MulticoreFuture ... done
[16:17:42.501] result() for MulticoreFuture ...
[16:17:42.501] result() for MulticoreFuture ... done
[16:17:42.502] result() for MulticoreFuture ...
[16:17:42.502] result() for MulticoreFuture ... done
[16:17:42.502] - relayed: [n=2] TRUE, FALSE
[16:17:42.502] - queued futures: [n=2] TRUE, FALSE
[16:17:42.502] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:42.502]  length: 1 (resolved future 1)
[16:17:42.503] Future #2
[16:17:42.503] result() for MulticoreFuture ...
[16:17:42.506] result() for MulticoreFuture ...
[16:17:42.506] result() for MulticoreFuture ... done
[16:17:42.507] result() for MulticoreFuture ... done
[16:17:42.507] result() for MulticoreFuture ...
[16:17:42.507] result() for MulticoreFuture ... done
[16:17:42.507] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:42.507] - nx: 2
[16:17:42.508] - relay: TRUE
[16:17:42.508] - stdout: TRUE
[16:17:42.508] - signal: TRUE
[16:17:42.508] - resignal: FALSE
[16:17:42.508] - force: TRUE
[16:17:42.508] - relayed: [n=2] TRUE, FALSE
[16:17:42.509] - queued futures: [n=2] TRUE, FALSE
[16:17:42.509]  - until=2
[16:17:42.509]  - relaying element #2
[16:17:42.509] result() for MulticoreFuture ...
[16:17:42.509] result() for MulticoreFuture ... done
[16:17:42.509] result() for MulticoreFuture ...
[16:17:42.510] result() for MulticoreFuture ... done
[16:17:42.510] result() for MulticoreFuture ...
[16:17:42.510] result() for MulticoreFuture ... done
[16:17:42.510] result() for MulticoreFuture ...
[16:17:42.510] result() for MulticoreFuture ... done
[16:17:42.510] - relayed: [n=2] TRUE, TRUE
[16:17:42.511] - queued futures: [n=2] TRUE, TRUE
[16:17:42.511] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:42.511]  length: 0 (resolved future 2)
[16:17:42.511] Relaying remaining futures
[16:17:42.511] signalConditionsASAP(NULL, pos=0) ...
[16:17:42.511] - nx: 2
[16:17:42.511] - relay: TRUE
[16:17:42.511] - stdout: TRUE
[16:17:42.512] - signal: TRUE
[16:17:42.512] - resignal: FALSE
[16:17:42.512] - force: TRUE
[16:17:42.512] - relayed: [n=2] TRUE, TRUE
[16:17:42.512] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:42.512] - relayed: [n=2] TRUE, TRUE
[16:17:42.512] - queued futures: [n=2] TRUE, TRUE
[16:17:42.512] signalConditionsASAP(NULL, pos=0) ... done
[16:17:42.512] resolve() on list ... DONE
[16:17:42.513] result() for MulticoreFuture ...
[16:17:42.513] result() for MulticoreFuture ... done
[16:17:42.513] result() for MulticoreFuture ...
[16:17:42.513] result() for MulticoreFuture ... done
[16:17:42.513] result() for MulticoreFuture ...
[16:17:42.513] result() for MulticoreFuture ... done
[16:17:42.513] result() for MulticoreFuture ...
[16:17:42.514] result() for MulticoreFuture ... done
[16:17:42.514]  - Number of value chunks collected: 2
[16:17:42.514] Resolving 2 futures (chunks) ... DONE
[16:17:42.514] Reducing values from 2 chunks ...
[16:17:42.514]  - Number of values collected after concatenation: 2
[16:17:42.514]  - Number of values expected: 2
[16:17:42.514] Reducing values from 2 chunks ... DONE
[16:17:42.514] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:17:42.515] getGlobalsAndPackagesXApply() ...
[16:17:42.515]  - future.globals: TRUE
[16:17:42.515] getGlobalsAndPackages() ...
[16:17:42.515] Searching for globals...
[16:17:42.516] - globals found: [1] ‘FUN’
[16:17:42.517] Searching for globals ... DONE
[16:17:42.517] Resolving globals: FALSE
[16:17:42.517] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:42.518] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:42.518] - globals: [1] ‘FUN’
[16:17:42.518] 
[16:17:42.518] getGlobalsAndPackages() ... DONE
[16:17:42.518]  - globals found/used: [n=1] ‘FUN’
[16:17:42.518]  - needed namespaces: [n=0] 
[16:17:42.518] Finding globals ... DONE
[16:17:42.518]  - use_args: TRUE
[16:17:42.518]  - Getting '...' globals ...
[16:17:42.519] resolve() on list ...
[16:17:42.519]  recursive: 0
[16:17:42.519]  length: 1
[16:17:42.519]  elements: ‘...’
[16:17:42.519]  length: 0 (resolved future 1)
[16:17:42.519] resolve() on list ... DONE
[16:17:42.519]    - '...' content: [n=0] 
[16:17:42.520] List of 1
[16:17:42.520]  $ ...: list()
[16:17:42.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.520]  - attr(*, "where")=List of 1
[16:17:42.520]   ..$ ...:<environment: 0x555be0c289a0> 
[16:17:42.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.520]  - attr(*, "resolved")= logi TRUE
[16:17:42.520]  - attr(*, "total_size")= num NA
[16:17:42.522]  - Getting '...' globals ... DONE
[16:17:42.523] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:42.523] List of 2
[16:17:42.523]  $ ...future.FUN:function (x)  
[16:17:42.523]  $ ...          : list()
[16:17:42.523]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.523]  - attr(*, "where")=List of 2
[16:17:42.523]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:42.523]   ..$ ...          :<environment: 0x555be0c289a0> 
[16:17:42.523]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.523]  - attr(*, "resolved")= logi FALSE
[16:17:42.523]  - attr(*, "total_size")= num 848
[16:17:42.526] Packages to be attached in all futures: [n=0] 
[16:17:42.526] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.529] future_lapply() ...
[16:17:42.533] Number of chunks: 2
[16:17:42.533] getGlobalsAndPackagesXApply() ...
[16:17:42.533]  - future.globals: <name-value list> with names ‘list()’
[16:17:42.533]  - use_args: TRUE
[16:17:42.534] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:42.534] List of 2
[16:17:42.534]  $ ...          : list()
[16:17:42.534]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.534]  $ ...future.FUN:function (x)  
[16:17:42.534]  - attr(*, "where")=List of 2
[16:17:42.534]   ..$ ...          :<environment: 0x555be0c289a0> 
[16:17:42.534]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:42.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.534]  - attr(*, "resolved")= logi FALSE
[16:17:42.534]  - attr(*, "total_size")= num NA
[16:17:42.538] Packages to be attached in all futures: [n=0] 
[16:17:42.538] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.539] Number of futures (= number of chunks): 2
[16:17:42.539] Launching 2 futures (chunks) ...
[16:17:42.539] Chunk #1 of 2 ...
[16:17:42.539]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.539]  - seeds: <none>
[16:17:42.539]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.539] getGlobalsAndPackages() ...
[16:17:42.540] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.540] Resolving globals: FALSE
[16:17:42.540] Tweak future expression to call with '...' arguments ...
[16:17:42.540] {
[16:17:42.540]     do.call(function(...) {
[16:17:42.540]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.540]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.540]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.540]             on.exit(options(oopts), add = TRUE)
[16:17:42.540]         }
[16:17:42.540]         {
[16:17:42.540]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.540]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.540]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.540]             })
[16:17:42.540]         }
[16:17:42.540]     }, args = future.call.arguments)
[16:17:42.540] }
[16:17:42.540] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.541] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.541] 
[16:17:42.541] getGlobalsAndPackages() ... DONE
[16:17:42.541] run() for ‘Future’ ...
[16:17:42.541] - state: ‘created’
[16:17:42.541] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.545] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.545]   - Field: ‘label’
[16:17:42.545]   - Field: ‘local’
[16:17:42.545]   - Field: ‘owner’
[16:17:42.545]   - Field: ‘envir’
[16:17:42.545]   - Field: ‘workers’
[16:17:42.545]   - Field: ‘packages’
[16:17:42.546]   - Field: ‘gc’
[16:17:42.546]   - Field: ‘job’
[16:17:42.546]   - Field: ‘conditions’
[16:17:42.546]   - Field: ‘expr’
[16:17:42.546]   - Field: ‘uuid’
[16:17:42.546]   - Field: ‘seed’
[16:17:42.546]   - Field: ‘version’
[16:17:42.546]   - Field: ‘result’
[16:17:42.546]   - Field: ‘asynchronous’
[16:17:42.546]   - Field: ‘calls’
[16:17:42.546]   - Field: ‘globals’
[16:17:42.547]   - Field: ‘stdout’
[16:17:42.547]   - Field: ‘earlySignal’
[16:17:42.547]   - Field: ‘lazy’
[16:17:42.547]   - Field: ‘state’
[16:17:42.547] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.547] - Launch lazy future ...
[16:17:42.547] Packages needed by the future expression (n = 0): <none>
[16:17:42.547] Packages needed by future strategies (n = 0): <none>
[16:17:42.548] {
[16:17:42.548]     {
[16:17:42.548]         {
[16:17:42.548]             ...future.startTime <- base::Sys.time()
[16:17:42.548]             {
[16:17:42.548]                 {
[16:17:42.548]                   {
[16:17:42.548]                     {
[16:17:42.548]                       base::local({
[16:17:42.548]                         has_future <- base::requireNamespace("future", 
[16:17:42.548]                           quietly = TRUE)
[16:17:42.548]                         if (has_future) {
[16:17:42.548]                           ns <- base::getNamespace("future")
[16:17:42.548]                           version <- ns[[".package"]][["version"]]
[16:17:42.548]                           if (is.null(version)) 
[16:17:42.548]                             version <- utils::packageVersion("future")
[16:17:42.548]                         }
[16:17:42.548]                         else {
[16:17:42.548]                           version <- NULL
[16:17:42.548]                         }
[16:17:42.548]                         if (!has_future || version < "1.8.0") {
[16:17:42.548]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.548]                             "", base::R.version$version.string), 
[16:17:42.548]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.548]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.548]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.548]                               "release", "version")], collapse = " "), 
[16:17:42.548]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.548]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.548]                             info)
[16:17:42.548]                           info <- base::paste(info, collapse = "; ")
[16:17:42.548]                           if (!has_future) {
[16:17:42.548]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.548]                               info)
[16:17:42.548]                           }
[16:17:42.548]                           else {
[16:17:42.548]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.548]                               info, version)
[16:17:42.548]                           }
[16:17:42.548]                           base::stop(msg)
[16:17:42.548]                         }
[16:17:42.548]                       })
[16:17:42.548]                     }
[16:17:42.548]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.548]                     base::options(mc.cores = 1L)
[16:17:42.548]                   }
[16:17:42.548]                   ...future.strategy.old <- future::plan("list")
[16:17:42.548]                   options(future.plan = NULL)
[16:17:42.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.548]                 }
[16:17:42.548]                 ...future.workdir <- getwd()
[16:17:42.548]             }
[16:17:42.548]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.548]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.548]         }
[16:17:42.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.548]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.548]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.548]             base::names(...future.oldOptions))
[16:17:42.548]     }
[16:17:42.548]     if (FALSE) {
[16:17:42.548]     }
[16:17:42.548]     else {
[16:17:42.548]         if (TRUE) {
[16:17:42.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.548]                 open = "w")
[16:17:42.548]         }
[16:17:42.548]         else {
[16:17:42.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.548]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.548]         }
[16:17:42.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.548]             base::sink(type = "output", split = FALSE)
[16:17:42.548]             base::close(...future.stdout)
[16:17:42.548]         }, add = TRUE)
[16:17:42.548]     }
[16:17:42.548]     ...future.frame <- base::sys.nframe()
[16:17:42.548]     ...future.conditions <- base::list()
[16:17:42.548]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.548]     if (FALSE) {
[16:17:42.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.548]     }
[16:17:42.548]     ...future.result <- base::tryCatch({
[16:17:42.548]         base::withCallingHandlers({
[16:17:42.548]             ...future.value <- base::withVisible(base::local({
[16:17:42.548]                 withCallingHandlers({
[16:17:42.548]                   {
[16:17:42.548]                     do.call(function(...) {
[16:17:42.548]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.548]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.548]                         ...future.globals.maxSize)) {
[16:17:42.548]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.548]                         on.exit(options(oopts), add = TRUE)
[16:17:42.548]                       }
[16:17:42.548]                       {
[16:17:42.548]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.548]                           FUN = function(jj) {
[16:17:42.548]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.548]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.548]                           })
[16:17:42.548]                       }
[16:17:42.548]                     }, args = future.call.arguments)
[16:17:42.548]                   }
[16:17:42.548]                 }, immediateCondition = function(cond) {
[16:17:42.548]                   save_rds <- function (object, pathname, ...) 
[16:17:42.548]                   {
[16:17:42.548]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.548]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.548]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.548]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.548]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.548]                         fi_tmp[["mtime"]])
[16:17:42.548]                     }
[16:17:42.548]                     tryCatch({
[16:17:42.548]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.548]                     }, error = function(ex) {
[16:17:42.548]                       msg <- conditionMessage(ex)
[16:17:42.548]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.548]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.548]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.548]                         fi_tmp[["mtime"]], msg)
[16:17:42.548]                       ex$message <- msg
[16:17:42.548]                       stop(ex)
[16:17:42.548]                     })
[16:17:42.548]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.548]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.548]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.548]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.548]                       fi <- file.info(pathname)
[16:17:42.548]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.548]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.548]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.548]                         fi[["size"]], fi[["mtime"]])
[16:17:42.548]                       stop(msg)
[16:17:42.548]                     }
[16:17:42.548]                     invisible(pathname)
[16:17:42.548]                   }
[16:17:42.548]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.548]                     rootPath = tempdir()) 
[16:17:42.548]                   {
[16:17:42.548]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.548]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.548]                       tmpdir = path, fileext = ".rds")
[16:17:42.548]                     save_rds(obj, file)
[16:17:42.548]                   }
[16:17:42.548]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.548]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.548]                   {
[16:17:42.548]                     inherits <- base::inherits
[16:17:42.548]                     invokeRestart <- base::invokeRestart
[16:17:42.548]                     is.null <- base::is.null
[16:17:42.548]                     muffled <- FALSE
[16:17:42.548]                     if (inherits(cond, "message")) {
[16:17:42.548]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.548]                       if (muffled) 
[16:17:42.548]                         invokeRestart("muffleMessage")
[16:17:42.548]                     }
[16:17:42.548]                     else if (inherits(cond, "warning")) {
[16:17:42.548]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.548]                       if (muffled) 
[16:17:42.548]                         invokeRestart("muffleWarning")
[16:17:42.548]                     }
[16:17:42.548]                     else if (inherits(cond, "condition")) {
[16:17:42.548]                       if (!is.null(pattern)) {
[16:17:42.548]                         computeRestarts <- base::computeRestarts
[16:17:42.548]                         grepl <- base::grepl
[16:17:42.548]                         restarts <- computeRestarts(cond)
[16:17:42.548]                         for (restart in restarts) {
[16:17:42.548]                           name <- restart$name
[16:17:42.548]                           if (is.null(name)) 
[16:17:42.548]                             next
[16:17:42.548]                           if (!grepl(pattern, name)) 
[16:17:42.548]                             next
[16:17:42.548]                           invokeRestart(restart)
[16:17:42.548]                           muffled <- TRUE
[16:17:42.548]                           break
[16:17:42.548]                         }
[16:17:42.548]                       }
[16:17:42.548]                     }
[16:17:42.548]                     invisible(muffled)
[16:17:42.548]                   }
[16:17:42.548]                   muffleCondition(cond)
[16:17:42.548]                 })
[16:17:42.548]             }))
[16:17:42.548]             future::FutureResult(value = ...future.value$value, 
[16:17:42.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.548]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.548]                     ...future.globalenv.names))
[16:17:42.548]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.548]         }, condition = base::local({
[16:17:42.548]             c <- base::c
[16:17:42.548]             inherits <- base::inherits
[16:17:42.548]             invokeRestart <- base::invokeRestart
[16:17:42.548]             length <- base::length
[16:17:42.548]             list <- base::list
[16:17:42.548]             seq.int <- base::seq.int
[16:17:42.548]             signalCondition <- base::signalCondition
[16:17:42.548]             sys.calls <- base::sys.calls
[16:17:42.548]             `[[` <- base::`[[`
[16:17:42.548]             `+` <- base::`+`
[16:17:42.548]             `<<-` <- base::`<<-`
[16:17:42.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.548]                   3L)]
[16:17:42.548]             }
[16:17:42.548]             function(cond) {
[16:17:42.548]                 is_error <- inherits(cond, "error")
[16:17:42.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.548]                   NULL)
[16:17:42.548]                 if (is_error) {
[16:17:42.548]                   sessionInformation <- function() {
[16:17:42.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.548]                       search = base::search(), system = base::Sys.info())
[16:17:42.548]                   }
[16:17:42.548]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.548]                     cond$call), session = sessionInformation(), 
[16:17:42.548]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.548]                   signalCondition(cond)
[16:17:42.548]                 }
[16:17:42.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.548]                 "immediateCondition"))) {
[16:17:42.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.548]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.548]                   if (TRUE && !signal) {
[16:17:42.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.548]                     {
[16:17:42.548]                       inherits <- base::inherits
[16:17:42.548]                       invokeRestart <- base::invokeRestart
[16:17:42.548]                       is.null <- base::is.null
[16:17:42.548]                       muffled <- FALSE
[16:17:42.548]                       if (inherits(cond, "message")) {
[16:17:42.548]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.548]                         if (muffled) 
[16:17:42.548]                           invokeRestart("muffleMessage")
[16:17:42.548]                       }
[16:17:42.548]                       else if (inherits(cond, "warning")) {
[16:17:42.548]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.548]                         if (muffled) 
[16:17:42.548]                           invokeRestart("muffleWarning")
[16:17:42.548]                       }
[16:17:42.548]                       else if (inherits(cond, "condition")) {
[16:17:42.548]                         if (!is.null(pattern)) {
[16:17:42.548]                           computeRestarts <- base::computeRestarts
[16:17:42.548]                           grepl <- base::grepl
[16:17:42.548]                           restarts <- computeRestarts(cond)
[16:17:42.548]                           for (restart in restarts) {
[16:17:42.548]                             name <- restart$name
[16:17:42.548]                             if (is.null(name)) 
[16:17:42.548]                               next
[16:17:42.548]                             if (!grepl(pattern, name)) 
[16:17:42.548]                               next
[16:17:42.548]                             invokeRestart(restart)
[16:17:42.548]                             muffled <- TRUE
[16:17:42.548]                             break
[16:17:42.548]                           }
[16:17:42.548]                         }
[16:17:42.548]                       }
[16:17:42.548]                       invisible(muffled)
[16:17:42.548]                     }
[16:17:42.548]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.548]                   }
[16:17:42.548]                 }
[16:17:42.548]                 else {
[16:17:42.548]                   if (TRUE) {
[16:17:42.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.548]                     {
[16:17:42.548]                       inherits <- base::inherits
[16:17:42.548]                       invokeRestart <- base::invokeRestart
[16:17:42.548]                       is.null <- base::is.null
[16:17:42.548]                       muffled <- FALSE
[16:17:42.548]                       if (inherits(cond, "message")) {
[16:17:42.548]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.548]                         if (muffled) 
[16:17:42.548]                           invokeRestart("muffleMessage")
[16:17:42.548]                       }
[16:17:42.548]                       else if (inherits(cond, "warning")) {
[16:17:42.548]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.548]                         if (muffled) 
[16:17:42.548]                           invokeRestart("muffleWarning")
[16:17:42.548]                       }
[16:17:42.548]                       else if (inherits(cond, "condition")) {
[16:17:42.548]                         if (!is.null(pattern)) {
[16:17:42.548]                           computeRestarts <- base::computeRestarts
[16:17:42.548]                           grepl <- base::grepl
[16:17:42.548]                           restarts <- computeRestarts(cond)
[16:17:42.548]                           for (restart in restarts) {
[16:17:42.548]                             name <- restart$name
[16:17:42.548]                             if (is.null(name)) 
[16:17:42.548]                               next
[16:17:42.548]                             if (!grepl(pattern, name)) 
[16:17:42.548]                               next
[16:17:42.548]                             invokeRestart(restart)
[16:17:42.548]                             muffled <- TRUE
[16:17:42.548]                             break
[16:17:42.548]                           }
[16:17:42.548]                         }
[16:17:42.548]                       }
[16:17:42.548]                       invisible(muffled)
[16:17:42.548]                     }
[16:17:42.548]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.548]                   }
[16:17:42.548]                 }
[16:17:42.548]             }
[16:17:42.548]         }))
[16:17:42.548]     }, error = function(ex) {
[16:17:42.548]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.548]                 ...future.rng), started = ...future.startTime, 
[16:17:42.548]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.548]             version = "1.8"), class = "FutureResult")
[16:17:42.548]     }, finally = {
[16:17:42.548]         if (!identical(...future.workdir, getwd())) 
[16:17:42.548]             setwd(...future.workdir)
[16:17:42.548]         {
[16:17:42.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.548]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.548]             }
[16:17:42.548]             base::options(...future.oldOptions)
[16:17:42.548]             if (.Platform$OS.type == "windows") {
[16:17:42.548]                 old_names <- names(...future.oldEnvVars)
[16:17:42.548]                 envs <- base::Sys.getenv()
[16:17:42.548]                 names <- names(envs)
[16:17:42.548]                 common <- intersect(names, old_names)
[16:17:42.548]                 added <- setdiff(names, old_names)
[16:17:42.548]                 removed <- setdiff(old_names, names)
[16:17:42.548]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.548]                   envs[common]]
[16:17:42.548]                 NAMES <- toupper(changed)
[16:17:42.548]                 args <- list()
[16:17:42.548]                 for (kk in seq_along(NAMES)) {
[16:17:42.548]                   name <- changed[[kk]]
[16:17:42.548]                   NAME <- NAMES[[kk]]
[16:17:42.548]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.548]                     next
[16:17:42.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.548]                 }
[16:17:42.548]                 NAMES <- toupper(added)
[16:17:42.548]                 for (kk in seq_along(NAMES)) {
[16:17:42.548]                   name <- added[[kk]]
[16:17:42.548]                   NAME <- NAMES[[kk]]
[16:17:42.548]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.548]                     next
[16:17:42.548]                   args[[name]] <- ""
[16:17:42.548]                 }
[16:17:42.548]                 NAMES <- toupper(removed)
[16:17:42.548]                 for (kk in seq_along(NAMES)) {
[16:17:42.548]                   name <- removed[[kk]]
[16:17:42.548]                   NAME <- NAMES[[kk]]
[16:17:42.548]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.548]                     next
[16:17:42.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.548]                 }
[16:17:42.548]                 if (length(args) > 0) 
[16:17:42.548]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.548]             }
[16:17:42.548]             else {
[16:17:42.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.548]             }
[16:17:42.548]             {
[16:17:42.548]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.548]                   0L) {
[16:17:42.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.548]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.548]                   base::options(opts)
[16:17:42.548]                 }
[16:17:42.548]                 {
[16:17:42.548]                   {
[16:17:42.548]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.548]                     NULL
[16:17:42.548]                   }
[16:17:42.548]                   options(future.plan = NULL)
[16:17:42.548]                   if (is.na(NA_character_)) 
[16:17:42.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.548]                     .init = FALSE)
[16:17:42.548]                 }
[16:17:42.548]             }
[16:17:42.548]         }
[16:17:42.548]     })
[16:17:42.548]     if (TRUE) {
[16:17:42.548]         base::sink(type = "output", split = FALSE)
[16:17:42.548]         if (TRUE) {
[16:17:42.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.548]         }
[16:17:42.548]         else {
[16:17:42.548]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.548]         }
[16:17:42.548]         base::close(...future.stdout)
[16:17:42.548]         ...future.stdout <- NULL
[16:17:42.548]     }
[16:17:42.548]     ...future.result$conditions <- ...future.conditions
[16:17:42.548]     ...future.result$finished <- base::Sys.time()
[16:17:42.548]     ...future.result
[16:17:42.548] }
[16:17:42.550] assign_globals() ...
[16:17:42.550] List of 5
[16:17:42.550]  $ future.call.arguments    : list()
[16:17:42.550]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.550]  $ ...future.FUN            :function (x)  
[16:17:42.550]  $ ...future.elements_ii    :List of 3
[16:17:42.550]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:17:42.550]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:17:42.550]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:17:42.550]  $ ...future.seeds_ii       : NULL
[16:17:42.550]  $ ...future.globals.maxSize: num Inf
[16:17:42.550]  - attr(*, "resolved")= logi FALSE
[16:17:42.550]  - attr(*, "total_size")= num NA
[16:17:42.550]  - attr(*, "where")=List of 5
[16:17:42.550]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.550]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.550]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.550]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.550]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.550]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.550]  - attr(*, "already-done")= logi TRUE
[16:17:42.555] - copied ‘future.call.arguments’ to environment
[16:17:42.556] - copied ‘...future.FUN’ to environment
[16:17:42.556] - copied ‘...future.elements_ii’ to environment
[16:17:42.556] - copied ‘...future.seeds_ii’ to environment
[16:17:42.556] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.556] assign_globals() ... done
[16:17:42.556] requestCore(): workers = 2
[16:17:42.558] MulticoreFuture started
[16:17:42.559] - Launch lazy future ... done
[16:17:42.559] run() for ‘MulticoreFuture’ ... done
[16:17:42.559] Created future:
[16:17:42.559] plan(): Setting new future strategy stack:
[16:17:42.559] List of future strategies:
[16:17:42.559] 1. sequential:
[16:17:42.559]    - args: function (..., envir = parent.frame())
[16:17:42.559]    - tweaked: FALSE
[16:17:42.559]    - call: NULL
[16:17:42.560] plan(): nbrOfWorkers() = 1
[16:17:42.562] plan(): Setting new future strategy stack:
[16:17:42.562] List of future strategies:
[16:17:42.562] 1. multicore:
[16:17:42.562]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.562]    - tweaked: FALSE
[16:17:42.562]    - call: plan(strategy)
[16:17:42.568] plan(): nbrOfWorkers() = 2
[16:17:42.559] MulticoreFuture:
[16:17:42.559] Label: ‘future_apply-1’
[16:17:42.559] Expression:
[16:17:42.559] {
[16:17:42.559]     do.call(function(...) {
[16:17:42.559]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.559]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.559]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.559]             on.exit(options(oopts), add = TRUE)
[16:17:42.559]         }
[16:17:42.559]         {
[16:17:42.559]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.559]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.559]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.559]             })
[16:17:42.559]         }
[16:17:42.559]     }, args = future.call.arguments)
[16:17:42.559] }
[16:17:42.559] Lazy evaluation: FALSE
[16:17:42.559] Asynchronous evaluation: TRUE
[16:17:42.559] Local evaluation: TRUE
[16:17:42.559] Environment: R_GlobalEnv
[16:17:42.559] Capture standard output: TRUE
[16:17:42.559] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.559] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.559] Packages: <none>
[16:17:42.559] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.559] Resolved: TRUE
[16:17:42.559] Value: <not collected>
[16:17:42.559] Conditions captured: <none>
[16:17:42.559] Early signaling: FALSE
[16:17:42.559] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.559] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.569] Chunk #1 of 2 ... DONE
[16:17:42.569] Chunk #2 of 2 ...
[16:17:42.569]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.569]  - seeds: <none>
[16:17:42.570]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.570] getGlobalsAndPackages() ...
[16:17:42.570] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.570] Resolving globals: FALSE
[16:17:42.570] Tweak future expression to call with '...' arguments ...
[16:17:42.570] {
[16:17:42.570]     do.call(function(...) {
[16:17:42.570]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.570]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.570]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.570]             on.exit(options(oopts), add = TRUE)
[16:17:42.570]         }
[16:17:42.570]         {
[16:17:42.570]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.570]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.570]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.570]             })
[16:17:42.570]         }
[16:17:42.570]     }, args = future.call.arguments)
[16:17:42.570] }
[16:17:42.571] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.571] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.572] 
[16:17:42.572] getGlobalsAndPackages() ... DONE
[16:17:42.572] run() for ‘Future’ ...
[16:17:42.572] - state: ‘created’
[16:17:42.573] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.583] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.583] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.583]   - Field: ‘label’
[16:17:42.583]   - Field: ‘local’
[16:17:42.584]   - Field: ‘owner’
[16:17:42.584]   - Field: ‘envir’
[16:17:42.584]   - Field: ‘workers’
[16:17:42.585]   - Field: ‘packages’
[16:17:42.585]   - Field: ‘gc’
[16:17:42.585]   - Field: ‘job’
[16:17:42.585]   - Field: ‘conditions’
[16:17:42.586]   - Field: ‘expr’
[16:17:42.586]   - Field: ‘uuid’
[16:17:42.586]   - Field: ‘seed’
[16:17:42.586]   - Field: ‘version’
[16:17:42.586]   - Field: ‘result’
[16:17:42.587]   - Field: ‘asynchronous’
[16:17:42.587]   - Field: ‘calls’
[16:17:42.587]   - Field: ‘globals’
[16:17:42.587]   - Field: ‘stdout’
[16:17:42.587]   - Field: ‘earlySignal’
[16:17:42.587]   - Field: ‘lazy’
[16:17:42.588]   - Field: ‘state’
[16:17:42.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.588] - Launch lazy future ...
[16:17:42.588] Packages needed by the future expression (n = 0): <none>
[16:17:42.589] Packages needed by future strategies (n = 0): <none>
[16:17:42.589] {
[16:17:42.589]     {
[16:17:42.589]         {
[16:17:42.589]             ...future.startTime <- base::Sys.time()
[16:17:42.589]             {
[16:17:42.589]                 {
[16:17:42.589]                   {
[16:17:42.589]                     {
[16:17:42.589]                       base::local({
[16:17:42.589]                         has_future <- base::requireNamespace("future", 
[16:17:42.589]                           quietly = TRUE)
[16:17:42.589]                         if (has_future) {
[16:17:42.589]                           ns <- base::getNamespace("future")
[16:17:42.589]                           version <- ns[[".package"]][["version"]]
[16:17:42.589]                           if (is.null(version)) 
[16:17:42.589]                             version <- utils::packageVersion("future")
[16:17:42.589]                         }
[16:17:42.589]                         else {
[16:17:42.589]                           version <- NULL
[16:17:42.589]                         }
[16:17:42.589]                         if (!has_future || version < "1.8.0") {
[16:17:42.589]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.589]                             "", base::R.version$version.string), 
[16:17:42.589]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.589]                               "release", "version")], collapse = " "), 
[16:17:42.589]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.589]                             info)
[16:17:42.589]                           info <- base::paste(info, collapse = "; ")
[16:17:42.589]                           if (!has_future) {
[16:17:42.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.589]                               info)
[16:17:42.589]                           }
[16:17:42.589]                           else {
[16:17:42.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.589]                               info, version)
[16:17:42.589]                           }
[16:17:42.589]                           base::stop(msg)
[16:17:42.589]                         }
[16:17:42.589]                       })
[16:17:42.589]                     }
[16:17:42.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.589]                     base::options(mc.cores = 1L)
[16:17:42.589]                   }
[16:17:42.589]                   ...future.strategy.old <- future::plan("list")
[16:17:42.589]                   options(future.plan = NULL)
[16:17:42.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.589]                 }
[16:17:42.589]                 ...future.workdir <- getwd()
[16:17:42.589]             }
[16:17:42.589]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.589]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.589]         }
[16:17:42.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.589]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.589]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.589]             base::names(...future.oldOptions))
[16:17:42.589]     }
[16:17:42.589]     if (FALSE) {
[16:17:42.589]     }
[16:17:42.589]     else {
[16:17:42.589]         if (TRUE) {
[16:17:42.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.589]                 open = "w")
[16:17:42.589]         }
[16:17:42.589]         else {
[16:17:42.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.589]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.589]         }
[16:17:42.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.589]             base::sink(type = "output", split = FALSE)
[16:17:42.589]             base::close(...future.stdout)
[16:17:42.589]         }, add = TRUE)
[16:17:42.589]     }
[16:17:42.589]     ...future.frame <- base::sys.nframe()
[16:17:42.589]     ...future.conditions <- base::list()
[16:17:42.589]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.589]     if (FALSE) {
[16:17:42.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.589]     }
[16:17:42.589]     ...future.result <- base::tryCatch({
[16:17:42.589]         base::withCallingHandlers({
[16:17:42.589]             ...future.value <- base::withVisible(base::local({
[16:17:42.589]                 withCallingHandlers({
[16:17:42.589]                   {
[16:17:42.589]                     do.call(function(...) {
[16:17:42.589]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.589]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.589]                         ...future.globals.maxSize)) {
[16:17:42.589]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.589]                         on.exit(options(oopts), add = TRUE)
[16:17:42.589]                       }
[16:17:42.589]                       {
[16:17:42.589]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.589]                           FUN = function(jj) {
[16:17:42.589]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.589]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.589]                           })
[16:17:42.589]                       }
[16:17:42.589]                     }, args = future.call.arguments)
[16:17:42.589]                   }
[16:17:42.589]                 }, immediateCondition = function(cond) {
[16:17:42.589]                   save_rds <- function (object, pathname, ...) 
[16:17:42.589]                   {
[16:17:42.589]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.589]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.589]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.589]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.589]                         fi_tmp[["mtime"]])
[16:17:42.589]                     }
[16:17:42.589]                     tryCatch({
[16:17:42.589]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.589]                     }, error = function(ex) {
[16:17:42.589]                       msg <- conditionMessage(ex)
[16:17:42.589]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.589]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.589]                         fi_tmp[["mtime"]], msg)
[16:17:42.589]                       ex$message <- msg
[16:17:42.589]                       stop(ex)
[16:17:42.589]                     })
[16:17:42.589]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.589]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.589]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.589]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.589]                       fi <- file.info(pathname)
[16:17:42.589]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.589]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.589]                         fi[["size"]], fi[["mtime"]])
[16:17:42.589]                       stop(msg)
[16:17:42.589]                     }
[16:17:42.589]                     invisible(pathname)
[16:17:42.589]                   }
[16:17:42.589]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.589]                     rootPath = tempdir()) 
[16:17:42.589]                   {
[16:17:42.589]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.589]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.589]                       tmpdir = path, fileext = ".rds")
[16:17:42.589]                     save_rds(obj, file)
[16:17:42.589]                   }
[16:17:42.589]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.589]                   {
[16:17:42.589]                     inherits <- base::inherits
[16:17:42.589]                     invokeRestart <- base::invokeRestart
[16:17:42.589]                     is.null <- base::is.null
[16:17:42.589]                     muffled <- FALSE
[16:17:42.589]                     if (inherits(cond, "message")) {
[16:17:42.589]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.589]                       if (muffled) 
[16:17:42.589]                         invokeRestart("muffleMessage")
[16:17:42.589]                     }
[16:17:42.589]                     else if (inherits(cond, "warning")) {
[16:17:42.589]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.589]                       if (muffled) 
[16:17:42.589]                         invokeRestart("muffleWarning")
[16:17:42.589]                     }
[16:17:42.589]                     else if (inherits(cond, "condition")) {
[16:17:42.589]                       if (!is.null(pattern)) {
[16:17:42.589]                         computeRestarts <- base::computeRestarts
[16:17:42.589]                         grepl <- base::grepl
[16:17:42.589]                         restarts <- computeRestarts(cond)
[16:17:42.589]                         for (restart in restarts) {
[16:17:42.589]                           name <- restart$name
[16:17:42.589]                           if (is.null(name)) 
[16:17:42.589]                             next
[16:17:42.589]                           if (!grepl(pattern, name)) 
[16:17:42.589]                             next
[16:17:42.589]                           invokeRestart(restart)
[16:17:42.589]                           muffled <- TRUE
[16:17:42.589]                           break
[16:17:42.589]                         }
[16:17:42.589]                       }
[16:17:42.589]                     }
[16:17:42.589]                     invisible(muffled)
[16:17:42.589]                   }
[16:17:42.589]                   muffleCondition(cond)
[16:17:42.589]                 })
[16:17:42.589]             }))
[16:17:42.589]             future::FutureResult(value = ...future.value$value, 
[16:17:42.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.589]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.589]                     ...future.globalenv.names))
[16:17:42.589]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.589]         }, condition = base::local({
[16:17:42.589]             c <- base::c
[16:17:42.589]             inherits <- base::inherits
[16:17:42.589]             invokeRestart <- base::invokeRestart
[16:17:42.589]             length <- base::length
[16:17:42.589]             list <- base::list
[16:17:42.589]             seq.int <- base::seq.int
[16:17:42.589]             signalCondition <- base::signalCondition
[16:17:42.589]             sys.calls <- base::sys.calls
[16:17:42.589]             `[[` <- base::`[[`
[16:17:42.589]             `+` <- base::`+`
[16:17:42.589]             `<<-` <- base::`<<-`
[16:17:42.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.589]                   3L)]
[16:17:42.589]             }
[16:17:42.589]             function(cond) {
[16:17:42.589]                 is_error <- inherits(cond, "error")
[16:17:42.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.589]                   NULL)
[16:17:42.589]                 if (is_error) {
[16:17:42.589]                   sessionInformation <- function() {
[16:17:42.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.589]                       search = base::search(), system = base::Sys.info())
[16:17:42.589]                   }
[16:17:42.589]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.589]                     cond$call), session = sessionInformation(), 
[16:17:42.589]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.589]                   signalCondition(cond)
[16:17:42.589]                 }
[16:17:42.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.589]                 "immediateCondition"))) {
[16:17:42.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.589]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.589]                   if (TRUE && !signal) {
[16:17:42.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.589]                     {
[16:17:42.589]                       inherits <- base::inherits
[16:17:42.589]                       invokeRestart <- base::invokeRestart
[16:17:42.589]                       is.null <- base::is.null
[16:17:42.589]                       muffled <- FALSE
[16:17:42.589]                       if (inherits(cond, "message")) {
[16:17:42.589]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.589]                         if (muffled) 
[16:17:42.589]                           invokeRestart("muffleMessage")
[16:17:42.589]                       }
[16:17:42.589]                       else if (inherits(cond, "warning")) {
[16:17:42.589]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.589]                         if (muffled) 
[16:17:42.589]                           invokeRestart("muffleWarning")
[16:17:42.589]                       }
[16:17:42.589]                       else if (inherits(cond, "condition")) {
[16:17:42.589]                         if (!is.null(pattern)) {
[16:17:42.589]                           computeRestarts <- base::computeRestarts
[16:17:42.589]                           grepl <- base::grepl
[16:17:42.589]                           restarts <- computeRestarts(cond)
[16:17:42.589]                           for (restart in restarts) {
[16:17:42.589]                             name <- restart$name
[16:17:42.589]                             if (is.null(name)) 
[16:17:42.589]                               next
[16:17:42.589]                             if (!grepl(pattern, name)) 
[16:17:42.589]                               next
[16:17:42.589]                             invokeRestart(restart)
[16:17:42.589]                             muffled <- TRUE
[16:17:42.589]                             break
[16:17:42.589]                           }
[16:17:42.589]                         }
[16:17:42.589]                       }
[16:17:42.589]                       invisible(muffled)
[16:17:42.589]                     }
[16:17:42.589]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.589]                   }
[16:17:42.589]                 }
[16:17:42.589]                 else {
[16:17:42.589]                   if (TRUE) {
[16:17:42.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.589]                     {
[16:17:42.589]                       inherits <- base::inherits
[16:17:42.589]                       invokeRestart <- base::invokeRestart
[16:17:42.589]                       is.null <- base::is.null
[16:17:42.589]                       muffled <- FALSE
[16:17:42.589]                       if (inherits(cond, "message")) {
[16:17:42.589]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.589]                         if (muffled) 
[16:17:42.589]                           invokeRestart("muffleMessage")
[16:17:42.589]                       }
[16:17:42.589]                       else if (inherits(cond, "warning")) {
[16:17:42.589]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.589]                         if (muffled) 
[16:17:42.589]                           invokeRestart("muffleWarning")
[16:17:42.589]                       }
[16:17:42.589]                       else if (inherits(cond, "condition")) {
[16:17:42.589]                         if (!is.null(pattern)) {
[16:17:42.589]                           computeRestarts <- base::computeRestarts
[16:17:42.589]                           grepl <- base::grepl
[16:17:42.589]                           restarts <- computeRestarts(cond)
[16:17:42.589]                           for (restart in restarts) {
[16:17:42.589]                             name <- restart$name
[16:17:42.589]                             if (is.null(name)) 
[16:17:42.589]                               next
[16:17:42.589]                             if (!grepl(pattern, name)) 
[16:17:42.589]                               next
[16:17:42.589]                             invokeRestart(restart)
[16:17:42.589]                             muffled <- TRUE
[16:17:42.589]                             break
[16:17:42.589]                           }
[16:17:42.589]                         }
[16:17:42.589]                       }
[16:17:42.589]                       invisible(muffled)
[16:17:42.589]                     }
[16:17:42.589]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.589]                   }
[16:17:42.589]                 }
[16:17:42.589]             }
[16:17:42.589]         }))
[16:17:42.589]     }, error = function(ex) {
[16:17:42.589]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.589]                 ...future.rng), started = ...future.startTime, 
[16:17:42.589]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.589]             version = "1.8"), class = "FutureResult")
[16:17:42.589]     }, finally = {
[16:17:42.589]         if (!identical(...future.workdir, getwd())) 
[16:17:42.589]             setwd(...future.workdir)
[16:17:42.589]         {
[16:17:42.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.589]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.589]             }
[16:17:42.589]             base::options(...future.oldOptions)
[16:17:42.589]             if (.Platform$OS.type == "windows") {
[16:17:42.589]                 old_names <- names(...future.oldEnvVars)
[16:17:42.589]                 envs <- base::Sys.getenv()
[16:17:42.589]                 names <- names(envs)
[16:17:42.589]                 common <- intersect(names, old_names)
[16:17:42.589]                 added <- setdiff(names, old_names)
[16:17:42.589]                 removed <- setdiff(old_names, names)
[16:17:42.589]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.589]                   envs[common]]
[16:17:42.589]                 NAMES <- toupper(changed)
[16:17:42.589]                 args <- list()
[16:17:42.589]                 for (kk in seq_along(NAMES)) {
[16:17:42.589]                   name <- changed[[kk]]
[16:17:42.589]                   NAME <- NAMES[[kk]]
[16:17:42.589]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.589]                     next
[16:17:42.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.589]                 }
[16:17:42.589]                 NAMES <- toupper(added)
[16:17:42.589]                 for (kk in seq_along(NAMES)) {
[16:17:42.589]                   name <- added[[kk]]
[16:17:42.589]                   NAME <- NAMES[[kk]]
[16:17:42.589]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.589]                     next
[16:17:42.589]                   args[[name]] <- ""
[16:17:42.589]                 }
[16:17:42.589]                 NAMES <- toupper(removed)
[16:17:42.589]                 for (kk in seq_along(NAMES)) {
[16:17:42.589]                   name <- removed[[kk]]
[16:17:42.589]                   NAME <- NAMES[[kk]]
[16:17:42.589]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.589]                     next
[16:17:42.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.589]                 }
[16:17:42.589]                 if (length(args) > 0) 
[16:17:42.589]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.589]             }
[16:17:42.589]             else {
[16:17:42.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.589]             }
[16:17:42.589]             {
[16:17:42.589]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.589]                   0L) {
[16:17:42.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.589]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.589]                   base::options(opts)
[16:17:42.589]                 }
[16:17:42.589]                 {
[16:17:42.589]                   {
[16:17:42.589]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.589]                     NULL
[16:17:42.589]                   }
[16:17:42.589]                   options(future.plan = NULL)
[16:17:42.589]                   if (is.na(NA_character_)) 
[16:17:42.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.589]                     .init = FALSE)
[16:17:42.589]                 }
[16:17:42.589]             }
[16:17:42.589]         }
[16:17:42.589]     })
[16:17:42.589]     if (TRUE) {
[16:17:42.589]         base::sink(type = "output", split = FALSE)
[16:17:42.589]         if (TRUE) {
[16:17:42.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.589]         }
[16:17:42.589]         else {
[16:17:42.589]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.589]         }
[16:17:42.589]         base::close(...future.stdout)
[16:17:42.589]         ...future.stdout <- NULL
[16:17:42.589]     }
[16:17:42.589]     ...future.result$conditions <- ...future.conditions
[16:17:42.589]     ...future.result$finished <- base::Sys.time()
[16:17:42.589]     ...future.result
[16:17:42.589] }
[16:17:42.592] assign_globals() ...
[16:17:42.593] List of 5
[16:17:42.593]  $ future.call.arguments    : list()
[16:17:42.593]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.593]  $ ...future.FUN            :function (x)  
[16:17:42.593]  $ ...future.elements_ii    :List of 3
[16:17:42.593]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:17:42.593]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:17:42.593]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:17:42.593]  $ ...future.seeds_ii       : NULL
[16:17:42.593]  $ ...future.globals.maxSize: num Inf
[16:17:42.593]  - attr(*, "resolved")= logi FALSE
[16:17:42.593]  - attr(*, "total_size")= num NA
[16:17:42.593]  - attr(*, "where")=List of 5
[16:17:42.593]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.593]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.593]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.593]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.593]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.593]  - attr(*, "already-done")= logi TRUE
[16:17:42.600] - copied ‘future.call.arguments’ to environment
[16:17:42.600] - copied ‘...future.FUN’ to environment
[16:17:42.600] - copied ‘...future.elements_ii’ to environment
[16:17:42.601] - copied ‘...future.seeds_ii’ to environment
[16:17:42.601] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.601] assign_globals() ... done
[16:17:42.601] requestCore(): workers = 2
[16:17:42.603] MulticoreFuture started
[16:17:42.604] - Launch lazy future ... done
[16:17:42.604] run() for ‘MulticoreFuture’ ... done
[16:17:42.604] Created future:
[16:17:42.604] plan(): Setting new future strategy stack:
[16:17:42.605] List of future strategies:
[16:17:42.605] 1. sequential:
[16:17:42.605]    - args: function (..., envir = parent.frame())
[16:17:42.605]    - tweaked: FALSE
[16:17:42.605]    - call: NULL
[16:17:42.605] plan(): nbrOfWorkers() = 1
[16:17:42.607] plan(): Setting new future strategy stack:
[16:17:42.608] List of future strategies:
[16:17:42.608] 1. multicore:
[16:17:42.608]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.608]    - tweaked: FALSE
[16:17:42.608]    - call: plan(strategy)
[16:17:42.613] plan(): nbrOfWorkers() = 2
[16:17:42.604] MulticoreFuture:
[16:17:42.604] Label: ‘future_apply-2’
[16:17:42.604] Expression:
[16:17:42.604] {
[16:17:42.604]     do.call(function(...) {
[16:17:42.604]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.604]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.604]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.604]             on.exit(options(oopts), add = TRUE)
[16:17:42.604]         }
[16:17:42.604]         {
[16:17:42.604]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.604]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.604]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.604]             })
[16:17:42.604]         }
[16:17:42.604]     }, args = future.call.arguments)
[16:17:42.604] }
[16:17:42.604] Lazy evaluation: FALSE
[16:17:42.604] Asynchronous evaluation: TRUE
[16:17:42.604] Local evaluation: TRUE
[16:17:42.604] Environment: R_GlobalEnv
[16:17:42.604] Capture standard output: TRUE
[16:17:42.604] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.604] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.604] Packages: <none>
[16:17:42.604] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.604] Resolved: TRUE
[16:17:42.604] Value: <not collected>
[16:17:42.604] Conditions captured: <none>
[16:17:42.604] Early signaling: FALSE
[16:17:42.604] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.604] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.614] Chunk #2 of 2 ... DONE
[16:17:42.614] Launching 2 futures (chunks) ... DONE
[16:17:42.614] Resolving 2 futures (chunks) ...
[16:17:42.615] resolve() on list ...
[16:17:42.615]  recursive: 0
[16:17:42.615]  length: 2
[16:17:42.615] 
[16:17:42.616] Future #1
[16:17:42.616] result() for MulticoreFuture ...
[16:17:42.617] result() for MulticoreFuture ...
[16:17:42.617] result() for MulticoreFuture ... done
[16:17:42.617] result() for MulticoreFuture ... done
[16:17:42.617] result() for MulticoreFuture ...
[16:17:42.617] result() for MulticoreFuture ... done
[16:17:42.617] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:42.618] - nx: 2
[16:17:42.618] - relay: TRUE
[16:17:42.618] - stdout: TRUE
[16:17:42.618] - signal: TRUE
[16:17:42.618] - resignal: FALSE
[16:17:42.618] - force: TRUE
[16:17:42.618] - relayed: [n=2] FALSE, FALSE
[16:17:42.618] - queued futures: [n=2] FALSE, FALSE
[16:17:42.619]  - until=1
[16:17:42.619]  - relaying element #1
[16:17:42.619] result() for MulticoreFuture ...
[16:17:42.619] result() for MulticoreFuture ... done
[16:17:42.619] result() for MulticoreFuture ...
[16:17:42.619] result() for MulticoreFuture ... done
[16:17:42.619] result() for MulticoreFuture ...
[16:17:42.620] result() for MulticoreFuture ... done
[16:17:42.620] result() for MulticoreFuture ...
[16:17:42.620] result() for MulticoreFuture ... done
[16:17:42.620] - relayed: [n=2] TRUE, FALSE
[16:17:42.620] - queued futures: [n=2] TRUE, FALSE
[16:17:42.620] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:42.621]  length: 1 (resolved future 1)
[16:17:42.621] Future #2
[16:17:42.621] result() for MulticoreFuture ...
[16:17:42.622] result() for MulticoreFuture ...
[16:17:42.622] result() for MulticoreFuture ... done
[16:17:42.622] result() for MulticoreFuture ... done
[16:17:42.622] result() for MulticoreFuture ...
[16:17:42.622] result() for MulticoreFuture ... done
[16:17:42.622] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:42.623] - nx: 2
[16:17:42.623] - relay: TRUE
[16:17:42.623] - stdout: TRUE
[16:17:42.623] - signal: TRUE
[16:17:42.623] - resignal: FALSE
[16:17:42.623] - force: TRUE
[16:17:42.623] - relayed: [n=2] TRUE, FALSE
[16:17:42.623] - queued futures: [n=2] TRUE, FALSE
[16:17:42.624]  - until=2
[16:17:42.624]  - relaying element #2
[16:17:42.624] result() for MulticoreFuture ...
[16:17:42.624] result() for MulticoreFuture ... done
[16:17:42.624] result() for MulticoreFuture ...
[16:17:42.624] result() for MulticoreFuture ... done
[16:17:42.624] result() for MulticoreFuture ...
[16:17:42.624] result() for MulticoreFuture ... done
[16:17:42.625] result() for MulticoreFuture ...
[16:17:42.627] result() for MulticoreFuture ... done
[16:17:42.627] - relayed: [n=2] TRUE, TRUE
[16:17:42.627] - queued futures: [n=2] TRUE, TRUE
[16:17:42.628] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:42.628]  length: 0 (resolved future 2)
[16:17:42.628] Relaying remaining futures
[16:17:42.628] signalConditionsASAP(NULL, pos=0) ...
[16:17:42.628] - nx: 2
[16:17:42.628] - relay: TRUE
[16:17:42.629] - stdout: TRUE
[16:17:42.629] - signal: TRUE
[16:17:42.629] - resignal: FALSE
[16:17:42.629] - force: TRUE
[16:17:42.629] - relayed: [n=2] TRUE, TRUE
[16:17:42.629] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:42.629] - relayed: [n=2] TRUE, TRUE
[16:17:42.630] - queued futures: [n=2] TRUE, TRUE
[16:17:42.630] signalConditionsASAP(NULL, pos=0) ... done
[16:17:42.630] resolve() on list ... DONE
[16:17:42.630] result() for MulticoreFuture ...
[16:17:42.630] result() for MulticoreFuture ... done
[16:17:42.631] result() for MulticoreFuture ...
[16:17:42.631] result() for MulticoreFuture ... done
[16:17:42.631] result() for MulticoreFuture ...
[16:17:42.631] result() for MulticoreFuture ... done
[16:17:42.631] result() for MulticoreFuture ...
[16:17:42.631] result() for MulticoreFuture ... done
[16:17:42.631]  - Number of value chunks collected: 2
[16:17:42.632] Resolving 2 futures (chunks) ... DONE
[16:17:42.632] Reducing values from 2 chunks ...
[16:17:42.632]  - Number of values collected after concatenation: 6
[16:17:42.632]  - Number of values expected: 6
[16:17:42.632] Reducing values from 2 chunks ... DONE
[16:17:42.632] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:17:42.633] getGlobalsAndPackagesXApply() ...
[16:17:42.633]  - future.globals: TRUE
[16:17:42.633] getGlobalsAndPackages() ...
[16:17:42.633] Searching for globals...
[16:17:42.635] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:17:42.635] Searching for globals ... DONE
[16:17:42.635] Resolving globals: FALSE
[16:17:42.636] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:17:42.636] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:17:42.636] - globals: [1] ‘FUN’
[16:17:42.636] 
[16:17:42.636] getGlobalsAndPackages() ... DONE
[16:17:42.637]  - globals found/used: [n=1] ‘FUN’
[16:17:42.637]  - needed namespaces: [n=0] 
[16:17:42.637] Finding globals ... DONE
[16:17:42.637]  - use_args: TRUE
[16:17:42.637]  - Getting '...' globals ...
[16:17:42.637] resolve() on list ...
[16:17:42.638]  recursive: 0
[16:17:42.638]  length: 1
[16:17:42.638]  elements: ‘...’
[16:17:42.638]  length: 0 (resolved future 1)
[16:17:42.638] resolve() on list ... DONE
[16:17:42.638]    - '...' content: [n=0] 
[16:17:42.638] List of 1
[16:17:42.638]  $ ...: list()
[16:17:42.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.638]  - attr(*, "where")=List of 1
[16:17:42.638]   ..$ ...:<environment: 0x555be187da28> 
[16:17:42.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.638]  - attr(*, "resolved")= logi TRUE
[16:17:42.638]  - attr(*, "total_size")= num NA
[16:17:42.641]  - Getting '...' globals ... DONE
[16:17:42.641] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:42.641] List of 2
[16:17:42.641]  $ ...future.FUN:function (x)  
[16:17:42.641]  $ ...          : list()
[16:17:42.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.641]  - attr(*, "where")=List of 2
[16:17:42.641]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:42.641]   ..$ ...          :<environment: 0x555be187da28> 
[16:17:42.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.641]  - attr(*, "resolved")= logi FALSE
[16:17:42.641]  - attr(*, "total_size")= num 1768
[16:17:42.644] Packages to be attached in all futures: [n=0] 
[16:17:42.644] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.648] future_lapply() ...
[16:17:42.652] Number of chunks: 2
[16:17:42.652] getGlobalsAndPackagesXApply() ...
[16:17:42.652]  - future.globals: <name-value list> with names ‘list()’
[16:17:42.652]  - use_args: TRUE
[16:17:42.652] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:42.652] List of 2
[16:17:42.652]  $ ...          : list()
[16:17:42.652]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.652]  $ ...future.FUN:function (x)  
[16:17:42.652]  - attr(*, "where")=List of 2
[16:17:42.652]   ..$ ...          :<environment: 0x555be187da28> 
[16:17:42.652]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:17:42.652]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.652]  - attr(*, "resolved")= logi FALSE
[16:17:42.652]  - attr(*, "total_size")= num NA
[16:17:42.658] Packages to be attached in all futures: [n=0] 
[16:17:42.658] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.658] Number of futures (= number of chunks): 2
[16:17:42.658] Launching 2 futures (chunks) ...
[16:17:42.658] Chunk #1 of 2 ...
[16:17:42.659]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.659]  - seeds: <none>
[16:17:42.659]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.659] getGlobalsAndPackages() ...
[16:17:42.659] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.659] Resolving globals: FALSE
[16:17:42.659] Tweak future expression to call with '...' arguments ...
[16:17:42.659] {
[16:17:42.659]     do.call(function(...) {
[16:17:42.659]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.659]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.659]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.659]             on.exit(options(oopts), add = TRUE)
[16:17:42.659]         }
[16:17:42.659]         {
[16:17:42.659]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.659]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.659]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.659]             })
[16:17:42.659]         }
[16:17:42.659]     }, args = future.call.arguments)
[16:17:42.659] }
[16:17:42.660] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.660] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.660] 
[16:17:42.660] getGlobalsAndPackages() ... DONE
[16:17:42.661] run() for ‘Future’ ...
[16:17:42.661] - state: ‘created’
[16:17:42.661] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.665] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.665] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.666]   - Field: ‘label’
[16:17:42.666]   - Field: ‘local’
[16:17:42.666]   - Field: ‘owner’
[16:17:42.666]   - Field: ‘envir’
[16:17:42.666]   - Field: ‘workers’
[16:17:42.666]   - Field: ‘packages’
[16:17:42.666]   - Field: ‘gc’
[16:17:42.666]   - Field: ‘job’
[16:17:42.666]   - Field: ‘conditions’
[16:17:42.666]   - Field: ‘expr’
[16:17:42.667]   - Field: ‘uuid’
[16:17:42.667]   - Field: ‘seed’
[16:17:42.667]   - Field: ‘version’
[16:17:42.667]   - Field: ‘result’
[16:17:42.667]   - Field: ‘asynchronous’
[16:17:42.667]   - Field: ‘calls’
[16:17:42.667]   - Field: ‘globals’
[16:17:42.667]   - Field: ‘stdout’
[16:17:42.667]   - Field: ‘earlySignal’
[16:17:42.667]   - Field: ‘lazy’
[16:17:42.667]   - Field: ‘state’
[16:17:42.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.668] - Launch lazy future ...
[16:17:42.668] Packages needed by the future expression (n = 0): <none>
[16:17:42.668] Packages needed by future strategies (n = 0): <none>
[16:17:42.669] {
[16:17:42.669]     {
[16:17:42.669]         {
[16:17:42.669]             ...future.startTime <- base::Sys.time()
[16:17:42.669]             {
[16:17:42.669]                 {
[16:17:42.669]                   {
[16:17:42.669]                     {
[16:17:42.669]                       base::local({
[16:17:42.669]                         has_future <- base::requireNamespace("future", 
[16:17:42.669]                           quietly = TRUE)
[16:17:42.669]                         if (has_future) {
[16:17:42.669]                           ns <- base::getNamespace("future")
[16:17:42.669]                           version <- ns[[".package"]][["version"]]
[16:17:42.669]                           if (is.null(version)) 
[16:17:42.669]                             version <- utils::packageVersion("future")
[16:17:42.669]                         }
[16:17:42.669]                         else {
[16:17:42.669]                           version <- NULL
[16:17:42.669]                         }
[16:17:42.669]                         if (!has_future || version < "1.8.0") {
[16:17:42.669]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.669]                             "", base::R.version$version.string), 
[16:17:42.669]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.669]                               "release", "version")], collapse = " "), 
[16:17:42.669]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.669]                             info)
[16:17:42.669]                           info <- base::paste(info, collapse = "; ")
[16:17:42.669]                           if (!has_future) {
[16:17:42.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.669]                               info)
[16:17:42.669]                           }
[16:17:42.669]                           else {
[16:17:42.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.669]                               info, version)
[16:17:42.669]                           }
[16:17:42.669]                           base::stop(msg)
[16:17:42.669]                         }
[16:17:42.669]                       })
[16:17:42.669]                     }
[16:17:42.669]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.669]                     base::options(mc.cores = 1L)
[16:17:42.669]                   }
[16:17:42.669]                   ...future.strategy.old <- future::plan("list")
[16:17:42.669]                   options(future.plan = NULL)
[16:17:42.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.669]                 }
[16:17:42.669]                 ...future.workdir <- getwd()
[16:17:42.669]             }
[16:17:42.669]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.669]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.669]         }
[16:17:42.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.669]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.669]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.669]             base::names(...future.oldOptions))
[16:17:42.669]     }
[16:17:42.669]     if (FALSE) {
[16:17:42.669]     }
[16:17:42.669]     else {
[16:17:42.669]         if (TRUE) {
[16:17:42.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.669]                 open = "w")
[16:17:42.669]         }
[16:17:42.669]         else {
[16:17:42.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.669]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.669]         }
[16:17:42.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.669]             base::sink(type = "output", split = FALSE)
[16:17:42.669]             base::close(...future.stdout)
[16:17:42.669]         }, add = TRUE)
[16:17:42.669]     }
[16:17:42.669]     ...future.frame <- base::sys.nframe()
[16:17:42.669]     ...future.conditions <- base::list()
[16:17:42.669]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.669]     if (FALSE) {
[16:17:42.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.669]     }
[16:17:42.669]     ...future.result <- base::tryCatch({
[16:17:42.669]         base::withCallingHandlers({
[16:17:42.669]             ...future.value <- base::withVisible(base::local({
[16:17:42.669]                 withCallingHandlers({
[16:17:42.669]                   {
[16:17:42.669]                     do.call(function(...) {
[16:17:42.669]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.669]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.669]                         ...future.globals.maxSize)) {
[16:17:42.669]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.669]                         on.exit(options(oopts), add = TRUE)
[16:17:42.669]                       }
[16:17:42.669]                       {
[16:17:42.669]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.669]                           FUN = function(jj) {
[16:17:42.669]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.669]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.669]                           })
[16:17:42.669]                       }
[16:17:42.669]                     }, args = future.call.arguments)
[16:17:42.669]                   }
[16:17:42.669]                 }, immediateCondition = function(cond) {
[16:17:42.669]                   save_rds <- function (object, pathname, ...) 
[16:17:42.669]                   {
[16:17:42.669]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.669]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.669]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.669]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.669]                         fi_tmp[["mtime"]])
[16:17:42.669]                     }
[16:17:42.669]                     tryCatch({
[16:17:42.669]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.669]                     }, error = function(ex) {
[16:17:42.669]                       msg <- conditionMessage(ex)
[16:17:42.669]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.669]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.669]                         fi_tmp[["mtime"]], msg)
[16:17:42.669]                       ex$message <- msg
[16:17:42.669]                       stop(ex)
[16:17:42.669]                     })
[16:17:42.669]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.669]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.669]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.669]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.669]                       fi <- file.info(pathname)
[16:17:42.669]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.669]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.669]                         fi[["size"]], fi[["mtime"]])
[16:17:42.669]                       stop(msg)
[16:17:42.669]                     }
[16:17:42.669]                     invisible(pathname)
[16:17:42.669]                   }
[16:17:42.669]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.669]                     rootPath = tempdir()) 
[16:17:42.669]                   {
[16:17:42.669]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.669]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.669]                       tmpdir = path, fileext = ".rds")
[16:17:42.669]                     save_rds(obj, file)
[16:17:42.669]                   }
[16:17:42.669]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.669]                   {
[16:17:42.669]                     inherits <- base::inherits
[16:17:42.669]                     invokeRestart <- base::invokeRestart
[16:17:42.669]                     is.null <- base::is.null
[16:17:42.669]                     muffled <- FALSE
[16:17:42.669]                     if (inherits(cond, "message")) {
[16:17:42.669]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.669]                       if (muffled) 
[16:17:42.669]                         invokeRestart("muffleMessage")
[16:17:42.669]                     }
[16:17:42.669]                     else if (inherits(cond, "warning")) {
[16:17:42.669]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.669]                       if (muffled) 
[16:17:42.669]                         invokeRestart("muffleWarning")
[16:17:42.669]                     }
[16:17:42.669]                     else if (inherits(cond, "condition")) {
[16:17:42.669]                       if (!is.null(pattern)) {
[16:17:42.669]                         computeRestarts <- base::computeRestarts
[16:17:42.669]                         grepl <- base::grepl
[16:17:42.669]                         restarts <- computeRestarts(cond)
[16:17:42.669]                         for (restart in restarts) {
[16:17:42.669]                           name <- restart$name
[16:17:42.669]                           if (is.null(name)) 
[16:17:42.669]                             next
[16:17:42.669]                           if (!grepl(pattern, name)) 
[16:17:42.669]                             next
[16:17:42.669]                           invokeRestart(restart)
[16:17:42.669]                           muffled <- TRUE
[16:17:42.669]                           break
[16:17:42.669]                         }
[16:17:42.669]                       }
[16:17:42.669]                     }
[16:17:42.669]                     invisible(muffled)
[16:17:42.669]                   }
[16:17:42.669]                   muffleCondition(cond)
[16:17:42.669]                 })
[16:17:42.669]             }))
[16:17:42.669]             future::FutureResult(value = ...future.value$value, 
[16:17:42.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.669]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.669]                     ...future.globalenv.names))
[16:17:42.669]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.669]         }, condition = base::local({
[16:17:42.669]             c <- base::c
[16:17:42.669]             inherits <- base::inherits
[16:17:42.669]             invokeRestart <- base::invokeRestart
[16:17:42.669]             length <- base::length
[16:17:42.669]             list <- base::list
[16:17:42.669]             seq.int <- base::seq.int
[16:17:42.669]             signalCondition <- base::signalCondition
[16:17:42.669]             sys.calls <- base::sys.calls
[16:17:42.669]             `[[` <- base::`[[`
[16:17:42.669]             `+` <- base::`+`
[16:17:42.669]             `<<-` <- base::`<<-`
[16:17:42.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.669]                   3L)]
[16:17:42.669]             }
[16:17:42.669]             function(cond) {
[16:17:42.669]                 is_error <- inherits(cond, "error")
[16:17:42.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.669]                   NULL)
[16:17:42.669]                 if (is_error) {
[16:17:42.669]                   sessionInformation <- function() {
[16:17:42.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.669]                       search = base::search(), system = base::Sys.info())
[16:17:42.669]                   }
[16:17:42.669]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.669]                     cond$call), session = sessionInformation(), 
[16:17:42.669]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.669]                   signalCondition(cond)
[16:17:42.669]                 }
[16:17:42.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.669]                 "immediateCondition"))) {
[16:17:42.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.669]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.669]                   if (TRUE && !signal) {
[16:17:42.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.669]                     {
[16:17:42.669]                       inherits <- base::inherits
[16:17:42.669]                       invokeRestart <- base::invokeRestart
[16:17:42.669]                       is.null <- base::is.null
[16:17:42.669]                       muffled <- FALSE
[16:17:42.669]                       if (inherits(cond, "message")) {
[16:17:42.669]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.669]                         if (muffled) 
[16:17:42.669]                           invokeRestart("muffleMessage")
[16:17:42.669]                       }
[16:17:42.669]                       else if (inherits(cond, "warning")) {
[16:17:42.669]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.669]                         if (muffled) 
[16:17:42.669]                           invokeRestart("muffleWarning")
[16:17:42.669]                       }
[16:17:42.669]                       else if (inherits(cond, "condition")) {
[16:17:42.669]                         if (!is.null(pattern)) {
[16:17:42.669]                           computeRestarts <- base::computeRestarts
[16:17:42.669]                           grepl <- base::grepl
[16:17:42.669]                           restarts <- computeRestarts(cond)
[16:17:42.669]                           for (restart in restarts) {
[16:17:42.669]                             name <- restart$name
[16:17:42.669]                             if (is.null(name)) 
[16:17:42.669]                               next
[16:17:42.669]                             if (!grepl(pattern, name)) 
[16:17:42.669]                               next
[16:17:42.669]                             invokeRestart(restart)
[16:17:42.669]                             muffled <- TRUE
[16:17:42.669]                             break
[16:17:42.669]                           }
[16:17:42.669]                         }
[16:17:42.669]                       }
[16:17:42.669]                       invisible(muffled)
[16:17:42.669]                     }
[16:17:42.669]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.669]                   }
[16:17:42.669]                 }
[16:17:42.669]                 else {
[16:17:42.669]                   if (TRUE) {
[16:17:42.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.669]                     {
[16:17:42.669]                       inherits <- base::inherits
[16:17:42.669]                       invokeRestart <- base::invokeRestart
[16:17:42.669]                       is.null <- base::is.null
[16:17:42.669]                       muffled <- FALSE
[16:17:42.669]                       if (inherits(cond, "message")) {
[16:17:42.669]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.669]                         if (muffled) 
[16:17:42.669]                           invokeRestart("muffleMessage")
[16:17:42.669]                       }
[16:17:42.669]                       else if (inherits(cond, "warning")) {
[16:17:42.669]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.669]                         if (muffled) 
[16:17:42.669]                           invokeRestart("muffleWarning")
[16:17:42.669]                       }
[16:17:42.669]                       else if (inherits(cond, "condition")) {
[16:17:42.669]                         if (!is.null(pattern)) {
[16:17:42.669]                           computeRestarts <- base::computeRestarts
[16:17:42.669]                           grepl <- base::grepl
[16:17:42.669]                           restarts <- computeRestarts(cond)
[16:17:42.669]                           for (restart in restarts) {
[16:17:42.669]                             name <- restart$name
[16:17:42.669]                             if (is.null(name)) 
[16:17:42.669]                               next
[16:17:42.669]                             if (!grepl(pattern, name)) 
[16:17:42.669]                               next
[16:17:42.669]                             invokeRestart(restart)
[16:17:42.669]                             muffled <- TRUE
[16:17:42.669]                             break
[16:17:42.669]                           }
[16:17:42.669]                         }
[16:17:42.669]                       }
[16:17:42.669]                       invisible(muffled)
[16:17:42.669]                     }
[16:17:42.669]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.669]                   }
[16:17:42.669]                 }
[16:17:42.669]             }
[16:17:42.669]         }))
[16:17:42.669]     }, error = function(ex) {
[16:17:42.669]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.669]                 ...future.rng), started = ...future.startTime, 
[16:17:42.669]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.669]             version = "1.8"), class = "FutureResult")
[16:17:42.669]     }, finally = {
[16:17:42.669]         if (!identical(...future.workdir, getwd())) 
[16:17:42.669]             setwd(...future.workdir)
[16:17:42.669]         {
[16:17:42.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.669]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.669]             }
[16:17:42.669]             base::options(...future.oldOptions)
[16:17:42.669]             if (.Platform$OS.type == "windows") {
[16:17:42.669]                 old_names <- names(...future.oldEnvVars)
[16:17:42.669]                 envs <- base::Sys.getenv()
[16:17:42.669]                 names <- names(envs)
[16:17:42.669]                 common <- intersect(names, old_names)
[16:17:42.669]                 added <- setdiff(names, old_names)
[16:17:42.669]                 removed <- setdiff(old_names, names)
[16:17:42.669]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.669]                   envs[common]]
[16:17:42.669]                 NAMES <- toupper(changed)
[16:17:42.669]                 args <- list()
[16:17:42.669]                 for (kk in seq_along(NAMES)) {
[16:17:42.669]                   name <- changed[[kk]]
[16:17:42.669]                   NAME <- NAMES[[kk]]
[16:17:42.669]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.669]                     next
[16:17:42.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.669]                 }
[16:17:42.669]                 NAMES <- toupper(added)
[16:17:42.669]                 for (kk in seq_along(NAMES)) {
[16:17:42.669]                   name <- added[[kk]]
[16:17:42.669]                   NAME <- NAMES[[kk]]
[16:17:42.669]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.669]                     next
[16:17:42.669]                   args[[name]] <- ""
[16:17:42.669]                 }
[16:17:42.669]                 NAMES <- toupper(removed)
[16:17:42.669]                 for (kk in seq_along(NAMES)) {
[16:17:42.669]                   name <- removed[[kk]]
[16:17:42.669]                   NAME <- NAMES[[kk]]
[16:17:42.669]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.669]                     next
[16:17:42.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.669]                 }
[16:17:42.669]                 if (length(args) > 0) 
[16:17:42.669]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.669]             }
[16:17:42.669]             else {
[16:17:42.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.669]             }
[16:17:42.669]             {
[16:17:42.669]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.669]                   0L) {
[16:17:42.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.669]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.669]                   base::options(opts)
[16:17:42.669]                 }
[16:17:42.669]                 {
[16:17:42.669]                   {
[16:17:42.669]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.669]                     NULL
[16:17:42.669]                   }
[16:17:42.669]                   options(future.plan = NULL)
[16:17:42.669]                   if (is.na(NA_character_)) 
[16:17:42.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.669]                     .init = FALSE)
[16:17:42.669]                 }
[16:17:42.669]             }
[16:17:42.669]         }
[16:17:42.669]     })
[16:17:42.669]     if (TRUE) {
[16:17:42.669]         base::sink(type = "output", split = FALSE)
[16:17:42.669]         if (TRUE) {
[16:17:42.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.669]         }
[16:17:42.669]         else {
[16:17:42.669]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.669]         }
[16:17:42.669]         base::close(...future.stdout)
[16:17:42.669]         ...future.stdout <- NULL
[16:17:42.669]     }
[16:17:42.669]     ...future.result$conditions <- ...future.conditions
[16:17:42.669]     ...future.result$finished <- base::Sys.time()
[16:17:42.669]     ...future.result
[16:17:42.669] }
[16:17:42.671] assign_globals() ...
[16:17:42.671] List of 5
[16:17:42.671]  $ future.call.arguments    : list()
[16:17:42.671]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.671]  $ ...future.FUN            :function (x)  
[16:17:42.671]  $ ...future.elements_ii    :List of 3
[16:17:42.671]   ..$ : int [1:4] 1 7 13 19
[16:17:42.671]   ..$ : int [1:4] 2 8 14 20
[16:17:42.671]   ..$ : int [1:4] 3 9 15 21
[16:17:42.671]  $ ...future.seeds_ii       : NULL
[16:17:42.671]  $ ...future.globals.maxSize: num Inf
[16:17:42.671]  - attr(*, "resolved")= logi FALSE
[16:17:42.671]  - attr(*, "total_size")= num NA
[16:17:42.671]  - attr(*, "where")=List of 5
[16:17:42.671]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.671]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.671]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.671]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.671]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.671]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.671]  - attr(*, "already-done")= logi TRUE
[16:17:42.676] - copied ‘future.call.arguments’ to environment
[16:17:42.676] - reassign environment for ‘...future.FUN’
[16:17:42.677] - copied ‘...future.FUN’ to environment
[16:17:42.677] - copied ‘...future.elements_ii’ to environment
[16:17:42.677] - copied ‘...future.seeds_ii’ to environment
[16:17:42.677] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.677] assign_globals() ... done
[16:17:42.677] requestCore(): workers = 2
[16:17:42.679] MulticoreFuture started
[16:17:42.680] - Launch lazy future ... done
[16:17:42.680] run() for ‘MulticoreFuture’ ... done
[16:17:42.680] Created future:
[16:17:42.680] plan(): Setting new future strategy stack:
[16:17:42.681] List of future strategies:
[16:17:42.681] 1. sequential:
[16:17:42.681]    - args: function (..., envir = parent.frame())
[16:17:42.681]    - tweaked: FALSE
[16:17:42.681]    - call: NULL
[16:17:42.681] plan(): nbrOfWorkers() = 1
[16:17:42.683] plan(): Setting new future strategy stack:
[16:17:42.684] List of future strategies:
[16:17:42.684] 1. multicore:
[16:17:42.684]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.684]    - tweaked: FALSE
[16:17:42.684]    - call: plan(strategy)
[16:17:42.689] plan(): nbrOfWorkers() = 2
[16:17:42.680] MulticoreFuture:
[16:17:42.680] Label: ‘future_apply-1’
[16:17:42.680] Expression:
[16:17:42.680] {
[16:17:42.680]     do.call(function(...) {
[16:17:42.680]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.680]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.680]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.680]             on.exit(options(oopts), add = TRUE)
[16:17:42.680]         }
[16:17:42.680]         {
[16:17:42.680]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.680]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.680]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.680]             })
[16:17:42.680]         }
[16:17:42.680]     }, args = future.call.arguments)
[16:17:42.680] }
[16:17:42.680] Lazy evaluation: FALSE
[16:17:42.680] Asynchronous evaluation: TRUE
[16:17:42.680] Local evaluation: TRUE
[16:17:42.680] Environment: R_GlobalEnv
[16:17:42.680] Capture standard output: TRUE
[16:17:42.680] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.680] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.680] Packages: <none>
[16:17:42.680] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.680] Resolved: TRUE
[16:17:42.680] Value: <not collected>
[16:17:42.680] Conditions captured: <none>
[16:17:42.680] Early signaling: FALSE
[16:17:42.680] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.680] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.690] Chunk #1 of 2 ... DONE
[16:17:42.690] Chunk #2 of 2 ...
[16:17:42.690]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.691]  - seeds: <none>
[16:17:42.691]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.691] getGlobalsAndPackages() ...
[16:17:42.691] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.691] Resolving globals: FALSE
[16:17:42.691] Tweak future expression to call with '...' arguments ...
[16:17:42.692] {
[16:17:42.692]     do.call(function(...) {
[16:17:42.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.692]             on.exit(options(oopts), add = TRUE)
[16:17:42.692]         }
[16:17:42.692]         {
[16:17:42.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.692]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.692]             })
[16:17:42.692]         }
[16:17:42.692]     }, args = future.call.arguments)
[16:17:42.692] }
[16:17:42.692] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.693] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.693] 
[16:17:42.693] getGlobalsAndPackages() ... DONE
[16:17:42.693] run() for ‘Future’ ...
[16:17:42.694] - state: ‘created’
[16:17:42.694] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.702] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.703] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.703]   - Field: ‘label’
[16:17:42.704]   - Field: ‘local’
[16:17:42.704]   - Field: ‘owner’
[16:17:42.704]   - Field: ‘envir’
[16:17:42.705]   - Field: ‘workers’
[16:17:42.705]   - Field: ‘packages’
[16:17:42.705]   - Field: ‘gc’
[16:17:42.706]   - Field: ‘job’
[16:17:42.706]   - Field: ‘conditions’
[16:17:42.706]   - Field: ‘expr’
[16:17:42.706]   - Field: ‘uuid’
[16:17:42.706]   - Field: ‘seed’
[16:17:42.707]   - Field: ‘version’
[16:17:42.707]   - Field: ‘result’
[16:17:42.708]   - Field: ‘asynchronous’
[16:17:42.708]   - Field: ‘calls’
[16:17:42.708]   - Field: ‘globals’
[16:17:42.708]   - Field: ‘stdout’
[16:17:42.709]   - Field: ‘earlySignal’
[16:17:42.709]   - Field: ‘lazy’
[16:17:42.709]   - Field: ‘state’
[16:17:42.709] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.709] - Launch lazy future ...
[16:17:42.710] Packages needed by the future expression (n = 0): <none>
[16:17:42.710] Packages needed by future strategies (n = 0): <none>
[16:17:42.711] {
[16:17:42.711]     {
[16:17:42.711]         {
[16:17:42.711]             ...future.startTime <- base::Sys.time()
[16:17:42.711]             {
[16:17:42.711]                 {
[16:17:42.711]                   {
[16:17:42.711]                     {
[16:17:42.711]                       base::local({
[16:17:42.711]                         has_future <- base::requireNamespace("future", 
[16:17:42.711]                           quietly = TRUE)
[16:17:42.711]                         if (has_future) {
[16:17:42.711]                           ns <- base::getNamespace("future")
[16:17:42.711]                           version <- ns[[".package"]][["version"]]
[16:17:42.711]                           if (is.null(version)) 
[16:17:42.711]                             version <- utils::packageVersion("future")
[16:17:42.711]                         }
[16:17:42.711]                         else {
[16:17:42.711]                           version <- NULL
[16:17:42.711]                         }
[16:17:42.711]                         if (!has_future || version < "1.8.0") {
[16:17:42.711]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.711]                             "", base::R.version$version.string), 
[16:17:42.711]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.711]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.711]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.711]                               "release", "version")], collapse = " "), 
[16:17:42.711]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.711]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.711]                             info)
[16:17:42.711]                           info <- base::paste(info, collapse = "; ")
[16:17:42.711]                           if (!has_future) {
[16:17:42.711]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.711]                               info)
[16:17:42.711]                           }
[16:17:42.711]                           else {
[16:17:42.711]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.711]                               info, version)
[16:17:42.711]                           }
[16:17:42.711]                           base::stop(msg)
[16:17:42.711]                         }
[16:17:42.711]                       })
[16:17:42.711]                     }
[16:17:42.711]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.711]                     base::options(mc.cores = 1L)
[16:17:42.711]                   }
[16:17:42.711]                   ...future.strategy.old <- future::plan("list")
[16:17:42.711]                   options(future.plan = NULL)
[16:17:42.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.711]                 }
[16:17:42.711]                 ...future.workdir <- getwd()
[16:17:42.711]             }
[16:17:42.711]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.711]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.711]         }
[16:17:42.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.711]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.711]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.711]             base::names(...future.oldOptions))
[16:17:42.711]     }
[16:17:42.711]     if (FALSE) {
[16:17:42.711]     }
[16:17:42.711]     else {
[16:17:42.711]         if (TRUE) {
[16:17:42.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.711]                 open = "w")
[16:17:42.711]         }
[16:17:42.711]         else {
[16:17:42.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.711]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.711]         }
[16:17:42.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.711]             base::sink(type = "output", split = FALSE)
[16:17:42.711]             base::close(...future.stdout)
[16:17:42.711]         }, add = TRUE)
[16:17:42.711]     }
[16:17:42.711]     ...future.frame <- base::sys.nframe()
[16:17:42.711]     ...future.conditions <- base::list()
[16:17:42.711]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.711]     if (FALSE) {
[16:17:42.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.711]     }
[16:17:42.711]     ...future.result <- base::tryCatch({
[16:17:42.711]         base::withCallingHandlers({
[16:17:42.711]             ...future.value <- base::withVisible(base::local({
[16:17:42.711]                 withCallingHandlers({
[16:17:42.711]                   {
[16:17:42.711]                     do.call(function(...) {
[16:17:42.711]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.711]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.711]                         ...future.globals.maxSize)) {
[16:17:42.711]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.711]                         on.exit(options(oopts), add = TRUE)
[16:17:42.711]                       }
[16:17:42.711]                       {
[16:17:42.711]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.711]                           FUN = function(jj) {
[16:17:42.711]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.711]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.711]                           })
[16:17:42.711]                       }
[16:17:42.711]                     }, args = future.call.arguments)
[16:17:42.711]                   }
[16:17:42.711]                 }, immediateCondition = function(cond) {
[16:17:42.711]                   save_rds <- function (object, pathname, ...) 
[16:17:42.711]                   {
[16:17:42.711]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.711]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.711]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.711]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.711]                         fi_tmp[["mtime"]])
[16:17:42.711]                     }
[16:17:42.711]                     tryCatch({
[16:17:42.711]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.711]                     }, error = function(ex) {
[16:17:42.711]                       msg <- conditionMessage(ex)
[16:17:42.711]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.711]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.711]                         fi_tmp[["mtime"]], msg)
[16:17:42.711]                       ex$message <- msg
[16:17:42.711]                       stop(ex)
[16:17:42.711]                     })
[16:17:42.711]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.711]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.711]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.711]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.711]                       fi <- file.info(pathname)
[16:17:42.711]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.711]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.711]                         fi[["size"]], fi[["mtime"]])
[16:17:42.711]                       stop(msg)
[16:17:42.711]                     }
[16:17:42.711]                     invisible(pathname)
[16:17:42.711]                   }
[16:17:42.711]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.711]                     rootPath = tempdir()) 
[16:17:42.711]                   {
[16:17:42.711]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.711]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.711]                       tmpdir = path, fileext = ".rds")
[16:17:42.711]                     save_rds(obj, file)
[16:17:42.711]                   }
[16:17:42.711]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.711]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.711]                   {
[16:17:42.711]                     inherits <- base::inherits
[16:17:42.711]                     invokeRestart <- base::invokeRestart
[16:17:42.711]                     is.null <- base::is.null
[16:17:42.711]                     muffled <- FALSE
[16:17:42.711]                     if (inherits(cond, "message")) {
[16:17:42.711]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.711]                       if (muffled) 
[16:17:42.711]                         invokeRestart("muffleMessage")
[16:17:42.711]                     }
[16:17:42.711]                     else if (inherits(cond, "warning")) {
[16:17:42.711]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.711]                       if (muffled) 
[16:17:42.711]                         invokeRestart("muffleWarning")
[16:17:42.711]                     }
[16:17:42.711]                     else if (inherits(cond, "condition")) {
[16:17:42.711]                       if (!is.null(pattern)) {
[16:17:42.711]                         computeRestarts <- base::computeRestarts
[16:17:42.711]                         grepl <- base::grepl
[16:17:42.711]                         restarts <- computeRestarts(cond)
[16:17:42.711]                         for (restart in restarts) {
[16:17:42.711]                           name <- restart$name
[16:17:42.711]                           if (is.null(name)) 
[16:17:42.711]                             next
[16:17:42.711]                           if (!grepl(pattern, name)) 
[16:17:42.711]                             next
[16:17:42.711]                           invokeRestart(restart)
[16:17:42.711]                           muffled <- TRUE
[16:17:42.711]                           break
[16:17:42.711]                         }
[16:17:42.711]                       }
[16:17:42.711]                     }
[16:17:42.711]                     invisible(muffled)
[16:17:42.711]                   }
[16:17:42.711]                   muffleCondition(cond)
[16:17:42.711]                 })
[16:17:42.711]             }))
[16:17:42.711]             future::FutureResult(value = ...future.value$value, 
[16:17:42.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.711]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.711]                     ...future.globalenv.names))
[16:17:42.711]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.711]         }, condition = base::local({
[16:17:42.711]             c <- base::c
[16:17:42.711]             inherits <- base::inherits
[16:17:42.711]             invokeRestart <- base::invokeRestart
[16:17:42.711]             length <- base::length
[16:17:42.711]             list <- base::list
[16:17:42.711]             seq.int <- base::seq.int
[16:17:42.711]             signalCondition <- base::signalCondition
[16:17:42.711]             sys.calls <- base::sys.calls
[16:17:42.711]             `[[` <- base::`[[`
[16:17:42.711]             `+` <- base::`+`
[16:17:42.711]             `<<-` <- base::`<<-`
[16:17:42.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.711]                   3L)]
[16:17:42.711]             }
[16:17:42.711]             function(cond) {
[16:17:42.711]                 is_error <- inherits(cond, "error")
[16:17:42.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.711]                   NULL)
[16:17:42.711]                 if (is_error) {
[16:17:42.711]                   sessionInformation <- function() {
[16:17:42.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.711]                       search = base::search(), system = base::Sys.info())
[16:17:42.711]                   }
[16:17:42.711]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.711]                     cond$call), session = sessionInformation(), 
[16:17:42.711]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.711]                   signalCondition(cond)
[16:17:42.711]                 }
[16:17:42.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.711]                 "immediateCondition"))) {
[16:17:42.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.711]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.711]                   if (TRUE && !signal) {
[16:17:42.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.711]                     {
[16:17:42.711]                       inherits <- base::inherits
[16:17:42.711]                       invokeRestart <- base::invokeRestart
[16:17:42.711]                       is.null <- base::is.null
[16:17:42.711]                       muffled <- FALSE
[16:17:42.711]                       if (inherits(cond, "message")) {
[16:17:42.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.711]                         if (muffled) 
[16:17:42.711]                           invokeRestart("muffleMessage")
[16:17:42.711]                       }
[16:17:42.711]                       else if (inherits(cond, "warning")) {
[16:17:42.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.711]                         if (muffled) 
[16:17:42.711]                           invokeRestart("muffleWarning")
[16:17:42.711]                       }
[16:17:42.711]                       else if (inherits(cond, "condition")) {
[16:17:42.711]                         if (!is.null(pattern)) {
[16:17:42.711]                           computeRestarts <- base::computeRestarts
[16:17:42.711]                           grepl <- base::grepl
[16:17:42.711]                           restarts <- computeRestarts(cond)
[16:17:42.711]                           for (restart in restarts) {
[16:17:42.711]                             name <- restart$name
[16:17:42.711]                             if (is.null(name)) 
[16:17:42.711]                               next
[16:17:42.711]                             if (!grepl(pattern, name)) 
[16:17:42.711]                               next
[16:17:42.711]                             invokeRestart(restart)
[16:17:42.711]                             muffled <- TRUE
[16:17:42.711]                             break
[16:17:42.711]                           }
[16:17:42.711]                         }
[16:17:42.711]                       }
[16:17:42.711]                       invisible(muffled)
[16:17:42.711]                     }
[16:17:42.711]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.711]                   }
[16:17:42.711]                 }
[16:17:42.711]                 else {
[16:17:42.711]                   if (TRUE) {
[16:17:42.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.711]                     {
[16:17:42.711]                       inherits <- base::inherits
[16:17:42.711]                       invokeRestart <- base::invokeRestart
[16:17:42.711]                       is.null <- base::is.null
[16:17:42.711]                       muffled <- FALSE
[16:17:42.711]                       if (inherits(cond, "message")) {
[16:17:42.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.711]                         if (muffled) 
[16:17:42.711]                           invokeRestart("muffleMessage")
[16:17:42.711]                       }
[16:17:42.711]                       else if (inherits(cond, "warning")) {
[16:17:42.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.711]                         if (muffled) 
[16:17:42.711]                           invokeRestart("muffleWarning")
[16:17:42.711]                       }
[16:17:42.711]                       else if (inherits(cond, "condition")) {
[16:17:42.711]                         if (!is.null(pattern)) {
[16:17:42.711]                           computeRestarts <- base::computeRestarts
[16:17:42.711]                           grepl <- base::grepl
[16:17:42.711]                           restarts <- computeRestarts(cond)
[16:17:42.711]                           for (restart in restarts) {
[16:17:42.711]                             name <- restart$name
[16:17:42.711]                             if (is.null(name)) 
[16:17:42.711]                               next
[16:17:42.711]                             if (!grepl(pattern, name)) 
[16:17:42.711]                               next
[16:17:42.711]                             invokeRestart(restart)
[16:17:42.711]                             muffled <- TRUE
[16:17:42.711]                             break
[16:17:42.711]                           }
[16:17:42.711]                         }
[16:17:42.711]                       }
[16:17:42.711]                       invisible(muffled)
[16:17:42.711]                     }
[16:17:42.711]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.711]                   }
[16:17:42.711]                 }
[16:17:42.711]             }
[16:17:42.711]         }))
[16:17:42.711]     }, error = function(ex) {
[16:17:42.711]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.711]                 ...future.rng), started = ...future.startTime, 
[16:17:42.711]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.711]             version = "1.8"), class = "FutureResult")
[16:17:42.711]     }, finally = {
[16:17:42.711]         if (!identical(...future.workdir, getwd())) 
[16:17:42.711]             setwd(...future.workdir)
[16:17:42.711]         {
[16:17:42.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.711]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.711]             }
[16:17:42.711]             base::options(...future.oldOptions)
[16:17:42.711]             if (.Platform$OS.type == "windows") {
[16:17:42.711]                 old_names <- names(...future.oldEnvVars)
[16:17:42.711]                 envs <- base::Sys.getenv()
[16:17:42.711]                 names <- names(envs)
[16:17:42.711]                 common <- intersect(names, old_names)
[16:17:42.711]                 added <- setdiff(names, old_names)
[16:17:42.711]                 removed <- setdiff(old_names, names)
[16:17:42.711]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.711]                   envs[common]]
[16:17:42.711]                 NAMES <- toupper(changed)
[16:17:42.711]                 args <- list()
[16:17:42.711]                 for (kk in seq_along(NAMES)) {
[16:17:42.711]                   name <- changed[[kk]]
[16:17:42.711]                   NAME <- NAMES[[kk]]
[16:17:42.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.711]                     next
[16:17:42.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.711]                 }
[16:17:42.711]                 NAMES <- toupper(added)
[16:17:42.711]                 for (kk in seq_along(NAMES)) {
[16:17:42.711]                   name <- added[[kk]]
[16:17:42.711]                   NAME <- NAMES[[kk]]
[16:17:42.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.711]                     next
[16:17:42.711]                   args[[name]] <- ""
[16:17:42.711]                 }
[16:17:42.711]                 NAMES <- toupper(removed)
[16:17:42.711]                 for (kk in seq_along(NAMES)) {
[16:17:42.711]                   name <- removed[[kk]]
[16:17:42.711]                   NAME <- NAMES[[kk]]
[16:17:42.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.711]                     next
[16:17:42.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.711]                 }
[16:17:42.711]                 if (length(args) > 0) 
[16:17:42.711]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.711]             }
[16:17:42.711]             else {
[16:17:42.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.711]             }
[16:17:42.711]             {
[16:17:42.711]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.711]                   0L) {
[16:17:42.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.711]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.711]                   base::options(opts)
[16:17:42.711]                 }
[16:17:42.711]                 {
[16:17:42.711]                   {
[16:17:42.711]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.711]                     NULL
[16:17:42.711]                   }
[16:17:42.711]                   options(future.plan = NULL)
[16:17:42.711]                   if (is.na(NA_character_)) 
[16:17:42.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.711]                     .init = FALSE)
[16:17:42.711]                 }
[16:17:42.711]             }
[16:17:42.711]         }
[16:17:42.711]     })
[16:17:42.711]     if (TRUE) {
[16:17:42.711]         base::sink(type = "output", split = FALSE)
[16:17:42.711]         if (TRUE) {
[16:17:42.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.711]         }
[16:17:42.711]         else {
[16:17:42.711]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.711]         }
[16:17:42.711]         base::close(...future.stdout)
[16:17:42.711]         ...future.stdout <- NULL
[16:17:42.711]     }
[16:17:42.711]     ...future.result$conditions <- ...future.conditions
[16:17:42.711]     ...future.result$finished <- base::Sys.time()
[16:17:42.711]     ...future.result
[16:17:42.711] }
[16:17:42.714] assign_globals() ...
[16:17:42.714] List of 5
[16:17:42.714]  $ future.call.arguments    : list()
[16:17:42.714]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.714]  $ ...future.FUN            :function (x)  
[16:17:42.714]  $ ...future.elements_ii    :List of 3
[16:17:42.714]   ..$ : int [1:4] 4 10 16 22
[16:17:42.714]   ..$ : int [1:4] 5 11 17 23
[16:17:42.714]   ..$ : int [1:4] 6 12 18 24
[16:17:42.714]  $ ...future.seeds_ii       : NULL
[16:17:42.714]  $ ...future.globals.maxSize: num Inf
[16:17:42.714]  - attr(*, "resolved")= logi FALSE
[16:17:42.714]  - attr(*, "total_size")= num NA
[16:17:42.714]  - attr(*, "where")=List of 5
[16:17:42.714]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.714]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.714]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.714]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.714]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.714]  - attr(*, "already-done")= logi TRUE
[16:17:42.722] - copied ‘future.call.arguments’ to environment
[16:17:42.722] - reassign environment for ‘...future.FUN’
[16:17:42.723] - copied ‘...future.FUN’ to environment
[16:17:42.723] - copied ‘...future.elements_ii’ to environment
[16:17:42.723] - copied ‘...future.seeds_ii’ to environment
[16:17:42.723] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.723] assign_globals() ... done
[16:17:42.723] requestCore(): workers = 2
[16:17:42.726] MulticoreFuture started
[16:17:42.726] - Launch lazy future ... done
[16:17:42.726] run() for ‘MulticoreFuture’ ... done
[16:17:42.726] Created future:
[16:17:42.727] plan(): Setting new future strategy stack:
[16:17:42.727] List of future strategies:
[16:17:42.727] 1. sequential:
[16:17:42.727]    - args: function (..., envir = parent.frame())
[16:17:42.727]    - tweaked: FALSE
[16:17:42.727]    - call: NULL
[16:17:42.728] plan(): nbrOfWorkers() = 1
[16:17:42.730] plan(): Setting new future strategy stack:
[16:17:42.730] List of future strategies:
[16:17:42.730] 1. multicore:
[16:17:42.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.730]    - tweaked: FALSE
[16:17:42.730]    - call: plan(strategy)
[16:17:42.736] plan(): nbrOfWorkers() = 2
[16:17:42.727] MulticoreFuture:
[16:17:42.727] Label: ‘future_apply-2’
[16:17:42.727] Expression:
[16:17:42.727] {
[16:17:42.727]     do.call(function(...) {
[16:17:42.727]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.727]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.727]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.727]             on.exit(options(oopts), add = TRUE)
[16:17:42.727]         }
[16:17:42.727]         {
[16:17:42.727]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.727]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.727]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.727]             })
[16:17:42.727]         }
[16:17:42.727]     }, args = future.call.arguments)
[16:17:42.727] }
[16:17:42.727] Lazy evaluation: FALSE
[16:17:42.727] Asynchronous evaluation: TRUE
[16:17:42.727] Local evaluation: TRUE
[16:17:42.727] Environment: R_GlobalEnv
[16:17:42.727] Capture standard output: TRUE
[16:17:42.727] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.727] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.727] Packages: <none>
[16:17:42.727] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.727] Resolved: TRUE
[16:17:42.727] Value: <not collected>
[16:17:42.727] Conditions captured: <none>
[16:17:42.727] Early signaling: FALSE
[16:17:42.727] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.727] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.737] Chunk #2 of 2 ... DONE
[16:17:42.737] Launching 2 futures (chunks) ... DONE
[16:17:42.737] Resolving 2 futures (chunks) ...
[16:17:42.737] resolve() on list ...
[16:17:42.737]  recursive: 0
[16:17:42.738]  length: 2
[16:17:42.738] 
[16:17:42.738] Future #1
[16:17:42.738] result() for MulticoreFuture ...
[16:17:42.739] result() for MulticoreFuture ...
[16:17:42.739] result() for MulticoreFuture ... done
[16:17:42.740] result() for MulticoreFuture ... done
[16:17:42.740] result() for MulticoreFuture ...
[16:17:42.740] result() for MulticoreFuture ... done
[16:17:42.740] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:42.740] - nx: 2
[16:17:42.741] - relay: TRUE
[16:17:42.741] - stdout: TRUE
[16:17:42.741] - signal: TRUE
[16:17:42.741] - resignal: FALSE
[16:17:42.741] - force: TRUE
[16:17:42.741] - relayed: [n=2] FALSE, FALSE
[16:17:42.741] - queued futures: [n=2] FALSE, FALSE
[16:17:42.742]  - until=1
[16:17:42.742]  - relaying element #1
[16:17:42.742] result() for MulticoreFuture ...
[16:17:42.742] result() for MulticoreFuture ... done
[16:17:42.742] result() for MulticoreFuture ...
[16:17:42.742] result() for MulticoreFuture ... done
[16:17:42.742] result() for MulticoreFuture ...
[16:17:42.743] result() for MulticoreFuture ... done
[16:17:42.743] result() for MulticoreFuture ...
[16:17:42.743] result() for MulticoreFuture ... done
[16:17:42.743] - relayed: [n=2] TRUE, FALSE
[16:17:42.743] - queued futures: [n=2] TRUE, FALSE
[16:17:42.743] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:42.743]  length: 1 (resolved future 1)
[16:17:42.744] Future #2
[16:17:42.744] result() for MulticoreFuture ...
[16:17:42.745] result() for MulticoreFuture ...
[16:17:42.745] result() for MulticoreFuture ... done
[16:17:42.745] result() for MulticoreFuture ... done
[16:17:42.745] result() for MulticoreFuture ...
[16:17:42.745] result() for MulticoreFuture ... done
[16:17:42.745] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:42.746] - nx: 2
[16:17:42.746] - relay: TRUE
[16:17:42.746] - stdout: TRUE
[16:17:42.746] - signal: TRUE
[16:17:42.746] - resignal: FALSE
[16:17:42.746] - force: TRUE
[16:17:42.746] - relayed: [n=2] TRUE, FALSE
[16:17:42.746] - queued futures: [n=2] TRUE, FALSE
[16:17:42.747]  - until=2
[16:17:42.747]  - relaying element #2
[16:17:42.747] result() for MulticoreFuture ...
[16:17:42.747] result() for MulticoreFuture ... done
[16:17:42.747] result() for MulticoreFuture ...
[16:17:42.747] result() for MulticoreFuture ... done
[16:17:42.747] result() for MulticoreFuture ...
[16:17:42.748] result() for MulticoreFuture ... done
[16:17:42.748] result() for MulticoreFuture ...
[16:17:42.748] result() for MulticoreFuture ... done
[16:17:42.748] - relayed: [n=2] TRUE, TRUE
[16:17:42.748] - queued futures: [n=2] TRUE, TRUE
[16:17:42.748] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:42.748]  length: 0 (resolved future 2)
[16:17:42.751] Relaying remaining futures
[16:17:42.751] signalConditionsASAP(NULL, pos=0) ...
[16:17:42.751] - nx: 2
[16:17:42.752] - relay: TRUE
[16:17:42.752] - stdout: TRUE
[16:17:42.752] - signal: TRUE
[16:17:42.752] - resignal: FALSE
[16:17:42.752] - force: TRUE
[16:17:42.752] - relayed: [n=2] TRUE, TRUE
[16:17:42.753] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:42.753] - relayed: [n=2] TRUE, TRUE
[16:17:42.753] - queued futures: [n=2] TRUE, TRUE
[16:17:42.753] signalConditionsASAP(NULL, pos=0) ... done
[16:17:42.753] resolve() on list ... DONE
[16:17:42.753] result() for MulticoreFuture ...
[16:17:42.754] result() for MulticoreFuture ... done
[16:17:42.754] result() for MulticoreFuture ...
[16:17:42.754] result() for MulticoreFuture ... done
[16:17:42.754] result() for MulticoreFuture ...
[16:17:42.754] result() for MulticoreFuture ... done
[16:17:42.755] result() for MulticoreFuture ...
[16:17:42.755] result() for MulticoreFuture ... done
[16:17:42.755]  - Number of value chunks collected: 2
[16:17:42.755] Resolving 2 futures (chunks) ... DONE
[16:17:42.755] Reducing values from 2 chunks ...
[16:17:42.755]  - Number of values collected after concatenation: 6
[16:17:42.755]  - Number of values expected: 6
[16:17:42.756] Reducing values from 2 chunks ... DONE
[16:17:42.756] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:17:42.756] getGlobalsAndPackagesXApply() ...
[16:17:42.756]  - future.globals: TRUE
[16:17:42.756] getGlobalsAndPackages() ...
[16:17:42.757] Searching for globals...
[16:17:42.758] - globals found: [1] ‘FUN’
[16:17:42.758] Searching for globals ... DONE
[16:17:42.758] Resolving globals: FALSE
[16:17:42.759] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:42.759] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:42.759] - globals: [1] ‘FUN’
[16:17:42.759] 
[16:17:42.760] getGlobalsAndPackages() ... DONE
[16:17:42.760]  - globals found/used: [n=1] ‘FUN’
[16:17:42.760]  - needed namespaces: [n=0] 
[16:17:42.760] Finding globals ... DONE
[16:17:42.760]  - use_args: TRUE
[16:17:42.760]  - Getting '...' globals ...
[16:17:42.761] resolve() on list ...
[16:17:42.761]  recursive: 0
[16:17:42.761]  length: 1
[16:17:42.761]  elements: ‘...’
[16:17:42.761]  length: 0 (resolved future 1)
[16:17:42.761] resolve() on list ... DONE
[16:17:42.761]    - '...' content: [n=0] 
[16:17:42.761] List of 1
[16:17:42.761]  $ ...: list()
[16:17:42.761]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.761]  - attr(*, "where")=List of 1
[16:17:42.761]   ..$ ...:<environment: 0x555be193bd70> 
[16:17:42.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.761]  - attr(*, "resolved")= logi TRUE
[16:17:42.761]  - attr(*, "total_size")= num NA
[16:17:42.764]  - Getting '...' globals ... DONE
[16:17:42.765] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:42.765] List of 2
[16:17:42.765]  $ ...future.FUN:function (x)  
[16:17:42.765]  $ ...          : list()
[16:17:42.765]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.765]  - attr(*, "where")=List of 2
[16:17:42.765]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:42.765]   ..$ ...          :<environment: 0x555be193bd70> 
[16:17:42.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.765]  - attr(*, "resolved")= logi FALSE
[16:17:42.765]  - attr(*, "total_size")= num 848
[16:17:42.767] Packages to be attached in all futures: [n=0] 
[16:17:42.768] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.771] future_lapply() ...
[16:17:42.775] Number of chunks: 2
[16:17:42.775] getGlobalsAndPackagesXApply() ...
[16:17:42.775]  - future.globals: <name-value list> with names ‘list()’
[16:17:42.775]  - use_args: TRUE
[16:17:42.776] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:42.776] List of 2
[16:17:42.776]  $ ...          : list()
[16:17:42.776]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.776]  $ ...future.FUN:function (x)  
[16:17:42.776]  - attr(*, "where")=List of 2
[16:17:42.776]   ..$ ...          :<environment: 0x555be193bd70> 
[16:17:42.776]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:42.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.776]  - attr(*, "resolved")= logi FALSE
[16:17:42.776]  - attr(*, "total_size")= num NA
[16:17:42.779] Packages to be attached in all futures: [n=0] 
[16:17:42.780] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.781] Number of futures (= number of chunks): 2
[16:17:42.781] Launching 2 futures (chunks) ...
[16:17:42.781] Chunk #1 of 2 ...
[16:17:42.781]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.781]  - seeds: <none>
[16:17:42.781]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.781] getGlobalsAndPackages() ...
[16:17:42.782] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.782] Resolving globals: FALSE
[16:17:42.782] Tweak future expression to call with '...' arguments ...
[16:17:42.782] {
[16:17:42.782]     do.call(function(...) {
[16:17:42.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.782]             on.exit(options(oopts), add = TRUE)
[16:17:42.782]         }
[16:17:42.782]         {
[16:17:42.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.782]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.782]             })
[16:17:42.782]         }
[16:17:42.782]     }, args = future.call.arguments)
[16:17:42.782] }
[16:17:42.782] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.783] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.783] 
[16:17:42.783] getGlobalsAndPackages() ... DONE
[16:17:42.783] run() for ‘Future’ ...
[16:17:42.783] - state: ‘created’
[16:17:42.784] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.787] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.787]   - Field: ‘label’
[16:17:42.788]   - Field: ‘local’
[16:17:42.788]   - Field: ‘owner’
[16:17:42.788]   - Field: ‘envir’
[16:17:42.788]   - Field: ‘workers’
[16:17:42.788]   - Field: ‘packages’
[16:17:42.788]   - Field: ‘gc’
[16:17:42.788]   - Field: ‘job’
[16:17:42.788]   - Field: ‘conditions’
[16:17:42.788]   - Field: ‘expr’
[16:17:42.788]   - Field: ‘uuid’
[16:17:42.789]   - Field: ‘seed’
[16:17:42.789]   - Field: ‘version’
[16:17:42.789]   - Field: ‘result’
[16:17:42.789]   - Field: ‘asynchronous’
[16:17:42.789]   - Field: ‘calls’
[16:17:42.789]   - Field: ‘globals’
[16:17:42.789]   - Field: ‘stdout’
[16:17:42.789]   - Field: ‘earlySignal’
[16:17:42.789]   - Field: ‘lazy’
[16:17:42.789]   - Field: ‘state’
[16:17:42.789] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.790] - Launch lazy future ...
[16:17:42.790] Packages needed by the future expression (n = 0): <none>
[16:17:42.790] Packages needed by future strategies (n = 0): <none>
[16:17:42.790] {
[16:17:42.790]     {
[16:17:42.790]         {
[16:17:42.790]             ...future.startTime <- base::Sys.time()
[16:17:42.790]             {
[16:17:42.790]                 {
[16:17:42.790]                   {
[16:17:42.790]                     {
[16:17:42.790]                       base::local({
[16:17:42.790]                         has_future <- base::requireNamespace("future", 
[16:17:42.790]                           quietly = TRUE)
[16:17:42.790]                         if (has_future) {
[16:17:42.790]                           ns <- base::getNamespace("future")
[16:17:42.790]                           version <- ns[[".package"]][["version"]]
[16:17:42.790]                           if (is.null(version)) 
[16:17:42.790]                             version <- utils::packageVersion("future")
[16:17:42.790]                         }
[16:17:42.790]                         else {
[16:17:42.790]                           version <- NULL
[16:17:42.790]                         }
[16:17:42.790]                         if (!has_future || version < "1.8.0") {
[16:17:42.790]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.790]                             "", base::R.version$version.string), 
[16:17:42.790]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.790]                               "release", "version")], collapse = " "), 
[16:17:42.790]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.790]                             info)
[16:17:42.790]                           info <- base::paste(info, collapse = "; ")
[16:17:42.790]                           if (!has_future) {
[16:17:42.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.790]                               info)
[16:17:42.790]                           }
[16:17:42.790]                           else {
[16:17:42.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.790]                               info, version)
[16:17:42.790]                           }
[16:17:42.790]                           base::stop(msg)
[16:17:42.790]                         }
[16:17:42.790]                       })
[16:17:42.790]                     }
[16:17:42.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.790]                     base::options(mc.cores = 1L)
[16:17:42.790]                   }
[16:17:42.790]                   ...future.strategy.old <- future::plan("list")
[16:17:42.790]                   options(future.plan = NULL)
[16:17:42.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.790]                 }
[16:17:42.790]                 ...future.workdir <- getwd()
[16:17:42.790]             }
[16:17:42.790]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.790]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.790]         }
[16:17:42.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.790]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.790]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.790]             base::names(...future.oldOptions))
[16:17:42.790]     }
[16:17:42.790]     if (FALSE) {
[16:17:42.790]     }
[16:17:42.790]     else {
[16:17:42.790]         if (TRUE) {
[16:17:42.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.790]                 open = "w")
[16:17:42.790]         }
[16:17:42.790]         else {
[16:17:42.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.790]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.790]         }
[16:17:42.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.790]             base::sink(type = "output", split = FALSE)
[16:17:42.790]             base::close(...future.stdout)
[16:17:42.790]         }, add = TRUE)
[16:17:42.790]     }
[16:17:42.790]     ...future.frame <- base::sys.nframe()
[16:17:42.790]     ...future.conditions <- base::list()
[16:17:42.790]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.790]     if (FALSE) {
[16:17:42.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.790]     }
[16:17:42.790]     ...future.result <- base::tryCatch({
[16:17:42.790]         base::withCallingHandlers({
[16:17:42.790]             ...future.value <- base::withVisible(base::local({
[16:17:42.790]                 withCallingHandlers({
[16:17:42.790]                   {
[16:17:42.790]                     do.call(function(...) {
[16:17:42.790]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.790]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.790]                         ...future.globals.maxSize)) {
[16:17:42.790]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.790]                         on.exit(options(oopts), add = TRUE)
[16:17:42.790]                       }
[16:17:42.790]                       {
[16:17:42.790]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.790]                           FUN = function(jj) {
[16:17:42.790]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.790]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.790]                           })
[16:17:42.790]                       }
[16:17:42.790]                     }, args = future.call.arguments)
[16:17:42.790]                   }
[16:17:42.790]                 }, immediateCondition = function(cond) {
[16:17:42.790]                   save_rds <- function (object, pathname, ...) 
[16:17:42.790]                   {
[16:17:42.790]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.790]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.790]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.790]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.790]                         fi_tmp[["mtime"]])
[16:17:42.790]                     }
[16:17:42.790]                     tryCatch({
[16:17:42.790]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.790]                     }, error = function(ex) {
[16:17:42.790]                       msg <- conditionMessage(ex)
[16:17:42.790]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.790]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.790]                         fi_tmp[["mtime"]], msg)
[16:17:42.790]                       ex$message <- msg
[16:17:42.790]                       stop(ex)
[16:17:42.790]                     })
[16:17:42.790]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.790]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.790]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.790]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.790]                       fi <- file.info(pathname)
[16:17:42.790]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.790]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.790]                         fi[["size"]], fi[["mtime"]])
[16:17:42.790]                       stop(msg)
[16:17:42.790]                     }
[16:17:42.790]                     invisible(pathname)
[16:17:42.790]                   }
[16:17:42.790]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.790]                     rootPath = tempdir()) 
[16:17:42.790]                   {
[16:17:42.790]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.790]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.790]                       tmpdir = path, fileext = ".rds")
[16:17:42.790]                     save_rds(obj, file)
[16:17:42.790]                   }
[16:17:42.790]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.790]                   {
[16:17:42.790]                     inherits <- base::inherits
[16:17:42.790]                     invokeRestart <- base::invokeRestart
[16:17:42.790]                     is.null <- base::is.null
[16:17:42.790]                     muffled <- FALSE
[16:17:42.790]                     if (inherits(cond, "message")) {
[16:17:42.790]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.790]                       if (muffled) 
[16:17:42.790]                         invokeRestart("muffleMessage")
[16:17:42.790]                     }
[16:17:42.790]                     else if (inherits(cond, "warning")) {
[16:17:42.790]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.790]                       if (muffled) 
[16:17:42.790]                         invokeRestart("muffleWarning")
[16:17:42.790]                     }
[16:17:42.790]                     else if (inherits(cond, "condition")) {
[16:17:42.790]                       if (!is.null(pattern)) {
[16:17:42.790]                         computeRestarts <- base::computeRestarts
[16:17:42.790]                         grepl <- base::grepl
[16:17:42.790]                         restarts <- computeRestarts(cond)
[16:17:42.790]                         for (restart in restarts) {
[16:17:42.790]                           name <- restart$name
[16:17:42.790]                           if (is.null(name)) 
[16:17:42.790]                             next
[16:17:42.790]                           if (!grepl(pattern, name)) 
[16:17:42.790]                             next
[16:17:42.790]                           invokeRestart(restart)
[16:17:42.790]                           muffled <- TRUE
[16:17:42.790]                           break
[16:17:42.790]                         }
[16:17:42.790]                       }
[16:17:42.790]                     }
[16:17:42.790]                     invisible(muffled)
[16:17:42.790]                   }
[16:17:42.790]                   muffleCondition(cond)
[16:17:42.790]                 })
[16:17:42.790]             }))
[16:17:42.790]             future::FutureResult(value = ...future.value$value, 
[16:17:42.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.790]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.790]                     ...future.globalenv.names))
[16:17:42.790]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.790]         }, condition = base::local({
[16:17:42.790]             c <- base::c
[16:17:42.790]             inherits <- base::inherits
[16:17:42.790]             invokeRestart <- base::invokeRestart
[16:17:42.790]             length <- base::length
[16:17:42.790]             list <- base::list
[16:17:42.790]             seq.int <- base::seq.int
[16:17:42.790]             signalCondition <- base::signalCondition
[16:17:42.790]             sys.calls <- base::sys.calls
[16:17:42.790]             `[[` <- base::`[[`
[16:17:42.790]             `+` <- base::`+`
[16:17:42.790]             `<<-` <- base::`<<-`
[16:17:42.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.790]                   3L)]
[16:17:42.790]             }
[16:17:42.790]             function(cond) {
[16:17:42.790]                 is_error <- inherits(cond, "error")
[16:17:42.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.790]                   NULL)
[16:17:42.790]                 if (is_error) {
[16:17:42.790]                   sessionInformation <- function() {
[16:17:42.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.790]                       search = base::search(), system = base::Sys.info())
[16:17:42.790]                   }
[16:17:42.790]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.790]                     cond$call), session = sessionInformation(), 
[16:17:42.790]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.790]                   signalCondition(cond)
[16:17:42.790]                 }
[16:17:42.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.790]                 "immediateCondition"))) {
[16:17:42.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.790]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.790]                   if (TRUE && !signal) {
[16:17:42.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.790]                     {
[16:17:42.790]                       inherits <- base::inherits
[16:17:42.790]                       invokeRestart <- base::invokeRestart
[16:17:42.790]                       is.null <- base::is.null
[16:17:42.790]                       muffled <- FALSE
[16:17:42.790]                       if (inherits(cond, "message")) {
[16:17:42.790]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.790]                         if (muffled) 
[16:17:42.790]                           invokeRestart("muffleMessage")
[16:17:42.790]                       }
[16:17:42.790]                       else if (inherits(cond, "warning")) {
[16:17:42.790]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.790]                         if (muffled) 
[16:17:42.790]                           invokeRestart("muffleWarning")
[16:17:42.790]                       }
[16:17:42.790]                       else if (inherits(cond, "condition")) {
[16:17:42.790]                         if (!is.null(pattern)) {
[16:17:42.790]                           computeRestarts <- base::computeRestarts
[16:17:42.790]                           grepl <- base::grepl
[16:17:42.790]                           restarts <- computeRestarts(cond)
[16:17:42.790]                           for (restart in restarts) {
[16:17:42.790]                             name <- restart$name
[16:17:42.790]                             if (is.null(name)) 
[16:17:42.790]                               next
[16:17:42.790]                             if (!grepl(pattern, name)) 
[16:17:42.790]                               next
[16:17:42.790]                             invokeRestart(restart)
[16:17:42.790]                             muffled <- TRUE
[16:17:42.790]                             break
[16:17:42.790]                           }
[16:17:42.790]                         }
[16:17:42.790]                       }
[16:17:42.790]                       invisible(muffled)
[16:17:42.790]                     }
[16:17:42.790]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.790]                   }
[16:17:42.790]                 }
[16:17:42.790]                 else {
[16:17:42.790]                   if (TRUE) {
[16:17:42.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.790]                     {
[16:17:42.790]                       inherits <- base::inherits
[16:17:42.790]                       invokeRestart <- base::invokeRestart
[16:17:42.790]                       is.null <- base::is.null
[16:17:42.790]                       muffled <- FALSE
[16:17:42.790]                       if (inherits(cond, "message")) {
[16:17:42.790]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.790]                         if (muffled) 
[16:17:42.790]                           invokeRestart("muffleMessage")
[16:17:42.790]                       }
[16:17:42.790]                       else if (inherits(cond, "warning")) {
[16:17:42.790]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.790]                         if (muffled) 
[16:17:42.790]                           invokeRestart("muffleWarning")
[16:17:42.790]                       }
[16:17:42.790]                       else if (inherits(cond, "condition")) {
[16:17:42.790]                         if (!is.null(pattern)) {
[16:17:42.790]                           computeRestarts <- base::computeRestarts
[16:17:42.790]                           grepl <- base::grepl
[16:17:42.790]                           restarts <- computeRestarts(cond)
[16:17:42.790]                           for (restart in restarts) {
[16:17:42.790]                             name <- restart$name
[16:17:42.790]                             if (is.null(name)) 
[16:17:42.790]                               next
[16:17:42.790]                             if (!grepl(pattern, name)) 
[16:17:42.790]                               next
[16:17:42.790]                             invokeRestart(restart)
[16:17:42.790]                             muffled <- TRUE
[16:17:42.790]                             break
[16:17:42.790]                           }
[16:17:42.790]                         }
[16:17:42.790]                       }
[16:17:42.790]                       invisible(muffled)
[16:17:42.790]                     }
[16:17:42.790]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.790]                   }
[16:17:42.790]                 }
[16:17:42.790]             }
[16:17:42.790]         }))
[16:17:42.790]     }, error = function(ex) {
[16:17:42.790]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.790]                 ...future.rng), started = ...future.startTime, 
[16:17:42.790]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.790]             version = "1.8"), class = "FutureResult")
[16:17:42.790]     }, finally = {
[16:17:42.790]         if (!identical(...future.workdir, getwd())) 
[16:17:42.790]             setwd(...future.workdir)
[16:17:42.790]         {
[16:17:42.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.790]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.790]             }
[16:17:42.790]             base::options(...future.oldOptions)
[16:17:42.790]             if (.Platform$OS.type == "windows") {
[16:17:42.790]                 old_names <- names(...future.oldEnvVars)
[16:17:42.790]                 envs <- base::Sys.getenv()
[16:17:42.790]                 names <- names(envs)
[16:17:42.790]                 common <- intersect(names, old_names)
[16:17:42.790]                 added <- setdiff(names, old_names)
[16:17:42.790]                 removed <- setdiff(old_names, names)
[16:17:42.790]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.790]                   envs[common]]
[16:17:42.790]                 NAMES <- toupper(changed)
[16:17:42.790]                 args <- list()
[16:17:42.790]                 for (kk in seq_along(NAMES)) {
[16:17:42.790]                   name <- changed[[kk]]
[16:17:42.790]                   NAME <- NAMES[[kk]]
[16:17:42.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.790]                     next
[16:17:42.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.790]                 }
[16:17:42.790]                 NAMES <- toupper(added)
[16:17:42.790]                 for (kk in seq_along(NAMES)) {
[16:17:42.790]                   name <- added[[kk]]
[16:17:42.790]                   NAME <- NAMES[[kk]]
[16:17:42.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.790]                     next
[16:17:42.790]                   args[[name]] <- ""
[16:17:42.790]                 }
[16:17:42.790]                 NAMES <- toupper(removed)
[16:17:42.790]                 for (kk in seq_along(NAMES)) {
[16:17:42.790]                   name <- removed[[kk]]
[16:17:42.790]                   NAME <- NAMES[[kk]]
[16:17:42.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.790]                     next
[16:17:42.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.790]                 }
[16:17:42.790]                 if (length(args) > 0) 
[16:17:42.790]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.790]             }
[16:17:42.790]             else {
[16:17:42.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.790]             }
[16:17:42.790]             {
[16:17:42.790]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.790]                   0L) {
[16:17:42.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.790]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.790]                   base::options(opts)
[16:17:42.790]                 }
[16:17:42.790]                 {
[16:17:42.790]                   {
[16:17:42.790]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.790]                     NULL
[16:17:42.790]                   }
[16:17:42.790]                   options(future.plan = NULL)
[16:17:42.790]                   if (is.na(NA_character_)) 
[16:17:42.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.790]                     .init = FALSE)
[16:17:42.790]                 }
[16:17:42.790]             }
[16:17:42.790]         }
[16:17:42.790]     })
[16:17:42.790]     if (TRUE) {
[16:17:42.790]         base::sink(type = "output", split = FALSE)
[16:17:42.790]         if (TRUE) {
[16:17:42.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.790]         }
[16:17:42.790]         else {
[16:17:42.790]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.790]         }
[16:17:42.790]         base::close(...future.stdout)
[16:17:42.790]         ...future.stdout <- NULL
[16:17:42.790]     }
[16:17:42.790]     ...future.result$conditions <- ...future.conditions
[16:17:42.790]     ...future.result$finished <- base::Sys.time()
[16:17:42.790]     ...future.result
[16:17:42.790] }
[16:17:42.793] assign_globals() ...
[16:17:42.793] List of 5
[16:17:42.793]  $ future.call.arguments    : list()
[16:17:42.793]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.793]  $ ...future.FUN            :function (x)  
[16:17:42.793]  $ ...future.elements_ii    :List of 1
[16:17:42.793]   ..$ : int 1
[16:17:42.793]  $ ...future.seeds_ii       : NULL
[16:17:42.793]  $ ...future.globals.maxSize: num Inf
[16:17:42.793]  - attr(*, "resolved")= logi FALSE
[16:17:42.793]  - attr(*, "total_size")= num NA
[16:17:42.793]  - attr(*, "where")=List of 5
[16:17:42.793]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.793]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.793]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.793]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.793]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.793]  - attr(*, "already-done")= logi TRUE
[16:17:42.797] - copied ‘future.call.arguments’ to environment
[16:17:42.797] - copied ‘...future.FUN’ to environment
[16:17:42.798] - copied ‘...future.elements_ii’ to environment
[16:17:42.798] - copied ‘...future.seeds_ii’ to environment
[16:17:42.798] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.798] assign_globals() ... done
[16:17:42.798] requestCore(): workers = 2
[16:17:42.800] MulticoreFuture started
[16:17:42.800] - Launch lazy future ... done
[16:17:42.801] run() for ‘MulticoreFuture’ ... done
[16:17:42.801] Created future:
[16:17:42.801] plan(): Setting new future strategy stack:
[16:17:42.801] List of future strategies:
[16:17:42.801] 1. sequential:
[16:17:42.801]    - args: function (..., envir = parent.frame())
[16:17:42.801]    - tweaked: FALSE
[16:17:42.801]    - call: NULL
[16:17:42.802] plan(): nbrOfWorkers() = 1
[16:17:42.804] plan(): Setting new future strategy stack:
[16:17:42.804] List of future strategies:
[16:17:42.804] 1. multicore:
[16:17:42.804]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.804]    - tweaked: FALSE
[16:17:42.804]    - call: plan(strategy)
[16:17:42.809] plan(): nbrOfWorkers() = 2
[16:17:42.801] MulticoreFuture:
[16:17:42.801] Label: ‘future_apply-1’
[16:17:42.801] Expression:
[16:17:42.801] {
[16:17:42.801]     do.call(function(...) {
[16:17:42.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.801]             on.exit(options(oopts), add = TRUE)
[16:17:42.801]         }
[16:17:42.801]         {
[16:17:42.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.801]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.801]             })
[16:17:42.801]         }
[16:17:42.801]     }, args = future.call.arguments)
[16:17:42.801] }
[16:17:42.801] Lazy evaluation: FALSE
[16:17:42.801] Asynchronous evaluation: TRUE
[16:17:42.801] Local evaluation: TRUE
[16:17:42.801] Environment: R_GlobalEnv
[16:17:42.801] Capture standard output: TRUE
[16:17:42.801] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.801] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.801] Packages: <none>
[16:17:42.801] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.801] Resolved: TRUE
[16:17:42.801] Value: <not collected>
[16:17:42.801] Conditions captured: <none>
[16:17:42.801] Early signaling: FALSE
[16:17:42.801] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.801] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.810] Chunk #1 of 2 ... DONE
[16:17:42.810] Chunk #2 of 2 ...
[16:17:42.811]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.811]  - seeds: <none>
[16:17:42.811]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.811] getGlobalsAndPackages() ...
[16:17:42.811] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.811] Resolving globals: FALSE
[16:17:42.812] Tweak future expression to call with '...' arguments ...
[16:17:42.812] {
[16:17:42.812]     do.call(function(...) {
[16:17:42.812]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.812]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.812]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.812]             on.exit(options(oopts), add = TRUE)
[16:17:42.812]         }
[16:17:42.812]         {
[16:17:42.812]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.812]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.812]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.812]             })
[16:17:42.812]         }
[16:17:42.812]     }, args = future.call.arguments)
[16:17:42.812] }
[16:17:42.812] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.813] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.813] 
[16:17:42.813] getGlobalsAndPackages() ... DONE
[16:17:42.814] run() for ‘Future’ ...
[16:17:42.814] - state: ‘created’
[16:17:42.814] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.818] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.819] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.819]   - Field: ‘label’
[16:17:42.819]   - Field: ‘local’
[16:17:42.819]   - Field: ‘owner’
[16:17:42.819]   - Field: ‘envir’
[16:17:42.819]   - Field: ‘workers’
[16:17:42.820]   - Field: ‘packages’
[16:17:42.820]   - Field: ‘gc’
[16:17:42.823]   - Field: ‘job’
[16:17:42.823]   - Field: ‘conditions’
[16:17:42.824]   - Field: ‘expr’
[16:17:42.824]   - Field: ‘uuid’
[16:17:42.824]   - Field: ‘seed’
[16:17:42.825]   - Field: ‘version’
[16:17:42.825]   - Field: ‘result’
[16:17:42.825]   - Field: ‘asynchronous’
[16:17:42.826]   - Field: ‘calls’
[16:17:42.826]   - Field: ‘globals’
[16:17:42.826]   - Field: ‘stdout’
[16:17:42.826]   - Field: ‘earlySignal’
[16:17:42.827]   - Field: ‘lazy’
[16:17:42.827]   - Field: ‘state’
[16:17:42.827] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.827] - Launch lazy future ...
[16:17:42.828] Packages needed by the future expression (n = 0): <none>
[16:17:42.828] Packages needed by future strategies (n = 0): <none>
[16:17:42.830] {
[16:17:42.830]     {
[16:17:42.830]         {
[16:17:42.830]             ...future.startTime <- base::Sys.time()
[16:17:42.830]             {
[16:17:42.830]                 {
[16:17:42.830]                   {
[16:17:42.830]                     {
[16:17:42.830]                       base::local({
[16:17:42.830]                         has_future <- base::requireNamespace("future", 
[16:17:42.830]                           quietly = TRUE)
[16:17:42.830]                         if (has_future) {
[16:17:42.830]                           ns <- base::getNamespace("future")
[16:17:42.830]                           version <- ns[[".package"]][["version"]]
[16:17:42.830]                           if (is.null(version)) 
[16:17:42.830]                             version <- utils::packageVersion("future")
[16:17:42.830]                         }
[16:17:42.830]                         else {
[16:17:42.830]                           version <- NULL
[16:17:42.830]                         }
[16:17:42.830]                         if (!has_future || version < "1.8.0") {
[16:17:42.830]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.830]                             "", base::R.version$version.string), 
[16:17:42.830]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.830]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.830]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.830]                               "release", "version")], collapse = " "), 
[16:17:42.830]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.830]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.830]                             info)
[16:17:42.830]                           info <- base::paste(info, collapse = "; ")
[16:17:42.830]                           if (!has_future) {
[16:17:42.830]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.830]                               info)
[16:17:42.830]                           }
[16:17:42.830]                           else {
[16:17:42.830]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.830]                               info, version)
[16:17:42.830]                           }
[16:17:42.830]                           base::stop(msg)
[16:17:42.830]                         }
[16:17:42.830]                       })
[16:17:42.830]                     }
[16:17:42.830]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.830]                     base::options(mc.cores = 1L)
[16:17:42.830]                   }
[16:17:42.830]                   ...future.strategy.old <- future::plan("list")
[16:17:42.830]                   options(future.plan = NULL)
[16:17:42.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.830]                 }
[16:17:42.830]                 ...future.workdir <- getwd()
[16:17:42.830]             }
[16:17:42.830]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.830]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.830]         }
[16:17:42.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.830]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.830]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.830]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.830]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.830]             base::names(...future.oldOptions))
[16:17:42.830]     }
[16:17:42.830]     if (FALSE) {
[16:17:42.830]     }
[16:17:42.830]     else {
[16:17:42.830]         if (TRUE) {
[16:17:42.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.830]                 open = "w")
[16:17:42.830]         }
[16:17:42.830]         else {
[16:17:42.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.830]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.830]         }
[16:17:42.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.830]             base::sink(type = "output", split = FALSE)
[16:17:42.830]             base::close(...future.stdout)
[16:17:42.830]         }, add = TRUE)
[16:17:42.830]     }
[16:17:42.830]     ...future.frame <- base::sys.nframe()
[16:17:42.830]     ...future.conditions <- base::list()
[16:17:42.830]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.830]     if (FALSE) {
[16:17:42.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.830]     }
[16:17:42.830]     ...future.result <- base::tryCatch({
[16:17:42.830]         base::withCallingHandlers({
[16:17:42.830]             ...future.value <- base::withVisible(base::local({
[16:17:42.830]                 withCallingHandlers({
[16:17:42.830]                   {
[16:17:42.830]                     do.call(function(...) {
[16:17:42.830]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.830]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.830]                         ...future.globals.maxSize)) {
[16:17:42.830]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.830]                         on.exit(options(oopts), add = TRUE)
[16:17:42.830]                       }
[16:17:42.830]                       {
[16:17:42.830]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.830]                           FUN = function(jj) {
[16:17:42.830]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.830]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.830]                           })
[16:17:42.830]                       }
[16:17:42.830]                     }, args = future.call.arguments)
[16:17:42.830]                   }
[16:17:42.830]                 }, immediateCondition = function(cond) {
[16:17:42.830]                   save_rds <- function (object, pathname, ...) 
[16:17:42.830]                   {
[16:17:42.830]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.830]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.830]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.830]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.830]                         fi_tmp[["mtime"]])
[16:17:42.830]                     }
[16:17:42.830]                     tryCatch({
[16:17:42.830]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.830]                     }, error = function(ex) {
[16:17:42.830]                       msg <- conditionMessage(ex)
[16:17:42.830]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.830]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.830]                         fi_tmp[["mtime"]], msg)
[16:17:42.830]                       ex$message <- msg
[16:17:42.830]                       stop(ex)
[16:17:42.830]                     })
[16:17:42.830]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.830]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.830]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.830]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.830]                       fi <- file.info(pathname)
[16:17:42.830]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.830]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.830]                         fi[["size"]], fi[["mtime"]])
[16:17:42.830]                       stop(msg)
[16:17:42.830]                     }
[16:17:42.830]                     invisible(pathname)
[16:17:42.830]                   }
[16:17:42.830]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.830]                     rootPath = tempdir()) 
[16:17:42.830]                   {
[16:17:42.830]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.830]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.830]                       tmpdir = path, fileext = ".rds")
[16:17:42.830]                     save_rds(obj, file)
[16:17:42.830]                   }
[16:17:42.830]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.830]                   {
[16:17:42.830]                     inherits <- base::inherits
[16:17:42.830]                     invokeRestart <- base::invokeRestart
[16:17:42.830]                     is.null <- base::is.null
[16:17:42.830]                     muffled <- FALSE
[16:17:42.830]                     if (inherits(cond, "message")) {
[16:17:42.830]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.830]                       if (muffled) 
[16:17:42.830]                         invokeRestart("muffleMessage")
[16:17:42.830]                     }
[16:17:42.830]                     else if (inherits(cond, "warning")) {
[16:17:42.830]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.830]                       if (muffled) 
[16:17:42.830]                         invokeRestart("muffleWarning")
[16:17:42.830]                     }
[16:17:42.830]                     else if (inherits(cond, "condition")) {
[16:17:42.830]                       if (!is.null(pattern)) {
[16:17:42.830]                         computeRestarts <- base::computeRestarts
[16:17:42.830]                         grepl <- base::grepl
[16:17:42.830]                         restarts <- computeRestarts(cond)
[16:17:42.830]                         for (restart in restarts) {
[16:17:42.830]                           name <- restart$name
[16:17:42.830]                           if (is.null(name)) 
[16:17:42.830]                             next
[16:17:42.830]                           if (!grepl(pattern, name)) 
[16:17:42.830]                             next
[16:17:42.830]                           invokeRestart(restart)
[16:17:42.830]                           muffled <- TRUE
[16:17:42.830]                           break
[16:17:42.830]                         }
[16:17:42.830]                       }
[16:17:42.830]                     }
[16:17:42.830]                     invisible(muffled)
[16:17:42.830]                   }
[16:17:42.830]                   muffleCondition(cond)
[16:17:42.830]                 })
[16:17:42.830]             }))
[16:17:42.830]             future::FutureResult(value = ...future.value$value, 
[16:17:42.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.830]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.830]                     ...future.globalenv.names))
[16:17:42.830]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.830]         }, condition = base::local({
[16:17:42.830]             c <- base::c
[16:17:42.830]             inherits <- base::inherits
[16:17:42.830]             invokeRestart <- base::invokeRestart
[16:17:42.830]             length <- base::length
[16:17:42.830]             list <- base::list
[16:17:42.830]             seq.int <- base::seq.int
[16:17:42.830]             signalCondition <- base::signalCondition
[16:17:42.830]             sys.calls <- base::sys.calls
[16:17:42.830]             `[[` <- base::`[[`
[16:17:42.830]             `+` <- base::`+`
[16:17:42.830]             `<<-` <- base::`<<-`
[16:17:42.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.830]                   3L)]
[16:17:42.830]             }
[16:17:42.830]             function(cond) {
[16:17:42.830]                 is_error <- inherits(cond, "error")
[16:17:42.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.830]                   NULL)
[16:17:42.830]                 if (is_error) {
[16:17:42.830]                   sessionInformation <- function() {
[16:17:42.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.830]                       search = base::search(), system = base::Sys.info())
[16:17:42.830]                   }
[16:17:42.830]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.830]                     cond$call), session = sessionInformation(), 
[16:17:42.830]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.830]                   signalCondition(cond)
[16:17:42.830]                 }
[16:17:42.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.830]                 "immediateCondition"))) {
[16:17:42.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.830]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.830]                   if (TRUE && !signal) {
[16:17:42.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.830]                     {
[16:17:42.830]                       inherits <- base::inherits
[16:17:42.830]                       invokeRestart <- base::invokeRestart
[16:17:42.830]                       is.null <- base::is.null
[16:17:42.830]                       muffled <- FALSE
[16:17:42.830]                       if (inherits(cond, "message")) {
[16:17:42.830]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.830]                         if (muffled) 
[16:17:42.830]                           invokeRestart("muffleMessage")
[16:17:42.830]                       }
[16:17:42.830]                       else if (inherits(cond, "warning")) {
[16:17:42.830]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.830]                         if (muffled) 
[16:17:42.830]                           invokeRestart("muffleWarning")
[16:17:42.830]                       }
[16:17:42.830]                       else if (inherits(cond, "condition")) {
[16:17:42.830]                         if (!is.null(pattern)) {
[16:17:42.830]                           computeRestarts <- base::computeRestarts
[16:17:42.830]                           grepl <- base::grepl
[16:17:42.830]                           restarts <- computeRestarts(cond)
[16:17:42.830]                           for (restart in restarts) {
[16:17:42.830]                             name <- restart$name
[16:17:42.830]                             if (is.null(name)) 
[16:17:42.830]                               next
[16:17:42.830]                             if (!grepl(pattern, name)) 
[16:17:42.830]                               next
[16:17:42.830]                             invokeRestart(restart)
[16:17:42.830]                             muffled <- TRUE
[16:17:42.830]                             break
[16:17:42.830]                           }
[16:17:42.830]                         }
[16:17:42.830]                       }
[16:17:42.830]                       invisible(muffled)
[16:17:42.830]                     }
[16:17:42.830]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.830]                   }
[16:17:42.830]                 }
[16:17:42.830]                 else {
[16:17:42.830]                   if (TRUE) {
[16:17:42.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.830]                     {
[16:17:42.830]                       inherits <- base::inherits
[16:17:42.830]                       invokeRestart <- base::invokeRestart
[16:17:42.830]                       is.null <- base::is.null
[16:17:42.830]                       muffled <- FALSE
[16:17:42.830]                       if (inherits(cond, "message")) {
[16:17:42.830]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.830]                         if (muffled) 
[16:17:42.830]                           invokeRestart("muffleMessage")
[16:17:42.830]                       }
[16:17:42.830]                       else if (inherits(cond, "warning")) {
[16:17:42.830]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.830]                         if (muffled) 
[16:17:42.830]                           invokeRestart("muffleWarning")
[16:17:42.830]                       }
[16:17:42.830]                       else if (inherits(cond, "condition")) {
[16:17:42.830]                         if (!is.null(pattern)) {
[16:17:42.830]                           computeRestarts <- base::computeRestarts
[16:17:42.830]                           grepl <- base::grepl
[16:17:42.830]                           restarts <- computeRestarts(cond)
[16:17:42.830]                           for (restart in restarts) {
[16:17:42.830]                             name <- restart$name
[16:17:42.830]                             if (is.null(name)) 
[16:17:42.830]                               next
[16:17:42.830]                             if (!grepl(pattern, name)) 
[16:17:42.830]                               next
[16:17:42.830]                             invokeRestart(restart)
[16:17:42.830]                             muffled <- TRUE
[16:17:42.830]                             break
[16:17:42.830]                           }
[16:17:42.830]                         }
[16:17:42.830]                       }
[16:17:42.830]                       invisible(muffled)
[16:17:42.830]                     }
[16:17:42.830]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.830]                   }
[16:17:42.830]                 }
[16:17:42.830]             }
[16:17:42.830]         }))
[16:17:42.830]     }, error = function(ex) {
[16:17:42.830]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.830]                 ...future.rng), started = ...future.startTime, 
[16:17:42.830]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.830]             version = "1.8"), class = "FutureResult")
[16:17:42.830]     }, finally = {
[16:17:42.830]         if (!identical(...future.workdir, getwd())) 
[16:17:42.830]             setwd(...future.workdir)
[16:17:42.830]         {
[16:17:42.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.830]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.830]             }
[16:17:42.830]             base::options(...future.oldOptions)
[16:17:42.830]             if (.Platform$OS.type == "windows") {
[16:17:42.830]                 old_names <- names(...future.oldEnvVars)
[16:17:42.830]                 envs <- base::Sys.getenv()
[16:17:42.830]                 names <- names(envs)
[16:17:42.830]                 common <- intersect(names, old_names)
[16:17:42.830]                 added <- setdiff(names, old_names)
[16:17:42.830]                 removed <- setdiff(old_names, names)
[16:17:42.830]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.830]                   envs[common]]
[16:17:42.830]                 NAMES <- toupper(changed)
[16:17:42.830]                 args <- list()
[16:17:42.830]                 for (kk in seq_along(NAMES)) {
[16:17:42.830]                   name <- changed[[kk]]
[16:17:42.830]                   NAME <- NAMES[[kk]]
[16:17:42.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.830]                     next
[16:17:42.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.830]                 }
[16:17:42.830]                 NAMES <- toupper(added)
[16:17:42.830]                 for (kk in seq_along(NAMES)) {
[16:17:42.830]                   name <- added[[kk]]
[16:17:42.830]                   NAME <- NAMES[[kk]]
[16:17:42.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.830]                     next
[16:17:42.830]                   args[[name]] <- ""
[16:17:42.830]                 }
[16:17:42.830]                 NAMES <- toupper(removed)
[16:17:42.830]                 for (kk in seq_along(NAMES)) {
[16:17:42.830]                   name <- removed[[kk]]
[16:17:42.830]                   NAME <- NAMES[[kk]]
[16:17:42.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.830]                     next
[16:17:42.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.830]                 }
[16:17:42.830]                 if (length(args) > 0) 
[16:17:42.830]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.830]             }
[16:17:42.830]             else {
[16:17:42.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.830]             }
[16:17:42.830]             {
[16:17:42.830]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.830]                   0L) {
[16:17:42.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.830]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.830]                   base::options(opts)
[16:17:42.830]                 }
[16:17:42.830]                 {
[16:17:42.830]                   {
[16:17:42.830]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.830]                     NULL
[16:17:42.830]                   }
[16:17:42.830]                   options(future.plan = NULL)
[16:17:42.830]                   if (is.na(NA_character_)) 
[16:17:42.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.830]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.830]                     .init = FALSE)
[16:17:42.830]                 }
[16:17:42.830]             }
[16:17:42.830]         }
[16:17:42.830]     })
[16:17:42.830]     if (TRUE) {
[16:17:42.830]         base::sink(type = "output", split = FALSE)
[16:17:42.830]         if (TRUE) {
[16:17:42.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.830]         }
[16:17:42.830]         else {
[16:17:42.830]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.830]         }
[16:17:42.830]         base::close(...future.stdout)
[16:17:42.830]         ...future.stdout <- NULL
[16:17:42.830]     }
[16:17:42.830]     ...future.result$conditions <- ...future.conditions
[16:17:42.830]     ...future.result$finished <- base::Sys.time()
[16:17:42.830]     ...future.result
[16:17:42.830] }
[16:17:42.832] assign_globals() ...
[16:17:42.832] List of 5
[16:17:42.832]  $ future.call.arguments    : list()
[16:17:42.832]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.832]  $ ...future.FUN            :function (x)  
[16:17:42.832]  $ ...future.elements_ii    :List of 1
[16:17:42.832]   ..$ : int 2
[16:17:42.832]  $ ...future.seeds_ii       : NULL
[16:17:42.832]  $ ...future.globals.maxSize: num Inf
[16:17:42.832]  - attr(*, "resolved")= logi FALSE
[16:17:42.832]  - attr(*, "total_size")= num NA
[16:17:42.832]  - attr(*, "where")=List of 5
[16:17:42.832]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.832]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.832]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.832]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.832]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.832]  - attr(*, "already-done")= logi TRUE
[16:17:42.840] - copied ‘future.call.arguments’ to environment
[16:17:42.840] - copied ‘...future.FUN’ to environment
[16:17:42.840] - copied ‘...future.elements_ii’ to environment
[16:17:42.841] - copied ‘...future.seeds_ii’ to environment
[16:17:42.841] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.841] assign_globals() ... done
[16:17:42.841] requestCore(): workers = 2
[16:17:42.843] MulticoreFuture started
[16:17:42.843] - Launch lazy future ... done
[16:17:42.844] run() for ‘MulticoreFuture’ ... done
[16:17:42.844] Created future:
[16:17:42.844] plan(): Setting new future strategy stack:
[16:17:42.845] List of future strategies:
[16:17:42.845] 1. sequential:
[16:17:42.845]    - args: function (..., envir = parent.frame())
[16:17:42.845]    - tweaked: FALSE
[16:17:42.845]    - call: NULL
[16:17:42.845] plan(): nbrOfWorkers() = 1
[16:17:42.847] plan(): Setting new future strategy stack:
[16:17:42.848] List of future strategies:
[16:17:42.848] 1. multicore:
[16:17:42.848]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.848]    - tweaked: FALSE
[16:17:42.848]    - call: plan(strategy)
[16:17:42.853] plan(): nbrOfWorkers() = 2
[16:17:42.844] MulticoreFuture:
[16:17:42.844] Label: ‘future_apply-2’
[16:17:42.844] Expression:
[16:17:42.844] {
[16:17:42.844]     do.call(function(...) {
[16:17:42.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.844]             on.exit(options(oopts), add = TRUE)
[16:17:42.844]         }
[16:17:42.844]         {
[16:17:42.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.844]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.844]             })
[16:17:42.844]         }
[16:17:42.844]     }, args = future.call.arguments)
[16:17:42.844] }
[16:17:42.844] Lazy evaluation: FALSE
[16:17:42.844] Asynchronous evaluation: TRUE
[16:17:42.844] Local evaluation: TRUE
[16:17:42.844] Environment: R_GlobalEnv
[16:17:42.844] Capture standard output: TRUE
[16:17:42.844] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.844] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.844] Packages: <none>
[16:17:42.844] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.844] Resolved: TRUE
[16:17:42.844] Value: <not collected>
[16:17:42.844] Conditions captured: <none>
[16:17:42.844] Early signaling: FALSE
[16:17:42.844] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.844] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.854] Chunk #2 of 2 ... DONE
[16:17:42.854] Launching 2 futures (chunks) ... DONE
[16:17:42.854] Resolving 2 futures (chunks) ...
[16:17:42.854] resolve() on list ...
[16:17:42.854]  recursive: 0
[16:17:42.855]  length: 2
[16:17:42.855] 
[16:17:42.855] Future #1
[16:17:42.855] result() for MulticoreFuture ...
[16:17:42.856] result() for MulticoreFuture ...
[16:17:42.856] result() for MulticoreFuture ... done
[16:17:42.856] result() for MulticoreFuture ... done
[16:17:42.857] result() for MulticoreFuture ...
[16:17:42.857] result() for MulticoreFuture ... done
[16:17:42.857] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:42.857] - nx: 2
[16:17:42.857] - relay: TRUE
[16:17:42.857] - stdout: TRUE
[16:17:42.857] - signal: TRUE
[16:17:42.858] - resignal: FALSE
[16:17:42.858] - force: TRUE
[16:17:42.858] - relayed: [n=2] FALSE, FALSE
[16:17:42.858] - queued futures: [n=2] FALSE, FALSE
[16:17:42.858]  - until=1
[16:17:42.858]  - relaying element #1
[16:17:42.859] result() for MulticoreFuture ...
[16:17:42.859] result() for MulticoreFuture ... done
[16:17:42.859] result() for MulticoreFuture ...
[16:17:42.859] result() for MulticoreFuture ... done
[16:17:42.859] result() for MulticoreFuture ...
[16:17:42.859] result() for MulticoreFuture ... done
[16:17:42.860] result() for MulticoreFuture ...
[16:17:42.860] result() for MulticoreFuture ... done
[16:17:42.860] - relayed: [n=2] TRUE, FALSE
[16:17:42.860] - queued futures: [n=2] TRUE, FALSE
[16:17:42.860] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:42.860]  length: 1 (resolved future 1)
[16:17:42.861] Future #2
[16:17:42.861] result() for MulticoreFuture ...
[16:17:42.862] result() for MulticoreFuture ...
[16:17:42.862] result() for MulticoreFuture ... done
[16:17:42.862] result() for MulticoreFuture ... done
[16:17:42.862] result() for MulticoreFuture ...
[16:17:42.862] result() for MulticoreFuture ... done
[16:17:42.863] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:42.863] - nx: 2
[16:17:42.863] - relay: TRUE
[16:17:42.863] - stdout: TRUE
[16:17:42.863] - signal: TRUE
[16:17:42.863] - resignal: FALSE
[16:17:42.863] - force: TRUE
[16:17:42.863] - relayed: [n=2] TRUE, FALSE
[16:17:42.864] - queued futures: [n=2] TRUE, FALSE
[16:17:42.864]  - until=2
[16:17:42.864]  - relaying element #2
[16:17:42.864] result() for MulticoreFuture ...
[16:17:42.864] result() for MulticoreFuture ... done
[16:17:42.864] result() for MulticoreFuture ...
[16:17:42.864] result() for MulticoreFuture ... done
[16:17:42.864] result() for MulticoreFuture ...
[16:17:42.865] result() for MulticoreFuture ... done
[16:17:42.865] result() for MulticoreFuture ...
[16:17:42.865] result() for MulticoreFuture ... done
[16:17:42.865] - relayed: [n=2] TRUE, TRUE
[16:17:42.865] - queued futures: [n=2] TRUE, TRUE
[16:17:42.865] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:42.865]  length: 0 (resolved future 2)
[16:17:42.865] Relaying remaining futures
[16:17:42.865] signalConditionsASAP(NULL, pos=0) ...
[16:17:42.866] - nx: 2
[16:17:42.866] - relay: TRUE
[16:17:42.866] - stdout: TRUE
[16:17:42.866] - signal: TRUE
[16:17:42.866] - resignal: FALSE
[16:17:42.866] - force: TRUE
[16:17:42.866] - relayed: [n=2] TRUE, TRUE
[16:17:42.866] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:42.866] - relayed: [n=2] TRUE, TRUE
[16:17:42.867] - queued futures: [n=2] TRUE, TRUE
[16:17:42.867] signalConditionsASAP(NULL, pos=0) ... done
[16:17:42.867] resolve() on list ... DONE
[16:17:42.867] result() for MulticoreFuture ...
[16:17:42.867] result() for MulticoreFuture ... done
[16:17:42.869] result() for MulticoreFuture ...
[16:17:42.870] result() for MulticoreFuture ... done
[16:17:42.870] result() for MulticoreFuture ...
[16:17:42.870] result() for MulticoreFuture ... done
[16:17:42.870] result() for MulticoreFuture ...
[16:17:42.870] result() for MulticoreFuture ... done
[16:17:42.871]  - Number of value chunks collected: 2
[16:17:42.871] Resolving 2 futures (chunks) ... DONE
[16:17:42.871] Reducing values from 2 chunks ...
[16:17:42.871]  - Number of values collected after concatenation: 2
[16:17:42.871]  - Number of values expected: 2
[16:17:42.871] Reducing values from 2 chunks ... DONE
[16:17:42.871] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:17:42.872] getGlobalsAndPackagesXApply() ...
[16:17:42.872]  - future.globals: TRUE
[16:17:42.872] getGlobalsAndPackages() ...
[16:17:42.872] Searching for globals...
[16:17:42.874] - globals found: [1] ‘FUN’
[16:17:42.874] Searching for globals ... DONE
[16:17:42.874] Resolving globals: FALSE
[16:17:42.875] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:42.875] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:42.875] - globals: [1] ‘FUN’
[16:17:42.875] 
[16:17:42.876] getGlobalsAndPackages() ... DONE
[16:17:42.876]  - globals found/used: [n=1] ‘FUN’
[16:17:42.876]  - needed namespaces: [n=0] 
[16:17:42.876] Finding globals ... DONE
[16:17:42.876]  - use_args: TRUE
[16:17:42.876]  - Getting '...' globals ...
[16:17:42.877] resolve() on list ...
[16:17:42.877]  recursive: 0
[16:17:42.877]  length: 1
[16:17:42.877]  elements: ‘...’
[16:17:42.877]  length: 0 (resolved future 1)
[16:17:42.877] resolve() on list ... DONE
[16:17:42.877]    - '...' content: [n=0] 
[16:17:42.878] List of 1
[16:17:42.878]  $ ...: list()
[16:17:42.878]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.878]  - attr(*, "where")=List of 1
[16:17:42.878]   ..$ ...:<environment: 0x555be0fc80e8> 
[16:17:42.878]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.878]  - attr(*, "resolved")= logi TRUE
[16:17:42.878]  - attr(*, "total_size")= num NA
[16:17:42.881]  - Getting '...' globals ... DONE
[16:17:42.881] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:42.881] List of 2
[16:17:42.881]  $ ...future.FUN:function (x)  
[16:17:42.881]  $ ...          : list()
[16:17:42.881]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.881]  - attr(*, "where")=List of 2
[16:17:42.881]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:42.881]   ..$ ...          :<environment: 0x555be0fc80e8> 
[16:17:42.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.881]  - attr(*, "resolved")= logi FALSE
[16:17:42.881]  - attr(*, "total_size")= num 848
[16:17:42.884] Packages to be attached in all futures: [n=0] 
[16:17:42.884] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.887] future_lapply() ...
[16:17:42.891] Number of chunks: 2
[16:17:42.891] getGlobalsAndPackagesXApply() ...
[16:17:42.892]  - future.globals: <name-value list> with names ‘list()’
[16:17:42.892]  - use_args: TRUE
[16:17:42.892] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:42.892] List of 2
[16:17:42.892]  $ ...          : list()
[16:17:42.892]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.892]  $ ...future.FUN:function (x)  
[16:17:42.892]  - attr(*, "where")=List of 2
[16:17:42.892]   ..$ ...          :<environment: 0x555be0fc80e8> 
[16:17:42.892]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:42.892]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.892]  - attr(*, "resolved")= logi FALSE
[16:17:42.892]  - attr(*, "total_size")= num NA
[16:17:42.896] Packages to be attached in all futures: [n=0] 
[16:17:42.896] getGlobalsAndPackagesXApply() ... DONE
[16:17:42.896] Number of futures (= number of chunks): 2
[16:17:42.896] Launching 2 futures (chunks) ...
[16:17:42.896] Chunk #1 of 2 ...
[16:17:42.897]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.897]  - seeds: <none>
[16:17:42.897]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.897] getGlobalsAndPackages() ...
[16:17:42.897] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.897] Resolving globals: FALSE
[16:17:42.899] Tweak future expression to call with '...' arguments ...
[16:17:42.899] {
[16:17:42.899]     do.call(function(...) {
[16:17:42.899]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.899]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.899]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.899]             on.exit(options(oopts), add = TRUE)
[16:17:42.899]         }
[16:17:42.899]         {
[16:17:42.899]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.899]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.899]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.899]             })
[16:17:42.899]         }
[16:17:42.899]     }, args = future.call.arguments)
[16:17:42.899] }
[16:17:42.900] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.900] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.900] 
[16:17:42.901] getGlobalsAndPackages() ... DONE
[16:17:42.901] run() for ‘Future’ ...
[16:17:42.901] - state: ‘created’
[16:17:42.901] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.905] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.905] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.905]   - Field: ‘label’
[16:17:42.906]   - Field: ‘local’
[16:17:42.906]   - Field: ‘owner’
[16:17:42.906]   - Field: ‘envir’
[16:17:42.906]   - Field: ‘workers’
[16:17:42.906]   - Field: ‘packages’
[16:17:42.906]   - Field: ‘gc’
[16:17:42.906]   - Field: ‘job’
[16:17:42.906]   - Field: ‘conditions’
[16:17:42.906]   - Field: ‘expr’
[16:17:42.907]   - Field: ‘uuid’
[16:17:42.907]   - Field: ‘seed’
[16:17:42.907]   - Field: ‘version’
[16:17:42.907]   - Field: ‘result’
[16:17:42.907]   - Field: ‘asynchronous’
[16:17:42.907]   - Field: ‘calls’
[16:17:42.907]   - Field: ‘globals’
[16:17:42.907]   - Field: ‘stdout’
[16:17:42.907]   - Field: ‘earlySignal’
[16:17:42.907]   - Field: ‘lazy’
[16:17:42.907]   - Field: ‘state’
[16:17:42.908] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.908] - Launch lazy future ...
[16:17:42.908] Packages needed by the future expression (n = 0): <none>
[16:17:42.908] Packages needed by future strategies (n = 0): <none>
[16:17:42.909] {
[16:17:42.909]     {
[16:17:42.909]         {
[16:17:42.909]             ...future.startTime <- base::Sys.time()
[16:17:42.909]             {
[16:17:42.909]                 {
[16:17:42.909]                   {
[16:17:42.909]                     {
[16:17:42.909]                       base::local({
[16:17:42.909]                         has_future <- base::requireNamespace("future", 
[16:17:42.909]                           quietly = TRUE)
[16:17:42.909]                         if (has_future) {
[16:17:42.909]                           ns <- base::getNamespace("future")
[16:17:42.909]                           version <- ns[[".package"]][["version"]]
[16:17:42.909]                           if (is.null(version)) 
[16:17:42.909]                             version <- utils::packageVersion("future")
[16:17:42.909]                         }
[16:17:42.909]                         else {
[16:17:42.909]                           version <- NULL
[16:17:42.909]                         }
[16:17:42.909]                         if (!has_future || version < "1.8.0") {
[16:17:42.909]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.909]                             "", base::R.version$version.string), 
[16:17:42.909]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.909]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.909]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.909]                               "release", "version")], collapse = " "), 
[16:17:42.909]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.909]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.909]                             info)
[16:17:42.909]                           info <- base::paste(info, collapse = "; ")
[16:17:42.909]                           if (!has_future) {
[16:17:42.909]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.909]                               info)
[16:17:42.909]                           }
[16:17:42.909]                           else {
[16:17:42.909]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.909]                               info, version)
[16:17:42.909]                           }
[16:17:42.909]                           base::stop(msg)
[16:17:42.909]                         }
[16:17:42.909]                       })
[16:17:42.909]                     }
[16:17:42.909]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.909]                     base::options(mc.cores = 1L)
[16:17:42.909]                   }
[16:17:42.909]                   ...future.strategy.old <- future::plan("list")
[16:17:42.909]                   options(future.plan = NULL)
[16:17:42.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.909]                 }
[16:17:42.909]                 ...future.workdir <- getwd()
[16:17:42.909]             }
[16:17:42.909]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.909]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.909]         }
[16:17:42.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.909]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.909]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.909]             base::names(...future.oldOptions))
[16:17:42.909]     }
[16:17:42.909]     if (FALSE) {
[16:17:42.909]     }
[16:17:42.909]     else {
[16:17:42.909]         if (TRUE) {
[16:17:42.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.909]                 open = "w")
[16:17:42.909]         }
[16:17:42.909]         else {
[16:17:42.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.909]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.909]         }
[16:17:42.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.909]             base::sink(type = "output", split = FALSE)
[16:17:42.909]             base::close(...future.stdout)
[16:17:42.909]         }, add = TRUE)
[16:17:42.909]     }
[16:17:42.909]     ...future.frame <- base::sys.nframe()
[16:17:42.909]     ...future.conditions <- base::list()
[16:17:42.909]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.909]     if (FALSE) {
[16:17:42.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.909]     }
[16:17:42.909]     ...future.result <- base::tryCatch({
[16:17:42.909]         base::withCallingHandlers({
[16:17:42.909]             ...future.value <- base::withVisible(base::local({
[16:17:42.909]                 withCallingHandlers({
[16:17:42.909]                   {
[16:17:42.909]                     do.call(function(...) {
[16:17:42.909]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.909]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.909]                         ...future.globals.maxSize)) {
[16:17:42.909]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.909]                         on.exit(options(oopts), add = TRUE)
[16:17:42.909]                       }
[16:17:42.909]                       {
[16:17:42.909]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.909]                           FUN = function(jj) {
[16:17:42.909]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.909]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.909]                           })
[16:17:42.909]                       }
[16:17:42.909]                     }, args = future.call.arguments)
[16:17:42.909]                   }
[16:17:42.909]                 }, immediateCondition = function(cond) {
[16:17:42.909]                   save_rds <- function (object, pathname, ...) 
[16:17:42.909]                   {
[16:17:42.909]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.909]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.909]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.909]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.909]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.909]                         fi_tmp[["mtime"]])
[16:17:42.909]                     }
[16:17:42.909]                     tryCatch({
[16:17:42.909]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.909]                     }, error = function(ex) {
[16:17:42.909]                       msg <- conditionMessage(ex)
[16:17:42.909]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.909]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.909]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.909]                         fi_tmp[["mtime"]], msg)
[16:17:42.909]                       ex$message <- msg
[16:17:42.909]                       stop(ex)
[16:17:42.909]                     })
[16:17:42.909]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.909]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.909]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.909]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.909]                       fi <- file.info(pathname)
[16:17:42.909]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.909]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.909]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.909]                         fi[["size"]], fi[["mtime"]])
[16:17:42.909]                       stop(msg)
[16:17:42.909]                     }
[16:17:42.909]                     invisible(pathname)
[16:17:42.909]                   }
[16:17:42.909]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.909]                     rootPath = tempdir()) 
[16:17:42.909]                   {
[16:17:42.909]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.909]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.909]                       tmpdir = path, fileext = ".rds")
[16:17:42.909]                     save_rds(obj, file)
[16:17:42.909]                   }
[16:17:42.909]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.909]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.909]                   {
[16:17:42.909]                     inherits <- base::inherits
[16:17:42.909]                     invokeRestart <- base::invokeRestart
[16:17:42.909]                     is.null <- base::is.null
[16:17:42.909]                     muffled <- FALSE
[16:17:42.909]                     if (inherits(cond, "message")) {
[16:17:42.909]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.909]                       if (muffled) 
[16:17:42.909]                         invokeRestart("muffleMessage")
[16:17:42.909]                     }
[16:17:42.909]                     else if (inherits(cond, "warning")) {
[16:17:42.909]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.909]                       if (muffled) 
[16:17:42.909]                         invokeRestart("muffleWarning")
[16:17:42.909]                     }
[16:17:42.909]                     else if (inherits(cond, "condition")) {
[16:17:42.909]                       if (!is.null(pattern)) {
[16:17:42.909]                         computeRestarts <- base::computeRestarts
[16:17:42.909]                         grepl <- base::grepl
[16:17:42.909]                         restarts <- computeRestarts(cond)
[16:17:42.909]                         for (restart in restarts) {
[16:17:42.909]                           name <- restart$name
[16:17:42.909]                           if (is.null(name)) 
[16:17:42.909]                             next
[16:17:42.909]                           if (!grepl(pattern, name)) 
[16:17:42.909]                             next
[16:17:42.909]                           invokeRestart(restart)
[16:17:42.909]                           muffled <- TRUE
[16:17:42.909]                           break
[16:17:42.909]                         }
[16:17:42.909]                       }
[16:17:42.909]                     }
[16:17:42.909]                     invisible(muffled)
[16:17:42.909]                   }
[16:17:42.909]                   muffleCondition(cond)
[16:17:42.909]                 })
[16:17:42.909]             }))
[16:17:42.909]             future::FutureResult(value = ...future.value$value, 
[16:17:42.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.909]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.909]                     ...future.globalenv.names))
[16:17:42.909]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.909]         }, condition = base::local({
[16:17:42.909]             c <- base::c
[16:17:42.909]             inherits <- base::inherits
[16:17:42.909]             invokeRestart <- base::invokeRestart
[16:17:42.909]             length <- base::length
[16:17:42.909]             list <- base::list
[16:17:42.909]             seq.int <- base::seq.int
[16:17:42.909]             signalCondition <- base::signalCondition
[16:17:42.909]             sys.calls <- base::sys.calls
[16:17:42.909]             `[[` <- base::`[[`
[16:17:42.909]             `+` <- base::`+`
[16:17:42.909]             `<<-` <- base::`<<-`
[16:17:42.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.909]                   3L)]
[16:17:42.909]             }
[16:17:42.909]             function(cond) {
[16:17:42.909]                 is_error <- inherits(cond, "error")
[16:17:42.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.909]                   NULL)
[16:17:42.909]                 if (is_error) {
[16:17:42.909]                   sessionInformation <- function() {
[16:17:42.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.909]                       search = base::search(), system = base::Sys.info())
[16:17:42.909]                   }
[16:17:42.909]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.909]                     cond$call), session = sessionInformation(), 
[16:17:42.909]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.909]                   signalCondition(cond)
[16:17:42.909]                 }
[16:17:42.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.909]                 "immediateCondition"))) {
[16:17:42.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.909]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.909]                   if (TRUE && !signal) {
[16:17:42.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.909]                     {
[16:17:42.909]                       inherits <- base::inherits
[16:17:42.909]                       invokeRestart <- base::invokeRestart
[16:17:42.909]                       is.null <- base::is.null
[16:17:42.909]                       muffled <- FALSE
[16:17:42.909]                       if (inherits(cond, "message")) {
[16:17:42.909]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.909]                         if (muffled) 
[16:17:42.909]                           invokeRestart("muffleMessage")
[16:17:42.909]                       }
[16:17:42.909]                       else if (inherits(cond, "warning")) {
[16:17:42.909]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.909]                         if (muffled) 
[16:17:42.909]                           invokeRestart("muffleWarning")
[16:17:42.909]                       }
[16:17:42.909]                       else if (inherits(cond, "condition")) {
[16:17:42.909]                         if (!is.null(pattern)) {
[16:17:42.909]                           computeRestarts <- base::computeRestarts
[16:17:42.909]                           grepl <- base::grepl
[16:17:42.909]                           restarts <- computeRestarts(cond)
[16:17:42.909]                           for (restart in restarts) {
[16:17:42.909]                             name <- restart$name
[16:17:42.909]                             if (is.null(name)) 
[16:17:42.909]                               next
[16:17:42.909]                             if (!grepl(pattern, name)) 
[16:17:42.909]                               next
[16:17:42.909]                             invokeRestart(restart)
[16:17:42.909]                             muffled <- TRUE
[16:17:42.909]                             break
[16:17:42.909]                           }
[16:17:42.909]                         }
[16:17:42.909]                       }
[16:17:42.909]                       invisible(muffled)
[16:17:42.909]                     }
[16:17:42.909]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.909]                   }
[16:17:42.909]                 }
[16:17:42.909]                 else {
[16:17:42.909]                   if (TRUE) {
[16:17:42.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.909]                     {
[16:17:42.909]                       inherits <- base::inherits
[16:17:42.909]                       invokeRestart <- base::invokeRestart
[16:17:42.909]                       is.null <- base::is.null
[16:17:42.909]                       muffled <- FALSE
[16:17:42.909]                       if (inherits(cond, "message")) {
[16:17:42.909]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.909]                         if (muffled) 
[16:17:42.909]                           invokeRestart("muffleMessage")
[16:17:42.909]                       }
[16:17:42.909]                       else if (inherits(cond, "warning")) {
[16:17:42.909]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.909]                         if (muffled) 
[16:17:42.909]                           invokeRestart("muffleWarning")
[16:17:42.909]                       }
[16:17:42.909]                       else if (inherits(cond, "condition")) {
[16:17:42.909]                         if (!is.null(pattern)) {
[16:17:42.909]                           computeRestarts <- base::computeRestarts
[16:17:42.909]                           grepl <- base::grepl
[16:17:42.909]                           restarts <- computeRestarts(cond)
[16:17:42.909]                           for (restart in restarts) {
[16:17:42.909]                             name <- restart$name
[16:17:42.909]                             if (is.null(name)) 
[16:17:42.909]                               next
[16:17:42.909]                             if (!grepl(pattern, name)) 
[16:17:42.909]                               next
[16:17:42.909]                             invokeRestart(restart)
[16:17:42.909]                             muffled <- TRUE
[16:17:42.909]                             break
[16:17:42.909]                           }
[16:17:42.909]                         }
[16:17:42.909]                       }
[16:17:42.909]                       invisible(muffled)
[16:17:42.909]                     }
[16:17:42.909]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.909]                   }
[16:17:42.909]                 }
[16:17:42.909]             }
[16:17:42.909]         }))
[16:17:42.909]     }, error = function(ex) {
[16:17:42.909]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.909]                 ...future.rng), started = ...future.startTime, 
[16:17:42.909]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.909]             version = "1.8"), class = "FutureResult")
[16:17:42.909]     }, finally = {
[16:17:42.909]         if (!identical(...future.workdir, getwd())) 
[16:17:42.909]             setwd(...future.workdir)
[16:17:42.909]         {
[16:17:42.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.909]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.909]             }
[16:17:42.909]             base::options(...future.oldOptions)
[16:17:42.909]             if (.Platform$OS.type == "windows") {
[16:17:42.909]                 old_names <- names(...future.oldEnvVars)
[16:17:42.909]                 envs <- base::Sys.getenv()
[16:17:42.909]                 names <- names(envs)
[16:17:42.909]                 common <- intersect(names, old_names)
[16:17:42.909]                 added <- setdiff(names, old_names)
[16:17:42.909]                 removed <- setdiff(old_names, names)
[16:17:42.909]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.909]                   envs[common]]
[16:17:42.909]                 NAMES <- toupper(changed)
[16:17:42.909]                 args <- list()
[16:17:42.909]                 for (kk in seq_along(NAMES)) {
[16:17:42.909]                   name <- changed[[kk]]
[16:17:42.909]                   NAME <- NAMES[[kk]]
[16:17:42.909]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.909]                     next
[16:17:42.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.909]                 }
[16:17:42.909]                 NAMES <- toupper(added)
[16:17:42.909]                 for (kk in seq_along(NAMES)) {
[16:17:42.909]                   name <- added[[kk]]
[16:17:42.909]                   NAME <- NAMES[[kk]]
[16:17:42.909]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.909]                     next
[16:17:42.909]                   args[[name]] <- ""
[16:17:42.909]                 }
[16:17:42.909]                 NAMES <- toupper(removed)
[16:17:42.909]                 for (kk in seq_along(NAMES)) {
[16:17:42.909]                   name <- removed[[kk]]
[16:17:42.909]                   NAME <- NAMES[[kk]]
[16:17:42.909]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.909]                     next
[16:17:42.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.909]                 }
[16:17:42.909]                 if (length(args) > 0) 
[16:17:42.909]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.909]             }
[16:17:42.909]             else {
[16:17:42.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.909]             }
[16:17:42.909]             {
[16:17:42.909]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.909]                   0L) {
[16:17:42.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.909]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.909]                   base::options(opts)
[16:17:42.909]                 }
[16:17:42.909]                 {
[16:17:42.909]                   {
[16:17:42.909]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.909]                     NULL
[16:17:42.909]                   }
[16:17:42.909]                   options(future.plan = NULL)
[16:17:42.909]                   if (is.na(NA_character_)) 
[16:17:42.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.909]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.909]                     .init = FALSE)
[16:17:42.909]                 }
[16:17:42.909]             }
[16:17:42.909]         }
[16:17:42.909]     })
[16:17:42.909]     if (TRUE) {
[16:17:42.909]         base::sink(type = "output", split = FALSE)
[16:17:42.909]         if (TRUE) {
[16:17:42.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.909]         }
[16:17:42.909]         else {
[16:17:42.909]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.909]         }
[16:17:42.909]         base::close(...future.stdout)
[16:17:42.909]         ...future.stdout <- NULL
[16:17:42.909]     }
[16:17:42.909]     ...future.result$conditions <- ...future.conditions
[16:17:42.909]     ...future.result$finished <- base::Sys.time()
[16:17:42.909]     ...future.result
[16:17:42.909] }
[16:17:42.911] assign_globals() ...
[16:17:42.911] List of 5
[16:17:42.911]  $ future.call.arguments    : list()
[16:17:42.911]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.911]  $ ...future.FUN            :function (x)  
[16:17:42.911]  $ ...future.elements_ii    :List of 1
[16:17:42.911]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[16:17:42.911]  $ ...future.seeds_ii       : NULL
[16:17:42.911]  $ ...future.globals.maxSize: num Inf
[16:17:42.911]  - attr(*, "resolved")= logi FALSE
[16:17:42.911]  - attr(*, "total_size")= num NA
[16:17:42.911]  - attr(*, "where")=List of 5
[16:17:42.911]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.911]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.911]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.911]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.911]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.911]  - attr(*, "already-done")= logi TRUE
[16:17:42.916] - copied ‘future.call.arguments’ to environment
[16:17:42.916] - copied ‘...future.FUN’ to environment
[16:17:42.916] - copied ‘...future.elements_ii’ to environment
[16:17:42.916] - copied ‘...future.seeds_ii’ to environment
[16:17:42.916] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.917] assign_globals() ... done
[16:17:42.917] requestCore(): workers = 2
[16:17:42.919] MulticoreFuture started
[16:17:42.919] - Launch lazy future ... done
[16:17:42.920] run() for ‘MulticoreFuture’ ... done
[16:17:42.920] Created future:
[16:17:42.920] plan(): Setting new future strategy stack:
[16:17:42.920] List of future strategies:
[16:17:42.920] 1. sequential:
[16:17:42.920]    - args: function (..., envir = parent.frame())
[16:17:42.920]    - tweaked: FALSE
[16:17:42.920]    - call: NULL
[16:17:42.921] plan(): nbrOfWorkers() = 1
[16:17:42.923] plan(): Setting new future strategy stack:
[16:17:42.924] List of future strategies:
[16:17:42.924] 1. multicore:
[16:17:42.924]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.924]    - tweaked: FALSE
[16:17:42.924]    - call: plan(strategy)
[16:17:42.929] plan(): nbrOfWorkers() = 2
[16:17:42.920] MulticoreFuture:
[16:17:42.920] Label: ‘future_apply-1’
[16:17:42.920] Expression:
[16:17:42.920] {
[16:17:42.920]     do.call(function(...) {
[16:17:42.920]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.920]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.920]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.920]             on.exit(options(oopts), add = TRUE)
[16:17:42.920]         }
[16:17:42.920]         {
[16:17:42.920]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.920]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.920]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.920]             })
[16:17:42.920]         }
[16:17:42.920]     }, args = future.call.arguments)
[16:17:42.920] }
[16:17:42.920] Lazy evaluation: FALSE
[16:17:42.920] Asynchronous evaluation: TRUE
[16:17:42.920] Local evaluation: TRUE
[16:17:42.920] Environment: R_GlobalEnv
[16:17:42.920] Capture standard output: TRUE
[16:17:42.920] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.920] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.920] Packages: <none>
[16:17:42.920] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.920] Resolved: TRUE
[16:17:42.920] Value: <not collected>
[16:17:42.920] Conditions captured: <none>
[16:17:42.920] Early signaling: FALSE
[16:17:42.920] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.920] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.930] Chunk #1 of 2 ... DONE
[16:17:42.930] Chunk #2 of 2 ...
[16:17:42.930]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:42.931]  - seeds: <none>
[16:17:42.931]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.931] getGlobalsAndPackages() ...
[16:17:42.931] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.931] Resolving globals: FALSE
[16:17:42.931] Tweak future expression to call with '...' arguments ...
[16:17:42.932] {
[16:17:42.932]     do.call(function(...) {
[16:17:42.932]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.932]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.932]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.932]             on.exit(options(oopts), add = TRUE)
[16:17:42.932]         }
[16:17:42.932]         {
[16:17:42.932]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.932]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.932]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.932]             })
[16:17:42.932]         }
[16:17:42.932]     }, args = future.call.arguments)
[16:17:42.932] }
[16:17:42.932] Tweak future expression to call with '...' arguments ... DONE
[16:17:42.933] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:42.933] 
[16:17:42.933] getGlobalsAndPackages() ... DONE
[16:17:42.934] run() for ‘Future’ ...
[16:17:42.934] - state: ‘created’
[16:17:42.934] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:42.939] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:42.939]   - Field: ‘label’
[16:17:42.939]   - Field: ‘local’
[16:17:42.939]   - Field: ‘owner’
[16:17:42.939]   - Field: ‘envir’
[16:17:42.940]   - Field: ‘workers’
[16:17:42.940]   - Field: ‘packages’
[16:17:42.940]   - Field: ‘gc’
[16:17:42.940]   - Field: ‘job’
[16:17:42.940]   - Field: ‘conditions’
[16:17:42.940]   - Field: ‘expr’
[16:17:42.941]   - Field: ‘uuid’
[16:17:42.941]   - Field: ‘seed’
[16:17:42.941]   - Field: ‘version’
[16:17:42.941]   - Field: ‘result’
[16:17:42.941]   - Field: ‘asynchronous’
[16:17:42.945]   - Field: ‘calls’
[16:17:42.945]   - Field: ‘globals’
[16:17:42.945]   - Field: ‘stdout’
[16:17:42.946]   - Field: ‘earlySignal’
[16:17:42.946]   - Field: ‘lazy’
[16:17:42.946]   - Field: ‘state’
[16:17:42.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:42.947] - Launch lazy future ...
[16:17:42.947] Packages needed by the future expression (n = 0): <none>
[16:17:42.948] Packages needed by future strategies (n = 0): <none>
[16:17:42.949] {
[16:17:42.949]     {
[16:17:42.949]         {
[16:17:42.949]             ...future.startTime <- base::Sys.time()
[16:17:42.949]             {
[16:17:42.949]                 {
[16:17:42.949]                   {
[16:17:42.949]                     {
[16:17:42.949]                       base::local({
[16:17:42.949]                         has_future <- base::requireNamespace("future", 
[16:17:42.949]                           quietly = TRUE)
[16:17:42.949]                         if (has_future) {
[16:17:42.949]                           ns <- base::getNamespace("future")
[16:17:42.949]                           version <- ns[[".package"]][["version"]]
[16:17:42.949]                           if (is.null(version)) 
[16:17:42.949]                             version <- utils::packageVersion("future")
[16:17:42.949]                         }
[16:17:42.949]                         else {
[16:17:42.949]                           version <- NULL
[16:17:42.949]                         }
[16:17:42.949]                         if (!has_future || version < "1.8.0") {
[16:17:42.949]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:42.949]                             "", base::R.version$version.string), 
[16:17:42.949]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:42.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:42.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:42.949]                               "release", "version")], collapse = " "), 
[16:17:42.949]                             hostname = base::Sys.info()[["nodename"]])
[16:17:42.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:42.949]                             info)
[16:17:42.949]                           info <- base::paste(info, collapse = "; ")
[16:17:42.949]                           if (!has_future) {
[16:17:42.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:42.949]                               info)
[16:17:42.949]                           }
[16:17:42.949]                           else {
[16:17:42.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:42.949]                               info, version)
[16:17:42.949]                           }
[16:17:42.949]                           base::stop(msg)
[16:17:42.949]                         }
[16:17:42.949]                       })
[16:17:42.949]                     }
[16:17:42.949]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:42.949]                     base::options(mc.cores = 1L)
[16:17:42.949]                   }
[16:17:42.949]                   ...future.strategy.old <- future::plan("list")
[16:17:42.949]                   options(future.plan = NULL)
[16:17:42.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:42.949]                 }
[16:17:42.949]                 ...future.workdir <- getwd()
[16:17:42.949]             }
[16:17:42.949]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:42.949]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:42.949]         }
[16:17:42.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:42.949]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:42.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:42.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:42.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:42.949]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:42.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:42.949]             base::names(...future.oldOptions))
[16:17:42.949]     }
[16:17:42.949]     if (FALSE) {
[16:17:42.949]     }
[16:17:42.949]     else {
[16:17:42.949]         if (TRUE) {
[16:17:42.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:42.949]                 open = "w")
[16:17:42.949]         }
[16:17:42.949]         else {
[16:17:42.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:42.949]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:42.949]         }
[16:17:42.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:42.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:42.949]             base::sink(type = "output", split = FALSE)
[16:17:42.949]             base::close(...future.stdout)
[16:17:42.949]         }, add = TRUE)
[16:17:42.949]     }
[16:17:42.949]     ...future.frame <- base::sys.nframe()
[16:17:42.949]     ...future.conditions <- base::list()
[16:17:42.949]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:42.949]     if (FALSE) {
[16:17:42.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:42.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:42.949]     }
[16:17:42.949]     ...future.result <- base::tryCatch({
[16:17:42.949]         base::withCallingHandlers({
[16:17:42.949]             ...future.value <- base::withVisible(base::local({
[16:17:42.949]                 withCallingHandlers({
[16:17:42.949]                   {
[16:17:42.949]                     do.call(function(...) {
[16:17:42.949]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.949]                       if (!identical(...future.globals.maxSize.org, 
[16:17:42.949]                         ...future.globals.maxSize)) {
[16:17:42.949]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.949]                         on.exit(options(oopts), add = TRUE)
[16:17:42.949]                       }
[16:17:42.949]                       {
[16:17:42.949]                         lapply(seq_along(...future.elements_ii), 
[16:17:42.949]                           FUN = function(jj) {
[16:17:42.949]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.949]                             ...future.FUN(...future.X_jj, ...)
[16:17:42.949]                           })
[16:17:42.949]                       }
[16:17:42.949]                     }, args = future.call.arguments)
[16:17:42.949]                   }
[16:17:42.949]                 }, immediateCondition = function(cond) {
[16:17:42.949]                   save_rds <- function (object, pathname, ...) 
[16:17:42.949]                   {
[16:17:42.949]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:42.949]                     if (file_test("-f", pathname_tmp)) {
[16:17:42.949]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.949]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:42.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.949]                         fi_tmp[["mtime"]])
[16:17:42.949]                     }
[16:17:42.949]                     tryCatch({
[16:17:42.949]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:42.949]                     }, error = function(ex) {
[16:17:42.949]                       msg <- conditionMessage(ex)
[16:17:42.949]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.949]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:42.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.949]                         fi_tmp[["mtime"]], msg)
[16:17:42.949]                       ex$message <- msg
[16:17:42.949]                       stop(ex)
[16:17:42.949]                     })
[16:17:42.949]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:42.949]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:42.949]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:42.949]                       fi_tmp <- file.info(pathname_tmp)
[16:17:42.949]                       fi <- file.info(pathname)
[16:17:42.949]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:42.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:42.949]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:42.949]                         fi[["size"]], fi[["mtime"]])
[16:17:42.949]                       stop(msg)
[16:17:42.949]                     }
[16:17:42.949]                     invisible(pathname)
[16:17:42.949]                   }
[16:17:42.949]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:42.949]                     rootPath = tempdir()) 
[16:17:42.949]                   {
[16:17:42.949]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:42.949]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:42.949]                       tmpdir = path, fileext = ".rds")
[16:17:42.949]                     save_rds(obj, file)
[16:17:42.949]                   }
[16:17:42.949]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:42.949]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.949]                   {
[16:17:42.949]                     inherits <- base::inherits
[16:17:42.949]                     invokeRestart <- base::invokeRestart
[16:17:42.949]                     is.null <- base::is.null
[16:17:42.949]                     muffled <- FALSE
[16:17:42.949]                     if (inherits(cond, "message")) {
[16:17:42.949]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:42.949]                       if (muffled) 
[16:17:42.949]                         invokeRestart("muffleMessage")
[16:17:42.949]                     }
[16:17:42.949]                     else if (inherits(cond, "warning")) {
[16:17:42.949]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:42.949]                       if (muffled) 
[16:17:42.949]                         invokeRestart("muffleWarning")
[16:17:42.949]                     }
[16:17:42.949]                     else if (inherits(cond, "condition")) {
[16:17:42.949]                       if (!is.null(pattern)) {
[16:17:42.949]                         computeRestarts <- base::computeRestarts
[16:17:42.949]                         grepl <- base::grepl
[16:17:42.949]                         restarts <- computeRestarts(cond)
[16:17:42.949]                         for (restart in restarts) {
[16:17:42.949]                           name <- restart$name
[16:17:42.949]                           if (is.null(name)) 
[16:17:42.949]                             next
[16:17:42.949]                           if (!grepl(pattern, name)) 
[16:17:42.949]                             next
[16:17:42.949]                           invokeRestart(restart)
[16:17:42.949]                           muffled <- TRUE
[16:17:42.949]                           break
[16:17:42.949]                         }
[16:17:42.949]                       }
[16:17:42.949]                     }
[16:17:42.949]                     invisible(muffled)
[16:17:42.949]                   }
[16:17:42.949]                   muffleCondition(cond)
[16:17:42.949]                 })
[16:17:42.949]             }))
[16:17:42.949]             future::FutureResult(value = ...future.value$value, 
[16:17:42.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.949]                   ...future.rng), globalenv = if (FALSE) 
[16:17:42.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:42.949]                     ...future.globalenv.names))
[16:17:42.949]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:42.949]         }, condition = base::local({
[16:17:42.949]             c <- base::c
[16:17:42.949]             inherits <- base::inherits
[16:17:42.949]             invokeRestart <- base::invokeRestart
[16:17:42.949]             length <- base::length
[16:17:42.949]             list <- base::list
[16:17:42.949]             seq.int <- base::seq.int
[16:17:42.949]             signalCondition <- base::signalCondition
[16:17:42.949]             sys.calls <- base::sys.calls
[16:17:42.949]             `[[` <- base::`[[`
[16:17:42.949]             `+` <- base::`+`
[16:17:42.949]             `<<-` <- base::`<<-`
[16:17:42.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:42.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:42.949]                   3L)]
[16:17:42.949]             }
[16:17:42.949]             function(cond) {
[16:17:42.949]                 is_error <- inherits(cond, "error")
[16:17:42.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:42.949]                   NULL)
[16:17:42.949]                 if (is_error) {
[16:17:42.949]                   sessionInformation <- function() {
[16:17:42.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:42.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:42.949]                       search = base::search(), system = base::Sys.info())
[16:17:42.949]                   }
[16:17:42.949]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:42.949]                     cond$call), session = sessionInformation(), 
[16:17:42.949]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:42.949]                   signalCondition(cond)
[16:17:42.949]                 }
[16:17:42.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:42.949]                 "immediateCondition"))) {
[16:17:42.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:42.949]                   ...future.conditions[[length(...future.conditions) + 
[16:17:42.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:42.949]                   if (TRUE && !signal) {
[16:17:42.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.949]                     {
[16:17:42.949]                       inherits <- base::inherits
[16:17:42.949]                       invokeRestart <- base::invokeRestart
[16:17:42.949]                       is.null <- base::is.null
[16:17:42.949]                       muffled <- FALSE
[16:17:42.949]                       if (inherits(cond, "message")) {
[16:17:42.949]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.949]                         if (muffled) 
[16:17:42.949]                           invokeRestart("muffleMessage")
[16:17:42.949]                       }
[16:17:42.949]                       else if (inherits(cond, "warning")) {
[16:17:42.949]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.949]                         if (muffled) 
[16:17:42.949]                           invokeRestart("muffleWarning")
[16:17:42.949]                       }
[16:17:42.949]                       else if (inherits(cond, "condition")) {
[16:17:42.949]                         if (!is.null(pattern)) {
[16:17:42.949]                           computeRestarts <- base::computeRestarts
[16:17:42.949]                           grepl <- base::grepl
[16:17:42.949]                           restarts <- computeRestarts(cond)
[16:17:42.949]                           for (restart in restarts) {
[16:17:42.949]                             name <- restart$name
[16:17:42.949]                             if (is.null(name)) 
[16:17:42.949]                               next
[16:17:42.949]                             if (!grepl(pattern, name)) 
[16:17:42.949]                               next
[16:17:42.949]                             invokeRestart(restart)
[16:17:42.949]                             muffled <- TRUE
[16:17:42.949]                             break
[16:17:42.949]                           }
[16:17:42.949]                         }
[16:17:42.949]                       }
[16:17:42.949]                       invisible(muffled)
[16:17:42.949]                     }
[16:17:42.949]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.949]                   }
[16:17:42.949]                 }
[16:17:42.949]                 else {
[16:17:42.949]                   if (TRUE) {
[16:17:42.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:42.949]                     {
[16:17:42.949]                       inherits <- base::inherits
[16:17:42.949]                       invokeRestart <- base::invokeRestart
[16:17:42.949]                       is.null <- base::is.null
[16:17:42.949]                       muffled <- FALSE
[16:17:42.949]                       if (inherits(cond, "message")) {
[16:17:42.949]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:42.949]                         if (muffled) 
[16:17:42.949]                           invokeRestart("muffleMessage")
[16:17:42.949]                       }
[16:17:42.949]                       else if (inherits(cond, "warning")) {
[16:17:42.949]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:42.949]                         if (muffled) 
[16:17:42.949]                           invokeRestart("muffleWarning")
[16:17:42.949]                       }
[16:17:42.949]                       else if (inherits(cond, "condition")) {
[16:17:42.949]                         if (!is.null(pattern)) {
[16:17:42.949]                           computeRestarts <- base::computeRestarts
[16:17:42.949]                           grepl <- base::grepl
[16:17:42.949]                           restarts <- computeRestarts(cond)
[16:17:42.949]                           for (restart in restarts) {
[16:17:42.949]                             name <- restart$name
[16:17:42.949]                             if (is.null(name)) 
[16:17:42.949]                               next
[16:17:42.949]                             if (!grepl(pattern, name)) 
[16:17:42.949]                               next
[16:17:42.949]                             invokeRestart(restart)
[16:17:42.949]                             muffled <- TRUE
[16:17:42.949]                             break
[16:17:42.949]                           }
[16:17:42.949]                         }
[16:17:42.949]                       }
[16:17:42.949]                       invisible(muffled)
[16:17:42.949]                     }
[16:17:42.949]                     muffleCondition(cond, pattern = "^muffle")
[16:17:42.949]                   }
[16:17:42.949]                 }
[16:17:42.949]             }
[16:17:42.949]         }))
[16:17:42.949]     }, error = function(ex) {
[16:17:42.949]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:42.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:42.949]                 ...future.rng), started = ...future.startTime, 
[16:17:42.949]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:42.949]             version = "1.8"), class = "FutureResult")
[16:17:42.949]     }, finally = {
[16:17:42.949]         if (!identical(...future.workdir, getwd())) 
[16:17:42.949]             setwd(...future.workdir)
[16:17:42.949]         {
[16:17:42.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:42.949]                 ...future.oldOptions$nwarnings <- NULL
[16:17:42.949]             }
[16:17:42.949]             base::options(...future.oldOptions)
[16:17:42.949]             if (.Platform$OS.type == "windows") {
[16:17:42.949]                 old_names <- names(...future.oldEnvVars)
[16:17:42.949]                 envs <- base::Sys.getenv()
[16:17:42.949]                 names <- names(envs)
[16:17:42.949]                 common <- intersect(names, old_names)
[16:17:42.949]                 added <- setdiff(names, old_names)
[16:17:42.949]                 removed <- setdiff(old_names, names)
[16:17:42.949]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:42.949]                   envs[common]]
[16:17:42.949]                 NAMES <- toupper(changed)
[16:17:42.949]                 args <- list()
[16:17:42.949]                 for (kk in seq_along(NAMES)) {
[16:17:42.949]                   name <- changed[[kk]]
[16:17:42.949]                   NAME <- NAMES[[kk]]
[16:17:42.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.949]                     next
[16:17:42.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.949]                 }
[16:17:42.949]                 NAMES <- toupper(added)
[16:17:42.949]                 for (kk in seq_along(NAMES)) {
[16:17:42.949]                   name <- added[[kk]]
[16:17:42.949]                   NAME <- NAMES[[kk]]
[16:17:42.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.949]                     next
[16:17:42.949]                   args[[name]] <- ""
[16:17:42.949]                 }
[16:17:42.949]                 NAMES <- toupper(removed)
[16:17:42.949]                 for (kk in seq_along(NAMES)) {
[16:17:42.949]                   name <- removed[[kk]]
[16:17:42.949]                   NAME <- NAMES[[kk]]
[16:17:42.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:42.949]                     next
[16:17:42.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:42.949]                 }
[16:17:42.949]                 if (length(args) > 0) 
[16:17:42.949]                   base::do.call(base::Sys.setenv, args = args)
[16:17:42.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:42.949]             }
[16:17:42.949]             else {
[16:17:42.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:42.949]             }
[16:17:42.949]             {
[16:17:42.949]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:42.949]                   0L) {
[16:17:42.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:42.949]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:42.949]                   base::options(opts)
[16:17:42.949]                 }
[16:17:42.949]                 {
[16:17:42.949]                   {
[16:17:42.949]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:42.949]                     NULL
[16:17:42.949]                   }
[16:17:42.949]                   options(future.plan = NULL)
[16:17:42.949]                   if (is.na(NA_character_)) 
[16:17:42.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:42.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:42.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:42.949]                     .init = FALSE)
[16:17:42.949]                 }
[16:17:42.949]             }
[16:17:42.949]         }
[16:17:42.949]     })
[16:17:42.949]     if (TRUE) {
[16:17:42.949]         base::sink(type = "output", split = FALSE)
[16:17:42.949]         if (TRUE) {
[16:17:42.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:42.949]         }
[16:17:42.949]         else {
[16:17:42.949]             ...future.result["stdout"] <- base::list(NULL)
[16:17:42.949]         }
[16:17:42.949]         base::close(...future.stdout)
[16:17:42.949]         ...future.stdout <- NULL
[16:17:42.949]     }
[16:17:42.949]     ...future.result$conditions <- ...future.conditions
[16:17:42.949]     ...future.result$finished <- base::Sys.time()
[16:17:42.949]     ...future.result
[16:17:42.949] }
[16:17:42.952] assign_globals() ...
[16:17:42.952] List of 5
[16:17:42.952]  $ future.call.arguments    : list()
[16:17:42.952]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:42.952]  $ ...future.FUN            :function (x)  
[16:17:42.952]  $ ...future.elements_ii    :List of 1
[16:17:42.952]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[16:17:42.952]  $ ...future.seeds_ii       : NULL
[16:17:42.952]  $ ...future.globals.maxSize: num Inf
[16:17:42.952]  - attr(*, "resolved")= logi FALSE
[16:17:42.952]  - attr(*, "total_size")= num NA
[16:17:42.952]  - attr(*, "where")=List of 5
[16:17:42.952]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:42.952]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:42.952]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:42.952]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:42.952]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:42.952]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:42.952]  - attr(*, "already-done")= logi TRUE
[16:17:42.961] - copied ‘future.call.arguments’ to environment
[16:17:42.961] - copied ‘...future.FUN’ to environment
[16:17:42.961] - copied ‘...future.elements_ii’ to environment
[16:17:42.961] - copied ‘...future.seeds_ii’ to environment
[16:17:42.961] - copied ‘...future.globals.maxSize’ to environment
[16:17:42.961] assign_globals() ... done
[16:17:42.961] requestCore(): workers = 2
[16:17:42.964] MulticoreFuture started
[16:17:42.964] - Launch lazy future ... done
[16:17:42.964] run() for ‘MulticoreFuture’ ... done
[16:17:42.965] Created future:
[16:17:42.965] plan(): Setting new future strategy stack:
[16:17:42.965] List of future strategies:
[16:17:42.965] 1. sequential:
[16:17:42.965]    - args: function (..., envir = parent.frame())
[16:17:42.965]    - tweaked: FALSE
[16:17:42.965]    - call: NULL
[16:17:42.966] plan(): nbrOfWorkers() = 1
[16:17:42.968] plan(): Setting new future strategy stack:
[16:17:42.968] List of future strategies:
[16:17:42.968] 1. multicore:
[16:17:42.968]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:42.968]    - tweaked: FALSE
[16:17:42.968]    - call: plan(strategy)
[16:17:42.974] plan(): nbrOfWorkers() = 2
[16:17:42.965] MulticoreFuture:
[16:17:42.965] Label: ‘future_apply-2’
[16:17:42.965] Expression:
[16:17:42.965] {
[16:17:42.965]     do.call(function(...) {
[16:17:42.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:42.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:42.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:42.965]             on.exit(options(oopts), add = TRUE)
[16:17:42.965]         }
[16:17:42.965]         {
[16:17:42.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:42.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:42.965]                 ...future.FUN(...future.X_jj, ...)
[16:17:42.965]             })
[16:17:42.965]         }
[16:17:42.965]     }, args = future.call.arguments)
[16:17:42.965] }
[16:17:42.965] Lazy evaluation: FALSE
[16:17:42.965] Asynchronous evaluation: TRUE
[16:17:42.965] Local evaluation: TRUE
[16:17:42.965] Environment: R_GlobalEnv
[16:17:42.965] Capture standard output: TRUE
[16:17:42.965] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:42.965] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:42.965] Packages: <none>
[16:17:42.965] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:42.965] Resolved: TRUE
[16:17:42.965] Value: <not collected>
[16:17:42.965] Conditions captured: <none>
[16:17:42.965] Early signaling: FALSE
[16:17:42.965] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:42.965] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:42.975] Chunk #2 of 2 ... DONE
[16:17:42.975] Launching 2 futures (chunks) ... DONE
[16:17:42.975] Resolving 2 futures (chunks) ...
[16:17:42.976] resolve() on list ...
[16:17:42.976]  recursive: 0
[16:17:42.976]  length: 2
[16:17:42.976] 
[16:17:42.976] Future #1
[16:17:42.977] result() for MulticoreFuture ...
[16:17:42.978] result() for MulticoreFuture ...
[16:17:42.978] result() for MulticoreFuture ... done
[16:17:42.978] result() for MulticoreFuture ... done
[16:17:42.978] result() for MulticoreFuture ...
[16:17:42.978] result() for MulticoreFuture ... done
[16:17:42.979] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:42.979] - nx: 2
[16:17:42.979] - relay: TRUE
[16:17:42.979] - stdout: TRUE
[16:17:42.979] - signal: TRUE
[16:17:42.980] - resignal: FALSE
[16:17:42.980] - force: TRUE
[16:17:42.980] - relayed: [n=2] FALSE, FALSE
[16:17:42.980] - queued futures: [n=2] FALSE, FALSE
[16:17:42.980]  - until=1
[16:17:42.981]  - relaying element #1
[16:17:42.981] result() for MulticoreFuture ...
[16:17:42.981] result() for MulticoreFuture ... done
[16:17:42.981] result() for MulticoreFuture ...
[16:17:42.981] result() for MulticoreFuture ... done
[16:17:42.982] result() for MulticoreFuture ...
[16:17:42.982] result() for MulticoreFuture ... done
[16:17:42.982] result() for MulticoreFuture ...
[16:17:42.982] result() for MulticoreFuture ... done
[16:17:42.982] - relayed: [n=2] TRUE, FALSE
[16:17:42.982] - queued futures: [n=2] TRUE, FALSE
[16:17:42.983] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:42.983]  length: 1 (resolved future 1)
[16:17:42.983] Future #2
[16:17:42.983] result() for MulticoreFuture ...
[16:17:42.984] result() for MulticoreFuture ...
[16:17:42.984] result() for MulticoreFuture ... done
[16:17:42.985] result() for MulticoreFuture ... done
[16:17:42.985] result() for MulticoreFuture ...
[16:17:42.985] result() for MulticoreFuture ... done
[16:17:42.985] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:42.985] - nx: 2
[16:17:42.986] - relay: TRUE
[16:17:42.986] - stdout: TRUE
[16:17:42.986] - signal: TRUE
[16:17:42.986] - resignal: FALSE
[16:17:42.986] - force: TRUE
[16:17:42.986] - relayed: [n=2] TRUE, FALSE
[16:17:42.986] - queued futures: [n=2] TRUE, FALSE
[16:17:42.987]  - until=2
[16:17:42.987]  - relaying element #2
[16:17:42.987] result() for MulticoreFuture ...
[16:17:42.987] result() for MulticoreFuture ... done
[16:17:42.987] result() for MulticoreFuture ...
[16:17:42.987] result() for MulticoreFuture ... done
[16:17:42.987] result() for MulticoreFuture ...
[16:17:42.988] result() for MulticoreFuture ... done
[16:17:42.988] result() for MulticoreFuture ...
[16:17:42.988] result() for MulticoreFuture ... done
[16:17:42.988] - relayed: [n=2] TRUE, TRUE
[16:17:42.988] - queued futures: [n=2] TRUE, TRUE
[16:17:42.988] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:42.988]  length: 0 (resolved future 2)
[16:17:42.988] Relaying remaining futures
[16:17:42.989] signalConditionsASAP(NULL, pos=0) ...
[16:17:42.989] - nx: 2
[16:17:42.989] - relay: TRUE
[16:17:42.989] - stdout: TRUE
[16:17:42.989] - signal: TRUE
[16:17:42.989] - resignal: FALSE
[16:17:42.989] - force: TRUE
[16:17:42.989] - relayed: [n=2] TRUE, TRUE
[16:17:42.989] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:42.990] - relayed: [n=2] TRUE, TRUE
[16:17:42.990] - queued futures: [n=2] TRUE, TRUE
[16:17:42.990] signalConditionsASAP(NULL, pos=0) ... done
[16:17:42.990] resolve() on list ... DONE
[16:17:42.990] result() for MulticoreFuture ...
[16:17:42.990] result() for MulticoreFuture ... done
[16:17:42.990] result() for MulticoreFuture ...
[16:17:42.990] result() for MulticoreFuture ... done
[16:17:42.990] result() for MulticoreFuture ...
[16:17:42.991] result() for MulticoreFuture ... done
[16:17:42.993] result() for MulticoreFuture ...
[16:17:42.993] result() for MulticoreFuture ... done
[16:17:42.993]  - Number of value chunks collected: 2
[16:17:42.994] Resolving 2 futures (chunks) ... DONE
[16:17:42.994] Reducing values from 2 chunks ...
[16:17:42.994]  - Number of values collected after concatenation: 2
[16:17:42.994]  - Number of values expected: 2
[16:17:42.994] Reducing values from 2 chunks ... DONE
[16:17:42.994] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:17:42.995] getGlobalsAndPackagesXApply() ...
[16:17:42.995]  - future.globals: TRUE
[16:17:42.995] getGlobalsAndPackages() ...
[16:17:42.995] Searching for globals...
[16:17:42.999] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:17:42.999] Searching for globals ... DONE
[16:17:42.999] Resolving globals: FALSE
[16:17:43.000] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:17:43.000] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:17:43.001] - globals: [1] ‘FUN’
[16:17:43.001] 
[16:17:43.001] getGlobalsAndPackages() ... DONE
[16:17:43.001]  - globals found/used: [n=1] ‘FUN’
[16:17:43.001]  - needed namespaces: [n=0] 
[16:17:43.001] Finding globals ... DONE
[16:17:43.001]  - use_args: TRUE
[16:17:43.002]  - Getting '...' globals ...
[16:17:43.002] resolve() on list ...
[16:17:43.002]  recursive: 0
[16:17:43.002]  length: 1
[16:17:43.002]  elements: ‘...’
[16:17:43.002]  length: 0 (resolved future 1)
[16:17:43.002] resolve() on list ... DONE
[16:17:43.003]    - '...' content: [n=0] 
[16:17:43.003] List of 1
[16:17:43.003]  $ ...: list()
[16:17:43.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.003]  - attr(*, "where")=List of 1
[16:17:43.003]   ..$ ...:<environment: 0x555be08ed6e0> 
[16:17:43.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.003]  - attr(*, "resolved")= logi TRUE
[16:17:43.003]  - attr(*, "total_size")= num NA
[16:17:43.005]  - Getting '...' globals ... DONE
[16:17:43.006] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:43.006] List of 2
[16:17:43.006]  $ ...future.FUN:function (x)  
[16:17:43.006]  $ ...          : list()
[16:17:43.006]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.006]  - attr(*, "where")=List of 2
[16:17:43.006]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:43.006]   ..$ ...          :<environment: 0x555be08ed6e0> 
[16:17:43.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.006]  - attr(*, "resolved")= logi FALSE
[16:17:43.006]  - attr(*, "total_size")= num 9888
[16:17:43.008] Packages to be attached in all futures: [n=0] 
[16:17:43.008] getGlobalsAndPackagesXApply() ... DONE
[16:17:43.012] future_lapply() ...
[16:17:43.017] Number of chunks: 2
[16:17:43.017] getGlobalsAndPackagesXApply() ...
[16:17:43.017]  - future.globals: <name-value list> with names ‘list()’
[16:17:43.017]  - use_args: TRUE
[16:17:43.017] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:43.017] List of 2
[16:17:43.017]  $ ...          : list()
[16:17:43.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.017]  $ ...future.FUN:function (x)  
[16:17:43.017]  - attr(*, "where")=List of 2
[16:17:43.017]   ..$ ...          :<environment: 0x555be08ed6e0> 
[16:17:43.017]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:17:43.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.017]  - attr(*, "resolved")= logi FALSE
[16:17:43.017]  - attr(*, "total_size")= num NA
[16:17:43.021] Packages to be attached in all futures: [n=0] 
[16:17:43.022] getGlobalsAndPackagesXApply() ... DONE
[16:17:43.022] Number of futures (= number of chunks): 2
[16:17:43.022] Launching 2 futures (chunks) ...
[16:17:43.022] Chunk #1 of 2 ...
[16:17:43.022]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:43.022]  - seeds: <none>
[16:17:43.022]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.022] getGlobalsAndPackages() ...
[16:17:43.023] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.023] Resolving globals: FALSE
[16:17:43.023] Tweak future expression to call with '...' arguments ...
[16:17:43.023] {
[16:17:43.023]     do.call(function(...) {
[16:17:43.023]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.023]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:43.023]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.023]             on.exit(options(oopts), add = TRUE)
[16:17:43.023]         }
[16:17:43.023]         {
[16:17:43.023]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:43.023]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.023]                 ...future.FUN(...future.X_jj, ...)
[16:17:43.023]             })
[16:17:43.023]         }
[16:17:43.023]     }, args = future.call.arguments)
[16:17:43.023] }
[16:17:43.023] Tweak future expression to call with '...' arguments ... DONE
[16:17:43.023] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.024] 
[16:17:43.024] getGlobalsAndPackages() ... DONE
[16:17:43.024] run() for ‘Future’ ...
[16:17:43.024] - state: ‘created’
[16:17:43.024] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:43.028] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:43.028] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:43.028]   - Field: ‘label’
[16:17:43.028]   - Field: ‘local’
[16:17:43.028]   - Field: ‘owner’
[16:17:43.028]   - Field: ‘envir’
[16:17:43.028]   - Field: ‘workers’
[16:17:43.028]   - Field: ‘packages’
[16:17:43.028]   - Field: ‘gc’
[16:17:43.029]   - Field: ‘job’
[16:17:43.029]   - Field: ‘conditions’
[16:17:43.029]   - Field: ‘expr’
[16:17:43.029]   - Field: ‘uuid’
[16:17:43.029]   - Field: ‘seed’
[16:17:43.029]   - Field: ‘version’
[16:17:43.029]   - Field: ‘result’
[16:17:43.029]   - Field: ‘asynchronous’
[16:17:43.029]   - Field: ‘calls’
[16:17:43.029]   - Field: ‘globals’
[16:17:43.029]   - Field: ‘stdout’
[16:17:43.030]   - Field: ‘earlySignal’
[16:17:43.030]   - Field: ‘lazy’
[16:17:43.030]   - Field: ‘state’
[16:17:43.030] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:43.030] - Launch lazy future ...
[16:17:43.030] Packages needed by the future expression (n = 0): <none>
[16:17:43.030] Packages needed by future strategies (n = 0): <none>
[16:17:43.031] {
[16:17:43.031]     {
[16:17:43.031]         {
[16:17:43.031]             ...future.startTime <- base::Sys.time()
[16:17:43.031]             {
[16:17:43.031]                 {
[16:17:43.031]                   {
[16:17:43.031]                     {
[16:17:43.031]                       base::local({
[16:17:43.031]                         has_future <- base::requireNamespace("future", 
[16:17:43.031]                           quietly = TRUE)
[16:17:43.031]                         if (has_future) {
[16:17:43.031]                           ns <- base::getNamespace("future")
[16:17:43.031]                           version <- ns[[".package"]][["version"]]
[16:17:43.031]                           if (is.null(version)) 
[16:17:43.031]                             version <- utils::packageVersion("future")
[16:17:43.031]                         }
[16:17:43.031]                         else {
[16:17:43.031]                           version <- NULL
[16:17:43.031]                         }
[16:17:43.031]                         if (!has_future || version < "1.8.0") {
[16:17:43.031]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:43.031]                             "", base::R.version$version.string), 
[16:17:43.031]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:43.031]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:43.031]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:43.031]                               "release", "version")], collapse = " "), 
[16:17:43.031]                             hostname = base::Sys.info()[["nodename"]])
[16:17:43.031]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:43.031]                             info)
[16:17:43.031]                           info <- base::paste(info, collapse = "; ")
[16:17:43.031]                           if (!has_future) {
[16:17:43.031]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:43.031]                               info)
[16:17:43.031]                           }
[16:17:43.031]                           else {
[16:17:43.031]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:43.031]                               info, version)
[16:17:43.031]                           }
[16:17:43.031]                           base::stop(msg)
[16:17:43.031]                         }
[16:17:43.031]                       })
[16:17:43.031]                     }
[16:17:43.031]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:43.031]                     base::options(mc.cores = 1L)
[16:17:43.031]                   }
[16:17:43.031]                   ...future.strategy.old <- future::plan("list")
[16:17:43.031]                   options(future.plan = NULL)
[16:17:43.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:43.031]                 }
[16:17:43.031]                 ...future.workdir <- getwd()
[16:17:43.031]             }
[16:17:43.031]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:43.031]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:43.031]         }
[16:17:43.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:43.031]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:43.031]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:43.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:43.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:43.031]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:43.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:43.031]             base::names(...future.oldOptions))
[16:17:43.031]     }
[16:17:43.031]     if (FALSE) {
[16:17:43.031]     }
[16:17:43.031]     else {
[16:17:43.031]         if (TRUE) {
[16:17:43.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:43.031]                 open = "w")
[16:17:43.031]         }
[16:17:43.031]         else {
[16:17:43.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:43.031]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:43.031]         }
[16:17:43.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:43.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:43.031]             base::sink(type = "output", split = FALSE)
[16:17:43.031]             base::close(...future.stdout)
[16:17:43.031]         }, add = TRUE)
[16:17:43.031]     }
[16:17:43.031]     ...future.frame <- base::sys.nframe()
[16:17:43.031]     ...future.conditions <- base::list()
[16:17:43.031]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:43.031]     if (FALSE) {
[16:17:43.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:43.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:43.031]     }
[16:17:43.031]     ...future.result <- base::tryCatch({
[16:17:43.031]         base::withCallingHandlers({
[16:17:43.031]             ...future.value <- base::withVisible(base::local({
[16:17:43.031]                 withCallingHandlers({
[16:17:43.031]                   {
[16:17:43.031]                     do.call(function(...) {
[16:17:43.031]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.031]                       if (!identical(...future.globals.maxSize.org, 
[16:17:43.031]                         ...future.globals.maxSize)) {
[16:17:43.031]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.031]                         on.exit(options(oopts), add = TRUE)
[16:17:43.031]                       }
[16:17:43.031]                       {
[16:17:43.031]                         lapply(seq_along(...future.elements_ii), 
[16:17:43.031]                           FUN = function(jj) {
[16:17:43.031]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.031]                             ...future.FUN(...future.X_jj, ...)
[16:17:43.031]                           })
[16:17:43.031]                       }
[16:17:43.031]                     }, args = future.call.arguments)
[16:17:43.031]                   }
[16:17:43.031]                 }, immediateCondition = function(cond) {
[16:17:43.031]                   save_rds <- function (object, pathname, ...) 
[16:17:43.031]                   {
[16:17:43.031]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:43.031]                     if (file_test("-f", pathname_tmp)) {
[16:17:43.031]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.031]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:43.031]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.031]                         fi_tmp[["mtime"]])
[16:17:43.031]                     }
[16:17:43.031]                     tryCatch({
[16:17:43.031]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:43.031]                     }, error = function(ex) {
[16:17:43.031]                       msg <- conditionMessage(ex)
[16:17:43.031]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.031]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:43.031]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.031]                         fi_tmp[["mtime"]], msg)
[16:17:43.031]                       ex$message <- msg
[16:17:43.031]                       stop(ex)
[16:17:43.031]                     })
[16:17:43.031]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:43.031]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:43.031]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:43.031]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.031]                       fi <- file.info(pathname)
[16:17:43.031]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:43.031]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.031]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:43.031]                         fi[["size"]], fi[["mtime"]])
[16:17:43.031]                       stop(msg)
[16:17:43.031]                     }
[16:17:43.031]                     invisible(pathname)
[16:17:43.031]                   }
[16:17:43.031]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:43.031]                     rootPath = tempdir()) 
[16:17:43.031]                   {
[16:17:43.031]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:43.031]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:43.031]                       tmpdir = path, fileext = ".rds")
[16:17:43.031]                     save_rds(obj, file)
[16:17:43.031]                   }
[16:17:43.031]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:43.031]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.031]                   {
[16:17:43.031]                     inherits <- base::inherits
[16:17:43.031]                     invokeRestart <- base::invokeRestart
[16:17:43.031]                     is.null <- base::is.null
[16:17:43.031]                     muffled <- FALSE
[16:17:43.031]                     if (inherits(cond, "message")) {
[16:17:43.031]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:43.031]                       if (muffled) 
[16:17:43.031]                         invokeRestart("muffleMessage")
[16:17:43.031]                     }
[16:17:43.031]                     else if (inherits(cond, "warning")) {
[16:17:43.031]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:43.031]                       if (muffled) 
[16:17:43.031]                         invokeRestart("muffleWarning")
[16:17:43.031]                     }
[16:17:43.031]                     else if (inherits(cond, "condition")) {
[16:17:43.031]                       if (!is.null(pattern)) {
[16:17:43.031]                         computeRestarts <- base::computeRestarts
[16:17:43.031]                         grepl <- base::grepl
[16:17:43.031]                         restarts <- computeRestarts(cond)
[16:17:43.031]                         for (restart in restarts) {
[16:17:43.031]                           name <- restart$name
[16:17:43.031]                           if (is.null(name)) 
[16:17:43.031]                             next
[16:17:43.031]                           if (!grepl(pattern, name)) 
[16:17:43.031]                             next
[16:17:43.031]                           invokeRestart(restart)
[16:17:43.031]                           muffled <- TRUE
[16:17:43.031]                           break
[16:17:43.031]                         }
[16:17:43.031]                       }
[16:17:43.031]                     }
[16:17:43.031]                     invisible(muffled)
[16:17:43.031]                   }
[16:17:43.031]                   muffleCondition(cond)
[16:17:43.031]                 })
[16:17:43.031]             }))
[16:17:43.031]             future::FutureResult(value = ...future.value$value, 
[16:17:43.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.031]                   ...future.rng), globalenv = if (FALSE) 
[16:17:43.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:43.031]                     ...future.globalenv.names))
[16:17:43.031]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:43.031]         }, condition = base::local({
[16:17:43.031]             c <- base::c
[16:17:43.031]             inherits <- base::inherits
[16:17:43.031]             invokeRestart <- base::invokeRestart
[16:17:43.031]             length <- base::length
[16:17:43.031]             list <- base::list
[16:17:43.031]             seq.int <- base::seq.int
[16:17:43.031]             signalCondition <- base::signalCondition
[16:17:43.031]             sys.calls <- base::sys.calls
[16:17:43.031]             `[[` <- base::`[[`
[16:17:43.031]             `+` <- base::`+`
[16:17:43.031]             `<<-` <- base::`<<-`
[16:17:43.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:43.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:43.031]                   3L)]
[16:17:43.031]             }
[16:17:43.031]             function(cond) {
[16:17:43.031]                 is_error <- inherits(cond, "error")
[16:17:43.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:43.031]                   NULL)
[16:17:43.031]                 if (is_error) {
[16:17:43.031]                   sessionInformation <- function() {
[16:17:43.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:43.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:43.031]                       search = base::search(), system = base::Sys.info())
[16:17:43.031]                   }
[16:17:43.031]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:43.031]                     cond$call), session = sessionInformation(), 
[16:17:43.031]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:43.031]                   signalCondition(cond)
[16:17:43.031]                 }
[16:17:43.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:43.031]                 "immediateCondition"))) {
[16:17:43.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:43.031]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:43.031]                   if (TRUE && !signal) {
[16:17:43.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.031]                     {
[16:17:43.031]                       inherits <- base::inherits
[16:17:43.031]                       invokeRestart <- base::invokeRestart
[16:17:43.031]                       is.null <- base::is.null
[16:17:43.031]                       muffled <- FALSE
[16:17:43.031]                       if (inherits(cond, "message")) {
[16:17:43.031]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.031]                         if (muffled) 
[16:17:43.031]                           invokeRestart("muffleMessage")
[16:17:43.031]                       }
[16:17:43.031]                       else if (inherits(cond, "warning")) {
[16:17:43.031]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.031]                         if (muffled) 
[16:17:43.031]                           invokeRestart("muffleWarning")
[16:17:43.031]                       }
[16:17:43.031]                       else if (inherits(cond, "condition")) {
[16:17:43.031]                         if (!is.null(pattern)) {
[16:17:43.031]                           computeRestarts <- base::computeRestarts
[16:17:43.031]                           grepl <- base::grepl
[16:17:43.031]                           restarts <- computeRestarts(cond)
[16:17:43.031]                           for (restart in restarts) {
[16:17:43.031]                             name <- restart$name
[16:17:43.031]                             if (is.null(name)) 
[16:17:43.031]                               next
[16:17:43.031]                             if (!grepl(pattern, name)) 
[16:17:43.031]                               next
[16:17:43.031]                             invokeRestart(restart)
[16:17:43.031]                             muffled <- TRUE
[16:17:43.031]                             break
[16:17:43.031]                           }
[16:17:43.031]                         }
[16:17:43.031]                       }
[16:17:43.031]                       invisible(muffled)
[16:17:43.031]                     }
[16:17:43.031]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.031]                   }
[16:17:43.031]                 }
[16:17:43.031]                 else {
[16:17:43.031]                   if (TRUE) {
[16:17:43.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.031]                     {
[16:17:43.031]                       inherits <- base::inherits
[16:17:43.031]                       invokeRestart <- base::invokeRestart
[16:17:43.031]                       is.null <- base::is.null
[16:17:43.031]                       muffled <- FALSE
[16:17:43.031]                       if (inherits(cond, "message")) {
[16:17:43.031]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.031]                         if (muffled) 
[16:17:43.031]                           invokeRestart("muffleMessage")
[16:17:43.031]                       }
[16:17:43.031]                       else if (inherits(cond, "warning")) {
[16:17:43.031]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.031]                         if (muffled) 
[16:17:43.031]                           invokeRestart("muffleWarning")
[16:17:43.031]                       }
[16:17:43.031]                       else if (inherits(cond, "condition")) {
[16:17:43.031]                         if (!is.null(pattern)) {
[16:17:43.031]                           computeRestarts <- base::computeRestarts
[16:17:43.031]                           grepl <- base::grepl
[16:17:43.031]                           restarts <- computeRestarts(cond)
[16:17:43.031]                           for (restart in restarts) {
[16:17:43.031]                             name <- restart$name
[16:17:43.031]                             if (is.null(name)) 
[16:17:43.031]                               next
[16:17:43.031]                             if (!grepl(pattern, name)) 
[16:17:43.031]                               next
[16:17:43.031]                             invokeRestart(restart)
[16:17:43.031]                             muffled <- TRUE
[16:17:43.031]                             break
[16:17:43.031]                           }
[16:17:43.031]                         }
[16:17:43.031]                       }
[16:17:43.031]                       invisible(muffled)
[16:17:43.031]                     }
[16:17:43.031]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.031]                   }
[16:17:43.031]                 }
[16:17:43.031]             }
[16:17:43.031]         }))
[16:17:43.031]     }, error = function(ex) {
[16:17:43.031]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:43.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.031]                 ...future.rng), started = ...future.startTime, 
[16:17:43.031]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:43.031]             version = "1.8"), class = "FutureResult")
[16:17:43.031]     }, finally = {
[16:17:43.031]         if (!identical(...future.workdir, getwd())) 
[16:17:43.031]             setwd(...future.workdir)
[16:17:43.031]         {
[16:17:43.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:43.031]                 ...future.oldOptions$nwarnings <- NULL
[16:17:43.031]             }
[16:17:43.031]             base::options(...future.oldOptions)
[16:17:43.031]             if (.Platform$OS.type == "windows") {
[16:17:43.031]                 old_names <- names(...future.oldEnvVars)
[16:17:43.031]                 envs <- base::Sys.getenv()
[16:17:43.031]                 names <- names(envs)
[16:17:43.031]                 common <- intersect(names, old_names)
[16:17:43.031]                 added <- setdiff(names, old_names)
[16:17:43.031]                 removed <- setdiff(old_names, names)
[16:17:43.031]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:43.031]                   envs[common]]
[16:17:43.031]                 NAMES <- toupper(changed)
[16:17:43.031]                 args <- list()
[16:17:43.031]                 for (kk in seq_along(NAMES)) {
[16:17:43.031]                   name <- changed[[kk]]
[16:17:43.031]                   NAME <- NAMES[[kk]]
[16:17:43.031]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.031]                     next
[16:17:43.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.031]                 }
[16:17:43.031]                 NAMES <- toupper(added)
[16:17:43.031]                 for (kk in seq_along(NAMES)) {
[16:17:43.031]                   name <- added[[kk]]
[16:17:43.031]                   NAME <- NAMES[[kk]]
[16:17:43.031]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.031]                     next
[16:17:43.031]                   args[[name]] <- ""
[16:17:43.031]                 }
[16:17:43.031]                 NAMES <- toupper(removed)
[16:17:43.031]                 for (kk in seq_along(NAMES)) {
[16:17:43.031]                   name <- removed[[kk]]
[16:17:43.031]                   NAME <- NAMES[[kk]]
[16:17:43.031]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.031]                     next
[16:17:43.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.031]                 }
[16:17:43.031]                 if (length(args) > 0) 
[16:17:43.031]                   base::do.call(base::Sys.setenv, args = args)
[16:17:43.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:43.031]             }
[16:17:43.031]             else {
[16:17:43.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:43.031]             }
[16:17:43.031]             {
[16:17:43.031]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:43.031]                   0L) {
[16:17:43.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:43.031]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:43.031]                   base::options(opts)
[16:17:43.031]                 }
[16:17:43.031]                 {
[16:17:43.031]                   {
[16:17:43.031]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:43.031]                     NULL
[16:17:43.031]                   }
[16:17:43.031]                   options(future.plan = NULL)
[16:17:43.031]                   if (is.na(NA_character_)) 
[16:17:43.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:43.031]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:43.031]                     .init = FALSE)
[16:17:43.031]                 }
[16:17:43.031]             }
[16:17:43.031]         }
[16:17:43.031]     })
[16:17:43.031]     if (TRUE) {
[16:17:43.031]         base::sink(type = "output", split = FALSE)
[16:17:43.031]         if (TRUE) {
[16:17:43.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:43.031]         }
[16:17:43.031]         else {
[16:17:43.031]             ...future.result["stdout"] <- base::list(NULL)
[16:17:43.031]         }
[16:17:43.031]         base::close(...future.stdout)
[16:17:43.031]         ...future.stdout <- NULL
[16:17:43.031]     }
[16:17:43.031]     ...future.result$conditions <- ...future.conditions
[16:17:43.031]     ...future.result$finished <- base::Sys.time()
[16:17:43.031]     ...future.result
[16:17:43.031] }
[16:17:43.033] assign_globals() ...
[16:17:43.033] List of 5
[16:17:43.033]  $ future.call.arguments    : list()
[16:17:43.033]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.033]  $ ...future.FUN            :function (x)  
[16:17:43.033]  $ ...future.elements_ii    :List of 1
[16:17:43.033]   ..$ : int [1:2] 1 3
[16:17:43.033]  $ ...future.seeds_ii       : NULL
[16:17:43.033]  $ ...future.globals.maxSize: num Inf
[16:17:43.033]  - attr(*, "resolved")= logi FALSE
[16:17:43.033]  - attr(*, "total_size")= num NA
[16:17:43.033]  - attr(*, "where")=List of 5
[16:17:43.033]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:43.033]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:43.033]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:43.033]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:43.033]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:43.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.033]  - attr(*, "already-done")= logi TRUE
[16:17:43.038] - copied ‘future.call.arguments’ to environment
[16:17:43.038] - reassign environment for ‘...future.FUN’
[16:17:43.038] - copied ‘...future.FUN’ to environment
[16:17:43.038] - copied ‘...future.elements_ii’ to environment
[16:17:43.038] - copied ‘...future.seeds_ii’ to environment
[16:17:43.038] - copied ‘...future.globals.maxSize’ to environment
[16:17:43.038] assign_globals() ... done
[16:17:43.038] requestCore(): workers = 2
[16:17:43.040] MulticoreFuture started
[16:17:43.041] - Launch lazy future ... done
[16:17:43.041] run() for ‘MulticoreFuture’ ... done
[16:17:43.041] Created future:
[16:17:43.042] plan(): Setting new future strategy stack:
[16:17:43.042] List of future strategies:
[16:17:43.042] 1. sequential:
[16:17:43.042]    - args: function (..., envir = parent.frame())
[16:17:43.042]    - tweaked: FALSE
[16:17:43.042]    - call: NULL
[16:17:43.043] plan(): nbrOfWorkers() = 1
[16:17:43.044] plan(): Setting new future strategy stack:
[16:17:43.045] List of future strategies:
[16:17:43.045] 1. multicore:
[16:17:43.045]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:43.045]    - tweaked: FALSE
[16:17:43.045]    - call: plan(strategy)
[16:17:43.050] plan(): nbrOfWorkers() = 2
[16:17:43.041] MulticoreFuture:
[16:17:43.041] Label: ‘future_apply-1’
[16:17:43.041] Expression:
[16:17:43.041] {
[16:17:43.041]     do.call(function(...) {
[16:17:43.041]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.041]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:43.041]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.041]             on.exit(options(oopts), add = TRUE)
[16:17:43.041]         }
[16:17:43.041]         {
[16:17:43.041]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:43.041]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.041]                 ...future.FUN(...future.X_jj, ...)
[16:17:43.041]             })
[16:17:43.041]         }
[16:17:43.041]     }, args = future.call.arguments)
[16:17:43.041] }
[16:17:43.041] Lazy evaluation: FALSE
[16:17:43.041] Asynchronous evaluation: TRUE
[16:17:43.041] Local evaluation: TRUE
[16:17:43.041] Environment: R_GlobalEnv
[16:17:43.041] Capture standard output: TRUE
[16:17:43.041] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:43.041] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:43.041] Packages: <none>
[16:17:43.041] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:43.041] Resolved: TRUE
[16:17:43.041] Value: <not collected>
[16:17:43.041] Conditions captured: <none>
[16:17:43.041] Early signaling: FALSE
[16:17:43.041] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:43.041] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:43.051] Chunk #1 of 2 ... DONE
[16:17:43.051] Chunk #2 of 2 ...
[16:17:43.051]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:43.051]  - seeds: <none>
[16:17:43.051]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.052] getGlobalsAndPackages() ...
[16:17:43.052] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.052] Resolving globals: FALSE
[16:17:43.052] Tweak future expression to call with '...' arguments ...
[16:17:43.052] {
[16:17:43.052]     do.call(function(...) {
[16:17:43.052]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.052]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:43.052]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.052]             on.exit(options(oopts), add = TRUE)
[16:17:43.052]         }
[16:17:43.052]         {
[16:17:43.052]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:43.052]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.052]                 ...future.FUN(...future.X_jj, ...)
[16:17:43.052]             })
[16:17:43.052]         }
[16:17:43.052]     }, args = future.call.arguments)
[16:17:43.052] }
[16:17:43.053] Tweak future expression to call with '...' arguments ... DONE
[16:17:43.057] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.057] 
[16:17:43.058] getGlobalsAndPackages() ... DONE
[16:17:43.059] run() for ‘Future’ ...
[16:17:43.059] - state: ‘created’
[16:17:43.060] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:43.066] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:43.066] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:43.067]   - Field: ‘label’
[16:17:43.067]   - Field: ‘local’
[16:17:43.067]   - Field: ‘owner’
[16:17:43.067]   - Field: ‘envir’
[16:17:43.067]   - Field: ‘workers’
[16:17:43.068]   - Field: ‘packages’
[16:17:43.068]   - Field: ‘gc’
[16:17:43.068]   - Field: ‘job’
[16:17:43.068]   - Field: ‘conditions’
[16:17:43.068]   - Field: ‘expr’
[16:17:43.069]   - Field: ‘uuid’
[16:17:43.069]   - Field: ‘seed’
[16:17:43.069]   - Field: ‘version’
[16:17:43.069]   - Field: ‘result’
[16:17:43.069]   - Field: ‘asynchronous’
[16:17:43.069]   - Field: ‘calls’
[16:17:43.069]   - Field: ‘globals’
[16:17:43.070]   - Field: ‘stdout’
[16:17:43.070]   - Field: ‘earlySignal’
[16:17:43.070]   - Field: ‘lazy’
[16:17:43.070]   - Field: ‘state’
[16:17:43.070] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:43.071] - Launch lazy future ...
[16:17:43.071] Packages needed by the future expression (n = 0): <none>
[16:17:43.071] Packages needed by future strategies (n = 0): <none>
[16:17:43.072] {
[16:17:43.072]     {
[16:17:43.072]         {
[16:17:43.072]             ...future.startTime <- base::Sys.time()
[16:17:43.072]             {
[16:17:43.072]                 {
[16:17:43.072]                   {
[16:17:43.072]                     {
[16:17:43.072]                       base::local({
[16:17:43.072]                         has_future <- base::requireNamespace("future", 
[16:17:43.072]                           quietly = TRUE)
[16:17:43.072]                         if (has_future) {
[16:17:43.072]                           ns <- base::getNamespace("future")
[16:17:43.072]                           version <- ns[[".package"]][["version"]]
[16:17:43.072]                           if (is.null(version)) 
[16:17:43.072]                             version <- utils::packageVersion("future")
[16:17:43.072]                         }
[16:17:43.072]                         else {
[16:17:43.072]                           version <- NULL
[16:17:43.072]                         }
[16:17:43.072]                         if (!has_future || version < "1.8.0") {
[16:17:43.072]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:43.072]                             "", base::R.version$version.string), 
[16:17:43.072]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:43.072]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:43.072]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:43.072]                               "release", "version")], collapse = " "), 
[16:17:43.072]                             hostname = base::Sys.info()[["nodename"]])
[16:17:43.072]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:43.072]                             info)
[16:17:43.072]                           info <- base::paste(info, collapse = "; ")
[16:17:43.072]                           if (!has_future) {
[16:17:43.072]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:43.072]                               info)
[16:17:43.072]                           }
[16:17:43.072]                           else {
[16:17:43.072]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:43.072]                               info, version)
[16:17:43.072]                           }
[16:17:43.072]                           base::stop(msg)
[16:17:43.072]                         }
[16:17:43.072]                       })
[16:17:43.072]                     }
[16:17:43.072]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:43.072]                     base::options(mc.cores = 1L)
[16:17:43.072]                   }
[16:17:43.072]                   ...future.strategy.old <- future::plan("list")
[16:17:43.072]                   options(future.plan = NULL)
[16:17:43.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:43.072]                 }
[16:17:43.072]                 ...future.workdir <- getwd()
[16:17:43.072]             }
[16:17:43.072]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:43.072]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:43.072]         }
[16:17:43.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:43.072]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:43.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:43.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:43.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:43.072]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:43.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:43.072]             base::names(...future.oldOptions))
[16:17:43.072]     }
[16:17:43.072]     if (FALSE) {
[16:17:43.072]     }
[16:17:43.072]     else {
[16:17:43.072]         if (TRUE) {
[16:17:43.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:43.072]                 open = "w")
[16:17:43.072]         }
[16:17:43.072]         else {
[16:17:43.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:43.072]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:43.072]         }
[16:17:43.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:43.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:43.072]             base::sink(type = "output", split = FALSE)
[16:17:43.072]             base::close(...future.stdout)
[16:17:43.072]         }, add = TRUE)
[16:17:43.072]     }
[16:17:43.072]     ...future.frame <- base::sys.nframe()
[16:17:43.072]     ...future.conditions <- base::list()
[16:17:43.072]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:43.072]     if (FALSE) {
[16:17:43.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:43.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:43.072]     }
[16:17:43.072]     ...future.result <- base::tryCatch({
[16:17:43.072]         base::withCallingHandlers({
[16:17:43.072]             ...future.value <- base::withVisible(base::local({
[16:17:43.072]                 withCallingHandlers({
[16:17:43.072]                   {
[16:17:43.072]                     do.call(function(...) {
[16:17:43.072]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.072]                       if (!identical(...future.globals.maxSize.org, 
[16:17:43.072]                         ...future.globals.maxSize)) {
[16:17:43.072]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.072]                         on.exit(options(oopts), add = TRUE)
[16:17:43.072]                       }
[16:17:43.072]                       {
[16:17:43.072]                         lapply(seq_along(...future.elements_ii), 
[16:17:43.072]                           FUN = function(jj) {
[16:17:43.072]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.072]                             ...future.FUN(...future.X_jj, ...)
[16:17:43.072]                           })
[16:17:43.072]                       }
[16:17:43.072]                     }, args = future.call.arguments)
[16:17:43.072]                   }
[16:17:43.072]                 }, immediateCondition = function(cond) {
[16:17:43.072]                   save_rds <- function (object, pathname, ...) 
[16:17:43.072]                   {
[16:17:43.072]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:43.072]                     if (file_test("-f", pathname_tmp)) {
[16:17:43.072]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.072]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:43.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.072]                         fi_tmp[["mtime"]])
[16:17:43.072]                     }
[16:17:43.072]                     tryCatch({
[16:17:43.072]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:43.072]                     }, error = function(ex) {
[16:17:43.072]                       msg <- conditionMessage(ex)
[16:17:43.072]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.072]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:43.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.072]                         fi_tmp[["mtime"]], msg)
[16:17:43.072]                       ex$message <- msg
[16:17:43.072]                       stop(ex)
[16:17:43.072]                     })
[16:17:43.072]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:43.072]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:43.072]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:43.072]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.072]                       fi <- file.info(pathname)
[16:17:43.072]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:43.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.072]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:43.072]                         fi[["size"]], fi[["mtime"]])
[16:17:43.072]                       stop(msg)
[16:17:43.072]                     }
[16:17:43.072]                     invisible(pathname)
[16:17:43.072]                   }
[16:17:43.072]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:43.072]                     rootPath = tempdir()) 
[16:17:43.072]                   {
[16:17:43.072]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:43.072]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:43.072]                       tmpdir = path, fileext = ".rds")
[16:17:43.072]                     save_rds(obj, file)
[16:17:43.072]                   }
[16:17:43.072]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:43.072]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.072]                   {
[16:17:43.072]                     inherits <- base::inherits
[16:17:43.072]                     invokeRestart <- base::invokeRestart
[16:17:43.072]                     is.null <- base::is.null
[16:17:43.072]                     muffled <- FALSE
[16:17:43.072]                     if (inherits(cond, "message")) {
[16:17:43.072]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:43.072]                       if (muffled) 
[16:17:43.072]                         invokeRestart("muffleMessage")
[16:17:43.072]                     }
[16:17:43.072]                     else if (inherits(cond, "warning")) {
[16:17:43.072]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:43.072]                       if (muffled) 
[16:17:43.072]                         invokeRestart("muffleWarning")
[16:17:43.072]                     }
[16:17:43.072]                     else if (inherits(cond, "condition")) {
[16:17:43.072]                       if (!is.null(pattern)) {
[16:17:43.072]                         computeRestarts <- base::computeRestarts
[16:17:43.072]                         grepl <- base::grepl
[16:17:43.072]                         restarts <- computeRestarts(cond)
[16:17:43.072]                         for (restart in restarts) {
[16:17:43.072]                           name <- restart$name
[16:17:43.072]                           if (is.null(name)) 
[16:17:43.072]                             next
[16:17:43.072]                           if (!grepl(pattern, name)) 
[16:17:43.072]                             next
[16:17:43.072]                           invokeRestart(restart)
[16:17:43.072]                           muffled <- TRUE
[16:17:43.072]                           break
[16:17:43.072]                         }
[16:17:43.072]                       }
[16:17:43.072]                     }
[16:17:43.072]                     invisible(muffled)
[16:17:43.072]                   }
[16:17:43.072]                   muffleCondition(cond)
[16:17:43.072]                 })
[16:17:43.072]             }))
[16:17:43.072]             future::FutureResult(value = ...future.value$value, 
[16:17:43.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.072]                   ...future.rng), globalenv = if (FALSE) 
[16:17:43.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:43.072]                     ...future.globalenv.names))
[16:17:43.072]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:43.072]         }, condition = base::local({
[16:17:43.072]             c <- base::c
[16:17:43.072]             inherits <- base::inherits
[16:17:43.072]             invokeRestart <- base::invokeRestart
[16:17:43.072]             length <- base::length
[16:17:43.072]             list <- base::list
[16:17:43.072]             seq.int <- base::seq.int
[16:17:43.072]             signalCondition <- base::signalCondition
[16:17:43.072]             sys.calls <- base::sys.calls
[16:17:43.072]             `[[` <- base::`[[`
[16:17:43.072]             `+` <- base::`+`
[16:17:43.072]             `<<-` <- base::`<<-`
[16:17:43.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:43.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:43.072]                   3L)]
[16:17:43.072]             }
[16:17:43.072]             function(cond) {
[16:17:43.072]                 is_error <- inherits(cond, "error")
[16:17:43.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:43.072]                   NULL)
[16:17:43.072]                 if (is_error) {
[16:17:43.072]                   sessionInformation <- function() {
[16:17:43.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:43.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:43.072]                       search = base::search(), system = base::Sys.info())
[16:17:43.072]                   }
[16:17:43.072]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:43.072]                     cond$call), session = sessionInformation(), 
[16:17:43.072]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:43.072]                   signalCondition(cond)
[16:17:43.072]                 }
[16:17:43.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:43.072]                 "immediateCondition"))) {
[16:17:43.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:43.072]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:43.072]                   if (TRUE && !signal) {
[16:17:43.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.072]                     {
[16:17:43.072]                       inherits <- base::inherits
[16:17:43.072]                       invokeRestart <- base::invokeRestart
[16:17:43.072]                       is.null <- base::is.null
[16:17:43.072]                       muffled <- FALSE
[16:17:43.072]                       if (inherits(cond, "message")) {
[16:17:43.072]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.072]                         if (muffled) 
[16:17:43.072]                           invokeRestart("muffleMessage")
[16:17:43.072]                       }
[16:17:43.072]                       else if (inherits(cond, "warning")) {
[16:17:43.072]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.072]                         if (muffled) 
[16:17:43.072]                           invokeRestart("muffleWarning")
[16:17:43.072]                       }
[16:17:43.072]                       else if (inherits(cond, "condition")) {
[16:17:43.072]                         if (!is.null(pattern)) {
[16:17:43.072]                           computeRestarts <- base::computeRestarts
[16:17:43.072]                           grepl <- base::grepl
[16:17:43.072]                           restarts <- computeRestarts(cond)
[16:17:43.072]                           for (restart in restarts) {
[16:17:43.072]                             name <- restart$name
[16:17:43.072]                             if (is.null(name)) 
[16:17:43.072]                               next
[16:17:43.072]                             if (!grepl(pattern, name)) 
[16:17:43.072]                               next
[16:17:43.072]                             invokeRestart(restart)
[16:17:43.072]                             muffled <- TRUE
[16:17:43.072]                             break
[16:17:43.072]                           }
[16:17:43.072]                         }
[16:17:43.072]                       }
[16:17:43.072]                       invisible(muffled)
[16:17:43.072]                     }
[16:17:43.072]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.072]                   }
[16:17:43.072]                 }
[16:17:43.072]                 else {
[16:17:43.072]                   if (TRUE) {
[16:17:43.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.072]                     {
[16:17:43.072]                       inherits <- base::inherits
[16:17:43.072]                       invokeRestart <- base::invokeRestart
[16:17:43.072]                       is.null <- base::is.null
[16:17:43.072]                       muffled <- FALSE
[16:17:43.072]                       if (inherits(cond, "message")) {
[16:17:43.072]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.072]                         if (muffled) 
[16:17:43.072]                           invokeRestart("muffleMessage")
[16:17:43.072]                       }
[16:17:43.072]                       else if (inherits(cond, "warning")) {
[16:17:43.072]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.072]                         if (muffled) 
[16:17:43.072]                           invokeRestart("muffleWarning")
[16:17:43.072]                       }
[16:17:43.072]                       else if (inherits(cond, "condition")) {
[16:17:43.072]                         if (!is.null(pattern)) {
[16:17:43.072]                           computeRestarts <- base::computeRestarts
[16:17:43.072]                           grepl <- base::grepl
[16:17:43.072]                           restarts <- computeRestarts(cond)
[16:17:43.072]                           for (restart in restarts) {
[16:17:43.072]                             name <- restart$name
[16:17:43.072]                             if (is.null(name)) 
[16:17:43.072]                               next
[16:17:43.072]                             if (!grepl(pattern, name)) 
[16:17:43.072]                               next
[16:17:43.072]                             invokeRestart(restart)
[16:17:43.072]                             muffled <- TRUE
[16:17:43.072]                             break
[16:17:43.072]                           }
[16:17:43.072]                         }
[16:17:43.072]                       }
[16:17:43.072]                       invisible(muffled)
[16:17:43.072]                     }
[16:17:43.072]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.072]                   }
[16:17:43.072]                 }
[16:17:43.072]             }
[16:17:43.072]         }))
[16:17:43.072]     }, error = function(ex) {
[16:17:43.072]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:43.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.072]                 ...future.rng), started = ...future.startTime, 
[16:17:43.072]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:43.072]             version = "1.8"), class = "FutureResult")
[16:17:43.072]     }, finally = {
[16:17:43.072]         if (!identical(...future.workdir, getwd())) 
[16:17:43.072]             setwd(...future.workdir)
[16:17:43.072]         {
[16:17:43.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:43.072]                 ...future.oldOptions$nwarnings <- NULL
[16:17:43.072]             }
[16:17:43.072]             base::options(...future.oldOptions)
[16:17:43.072]             if (.Platform$OS.type == "windows") {
[16:17:43.072]                 old_names <- names(...future.oldEnvVars)
[16:17:43.072]                 envs <- base::Sys.getenv()
[16:17:43.072]                 names <- names(envs)
[16:17:43.072]                 common <- intersect(names, old_names)
[16:17:43.072]                 added <- setdiff(names, old_names)
[16:17:43.072]                 removed <- setdiff(old_names, names)
[16:17:43.072]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:43.072]                   envs[common]]
[16:17:43.072]                 NAMES <- toupper(changed)
[16:17:43.072]                 args <- list()
[16:17:43.072]                 for (kk in seq_along(NAMES)) {
[16:17:43.072]                   name <- changed[[kk]]
[16:17:43.072]                   NAME <- NAMES[[kk]]
[16:17:43.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.072]                     next
[16:17:43.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.072]                 }
[16:17:43.072]                 NAMES <- toupper(added)
[16:17:43.072]                 for (kk in seq_along(NAMES)) {
[16:17:43.072]                   name <- added[[kk]]
[16:17:43.072]                   NAME <- NAMES[[kk]]
[16:17:43.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.072]                     next
[16:17:43.072]                   args[[name]] <- ""
[16:17:43.072]                 }
[16:17:43.072]                 NAMES <- toupper(removed)
[16:17:43.072]                 for (kk in seq_along(NAMES)) {
[16:17:43.072]                   name <- removed[[kk]]
[16:17:43.072]                   NAME <- NAMES[[kk]]
[16:17:43.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.072]                     next
[16:17:43.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.072]                 }
[16:17:43.072]                 if (length(args) > 0) 
[16:17:43.072]                   base::do.call(base::Sys.setenv, args = args)
[16:17:43.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:43.072]             }
[16:17:43.072]             else {
[16:17:43.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:43.072]             }
[16:17:43.072]             {
[16:17:43.072]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:43.072]                   0L) {
[16:17:43.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:43.072]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:43.072]                   base::options(opts)
[16:17:43.072]                 }
[16:17:43.072]                 {
[16:17:43.072]                   {
[16:17:43.072]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:43.072]                     NULL
[16:17:43.072]                   }
[16:17:43.072]                   options(future.plan = NULL)
[16:17:43.072]                   if (is.na(NA_character_)) 
[16:17:43.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:43.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:43.072]                     .init = FALSE)
[16:17:43.072]                 }
[16:17:43.072]             }
[16:17:43.072]         }
[16:17:43.072]     })
[16:17:43.072]     if (TRUE) {
[16:17:43.072]         base::sink(type = "output", split = FALSE)
[16:17:43.072]         if (TRUE) {
[16:17:43.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:43.072]         }
[16:17:43.072]         else {
[16:17:43.072]             ...future.result["stdout"] <- base::list(NULL)
[16:17:43.072]         }
[16:17:43.072]         base::close(...future.stdout)
[16:17:43.072]         ...future.stdout <- NULL
[16:17:43.072]     }
[16:17:43.072]     ...future.result$conditions <- ...future.conditions
[16:17:43.072]     ...future.result$finished <- base::Sys.time()
[16:17:43.072]     ...future.result
[16:17:43.072] }
[16:17:43.075] assign_globals() ...
[16:17:43.075] List of 5
[16:17:43.075]  $ future.call.arguments    : list()
[16:17:43.075]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.075]  $ ...future.FUN            :function (x)  
[16:17:43.075]  $ ...future.elements_ii    :List of 1
[16:17:43.075]   ..$ : int [1:2] 2 4
[16:17:43.075]  $ ...future.seeds_ii       : NULL
[16:17:43.075]  $ ...future.globals.maxSize: num Inf
[16:17:43.075]  - attr(*, "resolved")= logi FALSE
[16:17:43.075]  - attr(*, "total_size")= num NA
[16:17:43.075]  - attr(*, "where")=List of 5
[16:17:43.075]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:43.075]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:43.075]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:43.075]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:43.075]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:43.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.075]  - attr(*, "already-done")= logi TRUE
[16:17:43.082] - copied ‘future.call.arguments’ to environment
[16:17:43.082] - reassign environment for ‘...future.FUN’
[16:17:43.082] - copied ‘...future.FUN’ to environment
[16:17:43.082] - copied ‘...future.elements_ii’ to environment
[16:17:43.082] - copied ‘...future.seeds_ii’ to environment
[16:17:43.082] - copied ‘...future.globals.maxSize’ to environment
[16:17:43.082] assign_globals() ... done
[16:17:43.083] requestCore(): workers = 2
[16:17:43.085] MulticoreFuture started
[16:17:43.085] - Launch lazy future ... done
[16:17:43.085] run() for ‘MulticoreFuture’ ... done
[16:17:43.086] Created future:
[16:17:43.086] plan(): Setting new future strategy stack:
[16:17:43.086] List of future strategies:
[16:17:43.086] 1. sequential:
[16:17:43.086]    - args: function (..., envir = parent.frame())
[16:17:43.086]    - tweaked: FALSE
[16:17:43.086]    - call: NULL
[16:17:43.087] plan(): nbrOfWorkers() = 1
[16:17:43.089] plan(): Setting new future strategy stack:
[16:17:43.089] List of future strategies:
[16:17:43.089] 1. multicore:
[16:17:43.089]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:43.089]    - tweaked: FALSE
[16:17:43.089]    - call: plan(strategy)
[16:17:43.095] plan(): nbrOfWorkers() = 2
[16:17:43.086] MulticoreFuture:
[16:17:43.086] Label: ‘future_apply-2’
[16:17:43.086] Expression:
[16:17:43.086] {
[16:17:43.086]     do.call(function(...) {
[16:17:43.086]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.086]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:43.086]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.086]             on.exit(options(oopts), add = TRUE)
[16:17:43.086]         }
[16:17:43.086]         {
[16:17:43.086]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:43.086]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.086]                 ...future.FUN(...future.X_jj, ...)
[16:17:43.086]             })
[16:17:43.086]         }
[16:17:43.086]     }, args = future.call.arguments)
[16:17:43.086] }
[16:17:43.086] Lazy evaluation: FALSE
[16:17:43.086] Asynchronous evaluation: TRUE
[16:17:43.086] Local evaluation: TRUE
[16:17:43.086] Environment: R_GlobalEnv
[16:17:43.086] Capture standard output: TRUE
[16:17:43.086] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:43.086] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:43.086] Packages: <none>
[16:17:43.086] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:43.086] Resolved: TRUE
[16:17:43.086] Value: <not collected>
[16:17:43.086] Conditions captured: <none>
[16:17:43.086] Early signaling: FALSE
[16:17:43.086] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:43.086] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:43.096] Chunk #2 of 2 ... DONE
[16:17:43.096] Launching 2 futures (chunks) ... DONE
[16:17:43.096] Resolving 2 futures (chunks) ...
[16:17:43.096] resolve() on list ...
[16:17:43.096]  recursive: 0
[16:17:43.097]  length: 2
[16:17:43.097] 
[16:17:43.097] Future #1
[16:17:43.097] result() for MulticoreFuture ...
[16:17:43.098] result() for MulticoreFuture ...
[16:17:43.098] result() for MulticoreFuture ... done
[16:17:43.098] result() for MulticoreFuture ... done
[16:17:43.098] result() for MulticoreFuture ...
[16:17:43.099] result() for MulticoreFuture ... done
[16:17:43.099] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:43.099] - nx: 2
[16:17:43.099] - relay: TRUE
[16:17:43.099] - stdout: TRUE
[16:17:43.099] - signal: TRUE
[16:17:43.099] - resignal: FALSE
[16:17:43.100] - force: TRUE
[16:17:43.100] - relayed: [n=2] FALSE, FALSE
[16:17:43.100] - queued futures: [n=2] FALSE, FALSE
[16:17:43.100]  - until=1
[16:17:43.100]  - relaying element #1
[16:17:43.100] result() for MulticoreFuture ...
[16:17:43.100] result() for MulticoreFuture ... done
[16:17:43.101] result() for MulticoreFuture ...
[16:17:43.101] result() for MulticoreFuture ... done
[16:17:43.101] result() for MulticoreFuture ...
[16:17:43.101] result() for MulticoreFuture ... done
[16:17:43.101] result() for MulticoreFuture ...
[16:17:43.101] result() for MulticoreFuture ... done
[16:17:43.102] - relayed: [n=2] TRUE, FALSE
[16:17:43.102] - queued futures: [n=2] TRUE, FALSE
[16:17:43.102] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:43.102]  length: 1 (resolved future 1)
[16:17:43.102] Future #2
[16:17:43.102] result() for MulticoreFuture ...
[16:17:43.103] result() for MulticoreFuture ...
[16:17:43.103] result() for MulticoreFuture ... done
[16:17:43.103] result() for MulticoreFuture ... done
[16:17:43.104] result() for MulticoreFuture ...
[16:17:43.104] result() for MulticoreFuture ... done
[16:17:43.104] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:43.104] - nx: 2
[16:17:43.107] - relay: TRUE
[16:17:43.107] - stdout: TRUE
[16:17:43.107] - signal: TRUE
[16:17:43.107] - resignal: FALSE
[16:17:43.107] - force: TRUE
[16:17:43.108] - relayed: [n=2] TRUE, FALSE
[16:17:43.108] - queued futures: [n=2] TRUE, FALSE
[16:17:43.108]  - until=2
[16:17:43.108]  - relaying element #2
[16:17:43.108] result() for MulticoreFuture ...
[16:17:43.109] result() for MulticoreFuture ... done
[16:17:43.109] result() for MulticoreFuture ...
[16:17:43.109] result() for MulticoreFuture ... done
[16:17:43.109] result() for MulticoreFuture ...
[16:17:43.109] result() for MulticoreFuture ... done
[16:17:43.109] result() for MulticoreFuture ...
[16:17:43.110] result() for MulticoreFuture ... done
[16:17:43.110] - relayed: [n=2] TRUE, TRUE
[16:17:43.110] - queued futures: [n=2] TRUE, TRUE
[16:17:43.110] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:43.110]  length: 0 (resolved future 2)
[16:17:43.110] Relaying remaining futures
[16:17:43.111] signalConditionsASAP(NULL, pos=0) ...
[16:17:43.111] - nx: 2
[16:17:43.111] - relay: TRUE
[16:17:43.111] - stdout: TRUE
[16:17:43.111] - signal: TRUE
[16:17:43.111] - resignal: FALSE
[16:17:43.111] - force: TRUE
[16:17:43.112] - relayed: [n=2] TRUE, TRUE
[16:17:43.112] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:43.112] - relayed: [n=2] TRUE, TRUE
[16:17:43.112] - queued futures: [n=2] TRUE, TRUE
[16:17:43.112] signalConditionsASAP(NULL, pos=0) ... done
[16:17:43.112] resolve() on list ... DONE
[16:17:43.112] result() for MulticoreFuture ...
[16:17:43.112] result() for MulticoreFuture ... done
[16:17:43.112] result() for MulticoreFuture ...
[16:17:43.113] result() for MulticoreFuture ... done
[16:17:43.113] result() for MulticoreFuture ...
[16:17:43.113] result() for MulticoreFuture ... done
[16:17:43.113] result() for MulticoreFuture ...
[16:17:43.113] result() for MulticoreFuture ... done
[16:17:43.113]  - Number of value chunks collected: 2
[16:17:43.113] Resolving 2 futures (chunks) ... DONE
[16:17:43.114] Reducing values from 2 chunks ...
[16:17:43.114]  - Number of values collected after concatenation: 2
[16:17:43.114]  - Number of values expected: 2
[16:17:43.114] Reducing values from 2 chunks ... DONE
[16:17:43.114] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:17:43.114] getGlobalsAndPackagesXApply() ...
[16:17:43.115]  - future.globals: TRUE
[16:17:43.115] getGlobalsAndPackages() ...
[16:17:43.115] Searching for globals...
[16:17:43.118] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:17:43.119] Searching for globals ... DONE
[16:17:43.119] Resolving globals: FALSE
[16:17:43.119] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:17:43.120] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:17:43.120] - globals: [1] ‘FUN’
[16:17:43.120] 
[16:17:43.120] getGlobalsAndPackages() ... DONE
[16:17:43.120]  - globals found/used: [n=1] ‘FUN’
[16:17:43.120]  - needed namespaces: [n=0] 
[16:17:43.120] Finding globals ... DONE
[16:17:43.121]  - use_args: TRUE
[16:17:43.121]  - Getting '...' globals ...
[16:17:43.121] resolve() on list ...
[16:17:43.121]  recursive: 0
[16:17:43.121]  length: 1
[16:17:43.121]  elements: ‘...’
[16:17:43.121]  length: 0 (resolved future 1)
[16:17:43.122] resolve() on list ... DONE
[16:17:43.122]    - '...' content: [n=0] 
[16:17:43.122] List of 1
[16:17:43.122]  $ ...: list()
[16:17:43.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.122]  - attr(*, "where")=List of 1
[16:17:43.122]   ..$ ...:<environment: 0x555be0dd9e78> 
[16:17:43.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.122]  - attr(*, "resolved")= logi TRUE
[16:17:43.122]  - attr(*, "total_size")= num NA
[16:17:43.124]  - Getting '...' globals ... DONE
[16:17:43.125] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:43.125] List of 2
[16:17:43.125]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:17:43.125]  $ ...          : list()
[16:17:43.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.125]  - attr(*, "where")=List of 2
[16:17:43.125]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:43.125]   ..$ ...          :<environment: 0x555be0dd9e78> 
[16:17:43.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.125]  - attr(*, "resolved")= logi FALSE
[16:17:43.125]  - attr(*, "total_size")= num 36296
[16:17:43.127] Packages to be attached in all futures: [n=0] 
[16:17:43.127] getGlobalsAndPackagesXApply() ... DONE
[16:17:43.134] future_lapply() ...
[16:17:43.136] Generating random seeds ...
[16:17:43.136] Generating random seed streams for 2 elements ...
[16:17:43.136] Generating random seed streams for 2 elements ... DONE
[16:17:43.136] Generating random seeds ... DONE
[16:17:43.136] Will set RNG state on exit: 10407, 1316158302, 262367299, -846597894, 720603801, 1858398825, -246648567
[16:17:43.140] Number of chunks: 2
[16:17:43.140] getGlobalsAndPackagesXApply() ...
[16:17:43.140]  - future.globals: <name-value list> with names ‘list()’
[16:17:43.140]  - use_args: TRUE
[16:17:43.140] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:43.141] List of 2
[16:17:43.141]  $ ...          : list()
[16:17:43.141]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.141]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:17:43.141]  - attr(*, "where")=List of 2
[16:17:43.141]   ..$ ...          :<environment: 0x555be0dd9e78> 
[16:17:43.141]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:43.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.141]  - attr(*, "resolved")= logi FALSE
[16:17:43.141]  - attr(*, "total_size")= num NA
[16:17:43.144] Packages to be attached in all futures: [n=0] 
[16:17:43.144] getGlobalsAndPackagesXApply() ... DONE
[16:17:43.144] Number of futures (= number of chunks): 2
[16:17:43.144] Launching 2 futures (chunks) ...
[16:17:43.144] Chunk #1 of 2 ...
[16:17:43.145]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:43.145]  - seeds: [1] <seeds>
[16:17:43.145]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.145] getGlobalsAndPackages() ...
[16:17:43.145] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.145] Resolving globals: FALSE
[16:17:43.145] Tweak future expression to call with '...' arguments ...
[16:17:43.145] {
[16:17:43.145]     do.call(function(...) {
[16:17:43.145]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.145]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:43.145]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.145]             on.exit(options(oopts), add = TRUE)
[16:17:43.145]         }
[16:17:43.145]         {
[16:17:43.145]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:43.145]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.145]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:43.145]                   envir = globalenv(), inherits = FALSE)
[16:17:43.145]                 ...future.FUN(...future.X_jj, ...)
[16:17:43.145]             })
[16:17:43.145]         }
[16:17:43.145]     }, args = future.call.arguments)
[16:17:43.145] }
[16:17:43.146] Tweak future expression to call with '...' arguments ... DONE
[16:17:43.146] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.146] 
[16:17:43.146] getGlobalsAndPackages() ... DONE
[16:17:43.146] run() for ‘Future’ ...
[16:17:43.147] - state: ‘created’
[16:17:43.147] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:43.150] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:43.150] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:43.150]   - Field: ‘label’
[16:17:43.150]   - Field: ‘local’
[16:17:43.151]   - Field: ‘owner’
[16:17:43.151]   - Field: ‘envir’
[16:17:43.151]   - Field: ‘workers’
[16:17:43.151]   - Field: ‘packages’
[16:17:43.151]   - Field: ‘gc’
[16:17:43.151]   - Field: ‘job’
[16:17:43.151]   - Field: ‘conditions’
[16:17:43.151]   - Field: ‘expr’
[16:17:43.151]   - Field: ‘uuid’
[16:17:43.151]   - Field: ‘seed’
[16:17:43.151]   - Field: ‘version’
[16:17:43.152]   - Field: ‘result’
[16:17:43.152]   - Field: ‘asynchronous’
[16:17:43.152]   - Field: ‘calls’
[16:17:43.152]   - Field: ‘globals’
[16:17:43.152]   - Field: ‘stdout’
[16:17:43.152]   - Field: ‘earlySignal’
[16:17:43.152]   - Field: ‘lazy’
[16:17:43.152]   - Field: ‘state’
[16:17:43.152] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:43.152] - Launch lazy future ...
[16:17:43.153] Packages needed by the future expression (n = 0): <none>
[16:17:43.153] Packages needed by future strategies (n = 0): <none>
[16:17:43.153] {
[16:17:43.153]     {
[16:17:43.153]         {
[16:17:43.153]             ...future.startTime <- base::Sys.time()
[16:17:43.153]             {
[16:17:43.153]                 {
[16:17:43.153]                   {
[16:17:43.153]                     {
[16:17:43.153]                       base::local({
[16:17:43.153]                         has_future <- base::requireNamespace("future", 
[16:17:43.153]                           quietly = TRUE)
[16:17:43.153]                         if (has_future) {
[16:17:43.153]                           ns <- base::getNamespace("future")
[16:17:43.153]                           version <- ns[[".package"]][["version"]]
[16:17:43.153]                           if (is.null(version)) 
[16:17:43.153]                             version <- utils::packageVersion("future")
[16:17:43.153]                         }
[16:17:43.153]                         else {
[16:17:43.153]                           version <- NULL
[16:17:43.153]                         }
[16:17:43.153]                         if (!has_future || version < "1.8.0") {
[16:17:43.153]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:43.153]                             "", base::R.version$version.string), 
[16:17:43.153]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:43.153]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:43.153]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:43.153]                               "release", "version")], collapse = " "), 
[16:17:43.153]                             hostname = base::Sys.info()[["nodename"]])
[16:17:43.153]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:43.153]                             info)
[16:17:43.153]                           info <- base::paste(info, collapse = "; ")
[16:17:43.153]                           if (!has_future) {
[16:17:43.153]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:43.153]                               info)
[16:17:43.153]                           }
[16:17:43.153]                           else {
[16:17:43.153]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:43.153]                               info, version)
[16:17:43.153]                           }
[16:17:43.153]                           base::stop(msg)
[16:17:43.153]                         }
[16:17:43.153]                       })
[16:17:43.153]                     }
[16:17:43.153]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:43.153]                     base::options(mc.cores = 1L)
[16:17:43.153]                   }
[16:17:43.153]                   ...future.strategy.old <- future::plan("list")
[16:17:43.153]                   options(future.plan = NULL)
[16:17:43.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:43.153]                 }
[16:17:43.153]                 ...future.workdir <- getwd()
[16:17:43.153]             }
[16:17:43.153]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:43.153]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:43.153]         }
[16:17:43.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:43.153]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:43.153]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:43.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:43.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:43.153]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:43.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:43.153]             base::names(...future.oldOptions))
[16:17:43.153]     }
[16:17:43.153]     if (FALSE) {
[16:17:43.153]     }
[16:17:43.153]     else {
[16:17:43.153]         if (TRUE) {
[16:17:43.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:43.153]                 open = "w")
[16:17:43.153]         }
[16:17:43.153]         else {
[16:17:43.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:43.153]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:43.153]         }
[16:17:43.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:43.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:43.153]             base::sink(type = "output", split = FALSE)
[16:17:43.153]             base::close(...future.stdout)
[16:17:43.153]         }, add = TRUE)
[16:17:43.153]     }
[16:17:43.153]     ...future.frame <- base::sys.nframe()
[16:17:43.153]     ...future.conditions <- base::list()
[16:17:43.153]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:43.153]     if (FALSE) {
[16:17:43.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:43.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:43.153]     }
[16:17:43.153]     ...future.result <- base::tryCatch({
[16:17:43.153]         base::withCallingHandlers({
[16:17:43.153]             ...future.value <- base::withVisible(base::local({
[16:17:43.153]                 withCallingHandlers({
[16:17:43.153]                   {
[16:17:43.153]                     do.call(function(...) {
[16:17:43.153]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.153]                       if (!identical(...future.globals.maxSize.org, 
[16:17:43.153]                         ...future.globals.maxSize)) {
[16:17:43.153]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.153]                         on.exit(options(oopts), add = TRUE)
[16:17:43.153]                       }
[16:17:43.153]                       {
[16:17:43.153]                         lapply(seq_along(...future.elements_ii), 
[16:17:43.153]                           FUN = function(jj) {
[16:17:43.153]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.153]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:43.153]                               envir = globalenv(), inherits = FALSE)
[16:17:43.153]                             ...future.FUN(...future.X_jj, ...)
[16:17:43.153]                           })
[16:17:43.153]                       }
[16:17:43.153]                     }, args = future.call.arguments)
[16:17:43.153]                   }
[16:17:43.153]                 }, immediateCondition = function(cond) {
[16:17:43.153]                   save_rds <- function (object, pathname, ...) 
[16:17:43.153]                   {
[16:17:43.153]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:43.153]                     if (file_test("-f", pathname_tmp)) {
[16:17:43.153]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.153]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:43.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.153]                         fi_tmp[["mtime"]])
[16:17:43.153]                     }
[16:17:43.153]                     tryCatch({
[16:17:43.153]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:43.153]                     }, error = function(ex) {
[16:17:43.153]                       msg <- conditionMessage(ex)
[16:17:43.153]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.153]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:43.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.153]                         fi_tmp[["mtime"]], msg)
[16:17:43.153]                       ex$message <- msg
[16:17:43.153]                       stop(ex)
[16:17:43.153]                     })
[16:17:43.153]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:43.153]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:43.153]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:43.153]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.153]                       fi <- file.info(pathname)
[16:17:43.153]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:43.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.153]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:43.153]                         fi[["size"]], fi[["mtime"]])
[16:17:43.153]                       stop(msg)
[16:17:43.153]                     }
[16:17:43.153]                     invisible(pathname)
[16:17:43.153]                   }
[16:17:43.153]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:43.153]                     rootPath = tempdir()) 
[16:17:43.153]                   {
[16:17:43.153]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:43.153]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:43.153]                       tmpdir = path, fileext = ".rds")
[16:17:43.153]                     save_rds(obj, file)
[16:17:43.153]                   }
[16:17:43.153]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:43.153]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.153]                   {
[16:17:43.153]                     inherits <- base::inherits
[16:17:43.153]                     invokeRestart <- base::invokeRestart
[16:17:43.153]                     is.null <- base::is.null
[16:17:43.153]                     muffled <- FALSE
[16:17:43.153]                     if (inherits(cond, "message")) {
[16:17:43.153]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:43.153]                       if (muffled) 
[16:17:43.153]                         invokeRestart("muffleMessage")
[16:17:43.153]                     }
[16:17:43.153]                     else if (inherits(cond, "warning")) {
[16:17:43.153]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:43.153]                       if (muffled) 
[16:17:43.153]                         invokeRestart("muffleWarning")
[16:17:43.153]                     }
[16:17:43.153]                     else if (inherits(cond, "condition")) {
[16:17:43.153]                       if (!is.null(pattern)) {
[16:17:43.153]                         computeRestarts <- base::computeRestarts
[16:17:43.153]                         grepl <- base::grepl
[16:17:43.153]                         restarts <- computeRestarts(cond)
[16:17:43.153]                         for (restart in restarts) {
[16:17:43.153]                           name <- restart$name
[16:17:43.153]                           if (is.null(name)) 
[16:17:43.153]                             next
[16:17:43.153]                           if (!grepl(pattern, name)) 
[16:17:43.153]                             next
[16:17:43.153]                           invokeRestart(restart)
[16:17:43.153]                           muffled <- TRUE
[16:17:43.153]                           break
[16:17:43.153]                         }
[16:17:43.153]                       }
[16:17:43.153]                     }
[16:17:43.153]                     invisible(muffled)
[16:17:43.153]                   }
[16:17:43.153]                   muffleCondition(cond)
[16:17:43.153]                 })
[16:17:43.153]             }))
[16:17:43.153]             future::FutureResult(value = ...future.value$value, 
[16:17:43.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.153]                   ...future.rng), globalenv = if (FALSE) 
[16:17:43.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:43.153]                     ...future.globalenv.names))
[16:17:43.153]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:43.153]         }, condition = base::local({
[16:17:43.153]             c <- base::c
[16:17:43.153]             inherits <- base::inherits
[16:17:43.153]             invokeRestart <- base::invokeRestart
[16:17:43.153]             length <- base::length
[16:17:43.153]             list <- base::list
[16:17:43.153]             seq.int <- base::seq.int
[16:17:43.153]             signalCondition <- base::signalCondition
[16:17:43.153]             sys.calls <- base::sys.calls
[16:17:43.153]             `[[` <- base::`[[`
[16:17:43.153]             `+` <- base::`+`
[16:17:43.153]             `<<-` <- base::`<<-`
[16:17:43.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:43.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:43.153]                   3L)]
[16:17:43.153]             }
[16:17:43.153]             function(cond) {
[16:17:43.153]                 is_error <- inherits(cond, "error")
[16:17:43.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:43.153]                   NULL)
[16:17:43.153]                 if (is_error) {
[16:17:43.153]                   sessionInformation <- function() {
[16:17:43.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:43.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:43.153]                       search = base::search(), system = base::Sys.info())
[16:17:43.153]                   }
[16:17:43.153]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:43.153]                     cond$call), session = sessionInformation(), 
[16:17:43.153]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:43.153]                   signalCondition(cond)
[16:17:43.153]                 }
[16:17:43.153]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:17:43.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:43.153]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:43.153]                   if (TRUE && !signal) {
[16:17:43.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.153]                     {
[16:17:43.153]                       inherits <- base::inherits
[16:17:43.153]                       invokeRestart <- base::invokeRestart
[16:17:43.153]                       is.null <- base::is.null
[16:17:43.153]                       muffled <- FALSE
[16:17:43.153]                       if (inherits(cond, "message")) {
[16:17:43.153]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.153]                         if (muffled) 
[16:17:43.153]                           invokeRestart("muffleMessage")
[16:17:43.153]                       }
[16:17:43.153]                       else if (inherits(cond, "warning")) {
[16:17:43.153]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.153]                         if (muffled) 
[16:17:43.153]                           invokeRestart("muffleWarning")
[16:17:43.153]                       }
[16:17:43.153]                       else if (inherits(cond, "condition")) {
[16:17:43.153]                         if (!is.null(pattern)) {
[16:17:43.153]                           computeRestarts <- base::computeRestarts
[16:17:43.153]                           grepl <- base::grepl
[16:17:43.153]                           restarts <- computeRestarts(cond)
[16:17:43.153]                           for (restart in restarts) {
[16:17:43.153]                             name <- restart$name
[16:17:43.153]                             if (is.null(name)) 
[16:17:43.153]                               next
[16:17:43.153]                             if (!grepl(pattern, name)) 
[16:17:43.153]                               next
[16:17:43.153]                             invokeRestart(restart)
[16:17:43.153]                             muffled <- TRUE
[16:17:43.153]                             break
[16:17:43.153]                           }
[16:17:43.153]                         }
[16:17:43.153]                       }
[16:17:43.153]                       invisible(muffled)
[16:17:43.153]                     }
[16:17:43.153]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.153]                   }
[16:17:43.153]                 }
[16:17:43.153]                 else {
[16:17:43.153]                   if (TRUE) {
[16:17:43.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.153]                     {
[16:17:43.153]                       inherits <- base::inherits
[16:17:43.153]                       invokeRestart <- base::invokeRestart
[16:17:43.153]                       is.null <- base::is.null
[16:17:43.153]                       muffled <- FALSE
[16:17:43.153]                       if (inherits(cond, "message")) {
[16:17:43.153]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.153]                         if (muffled) 
[16:17:43.153]                           invokeRestart("muffleMessage")
[16:17:43.153]                       }
[16:17:43.153]                       else if (inherits(cond, "warning")) {
[16:17:43.153]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.153]                         if (muffled) 
[16:17:43.153]                           invokeRestart("muffleWarning")
[16:17:43.153]                       }
[16:17:43.153]                       else if (inherits(cond, "condition")) {
[16:17:43.153]                         if (!is.null(pattern)) {
[16:17:43.153]                           computeRestarts <- base::computeRestarts
[16:17:43.153]                           grepl <- base::grepl
[16:17:43.153]                           restarts <- computeRestarts(cond)
[16:17:43.153]                           for (restart in restarts) {
[16:17:43.153]                             name <- restart$name
[16:17:43.153]                             if (is.null(name)) 
[16:17:43.153]                               next
[16:17:43.153]                             if (!grepl(pattern, name)) 
[16:17:43.153]                               next
[16:17:43.153]                             invokeRestart(restart)
[16:17:43.153]                             muffled <- TRUE
[16:17:43.153]                             break
[16:17:43.153]                           }
[16:17:43.153]                         }
[16:17:43.153]                       }
[16:17:43.153]                       invisible(muffled)
[16:17:43.153]                     }
[16:17:43.153]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.153]                   }
[16:17:43.153]                 }
[16:17:43.153]             }
[16:17:43.153]         }))
[16:17:43.153]     }, error = function(ex) {
[16:17:43.153]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:43.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.153]                 ...future.rng), started = ...future.startTime, 
[16:17:43.153]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:43.153]             version = "1.8"), class = "FutureResult")
[16:17:43.153]     }, finally = {
[16:17:43.153]         if (!identical(...future.workdir, getwd())) 
[16:17:43.153]             setwd(...future.workdir)
[16:17:43.153]         {
[16:17:43.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:43.153]                 ...future.oldOptions$nwarnings <- NULL
[16:17:43.153]             }
[16:17:43.153]             base::options(...future.oldOptions)
[16:17:43.153]             if (.Platform$OS.type == "windows") {
[16:17:43.153]                 old_names <- names(...future.oldEnvVars)
[16:17:43.153]                 envs <- base::Sys.getenv()
[16:17:43.153]                 names <- names(envs)
[16:17:43.153]                 common <- intersect(names, old_names)
[16:17:43.153]                 added <- setdiff(names, old_names)
[16:17:43.153]                 removed <- setdiff(old_names, names)
[16:17:43.153]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:43.153]                   envs[common]]
[16:17:43.153]                 NAMES <- toupper(changed)
[16:17:43.153]                 args <- list()
[16:17:43.153]                 for (kk in seq_along(NAMES)) {
[16:17:43.153]                   name <- changed[[kk]]
[16:17:43.153]                   NAME <- NAMES[[kk]]
[16:17:43.153]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.153]                     next
[16:17:43.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.153]                 }
[16:17:43.153]                 NAMES <- toupper(added)
[16:17:43.153]                 for (kk in seq_along(NAMES)) {
[16:17:43.153]                   name <- added[[kk]]
[16:17:43.153]                   NAME <- NAMES[[kk]]
[16:17:43.153]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.153]                     next
[16:17:43.153]                   args[[name]] <- ""
[16:17:43.153]                 }
[16:17:43.153]                 NAMES <- toupper(removed)
[16:17:43.153]                 for (kk in seq_along(NAMES)) {
[16:17:43.153]                   name <- removed[[kk]]
[16:17:43.153]                   NAME <- NAMES[[kk]]
[16:17:43.153]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.153]                     next
[16:17:43.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.153]                 }
[16:17:43.153]                 if (length(args) > 0) 
[16:17:43.153]                   base::do.call(base::Sys.setenv, args = args)
[16:17:43.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:43.153]             }
[16:17:43.153]             else {
[16:17:43.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:43.153]             }
[16:17:43.153]             {
[16:17:43.153]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:43.153]                   0L) {
[16:17:43.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:43.153]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:43.153]                   base::options(opts)
[16:17:43.153]                 }
[16:17:43.153]                 {
[16:17:43.153]                   {
[16:17:43.153]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:43.153]                     NULL
[16:17:43.153]                   }
[16:17:43.153]                   options(future.plan = NULL)
[16:17:43.153]                   if (is.na(NA_character_)) 
[16:17:43.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:43.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:43.153]                     .init = FALSE)
[16:17:43.153]                 }
[16:17:43.153]             }
[16:17:43.153]         }
[16:17:43.153]     })
[16:17:43.153]     if (TRUE) {
[16:17:43.153]         base::sink(type = "output", split = FALSE)
[16:17:43.153]         if (TRUE) {
[16:17:43.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:43.153]         }
[16:17:43.153]         else {
[16:17:43.153]             ...future.result["stdout"] <- base::list(NULL)
[16:17:43.153]         }
[16:17:43.153]         base::close(...future.stdout)
[16:17:43.153]         ...future.stdout <- NULL
[16:17:43.153]     }
[16:17:43.153]     ...future.result$conditions <- ...future.conditions
[16:17:43.153]     ...future.result$finished <- base::Sys.time()
[16:17:43.153]     ...future.result
[16:17:43.153] }
[16:17:43.156] assign_globals() ...
[16:17:43.156] List of 5
[16:17:43.156]  $ future.call.arguments    : list()
[16:17:43.156]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.156]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:17:43.156]  $ ...future.elements_ii    :List of 1
[16:17:43.156]   ..$ : int [1:2] 1 3
[16:17:43.156]  $ ...future.seeds_ii       :List of 1
[16:17:43.156]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:17:43.156]  $ ...future.globals.maxSize: num Inf
[16:17:43.156]  - attr(*, "resolved")= logi FALSE
[16:17:43.156]  - attr(*, "total_size")= num NA
[16:17:43.156]  - attr(*, "where")=List of 5
[16:17:43.156]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:43.156]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:43.156]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:43.156]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:43.156]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:43.156]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.156]  - attr(*, "already-done")= logi TRUE
[16:17:43.162] - copied ‘future.call.arguments’ to environment
[16:17:43.162] - copied ‘...future.FUN’ to environment
[16:17:43.162] - copied ‘...future.elements_ii’ to environment
[16:17:43.162] - copied ‘...future.seeds_ii’ to environment
[16:17:43.162] - copied ‘...future.globals.maxSize’ to environment
[16:17:43.162] assign_globals() ... done
[16:17:43.163] requestCore(): workers = 2
[16:17:43.165] MulticoreFuture started
[16:17:43.166] - Launch lazy future ... done
[16:17:43.166] plan(): Setting new future strategy stack:
[16:17:43.166] run() for ‘MulticoreFuture’ ... done
[16:17:43.167] Created future:
[16:17:43.167] List of future strategies:
[16:17:43.167] 1. sequential:
[16:17:43.167]    - args: function (..., envir = parent.frame())
[16:17:43.167]    - tweaked: FALSE
[16:17:43.167]    - call: NULL
[16:17:43.168] plan(): nbrOfWorkers() = 1
[16:17:43.171] plan(): Setting new future strategy stack:
[16:17:43.171] List of future strategies:
[16:17:43.171] 1. multicore:
[16:17:43.171]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:43.171]    - tweaked: FALSE
[16:17:43.171]    - call: plan(strategy)
[16:17:43.177] plan(): nbrOfWorkers() = 2
[16:17:43.167] MulticoreFuture:
[16:17:43.167] Label: ‘future_apply-1’
[16:17:43.167] Expression:
[16:17:43.167] {
[16:17:43.167]     do.call(function(...) {
[16:17:43.167]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.167]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:43.167]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.167]             on.exit(options(oopts), add = TRUE)
[16:17:43.167]         }
[16:17:43.167]         {
[16:17:43.167]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:43.167]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.167]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:43.167]                   envir = globalenv(), inherits = FALSE)
[16:17:43.167]                 ...future.FUN(...future.X_jj, ...)
[16:17:43.167]             })
[16:17:43.167]         }
[16:17:43.167]     }, args = future.call.arguments)
[16:17:43.167] }
[16:17:43.167] Lazy evaluation: FALSE
[16:17:43.167] Asynchronous evaluation: TRUE
[16:17:43.167] Local evaluation: TRUE
[16:17:43.167] Environment: R_GlobalEnv
[16:17:43.167] Capture standard output: TRUE
[16:17:43.167] Capture condition classes: <none>
[16:17:43.167] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:43.167] Packages: <none>
[16:17:43.167] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:17:43.167] Resolved: TRUE
[16:17:43.167] Value: <not collected>
[16:17:43.167] Conditions captured: <none>
[16:17:43.167] Early signaling: FALSE
[16:17:43.167] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:43.167] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:43.179] Chunk #1 of 2 ... DONE
[16:17:43.179] Chunk #2 of 2 ...
[16:17:43.179]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:43.179]  - seeds: [1] <seeds>
[16:17:43.180]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.180] getGlobalsAndPackages() ...
[16:17:43.180] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.180] Resolving globals: FALSE
[16:17:43.180] Tweak future expression to call with '...' arguments ...
[16:17:43.181] {
[16:17:43.181]     do.call(function(...) {
[16:17:43.181]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.181]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:43.181]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.181]             on.exit(options(oopts), add = TRUE)
[16:17:43.181]         }
[16:17:43.181]         {
[16:17:43.181]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:43.181]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.181]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:43.181]                   envir = globalenv(), inherits = FALSE)
[16:17:43.181]                 ...future.FUN(...future.X_jj, ...)
[16:17:43.181]             })
[16:17:43.181]         }
[16:17:43.181]     }, args = future.call.arguments)
[16:17:43.181] }
[16:17:43.181] Tweak future expression to call with '...' arguments ... DONE
[16:17:43.182] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.182] 
[16:17:43.182] getGlobalsAndPackages() ... DONE
[16:17:43.183] run() for ‘Future’ ...
[16:17:43.183] - state: ‘created’
[16:17:43.183] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:43.188] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:43.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:43.188]   - Field: ‘label’
[16:17:43.189]   - Field: ‘local’
[16:17:43.189]   - Field: ‘owner’
[16:17:43.189]   - Field: ‘envir’
[16:17:43.189]   - Field: ‘workers’
[16:17:43.189]   - Field: ‘packages’
[16:17:43.190]   - Field: ‘gc’
[16:17:43.190]   - Field: ‘job’
[16:17:43.190]   - Field: ‘conditions’
[16:17:43.190]   - Field: ‘expr’
[16:17:43.190]   - Field: ‘uuid’
[16:17:43.190]   - Field: ‘seed’
[16:17:43.190]   - Field: ‘version’
[16:17:43.191]   - Field: ‘result’
[16:17:43.191]   - Field: ‘asynchronous’
[16:17:43.191]   - Field: ‘calls’
[16:17:43.191]   - Field: ‘globals’
[16:17:43.191]   - Field: ‘stdout’
[16:17:43.191]   - Field: ‘earlySignal’
[16:17:43.191]   - Field: ‘lazy’
[16:17:43.191]   - Field: ‘state’
[16:17:43.192] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:43.192] - Launch lazy future ...
[16:17:43.192] Packages needed by the future expression (n = 0): <none>
[16:17:43.192] Packages needed by future strategies (n = 0): <none>
[16:17:43.193] {
[16:17:43.193]     {
[16:17:43.193]         {
[16:17:43.193]             ...future.startTime <- base::Sys.time()
[16:17:43.193]             {
[16:17:43.193]                 {
[16:17:43.193]                   {
[16:17:43.193]                     {
[16:17:43.193]                       base::local({
[16:17:43.193]                         has_future <- base::requireNamespace("future", 
[16:17:43.193]                           quietly = TRUE)
[16:17:43.193]                         if (has_future) {
[16:17:43.193]                           ns <- base::getNamespace("future")
[16:17:43.193]                           version <- ns[[".package"]][["version"]]
[16:17:43.193]                           if (is.null(version)) 
[16:17:43.193]                             version <- utils::packageVersion("future")
[16:17:43.193]                         }
[16:17:43.193]                         else {
[16:17:43.193]                           version <- NULL
[16:17:43.193]                         }
[16:17:43.193]                         if (!has_future || version < "1.8.0") {
[16:17:43.193]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:43.193]                             "", base::R.version$version.string), 
[16:17:43.193]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:43.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:43.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:43.193]                               "release", "version")], collapse = " "), 
[16:17:43.193]                             hostname = base::Sys.info()[["nodename"]])
[16:17:43.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:43.193]                             info)
[16:17:43.193]                           info <- base::paste(info, collapse = "; ")
[16:17:43.193]                           if (!has_future) {
[16:17:43.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:43.193]                               info)
[16:17:43.193]                           }
[16:17:43.193]                           else {
[16:17:43.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:43.193]                               info, version)
[16:17:43.193]                           }
[16:17:43.193]                           base::stop(msg)
[16:17:43.193]                         }
[16:17:43.193]                       })
[16:17:43.193]                     }
[16:17:43.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:43.193]                     base::options(mc.cores = 1L)
[16:17:43.193]                   }
[16:17:43.193]                   ...future.strategy.old <- future::plan("list")
[16:17:43.193]                   options(future.plan = NULL)
[16:17:43.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:43.193]                 }
[16:17:43.193]                 ...future.workdir <- getwd()
[16:17:43.193]             }
[16:17:43.193]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:43.193]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:43.193]         }
[16:17:43.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:43.193]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:43.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:43.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:43.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:43.193]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:43.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:43.193]             base::names(...future.oldOptions))
[16:17:43.193]     }
[16:17:43.193]     if (FALSE) {
[16:17:43.193]     }
[16:17:43.193]     else {
[16:17:43.193]         if (TRUE) {
[16:17:43.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:43.193]                 open = "w")
[16:17:43.193]         }
[16:17:43.193]         else {
[16:17:43.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:43.193]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:43.193]         }
[16:17:43.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:43.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:43.193]             base::sink(type = "output", split = FALSE)
[16:17:43.193]             base::close(...future.stdout)
[16:17:43.193]         }, add = TRUE)
[16:17:43.193]     }
[16:17:43.193]     ...future.frame <- base::sys.nframe()
[16:17:43.193]     ...future.conditions <- base::list()
[16:17:43.193]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:43.193]     if (FALSE) {
[16:17:43.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:43.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:43.193]     }
[16:17:43.193]     ...future.result <- base::tryCatch({
[16:17:43.193]         base::withCallingHandlers({
[16:17:43.193]             ...future.value <- base::withVisible(base::local({
[16:17:43.193]                 withCallingHandlers({
[16:17:43.193]                   {
[16:17:43.193]                     do.call(function(...) {
[16:17:43.193]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.193]                       if (!identical(...future.globals.maxSize.org, 
[16:17:43.193]                         ...future.globals.maxSize)) {
[16:17:43.193]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.193]                         on.exit(options(oopts), add = TRUE)
[16:17:43.193]                       }
[16:17:43.193]                       {
[16:17:43.193]                         lapply(seq_along(...future.elements_ii), 
[16:17:43.193]                           FUN = function(jj) {
[16:17:43.193]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.193]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:43.193]                               envir = globalenv(), inherits = FALSE)
[16:17:43.193]                             ...future.FUN(...future.X_jj, ...)
[16:17:43.193]                           })
[16:17:43.193]                       }
[16:17:43.193]                     }, args = future.call.arguments)
[16:17:43.193]                   }
[16:17:43.193]                 }, immediateCondition = function(cond) {
[16:17:43.193]                   save_rds <- function (object, pathname, ...) 
[16:17:43.193]                   {
[16:17:43.193]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:43.193]                     if (file_test("-f", pathname_tmp)) {
[16:17:43.193]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.193]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:43.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.193]                         fi_tmp[["mtime"]])
[16:17:43.193]                     }
[16:17:43.193]                     tryCatch({
[16:17:43.193]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:43.193]                     }, error = function(ex) {
[16:17:43.193]                       msg <- conditionMessage(ex)
[16:17:43.193]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.193]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:43.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.193]                         fi_tmp[["mtime"]], msg)
[16:17:43.193]                       ex$message <- msg
[16:17:43.193]                       stop(ex)
[16:17:43.193]                     })
[16:17:43.193]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:43.193]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:43.193]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:43.193]                       fi_tmp <- file.info(pathname_tmp)
[16:17:43.193]                       fi <- file.info(pathname)
[16:17:43.193]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:43.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:43.193]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:43.193]                         fi[["size"]], fi[["mtime"]])
[16:17:43.193]                       stop(msg)
[16:17:43.193]                     }
[16:17:43.193]                     invisible(pathname)
[16:17:43.193]                   }
[16:17:43.193]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:43.193]                     rootPath = tempdir()) 
[16:17:43.193]                   {
[16:17:43.193]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:43.193]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:43.193]                       tmpdir = path, fileext = ".rds")
[16:17:43.193]                     save_rds(obj, file)
[16:17:43.193]                   }
[16:17:43.193]                   saveImmediateCondition(cond, path = "/tmp/RtmpMCo32a/.future/immediateConditions")
[16:17:43.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.193]                   {
[16:17:43.193]                     inherits <- base::inherits
[16:17:43.193]                     invokeRestart <- base::invokeRestart
[16:17:43.193]                     is.null <- base::is.null
[16:17:43.193]                     muffled <- FALSE
[16:17:43.193]                     if (inherits(cond, "message")) {
[16:17:43.193]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:43.193]                       if (muffled) 
[16:17:43.193]                         invokeRestart("muffleMessage")
[16:17:43.193]                     }
[16:17:43.193]                     else if (inherits(cond, "warning")) {
[16:17:43.193]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:43.193]                       if (muffled) 
[16:17:43.193]                         invokeRestart("muffleWarning")
[16:17:43.193]                     }
[16:17:43.193]                     else if (inherits(cond, "condition")) {
[16:17:43.193]                       if (!is.null(pattern)) {
[16:17:43.193]                         computeRestarts <- base::computeRestarts
[16:17:43.193]                         grepl <- base::grepl
[16:17:43.193]                         restarts <- computeRestarts(cond)
[16:17:43.193]                         for (restart in restarts) {
[16:17:43.193]                           name <- restart$name
[16:17:43.193]                           if (is.null(name)) 
[16:17:43.193]                             next
[16:17:43.193]                           if (!grepl(pattern, name)) 
[16:17:43.193]                             next
[16:17:43.193]                           invokeRestart(restart)
[16:17:43.193]                           muffled <- TRUE
[16:17:43.193]                           break
[16:17:43.193]                         }
[16:17:43.193]                       }
[16:17:43.193]                     }
[16:17:43.193]                     invisible(muffled)
[16:17:43.193]                   }
[16:17:43.193]                   muffleCondition(cond)
[16:17:43.193]                 })
[16:17:43.193]             }))
[16:17:43.193]             future::FutureResult(value = ...future.value$value, 
[16:17:43.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.193]                   ...future.rng), globalenv = if (FALSE) 
[16:17:43.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:43.193]                     ...future.globalenv.names))
[16:17:43.193]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:43.193]         }, condition = base::local({
[16:17:43.193]             c <- base::c
[16:17:43.193]             inherits <- base::inherits
[16:17:43.193]             invokeRestart <- base::invokeRestart
[16:17:43.193]             length <- base::length
[16:17:43.193]             list <- base::list
[16:17:43.193]             seq.int <- base::seq.int
[16:17:43.193]             signalCondition <- base::signalCondition
[16:17:43.193]             sys.calls <- base::sys.calls
[16:17:43.193]             `[[` <- base::`[[`
[16:17:43.193]             `+` <- base::`+`
[16:17:43.193]             `<<-` <- base::`<<-`
[16:17:43.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:43.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:43.193]                   3L)]
[16:17:43.193]             }
[16:17:43.193]             function(cond) {
[16:17:43.193]                 is_error <- inherits(cond, "error")
[16:17:43.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:43.193]                   NULL)
[16:17:43.193]                 if (is_error) {
[16:17:43.193]                   sessionInformation <- function() {
[16:17:43.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:43.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:43.193]                       search = base::search(), system = base::Sys.info())
[16:17:43.193]                   }
[16:17:43.193]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:43.193]                     cond$call), session = sessionInformation(), 
[16:17:43.193]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:43.193]                   signalCondition(cond)
[16:17:43.193]                 }
[16:17:43.193]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:17:43.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:43.193]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:43.193]                   if (TRUE && !signal) {
[16:17:43.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.193]                     {
[16:17:43.193]                       inherits <- base::inherits
[16:17:43.193]                       invokeRestart <- base::invokeRestart
[16:17:43.193]                       is.null <- base::is.null
[16:17:43.193]                       muffled <- FALSE
[16:17:43.193]                       if (inherits(cond, "message")) {
[16:17:43.193]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.193]                         if (muffled) 
[16:17:43.193]                           invokeRestart("muffleMessage")
[16:17:43.193]                       }
[16:17:43.193]                       else if (inherits(cond, "warning")) {
[16:17:43.193]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.193]                         if (muffled) 
[16:17:43.193]                           invokeRestart("muffleWarning")
[16:17:43.193]                       }
[16:17:43.193]                       else if (inherits(cond, "condition")) {
[16:17:43.193]                         if (!is.null(pattern)) {
[16:17:43.193]                           computeRestarts <- base::computeRestarts
[16:17:43.193]                           grepl <- base::grepl
[16:17:43.193]                           restarts <- computeRestarts(cond)
[16:17:43.193]                           for (restart in restarts) {
[16:17:43.193]                             name <- restart$name
[16:17:43.193]                             if (is.null(name)) 
[16:17:43.193]                               next
[16:17:43.193]                             if (!grepl(pattern, name)) 
[16:17:43.193]                               next
[16:17:43.193]                             invokeRestart(restart)
[16:17:43.193]                             muffled <- TRUE
[16:17:43.193]                             break
[16:17:43.193]                           }
[16:17:43.193]                         }
[16:17:43.193]                       }
[16:17:43.193]                       invisible(muffled)
[16:17:43.193]                     }
[16:17:43.193]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.193]                   }
[16:17:43.193]                 }
[16:17:43.193]                 else {
[16:17:43.193]                   if (TRUE) {
[16:17:43.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.193]                     {
[16:17:43.193]                       inherits <- base::inherits
[16:17:43.193]                       invokeRestart <- base::invokeRestart
[16:17:43.193]                       is.null <- base::is.null
[16:17:43.193]                       muffled <- FALSE
[16:17:43.193]                       if (inherits(cond, "message")) {
[16:17:43.193]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.193]                         if (muffled) 
[16:17:43.193]                           invokeRestart("muffleMessage")
[16:17:43.193]                       }
[16:17:43.193]                       else if (inherits(cond, "warning")) {
[16:17:43.193]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.193]                         if (muffled) 
[16:17:43.193]                           invokeRestart("muffleWarning")
[16:17:43.193]                       }
[16:17:43.193]                       else if (inherits(cond, "condition")) {
[16:17:43.193]                         if (!is.null(pattern)) {
[16:17:43.193]                           computeRestarts <- base::computeRestarts
[16:17:43.193]                           grepl <- base::grepl
[16:17:43.193]                           restarts <- computeRestarts(cond)
[16:17:43.193]                           for (restart in restarts) {
[16:17:43.193]                             name <- restart$name
[16:17:43.193]                             if (is.null(name)) 
[16:17:43.193]                               next
[16:17:43.193]                             if (!grepl(pattern, name)) 
[16:17:43.193]                               next
[16:17:43.193]                             invokeRestart(restart)
[16:17:43.193]                             muffled <- TRUE
[16:17:43.193]                             break
[16:17:43.193]                           }
[16:17:43.193]                         }
[16:17:43.193]                       }
[16:17:43.193]                       invisible(muffled)
[16:17:43.193]                     }
[16:17:43.193]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.193]                   }
[16:17:43.193]                 }
[16:17:43.193]             }
[16:17:43.193]         }))
[16:17:43.193]     }, error = function(ex) {
[16:17:43.193]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:43.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.193]                 ...future.rng), started = ...future.startTime, 
[16:17:43.193]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:43.193]             version = "1.8"), class = "FutureResult")
[16:17:43.193]     }, finally = {
[16:17:43.193]         if (!identical(...future.workdir, getwd())) 
[16:17:43.193]             setwd(...future.workdir)
[16:17:43.193]         {
[16:17:43.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:43.193]                 ...future.oldOptions$nwarnings <- NULL
[16:17:43.193]             }
[16:17:43.193]             base::options(...future.oldOptions)
[16:17:43.193]             if (.Platform$OS.type == "windows") {
[16:17:43.193]                 old_names <- names(...future.oldEnvVars)
[16:17:43.193]                 envs <- base::Sys.getenv()
[16:17:43.193]                 names <- names(envs)
[16:17:43.193]                 common <- intersect(names, old_names)
[16:17:43.193]                 added <- setdiff(names, old_names)
[16:17:43.193]                 removed <- setdiff(old_names, names)
[16:17:43.193]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:43.193]                   envs[common]]
[16:17:43.193]                 NAMES <- toupper(changed)
[16:17:43.193]                 args <- list()
[16:17:43.193]                 for (kk in seq_along(NAMES)) {
[16:17:43.193]                   name <- changed[[kk]]
[16:17:43.193]                   NAME <- NAMES[[kk]]
[16:17:43.193]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.193]                     next
[16:17:43.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.193]                 }
[16:17:43.193]                 NAMES <- toupper(added)
[16:17:43.193]                 for (kk in seq_along(NAMES)) {
[16:17:43.193]                   name <- added[[kk]]
[16:17:43.193]                   NAME <- NAMES[[kk]]
[16:17:43.193]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.193]                     next
[16:17:43.193]                   args[[name]] <- ""
[16:17:43.193]                 }
[16:17:43.193]                 NAMES <- toupper(removed)
[16:17:43.193]                 for (kk in seq_along(NAMES)) {
[16:17:43.193]                   name <- removed[[kk]]
[16:17:43.193]                   NAME <- NAMES[[kk]]
[16:17:43.193]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.193]                     next
[16:17:43.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.193]                 }
[16:17:43.193]                 if (length(args) > 0) 
[16:17:43.193]                   base::do.call(base::Sys.setenv, args = args)
[16:17:43.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:43.193]             }
[16:17:43.193]             else {
[16:17:43.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:43.193]             }
[16:17:43.193]             {
[16:17:43.193]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:43.193]                   0L) {
[16:17:43.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:43.193]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:43.193]                   base::options(opts)
[16:17:43.193]                 }
[16:17:43.193]                 {
[16:17:43.193]                   {
[16:17:43.193]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:43.193]                     NULL
[16:17:43.193]                   }
[16:17:43.193]                   options(future.plan = NULL)
[16:17:43.193]                   if (is.na(NA_character_)) 
[16:17:43.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:43.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:43.193]                     .init = FALSE)
[16:17:43.193]                 }
[16:17:43.193]             }
[16:17:43.193]         }
[16:17:43.193]     })
[16:17:43.193]     if (TRUE) {
[16:17:43.193]         base::sink(type = "output", split = FALSE)
[16:17:43.193]         if (TRUE) {
[16:17:43.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:43.193]         }
[16:17:43.193]         else {
[16:17:43.193]             ...future.result["stdout"] <- base::list(NULL)
[16:17:43.193]         }
[16:17:43.193]         base::close(...future.stdout)
[16:17:43.193]         ...future.stdout <- NULL
[16:17:43.193]     }
[16:17:43.193]     ...future.result$conditions <- ...future.conditions
[16:17:43.193]     ...future.result$finished <- base::Sys.time()
[16:17:43.193]     ...future.result
[16:17:43.193] }
[16:17:43.196] assign_globals() ...
[16:17:43.196] List of 5
[16:17:43.196]  $ future.call.arguments    : list()
[16:17:43.196]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.196]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:17:43.196]  $ ...future.elements_ii    :List of 1
[16:17:43.196]   ..$ : int [1:2] 2 4
[16:17:43.196]  $ ...future.seeds_ii       :List of 1
[16:17:43.196]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:17:43.196]  $ ...future.globals.maxSize: num Inf
[16:17:43.196]  - attr(*, "resolved")= logi FALSE
[16:17:43.196]  - attr(*, "total_size")= num NA
[16:17:43.196]  - attr(*, "where")=List of 5
[16:17:43.196]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:43.196]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:43.196]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:43.196]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:43.196]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:43.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.196]  - attr(*, "already-done")= logi TRUE
[16:17:43.203] - copied ‘future.call.arguments’ to environment
[16:17:43.204] - copied ‘...future.FUN’ to environment
[16:17:43.204] - copied ‘...future.elements_ii’ to environment
[16:17:43.204] - copied ‘...future.seeds_ii’ to environment
[16:17:43.204] - copied ‘...future.globals.maxSize’ to environment
[16:17:43.204] assign_globals() ... done
[16:17:43.204] requestCore(): workers = 2
[16:17:43.206] MulticoreFuture started
[16:17:43.207] - Launch lazy future ... done
[16:17:43.207] run() for ‘MulticoreFuture’ ... done
[16:17:43.207] Created future:
[16:17:43.207] plan(): Setting new future strategy stack:
[16:17:43.208] List of future strategies:
[16:17:43.208] 1. sequential:
[16:17:43.208]    - args: function (..., envir = parent.frame())
[16:17:43.208]    - tweaked: FALSE
[16:17:43.208]    - call: NULL
[16:17:43.208] plan(): nbrOfWorkers() = 1
[16:17:43.210] plan(): Setting new future strategy stack:
[16:17:43.211] List of future strategies:
[16:17:43.211] 1. multicore:
[16:17:43.211]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:43.211]    - tweaked: FALSE
[16:17:43.211]    - call: plan(strategy)
[16:17:43.207] MulticoreFuture:
[16:17:43.207] Label: ‘future_apply-2’
[16:17:43.207] Expression:
[16:17:43.207] {
[16:17:43.207]     do.call(function(...) {
[16:17:43.207]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.207]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:43.207]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.207]             on.exit(options(oopts), add = TRUE)
[16:17:43.207]         }
[16:17:43.207]         {
[16:17:43.207]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:43.207]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.207]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:43.207]                   envir = globalenv(), inherits = FALSE)
[16:17:43.207]                 ...future.FUN(...future.X_jj, ...)
[16:17:43.207]             })
[16:17:43.207]         }
[16:17:43.207]     }, args = future.call.arguments)
[16:17:43.207] }
[16:17:43.207] Lazy evaluation: FALSE
[16:17:43.207] Asynchronous evaluation: TRUE
[16:17:43.207] Local evaluation: TRUE
[16:17:43.207] Environment: R_GlobalEnv
[16:17:43.207] Capture standard output: TRUE
[16:17:43.207] Capture condition classes: <none>
[16:17:43.207] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:43.207] Packages: <none>
[16:17:43.207] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:17:43.207] Resolved: FALSE
[16:17:43.207] Value: <not collected>
[16:17:43.207] Conditions captured: <none>
[16:17:43.207] Early signaling: FALSE
[16:17:43.207] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:43.207] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:43.220] Chunk #2 of 2 ... DONE
[16:17:43.221] Launching 2 futures (chunks) ... DONE
[16:17:43.221] Resolving 2 futures (chunks) ...
[16:17:43.221] resolve() on list ...
[16:17:43.221] plan(): nbrOfWorkers() = 2
[16:17:43.221]  recursive: 0
[16:17:43.221]  length: 2
[16:17:43.221] 
[16:17:43.222] Future #1
[16:17:43.224] result() for MulticoreFuture ...
[16:17:43.226] result() for MulticoreFuture ...
[16:17:43.226] result() for MulticoreFuture ... done
[16:17:43.226] result() for MulticoreFuture ... done
[16:17:43.226] result() for MulticoreFuture ...
[16:17:43.227] result() for MulticoreFuture ... done
[16:17:43.227] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:43.227] - nx: 2
[16:17:43.228] - relay: TRUE
[16:17:43.228] - stdout: TRUE
[16:17:43.228] - signal: TRUE
[16:17:43.228] - resignal: FALSE
[16:17:43.229] - force: TRUE
[16:17:43.229] - relayed: [n=2] FALSE, FALSE
[16:17:43.229] - queued futures: [n=2] FALSE, FALSE
[16:17:43.229]  - until=1
[16:17:43.230]  - relaying element #1
[16:17:43.230] result() for MulticoreFuture ...
[16:17:43.230] result() for MulticoreFuture ... done
[16:17:43.231] result() for MulticoreFuture ...
[16:17:43.231] result() for MulticoreFuture ... done
[16:17:43.231] result() for MulticoreFuture ...
[16:17:43.231] result() for MulticoreFuture ... done
[16:17:43.231] result() for MulticoreFuture ...
[16:17:43.232] result() for MulticoreFuture ... done
[16:17:43.232] - relayed: [n=2] TRUE, FALSE
[16:17:43.232] - queued futures: [n=2] TRUE, FALSE
[16:17:43.233] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:43.233]  length: 1 (resolved future 1)
[16:17:43.233] Future #2
[16:17:43.234] result() for MulticoreFuture ...
[16:17:43.234] result() for MulticoreFuture ...
[16:17:43.235] result() for MulticoreFuture ... done
[16:17:43.235] result() for MulticoreFuture ... done
[16:17:43.235] result() for MulticoreFuture ...
[16:17:43.235] result() for MulticoreFuture ... done
[16:17:43.235] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:43.236] - nx: 2
[16:17:43.236] - relay: TRUE
[16:17:43.236] - stdout: TRUE
[16:17:43.236] - signal: TRUE
[16:17:43.236] - resignal: FALSE
[16:17:43.236] - force: TRUE
[16:17:43.236] - relayed: [n=2] TRUE, FALSE
[16:17:43.236] - queued futures: [n=2] TRUE, FALSE
[16:17:43.236]  - until=2
[16:17:43.237]  - relaying element #2
[16:17:43.237] result() for MulticoreFuture ...
[16:17:43.237] result() for MulticoreFuture ... done
[16:17:43.237] result() for MulticoreFuture ...
[16:17:43.237] result() for MulticoreFuture ... done
[16:17:43.237] result() for MulticoreFuture ...
[16:17:43.238] result() for MulticoreFuture ... done
[16:17:43.238] result() for MulticoreFuture ...
[16:17:43.238] result() for MulticoreFuture ... done
[16:17:43.238] - relayed: [n=2] TRUE, TRUE
[16:17:43.238] - queued futures: [n=2] TRUE, TRUE
[16:17:43.238] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:43.238]  length: 0 (resolved future 2)
[16:17:43.238] Relaying remaining futures
[16:17:43.238] signalConditionsASAP(NULL, pos=0) ...
[16:17:43.239] - nx: 2
[16:17:43.239] - relay: TRUE
[16:17:43.239] - stdout: TRUE
[16:17:43.239] - signal: TRUE
[16:17:43.239] - resignal: FALSE
[16:17:43.239] - force: TRUE
[16:17:43.239] - relayed: [n=2] TRUE, TRUE
[16:17:43.239] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:43.239] - relayed: [n=2] TRUE, TRUE
[16:17:43.240] - queued futures: [n=2] TRUE, TRUE
[16:17:43.240] signalConditionsASAP(NULL, pos=0) ... done
[16:17:43.240] resolve() on list ... DONE
[16:17:43.240] result() for MulticoreFuture ...
[16:17:43.240] result() for MulticoreFuture ... done
[16:17:43.240] result() for MulticoreFuture ...
[16:17:43.240] result() for MulticoreFuture ... done
[16:17:43.240] result() for MulticoreFuture ...
[16:17:43.240] result() for MulticoreFuture ... done
[16:17:43.241] result() for MulticoreFuture ...
[16:17:43.241] result() for MulticoreFuture ... done
[16:17:43.241]  - Number of value chunks collected: 2
[16:17:43.241] Resolving 2 futures (chunks) ... DONE
[16:17:43.241] Reducing values from 2 chunks ...
[16:17:43.241]  - Number of values collected after concatenation: 2
[16:17:43.241]  - Number of values expected: 2
[16:17:43.241] Reducing values from 2 chunks ... DONE
[16:17:43.241] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:17:43.242] plan(): Setting new future strategy stack:
[16:17:43.242] List of future strategies:
[16:17:43.242] 1. sequential:
[16:17:43.242]    - args: function (..., envir = parent.frame())
[16:17:43.242]    - tweaked: FALSE
[16:17:43.242]    - call: plan(sequential)
[16:17:43.242] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:17:43.243] plan(): Setting new future strategy stack:
[16:17:43.243] List of future strategies:
[16:17:43.243] 1. multisession:
[16:17:43.243]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:43.243]    - tweaked: FALSE
[16:17:43.243]    - call: plan(strategy)
[16:17:43.243] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:17:43.243] multisession:
[16:17:43.243] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:43.243] - tweaked: FALSE
[16:17:43.243] - call: plan(strategy)
[16:17:43.250] getGlobalsAndPackages() ...
[16:17:43.250] Not searching for globals
[16:17:43.250] - globals: [0] <none>
[16:17:43.250] getGlobalsAndPackages() ... DONE
[16:17:43.251] [local output] makeClusterPSOCK() ...
[16:17:43.293] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:17:43.294] [local output] Base port: 11132
[16:17:43.295] [local output] Getting setup options for 2 cluster nodes ...
[16:17:43.295] [local output]  - Node 1 of 2 ...
[16:17:43.295] [local output] localMachine=TRUE => revtunnel=FALSE

[16:17:43.296] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMCo32a/worker.rank=1.parallelly.parent=67777.108c161ca493d.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpMCo32a/worker.rank=1.parallelly.parent=67777.108c161ca493d.pid")'’
[16:17:43.485] - Possible to infer worker's PID: TRUE
[16:17:43.485] [local output] Rscript port: 11132

[16:17:43.486] [local output]  - Node 2 of 2 ...
[16:17:43.486] [local output] localMachine=TRUE => revtunnel=FALSE

[16:17:43.487] [local output] Rscript port: 11132

[16:17:43.487] [local output] Getting setup options for 2 cluster nodes ... done
[16:17:43.487] [local output]  - Parallel setup requested for some PSOCK nodes
[16:17:43.487] [local output] Setting up PSOCK nodes in parallel
[16:17:43.488] List of 36
[16:17:43.488]  $ worker          : chr "localhost"
[16:17:43.488]   ..- attr(*, "localhost")= logi TRUE
[16:17:43.488]  $ master          : chr "localhost"
[16:17:43.488]  $ port            : int 11132
[16:17:43.488]  $ connectTimeout  : num 120
[16:17:43.488]  $ timeout         : num 2592000
[16:17:43.488]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:17:43.488]  $ homogeneous     : logi TRUE
[16:17:43.488]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:17:43.488]  $ rscript_envs    : NULL
[16:17:43.488]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:17:43.488]  $ rscript_startup : NULL
[16:17:43.488]  $ rscript_sh      : chr "sh"
[16:17:43.488]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:17:43.488]  $ methods         : logi TRUE
[16:17:43.488]  $ socketOptions   : chr "no-delay"
[16:17:43.488]  $ useXDR          : logi FALSE
[16:17:43.488]  $ outfile         : chr "/dev/null"
[16:17:43.488]  $ renice          : int NA
[16:17:43.488]  $ rshcmd          : NULL
[16:17:43.488]  $ user            : chr(0) 
[16:17:43.488]  $ revtunnel       : logi FALSE
[16:17:43.488]  $ rshlogfile      : NULL
[16:17:43.488]  $ rshopts         : chr(0) 
[16:17:43.488]  $ rank            : int 1
[16:17:43.488]  $ manual          : logi FALSE
[16:17:43.488]  $ dryrun          : logi FALSE
[16:17:43.488]  $ quiet           : logi FALSE
[16:17:43.488]  $ setup_strategy  : chr "parallel"
[16:17:43.488]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:17:43.488]  $ pidfile         : chr "/tmp/RtmpMCo32a/worker.rank=1.parallelly.parent=67777.108c161ca493d.pid"
[16:17:43.488]  $ rshcmd_label    : NULL
[16:17:43.488]  $ rsh_call        : NULL
[16:17:43.488]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:17:43.488]  $ localMachine    : logi TRUE
[16:17:43.488]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:17:43.488]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:17:43.488]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:17:43.488]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:17:43.488]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:17:43.488]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:17:43.488]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:17:43.488]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:17:43.488]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:17:43.488]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:17:43.488]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:17:43.488]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:17:43.488]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:17:43.488]  $ arguments       :List of 28
[16:17:43.488]   ..$ worker          : chr "localhost"
[16:17:43.488]   ..$ master          : NULL
[16:17:43.488]   ..$ port            : int 11132
[16:17:43.488]   ..$ connectTimeout  : num 120
[16:17:43.488]   ..$ timeout         : num 2592000
[16:17:43.488]   ..$ rscript         : NULL
[16:17:43.488]   ..$ homogeneous     : NULL
[16:17:43.488]   ..$ rscript_args    : NULL
[16:17:43.488]   ..$ rscript_envs    : NULL
[16:17:43.488]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:17:43.488]   ..$ rscript_startup : NULL
[16:17:43.488]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:17:43.488]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:17:43.488]   ..$ methods         : logi TRUE
[16:17:43.488]   ..$ socketOptions   : chr "no-delay"
[16:17:43.488]   ..$ useXDR          : logi FALSE
[16:17:43.488]   ..$ outfile         : chr "/dev/null"
[16:17:43.488]   ..$ renice          : int NA
[16:17:43.488]   ..$ rshcmd          : NULL
[16:17:43.488]   ..$ user            : NULL
[16:17:43.488]   ..$ revtunnel       : logi NA
[16:17:43.488]   ..$ rshlogfile      : NULL
[16:17:43.488]   ..$ rshopts         : NULL
[16:17:43.488]   ..$ rank            : int 1
[16:17:43.488]   ..$ manual          : logi FALSE
[16:17:43.488]   ..$ dryrun          : logi FALSE
[16:17:43.488]   ..$ quiet           : logi FALSE
[16:17:43.488]   ..$ setup_strategy  : chr "parallel"
[16:17:43.488]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:17:43.505] [local output] System call to launch all workers:
[16:17:43.505] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMCo32a/worker.rank=1.parallelly.parent=67777.108c161ca493d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11132 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:17:43.505] [local output] Starting PSOCK main server
[16:17:43.510] [local output] Workers launched
[16:17:43.511] [local output] Waiting for workers to connect back
[16:17:43.511]  - [local output] 0 workers out of 2 ready
[16:17:43.750]  - [local output] 0 workers out of 2 ready
[16:17:43.751]  - [local output] 1 workers out of 2 ready
[16:17:43.753]  - [local output] 1 workers out of 2 ready
[16:17:43.754]  - [local output] 2 workers out of 2 ready
[16:17:43.754] [local output] Launching of workers completed
[16:17:43.754] [local output] Collecting session information from workers
[16:17:43.755] [local output]  - Worker #1 of 2
[16:17:43.755] [local output]  - Worker #2 of 2
[16:17:43.756] [local output] makeClusterPSOCK() ... done
[16:17:43.767] Packages needed by the future expression (n = 0): <none>
[16:17:43.767] Packages needed by future strategies (n = 0): <none>
[16:17:43.768] {
[16:17:43.768]     {
[16:17:43.768]         {
[16:17:43.768]             ...future.startTime <- base::Sys.time()
[16:17:43.768]             {
[16:17:43.768]                 {
[16:17:43.768]                   {
[16:17:43.768]                     {
[16:17:43.768]                       base::local({
[16:17:43.768]                         has_future <- base::requireNamespace("future", 
[16:17:43.768]                           quietly = TRUE)
[16:17:43.768]                         if (has_future) {
[16:17:43.768]                           ns <- base::getNamespace("future")
[16:17:43.768]                           version <- ns[[".package"]][["version"]]
[16:17:43.768]                           if (is.null(version)) 
[16:17:43.768]                             version <- utils::packageVersion("future")
[16:17:43.768]                         }
[16:17:43.768]                         else {
[16:17:43.768]                           version <- NULL
[16:17:43.768]                         }
[16:17:43.768]                         if (!has_future || version < "1.8.0") {
[16:17:43.768]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:43.768]                             "", base::R.version$version.string), 
[16:17:43.768]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:43.768]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:43.768]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:43.768]                               "release", "version")], collapse = " "), 
[16:17:43.768]                             hostname = base::Sys.info()[["nodename"]])
[16:17:43.768]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:43.768]                             info)
[16:17:43.768]                           info <- base::paste(info, collapse = "; ")
[16:17:43.768]                           if (!has_future) {
[16:17:43.768]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:43.768]                               info)
[16:17:43.768]                           }
[16:17:43.768]                           else {
[16:17:43.768]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:43.768]                               info, version)
[16:17:43.768]                           }
[16:17:43.768]                           base::stop(msg)
[16:17:43.768]                         }
[16:17:43.768]                       })
[16:17:43.768]                     }
[16:17:43.768]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:43.768]                     base::options(mc.cores = 1L)
[16:17:43.768]                   }
[16:17:43.768]                   ...future.strategy.old <- future::plan("list")
[16:17:43.768]                   options(future.plan = NULL)
[16:17:43.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:43.768]                 }
[16:17:43.768]                 ...future.workdir <- getwd()
[16:17:43.768]             }
[16:17:43.768]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:43.768]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:43.768]         }
[16:17:43.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:43.768]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:43.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:43.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:43.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:43.768]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:43.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:43.768]             base::names(...future.oldOptions))
[16:17:43.768]     }
[16:17:43.768]     if (FALSE) {
[16:17:43.768]     }
[16:17:43.768]     else {
[16:17:43.768]         if (TRUE) {
[16:17:43.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:43.768]                 open = "w")
[16:17:43.768]         }
[16:17:43.768]         else {
[16:17:43.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:43.768]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:43.768]         }
[16:17:43.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:43.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:43.768]             base::sink(type = "output", split = FALSE)
[16:17:43.768]             base::close(...future.stdout)
[16:17:43.768]         }, add = TRUE)
[16:17:43.768]     }
[16:17:43.768]     ...future.frame <- base::sys.nframe()
[16:17:43.768]     ...future.conditions <- base::list()
[16:17:43.768]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:43.768]     if (FALSE) {
[16:17:43.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:43.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:43.768]     }
[16:17:43.768]     ...future.result <- base::tryCatch({
[16:17:43.768]         base::withCallingHandlers({
[16:17:43.768]             ...future.value <- base::withVisible(base::local({
[16:17:43.768]                 ...future.makeSendCondition <- base::local({
[16:17:43.768]                   sendCondition <- NULL
[16:17:43.768]                   function(frame = 1L) {
[16:17:43.768]                     if (is.function(sendCondition)) 
[16:17:43.768]                       return(sendCondition)
[16:17:43.768]                     ns <- getNamespace("parallel")
[16:17:43.768]                     if (exists("sendData", mode = "function", 
[16:17:43.768]                       envir = ns)) {
[16:17:43.768]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:43.768]                         envir = ns)
[16:17:43.768]                       envir <- sys.frame(frame)
[16:17:43.768]                       master <- NULL
[16:17:43.768]                       while (!identical(envir, .GlobalEnv) && 
[16:17:43.768]                         !identical(envir, emptyenv())) {
[16:17:43.768]                         if (exists("master", mode = "list", envir = envir, 
[16:17:43.768]                           inherits = FALSE)) {
[16:17:43.768]                           master <- get("master", mode = "list", 
[16:17:43.768]                             envir = envir, inherits = FALSE)
[16:17:43.768]                           if (inherits(master, c("SOCKnode", 
[16:17:43.768]                             "SOCK0node"))) {
[16:17:43.768]                             sendCondition <<- function(cond) {
[16:17:43.768]                               data <- list(type = "VALUE", value = cond, 
[16:17:43.768]                                 success = TRUE)
[16:17:43.768]                               parallel_sendData(master, data)
[16:17:43.768]                             }
[16:17:43.768]                             return(sendCondition)
[16:17:43.768]                           }
[16:17:43.768]                         }
[16:17:43.768]                         frame <- frame + 1L
[16:17:43.768]                         envir <- sys.frame(frame)
[16:17:43.768]                       }
[16:17:43.768]                     }
[16:17:43.768]                     sendCondition <<- function(cond) NULL
[16:17:43.768]                   }
[16:17:43.768]                 })
[16:17:43.768]                 withCallingHandlers({
[16:17:43.768]                   NA
[16:17:43.768]                 }, immediateCondition = function(cond) {
[16:17:43.768]                   sendCondition <- ...future.makeSendCondition()
[16:17:43.768]                   sendCondition(cond)
[16:17:43.768]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.768]                   {
[16:17:43.768]                     inherits <- base::inherits
[16:17:43.768]                     invokeRestart <- base::invokeRestart
[16:17:43.768]                     is.null <- base::is.null
[16:17:43.768]                     muffled <- FALSE
[16:17:43.768]                     if (inherits(cond, "message")) {
[16:17:43.768]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:43.768]                       if (muffled) 
[16:17:43.768]                         invokeRestart("muffleMessage")
[16:17:43.768]                     }
[16:17:43.768]                     else if (inherits(cond, "warning")) {
[16:17:43.768]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:43.768]                       if (muffled) 
[16:17:43.768]                         invokeRestart("muffleWarning")
[16:17:43.768]                     }
[16:17:43.768]                     else if (inherits(cond, "condition")) {
[16:17:43.768]                       if (!is.null(pattern)) {
[16:17:43.768]                         computeRestarts <- base::computeRestarts
[16:17:43.768]                         grepl <- base::grepl
[16:17:43.768]                         restarts <- computeRestarts(cond)
[16:17:43.768]                         for (restart in restarts) {
[16:17:43.768]                           name <- restart$name
[16:17:43.768]                           if (is.null(name)) 
[16:17:43.768]                             next
[16:17:43.768]                           if (!grepl(pattern, name)) 
[16:17:43.768]                             next
[16:17:43.768]                           invokeRestart(restart)
[16:17:43.768]                           muffled <- TRUE
[16:17:43.768]                           break
[16:17:43.768]                         }
[16:17:43.768]                       }
[16:17:43.768]                     }
[16:17:43.768]                     invisible(muffled)
[16:17:43.768]                   }
[16:17:43.768]                   muffleCondition(cond)
[16:17:43.768]                 })
[16:17:43.768]             }))
[16:17:43.768]             future::FutureResult(value = ...future.value$value, 
[16:17:43.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.768]                   ...future.rng), globalenv = if (FALSE) 
[16:17:43.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:43.768]                     ...future.globalenv.names))
[16:17:43.768]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:43.768]         }, condition = base::local({
[16:17:43.768]             c <- base::c
[16:17:43.768]             inherits <- base::inherits
[16:17:43.768]             invokeRestart <- base::invokeRestart
[16:17:43.768]             length <- base::length
[16:17:43.768]             list <- base::list
[16:17:43.768]             seq.int <- base::seq.int
[16:17:43.768]             signalCondition <- base::signalCondition
[16:17:43.768]             sys.calls <- base::sys.calls
[16:17:43.768]             `[[` <- base::`[[`
[16:17:43.768]             `+` <- base::`+`
[16:17:43.768]             `<<-` <- base::`<<-`
[16:17:43.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:43.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:43.768]                   3L)]
[16:17:43.768]             }
[16:17:43.768]             function(cond) {
[16:17:43.768]                 is_error <- inherits(cond, "error")
[16:17:43.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:43.768]                   NULL)
[16:17:43.768]                 if (is_error) {
[16:17:43.768]                   sessionInformation <- function() {
[16:17:43.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:43.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:43.768]                       search = base::search(), system = base::Sys.info())
[16:17:43.768]                   }
[16:17:43.768]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:43.768]                     cond$call), session = sessionInformation(), 
[16:17:43.768]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:43.768]                   signalCondition(cond)
[16:17:43.768]                 }
[16:17:43.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:43.768]                 "immediateCondition"))) {
[16:17:43.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:43.768]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:43.768]                   if (TRUE && !signal) {
[16:17:43.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.768]                     {
[16:17:43.768]                       inherits <- base::inherits
[16:17:43.768]                       invokeRestart <- base::invokeRestart
[16:17:43.768]                       is.null <- base::is.null
[16:17:43.768]                       muffled <- FALSE
[16:17:43.768]                       if (inherits(cond, "message")) {
[16:17:43.768]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.768]                         if (muffled) 
[16:17:43.768]                           invokeRestart("muffleMessage")
[16:17:43.768]                       }
[16:17:43.768]                       else if (inherits(cond, "warning")) {
[16:17:43.768]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.768]                         if (muffled) 
[16:17:43.768]                           invokeRestart("muffleWarning")
[16:17:43.768]                       }
[16:17:43.768]                       else if (inherits(cond, "condition")) {
[16:17:43.768]                         if (!is.null(pattern)) {
[16:17:43.768]                           computeRestarts <- base::computeRestarts
[16:17:43.768]                           grepl <- base::grepl
[16:17:43.768]                           restarts <- computeRestarts(cond)
[16:17:43.768]                           for (restart in restarts) {
[16:17:43.768]                             name <- restart$name
[16:17:43.768]                             if (is.null(name)) 
[16:17:43.768]                               next
[16:17:43.768]                             if (!grepl(pattern, name)) 
[16:17:43.768]                               next
[16:17:43.768]                             invokeRestart(restart)
[16:17:43.768]                             muffled <- TRUE
[16:17:43.768]                             break
[16:17:43.768]                           }
[16:17:43.768]                         }
[16:17:43.768]                       }
[16:17:43.768]                       invisible(muffled)
[16:17:43.768]                     }
[16:17:43.768]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.768]                   }
[16:17:43.768]                 }
[16:17:43.768]                 else {
[16:17:43.768]                   if (TRUE) {
[16:17:43.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.768]                     {
[16:17:43.768]                       inherits <- base::inherits
[16:17:43.768]                       invokeRestart <- base::invokeRestart
[16:17:43.768]                       is.null <- base::is.null
[16:17:43.768]                       muffled <- FALSE
[16:17:43.768]                       if (inherits(cond, "message")) {
[16:17:43.768]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.768]                         if (muffled) 
[16:17:43.768]                           invokeRestart("muffleMessage")
[16:17:43.768]                       }
[16:17:43.768]                       else if (inherits(cond, "warning")) {
[16:17:43.768]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.768]                         if (muffled) 
[16:17:43.768]                           invokeRestart("muffleWarning")
[16:17:43.768]                       }
[16:17:43.768]                       else if (inherits(cond, "condition")) {
[16:17:43.768]                         if (!is.null(pattern)) {
[16:17:43.768]                           computeRestarts <- base::computeRestarts
[16:17:43.768]                           grepl <- base::grepl
[16:17:43.768]                           restarts <- computeRestarts(cond)
[16:17:43.768]                           for (restart in restarts) {
[16:17:43.768]                             name <- restart$name
[16:17:43.768]                             if (is.null(name)) 
[16:17:43.768]                               next
[16:17:43.768]                             if (!grepl(pattern, name)) 
[16:17:43.768]                               next
[16:17:43.768]                             invokeRestart(restart)
[16:17:43.768]                             muffled <- TRUE
[16:17:43.768]                             break
[16:17:43.768]                           }
[16:17:43.768]                         }
[16:17:43.768]                       }
[16:17:43.768]                       invisible(muffled)
[16:17:43.768]                     }
[16:17:43.768]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.768]                   }
[16:17:43.768]                 }
[16:17:43.768]             }
[16:17:43.768]         }))
[16:17:43.768]     }, error = function(ex) {
[16:17:43.768]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:43.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.768]                 ...future.rng), started = ...future.startTime, 
[16:17:43.768]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:43.768]             version = "1.8"), class = "FutureResult")
[16:17:43.768]     }, finally = {
[16:17:43.768]         if (!identical(...future.workdir, getwd())) 
[16:17:43.768]             setwd(...future.workdir)
[16:17:43.768]         {
[16:17:43.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:43.768]                 ...future.oldOptions$nwarnings <- NULL
[16:17:43.768]             }
[16:17:43.768]             base::options(...future.oldOptions)
[16:17:43.768]             if (.Platform$OS.type == "windows") {
[16:17:43.768]                 old_names <- names(...future.oldEnvVars)
[16:17:43.768]                 envs <- base::Sys.getenv()
[16:17:43.768]                 names <- names(envs)
[16:17:43.768]                 common <- intersect(names, old_names)
[16:17:43.768]                 added <- setdiff(names, old_names)
[16:17:43.768]                 removed <- setdiff(old_names, names)
[16:17:43.768]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:43.768]                   envs[common]]
[16:17:43.768]                 NAMES <- toupper(changed)
[16:17:43.768]                 args <- list()
[16:17:43.768]                 for (kk in seq_along(NAMES)) {
[16:17:43.768]                   name <- changed[[kk]]
[16:17:43.768]                   NAME <- NAMES[[kk]]
[16:17:43.768]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.768]                     next
[16:17:43.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.768]                 }
[16:17:43.768]                 NAMES <- toupper(added)
[16:17:43.768]                 for (kk in seq_along(NAMES)) {
[16:17:43.768]                   name <- added[[kk]]
[16:17:43.768]                   NAME <- NAMES[[kk]]
[16:17:43.768]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.768]                     next
[16:17:43.768]                   args[[name]] <- ""
[16:17:43.768]                 }
[16:17:43.768]                 NAMES <- toupper(removed)
[16:17:43.768]                 for (kk in seq_along(NAMES)) {
[16:17:43.768]                   name <- removed[[kk]]
[16:17:43.768]                   NAME <- NAMES[[kk]]
[16:17:43.768]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.768]                     next
[16:17:43.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.768]                 }
[16:17:43.768]                 if (length(args) > 0) 
[16:17:43.768]                   base::do.call(base::Sys.setenv, args = args)
[16:17:43.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:43.768]             }
[16:17:43.768]             else {
[16:17:43.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:43.768]             }
[16:17:43.768]             {
[16:17:43.768]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:43.768]                   0L) {
[16:17:43.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:43.768]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:43.768]                   base::options(opts)
[16:17:43.768]                 }
[16:17:43.768]                 {
[16:17:43.768]                   {
[16:17:43.768]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:43.768]                     NULL
[16:17:43.768]                   }
[16:17:43.768]                   options(future.plan = NULL)
[16:17:43.768]                   if (is.na(NA_character_)) 
[16:17:43.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:43.768]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:43.768]                     .init = FALSE)
[16:17:43.768]                 }
[16:17:43.768]             }
[16:17:43.768]         }
[16:17:43.768]     })
[16:17:43.768]     if (TRUE) {
[16:17:43.768]         base::sink(type = "output", split = FALSE)
[16:17:43.768]         if (TRUE) {
[16:17:43.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:43.768]         }
[16:17:43.768]         else {
[16:17:43.768]             ...future.result["stdout"] <- base::list(NULL)
[16:17:43.768]         }
[16:17:43.768]         base::close(...future.stdout)
[16:17:43.768]         ...future.stdout <- NULL
[16:17:43.768]     }
[16:17:43.768]     ...future.result$conditions <- ...future.conditions
[16:17:43.768]     ...future.result$finished <- base::Sys.time()
[16:17:43.768]     ...future.result
[16:17:43.768] }
[16:17:43.820] MultisessionFuture started
[16:17:43.820] result() for ClusterFuture ...
[16:17:43.821] receiveMessageFromWorker() for ClusterFuture ...
[16:17:43.822] - Validating connection of MultisessionFuture
[16:17:43.854] - received message: FutureResult
[16:17:43.854] - Received FutureResult
[16:17:43.854] - Erased future from FutureRegistry
[16:17:43.854] result() for ClusterFuture ...
[16:17:43.854] - result already collected: FutureResult
[16:17:43.854] result() for ClusterFuture ... done
[16:17:43.854] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:43.855] result() for ClusterFuture ... done
[16:17:43.855] result() for ClusterFuture ...
[16:17:43.855] - result already collected: FutureResult
[16:17:43.855] result() for ClusterFuture ... done
[16:17:43.855] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:17:43.859] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[16:17:43.860] getGlobalsAndPackagesXApply() ...
[16:17:43.860]  - future.globals: TRUE
[16:17:43.860] getGlobalsAndPackages() ...
[16:17:43.860] Searching for globals...
[16:17:43.904] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:17:43.904] Searching for globals ... DONE
[16:17:43.904] Resolving globals: FALSE
[16:17:43.906] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:17:43.906] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:17:43.906] - globals: [1] ‘FUN’
[16:17:43.906] 
[16:17:43.906] getGlobalsAndPackages() ... DONE
[16:17:43.906]  - globals found/used: [n=1] ‘FUN’
[16:17:43.907]  - needed namespaces: [n=0] 
[16:17:43.907] Finding globals ... DONE
[16:17:43.907]  - use_args: TRUE
[16:17:43.907]  - Getting '...' globals ...
[16:17:43.907] resolve() on list ...
[16:17:43.907]  recursive: 0
[16:17:43.907]  length: 1
[16:17:43.907]  elements: ‘...’
[16:17:43.908]  length: 0 (resolved future 1)
[16:17:43.908] resolve() on list ... DONE
[16:17:43.908]    - '...' content: [n=0] 
[16:17:43.908] List of 1
[16:17:43.908]  $ ...: list()
[16:17:43.908]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.908]  - attr(*, "where")=List of 1
[16:17:43.908]   ..$ ...:<environment: 0x555be3500fa0> 
[16:17:43.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.908]  - attr(*, "resolved")= logi TRUE
[16:17:43.908]  - attr(*, "total_size")= num NA
[16:17:43.910]  - Getting '...' globals ... DONE
[16:17:43.911] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:43.911] List of 2
[16:17:43.911]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:43.911]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:43.911]  $ ...          : list()
[16:17:43.911]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.911]  - attr(*, "where")=List of 2
[16:17:43.911]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:43.911]   ..$ ...          :<environment: 0x555be3500fa0> 
[16:17:43.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.911]  - attr(*, "resolved")= logi FALSE
[16:17:43.911]  - attr(*, "total_size")= num 354224
[16:17:43.913] Packages to be attached in all futures: [n=0] 
[16:17:43.913] getGlobalsAndPackagesXApply() ... DONE
[16:17:43.917] future_lapply() ...
[16:17:43.950] Number of chunks: 2
[16:17:43.950] getGlobalsAndPackagesXApply() ...
[16:17:43.950]  - future.globals: <name-value list> with names ‘list()’
[16:17:43.950]  - use_args: TRUE
[16:17:43.951] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:43.951] List of 2
[16:17:43.951]  $ ...          : list()
[16:17:43.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:43.951]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:43.951]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:43.951]  - attr(*, "where")=List of 2
[16:17:43.951]   ..$ ...          :<environment: 0x555be3500fa0> 
[16:17:43.951]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:43.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:43.951]  - attr(*, "resolved")= logi FALSE
[16:17:43.951]  - attr(*, "total_size")= num NA
[16:17:43.954] Packages to be attached in all futures: [n=0] 
[16:17:43.954] getGlobalsAndPackagesXApply() ... DONE
[16:17:43.954] Number of futures (= number of chunks): 2
[16:17:43.954] Launching 2 futures (chunks) ...
[16:17:43.955] Chunk #1 of 2 ...
[16:17:43.955]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:43.955]  - seeds: <none>
[16:17:43.955]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.955] getGlobalsAndPackages() ...
[16:17:43.955] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.955] Resolving globals: FALSE
[16:17:43.955] Tweak future expression to call with '...' arguments ...
[16:17:43.955] {
[16:17:43.955]     do.call(function(...) {
[16:17:43.955]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.955]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:43.955]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.955]             on.exit(options(oopts), add = TRUE)
[16:17:43.955]         }
[16:17:43.955]         {
[16:17:43.955]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:43.955]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.955]                 ...future.FUN(...future.X_jj, ...)
[16:17:43.955]             })
[16:17:43.955]         }
[16:17:43.955]     }, args = future.call.arguments)
[16:17:43.955] }
[16:17:43.956] Tweak future expression to call with '...' arguments ... DONE
[16:17:43.956] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:43.956] 
[16:17:43.956] getGlobalsAndPackages() ... DONE
[16:17:43.957] run() for ‘Future’ ...
[16:17:43.957] - state: ‘created’
[16:17:43.957] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:43.970] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:43.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:43.971]   - Field: ‘node’
[16:17:43.971]   - Field: ‘label’
[16:17:43.971]   - Field: ‘local’
[16:17:43.971]   - Field: ‘owner’
[16:17:43.971]   - Field: ‘envir’
[16:17:43.971]   - Field: ‘workers’
[16:17:43.971]   - Field: ‘packages’
[16:17:43.971]   - Field: ‘gc’
[16:17:43.971]   - Field: ‘conditions’
[16:17:43.971]   - Field: ‘persistent’
[16:17:43.971]   - Field: ‘expr’
[16:17:43.972]   - Field: ‘uuid’
[16:17:43.972]   - Field: ‘seed’
[16:17:43.972]   - Field: ‘version’
[16:17:43.972]   - Field: ‘result’
[16:17:43.972]   - Field: ‘asynchronous’
[16:17:43.972]   - Field: ‘calls’
[16:17:43.972]   - Field: ‘globals’
[16:17:43.972]   - Field: ‘stdout’
[16:17:43.972]   - Field: ‘earlySignal’
[16:17:43.972]   - Field: ‘lazy’
[16:17:43.972]   - Field: ‘state’
[16:17:43.973] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:43.973] - Launch lazy future ...
[16:17:43.973] Packages needed by the future expression (n = 0): <none>
[16:17:43.973] Packages needed by future strategies (n = 0): <none>
[16:17:43.973] {
[16:17:43.973]     {
[16:17:43.973]         {
[16:17:43.973]             ...future.startTime <- base::Sys.time()
[16:17:43.973]             {
[16:17:43.973]                 {
[16:17:43.973]                   {
[16:17:43.973]                     {
[16:17:43.973]                       base::local({
[16:17:43.973]                         has_future <- base::requireNamespace("future", 
[16:17:43.973]                           quietly = TRUE)
[16:17:43.973]                         if (has_future) {
[16:17:43.973]                           ns <- base::getNamespace("future")
[16:17:43.973]                           version <- ns[[".package"]][["version"]]
[16:17:43.973]                           if (is.null(version)) 
[16:17:43.973]                             version <- utils::packageVersion("future")
[16:17:43.973]                         }
[16:17:43.973]                         else {
[16:17:43.973]                           version <- NULL
[16:17:43.973]                         }
[16:17:43.973]                         if (!has_future || version < "1.8.0") {
[16:17:43.973]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:43.973]                             "", base::R.version$version.string), 
[16:17:43.973]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:43.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:43.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:43.973]                               "release", "version")], collapse = " "), 
[16:17:43.973]                             hostname = base::Sys.info()[["nodename"]])
[16:17:43.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:43.973]                             info)
[16:17:43.973]                           info <- base::paste(info, collapse = "; ")
[16:17:43.973]                           if (!has_future) {
[16:17:43.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:43.973]                               info)
[16:17:43.973]                           }
[16:17:43.973]                           else {
[16:17:43.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:43.973]                               info, version)
[16:17:43.973]                           }
[16:17:43.973]                           base::stop(msg)
[16:17:43.973]                         }
[16:17:43.973]                       })
[16:17:43.973]                     }
[16:17:43.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:43.973]                     base::options(mc.cores = 1L)
[16:17:43.973]                   }
[16:17:43.973]                   ...future.strategy.old <- future::plan("list")
[16:17:43.973]                   options(future.plan = NULL)
[16:17:43.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:43.973]                 }
[16:17:43.973]                 ...future.workdir <- getwd()
[16:17:43.973]             }
[16:17:43.973]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:43.973]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:43.973]         }
[16:17:43.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:43.973]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:43.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:43.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:43.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:43.973]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:43.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:43.973]             base::names(...future.oldOptions))
[16:17:43.973]     }
[16:17:43.973]     if (FALSE) {
[16:17:43.973]     }
[16:17:43.973]     else {
[16:17:43.973]         if (TRUE) {
[16:17:43.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:43.973]                 open = "w")
[16:17:43.973]         }
[16:17:43.973]         else {
[16:17:43.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:43.973]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:43.973]         }
[16:17:43.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:43.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:43.973]             base::sink(type = "output", split = FALSE)
[16:17:43.973]             base::close(...future.stdout)
[16:17:43.973]         }, add = TRUE)
[16:17:43.973]     }
[16:17:43.973]     ...future.frame <- base::sys.nframe()
[16:17:43.973]     ...future.conditions <- base::list()
[16:17:43.973]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:43.973]     if (FALSE) {
[16:17:43.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:43.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:43.973]     }
[16:17:43.973]     ...future.result <- base::tryCatch({
[16:17:43.973]         base::withCallingHandlers({
[16:17:43.973]             ...future.value <- base::withVisible(base::local({
[16:17:43.973]                 ...future.makeSendCondition <- base::local({
[16:17:43.973]                   sendCondition <- NULL
[16:17:43.973]                   function(frame = 1L) {
[16:17:43.973]                     if (is.function(sendCondition)) 
[16:17:43.973]                       return(sendCondition)
[16:17:43.973]                     ns <- getNamespace("parallel")
[16:17:43.973]                     if (exists("sendData", mode = "function", 
[16:17:43.973]                       envir = ns)) {
[16:17:43.973]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:43.973]                         envir = ns)
[16:17:43.973]                       envir <- sys.frame(frame)
[16:17:43.973]                       master <- NULL
[16:17:43.973]                       while (!identical(envir, .GlobalEnv) && 
[16:17:43.973]                         !identical(envir, emptyenv())) {
[16:17:43.973]                         if (exists("master", mode = "list", envir = envir, 
[16:17:43.973]                           inherits = FALSE)) {
[16:17:43.973]                           master <- get("master", mode = "list", 
[16:17:43.973]                             envir = envir, inherits = FALSE)
[16:17:43.973]                           if (inherits(master, c("SOCKnode", 
[16:17:43.973]                             "SOCK0node"))) {
[16:17:43.973]                             sendCondition <<- function(cond) {
[16:17:43.973]                               data <- list(type = "VALUE", value = cond, 
[16:17:43.973]                                 success = TRUE)
[16:17:43.973]                               parallel_sendData(master, data)
[16:17:43.973]                             }
[16:17:43.973]                             return(sendCondition)
[16:17:43.973]                           }
[16:17:43.973]                         }
[16:17:43.973]                         frame <- frame + 1L
[16:17:43.973]                         envir <- sys.frame(frame)
[16:17:43.973]                       }
[16:17:43.973]                     }
[16:17:43.973]                     sendCondition <<- function(cond) NULL
[16:17:43.973]                   }
[16:17:43.973]                 })
[16:17:43.973]                 withCallingHandlers({
[16:17:43.973]                   {
[16:17:43.973]                     do.call(function(...) {
[16:17:43.973]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:43.973]                       if (!identical(...future.globals.maxSize.org, 
[16:17:43.973]                         ...future.globals.maxSize)) {
[16:17:43.973]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:43.973]                         on.exit(options(oopts), add = TRUE)
[16:17:43.973]                       }
[16:17:43.973]                       {
[16:17:43.973]                         lapply(seq_along(...future.elements_ii), 
[16:17:43.973]                           FUN = function(jj) {
[16:17:43.973]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:43.973]                             ...future.FUN(...future.X_jj, ...)
[16:17:43.973]                           })
[16:17:43.973]                       }
[16:17:43.973]                     }, args = future.call.arguments)
[16:17:43.973]                   }
[16:17:43.973]                 }, immediateCondition = function(cond) {
[16:17:43.973]                   sendCondition <- ...future.makeSendCondition()
[16:17:43.973]                   sendCondition(cond)
[16:17:43.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.973]                   {
[16:17:43.973]                     inherits <- base::inherits
[16:17:43.973]                     invokeRestart <- base::invokeRestart
[16:17:43.973]                     is.null <- base::is.null
[16:17:43.973]                     muffled <- FALSE
[16:17:43.973]                     if (inherits(cond, "message")) {
[16:17:43.973]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:43.973]                       if (muffled) 
[16:17:43.973]                         invokeRestart("muffleMessage")
[16:17:43.973]                     }
[16:17:43.973]                     else if (inherits(cond, "warning")) {
[16:17:43.973]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:43.973]                       if (muffled) 
[16:17:43.973]                         invokeRestart("muffleWarning")
[16:17:43.973]                     }
[16:17:43.973]                     else if (inherits(cond, "condition")) {
[16:17:43.973]                       if (!is.null(pattern)) {
[16:17:43.973]                         computeRestarts <- base::computeRestarts
[16:17:43.973]                         grepl <- base::grepl
[16:17:43.973]                         restarts <- computeRestarts(cond)
[16:17:43.973]                         for (restart in restarts) {
[16:17:43.973]                           name <- restart$name
[16:17:43.973]                           if (is.null(name)) 
[16:17:43.973]                             next
[16:17:43.973]                           if (!grepl(pattern, name)) 
[16:17:43.973]                             next
[16:17:43.973]                           invokeRestart(restart)
[16:17:43.973]                           muffled <- TRUE
[16:17:43.973]                           break
[16:17:43.973]                         }
[16:17:43.973]                       }
[16:17:43.973]                     }
[16:17:43.973]                     invisible(muffled)
[16:17:43.973]                   }
[16:17:43.973]                   muffleCondition(cond)
[16:17:43.973]                 })
[16:17:43.973]             }))
[16:17:43.973]             future::FutureResult(value = ...future.value$value, 
[16:17:43.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.973]                   ...future.rng), globalenv = if (FALSE) 
[16:17:43.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:43.973]                     ...future.globalenv.names))
[16:17:43.973]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:43.973]         }, condition = base::local({
[16:17:43.973]             c <- base::c
[16:17:43.973]             inherits <- base::inherits
[16:17:43.973]             invokeRestart <- base::invokeRestart
[16:17:43.973]             length <- base::length
[16:17:43.973]             list <- base::list
[16:17:43.973]             seq.int <- base::seq.int
[16:17:43.973]             signalCondition <- base::signalCondition
[16:17:43.973]             sys.calls <- base::sys.calls
[16:17:43.973]             `[[` <- base::`[[`
[16:17:43.973]             `+` <- base::`+`
[16:17:43.973]             `<<-` <- base::`<<-`
[16:17:43.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:43.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:43.973]                   3L)]
[16:17:43.973]             }
[16:17:43.973]             function(cond) {
[16:17:43.973]                 is_error <- inherits(cond, "error")
[16:17:43.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:43.973]                   NULL)
[16:17:43.973]                 if (is_error) {
[16:17:43.973]                   sessionInformation <- function() {
[16:17:43.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:43.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:43.973]                       search = base::search(), system = base::Sys.info())
[16:17:43.973]                   }
[16:17:43.973]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:43.973]                     cond$call), session = sessionInformation(), 
[16:17:43.973]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:43.973]                   signalCondition(cond)
[16:17:43.973]                 }
[16:17:43.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:43.973]                 "immediateCondition"))) {
[16:17:43.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:43.973]                   ...future.conditions[[length(...future.conditions) + 
[16:17:43.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:43.973]                   if (TRUE && !signal) {
[16:17:43.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.973]                     {
[16:17:43.973]                       inherits <- base::inherits
[16:17:43.973]                       invokeRestart <- base::invokeRestart
[16:17:43.973]                       is.null <- base::is.null
[16:17:43.973]                       muffled <- FALSE
[16:17:43.973]                       if (inherits(cond, "message")) {
[16:17:43.973]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.973]                         if (muffled) 
[16:17:43.973]                           invokeRestart("muffleMessage")
[16:17:43.973]                       }
[16:17:43.973]                       else if (inherits(cond, "warning")) {
[16:17:43.973]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.973]                         if (muffled) 
[16:17:43.973]                           invokeRestart("muffleWarning")
[16:17:43.973]                       }
[16:17:43.973]                       else if (inherits(cond, "condition")) {
[16:17:43.973]                         if (!is.null(pattern)) {
[16:17:43.973]                           computeRestarts <- base::computeRestarts
[16:17:43.973]                           grepl <- base::grepl
[16:17:43.973]                           restarts <- computeRestarts(cond)
[16:17:43.973]                           for (restart in restarts) {
[16:17:43.973]                             name <- restart$name
[16:17:43.973]                             if (is.null(name)) 
[16:17:43.973]                               next
[16:17:43.973]                             if (!grepl(pattern, name)) 
[16:17:43.973]                               next
[16:17:43.973]                             invokeRestart(restart)
[16:17:43.973]                             muffled <- TRUE
[16:17:43.973]                             break
[16:17:43.973]                           }
[16:17:43.973]                         }
[16:17:43.973]                       }
[16:17:43.973]                       invisible(muffled)
[16:17:43.973]                     }
[16:17:43.973]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.973]                   }
[16:17:43.973]                 }
[16:17:43.973]                 else {
[16:17:43.973]                   if (TRUE) {
[16:17:43.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:43.973]                     {
[16:17:43.973]                       inherits <- base::inherits
[16:17:43.973]                       invokeRestart <- base::invokeRestart
[16:17:43.973]                       is.null <- base::is.null
[16:17:43.973]                       muffled <- FALSE
[16:17:43.973]                       if (inherits(cond, "message")) {
[16:17:43.973]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:43.973]                         if (muffled) 
[16:17:43.973]                           invokeRestart("muffleMessage")
[16:17:43.973]                       }
[16:17:43.973]                       else if (inherits(cond, "warning")) {
[16:17:43.973]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:43.973]                         if (muffled) 
[16:17:43.973]                           invokeRestart("muffleWarning")
[16:17:43.973]                       }
[16:17:43.973]                       else if (inherits(cond, "condition")) {
[16:17:43.973]                         if (!is.null(pattern)) {
[16:17:43.973]                           computeRestarts <- base::computeRestarts
[16:17:43.973]                           grepl <- base::grepl
[16:17:43.973]                           restarts <- computeRestarts(cond)
[16:17:43.973]                           for (restart in restarts) {
[16:17:43.973]                             name <- restart$name
[16:17:43.973]                             if (is.null(name)) 
[16:17:43.973]                               next
[16:17:43.973]                             if (!grepl(pattern, name)) 
[16:17:43.973]                               next
[16:17:43.973]                             invokeRestart(restart)
[16:17:43.973]                             muffled <- TRUE
[16:17:43.973]                             break
[16:17:43.973]                           }
[16:17:43.973]                         }
[16:17:43.973]                       }
[16:17:43.973]                       invisible(muffled)
[16:17:43.973]                     }
[16:17:43.973]                     muffleCondition(cond, pattern = "^muffle")
[16:17:43.973]                   }
[16:17:43.973]                 }
[16:17:43.973]             }
[16:17:43.973]         }))
[16:17:43.973]     }, error = function(ex) {
[16:17:43.973]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:43.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:43.973]                 ...future.rng), started = ...future.startTime, 
[16:17:43.973]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:43.973]             version = "1.8"), class = "FutureResult")
[16:17:43.973]     }, finally = {
[16:17:43.973]         if (!identical(...future.workdir, getwd())) 
[16:17:43.973]             setwd(...future.workdir)
[16:17:43.973]         {
[16:17:43.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:43.973]                 ...future.oldOptions$nwarnings <- NULL
[16:17:43.973]             }
[16:17:43.973]             base::options(...future.oldOptions)
[16:17:43.973]             if (.Platform$OS.type == "windows") {
[16:17:43.973]                 old_names <- names(...future.oldEnvVars)
[16:17:43.973]                 envs <- base::Sys.getenv()
[16:17:43.973]                 names <- names(envs)
[16:17:43.973]                 common <- intersect(names, old_names)
[16:17:43.973]                 added <- setdiff(names, old_names)
[16:17:43.973]                 removed <- setdiff(old_names, names)
[16:17:43.973]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:43.973]                   envs[common]]
[16:17:43.973]                 NAMES <- toupper(changed)
[16:17:43.973]                 args <- list()
[16:17:43.973]                 for (kk in seq_along(NAMES)) {
[16:17:43.973]                   name <- changed[[kk]]
[16:17:43.973]                   NAME <- NAMES[[kk]]
[16:17:43.973]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.973]                     next
[16:17:43.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.973]                 }
[16:17:43.973]                 NAMES <- toupper(added)
[16:17:43.973]                 for (kk in seq_along(NAMES)) {
[16:17:43.973]                   name <- added[[kk]]
[16:17:43.973]                   NAME <- NAMES[[kk]]
[16:17:43.973]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.973]                     next
[16:17:43.973]                   args[[name]] <- ""
[16:17:43.973]                 }
[16:17:43.973]                 NAMES <- toupper(removed)
[16:17:43.973]                 for (kk in seq_along(NAMES)) {
[16:17:43.973]                   name <- removed[[kk]]
[16:17:43.973]                   NAME <- NAMES[[kk]]
[16:17:43.973]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:43.973]                     next
[16:17:43.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:43.973]                 }
[16:17:43.973]                 if (length(args) > 0) 
[16:17:43.973]                   base::do.call(base::Sys.setenv, args = args)
[16:17:43.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:43.973]             }
[16:17:43.973]             else {
[16:17:43.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:43.973]             }
[16:17:43.973]             {
[16:17:43.973]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:43.973]                   0L) {
[16:17:43.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:43.973]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:43.973]                   base::options(opts)
[16:17:43.973]                 }
[16:17:43.973]                 {
[16:17:43.973]                   {
[16:17:43.973]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:43.973]                     NULL
[16:17:43.973]                   }
[16:17:43.973]                   options(future.plan = NULL)
[16:17:43.973]                   if (is.na(NA_character_)) 
[16:17:43.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:43.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:43.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:43.973]                     .init = FALSE)
[16:17:43.973]                 }
[16:17:43.973]             }
[16:17:43.973]         }
[16:17:43.973]     })
[16:17:43.973]     if (TRUE) {
[16:17:43.973]         base::sink(type = "output", split = FALSE)
[16:17:43.973]         if (TRUE) {
[16:17:43.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:43.973]         }
[16:17:43.973]         else {
[16:17:43.973]             ...future.result["stdout"] <- base::list(NULL)
[16:17:43.973]         }
[16:17:43.973]         base::close(...future.stdout)
[16:17:43.973]         ...future.stdout <- NULL
[16:17:43.973]     }
[16:17:43.973]     ...future.result$conditions <- ...future.conditions
[16:17:43.973]     ...future.result$finished <- base::Sys.time()
[16:17:43.973]     ...future.result
[16:17:43.973] }
[16:17:43.977] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[16:17:43.977] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:43.977] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:43.977] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[16:17:44.021] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[16:17:44.021] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:17:44.021] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:17:44.021] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:44.022] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.022] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:17:44.022] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:17:44.022] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[16:17:44.023] MultisessionFuture started
[16:17:44.023] - Launch lazy future ... done
[16:17:44.023] run() for ‘MultisessionFuture’ ... done
[16:17:44.023] Created future:
[16:17:44.023] MultisessionFuture:
[16:17:44.023] Label: ‘future_apply-1’
[16:17:44.023] Expression:
[16:17:44.023] {
[16:17:44.023]     do.call(function(...) {
[16:17:44.023]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.023]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.023]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.023]             on.exit(options(oopts), add = TRUE)
[16:17:44.023]         }
[16:17:44.023]         {
[16:17:44.023]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.023]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.023]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.023]             })
[16:17:44.023]         }
[16:17:44.023]     }, args = future.call.arguments)
[16:17:44.023] }
[16:17:44.023] Lazy evaluation: FALSE
[16:17:44.023] Asynchronous evaluation: TRUE
[16:17:44.023] Local evaluation: TRUE
[16:17:44.023] Environment: R_GlobalEnv
[16:17:44.023] Capture standard output: TRUE
[16:17:44.023] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.023] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.023] Packages: <none>
[16:17:44.023] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.023] Resolved: FALSE
[16:17:44.023] Value: <not collected>
[16:17:44.023] Conditions captured: <none>
[16:17:44.023] Early signaling: FALSE
[16:17:44.023] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.023] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.035] Chunk #1 of 2 ... DONE
[16:17:44.035] Chunk #2 of 2 ...
[16:17:44.035]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.036]  - seeds: <none>
[16:17:44.036]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.036] getGlobalsAndPackages() ...
[16:17:44.036] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.036] Resolving globals: FALSE
[16:17:44.036] Tweak future expression to call with '...' arguments ...
[16:17:44.036] {
[16:17:44.036]     do.call(function(...) {
[16:17:44.036]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.036]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.036]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.036]             on.exit(options(oopts), add = TRUE)
[16:17:44.036]         }
[16:17:44.036]         {
[16:17:44.036]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.036]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.036]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.036]             })
[16:17:44.036]         }
[16:17:44.036]     }, args = future.call.arguments)
[16:17:44.036] }
[16:17:44.037] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.037] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.037] 
[16:17:44.037] getGlobalsAndPackages() ... DONE
[16:17:44.037] run() for ‘Future’ ...
[16:17:44.038] - state: ‘created’
[16:17:44.038] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:44.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:44.052]   - Field: ‘node’
[16:17:44.052]   - Field: ‘label’
[16:17:44.052]   - Field: ‘local’
[16:17:44.052]   - Field: ‘owner’
[16:17:44.052]   - Field: ‘envir’
[16:17:44.052]   - Field: ‘workers’
[16:17:44.052]   - Field: ‘packages’
[16:17:44.052]   - Field: ‘gc’
[16:17:44.053]   - Field: ‘conditions’
[16:17:44.055]   - Field: ‘persistent’
[16:17:44.055]   - Field: ‘expr’
[16:17:44.055]   - Field: ‘uuid’
[16:17:44.055]   - Field: ‘seed’
[16:17:44.055]   - Field: ‘version’
[16:17:44.055]   - Field: ‘result’
[16:17:44.055]   - Field: ‘asynchronous’
[16:17:44.055]   - Field: ‘calls’
[16:17:44.055]   - Field: ‘globals’
[16:17:44.055]   - Field: ‘stdout’
[16:17:44.055]   - Field: ‘earlySignal’
[16:17:44.056]   - Field: ‘lazy’
[16:17:44.056]   - Field: ‘state’
[16:17:44.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:44.056] - Launch lazy future ...
[16:17:44.056] Packages needed by the future expression (n = 0): <none>
[16:17:44.056] Packages needed by future strategies (n = 0): <none>
[16:17:44.057] {
[16:17:44.057]     {
[16:17:44.057]         {
[16:17:44.057]             ...future.startTime <- base::Sys.time()
[16:17:44.057]             {
[16:17:44.057]                 {
[16:17:44.057]                   {
[16:17:44.057]                     {
[16:17:44.057]                       base::local({
[16:17:44.057]                         has_future <- base::requireNamespace("future", 
[16:17:44.057]                           quietly = TRUE)
[16:17:44.057]                         if (has_future) {
[16:17:44.057]                           ns <- base::getNamespace("future")
[16:17:44.057]                           version <- ns[[".package"]][["version"]]
[16:17:44.057]                           if (is.null(version)) 
[16:17:44.057]                             version <- utils::packageVersion("future")
[16:17:44.057]                         }
[16:17:44.057]                         else {
[16:17:44.057]                           version <- NULL
[16:17:44.057]                         }
[16:17:44.057]                         if (!has_future || version < "1.8.0") {
[16:17:44.057]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:44.057]                             "", base::R.version$version.string), 
[16:17:44.057]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:44.057]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:44.057]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:44.057]                               "release", "version")], collapse = " "), 
[16:17:44.057]                             hostname = base::Sys.info()[["nodename"]])
[16:17:44.057]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:44.057]                             info)
[16:17:44.057]                           info <- base::paste(info, collapse = "; ")
[16:17:44.057]                           if (!has_future) {
[16:17:44.057]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:44.057]                               info)
[16:17:44.057]                           }
[16:17:44.057]                           else {
[16:17:44.057]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:44.057]                               info, version)
[16:17:44.057]                           }
[16:17:44.057]                           base::stop(msg)
[16:17:44.057]                         }
[16:17:44.057]                       })
[16:17:44.057]                     }
[16:17:44.057]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:44.057]                     base::options(mc.cores = 1L)
[16:17:44.057]                   }
[16:17:44.057]                   ...future.strategy.old <- future::plan("list")
[16:17:44.057]                   options(future.plan = NULL)
[16:17:44.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:44.057]                 }
[16:17:44.057]                 ...future.workdir <- getwd()
[16:17:44.057]             }
[16:17:44.057]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:44.057]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:44.057]         }
[16:17:44.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:44.057]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:44.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:44.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:44.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:44.057]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:44.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:44.057]             base::names(...future.oldOptions))
[16:17:44.057]     }
[16:17:44.057]     if (FALSE) {
[16:17:44.057]     }
[16:17:44.057]     else {
[16:17:44.057]         if (TRUE) {
[16:17:44.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:44.057]                 open = "w")
[16:17:44.057]         }
[16:17:44.057]         else {
[16:17:44.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:44.057]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:44.057]         }
[16:17:44.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:44.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:44.057]             base::sink(type = "output", split = FALSE)
[16:17:44.057]             base::close(...future.stdout)
[16:17:44.057]         }, add = TRUE)
[16:17:44.057]     }
[16:17:44.057]     ...future.frame <- base::sys.nframe()
[16:17:44.057]     ...future.conditions <- base::list()
[16:17:44.057]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:44.057]     if (FALSE) {
[16:17:44.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:44.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:44.057]     }
[16:17:44.057]     ...future.result <- base::tryCatch({
[16:17:44.057]         base::withCallingHandlers({
[16:17:44.057]             ...future.value <- base::withVisible(base::local({
[16:17:44.057]                 ...future.makeSendCondition <- base::local({
[16:17:44.057]                   sendCondition <- NULL
[16:17:44.057]                   function(frame = 1L) {
[16:17:44.057]                     if (is.function(sendCondition)) 
[16:17:44.057]                       return(sendCondition)
[16:17:44.057]                     ns <- getNamespace("parallel")
[16:17:44.057]                     if (exists("sendData", mode = "function", 
[16:17:44.057]                       envir = ns)) {
[16:17:44.057]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:44.057]                         envir = ns)
[16:17:44.057]                       envir <- sys.frame(frame)
[16:17:44.057]                       master <- NULL
[16:17:44.057]                       while (!identical(envir, .GlobalEnv) && 
[16:17:44.057]                         !identical(envir, emptyenv())) {
[16:17:44.057]                         if (exists("master", mode = "list", envir = envir, 
[16:17:44.057]                           inherits = FALSE)) {
[16:17:44.057]                           master <- get("master", mode = "list", 
[16:17:44.057]                             envir = envir, inherits = FALSE)
[16:17:44.057]                           if (inherits(master, c("SOCKnode", 
[16:17:44.057]                             "SOCK0node"))) {
[16:17:44.057]                             sendCondition <<- function(cond) {
[16:17:44.057]                               data <- list(type = "VALUE", value = cond, 
[16:17:44.057]                                 success = TRUE)
[16:17:44.057]                               parallel_sendData(master, data)
[16:17:44.057]                             }
[16:17:44.057]                             return(sendCondition)
[16:17:44.057]                           }
[16:17:44.057]                         }
[16:17:44.057]                         frame <- frame + 1L
[16:17:44.057]                         envir <- sys.frame(frame)
[16:17:44.057]                       }
[16:17:44.057]                     }
[16:17:44.057]                     sendCondition <<- function(cond) NULL
[16:17:44.057]                   }
[16:17:44.057]                 })
[16:17:44.057]                 withCallingHandlers({
[16:17:44.057]                   {
[16:17:44.057]                     do.call(function(...) {
[16:17:44.057]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.057]                       if (!identical(...future.globals.maxSize.org, 
[16:17:44.057]                         ...future.globals.maxSize)) {
[16:17:44.057]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.057]                         on.exit(options(oopts), add = TRUE)
[16:17:44.057]                       }
[16:17:44.057]                       {
[16:17:44.057]                         lapply(seq_along(...future.elements_ii), 
[16:17:44.057]                           FUN = function(jj) {
[16:17:44.057]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.057]                             ...future.FUN(...future.X_jj, ...)
[16:17:44.057]                           })
[16:17:44.057]                       }
[16:17:44.057]                     }, args = future.call.arguments)
[16:17:44.057]                   }
[16:17:44.057]                 }, immediateCondition = function(cond) {
[16:17:44.057]                   sendCondition <- ...future.makeSendCondition()
[16:17:44.057]                   sendCondition(cond)
[16:17:44.057]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.057]                   {
[16:17:44.057]                     inherits <- base::inherits
[16:17:44.057]                     invokeRestart <- base::invokeRestart
[16:17:44.057]                     is.null <- base::is.null
[16:17:44.057]                     muffled <- FALSE
[16:17:44.057]                     if (inherits(cond, "message")) {
[16:17:44.057]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:44.057]                       if (muffled) 
[16:17:44.057]                         invokeRestart("muffleMessage")
[16:17:44.057]                     }
[16:17:44.057]                     else if (inherits(cond, "warning")) {
[16:17:44.057]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:44.057]                       if (muffled) 
[16:17:44.057]                         invokeRestart("muffleWarning")
[16:17:44.057]                     }
[16:17:44.057]                     else if (inherits(cond, "condition")) {
[16:17:44.057]                       if (!is.null(pattern)) {
[16:17:44.057]                         computeRestarts <- base::computeRestarts
[16:17:44.057]                         grepl <- base::grepl
[16:17:44.057]                         restarts <- computeRestarts(cond)
[16:17:44.057]                         for (restart in restarts) {
[16:17:44.057]                           name <- restart$name
[16:17:44.057]                           if (is.null(name)) 
[16:17:44.057]                             next
[16:17:44.057]                           if (!grepl(pattern, name)) 
[16:17:44.057]                             next
[16:17:44.057]                           invokeRestart(restart)
[16:17:44.057]                           muffled <- TRUE
[16:17:44.057]                           break
[16:17:44.057]                         }
[16:17:44.057]                       }
[16:17:44.057]                     }
[16:17:44.057]                     invisible(muffled)
[16:17:44.057]                   }
[16:17:44.057]                   muffleCondition(cond)
[16:17:44.057]                 })
[16:17:44.057]             }))
[16:17:44.057]             future::FutureResult(value = ...future.value$value, 
[16:17:44.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.057]                   ...future.rng), globalenv = if (FALSE) 
[16:17:44.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:44.057]                     ...future.globalenv.names))
[16:17:44.057]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:44.057]         }, condition = base::local({
[16:17:44.057]             c <- base::c
[16:17:44.057]             inherits <- base::inherits
[16:17:44.057]             invokeRestart <- base::invokeRestart
[16:17:44.057]             length <- base::length
[16:17:44.057]             list <- base::list
[16:17:44.057]             seq.int <- base::seq.int
[16:17:44.057]             signalCondition <- base::signalCondition
[16:17:44.057]             sys.calls <- base::sys.calls
[16:17:44.057]             `[[` <- base::`[[`
[16:17:44.057]             `+` <- base::`+`
[16:17:44.057]             `<<-` <- base::`<<-`
[16:17:44.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:44.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:44.057]                   3L)]
[16:17:44.057]             }
[16:17:44.057]             function(cond) {
[16:17:44.057]                 is_error <- inherits(cond, "error")
[16:17:44.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:44.057]                   NULL)
[16:17:44.057]                 if (is_error) {
[16:17:44.057]                   sessionInformation <- function() {
[16:17:44.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:44.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:44.057]                       search = base::search(), system = base::Sys.info())
[16:17:44.057]                   }
[16:17:44.057]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:44.057]                     cond$call), session = sessionInformation(), 
[16:17:44.057]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:44.057]                   signalCondition(cond)
[16:17:44.057]                 }
[16:17:44.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:44.057]                 "immediateCondition"))) {
[16:17:44.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:44.057]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:44.057]                   if (TRUE && !signal) {
[16:17:44.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.057]                     {
[16:17:44.057]                       inherits <- base::inherits
[16:17:44.057]                       invokeRestart <- base::invokeRestart
[16:17:44.057]                       is.null <- base::is.null
[16:17:44.057]                       muffled <- FALSE
[16:17:44.057]                       if (inherits(cond, "message")) {
[16:17:44.057]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.057]                         if (muffled) 
[16:17:44.057]                           invokeRestart("muffleMessage")
[16:17:44.057]                       }
[16:17:44.057]                       else if (inherits(cond, "warning")) {
[16:17:44.057]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.057]                         if (muffled) 
[16:17:44.057]                           invokeRestart("muffleWarning")
[16:17:44.057]                       }
[16:17:44.057]                       else if (inherits(cond, "condition")) {
[16:17:44.057]                         if (!is.null(pattern)) {
[16:17:44.057]                           computeRestarts <- base::computeRestarts
[16:17:44.057]                           grepl <- base::grepl
[16:17:44.057]                           restarts <- computeRestarts(cond)
[16:17:44.057]                           for (restart in restarts) {
[16:17:44.057]                             name <- restart$name
[16:17:44.057]                             if (is.null(name)) 
[16:17:44.057]                               next
[16:17:44.057]                             if (!grepl(pattern, name)) 
[16:17:44.057]                               next
[16:17:44.057]                             invokeRestart(restart)
[16:17:44.057]                             muffled <- TRUE
[16:17:44.057]                             break
[16:17:44.057]                           }
[16:17:44.057]                         }
[16:17:44.057]                       }
[16:17:44.057]                       invisible(muffled)
[16:17:44.057]                     }
[16:17:44.057]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.057]                   }
[16:17:44.057]                 }
[16:17:44.057]                 else {
[16:17:44.057]                   if (TRUE) {
[16:17:44.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.057]                     {
[16:17:44.057]                       inherits <- base::inherits
[16:17:44.057]                       invokeRestart <- base::invokeRestart
[16:17:44.057]                       is.null <- base::is.null
[16:17:44.057]                       muffled <- FALSE
[16:17:44.057]                       if (inherits(cond, "message")) {
[16:17:44.057]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.057]                         if (muffled) 
[16:17:44.057]                           invokeRestart("muffleMessage")
[16:17:44.057]                       }
[16:17:44.057]                       else if (inherits(cond, "warning")) {
[16:17:44.057]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.057]                         if (muffled) 
[16:17:44.057]                           invokeRestart("muffleWarning")
[16:17:44.057]                       }
[16:17:44.057]                       else if (inherits(cond, "condition")) {
[16:17:44.057]                         if (!is.null(pattern)) {
[16:17:44.057]                           computeRestarts <- base::computeRestarts
[16:17:44.057]                           grepl <- base::grepl
[16:17:44.057]                           restarts <- computeRestarts(cond)
[16:17:44.057]                           for (restart in restarts) {
[16:17:44.057]                             name <- restart$name
[16:17:44.057]                             if (is.null(name)) 
[16:17:44.057]                               next
[16:17:44.057]                             if (!grepl(pattern, name)) 
[16:17:44.057]                               next
[16:17:44.057]                             invokeRestart(restart)
[16:17:44.057]                             muffled <- TRUE
[16:17:44.057]                             break
[16:17:44.057]                           }
[16:17:44.057]                         }
[16:17:44.057]                       }
[16:17:44.057]                       invisible(muffled)
[16:17:44.057]                     }
[16:17:44.057]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.057]                   }
[16:17:44.057]                 }
[16:17:44.057]             }
[16:17:44.057]         }))
[16:17:44.057]     }, error = function(ex) {
[16:17:44.057]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:44.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.057]                 ...future.rng), started = ...future.startTime, 
[16:17:44.057]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:44.057]             version = "1.8"), class = "FutureResult")
[16:17:44.057]     }, finally = {
[16:17:44.057]         if (!identical(...future.workdir, getwd())) 
[16:17:44.057]             setwd(...future.workdir)
[16:17:44.057]         {
[16:17:44.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:44.057]                 ...future.oldOptions$nwarnings <- NULL
[16:17:44.057]             }
[16:17:44.057]             base::options(...future.oldOptions)
[16:17:44.057]             if (.Platform$OS.type == "windows") {
[16:17:44.057]                 old_names <- names(...future.oldEnvVars)
[16:17:44.057]                 envs <- base::Sys.getenv()
[16:17:44.057]                 names <- names(envs)
[16:17:44.057]                 common <- intersect(names, old_names)
[16:17:44.057]                 added <- setdiff(names, old_names)
[16:17:44.057]                 removed <- setdiff(old_names, names)
[16:17:44.057]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:44.057]                   envs[common]]
[16:17:44.057]                 NAMES <- toupper(changed)
[16:17:44.057]                 args <- list()
[16:17:44.057]                 for (kk in seq_along(NAMES)) {
[16:17:44.057]                   name <- changed[[kk]]
[16:17:44.057]                   NAME <- NAMES[[kk]]
[16:17:44.057]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.057]                     next
[16:17:44.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.057]                 }
[16:17:44.057]                 NAMES <- toupper(added)
[16:17:44.057]                 for (kk in seq_along(NAMES)) {
[16:17:44.057]                   name <- added[[kk]]
[16:17:44.057]                   NAME <- NAMES[[kk]]
[16:17:44.057]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.057]                     next
[16:17:44.057]                   args[[name]] <- ""
[16:17:44.057]                 }
[16:17:44.057]                 NAMES <- toupper(removed)
[16:17:44.057]                 for (kk in seq_along(NAMES)) {
[16:17:44.057]                   name <- removed[[kk]]
[16:17:44.057]                   NAME <- NAMES[[kk]]
[16:17:44.057]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.057]                     next
[16:17:44.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.057]                 }
[16:17:44.057]                 if (length(args) > 0) 
[16:17:44.057]                   base::do.call(base::Sys.setenv, args = args)
[16:17:44.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:44.057]             }
[16:17:44.057]             else {
[16:17:44.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:44.057]             }
[16:17:44.057]             {
[16:17:44.057]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:44.057]                   0L) {
[16:17:44.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:44.057]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:44.057]                   base::options(opts)
[16:17:44.057]                 }
[16:17:44.057]                 {
[16:17:44.057]                   {
[16:17:44.057]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:44.057]                     NULL
[16:17:44.057]                   }
[16:17:44.057]                   options(future.plan = NULL)
[16:17:44.057]                   if (is.na(NA_character_)) 
[16:17:44.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:44.057]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:44.057]                     .init = FALSE)
[16:17:44.057]                 }
[16:17:44.057]             }
[16:17:44.057]         }
[16:17:44.057]     })
[16:17:44.057]     if (TRUE) {
[16:17:44.057]         base::sink(type = "output", split = FALSE)
[16:17:44.057]         if (TRUE) {
[16:17:44.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:44.057]         }
[16:17:44.057]         else {
[16:17:44.057]             ...future.result["stdout"] <- base::list(NULL)
[16:17:44.057]         }
[16:17:44.057]         base::close(...future.stdout)
[16:17:44.057]         ...future.stdout <- NULL
[16:17:44.057]     }
[16:17:44.057]     ...future.result$conditions <- ...future.conditions
[16:17:44.057]     ...future.result$finished <- base::Sys.time()
[16:17:44.057]     ...future.result
[16:17:44.057] }
[16:17:44.110] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[16:17:44.110] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:44.111] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:44.111] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[16:17:44.153] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[16:17:44.153] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:17:44.153] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:17:44.154] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:44.154] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:44.154] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:17:44.154] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:17:44.155] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[16:17:44.155] MultisessionFuture started
[16:17:44.155] - Launch lazy future ... done
[16:17:44.155] run() for ‘MultisessionFuture’ ... done
[16:17:44.156] Created future:
[16:17:44.156] MultisessionFuture:
[16:17:44.156] Label: ‘future_apply-2’
[16:17:44.156] Expression:
[16:17:44.156] {
[16:17:44.156]     do.call(function(...) {
[16:17:44.156]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.156]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.156]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.156]             on.exit(options(oopts), add = TRUE)
[16:17:44.156]         }
[16:17:44.156]         {
[16:17:44.156]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.156]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.156]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.156]             })
[16:17:44.156]         }
[16:17:44.156]     }, args = future.call.arguments)
[16:17:44.156] }
[16:17:44.156] Lazy evaluation: FALSE
[16:17:44.156] Asynchronous evaluation: TRUE
[16:17:44.156] Local evaluation: TRUE
[16:17:44.156] Environment: R_GlobalEnv
[16:17:44.156] Capture standard output: TRUE
[16:17:44.156] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.156] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.156] Packages: <none>
[16:17:44.156] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.156] Resolved: FALSE
[16:17:44.156] Value: <not collected>
[16:17:44.156] Conditions captured: <none>
[16:17:44.156] Early signaling: FALSE
[16:17:44.156] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.156] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.167] Chunk #2 of 2 ... DONE
[16:17:44.168] Launching 2 futures (chunks) ... DONE
[16:17:44.168] Resolving 2 futures (chunks) ...
[16:17:44.168] resolve() on list ...
[16:17:44.168]  recursive: 0
[16:17:44.168]  length: 2
[16:17:44.168] 
[16:17:44.169] receiveMessageFromWorker() for ClusterFuture ...
[16:17:44.169] - Validating connection of MultisessionFuture
[16:17:44.169] - received message: FutureResult
[16:17:44.169] - Received FutureResult
[16:17:44.169] - Erased future from FutureRegistry
[16:17:44.169] result() for ClusterFuture ...
[16:17:44.169] - result already collected: FutureResult
[16:17:44.169] result() for ClusterFuture ... done
[16:17:44.170] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:44.170] Future #1
[16:17:44.170] result() for ClusterFuture ...
[16:17:44.170] - result already collected: FutureResult
[16:17:44.170] result() for ClusterFuture ... done
[16:17:44.170] result() for ClusterFuture ...
[16:17:44.170] - result already collected: FutureResult
[16:17:44.170] result() for ClusterFuture ... done
[16:17:44.170] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:44.170] - nx: 2
[16:17:44.170] - relay: TRUE
[16:17:44.171] - stdout: TRUE
[16:17:44.171] - signal: TRUE
[16:17:44.171] - resignal: FALSE
[16:17:44.171] - force: TRUE
[16:17:44.171] - relayed: [n=2] FALSE, FALSE
[16:17:44.171] - queued futures: [n=2] FALSE, FALSE
[16:17:44.171]  - until=1
[16:17:44.171]  - relaying element #1
[16:17:44.171] result() for ClusterFuture ...
[16:17:44.171] - result already collected: FutureResult
[16:17:44.171] result() for ClusterFuture ... done
[16:17:44.171] result() for ClusterFuture ...
[16:17:44.172] - result already collected: FutureResult
[16:17:44.172] result() for ClusterFuture ... done
[16:17:44.172] result() for ClusterFuture ...
[16:17:44.172] - result already collected: FutureResult
[16:17:44.172] result() for ClusterFuture ... done
[16:17:44.172] result() for ClusterFuture ...
[16:17:44.172] - result already collected: FutureResult
[16:17:44.172] result() for ClusterFuture ... done
[16:17:44.172] - relayed: [n=2] TRUE, FALSE
[16:17:44.172] - queued futures: [n=2] TRUE, FALSE
[16:17:44.172] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:44.173]  length: 1 (resolved future 1)
[16:17:44.235] receiveMessageFromWorker() for ClusterFuture ...
[16:17:44.235] - Validating connection of MultisessionFuture
[16:17:44.235] - received message: FutureResult
[16:17:44.236] - Received FutureResult
[16:17:44.236] - Erased future from FutureRegistry
[16:17:44.236] result() for ClusterFuture ...
[16:17:44.236] - result already collected: FutureResult
[16:17:44.236] result() for ClusterFuture ... done
[16:17:44.236] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:44.236] Future #2
[16:17:44.236] result() for ClusterFuture ...
[16:17:44.236] - result already collected: FutureResult
[16:17:44.236] result() for ClusterFuture ... done
[16:17:44.237] result() for ClusterFuture ...
[16:17:44.237] - result already collected: FutureResult
[16:17:44.237] result() for ClusterFuture ... done
[16:17:44.237] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:44.237] - nx: 2
[16:17:44.237] - relay: TRUE
[16:17:44.237] - stdout: TRUE
[16:17:44.237] - signal: TRUE
[16:17:44.237] - resignal: FALSE
[16:17:44.237] - force: TRUE
[16:17:44.237] - relayed: [n=2] TRUE, FALSE
[16:17:44.237] - queued futures: [n=2] TRUE, FALSE
[16:17:44.238]  - until=2
[16:17:44.238]  - relaying element #2
[16:17:44.238] result() for ClusterFuture ...
[16:17:44.238] - result already collected: FutureResult
[16:17:44.238] result() for ClusterFuture ... done
[16:17:44.238] result() for ClusterFuture ...
[16:17:44.238] - result already collected: FutureResult
[16:17:44.238] result() for ClusterFuture ... done
[16:17:44.238] result() for ClusterFuture ...
[16:17:44.238] - result already collected: FutureResult
[16:17:44.239] result() for ClusterFuture ... done
[16:17:44.239] result() for ClusterFuture ...
[16:17:44.239] - result already collected: FutureResult
[16:17:44.239] result() for ClusterFuture ... done
[16:17:44.239] - relayed: [n=2] TRUE, TRUE
[16:17:44.239] - queued futures: [n=2] TRUE, TRUE
[16:17:44.239] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:44.239]  length: 0 (resolved future 2)
[16:17:44.239] Relaying remaining futures
[16:17:44.239] signalConditionsASAP(NULL, pos=0) ...
[16:17:44.239] - nx: 2
[16:17:44.240] - relay: TRUE
[16:17:44.240] - stdout: TRUE
[16:17:44.240] - signal: TRUE
[16:17:44.240] - resignal: FALSE
[16:17:44.240] - force: TRUE
[16:17:44.240] - relayed: [n=2] TRUE, TRUE
[16:17:44.240] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:44.240] - relayed: [n=2] TRUE, TRUE
[16:17:44.240] - queued futures: [n=2] TRUE, TRUE
[16:17:44.240] signalConditionsASAP(NULL, pos=0) ... done
[16:17:44.240] resolve() on list ... DONE
[16:17:44.241] result() for ClusterFuture ...
[16:17:44.241] - result already collected: FutureResult
[16:17:44.241] result() for ClusterFuture ... done
[16:17:44.241] result() for ClusterFuture ...
[16:17:44.241] - result already collected: FutureResult
[16:17:44.241] result() for ClusterFuture ... done
[16:17:44.241] result() for ClusterFuture ...
[16:17:44.241] - result already collected: FutureResult
[16:17:44.241] result() for ClusterFuture ... done
[16:17:44.241] result() for ClusterFuture ...
[16:17:44.241] - result already collected: FutureResult
[16:17:44.242] result() for ClusterFuture ... done
[16:17:44.242]  - Number of value chunks collected: 2
[16:17:44.242] Resolving 2 futures (chunks) ... DONE
[16:17:44.242] Reducing values from 2 chunks ...
[16:17:44.242]  - Number of values collected after concatenation: 2
[16:17:44.242]  - Number of values expected: 2
[16:17:44.242] Reducing values from 2 chunks ... DONE
[16:17:44.242] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:17:44.243] getGlobalsAndPackagesXApply() ...
[16:17:44.243]  - future.globals: TRUE
[16:17:44.243] getGlobalsAndPackages() ...
[16:17:44.243] Searching for globals...
[16:17:44.274] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:17:44.275] Searching for globals ... DONE
[16:17:44.275] Resolving globals: FALSE
[16:17:44.276] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:17:44.277] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:17:44.277] - globals: [1] ‘FUN’
[16:17:44.277] 
[16:17:44.277] getGlobalsAndPackages() ... DONE
[16:17:44.277]  - globals found/used: [n=1] ‘FUN’
[16:17:44.277]  - needed namespaces: [n=0] 
[16:17:44.277] Finding globals ... DONE
[16:17:44.277]  - use_args: TRUE
[16:17:44.278]  - Getting '...' globals ...
[16:17:44.278] resolve() on list ...
[16:17:44.278]  recursive: 0
[16:17:44.278]  length: 1
[16:17:44.278]  elements: ‘...’
[16:17:44.278]  length: 0 (resolved future 1)
[16:17:44.278] resolve() on list ... DONE
[16:17:44.278]    - '...' content: [n=0] 
[16:17:44.279] List of 1
[16:17:44.279]  $ ...: list()
[16:17:44.279]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.279]  - attr(*, "where")=List of 1
[16:17:44.279]   ..$ ...:<environment: 0x555be1617458> 
[16:17:44.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.279]  - attr(*, "resolved")= logi TRUE
[16:17:44.279]  - attr(*, "total_size")= num NA
[16:17:44.281]  - Getting '...' globals ... DONE
[16:17:44.281] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:44.281] List of 2
[16:17:44.281]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:44.281]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:44.281]  $ ...          : list()
[16:17:44.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.281]  - attr(*, "where")=List of 2
[16:17:44.281]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:44.281]   ..$ ...          :<environment: 0x555be1617458> 
[16:17:44.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.281]  - attr(*, "resolved")= logi FALSE
[16:17:44.281]  - attr(*, "total_size")= num 354224
[16:17:44.284] Packages to be attached in all futures: [n=0] 
[16:17:44.284] getGlobalsAndPackagesXApply() ... DONE
[16:17:44.288] future_lapply() ...
[16:17:44.322] Number of chunks: 2
[16:17:44.322] getGlobalsAndPackagesXApply() ...
[16:17:44.322]  - future.globals: <name-value list> with names ‘list()’
[16:17:44.322]  - use_args: TRUE
[16:17:44.323] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:44.323] List of 2
[16:17:44.323]  $ ...          : list()
[16:17:44.323]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.323]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:17:44.323]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:17:44.323]  - attr(*, "where")=List of 2
[16:17:44.323]   ..$ ...          :<environment: 0x555be1617458> 
[16:17:44.323]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:44.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.323]  - attr(*, "resolved")= logi FALSE
[16:17:44.323]  - attr(*, "total_size")= num NA
[16:17:44.326] Packages to be attached in all futures: [n=0] 
[16:17:44.326] getGlobalsAndPackagesXApply() ... DONE
[16:17:44.326] Number of futures (= number of chunks): 2
[16:17:44.326] Launching 2 futures (chunks) ...
[16:17:44.326] Chunk #1 of 2 ...
[16:17:44.327]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.327]  - seeds: <none>
[16:17:44.327]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.327] getGlobalsAndPackages() ...
[16:17:44.327] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.327] Resolving globals: FALSE
[16:17:44.327] Tweak future expression to call with '...' arguments ...
[16:17:44.327] {
[16:17:44.327]     do.call(function(...) {
[16:17:44.327]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.327]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.327]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.327]             on.exit(options(oopts), add = TRUE)
[16:17:44.327]         }
[16:17:44.327]         {
[16:17:44.327]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.327]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.327]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.327]             })
[16:17:44.327]         }
[16:17:44.327]     }, args = future.call.arguments)
[16:17:44.327] }
[16:17:44.328] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.328] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.328] 
[16:17:44.328] getGlobalsAndPackages() ... DONE
[16:17:44.328] run() for ‘Future’ ...
[16:17:44.329] - state: ‘created’
[16:17:44.329] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:44.342] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.342] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:44.342]   - Field: ‘node’
[16:17:44.342]   - Field: ‘label’
[16:17:44.342]   - Field: ‘local’
[16:17:44.343]   - Field: ‘owner’
[16:17:44.343]   - Field: ‘envir’
[16:17:44.343]   - Field: ‘workers’
[16:17:44.343]   - Field: ‘packages’
[16:17:44.343]   - Field: ‘gc’
[16:17:44.343]   - Field: ‘conditions’
[16:17:44.343]   - Field: ‘persistent’
[16:17:44.343]   - Field: ‘expr’
[16:17:44.343]   - Field: ‘uuid’
[16:17:44.343]   - Field: ‘seed’
[16:17:44.343]   - Field: ‘version’
[16:17:44.344]   - Field: ‘result’
[16:17:44.344]   - Field: ‘asynchronous’
[16:17:44.344]   - Field: ‘calls’
[16:17:44.344]   - Field: ‘globals’
[16:17:44.344]   - Field: ‘stdout’
[16:17:44.344]   - Field: ‘earlySignal’
[16:17:44.344]   - Field: ‘lazy’
[16:17:44.344]   - Field: ‘state’
[16:17:44.344] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:44.344] - Launch lazy future ...
[16:17:44.345] Packages needed by the future expression (n = 0): <none>
[16:17:44.345] Packages needed by future strategies (n = 0): <none>
[16:17:44.345] {
[16:17:44.345]     {
[16:17:44.345]         {
[16:17:44.345]             ...future.startTime <- base::Sys.time()
[16:17:44.345]             {
[16:17:44.345]                 {
[16:17:44.345]                   {
[16:17:44.345]                     {
[16:17:44.345]                       base::local({
[16:17:44.345]                         has_future <- base::requireNamespace("future", 
[16:17:44.345]                           quietly = TRUE)
[16:17:44.345]                         if (has_future) {
[16:17:44.345]                           ns <- base::getNamespace("future")
[16:17:44.345]                           version <- ns[[".package"]][["version"]]
[16:17:44.345]                           if (is.null(version)) 
[16:17:44.345]                             version <- utils::packageVersion("future")
[16:17:44.345]                         }
[16:17:44.345]                         else {
[16:17:44.345]                           version <- NULL
[16:17:44.345]                         }
[16:17:44.345]                         if (!has_future || version < "1.8.0") {
[16:17:44.345]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:44.345]                             "", base::R.version$version.string), 
[16:17:44.345]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:44.345]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:44.345]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:44.345]                               "release", "version")], collapse = " "), 
[16:17:44.345]                             hostname = base::Sys.info()[["nodename"]])
[16:17:44.345]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:44.345]                             info)
[16:17:44.345]                           info <- base::paste(info, collapse = "; ")
[16:17:44.345]                           if (!has_future) {
[16:17:44.345]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:44.345]                               info)
[16:17:44.345]                           }
[16:17:44.345]                           else {
[16:17:44.345]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:44.345]                               info, version)
[16:17:44.345]                           }
[16:17:44.345]                           base::stop(msg)
[16:17:44.345]                         }
[16:17:44.345]                       })
[16:17:44.345]                     }
[16:17:44.345]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:44.345]                     base::options(mc.cores = 1L)
[16:17:44.345]                   }
[16:17:44.345]                   ...future.strategy.old <- future::plan("list")
[16:17:44.345]                   options(future.plan = NULL)
[16:17:44.345]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.345]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:44.345]                 }
[16:17:44.345]                 ...future.workdir <- getwd()
[16:17:44.345]             }
[16:17:44.345]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:44.345]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:44.345]         }
[16:17:44.345]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:44.345]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:44.345]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:44.345]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:44.345]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:44.345]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:44.345]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:44.345]             base::names(...future.oldOptions))
[16:17:44.345]     }
[16:17:44.345]     if (FALSE) {
[16:17:44.345]     }
[16:17:44.345]     else {
[16:17:44.345]         if (TRUE) {
[16:17:44.345]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:44.345]                 open = "w")
[16:17:44.345]         }
[16:17:44.345]         else {
[16:17:44.345]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:44.345]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:44.345]         }
[16:17:44.345]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:44.345]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:44.345]             base::sink(type = "output", split = FALSE)
[16:17:44.345]             base::close(...future.stdout)
[16:17:44.345]         }, add = TRUE)
[16:17:44.345]     }
[16:17:44.345]     ...future.frame <- base::sys.nframe()
[16:17:44.345]     ...future.conditions <- base::list()
[16:17:44.345]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:44.345]     if (FALSE) {
[16:17:44.345]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:44.345]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:44.345]     }
[16:17:44.345]     ...future.result <- base::tryCatch({
[16:17:44.345]         base::withCallingHandlers({
[16:17:44.345]             ...future.value <- base::withVisible(base::local({
[16:17:44.345]                 ...future.makeSendCondition <- base::local({
[16:17:44.345]                   sendCondition <- NULL
[16:17:44.345]                   function(frame = 1L) {
[16:17:44.345]                     if (is.function(sendCondition)) 
[16:17:44.345]                       return(sendCondition)
[16:17:44.345]                     ns <- getNamespace("parallel")
[16:17:44.345]                     if (exists("sendData", mode = "function", 
[16:17:44.345]                       envir = ns)) {
[16:17:44.345]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:44.345]                         envir = ns)
[16:17:44.345]                       envir <- sys.frame(frame)
[16:17:44.345]                       master <- NULL
[16:17:44.345]                       while (!identical(envir, .GlobalEnv) && 
[16:17:44.345]                         !identical(envir, emptyenv())) {
[16:17:44.345]                         if (exists("master", mode = "list", envir = envir, 
[16:17:44.345]                           inherits = FALSE)) {
[16:17:44.345]                           master <- get("master", mode = "list", 
[16:17:44.345]                             envir = envir, inherits = FALSE)
[16:17:44.345]                           if (inherits(master, c("SOCKnode", 
[16:17:44.345]                             "SOCK0node"))) {
[16:17:44.345]                             sendCondition <<- function(cond) {
[16:17:44.345]                               data <- list(type = "VALUE", value = cond, 
[16:17:44.345]                                 success = TRUE)
[16:17:44.345]                               parallel_sendData(master, data)
[16:17:44.345]                             }
[16:17:44.345]                             return(sendCondition)
[16:17:44.345]                           }
[16:17:44.345]                         }
[16:17:44.345]                         frame <- frame + 1L
[16:17:44.345]                         envir <- sys.frame(frame)
[16:17:44.345]                       }
[16:17:44.345]                     }
[16:17:44.345]                     sendCondition <<- function(cond) NULL
[16:17:44.345]                   }
[16:17:44.345]                 })
[16:17:44.345]                 withCallingHandlers({
[16:17:44.345]                   {
[16:17:44.345]                     do.call(function(...) {
[16:17:44.345]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.345]                       if (!identical(...future.globals.maxSize.org, 
[16:17:44.345]                         ...future.globals.maxSize)) {
[16:17:44.345]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.345]                         on.exit(options(oopts), add = TRUE)
[16:17:44.345]                       }
[16:17:44.345]                       {
[16:17:44.345]                         lapply(seq_along(...future.elements_ii), 
[16:17:44.345]                           FUN = function(jj) {
[16:17:44.345]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.345]                             ...future.FUN(...future.X_jj, ...)
[16:17:44.345]                           })
[16:17:44.345]                       }
[16:17:44.345]                     }, args = future.call.arguments)
[16:17:44.345]                   }
[16:17:44.345]                 }, immediateCondition = function(cond) {
[16:17:44.345]                   sendCondition <- ...future.makeSendCondition()
[16:17:44.345]                   sendCondition(cond)
[16:17:44.345]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.345]                   {
[16:17:44.345]                     inherits <- base::inherits
[16:17:44.345]                     invokeRestart <- base::invokeRestart
[16:17:44.345]                     is.null <- base::is.null
[16:17:44.345]                     muffled <- FALSE
[16:17:44.345]                     if (inherits(cond, "message")) {
[16:17:44.345]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:44.345]                       if (muffled) 
[16:17:44.345]                         invokeRestart("muffleMessage")
[16:17:44.345]                     }
[16:17:44.345]                     else if (inherits(cond, "warning")) {
[16:17:44.345]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:44.345]                       if (muffled) 
[16:17:44.345]                         invokeRestart("muffleWarning")
[16:17:44.345]                     }
[16:17:44.345]                     else if (inherits(cond, "condition")) {
[16:17:44.345]                       if (!is.null(pattern)) {
[16:17:44.345]                         computeRestarts <- base::computeRestarts
[16:17:44.345]                         grepl <- base::grepl
[16:17:44.345]                         restarts <- computeRestarts(cond)
[16:17:44.345]                         for (restart in restarts) {
[16:17:44.345]                           name <- restart$name
[16:17:44.345]                           if (is.null(name)) 
[16:17:44.345]                             next
[16:17:44.345]                           if (!grepl(pattern, name)) 
[16:17:44.345]                             next
[16:17:44.345]                           invokeRestart(restart)
[16:17:44.345]                           muffled <- TRUE
[16:17:44.345]                           break
[16:17:44.345]                         }
[16:17:44.345]                       }
[16:17:44.345]                     }
[16:17:44.345]                     invisible(muffled)
[16:17:44.345]                   }
[16:17:44.345]                   muffleCondition(cond)
[16:17:44.345]                 })
[16:17:44.345]             }))
[16:17:44.345]             future::FutureResult(value = ...future.value$value, 
[16:17:44.345]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.345]                   ...future.rng), globalenv = if (FALSE) 
[16:17:44.345]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:44.345]                     ...future.globalenv.names))
[16:17:44.345]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:44.345]         }, condition = base::local({
[16:17:44.345]             c <- base::c
[16:17:44.345]             inherits <- base::inherits
[16:17:44.345]             invokeRestart <- base::invokeRestart
[16:17:44.345]             length <- base::length
[16:17:44.345]             list <- base::list
[16:17:44.345]             seq.int <- base::seq.int
[16:17:44.345]             signalCondition <- base::signalCondition
[16:17:44.345]             sys.calls <- base::sys.calls
[16:17:44.345]             `[[` <- base::`[[`
[16:17:44.345]             `+` <- base::`+`
[16:17:44.345]             `<<-` <- base::`<<-`
[16:17:44.345]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:44.345]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:44.345]                   3L)]
[16:17:44.345]             }
[16:17:44.345]             function(cond) {
[16:17:44.345]                 is_error <- inherits(cond, "error")
[16:17:44.345]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:44.345]                   NULL)
[16:17:44.345]                 if (is_error) {
[16:17:44.345]                   sessionInformation <- function() {
[16:17:44.345]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:44.345]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:44.345]                       search = base::search(), system = base::Sys.info())
[16:17:44.345]                   }
[16:17:44.345]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.345]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:44.345]                     cond$call), session = sessionInformation(), 
[16:17:44.345]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:44.345]                   signalCondition(cond)
[16:17:44.345]                 }
[16:17:44.345]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:44.345]                 "immediateCondition"))) {
[16:17:44.345]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:44.345]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.345]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:44.345]                   if (TRUE && !signal) {
[16:17:44.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.345]                     {
[16:17:44.345]                       inherits <- base::inherits
[16:17:44.345]                       invokeRestart <- base::invokeRestart
[16:17:44.345]                       is.null <- base::is.null
[16:17:44.345]                       muffled <- FALSE
[16:17:44.345]                       if (inherits(cond, "message")) {
[16:17:44.345]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.345]                         if (muffled) 
[16:17:44.345]                           invokeRestart("muffleMessage")
[16:17:44.345]                       }
[16:17:44.345]                       else if (inherits(cond, "warning")) {
[16:17:44.345]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.345]                         if (muffled) 
[16:17:44.345]                           invokeRestart("muffleWarning")
[16:17:44.345]                       }
[16:17:44.345]                       else if (inherits(cond, "condition")) {
[16:17:44.345]                         if (!is.null(pattern)) {
[16:17:44.345]                           computeRestarts <- base::computeRestarts
[16:17:44.345]                           grepl <- base::grepl
[16:17:44.345]                           restarts <- computeRestarts(cond)
[16:17:44.345]                           for (restart in restarts) {
[16:17:44.345]                             name <- restart$name
[16:17:44.345]                             if (is.null(name)) 
[16:17:44.345]                               next
[16:17:44.345]                             if (!grepl(pattern, name)) 
[16:17:44.345]                               next
[16:17:44.345]                             invokeRestart(restart)
[16:17:44.345]                             muffled <- TRUE
[16:17:44.345]                             break
[16:17:44.345]                           }
[16:17:44.345]                         }
[16:17:44.345]                       }
[16:17:44.345]                       invisible(muffled)
[16:17:44.345]                     }
[16:17:44.345]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.345]                   }
[16:17:44.345]                 }
[16:17:44.345]                 else {
[16:17:44.345]                   if (TRUE) {
[16:17:44.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.345]                     {
[16:17:44.345]                       inherits <- base::inherits
[16:17:44.345]                       invokeRestart <- base::invokeRestart
[16:17:44.345]                       is.null <- base::is.null
[16:17:44.345]                       muffled <- FALSE
[16:17:44.345]                       if (inherits(cond, "message")) {
[16:17:44.345]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.345]                         if (muffled) 
[16:17:44.345]                           invokeRestart("muffleMessage")
[16:17:44.345]                       }
[16:17:44.345]                       else if (inherits(cond, "warning")) {
[16:17:44.345]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.345]                         if (muffled) 
[16:17:44.345]                           invokeRestart("muffleWarning")
[16:17:44.345]                       }
[16:17:44.345]                       else if (inherits(cond, "condition")) {
[16:17:44.345]                         if (!is.null(pattern)) {
[16:17:44.345]                           computeRestarts <- base::computeRestarts
[16:17:44.345]                           grepl <- base::grepl
[16:17:44.345]                           restarts <- computeRestarts(cond)
[16:17:44.345]                           for (restart in restarts) {
[16:17:44.345]                             name <- restart$name
[16:17:44.345]                             if (is.null(name)) 
[16:17:44.345]                               next
[16:17:44.345]                             if (!grepl(pattern, name)) 
[16:17:44.345]                               next
[16:17:44.345]                             invokeRestart(restart)
[16:17:44.345]                             muffled <- TRUE
[16:17:44.345]                             break
[16:17:44.345]                           }
[16:17:44.345]                         }
[16:17:44.345]                       }
[16:17:44.345]                       invisible(muffled)
[16:17:44.345]                     }
[16:17:44.345]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.345]                   }
[16:17:44.345]                 }
[16:17:44.345]             }
[16:17:44.345]         }))
[16:17:44.345]     }, error = function(ex) {
[16:17:44.345]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:44.345]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.345]                 ...future.rng), started = ...future.startTime, 
[16:17:44.345]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:44.345]             version = "1.8"), class = "FutureResult")
[16:17:44.345]     }, finally = {
[16:17:44.345]         if (!identical(...future.workdir, getwd())) 
[16:17:44.345]             setwd(...future.workdir)
[16:17:44.345]         {
[16:17:44.345]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:44.345]                 ...future.oldOptions$nwarnings <- NULL
[16:17:44.345]             }
[16:17:44.345]             base::options(...future.oldOptions)
[16:17:44.345]             if (.Platform$OS.type == "windows") {
[16:17:44.345]                 old_names <- names(...future.oldEnvVars)
[16:17:44.345]                 envs <- base::Sys.getenv()
[16:17:44.345]                 names <- names(envs)
[16:17:44.345]                 common <- intersect(names, old_names)
[16:17:44.345]                 added <- setdiff(names, old_names)
[16:17:44.345]                 removed <- setdiff(old_names, names)
[16:17:44.345]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:44.345]                   envs[common]]
[16:17:44.345]                 NAMES <- toupper(changed)
[16:17:44.345]                 args <- list()
[16:17:44.345]                 for (kk in seq_along(NAMES)) {
[16:17:44.345]                   name <- changed[[kk]]
[16:17:44.345]                   NAME <- NAMES[[kk]]
[16:17:44.345]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.345]                     next
[16:17:44.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.345]                 }
[16:17:44.345]                 NAMES <- toupper(added)
[16:17:44.345]                 for (kk in seq_along(NAMES)) {
[16:17:44.345]                   name <- added[[kk]]
[16:17:44.345]                   NAME <- NAMES[[kk]]
[16:17:44.345]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.345]                     next
[16:17:44.345]                   args[[name]] <- ""
[16:17:44.345]                 }
[16:17:44.345]                 NAMES <- toupper(removed)
[16:17:44.345]                 for (kk in seq_along(NAMES)) {
[16:17:44.345]                   name <- removed[[kk]]
[16:17:44.345]                   NAME <- NAMES[[kk]]
[16:17:44.345]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.345]                     next
[16:17:44.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.345]                 }
[16:17:44.345]                 if (length(args) > 0) 
[16:17:44.345]                   base::do.call(base::Sys.setenv, args = args)
[16:17:44.345]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:44.345]             }
[16:17:44.345]             else {
[16:17:44.345]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:44.345]             }
[16:17:44.345]             {
[16:17:44.345]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:44.345]                   0L) {
[16:17:44.345]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:44.345]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:44.345]                   base::options(opts)
[16:17:44.345]                 }
[16:17:44.345]                 {
[16:17:44.345]                   {
[16:17:44.345]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:44.345]                     NULL
[16:17:44.345]                   }
[16:17:44.345]                   options(future.plan = NULL)
[16:17:44.345]                   if (is.na(NA_character_)) 
[16:17:44.345]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.345]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:44.345]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:44.345]                     .init = FALSE)
[16:17:44.345]                 }
[16:17:44.345]             }
[16:17:44.345]         }
[16:17:44.345]     })
[16:17:44.345]     if (TRUE) {
[16:17:44.345]         base::sink(type = "output", split = FALSE)
[16:17:44.345]         if (TRUE) {
[16:17:44.345]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:44.345]         }
[16:17:44.345]         else {
[16:17:44.345]             ...future.result["stdout"] <- base::list(NULL)
[16:17:44.345]         }
[16:17:44.345]         base::close(...future.stdout)
[16:17:44.345]         ...future.stdout <- NULL
[16:17:44.345]     }
[16:17:44.345]     ...future.result$conditions <- ...future.conditions
[16:17:44.345]     ...future.result$finished <- base::Sys.time()
[16:17:44.345]     ...future.result
[16:17:44.345] }
[16:17:44.348] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[16:17:44.349] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:44.349] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.349] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[16:17:44.393] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[16:17:44.393] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:17:44.393] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:17:44.393] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:44.394] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.394] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:17:44.394] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:17:44.394] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[16:17:44.395] MultisessionFuture started
[16:17:44.395] - Launch lazy future ... done
[16:17:44.395] run() for ‘MultisessionFuture’ ... done
[16:17:44.395] Created future:
[16:17:44.396] MultisessionFuture:
[16:17:44.396] Label: ‘future_apply-1’
[16:17:44.396] Expression:
[16:17:44.396] {
[16:17:44.396]     do.call(function(...) {
[16:17:44.396]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.396]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.396]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.396]             on.exit(options(oopts), add = TRUE)
[16:17:44.396]         }
[16:17:44.396]         {
[16:17:44.396]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.396]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.396]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.396]             })
[16:17:44.396]         }
[16:17:44.396]     }, args = future.call.arguments)
[16:17:44.396] }
[16:17:44.396] Lazy evaluation: FALSE
[16:17:44.396] Asynchronous evaluation: TRUE
[16:17:44.396] Local evaluation: TRUE
[16:17:44.396] Environment: R_GlobalEnv
[16:17:44.396] Capture standard output: TRUE
[16:17:44.396] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.396] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.396] Packages: <none>
[16:17:44.396] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.396] Resolved: FALSE
[16:17:44.396] Value: <not collected>
[16:17:44.396] Conditions captured: <none>
[16:17:44.396] Early signaling: FALSE
[16:17:44.396] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.396] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.407] Chunk #1 of 2 ... DONE
[16:17:44.407] Chunk #2 of 2 ...
[16:17:44.407]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.408]  - seeds: <none>
[16:17:44.408]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.408] getGlobalsAndPackages() ...
[16:17:44.408] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.408] Resolving globals: FALSE
[16:17:44.408] Tweak future expression to call with '...' arguments ...
[16:17:44.408] {
[16:17:44.408]     do.call(function(...) {
[16:17:44.408]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.408]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.408]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.408]             on.exit(options(oopts), add = TRUE)
[16:17:44.408]         }
[16:17:44.408]         {
[16:17:44.408]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.408]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.408]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.408]             })
[16:17:44.408]         }
[16:17:44.408]     }, args = future.call.arguments)
[16:17:44.408] }
[16:17:44.408] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.409] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.409] 
[16:17:44.409] getGlobalsAndPackages() ... DONE
[16:17:44.409] run() for ‘Future’ ...
[16:17:44.409] - state: ‘created’
[16:17:44.410] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:44.423] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:44.423]   - Field: ‘node’
[16:17:44.424]   - Field: ‘label’
[16:17:44.424]   - Field: ‘local’
[16:17:44.424]   - Field: ‘owner’
[16:17:44.424]   - Field: ‘envir’
[16:17:44.424]   - Field: ‘workers’
[16:17:44.424]   - Field: ‘packages’
[16:17:44.424]   - Field: ‘gc’
[16:17:44.424]   - Field: ‘conditions’
[16:17:44.424]   - Field: ‘persistent’
[16:17:44.424]   - Field: ‘expr’
[16:17:44.425]   - Field: ‘uuid’
[16:17:44.425]   - Field: ‘seed’
[16:17:44.425]   - Field: ‘version’
[16:17:44.425]   - Field: ‘result’
[16:17:44.425]   - Field: ‘asynchronous’
[16:17:44.425]   - Field: ‘calls’
[16:17:44.425]   - Field: ‘globals’
[16:17:44.425]   - Field: ‘stdout’
[16:17:44.425]   - Field: ‘earlySignal’
[16:17:44.425]   - Field: ‘lazy’
[16:17:44.425]   - Field: ‘state’
[16:17:44.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:44.426] - Launch lazy future ...
[16:17:44.426] Packages needed by the future expression (n = 0): <none>
[16:17:44.426] Packages needed by future strategies (n = 0): <none>
[16:17:44.426] {
[16:17:44.426]     {
[16:17:44.426]         {
[16:17:44.426]             ...future.startTime <- base::Sys.time()
[16:17:44.426]             {
[16:17:44.426]                 {
[16:17:44.426]                   {
[16:17:44.426]                     {
[16:17:44.426]                       base::local({
[16:17:44.426]                         has_future <- base::requireNamespace("future", 
[16:17:44.426]                           quietly = TRUE)
[16:17:44.426]                         if (has_future) {
[16:17:44.426]                           ns <- base::getNamespace("future")
[16:17:44.426]                           version <- ns[[".package"]][["version"]]
[16:17:44.426]                           if (is.null(version)) 
[16:17:44.426]                             version <- utils::packageVersion("future")
[16:17:44.426]                         }
[16:17:44.426]                         else {
[16:17:44.426]                           version <- NULL
[16:17:44.426]                         }
[16:17:44.426]                         if (!has_future || version < "1.8.0") {
[16:17:44.426]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:44.426]                             "", base::R.version$version.string), 
[16:17:44.426]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:44.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:44.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:44.426]                               "release", "version")], collapse = " "), 
[16:17:44.426]                             hostname = base::Sys.info()[["nodename"]])
[16:17:44.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:44.426]                             info)
[16:17:44.426]                           info <- base::paste(info, collapse = "; ")
[16:17:44.426]                           if (!has_future) {
[16:17:44.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:44.426]                               info)
[16:17:44.426]                           }
[16:17:44.426]                           else {
[16:17:44.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:44.426]                               info, version)
[16:17:44.426]                           }
[16:17:44.426]                           base::stop(msg)
[16:17:44.426]                         }
[16:17:44.426]                       })
[16:17:44.426]                     }
[16:17:44.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:44.426]                     base::options(mc.cores = 1L)
[16:17:44.426]                   }
[16:17:44.426]                   ...future.strategy.old <- future::plan("list")
[16:17:44.426]                   options(future.plan = NULL)
[16:17:44.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:44.426]                 }
[16:17:44.426]                 ...future.workdir <- getwd()
[16:17:44.426]             }
[16:17:44.426]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:44.426]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:44.426]         }
[16:17:44.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:44.426]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:44.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:44.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:44.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:44.426]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:44.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:44.426]             base::names(...future.oldOptions))
[16:17:44.426]     }
[16:17:44.426]     if (FALSE) {
[16:17:44.426]     }
[16:17:44.426]     else {
[16:17:44.426]         if (TRUE) {
[16:17:44.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:44.426]                 open = "w")
[16:17:44.426]         }
[16:17:44.426]         else {
[16:17:44.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:44.426]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:44.426]         }
[16:17:44.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:44.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:44.426]             base::sink(type = "output", split = FALSE)
[16:17:44.426]             base::close(...future.stdout)
[16:17:44.426]         }, add = TRUE)
[16:17:44.426]     }
[16:17:44.426]     ...future.frame <- base::sys.nframe()
[16:17:44.426]     ...future.conditions <- base::list()
[16:17:44.426]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:44.426]     if (FALSE) {
[16:17:44.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:44.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:44.426]     }
[16:17:44.426]     ...future.result <- base::tryCatch({
[16:17:44.426]         base::withCallingHandlers({
[16:17:44.426]             ...future.value <- base::withVisible(base::local({
[16:17:44.426]                 ...future.makeSendCondition <- base::local({
[16:17:44.426]                   sendCondition <- NULL
[16:17:44.426]                   function(frame = 1L) {
[16:17:44.426]                     if (is.function(sendCondition)) 
[16:17:44.426]                       return(sendCondition)
[16:17:44.426]                     ns <- getNamespace("parallel")
[16:17:44.426]                     if (exists("sendData", mode = "function", 
[16:17:44.426]                       envir = ns)) {
[16:17:44.426]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:44.426]                         envir = ns)
[16:17:44.426]                       envir <- sys.frame(frame)
[16:17:44.426]                       master <- NULL
[16:17:44.426]                       while (!identical(envir, .GlobalEnv) && 
[16:17:44.426]                         !identical(envir, emptyenv())) {
[16:17:44.426]                         if (exists("master", mode = "list", envir = envir, 
[16:17:44.426]                           inherits = FALSE)) {
[16:17:44.426]                           master <- get("master", mode = "list", 
[16:17:44.426]                             envir = envir, inherits = FALSE)
[16:17:44.426]                           if (inherits(master, c("SOCKnode", 
[16:17:44.426]                             "SOCK0node"))) {
[16:17:44.426]                             sendCondition <<- function(cond) {
[16:17:44.426]                               data <- list(type = "VALUE", value = cond, 
[16:17:44.426]                                 success = TRUE)
[16:17:44.426]                               parallel_sendData(master, data)
[16:17:44.426]                             }
[16:17:44.426]                             return(sendCondition)
[16:17:44.426]                           }
[16:17:44.426]                         }
[16:17:44.426]                         frame <- frame + 1L
[16:17:44.426]                         envir <- sys.frame(frame)
[16:17:44.426]                       }
[16:17:44.426]                     }
[16:17:44.426]                     sendCondition <<- function(cond) NULL
[16:17:44.426]                   }
[16:17:44.426]                 })
[16:17:44.426]                 withCallingHandlers({
[16:17:44.426]                   {
[16:17:44.426]                     do.call(function(...) {
[16:17:44.426]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.426]                       if (!identical(...future.globals.maxSize.org, 
[16:17:44.426]                         ...future.globals.maxSize)) {
[16:17:44.426]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.426]                         on.exit(options(oopts), add = TRUE)
[16:17:44.426]                       }
[16:17:44.426]                       {
[16:17:44.426]                         lapply(seq_along(...future.elements_ii), 
[16:17:44.426]                           FUN = function(jj) {
[16:17:44.426]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.426]                             ...future.FUN(...future.X_jj, ...)
[16:17:44.426]                           })
[16:17:44.426]                       }
[16:17:44.426]                     }, args = future.call.arguments)
[16:17:44.426]                   }
[16:17:44.426]                 }, immediateCondition = function(cond) {
[16:17:44.426]                   sendCondition <- ...future.makeSendCondition()
[16:17:44.426]                   sendCondition(cond)
[16:17:44.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.426]                   {
[16:17:44.426]                     inherits <- base::inherits
[16:17:44.426]                     invokeRestart <- base::invokeRestart
[16:17:44.426]                     is.null <- base::is.null
[16:17:44.426]                     muffled <- FALSE
[16:17:44.426]                     if (inherits(cond, "message")) {
[16:17:44.426]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:44.426]                       if (muffled) 
[16:17:44.426]                         invokeRestart("muffleMessage")
[16:17:44.426]                     }
[16:17:44.426]                     else if (inherits(cond, "warning")) {
[16:17:44.426]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:44.426]                       if (muffled) 
[16:17:44.426]                         invokeRestart("muffleWarning")
[16:17:44.426]                     }
[16:17:44.426]                     else if (inherits(cond, "condition")) {
[16:17:44.426]                       if (!is.null(pattern)) {
[16:17:44.426]                         computeRestarts <- base::computeRestarts
[16:17:44.426]                         grepl <- base::grepl
[16:17:44.426]                         restarts <- computeRestarts(cond)
[16:17:44.426]                         for (restart in restarts) {
[16:17:44.426]                           name <- restart$name
[16:17:44.426]                           if (is.null(name)) 
[16:17:44.426]                             next
[16:17:44.426]                           if (!grepl(pattern, name)) 
[16:17:44.426]                             next
[16:17:44.426]                           invokeRestart(restart)
[16:17:44.426]                           muffled <- TRUE
[16:17:44.426]                           break
[16:17:44.426]                         }
[16:17:44.426]                       }
[16:17:44.426]                     }
[16:17:44.426]                     invisible(muffled)
[16:17:44.426]                   }
[16:17:44.426]                   muffleCondition(cond)
[16:17:44.426]                 })
[16:17:44.426]             }))
[16:17:44.426]             future::FutureResult(value = ...future.value$value, 
[16:17:44.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.426]                   ...future.rng), globalenv = if (FALSE) 
[16:17:44.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:44.426]                     ...future.globalenv.names))
[16:17:44.426]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:44.426]         }, condition = base::local({
[16:17:44.426]             c <- base::c
[16:17:44.426]             inherits <- base::inherits
[16:17:44.426]             invokeRestart <- base::invokeRestart
[16:17:44.426]             length <- base::length
[16:17:44.426]             list <- base::list
[16:17:44.426]             seq.int <- base::seq.int
[16:17:44.426]             signalCondition <- base::signalCondition
[16:17:44.426]             sys.calls <- base::sys.calls
[16:17:44.426]             `[[` <- base::`[[`
[16:17:44.426]             `+` <- base::`+`
[16:17:44.426]             `<<-` <- base::`<<-`
[16:17:44.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:44.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:44.426]                   3L)]
[16:17:44.426]             }
[16:17:44.426]             function(cond) {
[16:17:44.426]                 is_error <- inherits(cond, "error")
[16:17:44.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:44.426]                   NULL)
[16:17:44.426]                 if (is_error) {
[16:17:44.426]                   sessionInformation <- function() {
[16:17:44.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:44.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:44.426]                       search = base::search(), system = base::Sys.info())
[16:17:44.426]                   }
[16:17:44.426]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:44.426]                     cond$call), session = sessionInformation(), 
[16:17:44.426]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:44.426]                   signalCondition(cond)
[16:17:44.426]                 }
[16:17:44.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:44.426]                 "immediateCondition"))) {
[16:17:44.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:44.426]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:44.426]                   if (TRUE && !signal) {
[16:17:44.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.426]                     {
[16:17:44.426]                       inherits <- base::inherits
[16:17:44.426]                       invokeRestart <- base::invokeRestart
[16:17:44.426]                       is.null <- base::is.null
[16:17:44.426]                       muffled <- FALSE
[16:17:44.426]                       if (inherits(cond, "message")) {
[16:17:44.426]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.426]                         if (muffled) 
[16:17:44.426]                           invokeRestart("muffleMessage")
[16:17:44.426]                       }
[16:17:44.426]                       else if (inherits(cond, "warning")) {
[16:17:44.426]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.426]                         if (muffled) 
[16:17:44.426]                           invokeRestart("muffleWarning")
[16:17:44.426]                       }
[16:17:44.426]                       else if (inherits(cond, "condition")) {
[16:17:44.426]                         if (!is.null(pattern)) {
[16:17:44.426]                           computeRestarts <- base::computeRestarts
[16:17:44.426]                           grepl <- base::grepl
[16:17:44.426]                           restarts <- computeRestarts(cond)
[16:17:44.426]                           for (restart in restarts) {
[16:17:44.426]                             name <- restart$name
[16:17:44.426]                             if (is.null(name)) 
[16:17:44.426]                               next
[16:17:44.426]                             if (!grepl(pattern, name)) 
[16:17:44.426]                               next
[16:17:44.426]                             invokeRestart(restart)
[16:17:44.426]                             muffled <- TRUE
[16:17:44.426]                             break
[16:17:44.426]                           }
[16:17:44.426]                         }
[16:17:44.426]                       }
[16:17:44.426]                       invisible(muffled)
[16:17:44.426]                     }
[16:17:44.426]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.426]                   }
[16:17:44.426]                 }
[16:17:44.426]                 else {
[16:17:44.426]                   if (TRUE) {
[16:17:44.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.426]                     {
[16:17:44.426]                       inherits <- base::inherits
[16:17:44.426]                       invokeRestart <- base::invokeRestart
[16:17:44.426]                       is.null <- base::is.null
[16:17:44.426]                       muffled <- FALSE
[16:17:44.426]                       if (inherits(cond, "message")) {
[16:17:44.426]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.426]                         if (muffled) 
[16:17:44.426]                           invokeRestart("muffleMessage")
[16:17:44.426]                       }
[16:17:44.426]                       else if (inherits(cond, "warning")) {
[16:17:44.426]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.426]                         if (muffled) 
[16:17:44.426]                           invokeRestart("muffleWarning")
[16:17:44.426]                       }
[16:17:44.426]                       else if (inherits(cond, "condition")) {
[16:17:44.426]                         if (!is.null(pattern)) {
[16:17:44.426]                           computeRestarts <- base::computeRestarts
[16:17:44.426]                           grepl <- base::grepl
[16:17:44.426]                           restarts <- computeRestarts(cond)
[16:17:44.426]                           for (restart in restarts) {
[16:17:44.426]                             name <- restart$name
[16:17:44.426]                             if (is.null(name)) 
[16:17:44.426]                               next
[16:17:44.426]                             if (!grepl(pattern, name)) 
[16:17:44.426]                               next
[16:17:44.426]                             invokeRestart(restart)
[16:17:44.426]                             muffled <- TRUE
[16:17:44.426]                             break
[16:17:44.426]                           }
[16:17:44.426]                         }
[16:17:44.426]                       }
[16:17:44.426]                       invisible(muffled)
[16:17:44.426]                     }
[16:17:44.426]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.426]                   }
[16:17:44.426]                 }
[16:17:44.426]             }
[16:17:44.426]         }))
[16:17:44.426]     }, error = function(ex) {
[16:17:44.426]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:44.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.426]                 ...future.rng), started = ...future.startTime, 
[16:17:44.426]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:44.426]             version = "1.8"), class = "FutureResult")
[16:17:44.426]     }, finally = {
[16:17:44.426]         if (!identical(...future.workdir, getwd())) 
[16:17:44.426]             setwd(...future.workdir)
[16:17:44.426]         {
[16:17:44.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:44.426]                 ...future.oldOptions$nwarnings <- NULL
[16:17:44.426]             }
[16:17:44.426]             base::options(...future.oldOptions)
[16:17:44.426]             if (.Platform$OS.type == "windows") {
[16:17:44.426]                 old_names <- names(...future.oldEnvVars)
[16:17:44.426]                 envs <- base::Sys.getenv()
[16:17:44.426]                 names <- names(envs)
[16:17:44.426]                 common <- intersect(names, old_names)
[16:17:44.426]                 added <- setdiff(names, old_names)
[16:17:44.426]                 removed <- setdiff(old_names, names)
[16:17:44.426]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:44.426]                   envs[common]]
[16:17:44.426]                 NAMES <- toupper(changed)
[16:17:44.426]                 args <- list()
[16:17:44.426]                 for (kk in seq_along(NAMES)) {
[16:17:44.426]                   name <- changed[[kk]]
[16:17:44.426]                   NAME <- NAMES[[kk]]
[16:17:44.426]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.426]                     next
[16:17:44.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.426]                 }
[16:17:44.426]                 NAMES <- toupper(added)
[16:17:44.426]                 for (kk in seq_along(NAMES)) {
[16:17:44.426]                   name <- added[[kk]]
[16:17:44.426]                   NAME <- NAMES[[kk]]
[16:17:44.426]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.426]                     next
[16:17:44.426]                   args[[name]] <- ""
[16:17:44.426]                 }
[16:17:44.426]                 NAMES <- toupper(removed)
[16:17:44.426]                 for (kk in seq_along(NAMES)) {
[16:17:44.426]                   name <- removed[[kk]]
[16:17:44.426]                   NAME <- NAMES[[kk]]
[16:17:44.426]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.426]                     next
[16:17:44.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.426]                 }
[16:17:44.426]                 if (length(args) > 0) 
[16:17:44.426]                   base::do.call(base::Sys.setenv, args = args)
[16:17:44.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:44.426]             }
[16:17:44.426]             else {
[16:17:44.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:44.426]             }
[16:17:44.426]             {
[16:17:44.426]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:44.426]                   0L) {
[16:17:44.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:44.426]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:44.426]                   base::options(opts)
[16:17:44.426]                 }
[16:17:44.426]                 {
[16:17:44.426]                   {
[16:17:44.426]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:44.426]                     NULL
[16:17:44.426]                   }
[16:17:44.426]                   options(future.plan = NULL)
[16:17:44.426]                   if (is.na(NA_character_)) 
[16:17:44.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:44.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:44.426]                     .init = FALSE)
[16:17:44.426]                 }
[16:17:44.426]             }
[16:17:44.426]         }
[16:17:44.426]     })
[16:17:44.426]     if (TRUE) {
[16:17:44.426]         base::sink(type = "output", split = FALSE)
[16:17:44.426]         if (TRUE) {
[16:17:44.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:44.426]         }
[16:17:44.426]         else {
[16:17:44.426]             ...future.result["stdout"] <- base::list(NULL)
[16:17:44.426]         }
[16:17:44.426]         base::close(...future.stdout)
[16:17:44.426]         ...future.stdout <- NULL
[16:17:44.426]     }
[16:17:44.426]     ...future.result$conditions <- ...future.conditions
[16:17:44.426]     ...future.result$finished <- base::Sys.time()
[16:17:44.426]     ...future.result
[16:17:44.426] }
[16:17:44.429] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[16:17:44.430] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:44.433] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:44.434] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[16:17:44.477] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[16:17:44.477] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:17:44.477] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:17:44.478] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:44.478] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:44.478] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:17:44.478] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:17:44.479] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[16:17:44.479] MultisessionFuture started
[16:17:44.479] - Launch lazy future ... done
[16:17:44.479] run() for ‘MultisessionFuture’ ... done
[16:17:44.480] Created future:
[16:17:44.480] MultisessionFuture:
[16:17:44.480] Label: ‘future_apply-2’
[16:17:44.480] Expression:
[16:17:44.480] {
[16:17:44.480]     do.call(function(...) {
[16:17:44.480]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.480]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.480]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.480]             on.exit(options(oopts), add = TRUE)
[16:17:44.480]         }
[16:17:44.480]         {
[16:17:44.480]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.480]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.480]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.480]             })
[16:17:44.480]         }
[16:17:44.480]     }, args = future.call.arguments)
[16:17:44.480] }
[16:17:44.480] Lazy evaluation: FALSE
[16:17:44.480] Asynchronous evaluation: TRUE
[16:17:44.480] Local evaluation: TRUE
[16:17:44.480] Environment: R_GlobalEnv
[16:17:44.480] Capture standard output: TRUE
[16:17:44.480] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.480] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.480] Packages: <none>
[16:17:44.480] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.480] Resolved: FALSE
[16:17:44.480] Value: <not collected>
[16:17:44.480] Conditions captured: <none>
[16:17:44.480] Early signaling: FALSE
[16:17:44.480] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.480] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.491] Chunk #2 of 2 ... DONE
[16:17:44.491] Launching 2 futures (chunks) ... DONE
[16:17:44.492] Resolving 2 futures (chunks) ...
[16:17:44.492] resolve() on list ...
[16:17:44.492]  recursive: 0
[16:17:44.492]  length: 2
[16:17:44.492] 
[16:17:44.492] receiveMessageFromWorker() for ClusterFuture ...
[16:17:44.493] - Validating connection of MultisessionFuture
[16:17:44.493] - received message: FutureResult
[16:17:44.493] - Received FutureResult
[16:17:44.493] - Erased future from FutureRegistry
[16:17:44.493] result() for ClusterFuture ...
[16:17:44.493] - result already collected: FutureResult
[16:17:44.493] result() for ClusterFuture ... done
[16:17:44.493] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:44.493] Future #1
[16:17:44.493] result() for ClusterFuture ...
[16:17:44.494] - result already collected: FutureResult
[16:17:44.494] result() for ClusterFuture ... done
[16:17:44.494] result() for ClusterFuture ...
[16:17:44.494] - result already collected: FutureResult
[16:17:44.494] result() for ClusterFuture ... done
[16:17:44.494] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:44.494] - nx: 2
[16:17:44.494] - relay: TRUE
[16:17:44.494] - stdout: TRUE
[16:17:44.494] - signal: TRUE
[16:17:44.494] - resignal: FALSE
[16:17:44.495] - force: TRUE
[16:17:44.495] - relayed: [n=2] FALSE, FALSE
[16:17:44.495] - queued futures: [n=2] FALSE, FALSE
[16:17:44.495]  - until=1
[16:17:44.495]  - relaying element #1
[16:17:44.495] result() for ClusterFuture ...
[16:17:44.495] - result already collected: FutureResult
[16:17:44.495] result() for ClusterFuture ... done
[16:17:44.495] result() for ClusterFuture ...
[16:17:44.495] - result already collected: FutureResult
[16:17:44.495] result() for ClusterFuture ... done
[16:17:44.496] result() for ClusterFuture ...
[16:17:44.496] - result already collected: FutureResult
[16:17:44.496] result() for ClusterFuture ... done
[16:17:44.496] result() for ClusterFuture ...
[16:17:44.496] - result already collected: FutureResult
[16:17:44.496] result() for ClusterFuture ... done
[16:17:44.498] - relayed: [n=2] TRUE, FALSE
[16:17:44.498] - queued futures: [n=2] TRUE, FALSE
[16:17:44.498] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:44.498]  length: 1 (resolved future 1)
[16:17:44.522] receiveMessageFromWorker() for ClusterFuture ...
[16:17:44.522] - Validating connection of MultisessionFuture
[16:17:44.522] - received message: FutureResult
[16:17:44.522] - Received FutureResult
[16:17:44.522] - Erased future from FutureRegistry
[16:17:44.522] result() for ClusterFuture ...
[16:17:44.523] - result already collected: FutureResult
[16:17:44.523] result() for ClusterFuture ... done
[16:17:44.523] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:44.523] Future #2
[16:17:44.523] result() for ClusterFuture ...
[16:17:44.523] - result already collected: FutureResult
[16:17:44.523] result() for ClusterFuture ... done
[16:17:44.523] result() for ClusterFuture ...
[16:17:44.523] - result already collected: FutureResult
[16:17:44.523] result() for ClusterFuture ... done
[16:17:44.523] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:44.523] - nx: 2
[16:17:44.524] - relay: TRUE
[16:17:44.524] - stdout: TRUE
[16:17:44.524] - signal: TRUE
[16:17:44.524] - resignal: FALSE
[16:17:44.524] - force: TRUE
[16:17:44.524] - relayed: [n=2] TRUE, FALSE
[16:17:44.524] - queued futures: [n=2] TRUE, FALSE
[16:17:44.524]  - until=2
[16:17:44.524]  - relaying element #2
[16:17:44.524] result() for ClusterFuture ...
[16:17:44.524] - result already collected: FutureResult
[16:17:44.525] result() for ClusterFuture ... done
[16:17:44.525] result() for ClusterFuture ...
[16:17:44.525] - result already collected: FutureResult
[16:17:44.525] result() for ClusterFuture ... done
[16:17:44.525] result() for ClusterFuture ...
[16:17:44.525] - result already collected: FutureResult
[16:17:44.525] result() for ClusterFuture ... done
[16:17:44.525] result() for ClusterFuture ...
[16:17:44.525] - result already collected: FutureResult
[16:17:44.525] result() for ClusterFuture ... done
[16:17:44.525] - relayed: [n=2] TRUE, TRUE
[16:17:44.525] - queued futures: [n=2] TRUE, TRUE
[16:17:44.526] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:44.526]  length: 0 (resolved future 2)
[16:17:44.526] Relaying remaining futures
[16:17:44.526] signalConditionsASAP(NULL, pos=0) ...
[16:17:44.526] - nx: 2
[16:17:44.526] - relay: TRUE
[16:17:44.526] - stdout: TRUE
[16:17:44.526] - signal: TRUE
[16:17:44.526] - resignal: FALSE
[16:17:44.526] - force: TRUE
[16:17:44.526] - relayed: [n=2] TRUE, TRUE
[16:17:44.526] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:44.527] - relayed: [n=2] TRUE, TRUE
[16:17:44.527] - queued futures: [n=2] TRUE, TRUE
[16:17:44.527] signalConditionsASAP(NULL, pos=0) ... done
[16:17:44.527] resolve() on list ... DONE
[16:17:44.527] result() for ClusterFuture ...
[16:17:44.527] - result already collected: FutureResult
[16:17:44.527] result() for ClusterFuture ... done
[16:17:44.527] result() for ClusterFuture ...
[16:17:44.527] - result already collected: FutureResult
[16:17:44.527] result() for ClusterFuture ... done
[16:17:44.527] result() for ClusterFuture ...
[16:17:44.528] - result already collected: FutureResult
[16:17:44.528] result() for ClusterFuture ... done
[16:17:44.528] result() for ClusterFuture ...
[16:17:44.528] - result already collected: FutureResult
[16:17:44.528] result() for ClusterFuture ... done
[16:17:44.528]  - Number of value chunks collected: 2
[16:17:44.528] Resolving 2 futures (chunks) ... DONE
[16:17:44.528] Reducing values from 2 chunks ...
[16:17:44.528]  - Number of values collected after concatenation: 2
[16:17:44.528]  - Number of values expected: 2
[16:17:44.528] Reducing values from 2 chunks ... DONE
[16:17:44.529] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:17:44.529] getGlobalsAndPackagesXApply() ...
[16:17:44.529]  - future.globals: TRUE
[16:17:44.530] getGlobalsAndPackages() ...
[16:17:44.530] Searching for globals...
[16:17:44.531] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:44.531] Searching for globals ... DONE
[16:17:44.531] Resolving globals: FALSE
[16:17:44.531] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:44.532] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:44.532] - globals: [1] ‘FUN’
[16:17:44.532] - packages: [1] ‘stats’
[16:17:44.532] getGlobalsAndPackages() ... DONE
[16:17:44.532]  - globals found/used: [n=1] ‘FUN’
[16:17:44.532]  - needed namespaces: [n=1] ‘stats’
[16:17:44.532] Finding globals ... DONE
[16:17:44.532]  - use_args: TRUE
[16:17:44.532]  - Getting '...' globals ...
[16:17:44.533] resolve() on list ...
[16:17:44.533]  recursive: 0
[16:17:44.533]  length: 1
[16:17:44.533]  elements: ‘...’
[16:17:44.533]  length: 0 (resolved future 1)
[16:17:44.533] resolve() on list ... DONE
[16:17:44.533]    - '...' content: [n=0] 
[16:17:44.533] List of 1
[16:17:44.533]  $ ...: list()
[16:17:44.533]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.533]  - attr(*, "where")=List of 1
[16:17:44.533]   ..$ ...:<environment: 0x555be2640c30> 
[16:17:44.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.533]  - attr(*, "resolved")= logi TRUE
[16:17:44.533]  - attr(*, "total_size")= num NA
[16:17:44.536]  - Getting '...' globals ... DONE
[16:17:44.536] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:44.536] List of 2
[16:17:44.536]  $ ...future.FUN:function (x, ...)  
[16:17:44.536]  $ ...          : list()
[16:17:44.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.536]  - attr(*, "where")=List of 2
[16:17:44.536]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:44.536]   ..$ ...          :<environment: 0x555be2640c30> 
[16:17:44.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.536]  - attr(*, "resolved")= logi FALSE
[16:17:44.536]  - attr(*, "total_size")= num 1248
[16:17:44.539] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:44.539] getGlobalsAndPackagesXApply() ... DONE
[16:17:44.542] future_lapply() ...
[16:17:44.546] Number of chunks: 2
[16:17:44.546] getGlobalsAndPackagesXApply() ...
[16:17:44.546]  - future.globals: <name-value list> with names ‘list()’
[16:17:44.546]  - use_args: TRUE
[16:17:44.546] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:44.547] List of 2
[16:17:44.547]  $ ...          : list()
[16:17:44.547]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.547]  $ ...future.FUN:function (x, ...)  
[16:17:44.547]  - attr(*, "where")=List of 2
[16:17:44.547]   ..$ ...          :<environment: 0x555be2640c30> 
[16:17:44.547]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:17:44.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.547]  - attr(*, "resolved")= logi FALSE
[16:17:44.547]  - attr(*, "total_size")= num NA
[16:17:44.549] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:44.549] getGlobalsAndPackagesXApply() ... DONE
[16:17:44.550] Number of futures (= number of chunks): 2
[16:17:44.550] Launching 2 futures (chunks) ...
[16:17:44.550] Chunk #1 of 2 ...
[16:17:44.550]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.550]  - seeds: <none>
[16:17:44.550]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.550] getGlobalsAndPackages() ...
[16:17:44.550] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.551] Resolving globals: FALSE
[16:17:44.551] Tweak future expression to call with '...' arguments ...
[16:17:44.551] {
[16:17:44.551]     do.call(function(...) {
[16:17:44.551]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.551]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.551]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.551]             on.exit(options(oopts), add = TRUE)
[16:17:44.551]         }
[16:17:44.551]         {
[16:17:44.551]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.551]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.551]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.551]             })
[16:17:44.551]         }
[16:17:44.551]     }, args = future.call.arguments)
[16:17:44.551] }
[16:17:44.551] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.551] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.552] - packages: [1] ‘stats’
[16:17:44.552] getGlobalsAndPackages() ... DONE
[16:17:44.552] run() for ‘Future’ ...
[16:17:44.552] - state: ‘created’
[16:17:44.552] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:44.566] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:44.566]   - Field: ‘node’
[16:17:44.566]   - Field: ‘label’
[16:17:44.566]   - Field: ‘local’
[16:17:44.566]   - Field: ‘owner’
[16:17:44.566]   - Field: ‘envir’
[16:17:44.566]   - Field: ‘workers’
[16:17:44.567]   - Field: ‘packages’
[16:17:44.567]   - Field: ‘gc’
[16:17:44.567]   - Field: ‘conditions’
[16:17:44.567]   - Field: ‘persistent’
[16:17:44.567]   - Field: ‘expr’
[16:17:44.567]   - Field: ‘uuid’
[16:17:44.567]   - Field: ‘seed’
[16:17:44.567]   - Field: ‘version’
[16:17:44.567]   - Field: ‘result’
[16:17:44.567]   - Field: ‘asynchronous’
[16:17:44.567]   - Field: ‘calls’
[16:17:44.568]   - Field: ‘globals’
[16:17:44.568]   - Field: ‘stdout’
[16:17:44.568]   - Field: ‘earlySignal’
[16:17:44.568]   - Field: ‘lazy’
[16:17:44.568]   - Field: ‘state’
[16:17:44.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:44.568] - Launch lazy future ...
[16:17:44.568] Packages needed by the future expression (n = 1): ‘stats’
[16:17:44.568] Packages needed by future strategies (n = 0): <none>
[16:17:44.569] {
[16:17:44.569]     {
[16:17:44.569]         {
[16:17:44.569]             ...future.startTime <- base::Sys.time()
[16:17:44.569]             {
[16:17:44.569]                 {
[16:17:44.569]                   {
[16:17:44.569]                     {
[16:17:44.569]                       {
[16:17:44.569]                         base::local({
[16:17:44.569]                           has_future <- base::requireNamespace("future", 
[16:17:44.569]                             quietly = TRUE)
[16:17:44.569]                           if (has_future) {
[16:17:44.569]                             ns <- base::getNamespace("future")
[16:17:44.569]                             version <- ns[[".package"]][["version"]]
[16:17:44.569]                             if (is.null(version)) 
[16:17:44.569]                               version <- utils::packageVersion("future")
[16:17:44.569]                           }
[16:17:44.569]                           else {
[16:17:44.569]                             version <- NULL
[16:17:44.569]                           }
[16:17:44.569]                           if (!has_future || version < "1.8.0") {
[16:17:44.569]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:44.569]                               "", base::R.version$version.string), 
[16:17:44.569]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:44.569]                                 base::R.version$platform, 8 * 
[16:17:44.569]                                   base::.Machine$sizeof.pointer), 
[16:17:44.569]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:44.569]                                 "release", "version")], collapse = " "), 
[16:17:44.569]                               hostname = base::Sys.info()[["nodename"]])
[16:17:44.569]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:44.569]                               info)
[16:17:44.569]                             info <- base::paste(info, collapse = "; ")
[16:17:44.569]                             if (!has_future) {
[16:17:44.569]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:44.569]                                 info)
[16:17:44.569]                             }
[16:17:44.569]                             else {
[16:17:44.569]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:44.569]                                 info, version)
[16:17:44.569]                             }
[16:17:44.569]                             base::stop(msg)
[16:17:44.569]                           }
[16:17:44.569]                         })
[16:17:44.569]                       }
[16:17:44.569]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:44.569]                       base::options(mc.cores = 1L)
[16:17:44.569]                     }
[16:17:44.569]                     base::local({
[16:17:44.569]                       for (pkg in "stats") {
[16:17:44.569]                         base::loadNamespace(pkg)
[16:17:44.569]                         base::library(pkg, character.only = TRUE)
[16:17:44.569]                       }
[16:17:44.569]                     })
[16:17:44.569]                   }
[16:17:44.569]                   ...future.strategy.old <- future::plan("list")
[16:17:44.569]                   options(future.plan = NULL)
[16:17:44.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:44.569]                 }
[16:17:44.569]                 ...future.workdir <- getwd()
[16:17:44.569]             }
[16:17:44.569]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:44.569]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:44.569]         }
[16:17:44.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:44.569]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:44.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:44.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:44.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:44.569]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:44.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:44.569]             base::names(...future.oldOptions))
[16:17:44.569]     }
[16:17:44.569]     if (FALSE) {
[16:17:44.569]     }
[16:17:44.569]     else {
[16:17:44.569]         if (TRUE) {
[16:17:44.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:44.569]                 open = "w")
[16:17:44.569]         }
[16:17:44.569]         else {
[16:17:44.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:44.569]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:44.569]         }
[16:17:44.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:44.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:44.569]             base::sink(type = "output", split = FALSE)
[16:17:44.569]             base::close(...future.stdout)
[16:17:44.569]         }, add = TRUE)
[16:17:44.569]     }
[16:17:44.569]     ...future.frame <- base::sys.nframe()
[16:17:44.569]     ...future.conditions <- base::list()
[16:17:44.569]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:44.569]     if (FALSE) {
[16:17:44.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:44.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:44.569]     }
[16:17:44.569]     ...future.result <- base::tryCatch({
[16:17:44.569]         base::withCallingHandlers({
[16:17:44.569]             ...future.value <- base::withVisible(base::local({
[16:17:44.569]                 ...future.makeSendCondition <- base::local({
[16:17:44.569]                   sendCondition <- NULL
[16:17:44.569]                   function(frame = 1L) {
[16:17:44.569]                     if (is.function(sendCondition)) 
[16:17:44.569]                       return(sendCondition)
[16:17:44.569]                     ns <- getNamespace("parallel")
[16:17:44.569]                     if (exists("sendData", mode = "function", 
[16:17:44.569]                       envir = ns)) {
[16:17:44.569]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:44.569]                         envir = ns)
[16:17:44.569]                       envir <- sys.frame(frame)
[16:17:44.569]                       master <- NULL
[16:17:44.569]                       while (!identical(envir, .GlobalEnv) && 
[16:17:44.569]                         !identical(envir, emptyenv())) {
[16:17:44.569]                         if (exists("master", mode = "list", envir = envir, 
[16:17:44.569]                           inherits = FALSE)) {
[16:17:44.569]                           master <- get("master", mode = "list", 
[16:17:44.569]                             envir = envir, inherits = FALSE)
[16:17:44.569]                           if (inherits(master, c("SOCKnode", 
[16:17:44.569]                             "SOCK0node"))) {
[16:17:44.569]                             sendCondition <<- function(cond) {
[16:17:44.569]                               data <- list(type = "VALUE", value = cond, 
[16:17:44.569]                                 success = TRUE)
[16:17:44.569]                               parallel_sendData(master, data)
[16:17:44.569]                             }
[16:17:44.569]                             return(sendCondition)
[16:17:44.569]                           }
[16:17:44.569]                         }
[16:17:44.569]                         frame <- frame + 1L
[16:17:44.569]                         envir <- sys.frame(frame)
[16:17:44.569]                       }
[16:17:44.569]                     }
[16:17:44.569]                     sendCondition <<- function(cond) NULL
[16:17:44.569]                   }
[16:17:44.569]                 })
[16:17:44.569]                 withCallingHandlers({
[16:17:44.569]                   {
[16:17:44.569]                     do.call(function(...) {
[16:17:44.569]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.569]                       if (!identical(...future.globals.maxSize.org, 
[16:17:44.569]                         ...future.globals.maxSize)) {
[16:17:44.569]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.569]                         on.exit(options(oopts), add = TRUE)
[16:17:44.569]                       }
[16:17:44.569]                       {
[16:17:44.569]                         lapply(seq_along(...future.elements_ii), 
[16:17:44.569]                           FUN = function(jj) {
[16:17:44.569]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.569]                             ...future.FUN(...future.X_jj, ...)
[16:17:44.569]                           })
[16:17:44.569]                       }
[16:17:44.569]                     }, args = future.call.arguments)
[16:17:44.569]                   }
[16:17:44.569]                 }, immediateCondition = function(cond) {
[16:17:44.569]                   sendCondition <- ...future.makeSendCondition()
[16:17:44.569]                   sendCondition(cond)
[16:17:44.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.569]                   {
[16:17:44.569]                     inherits <- base::inherits
[16:17:44.569]                     invokeRestart <- base::invokeRestart
[16:17:44.569]                     is.null <- base::is.null
[16:17:44.569]                     muffled <- FALSE
[16:17:44.569]                     if (inherits(cond, "message")) {
[16:17:44.569]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:44.569]                       if (muffled) 
[16:17:44.569]                         invokeRestart("muffleMessage")
[16:17:44.569]                     }
[16:17:44.569]                     else if (inherits(cond, "warning")) {
[16:17:44.569]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:44.569]                       if (muffled) 
[16:17:44.569]                         invokeRestart("muffleWarning")
[16:17:44.569]                     }
[16:17:44.569]                     else if (inherits(cond, "condition")) {
[16:17:44.569]                       if (!is.null(pattern)) {
[16:17:44.569]                         computeRestarts <- base::computeRestarts
[16:17:44.569]                         grepl <- base::grepl
[16:17:44.569]                         restarts <- computeRestarts(cond)
[16:17:44.569]                         for (restart in restarts) {
[16:17:44.569]                           name <- restart$name
[16:17:44.569]                           if (is.null(name)) 
[16:17:44.569]                             next
[16:17:44.569]                           if (!grepl(pattern, name)) 
[16:17:44.569]                             next
[16:17:44.569]                           invokeRestart(restart)
[16:17:44.569]                           muffled <- TRUE
[16:17:44.569]                           break
[16:17:44.569]                         }
[16:17:44.569]                       }
[16:17:44.569]                     }
[16:17:44.569]                     invisible(muffled)
[16:17:44.569]                   }
[16:17:44.569]                   muffleCondition(cond)
[16:17:44.569]                 })
[16:17:44.569]             }))
[16:17:44.569]             future::FutureResult(value = ...future.value$value, 
[16:17:44.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.569]                   ...future.rng), globalenv = if (FALSE) 
[16:17:44.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:44.569]                     ...future.globalenv.names))
[16:17:44.569]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:44.569]         }, condition = base::local({
[16:17:44.569]             c <- base::c
[16:17:44.569]             inherits <- base::inherits
[16:17:44.569]             invokeRestart <- base::invokeRestart
[16:17:44.569]             length <- base::length
[16:17:44.569]             list <- base::list
[16:17:44.569]             seq.int <- base::seq.int
[16:17:44.569]             signalCondition <- base::signalCondition
[16:17:44.569]             sys.calls <- base::sys.calls
[16:17:44.569]             `[[` <- base::`[[`
[16:17:44.569]             `+` <- base::`+`
[16:17:44.569]             `<<-` <- base::`<<-`
[16:17:44.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:44.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:44.569]                   3L)]
[16:17:44.569]             }
[16:17:44.569]             function(cond) {
[16:17:44.569]                 is_error <- inherits(cond, "error")
[16:17:44.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:44.569]                   NULL)
[16:17:44.569]                 if (is_error) {
[16:17:44.569]                   sessionInformation <- function() {
[16:17:44.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:44.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:44.569]                       search = base::search(), system = base::Sys.info())
[16:17:44.569]                   }
[16:17:44.569]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:44.569]                     cond$call), session = sessionInformation(), 
[16:17:44.569]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:44.569]                   signalCondition(cond)
[16:17:44.569]                 }
[16:17:44.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:44.569]                 "immediateCondition"))) {
[16:17:44.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:44.569]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:44.569]                   if (TRUE && !signal) {
[16:17:44.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.569]                     {
[16:17:44.569]                       inherits <- base::inherits
[16:17:44.569]                       invokeRestart <- base::invokeRestart
[16:17:44.569]                       is.null <- base::is.null
[16:17:44.569]                       muffled <- FALSE
[16:17:44.569]                       if (inherits(cond, "message")) {
[16:17:44.569]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.569]                         if (muffled) 
[16:17:44.569]                           invokeRestart("muffleMessage")
[16:17:44.569]                       }
[16:17:44.569]                       else if (inherits(cond, "warning")) {
[16:17:44.569]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.569]                         if (muffled) 
[16:17:44.569]                           invokeRestart("muffleWarning")
[16:17:44.569]                       }
[16:17:44.569]                       else if (inherits(cond, "condition")) {
[16:17:44.569]                         if (!is.null(pattern)) {
[16:17:44.569]                           computeRestarts <- base::computeRestarts
[16:17:44.569]                           grepl <- base::grepl
[16:17:44.569]                           restarts <- computeRestarts(cond)
[16:17:44.569]                           for (restart in restarts) {
[16:17:44.569]                             name <- restart$name
[16:17:44.569]                             if (is.null(name)) 
[16:17:44.569]                               next
[16:17:44.569]                             if (!grepl(pattern, name)) 
[16:17:44.569]                               next
[16:17:44.569]                             invokeRestart(restart)
[16:17:44.569]                             muffled <- TRUE
[16:17:44.569]                             break
[16:17:44.569]                           }
[16:17:44.569]                         }
[16:17:44.569]                       }
[16:17:44.569]                       invisible(muffled)
[16:17:44.569]                     }
[16:17:44.569]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.569]                   }
[16:17:44.569]                 }
[16:17:44.569]                 else {
[16:17:44.569]                   if (TRUE) {
[16:17:44.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.569]                     {
[16:17:44.569]                       inherits <- base::inherits
[16:17:44.569]                       invokeRestart <- base::invokeRestart
[16:17:44.569]                       is.null <- base::is.null
[16:17:44.569]                       muffled <- FALSE
[16:17:44.569]                       if (inherits(cond, "message")) {
[16:17:44.569]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.569]                         if (muffled) 
[16:17:44.569]                           invokeRestart("muffleMessage")
[16:17:44.569]                       }
[16:17:44.569]                       else if (inherits(cond, "warning")) {
[16:17:44.569]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.569]                         if (muffled) 
[16:17:44.569]                           invokeRestart("muffleWarning")
[16:17:44.569]                       }
[16:17:44.569]                       else if (inherits(cond, "condition")) {
[16:17:44.569]                         if (!is.null(pattern)) {
[16:17:44.569]                           computeRestarts <- base::computeRestarts
[16:17:44.569]                           grepl <- base::grepl
[16:17:44.569]                           restarts <- computeRestarts(cond)
[16:17:44.569]                           for (restart in restarts) {
[16:17:44.569]                             name <- restart$name
[16:17:44.569]                             if (is.null(name)) 
[16:17:44.569]                               next
[16:17:44.569]                             if (!grepl(pattern, name)) 
[16:17:44.569]                               next
[16:17:44.569]                             invokeRestart(restart)
[16:17:44.569]                             muffled <- TRUE
[16:17:44.569]                             break
[16:17:44.569]                           }
[16:17:44.569]                         }
[16:17:44.569]                       }
[16:17:44.569]                       invisible(muffled)
[16:17:44.569]                     }
[16:17:44.569]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.569]                   }
[16:17:44.569]                 }
[16:17:44.569]             }
[16:17:44.569]         }))
[16:17:44.569]     }, error = function(ex) {
[16:17:44.569]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:44.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.569]                 ...future.rng), started = ...future.startTime, 
[16:17:44.569]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:44.569]             version = "1.8"), class = "FutureResult")
[16:17:44.569]     }, finally = {
[16:17:44.569]         if (!identical(...future.workdir, getwd())) 
[16:17:44.569]             setwd(...future.workdir)
[16:17:44.569]         {
[16:17:44.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:44.569]                 ...future.oldOptions$nwarnings <- NULL
[16:17:44.569]             }
[16:17:44.569]             base::options(...future.oldOptions)
[16:17:44.569]             if (.Platform$OS.type == "windows") {
[16:17:44.569]                 old_names <- names(...future.oldEnvVars)
[16:17:44.569]                 envs <- base::Sys.getenv()
[16:17:44.569]                 names <- names(envs)
[16:17:44.569]                 common <- intersect(names, old_names)
[16:17:44.569]                 added <- setdiff(names, old_names)
[16:17:44.569]                 removed <- setdiff(old_names, names)
[16:17:44.569]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:44.569]                   envs[common]]
[16:17:44.569]                 NAMES <- toupper(changed)
[16:17:44.569]                 args <- list()
[16:17:44.569]                 for (kk in seq_along(NAMES)) {
[16:17:44.569]                   name <- changed[[kk]]
[16:17:44.569]                   NAME <- NAMES[[kk]]
[16:17:44.569]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.569]                     next
[16:17:44.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.569]                 }
[16:17:44.569]                 NAMES <- toupper(added)
[16:17:44.569]                 for (kk in seq_along(NAMES)) {
[16:17:44.569]                   name <- added[[kk]]
[16:17:44.569]                   NAME <- NAMES[[kk]]
[16:17:44.569]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.569]                     next
[16:17:44.569]                   args[[name]] <- ""
[16:17:44.569]                 }
[16:17:44.569]                 NAMES <- toupper(removed)
[16:17:44.569]                 for (kk in seq_along(NAMES)) {
[16:17:44.569]                   name <- removed[[kk]]
[16:17:44.569]                   NAME <- NAMES[[kk]]
[16:17:44.569]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.569]                     next
[16:17:44.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.569]                 }
[16:17:44.569]                 if (length(args) > 0) 
[16:17:44.569]                   base::do.call(base::Sys.setenv, args = args)
[16:17:44.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:44.569]             }
[16:17:44.569]             else {
[16:17:44.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:44.569]             }
[16:17:44.569]             {
[16:17:44.569]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:44.569]                   0L) {
[16:17:44.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:44.569]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:44.569]                   base::options(opts)
[16:17:44.569]                 }
[16:17:44.569]                 {
[16:17:44.569]                   {
[16:17:44.569]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:44.569]                     NULL
[16:17:44.569]                   }
[16:17:44.569]                   options(future.plan = NULL)
[16:17:44.569]                   if (is.na(NA_character_)) 
[16:17:44.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:44.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:44.569]                     .init = FALSE)
[16:17:44.569]                 }
[16:17:44.569]             }
[16:17:44.569]         }
[16:17:44.569]     })
[16:17:44.569]     if (TRUE) {
[16:17:44.569]         base::sink(type = "output", split = FALSE)
[16:17:44.569]         if (TRUE) {
[16:17:44.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:44.569]         }
[16:17:44.569]         else {
[16:17:44.569]             ...future.result["stdout"] <- base::list(NULL)
[16:17:44.569]         }
[16:17:44.569]         base::close(...future.stdout)
[16:17:44.569]         ...future.stdout <- NULL
[16:17:44.569]     }
[16:17:44.569]     ...future.result$conditions <- ...future.conditions
[16:17:44.569]     ...future.result$finished <- base::Sys.time()
[16:17:44.569]     ...future.result
[16:17:44.569] }
[16:17:44.572] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[16:17:44.572] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:44.572] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.573] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:17:44.573] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:17:44.573] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:17:44.574] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:17:44.574] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:44.574] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.574] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:17:44.574] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:17:44.575] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[16:17:44.575] MultisessionFuture started
[16:17:44.575] - Launch lazy future ... done
[16:17:44.575] run() for ‘MultisessionFuture’ ... done
[16:17:44.576] Created future:
[16:17:44.576] MultisessionFuture:
[16:17:44.576] Label: ‘future_apply-1’
[16:17:44.576] Expression:
[16:17:44.576] {
[16:17:44.576]     do.call(function(...) {
[16:17:44.576]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.576]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.576]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.576]             on.exit(options(oopts), add = TRUE)
[16:17:44.576]         }
[16:17:44.576]         {
[16:17:44.576]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.576]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.576]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.576]             })
[16:17:44.576]         }
[16:17:44.576]     }, args = future.call.arguments)
[16:17:44.576] }
[16:17:44.576] Lazy evaluation: FALSE
[16:17:44.576] Asynchronous evaluation: TRUE
[16:17:44.576] Local evaluation: TRUE
[16:17:44.576] Environment: R_GlobalEnv
[16:17:44.576] Capture standard output: TRUE
[16:17:44.576] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.576] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.576] Packages: 1 packages (‘stats’)
[16:17:44.576] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.576] Resolved: FALSE
[16:17:44.576] Value: <not collected>
[16:17:44.576] Conditions captured: <none>
[16:17:44.576] Early signaling: FALSE
[16:17:44.576] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.576] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.587] Chunk #1 of 2 ... DONE
[16:17:44.587] Chunk #2 of 2 ...
[16:17:44.588]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.588]  - seeds: <none>
[16:17:44.588]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.588] getGlobalsAndPackages() ...
[16:17:44.588] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.588] Resolving globals: FALSE
[16:17:44.588] Tweak future expression to call with '...' arguments ...
[16:17:44.588] {
[16:17:44.588]     do.call(function(...) {
[16:17:44.588]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.588]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.588]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.588]             on.exit(options(oopts), add = TRUE)
[16:17:44.588]         }
[16:17:44.588]         {
[16:17:44.588]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.588]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.588]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.588]             })
[16:17:44.588]         }
[16:17:44.588]     }, args = future.call.arguments)
[16:17:44.588] }
[16:17:44.589] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.589] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.589] - packages: [1] ‘stats’
[16:17:44.589] getGlobalsAndPackages() ... DONE
[16:17:44.590] run() for ‘Future’ ...
[16:17:44.590] - state: ‘created’
[16:17:44.590] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:44.603] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:44.603]   - Field: ‘node’
[16:17:44.603]   - Field: ‘label’
[16:17:44.604]   - Field: ‘local’
[16:17:44.604]   - Field: ‘owner’
[16:17:44.604]   - Field: ‘envir’
[16:17:44.604]   - Field: ‘workers’
[16:17:44.604]   - Field: ‘packages’
[16:17:44.604]   - Field: ‘gc’
[16:17:44.604]   - Field: ‘conditions’
[16:17:44.604]   - Field: ‘persistent’
[16:17:44.604]   - Field: ‘expr’
[16:17:44.604]   - Field: ‘uuid’
[16:17:44.605]   - Field: ‘seed’
[16:17:44.605]   - Field: ‘version’
[16:17:44.605]   - Field: ‘result’
[16:17:44.605]   - Field: ‘asynchronous’
[16:17:44.605]   - Field: ‘calls’
[16:17:44.605]   - Field: ‘globals’
[16:17:44.605]   - Field: ‘stdout’
[16:17:44.605]   - Field: ‘earlySignal’
[16:17:44.605]   - Field: ‘lazy’
[16:17:44.605]   - Field: ‘state’
[16:17:44.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:44.605] - Launch lazy future ...
[16:17:44.606] Packages needed by the future expression (n = 1): ‘stats’
[16:17:44.606] Packages needed by future strategies (n = 0): <none>
[16:17:44.606] {
[16:17:44.606]     {
[16:17:44.606]         {
[16:17:44.606]             ...future.startTime <- base::Sys.time()
[16:17:44.606]             {
[16:17:44.606]                 {
[16:17:44.606]                   {
[16:17:44.606]                     {
[16:17:44.606]                       {
[16:17:44.606]                         base::local({
[16:17:44.606]                           has_future <- base::requireNamespace("future", 
[16:17:44.606]                             quietly = TRUE)
[16:17:44.606]                           if (has_future) {
[16:17:44.606]                             ns <- base::getNamespace("future")
[16:17:44.606]                             version <- ns[[".package"]][["version"]]
[16:17:44.606]                             if (is.null(version)) 
[16:17:44.606]                               version <- utils::packageVersion("future")
[16:17:44.606]                           }
[16:17:44.606]                           else {
[16:17:44.606]                             version <- NULL
[16:17:44.606]                           }
[16:17:44.606]                           if (!has_future || version < "1.8.0") {
[16:17:44.606]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:44.606]                               "", base::R.version$version.string), 
[16:17:44.606]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:44.606]                                 base::R.version$platform, 8 * 
[16:17:44.606]                                   base::.Machine$sizeof.pointer), 
[16:17:44.606]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:44.606]                                 "release", "version")], collapse = " "), 
[16:17:44.606]                               hostname = base::Sys.info()[["nodename"]])
[16:17:44.606]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:44.606]                               info)
[16:17:44.606]                             info <- base::paste(info, collapse = "; ")
[16:17:44.606]                             if (!has_future) {
[16:17:44.606]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:44.606]                                 info)
[16:17:44.606]                             }
[16:17:44.606]                             else {
[16:17:44.606]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:44.606]                                 info, version)
[16:17:44.606]                             }
[16:17:44.606]                             base::stop(msg)
[16:17:44.606]                           }
[16:17:44.606]                         })
[16:17:44.606]                       }
[16:17:44.606]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:44.606]                       base::options(mc.cores = 1L)
[16:17:44.606]                     }
[16:17:44.606]                     base::local({
[16:17:44.606]                       for (pkg in "stats") {
[16:17:44.606]                         base::loadNamespace(pkg)
[16:17:44.606]                         base::library(pkg, character.only = TRUE)
[16:17:44.606]                       }
[16:17:44.606]                     })
[16:17:44.606]                   }
[16:17:44.606]                   ...future.strategy.old <- future::plan("list")
[16:17:44.606]                   options(future.plan = NULL)
[16:17:44.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:44.606]                 }
[16:17:44.606]                 ...future.workdir <- getwd()
[16:17:44.606]             }
[16:17:44.606]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:44.606]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:44.606]         }
[16:17:44.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:44.606]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:44.606]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:44.606]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:44.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:44.606]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:44.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:44.606]             base::names(...future.oldOptions))
[16:17:44.606]     }
[16:17:44.606]     if (FALSE) {
[16:17:44.606]     }
[16:17:44.606]     else {
[16:17:44.606]         if (TRUE) {
[16:17:44.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:44.606]                 open = "w")
[16:17:44.606]         }
[16:17:44.606]         else {
[16:17:44.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:44.606]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:44.606]         }
[16:17:44.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:44.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:44.606]             base::sink(type = "output", split = FALSE)
[16:17:44.606]             base::close(...future.stdout)
[16:17:44.606]         }, add = TRUE)
[16:17:44.606]     }
[16:17:44.606]     ...future.frame <- base::sys.nframe()
[16:17:44.606]     ...future.conditions <- base::list()
[16:17:44.606]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:44.606]     if (FALSE) {
[16:17:44.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:44.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:44.606]     }
[16:17:44.606]     ...future.result <- base::tryCatch({
[16:17:44.606]         base::withCallingHandlers({
[16:17:44.606]             ...future.value <- base::withVisible(base::local({
[16:17:44.606]                 ...future.makeSendCondition <- base::local({
[16:17:44.606]                   sendCondition <- NULL
[16:17:44.606]                   function(frame = 1L) {
[16:17:44.606]                     if (is.function(sendCondition)) 
[16:17:44.606]                       return(sendCondition)
[16:17:44.606]                     ns <- getNamespace("parallel")
[16:17:44.606]                     if (exists("sendData", mode = "function", 
[16:17:44.606]                       envir = ns)) {
[16:17:44.606]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:44.606]                         envir = ns)
[16:17:44.606]                       envir <- sys.frame(frame)
[16:17:44.606]                       master <- NULL
[16:17:44.606]                       while (!identical(envir, .GlobalEnv) && 
[16:17:44.606]                         !identical(envir, emptyenv())) {
[16:17:44.606]                         if (exists("master", mode = "list", envir = envir, 
[16:17:44.606]                           inherits = FALSE)) {
[16:17:44.606]                           master <- get("master", mode = "list", 
[16:17:44.606]                             envir = envir, inherits = FALSE)
[16:17:44.606]                           if (inherits(master, c("SOCKnode", 
[16:17:44.606]                             "SOCK0node"))) {
[16:17:44.606]                             sendCondition <<- function(cond) {
[16:17:44.606]                               data <- list(type = "VALUE", value = cond, 
[16:17:44.606]                                 success = TRUE)
[16:17:44.606]                               parallel_sendData(master, data)
[16:17:44.606]                             }
[16:17:44.606]                             return(sendCondition)
[16:17:44.606]                           }
[16:17:44.606]                         }
[16:17:44.606]                         frame <- frame + 1L
[16:17:44.606]                         envir <- sys.frame(frame)
[16:17:44.606]                       }
[16:17:44.606]                     }
[16:17:44.606]                     sendCondition <<- function(cond) NULL
[16:17:44.606]                   }
[16:17:44.606]                 })
[16:17:44.606]                 withCallingHandlers({
[16:17:44.606]                   {
[16:17:44.606]                     do.call(function(...) {
[16:17:44.606]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.606]                       if (!identical(...future.globals.maxSize.org, 
[16:17:44.606]                         ...future.globals.maxSize)) {
[16:17:44.606]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.606]                         on.exit(options(oopts), add = TRUE)
[16:17:44.606]                       }
[16:17:44.606]                       {
[16:17:44.606]                         lapply(seq_along(...future.elements_ii), 
[16:17:44.606]                           FUN = function(jj) {
[16:17:44.606]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.606]                             ...future.FUN(...future.X_jj, ...)
[16:17:44.606]                           })
[16:17:44.606]                       }
[16:17:44.606]                     }, args = future.call.arguments)
[16:17:44.606]                   }
[16:17:44.606]                 }, immediateCondition = function(cond) {
[16:17:44.606]                   sendCondition <- ...future.makeSendCondition()
[16:17:44.606]                   sendCondition(cond)
[16:17:44.606]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.606]                   {
[16:17:44.606]                     inherits <- base::inherits
[16:17:44.606]                     invokeRestart <- base::invokeRestart
[16:17:44.606]                     is.null <- base::is.null
[16:17:44.606]                     muffled <- FALSE
[16:17:44.606]                     if (inherits(cond, "message")) {
[16:17:44.606]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:44.606]                       if (muffled) 
[16:17:44.606]                         invokeRestart("muffleMessage")
[16:17:44.606]                     }
[16:17:44.606]                     else if (inherits(cond, "warning")) {
[16:17:44.606]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:44.606]                       if (muffled) 
[16:17:44.606]                         invokeRestart("muffleWarning")
[16:17:44.606]                     }
[16:17:44.606]                     else if (inherits(cond, "condition")) {
[16:17:44.606]                       if (!is.null(pattern)) {
[16:17:44.606]                         computeRestarts <- base::computeRestarts
[16:17:44.606]                         grepl <- base::grepl
[16:17:44.606]                         restarts <- computeRestarts(cond)
[16:17:44.606]                         for (restart in restarts) {
[16:17:44.606]                           name <- restart$name
[16:17:44.606]                           if (is.null(name)) 
[16:17:44.606]                             next
[16:17:44.606]                           if (!grepl(pattern, name)) 
[16:17:44.606]                             next
[16:17:44.606]                           invokeRestart(restart)
[16:17:44.606]                           muffled <- TRUE
[16:17:44.606]                           break
[16:17:44.606]                         }
[16:17:44.606]                       }
[16:17:44.606]                     }
[16:17:44.606]                     invisible(muffled)
[16:17:44.606]                   }
[16:17:44.606]                   muffleCondition(cond)
[16:17:44.606]                 })
[16:17:44.606]             }))
[16:17:44.606]             future::FutureResult(value = ...future.value$value, 
[16:17:44.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.606]                   ...future.rng), globalenv = if (FALSE) 
[16:17:44.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:44.606]                     ...future.globalenv.names))
[16:17:44.606]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:44.606]         }, condition = base::local({
[16:17:44.606]             c <- base::c
[16:17:44.606]             inherits <- base::inherits
[16:17:44.606]             invokeRestart <- base::invokeRestart
[16:17:44.606]             length <- base::length
[16:17:44.606]             list <- base::list
[16:17:44.606]             seq.int <- base::seq.int
[16:17:44.606]             signalCondition <- base::signalCondition
[16:17:44.606]             sys.calls <- base::sys.calls
[16:17:44.606]             `[[` <- base::`[[`
[16:17:44.606]             `+` <- base::`+`
[16:17:44.606]             `<<-` <- base::`<<-`
[16:17:44.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:44.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:44.606]                   3L)]
[16:17:44.606]             }
[16:17:44.606]             function(cond) {
[16:17:44.606]                 is_error <- inherits(cond, "error")
[16:17:44.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:44.606]                   NULL)
[16:17:44.606]                 if (is_error) {
[16:17:44.606]                   sessionInformation <- function() {
[16:17:44.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:44.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:44.606]                       search = base::search(), system = base::Sys.info())
[16:17:44.606]                   }
[16:17:44.606]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:44.606]                     cond$call), session = sessionInformation(), 
[16:17:44.606]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:44.606]                   signalCondition(cond)
[16:17:44.606]                 }
[16:17:44.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:44.606]                 "immediateCondition"))) {
[16:17:44.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:44.606]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:44.606]                   if (TRUE && !signal) {
[16:17:44.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.606]                     {
[16:17:44.606]                       inherits <- base::inherits
[16:17:44.606]                       invokeRestart <- base::invokeRestart
[16:17:44.606]                       is.null <- base::is.null
[16:17:44.606]                       muffled <- FALSE
[16:17:44.606]                       if (inherits(cond, "message")) {
[16:17:44.606]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.606]                         if (muffled) 
[16:17:44.606]                           invokeRestart("muffleMessage")
[16:17:44.606]                       }
[16:17:44.606]                       else if (inherits(cond, "warning")) {
[16:17:44.606]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.606]                         if (muffled) 
[16:17:44.606]                           invokeRestart("muffleWarning")
[16:17:44.606]                       }
[16:17:44.606]                       else if (inherits(cond, "condition")) {
[16:17:44.606]                         if (!is.null(pattern)) {
[16:17:44.606]                           computeRestarts <- base::computeRestarts
[16:17:44.606]                           grepl <- base::grepl
[16:17:44.606]                           restarts <- computeRestarts(cond)
[16:17:44.606]                           for (restart in restarts) {
[16:17:44.606]                             name <- restart$name
[16:17:44.606]                             if (is.null(name)) 
[16:17:44.606]                               next
[16:17:44.606]                             if (!grepl(pattern, name)) 
[16:17:44.606]                               next
[16:17:44.606]                             invokeRestart(restart)
[16:17:44.606]                             muffled <- TRUE
[16:17:44.606]                             break
[16:17:44.606]                           }
[16:17:44.606]                         }
[16:17:44.606]                       }
[16:17:44.606]                       invisible(muffled)
[16:17:44.606]                     }
[16:17:44.606]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.606]                   }
[16:17:44.606]                 }
[16:17:44.606]                 else {
[16:17:44.606]                   if (TRUE) {
[16:17:44.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.606]                     {
[16:17:44.606]                       inherits <- base::inherits
[16:17:44.606]                       invokeRestart <- base::invokeRestart
[16:17:44.606]                       is.null <- base::is.null
[16:17:44.606]                       muffled <- FALSE
[16:17:44.606]                       if (inherits(cond, "message")) {
[16:17:44.606]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.606]                         if (muffled) 
[16:17:44.606]                           invokeRestart("muffleMessage")
[16:17:44.606]                       }
[16:17:44.606]                       else if (inherits(cond, "warning")) {
[16:17:44.606]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.606]                         if (muffled) 
[16:17:44.606]                           invokeRestart("muffleWarning")
[16:17:44.606]                       }
[16:17:44.606]                       else if (inherits(cond, "condition")) {
[16:17:44.606]                         if (!is.null(pattern)) {
[16:17:44.606]                           computeRestarts <- base::computeRestarts
[16:17:44.606]                           grepl <- base::grepl
[16:17:44.606]                           restarts <- computeRestarts(cond)
[16:17:44.606]                           for (restart in restarts) {
[16:17:44.606]                             name <- restart$name
[16:17:44.606]                             if (is.null(name)) 
[16:17:44.606]                               next
[16:17:44.606]                             if (!grepl(pattern, name)) 
[16:17:44.606]                               next
[16:17:44.606]                             invokeRestart(restart)
[16:17:44.606]                             muffled <- TRUE
[16:17:44.606]                             break
[16:17:44.606]                           }
[16:17:44.606]                         }
[16:17:44.606]                       }
[16:17:44.606]                       invisible(muffled)
[16:17:44.606]                     }
[16:17:44.606]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.606]                   }
[16:17:44.606]                 }
[16:17:44.606]             }
[16:17:44.606]         }))
[16:17:44.606]     }, error = function(ex) {
[16:17:44.606]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:44.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.606]                 ...future.rng), started = ...future.startTime, 
[16:17:44.606]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:44.606]             version = "1.8"), class = "FutureResult")
[16:17:44.606]     }, finally = {
[16:17:44.606]         if (!identical(...future.workdir, getwd())) 
[16:17:44.606]             setwd(...future.workdir)
[16:17:44.606]         {
[16:17:44.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:44.606]                 ...future.oldOptions$nwarnings <- NULL
[16:17:44.606]             }
[16:17:44.606]             base::options(...future.oldOptions)
[16:17:44.606]             if (.Platform$OS.type == "windows") {
[16:17:44.606]                 old_names <- names(...future.oldEnvVars)
[16:17:44.606]                 envs <- base::Sys.getenv()
[16:17:44.606]                 names <- names(envs)
[16:17:44.606]                 common <- intersect(names, old_names)
[16:17:44.606]                 added <- setdiff(names, old_names)
[16:17:44.606]                 removed <- setdiff(old_names, names)
[16:17:44.606]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:44.606]                   envs[common]]
[16:17:44.606]                 NAMES <- toupper(changed)
[16:17:44.606]                 args <- list()
[16:17:44.606]                 for (kk in seq_along(NAMES)) {
[16:17:44.606]                   name <- changed[[kk]]
[16:17:44.606]                   NAME <- NAMES[[kk]]
[16:17:44.606]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.606]                     next
[16:17:44.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.606]                 }
[16:17:44.606]                 NAMES <- toupper(added)
[16:17:44.606]                 for (kk in seq_along(NAMES)) {
[16:17:44.606]                   name <- added[[kk]]
[16:17:44.606]                   NAME <- NAMES[[kk]]
[16:17:44.606]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.606]                     next
[16:17:44.606]                   args[[name]] <- ""
[16:17:44.606]                 }
[16:17:44.606]                 NAMES <- toupper(removed)
[16:17:44.606]                 for (kk in seq_along(NAMES)) {
[16:17:44.606]                   name <- removed[[kk]]
[16:17:44.606]                   NAME <- NAMES[[kk]]
[16:17:44.606]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.606]                     next
[16:17:44.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.606]                 }
[16:17:44.606]                 if (length(args) > 0) 
[16:17:44.606]                   base::do.call(base::Sys.setenv, args = args)
[16:17:44.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:44.606]             }
[16:17:44.606]             else {
[16:17:44.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:44.606]             }
[16:17:44.606]             {
[16:17:44.606]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:44.606]                   0L) {
[16:17:44.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:44.606]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:44.606]                   base::options(opts)
[16:17:44.606]                 }
[16:17:44.606]                 {
[16:17:44.606]                   {
[16:17:44.606]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:44.606]                     NULL
[16:17:44.606]                   }
[16:17:44.606]                   options(future.plan = NULL)
[16:17:44.606]                   if (is.na(NA_character_)) 
[16:17:44.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:44.606]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:44.606]                     .init = FALSE)
[16:17:44.606]                 }
[16:17:44.606]             }
[16:17:44.606]         }
[16:17:44.606]     })
[16:17:44.606]     if (TRUE) {
[16:17:44.606]         base::sink(type = "output", split = FALSE)
[16:17:44.606]         if (TRUE) {
[16:17:44.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:44.606]         }
[16:17:44.606]         else {
[16:17:44.606]             ...future.result["stdout"] <- base::list(NULL)
[16:17:44.606]         }
[16:17:44.606]         base::close(...future.stdout)
[16:17:44.606]         ...future.stdout <- NULL
[16:17:44.606]     }
[16:17:44.606]     ...future.result$conditions <- ...future.conditions
[16:17:44.606]     ...future.result$finished <- base::Sys.time()
[16:17:44.606]     ...future.result
[16:17:44.606] }
[16:17:44.609] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[16:17:44.609] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:44.610] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:44.610] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:17:44.610] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:17:44.610] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:17:44.611] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:17:44.611] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:44.611] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:44.611] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:17:44.611] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:17:44.611] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[16:17:44.612] MultisessionFuture started
[16:17:44.612] - Launch lazy future ... done
[16:17:44.612] run() for ‘MultisessionFuture’ ... done
[16:17:44.612] Created future:
[16:17:44.612] MultisessionFuture:
[16:17:44.612] Label: ‘future_apply-2’
[16:17:44.612] Expression:
[16:17:44.612] {
[16:17:44.612]     do.call(function(...) {
[16:17:44.612]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.612]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.612]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.612]             on.exit(options(oopts), add = TRUE)
[16:17:44.612]         }
[16:17:44.612]         {
[16:17:44.612]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.612]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.612]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.612]             })
[16:17:44.612]         }
[16:17:44.612]     }, args = future.call.arguments)
[16:17:44.612] }
[16:17:44.612] Lazy evaluation: FALSE
[16:17:44.612] Asynchronous evaluation: TRUE
[16:17:44.612] Local evaluation: TRUE
[16:17:44.612] Environment: R_GlobalEnv
[16:17:44.612] Capture standard output: TRUE
[16:17:44.612] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.612] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.612] Packages: 1 packages (‘stats’)
[16:17:44.612] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.612] Resolved: FALSE
[16:17:44.612] Value: <not collected>
[16:17:44.612] Conditions captured: <none>
[16:17:44.612] Early signaling: FALSE
[16:17:44.612] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.612] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.624] Chunk #2 of 2 ... DONE
[16:17:44.624] Launching 2 futures (chunks) ... DONE
[16:17:44.624] Resolving 2 futures (chunks) ...
[16:17:44.624] resolve() on list ...
[16:17:44.624]  recursive: 0
[16:17:44.624]  length: 2
[16:17:44.625] 
[16:17:44.625] receiveMessageFromWorker() for ClusterFuture ...
[16:17:44.625] - Validating connection of MultisessionFuture
[16:17:44.625] - received message: FutureResult
[16:17:44.625] - Received FutureResult
[16:17:44.625] - Erased future from FutureRegistry
[16:17:44.626] result() for ClusterFuture ...
[16:17:44.626] - result already collected: FutureResult
[16:17:44.626] result() for ClusterFuture ... done
[16:17:44.626] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:44.626] Future #1
[16:17:44.626] result() for ClusterFuture ...
[16:17:44.626] - result already collected: FutureResult
[16:17:44.626] result() for ClusterFuture ... done
[16:17:44.626] result() for ClusterFuture ...
[16:17:44.626] - result already collected: FutureResult
[16:17:44.626] result() for ClusterFuture ... done
[16:17:44.627] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:44.627] - nx: 2
[16:17:44.627] - relay: TRUE
[16:17:44.627] - stdout: TRUE
[16:17:44.627] - signal: TRUE
[16:17:44.627] - resignal: FALSE
[16:17:44.627] - force: TRUE
[16:17:44.627] - relayed: [n=2] FALSE, FALSE
[16:17:44.627] - queued futures: [n=2] FALSE, FALSE
[16:17:44.627]  - until=1
[16:17:44.627]  - relaying element #1
[16:17:44.627] result() for ClusterFuture ...
[16:17:44.628] - result already collected: FutureResult
[16:17:44.628] result() for ClusterFuture ... done
[16:17:44.628] result() for ClusterFuture ...
[16:17:44.628] - result already collected: FutureResult
[16:17:44.628] result() for ClusterFuture ... done
[16:17:44.628] result() for ClusterFuture ...
[16:17:44.628] - result already collected: FutureResult
[16:17:44.628] result() for ClusterFuture ... done
[16:17:44.628] result() for ClusterFuture ...
[16:17:44.628] - result already collected: FutureResult
[16:17:44.628] result() for ClusterFuture ... done
[16:17:44.629] - relayed: [n=2] TRUE, FALSE
[16:17:44.629] - queued futures: [n=2] TRUE, FALSE
[16:17:44.629] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:44.629]  length: 1 (resolved future 1)
[16:17:44.656] receiveMessageFromWorker() for ClusterFuture ...
[16:17:44.656] - Validating connection of MultisessionFuture
[16:17:44.656] - received message: FutureResult
[16:17:44.656] - Received FutureResult
[16:17:44.657] - Erased future from FutureRegistry
[16:17:44.657] result() for ClusterFuture ...
[16:17:44.657] - result already collected: FutureResult
[16:17:44.657] result() for ClusterFuture ... done
[16:17:44.657] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:44.657] Future #2
[16:17:44.657] result() for ClusterFuture ...
[16:17:44.657] - result already collected: FutureResult
[16:17:44.657] result() for ClusterFuture ... done
[16:17:44.657] result() for ClusterFuture ...
[16:17:44.658] - result already collected: FutureResult
[16:17:44.658] result() for ClusterFuture ... done
[16:17:44.658] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:44.658] - nx: 2
[16:17:44.658] - relay: TRUE
[16:17:44.658] - stdout: TRUE
[16:17:44.658] - signal: TRUE
[16:17:44.658] - resignal: FALSE
[16:17:44.658] - force: TRUE
[16:17:44.658] - relayed: [n=2] TRUE, FALSE
[16:17:44.658] - queued futures: [n=2] TRUE, FALSE
[16:17:44.658]  - until=2
[16:17:44.659]  - relaying element #2
[16:17:44.659] result() for ClusterFuture ...
[16:17:44.659] - result already collected: FutureResult
[16:17:44.659] result() for ClusterFuture ... done
[16:17:44.659] result() for ClusterFuture ...
[16:17:44.659] - result already collected: FutureResult
[16:17:44.659] result() for ClusterFuture ... done
[16:17:44.659] result() for ClusterFuture ...
[16:17:44.659] - result already collected: FutureResult
[16:17:44.659] result() for ClusterFuture ... done
[16:17:44.659] result() for ClusterFuture ...
[16:17:44.660] - result already collected: FutureResult
[16:17:44.660] result() for ClusterFuture ... done
[16:17:44.660] - relayed: [n=2] TRUE, TRUE
[16:17:44.660] - queued futures: [n=2] TRUE, TRUE
[16:17:44.660] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:44.660]  length: 0 (resolved future 2)
[16:17:44.660] Relaying remaining futures
[16:17:44.660] signalConditionsASAP(NULL, pos=0) ...
[16:17:44.660] - nx: 2
[16:17:44.660] - relay: TRUE
[16:17:44.660] - stdout: TRUE
[16:17:44.661] - signal: TRUE
[16:17:44.661] - resignal: FALSE
[16:17:44.661] - force: TRUE
[16:17:44.661] - relayed: [n=2] TRUE, TRUE
[16:17:44.661] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:44.661] - relayed: [n=2] TRUE, TRUE
[16:17:44.661] - queued futures: [n=2] TRUE, TRUE
[16:17:44.661] signalConditionsASAP(NULL, pos=0) ... done
[16:17:44.661] resolve() on list ... DONE
[16:17:44.661] result() for ClusterFuture ...
[16:17:44.661] - result already collected: FutureResult
[16:17:44.662] result() for ClusterFuture ... done
[16:17:44.662] result() for ClusterFuture ...
[16:17:44.662] - result already collected: FutureResult
[16:17:44.662] result() for ClusterFuture ... done
[16:17:44.662] result() for ClusterFuture ...
[16:17:44.662] - result already collected: FutureResult
[16:17:44.662] result() for ClusterFuture ... done
[16:17:44.662] result() for ClusterFuture ...
[16:17:44.662] - result already collected: FutureResult
[16:17:44.662] result() for ClusterFuture ... done
[16:17:44.662]  - Number of value chunks collected: 2
[16:17:44.663] Resolving 2 futures (chunks) ... DONE
[16:17:44.663] Reducing values from 2 chunks ...
[16:17:44.663]  - Number of values collected after concatenation: 2
[16:17:44.663]  - Number of values expected: 2
[16:17:44.663] Reducing values from 2 chunks ... DONE
[16:17:44.663] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:17:44.663] getGlobalsAndPackagesXApply() ...
[16:17:44.664]  - future.globals: TRUE
[16:17:44.664] getGlobalsAndPackages() ...
[16:17:44.664] Searching for globals...
[16:17:44.665] - globals found: [1] ‘FUN’
[16:17:44.665] Searching for globals ... DONE
[16:17:44.665] Resolving globals: FALSE
[16:17:44.665] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:44.666] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:44.666] - globals: [1] ‘FUN’
[16:17:44.666] 
[16:17:44.666] getGlobalsAndPackages() ... DONE
[16:17:44.666]  - globals found/used: [n=1] ‘FUN’
[16:17:44.666]  - needed namespaces: [n=0] 
[16:17:44.666] Finding globals ... DONE
[16:17:44.666]  - use_args: TRUE
[16:17:44.666]  - Getting '...' globals ...
[16:17:44.667] resolve() on list ...
[16:17:44.667]  recursive: 0
[16:17:44.667]  length: 1
[16:17:44.667]  elements: ‘...’
[16:17:44.667]  length: 0 (resolved future 1)
[16:17:44.667] resolve() on list ... DONE
[16:17:44.667]    - '...' content: [n=0] 
[16:17:44.667] List of 1
[16:17:44.667]  $ ...: list()
[16:17:44.667]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.667]  - attr(*, "where")=List of 1
[16:17:44.667]   ..$ ...:<environment: 0x555be41a4fa8> 
[16:17:44.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.667]  - attr(*, "resolved")= logi TRUE
[16:17:44.667]  - attr(*, "total_size")= num NA
[16:17:44.670]  - Getting '...' globals ... DONE
[16:17:44.670] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:44.670] List of 2
[16:17:44.670]  $ ...future.FUN:function (x)  
[16:17:44.670]  $ ...          : list()
[16:17:44.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.670]  - attr(*, "where")=List of 2
[16:17:44.670]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:44.670]   ..$ ...          :<environment: 0x555be41a4fa8> 
[16:17:44.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.670]  - attr(*, "resolved")= logi FALSE
[16:17:44.670]  - attr(*, "total_size")= num 848
[16:17:44.673] Packages to be attached in all futures: [n=0] 
[16:17:44.673] getGlobalsAndPackagesXApply() ... DONE
[16:17:44.679] future_lapply() ...
[16:17:44.682] Number of chunks: 2
[16:17:44.682] getGlobalsAndPackagesXApply() ...
[16:17:44.683]  - future.globals: <name-value list> with names ‘list()’
[16:17:44.683]  - use_args: TRUE
[16:17:44.683] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:44.683] List of 2
[16:17:44.683]  $ ...          : list()
[16:17:44.683]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.683]  $ ...future.FUN:function (x)  
[16:17:44.683]  - attr(*, "where")=List of 2
[16:17:44.683]   ..$ ...          :<environment: 0x555be41a4fa8> 
[16:17:44.683]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:44.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.683]  - attr(*, "resolved")= logi FALSE
[16:17:44.683]  - attr(*, "total_size")= num NA
[16:17:44.686] Packages to be attached in all futures: [n=0] 
[16:17:44.686] getGlobalsAndPackagesXApply() ... DONE
[16:17:44.687] Number of futures (= number of chunks): 2
[16:17:44.687] Launching 2 futures (chunks) ...
[16:17:44.687] Chunk #1 of 2 ...
[16:17:44.687]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.687]  - seeds: <none>
[16:17:44.687]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.687] getGlobalsAndPackages() ...
[16:17:44.687] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.688] Resolving globals: FALSE
[16:17:44.688] Tweak future expression to call with '...' arguments ...
[16:17:44.688] {
[16:17:44.688]     do.call(function(...) {
[16:17:44.688]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.688]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.688]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.688]             on.exit(options(oopts), add = TRUE)
[16:17:44.688]         }
[16:17:44.688]         {
[16:17:44.688]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.688]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.688]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.688]             })
[16:17:44.688]         }
[16:17:44.688]     }, args = future.call.arguments)
[16:17:44.688] }
[16:17:44.688] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.688] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.689] 
[16:17:44.689] getGlobalsAndPackages() ... DONE
[16:17:44.689] run() for ‘Future’ ...
[16:17:44.689] - state: ‘created’
[16:17:44.689] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:44.703] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.703] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:44.703]   - Field: ‘node’
[16:17:44.703]   - Field: ‘label’
[16:17:44.703]   - Field: ‘local’
[16:17:44.704]   - Field: ‘owner’
[16:17:44.704]   - Field: ‘envir’
[16:17:44.704]   - Field: ‘workers’
[16:17:44.704]   - Field: ‘packages’
[16:17:44.704]   - Field: ‘gc’
[16:17:44.704]   - Field: ‘conditions’
[16:17:44.704]   - Field: ‘persistent’
[16:17:44.704]   - Field: ‘expr’
[16:17:44.704]   - Field: ‘uuid’
[16:17:44.704]   - Field: ‘seed’
[16:17:44.704]   - Field: ‘version’
[16:17:44.705]   - Field: ‘result’
[16:17:44.705]   - Field: ‘asynchronous’
[16:17:44.705]   - Field: ‘calls’
[16:17:44.705]   - Field: ‘globals’
[16:17:44.705]   - Field: ‘stdout’
[16:17:44.705]   - Field: ‘earlySignal’
[16:17:44.705]   - Field: ‘lazy’
[16:17:44.705]   - Field: ‘state’
[16:17:44.705] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:44.705] - Launch lazy future ...
[16:17:44.706] Packages needed by the future expression (n = 0): <none>
[16:17:44.706] Packages needed by future strategies (n = 0): <none>
[16:17:44.706] {
[16:17:44.706]     {
[16:17:44.706]         {
[16:17:44.706]             ...future.startTime <- base::Sys.time()
[16:17:44.706]             {
[16:17:44.706]                 {
[16:17:44.706]                   {
[16:17:44.706]                     {
[16:17:44.706]                       base::local({
[16:17:44.706]                         has_future <- base::requireNamespace("future", 
[16:17:44.706]                           quietly = TRUE)
[16:17:44.706]                         if (has_future) {
[16:17:44.706]                           ns <- base::getNamespace("future")
[16:17:44.706]                           version <- ns[[".package"]][["version"]]
[16:17:44.706]                           if (is.null(version)) 
[16:17:44.706]                             version <- utils::packageVersion("future")
[16:17:44.706]                         }
[16:17:44.706]                         else {
[16:17:44.706]                           version <- NULL
[16:17:44.706]                         }
[16:17:44.706]                         if (!has_future || version < "1.8.0") {
[16:17:44.706]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:44.706]                             "", base::R.version$version.string), 
[16:17:44.706]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:44.706]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:44.706]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:44.706]                               "release", "version")], collapse = " "), 
[16:17:44.706]                             hostname = base::Sys.info()[["nodename"]])
[16:17:44.706]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:44.706]                             info)
[16:17:44.706]                           info <- base::paste(info, collapse = "; ")
[16:17:44.706]                           if (!has_future) {
[16:17:44.706]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:44.706]                               info)
[16:17:44.706]                           }
[16:17:44.706]                           else {
[16:17:44.706]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:44.706]                               info, version)
[16:17:44.706]                           }
[16:17:44.706]                           base::stop(msg)
[16:17:44.706]                         }
[16:17:44.706]                       })
[16:17:44.706]                     }
[16:17:44.706]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:44.706]                     base::options(mc.cores = 1L)
[16:17:44.706]                   }
[16:17:44.706]                   ...future.strategy.old <- future::plan("list")
[16:17:44.706]                   options(future.plan = NULL)
[16:17:44.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:44.706]                 }
[16:17:44.706]                 ...future.workdir <- getwd()
[16:17:44.706]             }
[16:17:44.706]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:44.706]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:44.706]         }
[16:17:44.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:44.706]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:44.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:44.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:44.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:44.706]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:44.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:44.706]             base::names(...future.oldOptions))
[16:17:44.706]     }
[16:17:44.706]     if (FALSE) {
[16:17:44.706]     }
[16:17:44.706]     else {
[16:17:44.706]         if (TRUE) {
[16:17:44.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:44.706]                 open = "w")
[16:17:44.706]         }
[16:17:44.706]         else {
[16:17:44.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:44.706]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:44.706]         }
[16:17:44.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:44.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:44.706]             base::sink(type = "output", split = FALSE)
[16:17:44.706]             base::close(...future.stdout)
[16:17:44.706]         }, add = TRUE)
[16:17:44.706]     }
[16:17:44.706]     ...future.frame <- base::sys.nframe()
[16:17:44.706]     ...future.conditions <- base::list()
[16:17:44.706]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:44.706]     if (FALSE) {
[16:17:44.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:44.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:44.706]     }
[16:17:44.706]     ...future.result <- base::tryCatch({
[16:17:44.706]         base::withCallingHandlers({
[16:17:44.706]             ...future.value <- base::withVisible(base::local({
[16:17:44.706]                 ...future.makeSendCondition <- base::local({
[16:17:44.706]                   sendCondition <- NULL
[16:17:44.706]                   function(frame = 1L) {
[16:17:44.706]                     if (is.function(sendCondition)) 
[16:17:44.706]                       return(sendCondition)
[16:17:44.706]                     ns <- getNamespace("parallel")
[16:17:44.706]                     if (exists("sendData", mode = "function", 
[16:17:44.706]                       envir = ns)) {
[16:17:44.706]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:44.706]                         envir = ns)
[16:17:44.706]                       envir <- sys.frame(frame)
[16:17:44.706]                       master <- NULL
[16:17:44.706]                       while (!identical(envir, .GlobalEnv) && 
[16:17:44.706]                         !identical(envir, emptyenv())) {
[16:17:44.706]                         if (exists("master", mode = "list", envir = envir, 
[16:17:44.706]                           inherits = FALSE)) {
[16:17:44.706]                           master <- get("master", mode = "list", 
[16:17:44.706]                             envir = envir, inherits = FALSE)
[16:17:44.706]                           if (inherits(master, c("SOCKnode", 
[16:17:44.706]                             "SOCK0node"))) {
[16:17:44.706]                             sendCondition <<- function(cond) {
[16:17:44.706]                               data <- list(type = "VALUE", value = cond, 
[16:17:44.706]                                 success = TRUE)
[16:17:44.706]                               parallel_sendData(master, data)
[16:17:44.706]                             }
[16:17:44.706]                             return(sendCondition)
[16:17:44.706]                           }
[16:17:44.706]                         }
[16:17:44.706]                         frame <- frame + 1L
[16:17:44.706]                         envir <- sys.frame(frame)
[16:17:44.706]                       }
[16:17:44.706]                     }
[16:17:44.706]                     sendCondition <<- function(cond) NULL
[16:17:44.706]                   }
[16:17:44.706]                 })
[16:17:44.706]                 withCallingHandlers({
[16:17:44.706]                   {
[16:17:44.706]                     do.call(function(...) {
[16:17:44.706]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.706]                       if (!identical(...future.globals.maxSize.org, 
[16:17:44.706]                         ...future.globals.maxSize)) {
[16:17:44.706]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.706]                         on.exit(options(oopts), add = TRUE)
[16:17:44.706]                       }
[16:17:44.706]                       {
[16:17:44.706]                         lapply(seq_along(...future.elements_ii), 
[16:17:44.706]                           FUN = function(jj) {
[16:17:44.706]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.706]                             ...future.FUN(...future.X_jj, ...)
[16:17:44.706]                           })
[16:17:44.706]                       }
[16:17:44.706]                     }, args = future.call.arguments)
[16:17:44.706]                   }
[16:17:44.706]                 }, immediateCondition = function(cond) {
[16:17:44.706]                   sendCondition <- ...future.makeSendCondition()
[16:17:44.706]                   sendCondition(cond)
[16:17:44.706]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.706]                   {
[16:17:44.706]                     inherits <- base::inherits
[16:17:44.706]                     invokeRestart <- base::invokeRestart
[16:17:44.706]                     is.null <- base::is.null
[16:17:44.706]                     muffled <- FALSE
[16:17:44.706]                     if (inherits(cond, "message")) {
[16:17:44.706]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:44.706]                       if (muffled) 
[16:17:44.706]                         invokeRestart("muffleMessage")
[16:17:44.706]                     }
[16:17:44.706]                     else if (inherits(cond, "warning")) {
[16:17:44.706]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:44.706]                       if (muffled) 
[16:17:44.706]                         invokeRestart("muffleWarning")
[16:17:44.706]                     }
[16:17:44.706]                     else if (inherits(cond, "condition")) {
[16:17:44.706]                       if (!is.null(pattern)) {
[16:17:44.706]                         computeRestarts <- base::computeRestarts
[16:17:44.706]                         grepl <- base::grepl
[16:17:44.706]                         restarts <- computeRestarts(cond)
[16:17:44.706]                         for (restart in restarts) {
[16:17:44.706]                           name <- restart$name
[16:17:44.706]                           if (is.null(name)) 
[16:17:44.706]                             next
[16:17:44.706]                           if (!grepl(pattern, name)) 
[16:17:44.706]                             next
[16:17:44.706]                           invokeRestart(restart)
[16:17:44.706]                           muffled <- TRUE
[16:17:44.706]                           break
[16:17:44.706]                         }
[16:17:44.706]                       }
[16:17:44.706]                     }
[16:17:44.706]                     invisible(muffled)
[16:17:44.706]                   }
[16:17:44.706]                   muffleCondition(cond)
[16:17:44.706]                 })
[16:17:44.706]             }))
[16:17:44.706]             future::FutureResult(value = ...future.value$value, 
[16:17:44.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.706]                   ...future.rng), globalenv = if (FALSE) 
[16:17:44.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:44.706]                     ...future.globalenv.names))
[16:17:44.706]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:44.706]         }, condition = base::local({
[16:17:44.706]             c <- base::c
[16:17:44.706]             inherits <- base::inherits
[16:17:44.706]             invokeRestart <- base::invokeRestart
[16:17:44.706]             length <- base::length
[16:17:44.706]             list <- base::list
[16:17:44.706]             seq.int <- base::seq.int
[16:17:44.706]             signalCondition <- base::signalCondition
[16:17:44.706]             sys.calls <- base::sys.calls
[16:17:44.706]             `[[` <- base::`[[`
[16:17:44.706]             `+` <- base::`+`
[16:17:44.706]             `<<-` <- base::`<<-`
[16:17:44.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:44.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:44.706]                   3L)]
[16:17:44.706]             }
[16:17:44.706]             function(cond) {
[16:17:44.706]                 is_error <- inherits(cond, "error")
[16:17:44.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:44.706]                   NULL)
[16:17:44.706]                 if (is_error) {
[16:17:44.706]                   sessionInformation <- function() {
[16:17:44.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:44.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:44.706]                       search = base::search(), system = base::Sys.info())
[16:17:44.706]                   }
[16:17:44.706]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:44.706]                     cond$call), session = sessionInformation(), 
[16:17:44.706]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:44.706]                   signalCondition(cond)
[16:17:44.706]                 }
[16:17:44.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:44.706]                 "immediateCondition"))) {
[16:17:44.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:44.706]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:44.706]                   if (TRUE && !signal) {
[16:17:44.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.706]                     {
[16:17:44.706]                       inherits <- base::inherits
[16:17:44.706]                       invokeRestart <- base::invokeRestart
[16:17:44.706]                       is.null <- base::is.null
[16:17:44.706]                       muffled <- FALSE
[16:17:44.706]                       if (inherits(cond, "message")) {
[16:17:44.706]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.706]                         if (muffled) 
[16:17:44.706]                           invokeRestart("muffleMessage")
[16:17:44.706]                       }
[16:17:44.706]                       else if (inherits(cond, "warning")) {
[16:17:44.706]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.706]                         if (muffled) 
[16:17:44.706]                           invokeRestart("muffleWarning")
[16:17:44.706]                       }
[16:17:44.706]                       else if (inherits(cond, "condition")) {
[16:17:44.706]                         if (!is.null(pattern)) {
[16:17:44.706]                           computeRestarts <- base::computeRestarts
[16:17:44.706]                           grepl <- base::grepl
[16:17:44.706]                           restarts <- computeRestarts(cond)
[16:17:44.706]                           for (restart in restarts) {
[16:17:44.706]                             name <- restart$name
[16:17:44.706]                             if (is.null(name)) 
[16:17:44.706]                               next
[16:17:44.706]                             if (!grepl(pattern, name)) 
[16:17:44.706]                               next
[16:17:44.706]                             invokeRestart(restart)
[16:17:44.706]                             muffled <- TRUE
[16:17:44.706]                             break
[16:17:44.706]                           }
[16:17:44.706]                         }
[16:17:44.706]                       }
[16:17:44.706]                       invisible(muffled)
[16:17:44.706]                     }
[16:17:44.706]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.706]                   }
[16:17:44.706]                 }
[16:17:44.706]                 else {
[16:17:44.706]                   if (TRUE) {
[16:17:44.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.706]                     {
[16:17:44.706]                       inherits <- base::inherits
[16:17:44.706]                       invokeRestart <- base::invokeRestart
[16:17:44.706]                       is.null <- base::is.null
[16:17:44.706]                       muffled <- FALSE
[16:17:44.706]                       if (inherits(cond, "message")) {
[16:17:44.706]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.706]                         if (muffled) 
[16:17:44.706]                           invokeRestart("muffleMessage")
[16:17:44.706]                       }
[16:17:44.706]                       else if (inherits(cond, "warning")) {
[16:17:44.706]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.706]                         if (muffled) 
[16:17:44.706]                           invokeRestart("muffleWarning")
[16:17:44.706]                       }
[16:17:44.706]                       else if (inherits(cond, "condition")) {
[16:17:44.706]                         if (!is.null(pattern)) {
[16:17:44.706]                           computeRestarts <- base::computeRestarts
[16:17:44.706]                           grepl <- base::grepl
[16:17:44.706]                           restarts <- computeRestarts(cond)
[16:17:44.706]                           for (restart in restarts) {
[16:17:44.706]                             name <- restart$name
[16:17:44.706]                             if (is.null(name)) 
[16:17:44.706]                               next
[16:17:44.706]                             if (!grepl(pattern, name)) 
[16:17:44.706]                               next
[16:17:44.706]                             invokeRestart(restart)
[16:17:44.706]                             muffled <- TRUE
[16:17:44.706]                             break
[16:17:44.706]                           }
[16:17:44.706]                         }
[16:17:44.706]                       }
[16:17:44.706]                       invisible(muffled)
[16:17:44.706]                     }
[16:17:44.706]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.706]                   }
[16:17:44.706]                 }
[16:17:44.706]             }
[16:17:44.706]         }))
[16:17:44.706]     }, error = function(ex) {
[16:17:44.706]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:44.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.706]                 ...future.rng), started = ...future.startTime, 
[16:17:44.706]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:44.706]             version = "1.8"), class = "FutureResult")
[16:17:44.706]     }, finally = {
[16:17:44.706]         if (!identical(...future.workdir, getwd())) 
[16:17:44.706]             setwd(...future.workdir)
[16:17:44.706]         {
[16:17:44.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:44.706]                 ...future.oldOptions$nwarnings <- NULL
[16:17:44.706]             }
[16:17:44.706]             base::options(...future.oldOptions)
[16:17:44.706]             if (.Platform$OS.type == "windows") {
[16:17:44.706]                 old_names <- names(...future.oldEnvVars)
[16:17:44.706]                 envs <- base::Sys.getenv()
[16:17:44.706]                 names <- names(envs)
[16:17:44.706]                 common <- intersect(names, old_names)
[16:17:44.706]                 added <- setdiff(names, old_names)
[16:17:44.706]                 removed <- setdiff(old_names, names)
[16:17:44.706]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:44.706]                   envs[common]]
[16:17:44.706]                 NAMES <- toupper(changed)
[16:17:44.706]                 args <- list()
[16:17:44.706]                 for (kk in seq_along(NAMES)) {
[16:17:44.706]                   name <- changed[[kk]]
[16:17:44.706]                   NAME <- NAMES[[kk]]
[16:17:44.706]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.706]                     next
[16:17:44.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.706]                 }
[16:17:44.706]                 NAMES <- toupper(added)
[16:17:44.706]                 for (kk in seq_along(NAMES)) {
[16:17:44.706]                   name <- added[[kk]]
[16:17:44.706]                   NAME <- NAMES[[kk]]
[16:17:44.706]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.706]                     next
[16:17:44.706]                   args[[name]] <- ""
[16:17:44.706]                 }
[16:17:44.706]                 NAMES <- toupper(removed)
[16:17:44.706]                 for (kk in seq_along(NAMES)) {
[16:17:44.706]                   name <- removed[[kk]]
[16:17:44.706]                   NAME <- NAMES[[kk]]
[16:17:44.706]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.706]                     next
[16:17:44.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.706]                 }
[16:17:44.706]                 if (length(args) > 0) 
[16:17:44.706]                   base::do.call(base::Sys.setenv, args = args)
[16:17:44.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:44.706]             }
[16:17:44.706]             else {
[16:17:44.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:44.706]             }
[16:17:44.706]             {
[16:17:44.706]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:44.706]                   0L) {
[16:17:44.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:44.706]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:44.706]                   base::options(opts)
[16:17:44.706]                 }
[16:17:44.706]                 {
[16:17:44.706]                   {
[16:17:44.706]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:44.706]                     NULL
[16:17:44.706]                   }
[16:17:44.706]                   options(future.plan = NULL)
[16:17:44.706]                   if (is.na(NA_character_)) 
[16:17:44.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:44.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:44.706]                     .init = FALSE)
[16:17:44.706]                 }
[16:17:44.706]             }
[16:17:44.706]         }
[16:17:44.706]     })
[16:17:44.706]     if (TRUE) {
[16:17:44.706]         base::sink(type = "output", split = FALSE)
[16:17:44.706]         if (TRUE) {
[16:17:44.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:44.706]         }
[16:17:44.706]         else {
[16:17:44.706]             ...future.result["stdout"] <- base::list(NULL)
[16:17:44.706]         }
[16:17:44.706]         base::close(...future.stdout)
[16:17:44.706]         ...future.stdout <- NULL
[16:17:44.706]     }
[16:17:44.706]     ...future.result$conditions <- ...future.conditions
[16:17:44.706]     ...future.result$finished <- base::Sys.time()
[16:17:44.706]     ...future.result
[16:17:44.706] }
[16:17:44.709] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[16:17:44.710] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:44.710] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.710] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:17:44.711] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:17:44.711] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:17:44.711] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:17:44.711] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:44.712] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.712] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:17:44.712] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:17:44.712] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[16:17:44.713] MultisessionFuture started
[16:17:44.713] - Launch lazy future ... done
[16:17:44.713] run() for ‘MultisessionFuture’ ... done
[16:17:44.713] Created future:
[16:17:44.713] MultisessionFuture:
[16:17:44.713] Label: ‘future_apply-1’
[16:17:44.713] Expression:
[16:17:44.713] {
[16:17:44.713]     do.call(function(...) {
[16:17:44.713]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.713]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.713]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.713]             on.exit(options(oopts), add = TRUE)
[16:17:44.713]         }
[16:17:44.713]         {
[16:17:44.713]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.713]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.713]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.713]             })
[16:17:44.713]         }
[16:17:44.713]     }, args = future.call.arguments)
[16:17:44.713] }
[16:17:44.713] Lazy evaluation: FALSE
[16:17:44.713] Asynchronous evaluation: TRUE
[16:17:44.713] Local evaluation: TRUE
[16:17:44.713] Environment: R_GlobalEnv
[16:17:44.713] Capture standard output: TRUE
[16:17:44.713] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.713] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.713] Packages: <none>
[16:17:44.713] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.713] Resolved: FALSE
[16:17:44.713] Value: <not collected>
[16:17:44.713] Conditions captured: <none>
[16:17:44.713] Early signaling: FALSE
[16:17:44.713] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.713] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.725] Chunk #1 of 2 ... DONE
[16:17:44.725] Chunk #2 of 2 ...
[16:17:44.725]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.725]  - seeds: <none>
[16:17:44.725]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.726] getGlobalsAndPackages() ...
[16:17:44.726] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.726] Resolving globals: FALSE
[16:17:44.726] Tweak future expression to call with '...' arguments ...
[16:17:44.726] {
[16:17:44.726]     do.call(function(...) {
[16:17:44.726]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.726]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.726]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.726]             on.exit(options(oopts), add = TRUE)
[16:17:44.726]         }
[16:17:44.726]         {
[16:17:44.726]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.726]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.726]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.726]             })
[16:17:44.726]         }
[16:17:44.726]     }, args = future.call.arguments)
[16:17:44.726] }
[16:17:44.726] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.727] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.727] 
[16:17:44.727] getGlobalsAndPackages() ... DONE
[16:17:44.727] run() for ‘Future’ ...
[16:17:44.727] - state: ‘created’
[16:17:44.727] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:44.743] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.743] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:44.743]   - Field: ‘node’
[16:17:44.743]   - Field: ‘label’
[16:17:44.743]   - Field: ‘local’
[16:17:44.743]   - Field: ‘owner’
[16:17:44.743]   - Field: ‘envir’
[16:17:44.743]   - Field: ‘workers’
[16:17:44.744]   - Field: ‘packages’
[16:17:44.744]   - Field: ‘gc’
[16:17:44.744]   - Field: ‘conditions’
[16:17:44.744]   - Field: ‘persistent’
[16:17:44.744]   - Field: ‘expr’
[16:17:44.744]   - Field: ‘uuid’
[16:17:44.744]   - Field: ‘seed’
[16:17:44.744]   - Field: ‘version’
[16:17:44.744]   - Field: ‘result’
[16:17:44.744]   - Field: ‘asynchronous’
[16:17:44.745]   - Field: ‘calls’
[16:17:44.745]   - Field: ‘globals’
[16:17:44.745]   - Field: ‘stdout’
[16:17:44.745]   - Field: ‘earlySignal’
[16:17:44.745]   - Field: ‘lazy’
[16:17:44.745]   - Field: ‘state’
[16:17:44.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:44.745] - Launch lazy future ...
[16:17:44.745] Packages needed by the future expression (n = 0): <none>
[16:17:44.746] Packages needed by future strategies (n = 0): <none>
[16:17:44.746] {
[16:17:44.746]     {
[16:17:44.746]         {
[16:17:44.746]             ...future.startTime <- base::Sys.time()
[16:17:44.746]             {
[16:17:44.746]                 {
[16:17:44.746]                   {
[16:17:44.746]                     {
[16:17:44.746]                       base::local({
[16:17:44.746]                         has_future <- base::requireNamespace("future", 
[16:17:44.746]                           quietly = TRUE)
[16:17:44.746]                         if (has_future) {
[16:17:44.746]                           ns <- base::getNamespace("future")
[16:17:44.746]                           version <- ns[[".package"]][["version"]]
[16:17:44.746]                           if (is.null(version)) 
[16:17:44.746]                             version <- utils::packageVersion("future")
[16:17:44.746]                         }
[16:17:44.746]                         else {
[16:17:44.746]                           version <- NULL
[16:17:44.746]                         }
[16:17:44.746]                         if (!has_future || version < "1.8.0") {
[16:17:44.746]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:44.746]                             "", base::R.version$version.string), 
[16:17:44.746]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:44.746]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:44.746]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:44.746]                               "release", "version")], collapse = " "), 
[16:17:44.746]                             hostname = base::Sys.info()[["nodename"]])
[16:17:44.746]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:44.746]                             info)
[16:17:44.746]                           info <- base::paste(info, collapse = "; ")
[16:17:44.746]                           if (!has_future) {
[16:17:44.746]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:44.746]                               info)
[16:17:44.746]                           }
[16:17:44.746]                           else {
[16:17:44.746]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:44.746]                               info, version)
[16:17:44.746]                           }
[16:17:44.746]                           base::stop(msg)
[16:17:44.746]                         }
[16:17:44.746]                       })
[16:17:44.746]                     }
[16:17:44.746]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:44.746]                     base::options(mc.cores = 1L)
[16:17:44.746]                   }
[16:17:44.746]                   ...future.strategy.old <- future::plan("list")
[16:17:44.746]                   options(future.plan = NULL)
[16:17:44.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:44.746]                 }
[16:17:44.746]                 ...future.workdir <- getwd()
[16:17:44.746]             }
[16:17:44.746]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:44.746]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:44.746]         }
[16:17:44.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:44.746]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:44.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:44.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:44.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:44.746]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:44.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:44.746]             base::names(...future.oldOptions))
[16:17:44.746]     }
[16:17:44.746]     if (FALSE) {
[16:17:44.746]     }
[16:17:44.746]     else {
[16:17:44.746]         if (TRUE) {
[16:17:44.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:44.746]                 open = "w")
[16:17:44.746]         }
[16:17:44.746]         else {
[16:17:44.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:44.746]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:44.746]         }
[16:17:44.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:44.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:44.746]             base::sink(type = "output", split = FALSE)
[16:17:44.746]             base::close(...future.stdout)
[16:17:44.746]         }, add = TRUE)
[16:17:44.746]     }
[16:17:44.746]     ...future.frame <- base::sys.nframe()
[16:17:44.746]     ...future.conditions <- base::list()
[16:17:44.746]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:44.746]     if (FALSE) {
[16:17:44.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:44.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:44.746]     }
[16:17:44.746]     ...future.result <- base::tryCatch({
[16:17:44.746]         base::withCallingHandlers({
[16:17:44.746]             ...future.value <- base::withVisible(base::local({
[16:17:44.746]                 ...future.makeSendCondition <- base::local({
[16:17:44.746]                   sendCondition <- NULL
[16:17:44.746]                   function(frame = 1L) {
[16:17:44.746]                     if (is.function(sendCondition)) 
[16:17:44.746]                       return(sendCondition)
[16:17:44.746]                     ns <- getNamespace("parallel")
[16:17:44.746]                     if (exists("sendData", mode = "function", 
[16:17:44.746]                       envir = ns)) {
[16:17:44.746]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:44.746]                         envir = ns)
[16:17:44.746]                       envir <- sys.frame(frame)
[16:17:44.746]                       master <- NULL
[16:17:44.746]                       while (!identical(envir, .GlobalEnv) && 
[16:17:44.746]                         !identical(envir, emptyenv())) {
[16:17:44.746]                         if (exists("master", mode = "list", envir = envir, 
[16:17:44.746]                           inherits = FALSE)) {
[16:17:44.746]                           master <- get("master", mode = "list", 
[16:17:44.746]                             envir = envir, inherits = FALSE)
[16:17:44.746]                           if (inherits(master, c("SOCKnode", 
[16:17:44.746]                             "SOCK0node"))) {
[16:17:44.746]                             sendCondition <<- function(cond) {
[16:17:44.746]                               data <- list(type = "VALUE", value = cond, 
[16:17:44.746]                                 success = TRUE)
[16:17:44.746]                               parallel_sendData(master, data)
[16:17:44.746]                             }
[16:17:44.746]                             return(sendCondition)
[16:17:44.746]                           }
[16:17:44.746]                         }
[16:17:44.746]                         frame <- frame + 1L
[16:17:44.746]                         envir <- sys.frame(frame)
[16:17:44.746]                       }
[16:17:44.746]                     }
[16:17:44.746]                     sendCondition <<- function(cond) NULL
[16:17:44.746]                   }
[16:17:44.746]                 })
[16:17:44.746]                 withCallingHandlers({
[16:17:44.746]                   {
[16:17:44.746]                     do.call(function(...) {
[16:17:44.746]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.746]                       if (!identical(...future.globals.maxSize.org, 
[16:17:44.746]                         ...future.globals.maxSize)) {
[16:17:44.746]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.746]                         on.exit(options(oopts), add = TRUE)
[16:17:44.746]                       }
[16:17:44.746]                       {
[16:17:44.746]                         lapply(seq_along(...future.elements_ii), 
[16:17:44.746]                           FUN = function(jj) {
[16:17:44.746]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.746]                             ...future.FUN(...future.X_jj, ...)
[16:17:44.746]                           })
[16:17:44.746]                       }
[16:17:44.746]                     }, args = future.call.arguments)
[16:17:44.746]                   }
[16:17:44.746]                 }, immediateCondition = function(cond) {
[16:17:44.746]                   sendCondition <- ...future.makeSendCondition()
[16:17:44.746]                   sendCondition(cond)
[16:17:44.746]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.746]                   {
[16:17:44.746]                     inherits <- base::inherits
[16:17:44.746]                     invokeRestart <- base::invokeRestart
[16:17:44.746]                     is.null <- base::is.null
[16:17:44.746]                     muffled <- FALSE
[16:17:44.746]                     if (inherits(cond, "message")) {
[16:17:44.746]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:44.746]                       if (muffled) 
[16:17:44.746]                         invokeRestart("muffleMessage")
[16:17:44.746]                     }
[16:17:44.746]                     else if (inherits(cond, "warning")) {
[16:17:44.746]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:44.746]                       if (muffled) 
[16:17:44.746]                         invokeRestart("muffleWarning")
[16:17:44.746]                     }
[16:17:44.746]                     else if (inherits(cond, "condition")) {
[16:17:44.746]                       if (!is.null(pattern)) {
[16:17:44.746]                         computeRestarts <- base::computeRestarts
[16:17:44.746]                         grepl <- base::grepl
[16:17:44.746]                         restarts <- computeRestarts(cond)
[16:17:44.746]                         for (restart in restarts) {
[16:17:44.746]                           name <- restart$name
[16:17:44.746]                           if (is.null(name)) 
[16:17:44.746]                             next
[16:17:44.746]                           if (!grepl(pattern, name)) 
[16:17:44.746]                             next
[16:17:44.746]                           invokeRestart(restart)
[16:17:44.746]                           muffled <- TRUE
[16:17:44.746]                           break
[16:17:44.746]                         }
[16:17:44.746]                       }
[16:17:44.746]                     }
[16:17:44.746]                     invisible(muffled)
[16:17:44.746]                   }
[16:17:44.746]                   muffleCondition(cond)
[16:17:44.746]                 })
[16:17:44.746]             }))
[16:17:44.746]             future::FutureResult(value = ...future.value$value, 
[16:17:44.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.746]                   ...future.rng), globalenv = if (FALSE) 
[16:17:44.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:44.746]                     ...future.globalenv.names))
[16:17:44.746]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:44.746]         }, condition = base::local({
[16:17:44.746]             c <- base::c
[16:17:44.746]             inherits <- base::inherits
[16:17:44.746]             invokeRestart <- base::invokeRestart
[16:17:44.746]             length <- base::length
[16:17:44.746]             list <- base::list
[16:17:44.746]             seq.int <- base::seq.int
[16:17:44.746]             signalCondition <- base::signalCondition
[16:17:44.746]             sys.calls <- base::sys.calls
[16:17:44.746]             `[[` <- base::`[[`
[16:17:44.746]             `+` <- base::`+`
[16:17:44.746]             `<<-` <- base::`<<-`
[16:17:44.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:44.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:44.746]                   3L)]
[16:17:44.746]             }
[16:17:44.746]             function(cond) {
[16:17:44.746]                 is_error <- inherits(cond, "error")
[16:17:44.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:44.746]                   NULL)
[16:17:44.746]                 if (is_error) {
[16:17:44.746]                   sessionInformation <- function() {
[16:17:44.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:44.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:44.746]                       search = base::search(), system = base::Sys.info())
[16:17:44.746]                   }
[16:17:44.746]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:44.746]                     cond$call), session = sessionInformation(), 
[16:17:44.746]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:44.746]                   signalCondition(cond)
[16:17:44.746]                 }
[16:17:44.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:44.746]                 "immediateCondition"))) {
[16:17:44.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:44.746]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:44.746]                   if (TRUE && !signal) {
[16:17:44.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.746]                     {
[16:17:44.746]                       inherits <- base::inherits
[16:17:44.746]                       invokeRestart <- base::invokeRestart
[16:17:44.746]                       is.null <- base::is.null
[16:17:44.746]                       muffled <- FALSE
[16:17:44.746]                       if (inherits(cond, "message")) {
[16:17:44.746]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.746]                         if (muffled) 
[16:17:44.746]                           invokeRestart("muffleMessage")
[16:17:44.746]                       }
[16:17:44.746]                       else if (inherits(cond, "warning")) {
[16:17:44.746]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.746]                         if (muffled) 
[16:17:44.746]                           invokeRestart("muffleWarning")
[16:17:44.746]                       }
[16:17:44.746]                       else if (inherits(cond, "condition")) {
[16:17:44.746]                         if (!is.null(pattern)) {
[16:17:44.746]                           computeRestarts <- base::computeRestarts
[16:17:44.746]                           grepl <- base::grepl
[16:17:44.746]                           restarts <- computeRestarts(cond)
[16:17:44.746]                           for (restart in restarts) {
[16:17:44.746]                             name <- restart$name
[16:17:44.746]                             if (is.null(name)) 
[16:17:44.746]                               next
[16:17:44.746]                             if (!grepl(pattern, name)) 
[16:17:44.746]                               next
[16:17:44.746]                             invokeRestart(restart)
[16:17:44.746]                             muffled <- TRUE
[16:17:44.746]                             break
[16:17:44.746]                           }
[16:17:44.746]                         }
[16:17:44.746]                       }
[16:17:44.746]                       invisible(muffled)
[16:17:44.746]                     }
[16:17:44.746]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.746]                   }
[16:17:44.746]                 }
[16:17:44.746]                 else {
[16:17:44.746]                   if (TRUE) {
[16:17:44.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.746]                     {
[16:17:44.746]                       inherits <- base::inherits
[16:17:44.746]                       invokeRestart <- base::invokeRestart
[16:17:44.746]                       is.null <- base::is.null
[16:17:44.746]                       muffled <- FALSE
[16:17:44.746]                       if (inherits(cond, "message")) {
[16:17:44.746]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.746]                         if (muffled) 
[16:17:44.746]                           invokeRestart("muffleMessage")
[16:17:44.746]                       }
[16:17:44.746]                       else if (inherits(cond, "warning")) {
[16:17:44.746]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.746]                         if (muffled) 
[16:17:44.746]                           invokeRestart("muffleWarning")
[16:17:44.746]                       }
[16:17:44.746]                       else if (inherits(cond, "condition")) {
[16:17:44.746]                         if (!is.null(pattern)) {
[16:17:44.746]                           computeRestarts <- base::computeRestarts
[16:17:44.746]                           grepl <- base::grepl
[16:17:44.746]                           restarts <- computeRestarts(cond)
[16:17:44.746]                           for (restart in restarts) {
[16:17:44.746]                             name <- restart$name
[16:17:44.746]                             if (is.null(name)) 
[16:17:44.746]                               next
[16:17:44.746]                             if (!grepl(pattern, name)) 
[16:17:44.746]                               next
[16:17:44.746]                             invokeRestart(restart)
[16:17:44.746]                             muffled <- TRUE
[16:17:44.746]                             break
[16:17:44.746]                           }
[16:17:44.746]                         }
[16:17:44.746]                       }
[16:17:44.746]                       invisible(muffled)
[16:17:44.746]                     }
[16:17:44.746]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.746]                   }
[16:17:44.746]                 }
[16:17:44.746]             }
[16:17:44.746]         }))
[16:17:44.746]     }, error = function(ex) {
[16:17:44.746]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:44.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.746]                 ...future.rng), started = ...future.startTime, 
[16:17:44.746]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:44.746]             version = "1.8"), class = "FutureResult")
[16:17:44.746]     }, finally = {
[16:17:44.746]         if (!identical(...future.workdir, getwd())) 
[16:17:44.746]             setwd(...future.workdir)
[16:17:44.746]         {
[16:17:44.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:44.746]                 ...future.oldOptions$nwarnings <- NULL
[16:17:44.746]             }
[16:17:44.746]             base::options(...future.oldOptions)
[16:17:44.746]             if (.Platform$OS.type == "windows") {
[16:17:44.746]                 old_names <- names(...future.oldEnvVars)
[16:17:44.746]                 envs <- base::Sys.getenv()
[16:17:44.746]                 names <- names(envs)
[16:17:44.746]                 common <- intersect(names, old_names)
[16:17:44.746]                 added <- setdiff(names, old_names)
[16:17:44.746]                 removed <- setdiff(old_names, names)
[16:17:44.746]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:44.746]                   envs[common]]
[16:17:44.746]                 NAMES <- toupper(changed)
[16:17:44.746]                 args <- list()
[16:17:44.746]                 for (kk in seq_along(NAMES)) {
[16:17:44.746]                   name <- changed[[kk]]
[16:17:44.746]                   NAME <- NAMES[[kk]]
[16:17:44.746]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.746]                     next
[16:17:44.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.746]                 }
[16:17:44.746]                 NAMES <- toupper(added)
[16:17:44.746]                 for (kk in seq_along(NAMES)) {
[16:17:44.746]                   name <- added[[kk]]
[16:17:44.746]                   NAME <- NAMES[[kk]]
[16:17:44.746]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.746]                     next
[16:17:44.746]                   args[[name]] <- ""
[16:17:44.746]                 }
[16:17:44.746]                 NAMES <- toupper(removed)
[16:17:44.746]                 for (kk in seq_along(NAMES)) {
[16:17:44.746]                   name <- removed[[kk]]
[16:17:44.746]                   NAME <- NAMES[[kk]]
[16:17:44.746]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.746]                     next
[16:17:44.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.746]                 }
[16:17:44.746]                 if (length(args) > 0) 
[16:17:44.746]                   base::do.call(base::Sys.setenv, args = args)
[16:17:44.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:44.746]             }
[16:17:44.746]             else {
[16:17:44.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:44.746]             }
[16:17:44.746]             {
[16:17:44.746]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:44.746]                   0L) {
[16:17:44.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:44.746]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:44.746]                   base::options(opts)
[16:17:44.746]                 }
[16:17:44.746]                 {
[16:17:44.746]                   {
[16:17:44.746]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:44.746]                     NULL
[16:17:44.746]                   }
[16:17:44.746]                   options(future.plan = NULL)
[16:17:44.746]                   if (is.na(NA_character_)) 
[16:17:44.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:44.746]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:44.746]                     .init = FALSE)
[16:17:44.746]                 }
[16:17:44.746]             }
[16:17:44.746]         }
[16:17:44.746]     })
[16:17:44.746]     if (TRUE) {
[16:17:44.746]         base::sink(type = "output", split = FALSE)
[16:17:44.746]         if (TRUE) {
[16:17:44.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:44.746]         }
[16:17:44.746]         else {
[16:17:44.746]             ...future.result["stdout"] <- base::list(NULL)
[16:17:44.746]         }
[16:17:44.746]         base::close(...future.stdout)
[16:17:44.746]         ...future.stdout <- NULL
[16:17:44.746]     }
[16:17:44.746]     ...future.result$conditions <- ...future.conditions
[16:17:44.746]     ...future.result$finished <- base::Sys.time()
[16:17:44.746]     ...future.result
[16:17:44.746] }
[16:17:44.749] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[16:17:44.749] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:44.750] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:44.750] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:17:44.750] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:17:44.750] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:17:44.751] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:17:44.751] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:44.751] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:44.751] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:17:44.752] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:17:44.752] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[16:17:44.752] MultisessionFuture started
[16:17:44.752] - Launch lazy future ... done
[16:17:44.752] run() for ‘MultisessionFuture’ ... done
[16:17:44.752] Created future:
[16:17:44.753] MultisessionFuture:
[16:17:44.753] Label: ‘future_apply-2’
[16:17:44.753] Expression:
[16:17:44.753] {
[16:17:44.753]     do.call(function(...) {
[16:17:44.753]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.753]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.753]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.753]             on.exit(options(oopts), add = TRUE)
[16:17:44.753]         }
[16:17:44.753]         {
[16:17:44.753]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.753]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.753]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.753]             })
[16:17:44.753]         }
[16:17:44.753]     }, args = future.call.arguments)
[16:17:44.753] }
[16:17:44.753] Lazy evaluation: FALSE
[16:17:44.753] Asynchronous evaluation: TRUE
[16:17:44.753] Local evaluation: TRUE
[16:17:44.753] Environment: R_GlobalEnv
[16:17:44.753] Capture standard output: TRUE
[16:17:44.753] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.753] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.753] Packages: <none>
[16:17:44.753] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.753] Resolved: FALSE
[16:17:44.753] Value: <not collected>
[16:17:44.753] Conditions captured: <none>
[16:17:44.753] Early signaling: FALSE
[16:17:44.753] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.753] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.764] Chunk #2 of 2 ... DONE
[16:17:44.764] Launching 2 futures (chunks) ... DONE
[16:17:44.764] Resolving 2 futures (chunks) ...
[16:17:44.764] resolve() on list ...
[16:17:44.765]  recursive: 0
[16:17:44.765]  length: 2
[16:17:44.765] 
[16:17:44.765] receiveMessageFromWorker() for ClusterFuture ...
[16:17:44.765] - Validating connection of MultisessionFuture
[16:17:44.765] - received message: FutureResult
[16:17:44.766] - Received FutureResult
[16:17:44.766] - Erased future from FutureRegistry
[16:17:44.766] result() for ClusterFuture ...
[16:17:44.766] - result already collected: FutureResult
[16:17:44.766] result() for ClusterFuture ... done
[16:17:44.766] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:44.766] Future #1
[16:17:44.766] result() for ClusterFuture ...
[16:17:44.766] - result already collected: FutureResult
[16:17:44.766] result() for ClusterFuture ... done
[16:17:44.767] result() for ClusterFuture ...
[16:17:44.767] - result already collected: FutureResult
[16:17:44.767] result() for ClusterFuture ... done
[16:17:44.767] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:44.767] - nx: 2
[16:17:44.767] - relay: TRUE
[16:17:44.767] - stdout: TRUE
[16:17:44.767] - signal: TRUE
[16:17:44.767] - resignal: FALSE
[16:17:44.767] - force: TRUE
[16:17:44.767] - relayed: [n=2] FALSE, FALSE
[16:17:44.767] - queued futures: [n=2] FALSE, FALSE
[16:17:44.768]  - until=1
[16:17:44.768]  - relaying element #1
[16:17:44.768] result() for ClusterFuture ...
[16:17:44.768] - result already collected: FutureResult
[16:17:44.768] result() for ClusterFuture ... done
[16:17:44.768] result() for ClusterFuture ...
[16:17:44.768] - result already collected: FutureResult
[16:17:44.768] result() for ClusterFuture ... done
[16:17:44.768] result() for ClusterFuture ...
[16:17:44.768] - result already collected: FutureResult
[16:17:44.769] result() for ClusterFuture ... done
[16:17:44.769] result() for ClusterFuture ...
[16:17:44.769] - result already collected: FutureResult
[16:17:44.769] result() for ClusterFuture ... done
[16:17:44.769] - relayed: [n=2] TRUE, FALSE
[16:17:44.769] - queued futures: [n=2] TRUE, FALSE
[16:17:44.769] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:44.769]  length: 1 (resolved future 1)
[16:17:44.794] receiveMessageFromWorker() for ClusterFuture ...
[16:17:44.794] - Validating connection of MultisessionFuture
[16:17:44.794] - received message: FutureResult
[16:17:44.794] - Received FutureResult
[16:17:44.794] - Erased future from FutureRegistry
[16:17:44.794] result() for ClusterFuture ...
[16:17:44.794] - result already collected: FutureResult
[16:17:44.795] result() for ClusterFuture ... done
[16:17:44.795] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:44.795] Future #2
[16:17:44.795] result() for ClusterFuture ...
[16:17:44.795] - result already collected: FutureResult
[16:17:44.795] result() for ClusterFuture ... done
[16:17:44.795] result() for ClusterFuture ...
[16:17:44.795] - result already collected: FutureResult
[16:17:44.795] result() for ClusterFuture ... done
[16:17:44.795] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:44.795] - nx: 2
[16:17:44.796] - relay: TRUE
[16:17:44.796] - stdout: TRUE
[16:17:44.796] - signal: TRUE
[16:17:44.796] - resignal: FALSE
[16:17:44.796] - force: TRUE
[16:17:44.796] - relayed: [n=2] TRUE, FALSE
[16:17:44.796] - queued futures: [n=2] TRUE, FALSE
[16:17:44.796]  - until=2
[16:17:44.796]  - relaying element #2
[16:17:44.796] result() for ClusterFuture ...
[16:17:44.796] - result already collected: FutureResult
[16:17:44.796] result() for ClusterFuture ... done
[16:17:44.797] result() for ClusterFuture ...
[16:17:44.797] - result already collected: FutureResult
[16:17:44.797] result() for ClusterFuture ... done
[16:17:44.797] result() for ClusterFuture ...
[16:17:44.797] - result already collected: FutureResult
[16:17:44.797] result() for ClusterFuture ... done
[16:17:44.797] result() for ClusterFuture ...
[16:17:44.797] - result already collected: FutureResult
[16:17:44.797] result() for ClusterFuture ... done
[16:17:44.797] - relayed: [n=2] TRUE, TRUE
[16:17:44.797] - queued futures: [n=2] TRUE, TRUE
[16:17:44.798] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:44.798]  length: 0 (resolved future 2)
[16:17:44.798] Relaying remaining futures
[16:17:44.798] signalConditionsASAP(NULL, pos=0) ...
[16:17:44.798] - nx: 2
[16:17:44.798] - relay: TRUE
[16:17:44.798] - stdout: TRUE
[16:17:44.798] - signal: TRUE
[16:17:44.798] - resignal: FALSE
[16:17:44.798] - force: TRUE
[16:17:44.798] - relayed: [n=2] TRUE, TRUE
[16:17:44.798] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:44.799] - relayed: [n=2] TRUE, TRUE
[16:17:44.799] - queued futures: [n=2] TRUE, TRUE
[16:17:44.799] signalConditionsASAP(NULL, pos=0) ... done
[16:17:44.799] resolve() on list ... DONE
[16:17:44.799] result() for ClusterFuture ...
[16:17:44.799] - result already collected: FutureResult
[16:17:44.799] result() for ClusterFuture ... done
[16:17:44.799] result() for ClusterFuture ...
[16:17:44.799] - result already collected: FutureResult
[16:17:44.799] result() for ClusterFuture ... done
[16:17:44.799] result() for ClusterFuture ...
[16:17:44.800] - result already collected: FutureResult
[16:17:44.800] result() for ClusterFuture ... done
[16:17:44.800] result() for ClusterFuture ...
[16:17:44.800] - result already collected: FutureResult
[16:17:44.800] result() for ClusterFuture ... done
[16:17:44.800]  - Number of value chunks collected: 2
[16:17:44.800] Resolving 2 futures (chunks) ... DONE
[16:17:44.800] Reducing values from 2 chunks ...
[16:17:44.800]  - Number of values collected after concatenation: 2
[16:17:44.800]  - Number of values expected: 2
[16:17:44.800] Reducing values from 2 chunks ... DONE
[16:17:44.801] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:17:44.801] getGlobalsAndPackagesXApply() ...
[16:17:44.801]  - future.globals: TRUE
[16:17:44.801] getGlobalsAndPackages() ...
[16:17:44.801] Searching for globals...
[16:17:44.802] - globals found: [1] ‘FUN’
[16:17:44.802] Searching for globals ... DONE
[16:17:44.802] Resolving globals: FALSE
[16:17:44.803] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:44.803] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:44.803] - globals: [1] ‘FUN’
[16:17:44.803] 
[16:17:44.803] getGlobalsAndPackages() ... DONE
[16:17:44.804]  - globals found/used: [n=1] ‘FUN’
[16:17:44.804]  - needed namespaces: [n=0] 
[16:17:44.804] Finding globals ... DONE
[16:17:44.804]  - use_args: TRUE
[16:17:44.804]  - Getting '...' globals ...
[16:17:44.804] resolve() on list ...
[16:17:44.804]  recursive: 0
[16:17:44.804]  length: 1
[16:17:44.805]  elements: ‘...’
[16:17:44.805]  length: 0 (resolved future 1)
[16:17:44.805] resolve() on list ... DONE
[16:17:44.805]    - '...' content: [n=0] 
[16:17:44.805] List of 1
[16:17:44.805]  $ ...: list()
[16:17:44.805]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.805]  - attr(*, "where")=List of 1
[16:17:44.805]   ..$ ...:<environment: 0x555be38fa778> 
[16:17:44.805]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.805]  - attr(*, "resolved")= logi TRUE
[16:17:44.805]  - attr(*, "total_size")= num NA
[16:17:44.807]  - Getting '...' globals ... DONE
[16:17:44.808] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:44.808] List of 2
[16:17:44.808]  $ ...future.FUN:function (x)  
[16:17:44.808]  $ ...          : list()
[16:17:44.808]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.808]  - attr(*, "where")=List of 2
[16:17:44.808]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:44.808]   ..$ ...          :<environment: 0x555be38fa778> 
[16:17:44.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.808]  - attr(*, "resolved")= logi FALSE
[16:17:44.808]  - attr(*, "total_size")= num 848
[16:17:44.810] Packages to be attached in all futures: [n=0] 
[16:17:44.810] getGlobalsAndPackagesXApply() ... DONE
[16:17:44.814] future_lapply() ...
[16:17:44.818] Number of chunks: 2
[16:17:44.818] getGlobalsAndPackagesXApply() ...
[16:17:44.818]  - future.globals: <name-value list> with names ‘list()’
[16:17:44.818]  - use_args: TRUE
[16:17:44.818] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:44.818] List of 2
[16:17:44.818]  $ ...          : list()
[16:17:44.818]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.818]  $ ...future.FUN:function (x)  
[16:17:44.818]  - attr(*, "where")=List of 2
[16:17:44.818]   ..$ ...          :<environment: 0x555be38fa778> 
[16:17:44.818]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:44.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.818]  - attr(*, "resolved")= logi FALSE
[16:17:44.818]  - attr(*, "total_size")= num NA
[16:17:44.822] Packages to be attached in all futures: [n=0] 
[16:17:44.822] getGlobalsAndPackagesXApply() ... DONE
[16:17:44.822] Number of futures (= number of chunks): 2
[16:17:44.822] Launching 2 futures (chunks) ...
[16:17:44.822] Chunk #1 of 2 ...
[16:17:44.822]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.822]  - seeds: <none>
[16:17:44.822]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.822] getGlobalsAndPackages() ...
[16:17:44.823] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.823] Resolving globals: FALSE
[16:17:44.823] Tweak future expression to call with '...' arguments ...
[16:17:44.823] {
[16:17:44.823]     do.call(function(...) {
[16:17:44.823]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.823]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.823]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.823]             on.exit(options(oopts), add = TRUE)
[16:17:44.823]         }
[16:17:44.823]         {
[16:17:44.823]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.823]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.823]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.823]             })
[16:17:44.823]         }
[16:17:44.823]     }, args = future.call.arguments)
[16:17:44.823] }
[16:17:44.823] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.824] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.824] 
[16:17:44.824] getGlobalsAndPackages() ... DONE
[16:17:44.824] run() for ‘Future’ ...
[16:17:44.824] - state: ‘created’
[16:17:44.824] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:44.838] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:44.838]   - Field: ‘node’
[16:17:44.838]   - Field: ‘label’
[16:17:44.838]   - Field: ‘local’
[16:17:44.838]   - Field: ‘owner’
[16:17:44.839]   - Field: ‘envir’
[16:17:44.839]   - Field: ‘workers’
[16:17:44.839]   - Field: ‘packages’
[16:17:44.839]   - Field: ‘gc’
[16:17:44.839]   - Field: ‘conditions’
[16:17:44.839]   - Field: ‘persistent’
[16:17:44.839]   - Field: ‘expr’
[16:17:44.839]   - Field: ‘uuid’
[16:17:44.839]   - Field: ‘seed’
[16:17:44.839]   - Field: ‘version’
[16:17:44.840]   - Field: ‘result’
[16:17:44.840]   - Field: ‘asynchronous’
[16:17:44.840]   - Field: ‘calls’
[16:17:44.840]   - Field: ‘globals’
[16:17:44.840]   - Field: ‘stdout’
[16:17:44.840]   - Field: ‘earlySignal’
[16:17:44.840]   - Field: ‘lazy’
[16:17:44.840]   - Field: ‘state’
[16:17:44.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:44.840] - Launch lazy future ...
[16:17:44.841] Packages needed by the future expression (n = 0): <none>
[16:17:44.841] Packages needed by future strategies (n = 0): <none>
[16:17:44.841] {
[16:17:44.841]     {
[16:17:44.841]         {
[16:17:44.841]             ...future.startTime <- base::Sys.time()
[16:17:44.841]             {
[16:17:44.841]                 {
[16:17:44.841]                   {
[16:17:44.841]                     {
[16:17:44.841]                       base::local({
[16:17:44.841]                         has_future <- base::requireNamespace("future", 
[16:17:44.841]                           quietly = TRUE)
[16:17:44.841]                         if (has_future) {
[16:17:44.841]                           ns <- base::getNamespace("future")
[16:17:44.841]                           version <- ns[[".package"]][["version"]]
[16:17:44.841]                           if (is.null(version)) 
[16:17:44.841]                             version <- utils::packageVersion("future")
[16:17:44.841]                         }
[16:17:44.841]                         else {
[16:17:44.841]                           version <- NULL
[16:17:44.841]                         }
[16:17:44.841]                         if (!has_future || version < "1.8.0") {
[16:17:44.841]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:44.841]                             "", base::R.version$version.string), 
[16:17:44.841]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:44.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:44.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:44.841]                               "release", "version")], collapse = " "), 
[16:17:44.841]                             hostname = base::Sys.info()[["nodename"]])
[16:17:44.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:44.841]                             info)
[16:17:44.841]                           info <- base::paste(info, collapse = "; ")
[16:17:44.841]                           if (!has_future) {
[16:17:44.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:44.841]                               info)
[16:17:44.841]                           }
[16:17:44.841]                           else {
[16:17:44.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:44.841]                               info, version)
[16:17:44.841]                           }
[16:17:44.841]                           base::stop(msg)
[16:17:44.841]                         }
[16:17:44.841]                       })
[16:17:44.841]                     }
[16:17:44.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:44.841]                     base::options(mc.cores = 1L)
[16:17:44.841]                   }
[16:17:44.841]                   ...future.strategy.old <- future::plan("list")
[16:17:44.841]                   options(future.plan = NULL)
[16:17:44.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:44.841]                 }
[16:17:44.841]                 ...future.workdir <- getwd()
[16:17:44.841]             }
[16:17:44.841]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:44.841]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:44.841]         }
[16:17:44.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:44.841]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:44.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:44.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:44.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:44.841]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:44.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:44.841]             base::names(...future.oldOptions))
[16:17:44.841]     }
[16:17:44.841]     if (FALSE) {
[16:17:44.841]     }
[16:17:44.841]     else {
[16:17:44.841]         if (TRUE) {
[16:17:44.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:44.841]                 open = "w")
[16:17:44.841]         }
[16:17:44.841]         else {
[16:17:44.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:44.841]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:44.841]         }
[16:17:44.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:44.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:44.841]             base::sink(type = "output", split = FALSE)
[16:17:44.841]             base::close(...future.stdout)
[16:17:44.841]         }, add = TRUE)
[16:17:44.841]     }
[16:17:44.841]     ...future.frame <- base::sys.nframe()
[16:17:44.841]     ...future.conditions <- base::list()
[16:17:44.841]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:44.841]     if (FALSE) {
[16:17:44.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:44.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:44.841]     }
[16:17:44.841]     ...future.result <- base::tryCatch({
[16:17:44.841]         base::withCallingHandlers({
[16:17:44.841]             ...future.value <- base::withVisible(base::local({
[16:17:44.841]                 ...future.makeSendCondition <- base::local({
[16:17:44.841]                   sendCondition <- NULL
[16:17:44.841]                   function(frame = 1L) {
[16:17:44.841]                     if (is.function(sendCondition)) 
[16:17:44.841]                       return(sendCondition)
[16:17:44.841]                     ns <- getNamespace("parallel")
[16:17:44.841]                     if (exists("sendData", mode = "function", 
[16:17:44.841]                       envir = ns)) {
[16:17:44.841]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:44.841]                         envir = ns)
[16:17:44.841]                       envir <- sys.frame(frame)
[16:17:44.841]                       master <- NULL
[16:17:44.841]                       while (!identical(envir, .GlobalEnv) && 
[16:17:44.841]                         !identical(envir, emptyenv())) {
[16:17:44.841]                         if (exists("master", mode = "list", envir = envir, 
[16:17:44.841]                           inherits = FALSE)) {
[16:17:44.841]                           master <- get("master", mode = "list", 
[16:17:44.841]                             envir = envir, inherits = FALSE)
[16:17:44.841]                           if (inherits(master, c("SOCKnode", 
[16:17:44.841]                             "SOCK0node"))) {
[16:17:44.841]                             sendCondition <<- function(cond) {
[16:17:44.841]                               data <- list(type = "VALUE", value = cond, 
[16:17:44.841]                                 success = TRUE)
[16:17:44.841]                               parallel_sendData(master, data)
[16:17:44.841]                             }
[16:17:44.841]                             return(sendCondition)
[16:17:44.841]                           }
[16:17:44.841]                         }
[16:17:44.841]                         frame <- frame + 1L
[16:17:44.841]                         envir <- sys.frame(frame)
[16:17:44.841]                       }
[16:17:44.841]                     }
[16:17:44.841]                     sendCondition <<- function(cond) NULL
[16:17:44.841]                   }
[16:17:44.841]                 })
[16:17:44.841]                 withCallingHandlers({
[16:17:44.841]                   {
[16:17:44.841]                     do.call(function(...) {
[16:17:44.841]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.841]                       if (!identical(...future.globals.maxSize.org, 
[16:17:44.841]                         ...future.globals.maxSize)) {
[16:17:44.841]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.841]                         on.exit(options(oopts), add = TRUE)
[16:17:44.841]                       }
[16:17:44.841]                       {
[16:17:44.841]                         lapply(seq_along(...future.elements_ii), 
[16:17:44.841]                           FUN = function(jj) {
[16:17:44.841]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.841]                             ...future.FUN(...future.X_jj, ...)
[16:17:44.841]                           })
[16:17:44.841]                       }
[16:17:44.841]                     }, args = future.call.arguments)
[16:17:44.841]                   }
[16:17:44.841]                 }, immediateCondition = function(cond) {
[16:17:44.841]                   sendCondition <- ...future.makeSendCondition()
[16:17:44.841]                   sendCondition(cond)
[16:17:44.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.841]                   {
[16:17:44.841]                     inherits <- base::inherits
[16:17:44.841]                     invokeRestart <- base::invokeRestart
[16:17:44.841]                     is.null <- base::is.null
[16:17:44.841]                     muffled <- FALSE
[16:17:44.841]                     if (inherits(cond, "message")) {
[16:17:44.841]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:44.841]                       if (muffled) 
[16:17:44.841]                         invokeRestart("muffleMessage")
[16:17:44.841]                     }
[16:17:44.841]                     else if (inherits(cond, "warning")) {
[16:17:44.841]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:44.841]                       if (muffled) 
[16:17:44.841]                         invokeRestart("muffleWarning")
[16:17:44.841]                     }
[16:17:44.841]                     else if (inherits(cond, "condition")) {
[16:17:44.841]                       if (!is.null(pattern)) {
[16:17:44.841]                         computeRestarts <- base::computeRestarts
[16:17:44.841]                         grepl <- base::grepl
[16:17:44.841]                         restarts <- computeRestarts(cond)
[16:17:44.841]                         for (restart in restarts) {
[16:17:44.841]                           name <- restart$name
[16:17:44.841]                           if (is.null(name)) 
[16:17:44.841]                             next
[16:17:44.841]                           if (!grepl(pattern, name)) 
[16:17:44.841]                             next
[16:17:44.841]                           invokeRestart(restart)
[16:17:44.841]                           muffled <- TRUE
[16:17:44.841]                           break
[16:17:44.841]                         }
[16:17:44.841]                       }
[16:17:44.841]                     }
[16:17:44.841]                     invisible(muffled)
[16:17:44.841]                   }
[16:17:44.841]                   muffleCondition(cond)
[16:17:44.841]                 })
[16:17:44.841]             }))
[16:17:44.841]             future::FutureResult(value = ...future.value$value, 
[16:17:44.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.841]                   ...future.rng), globalenv = if (FALSE) 
[16:17:44.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:44.841]                     ...future.globalenv.names))
[16:17:44.841]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:44.841]         }, condition = base::local({
[16:17:44.841]             c <- base::c
[16:17:44.841]             inherits <- base::inherits
[16:17:44.841]             invokeRestart <- base::invokeRestart
[16:17:44.841]             length <- base::length
[16:17:44.841]             list <- base::list
[16:17:44.841]             seq.int <- base::seq.int
[16:17:44.841]             signalCondition <- base::signalCondition
[16:17:44.841]             sys.calls <- base::sys.calls
[16:17:44.841]             `[[` <- base::`[[`
[16:17:44.841]             `+` <- base::`+`
[16:17:44.841]             `<<-` <- base::`<<-`
[16:17:44.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:44.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:44.841]                   3L)]
[16:17:44.841]             }
[16:17:44.841]             function(cond) {
[16:17:44.841]                 is_error <- inherits(cond, "error")
[16:17:44.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:44.841]                   NULL)
[16:17:44.841]                 if (is_error) {
[16:17:44.841]                   sessionInformation <- function() {
[16:17:44.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:44.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:44.841]                       search = base::search(), system = base::Sys.info())
[16:17:44.841]                   }
[16:17:44.841]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:44.841]                     cond$call), session = sessionInformation(), 
[16:17:44.841]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:44.841]                   signalCondition(cond)
[16:17:44.841]                 }
[16:17:44.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:44.841]                 "immediateCondition"))) {
[16:17:44.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:44.841]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:44.841]                   if (TRUE && !signal) {
[16:17:44.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.841]                     {
[16:17:44.841]                       inherits <- base::inherits
[16:17:44.841]                       invokeRestart <- base::invokeRestart
[16:17:44.841]                       is.null <- base::is.null
[16:17:44.841]                       muffled <- FALSE
[16:17:44.841]                       if (inherits(cond, "message")) {
[16:17:44.841]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.841]                         if (muffled) 
[16:17:44.841]                           invokeRestart("muffleMessage")
[16:17:44.841]                       }
[16:17:44.841]                       else if (inherits(cond, "warning")) {
[16:17:44.841]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.841]                         if (muffled) 
[16:17:44.841]                           invokeRestart("muffleWarning")
[16:17:44.841]                       }
[16:17:44.841]                       else if (inherits(cond, "condition")) {
[16:17:44.841]                         if (!is.null(pattern)) {
[16:17:44.841]                           computeRestarts <- base::computeRestarts
[16:17:44.841]                           grepl <- base::grepl
[16:17:44.841]                           restarts <- computeRestarts(cond)
[16:17:44.841]                           for (restart in restarts) {
[16:17:44.841]                             name <- restart$name
[16:17:44.841]                             if (is.null(name)) 
[16:17:44.841]                               next
[16:17:44.841]                             if (!grepl(pattern, name)) 
[16:17:44.841]                               next
[16:17:44.841]                             invokeRestart(restart)
[16:17:44.841]                             muffled <- TRUE
[16:17:44.841]                             break
[16:17:44.841]                           }
[16:17:44.841]                         }
[16:17:44.841]                       }
[16:17:44.841]                       invisible(muffled)
[16:17:44.841]                     }
[16:17:44.841]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.841]                   }
[16:17:44.841]                 }
[16:17:44.841]                 else {
[16:17:44.841]                   if (TRUE) {
[16:17:44.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.841]                     {
[16:17:44.841]                       inherits <- base::inherits
[16:17:44.841]                       invokeRestart <- base::invokeRestart
[16:17:44.841]                       is.null <- base::is.null
[16:17:44.841]                       muffled <- FALSE
[16:17:44.841]                       if (inherits(cond, "message")) {
[16:17:44.841]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.841]                         if (muffled) 
[16:17:44.841]                           invokeRestart("muffleMessage")
[16:17:44.841]                       }
[16:17:44.841]                       else if (inherits(cond, "warning")) {
[16:17:44.841]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.841]                         if (muffled) 
[16:17:44.841]                           invokeRestart("muffleWarning")
[16:17:44.841]                       }
[16:17:44.841]                       else if (inherits(cond, "condition")) {
[16:17:44.841]                         if (!is.null(pattern)) {
[16:17:44.841]                           computeRestarts <- base::computeRestarts
[16:17:44.841]                           grepl <- base::grepl
[16:17:44.841]                           restarts <- computeRestarts(cond)
[16:17:44.841]                           for (restart in restarts) {
[16:17:44.841]                             name <- restart$name
[16:17:44.841]                             if (is.null(name)) 
[16:17:44.841]                               next
[16:17:44.841]                             if (!grepl(pattern, name)) 
[16:17:44.841]                               next
[16:17:44.841]                             invokeRestart(restart)
[16:17:44.841]                             muffled <- TRUE
[16:17:44.841]                             break
[16:17:44.841]                           }
[16:17:44.841]                         }
[16:17:44.841]                       }
[16:17:44.841]                       invisible(muffled)
[16:17:44.841]                     }
[16:17:44.841]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.841]                   }
[16:17:44.841]                 }
[16:17:44.841]             }
[16:17:44.841]         }))
[16:17:44.841]     }, error = function(ex) {
[16:17:44.841]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:44.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.841]                 ...future.rng), started = ...future.startTime, 
[16:17:44.841]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:44.841]             version = "1.8"), class = "FutureResult")
[16:17:44.841]     }, finally = {
[16:17:44.841]         if (!identical(...future.workdir, getwd())) 
[16:17:44.841]             setwd(...future.workdir)
[16:17:44.841]         {
[16:17:44.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:44.841]                 ...future.oldOptions$nwarnings <- NULL
[16:17:44.841]             }
[16:17:44.841]             base::options(...future.oldOptions)
[16:17:44.841]             if (.Platform$OS.type == "windows") {
[16:17:44.841]                 old_names <- names(...future.oldEnvVars)
[16:17:44.841]                 envs <- base::Sys.getenv()
[16:17:44.841]                 names <- names(envs)
[16:17:44.841]                 common <- intersect(names, old_names)
[16:17:44.841]                 added <- setdiff(names, old_names)
[16:17:44.841]                 removed <- setdiff(old_names, names)
[16:17:44.841]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:44.841]                   envs[common]]
[16:17:44.841]                 NAMES <- toupper(changed)
[16:17:44.841]                 args <- list()
[16:17:44.841]                 for (kk in seq_along(NAMES)) {
[16:17:44.841]                   name <- changed[[kk]]
[16:17:44.841]                   NAME <- NAMES[[kk]]
[16:17:44.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.841]                     next
[16:17:44.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.841]                 }
[16:17:44.841]                 NAMES <- toupper(added)
[16:17:44.841]                 for (kk in seq_along(NAMES)) {
[16:17:44.841]                   name <- added[[kk]]
[16:17:44.841]                   NAME <- NAMES[[kk]]
[16:17:44.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.841]                     next
[16:17:44.841]                   args[[name]] <- ""
[16:17:44.841]                 }
[16:17:44.841]                 NAMES <- toupper(removed)
[16:17:44.841]                 for (kk in seq_along(NAMES)) {
[16:17:44.841]                   name <- removed[[kk]]
[16:17:44.841]                   NAME <- NAMES[[kk]]
[16:17:44.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.841]                     next
[16:17:44.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.841]                 }
[16:17:44.841]                 if (length(args) > 0) 
[16:17:44.841]                   base::do.call(base::Sys.setenv, args = args)
[16:17:44.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:44.841]             }
[16:17:44.841]             else {
[16:17:44.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:44.841]             }
[16:17:44.841]             {
[16:17:44.841]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:44.841]                   0L) {
[16:17:44.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:44.841]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:44.841]                   base::options(opts)
[16:17:44.841]                 }
[16:17:44.841]                 {
[16:17:44.841]                   {
[16:17:44.841]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:44.841]                     NULL
[16:17:44.841]                   }
[16:17:44.841]                   options(future.plan = NULL)
[16:17:44.841]                   if (is.na(NA_character_)) 
[16:17:44.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:44.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:44.841]                     .init = FALSE)
[16:17:44.841]                 }
[16:17:44.841]             }
[16:17:44.841]         }
[16:17:44.841]     })
[16:17:44.841]     if (TRUE) {
[16:17:44.841]         base::sink(type = "output", split = FALSE)
[16:17:44.841]         if (TRUE) {
[16:17:44.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:44.841]         }
[16:17:44.841]         else {
[16:17:44.841]             ...future.result["stdout"] <- base::list(NULL)
[16:17:44.841]         }
[16:17:44.841]         base::close(...future.stdout)
[16:17:44.841]         ...future.stdout <- NULL
[16:17:44.841]     }
[16:17:44.841]     ...future.result$conditions <- ...future.conditions
[16:17:44.841]     ...future.result$finished <- base::Sys.time()
[16:17:44.841]     ...future.result
[16:17:44.841] }
[16:17:44.844] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:17:44.844] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:44.845] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.845] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:17:44.845] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:17:44.845] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:17:44.846] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:17:44.846] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:44.846] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.847] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:17:44.847] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:17:44.847] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:17:44.848] MultisessionFuture started
[16:17:44.848] - Launch lazy future ... done
[16:17:44.848] run() for ‘MultisessionFuture’ ... done
[16:17:44.848] Created future:
[16:17:44.848] MultisessionFuture:
[16:17:44.848] Label: ‘future_apply-1’
[16:17:44.848] Expression:
[16:17:44.848] {
[16:17:44.848]     do.call(function(...) {
[16:17:44.848]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.848]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.848]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.848]             on.exit(options(oopts), add = TRUE)
[16:17:44.848]         }
[16:17:44.848]         {
[16:17:44.848]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.848]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.848]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.848]             })
[16:17:44.848]         }
[16:17:44.848]     }, args = future.call.arguments)
[16:17:44.848] }
[16:17:44.848] Lazy evaluation: FALSE
[16:17:44.848] Asynchronous evaluation: TRUE
[16:17:44.848] Local evaluation: TRUE
[16:17:44.848] Environment: R_GlobalEnv
[16:17:44.848] Capture standard output: TRUE
[16:17:44.848] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.848] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.848] Packages: <none>
[16:17:44.848] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.848] Resolved: FALSE
[16:17:44.848] Value: <not collected>
[16:17:44.848] Conditions captured: <none>
[16:17:44.848] Early signaling: FALSE
[16:17:44.848] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.848] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.860] Chunk #1 of 2 ... DONE
[16:17:44.860] Chunk #2 of 2 ...
[16:17:44.860]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.860]  - seeds: <none>
[16:17:44.860]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.860] getGlobalsAndPackages() ...
[16:17:44.860] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.861] Resolving globals: FALSE
[16:17:44.861] Tweak future expression to call with '...' arguments ...
[16:17:44.861] {
[16:17:44.861]     do.call(function(...) {
[16:17:44.861]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.861]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.861]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.861]             on.exit(options(oopts), add = TRUE)
[16:17:44.861]         }
[16:17:44.861]         {
[16:17:44.861]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.861]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.861]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.861]             })
[16:17:44.861]         }
[16:17:44.861]     }, args = future.call.arguments)
[16:17:44.861] }
[16:17:44.861] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.863] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.863] 
[16:17:44.864] getGlobalsAndPackages() ... DONE
[16:17:44.864] run() for ‘Future’ ...
[16:17:44.864] - state: ‘created’
[16:17:44.864] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:44.878] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.878] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:44.878]   - Field: ‘node’
[16:17:44.878]   - Field: ‘label’
[16:17:44.878]   - Field: ‘local’
[16:17:44.879]   - Field: ‘owner’
[16:17:44.879]   - Field: ‘envir’
[16:17:44.879]   - Field: ‘workers’
[16:17:44.879]   - Field: ‘packages’
[16:17:44.879]   - Field: ‘gc’
[16:17:44.879]   - Field: ‘conditions’
[16:17:44.879]   - Field: ‘persistent’
[16:17:44.879]   - Field: ‘expr’
[16:17:44.879]   - Field: ‘uuid’
[16:17:44.879]   - Field: ‘seed’
[16:17:44.879]   - Field: ‘version’
[16:17:44.880]   - Field: ‘result’
[16:17:44.880]   - Field: ‘asynchronous’
[16:17:44.880]   - Field: ‘calls’
[16:17:44.880]   - Field: ‘globals’
[16:17:44.880]   - Field: ‘stdout’
[16:17:44.880]   - Field: ‘earlySignal’
[16:17:44.880]   - Field: ‘lazy’
[16:17:44.880]   - Field: ‘state’
[16:17:44.880] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:44.880] - Launch lazy future ...
[16:17:44.881] Packages needed by the future expression (n = 0): <none>
[16:17:44.881] Packages needed by future strategies (n = 0): <none>
[16:17:44.881] {
[16:17:44.881]     {
[16:17:44.881]         {
[16:17:44.881]             ...future.startTime <- base::Sys.time()
[16:17:44.881]             {
[16:17:44.881]                 {
[16:17:44.881]                   {
[16:17:44.881]                     {
[16:17:44.881]                       base::local({
[16:17:44.881]                         has_future <- base::requireNamespace("future", 
[16:17:44.881]                           quietly = TRUE)
[16:17:44.881]                         if (has_future) {
[16:17:44.881]                           ns <- base::getNamespace("future")
[16:17:44.881]                           version <- ns[[".package"]][["version"]]
[16:17:44.881]                           if (is.null(version)) 
[16:17:44.881]                             version <- utils::packageVersion("future")
[16:17:44.881]                         }
[16:17:44.881]                         else {
[16:17:44.881]                           version <- NULL
[16:17:44.881]                         }
[16:17:44.881]                         if (!has_future || version < "1.8.0") {
[16:17:44.881]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:44.881]                             "", base::R.version$version.string), 
[16:17:44.881]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:44.881]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:44.881]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:44.881]                               "release", "version")], collapse = " "), 
[16:17:44.881]                             hostname = base::Sys.info()[["nodename"]])
[16:17:44.881]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:44.881]                             info)
[16:17:44.881]                           info <- base::paste(info, collapse = "; ")
[16:17:44.881]                           if (!has_future) {
[16:17:44.881]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:44.881]                               info)
[16:17:44.881]                           }
[16:17:44.881]                           else {
[16:17:44.881]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:44.881]                               info, version)
[16:17:44.881]                           }
[16:17:44.881]                           base::stop(msg)
[16:17:44.881]                         }
[16:17:44.881]                       })
[16:17:44.881]                     }
[16:17:44.881]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:44.881]                     base::options(mc.cores = 1L)
[16:17:44.881]                   }
[16:17:44.881]                   ...future.strategy.old <- future::plan("list")
[16:17:44.881]                   options(future.plan = NULL)
[16:17:44.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:44.881]                 }
[16:17:44.881]                 ...future.workdir <- getwd()
[16:17:44.881]             }
[16:17:44.881]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:44.881]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:44.881]         }
[16:17:44.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:44.881]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:44.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:44.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:44.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:44.881]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:44.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:44.881]             base::names(...future.oldOptions))
[16:17:44.881]     }
[16:17:44.881]     if (FALSE) {
[16:17:44.881]     }
[16:17:44.881]     else {
[16:17:44.881]         if (TRUE) {
[16:17:44.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:44.881]                 open = "w")
[16:17:44.881]         }
[16:17:44.881]         else {
[16:17:44.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:44.881]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:44.881]         }
[16:17:44.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:44.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:44.881]             base::sink(type = "output", split = FALSE)
[16:17:44.881]             base::close(...future.stdout)
[16:17:44.881]         }, add = TRUE)
[16:17:44.881]     }
[16:17:44.881]     ...future.frame <- base::sys.nframe()
[16:17:44.881]     ...future.conditions <- base::list()
[16:17:44.881]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:44.881]     if (FALSE) {
[16:17:44.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:44.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:44.881]     }
[16:17:44.881]     ...future.result <- base::tryCatch({
[16:17:44.881]         base::withCallingHandlers({
[16:17:44.881]             ...future.value <- base::withVisible(base::local({
[16:17:44.881]                 ...future.makeSendCondition <- base::local({
[16:17:44.881]                   sendCondition <- NULL
[16:17:44.881]                   function(frame = 1L) {
[16:17:44.881]                     if (is.function(sendCondition)) 
[16:17:44.881]                       return(sendCondition)
[16:17:44.881]                     ns <- getNamespace("parallel")
[16:17:44.881]                     if (exists("sendData", mode = "function", 
[16:17:44.881]                       envir = ns)) {
[16:17:44.881]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:44.881]                         envir = ns)
[16:17:44.881]                       envir <- sys.frame(frame)
[16:17:44.881]                       master <- NULL
[16:17:44.881]                       while (!identical(envir, .GlobalEnv) && 
[16:17:44.881]                         !identical(envir, emptyenv())) {
[16:17:44.881]                         if (exists("master", mode = "list", envir = envir, 
[16:17:44.881]                           inherits = FALSE)) {
[16:17:44.881]                           master <- get("master", mode = "list", 
[16:17:44.881]                             envir = envir, inherits = FALSE)
[16:17:44.881]                           if (inherits(master, c("SOCKnode", 
[16:17:44.881]                             "SOCK0node"))) {
[16:17:44.881]                             sendCondition <<- function(cond) {
[16:17:44.881]                               data <- list(type = "VALUE", value = cond, 
[16:17:44.881]                                 success = TRUE)
[16:17:44.881]                               parallel_sendData(master, data)
[16:17:44.881]                             }
[16:17:44.881]                             return(sendCondition)
[16:17:44.881]                           }
[16:17:44.881]                         }
[16:17:44.881]                         frame <- frame + 1L
[16:17:44.881]                         envir <- sys.frame(frame)
[16:17:44.881]                       }
[16:17:44.881]                     }
[16:17:44.881]                     sendCondition <<- function(cond) NULL
[16:17:44.881]                   }
[16:17:44.881]                 })
[16:17:44.881]                 withCallingHandlers({
[16:17:44.881]                   {
[16:17:44.881]                     do.call(function(...) {
[16:17:44.881]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.881]                       if (!identical(...future.globals.maxSize.org, 
[16:17:44.881]                         ...future.globals.maxSize)) {
[16:17:44.881]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.881]                         on.exit(options(oopts), add = TRUE)
[16:17:44.881]                       }
[16:17:44.881]                       {
[16:17:44.881]                         lapply(seq_along(...future.elements_ii), 
[16:17:44.881]                           FUN = function(jj) {
[16:17:44.881]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.881]                             ...future.FUN(...future.X_jj, ...)
[16:17:44.881]                           })
[16:17:44.881]                       }
[16:17:44.881]                     }, args = future.call.arguments)
[16:17:44.881]                   }
[16:17:44.881]                 }, immediateCondition = function(cond) {
[16:17:44.881]                   sendCondition <- ...future.makeSendCondition()
[16:17:44.881]                   sendCondition(cond)
[16:17:44.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.881]                   {
[16:17:44.881]                     inherits <- base::inherits
[16:17:44.881]                     invokeRestart <- base::invokeRestart
[16:17:44.881]                     is.null <- base::is.null
[16:17:44.881]                     muffled <- FALSE
[16:17:44.881]                     if (inherits(cond, "message")) {
[16:17:44.881]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:44.881]                       if (muffled) 
[16:17:44.881]                         invokeRestart("muffleMessage")
[16:17:44.881]                     }
[16:17:44.881]                     else if (inherits(cond, "warning")) {
[16:17:44.881]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:44.881]                       if (muffled) 
[16:17:44.881]                         invokeRestart("muffleWarning")
[16:17:44.881]                     }
[16:17:44.881]                     else if (inherits(cond, "condition")) {
[16:17:44.881]                       if (!is.null(pattern)) {
[16:17:44.881]                         computeRestarts <- base::computeRestarts
[16:17:44.881]                         grepl <- base::grepl
[16:17:44.881]                         restarts <- computeRestarts(cond)
[16:17:44.881]                         for (restart in restarts) {
[16:17:44.881]                           name <- restart$name
[16:17:44.881]                           if (is.null(name)) 
[16:17:44.881]                             next
[16:17:44.881]                           if (!grepl(pattern, name)) 
[16:17:44.881]                             next
[16:17:44.881]                           invokeRestart(restart)
[16:17:44.881]                           muffled <- TRUE
[16:17:44.881]                           break
[16:17:44.881]                         }
[16:17:44.881]                       }
[16:17:44.881]                     }
[16:17:44.881]                     invisible(muffled)
[16:17:44.881]                   }
[16:17:44.881]                   muffleCondition(cond)
[16:17:44.881]                 })
[16:17:44.881]             }))
[16:17:44.881]             future::FutureResult(value = ...future.value$value, 
[16:17:44.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.881]                   ...future.rng), globalenv = if (FALSE) 
[16:17:44.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:44.881]                     ...future.globalenv.names))
[16:17:44.881]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:44.881]         }, condition = base::local({
[16:17:44.881]             c <- base::c
[16:17:44.881]             inherits <- base::inherits
[16:17:44.881]             invokeRestart <- base::invokeRestart
[16:17:44.881]             length <- base::length
[16:17:44.881]             list <- base::list
[16:17:44.881]             seq.int <- base::seq.int
[16:17:44.881]             signalCondition <- base::signalCondition
[16:17:44.881]             sys.calls <- base::sys.calls
[16:17:44.881]             `[[` <- base::`[[`
[16:17:44.881]             `+` <- base::`+`
[16:17:44.881]             `<<-` <- base::`<<-`
[16:17:44.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:44.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:44.881]                   3L)]
[16:17:44.881]             }
[16:17:44.881]             function(cond) {
[16:17:44.881]                 is_error <- inherits(cond, "error")
[16:17:44.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:44.881]                   NULL)
[16:17:44.881]                 if (is_error) {
[16:17:44.881]                   sessionInformation <- function() {
[16:17:44.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:44.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:44.881]                       search = base::search(), system = base::Sys.info())
[16:17:44.881]                   }
[16:17:44.881]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:44.881]                     cond$call), session = sessionInformation(), 
[16:17:44.881]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:44.881]                   signalCondition(cond)
[16:17:44.881]                 }
[16:17:44.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:44.881]                 "immediateCondition"))) {
[16:17:44.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:44.881]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:44.881]                   if (TRUE && !signal) {
[16:17:44.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.881]                     {
[16:17:44.881]                       inherits <- base::inherits
[16:17:44.881]                       invokeRestart <- base::invokeRestart
[16:17:44.881]                       is.null <- base::is.null
[16:17:44.881]                       muffled <- FALSE
[16:17:44.881]                       if (inherits(cond, "message")) {
[16:17:44.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.881]                         if (muffled) 
[16:17:44.881]                           invokeRestart("muffleMessage")
[16:17:44.881]                       }
[16:17:44.881]                       else if (inherits(cond, "warning")) {
[16:17:44.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.881]                         if (muffled) 
[16:17:44.881]                           invokeRestart("muffleWarning")
[16:17:44.881]                       }
[16:17:44.881]                       else if (inherits(cond, "condition")) {
[16:17:44.881]                         if (!is.null(pattern)) {
[16:17:44.881]                           computeRestarts <- base::computeRestarts
[16:17:44.881]                           grepl <- base::grepl
[16:17:44.881]                           restarts <- computeRestarts(cond)
[16:17:44.881]                           for (restart in restarts) {
[16:17:44.881]                             name <- restart$name
[16:17:44.881]                             if (is.null(name)) 
[16:17:44.881]                               next
[16:17:44.881]                             if (!grepl(pattern, name)) 
[16:17:44.881]                               next
[16:17:44.881]                             invokeRestart(restart)
[16:17:44.881]                             muffled <- TRUE
[16:17:44.881]                             break
[16:17:44.881]                           }
[16:17:44.881]                         }
[16:17:44.881]                       }
[16:17:44.881]                       invisible(muffled)
[16:17:44.881]                     }
[16:17:44.881]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.881]                   }
[16:17:44.881]                 }
[16:17:44.881]                 else {
[16:17:44.881]                   if (TRUE) {
[16:17:44.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.881]                     {
[16:17:44.881]                       inherits <- base::inherits
[16:17:44.881]                       invokeRestart <- base::invokeRestart
[16:17:44.881]                       is.null <- base::is.null
[16:17:44.881]                       muffled <- FALSE
[16:17:44.881]                       if (inherits(cond, "message")) {
[16:17:44.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.881]                         if (muffled) 
[16:17:44.881]                           invokeRestart("muffleMessage")
[16:17:44.881]                       }
[16:17:44.881]                       else if (inherits(cond, "warning")) {
[16:17:44.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.881]                         if (muffled) 
[16:17:44.881]                           invokeRestart("muffleWarning")
[16:17:44.881]                       }
[16:17:44.881]                       else if (inherits(cond, "condition")) {
[16:17:44.881]                         if (!is.null(pattern)) {
[16:17:44.881]                           computeRestarts <- base::computeRestarts
[16:17:44.881]                           grepl <- base::grepl
[16:17:44.881]                           restarts <- computeRestarts(cond)
[16:17:44.881]                           for (restart in restarts) {
[16:17:44.881]                             name <- restart$name
[16:17:44.881]                             if (is.null(name)) 
[16:17:44.881]                               next
[16:17:44.881]                             if (!grepl(pattern, name)) 
[16:17:44.881]                               next
[16:17:44.881]                             invokeRestart(restart)
[16:17:44.881]                             muffled <- TRUE
[16:17:44.881]                             break
[16:17:44.881]                           }
[16:17:44.881]                         }
[16:17:44.881]                       }
[16:17:44.881]                       invisible(muffled)
[16:17:44.881]                     }
[16:17:44.881]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.881]                   }
[16:17:44.881]                 }
[16:17:44.881]             }
[16:17:44.881]         }))
[16:17:44.881]     }, error = function(ex) {
[16:17:44.881]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:44.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.881]                 ...future.rng), started = ...future.startTime, 
[16:17:44.881]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:44.881]             version = "1.8"), class = "FutureResult")
[16:17:44.881]     }, finally = {
[16:17:44.881]         if (!identical(...future.workdir, getwd())) 
[16:17:44.881]             setwd(...future.workdir)
[16:17:44.881]         {
[16:17:44.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:44.881]                 ...future.oldOptions$nwarnings <- NULL
[16:17:44.881]             }
[16:17:44.881]             base::options(...future.oldOptions)
[16:17:44.881]             if (.Platform$OS.type == "windows") {
[16:17:44.881]                 old_names <- names(...future.oldEnvVars)
[16:17:44.881]                 envs <- base::Sys.getenv()
[16:17:44.881]                 names <- names(envs)
[16:17:44.881]                 common <- intersect(names, old_names)
[16:17:44.881]                 added <- setdiff(names, old_names)
[16:17:44.881]                 removed <- setdiff(old_names, names)
[16:17:44.881]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:44.881]                   envs[common]]
[16:17:44.881]                 NAMES <- toupper(changed)
[16:17:44.881]                 args <- list()
[16:17:44.881]                 for (kk in seq_along(NAMES)) {
[16:17:44.881]                   name <- changed[[kk]]
[16:17:44.881]                   NAME <- NAMES[[kk]]
[16:17:44.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.881]                     next
[16:17:44.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.881]                 }
[16:17:44.881]                 NAMES <- toupper(added)
[16:17:44.881]                 for (kk in seq_along(NAMES)) {
[16:17:44.881]                   name <- added[[kk]]
[16:17:44.881]                   NAME <- NAMES[[kk]]
[16:17:44.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.881]                     next
[16:17:44.881]                   args[[name]] <- ""
[16:17:44.881]                 }
[16:17:44.881]                 NAMES <- toupper(removed)
[16:17:44.881]                 for (kk in seq_along(NAMES)) {
[16:17:44.881]                   name <- removed[[kk]]
[16:17:44.881]                   NAME <- NAMES[[kk]]
[16:17:44.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.881]                     next
[16:17:44.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.881]                 }
[16:17:44.881]                 if (length(args) > 0) 
[16:17:44.881]                   base::do.call(base::Sys.setenv, args = args)
[16:17:44.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:44.881]             }
[16:17:44.881]             else {
[16:17:44.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:44.881]             }
[16:17:44.881]             {
[16:17:44.881]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:44.881]                   0L) {
[16:17:44.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:44.881]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:44.881]                   base::options(opts)
[16:17:44.881]                 }
[16:17:44.881]                 {
[16:17:44.881]                   {
[16:17:44.881]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:44.881]                     NULL
[16:17:44.881]                   }
[16:17:44.881]                   options(future.plan = NULL)
[16:17:44.881]                   if (is.na(NA_character_)) 
[16:17:44.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:44.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:44.881]                     .init = FALSE)
[16:17:44.881]                 }
[16:17:44.881]             }
[16:17:44.881]         }
[16:17:44.881]     })
[16:17:44.881]     if (TRUE) {
[16:17:44.881]         base::sink(type = "output", split = FALSE)
[16:17:44.881]         if (TRUE) {
[16:17:44.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:44.881]         }
[16:17:44.881]         else {
[16:17:44.881]             ...future.result["stdout"] <- base::list(NULL)
[16:17:44.881]         }
[16:17:44.881]         base::close(...future.stdout)
[16:17:44.881]         ...future.stdout <- NULL
[16:17:44.881]     }
[16:17:44.881]     ...future.result$conditions <- ...future.conditions
[16:17:44.881]     ...future.result$finished <- base::Sys.time()
[16:17:44.881]     ...future.result
[16:17:44.881] }
[16:17:44.884] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:17:44.884] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:44.885] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:44.885] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:17:44.885] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:17:44.885] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[16:17:44.885] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[16:17:44.886] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:44.886] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:44.886] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:17:44.886] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:17:44.886] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:17:44.887] MultisessionFuture started
[16:17:44.887] - Launch lazy future ... done
[16:17:44.887] run() for ‘MultisessionFuture’ ... done
[16:17:44.887] Created future:
[16:17:44.887] MultisessionFuture:
[16:17:44.887] Label: ‘future_apply-2’
[16:17:44.887] Expression:
[16:17:44.887] {
[16:17:44.887]     do.call(function(...) {
[16:17:44.887]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.887]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.887]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.887]             on.exit(options(oopts), add = TRUE)
[16:17:44.887]         }
[16:17:44.887]         {
[16:17:44.887]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.887]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.887]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.887]             })
[16:17:44.887]         }
[16:17:44.887]     }, args = future.call.arguments)
[16:17:44.887] }
[16:17:44.887] Lazy evaluation: FALSE
[16:17:44.887] Asynchronous evaluation: TRUE
[16:17:44.887] Local evaluation: TRUE
[16:17:44.887] Environment: R_GlobalEnv
[16:17:44.887] Capture standard output: TRUE
[16:17:44.887] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.887] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.887] Packages: <none>
[16:17:44.887] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.887] Resolved: FALSE
[16:17:44.887] Value: <not collected>
[16:17:44.887] Conditions captured: <none>
[16:17:44.887] Early signaling: FALSE
[16:17:44.887] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.887] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.899] Chunk #2 of 2 ... DONE
[16:17:44.899] Launching 2 futures (chunks) ... DONE
[16:17:44.899] Resolving 2 futures (chunks) ...
[16:17:44.899] resolve() on list ...
[16:17:44.899]  recursive: 0
[16:17:44.899]  length: 2
[16:17:44.900] 
[16:17:44.900] receiveMessageFromWorker() for ClusterFuture ...
[16:17:44.900] - Validating connection of MultisessionFuture
[16:17:44.900] - received message: FutureResult
[16:17:44.900] - Received FutureResult
[16:17:44.901] - Erased future from FutureRegistry
[16:17:44.901] result() for ClusterFuture ...
[16:17:44.901] - result already collected: FutureResult
[16:17:44.901] result() for ClusterFuture ... done
[16:17:44.901] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:44.901] Future #1
[16:17:44.901] result() for ClusterFuture ...
[16:17:44.901] - result already collected: FutureResult
[16:17:44.901] result() for ClusterFuture ... done
[16:17:44.901] result() for ClusterFuture ...
[16:17:44.901] - result already collected: FutureResult
[16:17:44.901] result() for ClusterFuture ... done
[16:17:44.902] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:44.902] - nx: 2
[16:17:44.902] - relay: TRUE
[16:17:44.902] - stdout: TRUE
[16:17:44.902] - signal: TRUE
[16:17:44.902] - resignal: FALSE
[16:17:44.902] - force: TRUE
[16:17:44.902] - relayed: [n=2] FALSE, FALSE
[16:17:44.902] - queued futures: [n=2] FALSE, FALSE
[16:17:44.902]  - until=1
[16:17:44.902]  - relaying element #1
[16:17:44.903] result() for ClusterFuture ...
[16:17:44.903] - result already collected: FutureResult
[16:17:44.903] result() for ClusterFuture ... done
[16:17:44.903] result() for ClusterFuture ...
[16:17:44.903] - result already collected: FutureResult
[16:17:44.903] result() for ClusterFuture ... done
[16:17:44.903] result() for ClusterFuture ...
[16:17:44.903] - result already collected: FutureResult
[16:17:44.903] result() for ClusterFuture ... done
[16:17:44.903] result() for ClusterFuture ...
[16:17:44.903] - result already collected: FutureResult
[16:17:44.904] result() for ClusterFuture ... done
[16:17:44.904] - relayed: [n=2] TRUE, FALSE
[16:17:44.904] - queued futures: [n=2] TRUE, FALSE
[16:17:44.904] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:44.904]  length: 1 (resolved future 1)
[16:17:44.930] receiveMessageFromWorker() for ClusterFuture ...
[16:17:44.930] - Validating connection of MultisessionFuture
[16:17:44.930] - received message: FutureResult
[16:17:44.930] - Received FutureResult
[16:17:44.930] - Erased future from FutureRegistry
[16:17:44.930] result() for ClusterFuture ...
[16:17:44.930] - result already collected: FutureResult
[16:17:44.930] result() for ClusterFuture ... done
[16:17:44.931] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:44.931] Future #2
[16:17:44.931] result() for ClusterFuture ...
[16:17:44.931] - result already collected: FutureResult
[16:17:44.931] result() for ClusterFuture ... done
[16:17:44.931] result() for ClusterFuture ...
[16:17:44.931] - result already collected: FutureResult
[16:17:44.931] result() for ClusterFuture ... done
[16:17:44.931] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:44.931] - nx: 2
[16:17:44.931] - relay: TRUE
[16:17:44.932] - stdout: TRUE
[16:17:44.932] - signal: TRUE
[16:17:44.932] - resignal: FALSE
[16:17:44.932] - force: TRUE
[16:17:44.932] - relayed: [n=2] TRUE, FALSE
[16:17:44.932] - queued futures: [n=2] TRUE, FALSE
[16:17:44.932]  - until=2
[16:17:44.932]  - relaying element #2
[16:17:44.932] result() for ClusterFuture ...
[16:17:44.932] - result already collected: FutureResult
[16:17:44.932] result() for ClusterFuture ... done
[16:17:44.933] result() for ClusterFuture ...
[16:17:44.933] - result already collected: FutureResult
[16:17:44.933] result() for ClusterFuture ... done
[16:17:44.933] result() for ClusterFuture ...
[16:17:44.933] - result already collected: FutureResult
[16:17:44.933] result() for ClusterFuture ... done
[16:17:44.933] result() for ClusterFuture ...
[16:17:44.933] - result already collected: FutureResult
[16:17:44.933] result() for ClusterFuture ... done
[16:17:44.933] - relayed: [n=2] TRUE, TRUE
[16:17:44.933] - queued futures: [n=2] TRUE, TRUE
[16:17:44.933] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:44.934]  length: 0 (resolved future 2)
[16:17:44.934] Relaying remaining futures
[16:17:44.934] signalConditionsASAP(NULL, pos=0) ...
[16:17:44.934] - nx: 2
[16:17:44.934] - relay: TRUE
[16:17:44.934] - stdout: TRUE
[16:17:44.934] - signal: TRUE
[16:17:44.934] - resignal: FALSE
[16:17:44.934] - force: TRUE
[16:17:44.934] - relayed: [n=2] TRUE, TRUE
[16:17:44.934] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:44.935] - relayed: [n=2] TRUE, TRUE
[16:17:44.935] - queued futures: [n=2] TRUE, TRUE
[16:17:44.935] signalConditionsASAP(NULL, pos=0) ... done
[16:17:44.935] resolve() on list ... DONE
[16:17:44.935] result() for ClusterFuture ...
[16:17:44.935] - result already collected: FutureResult
[16:17:44.935] result() for ClusterFuture ... done
[16:17:44.935] result() for ClusterFuture ...
[16:17:44.935] - result already collected: FutureResult
[16:17:44.935] result() for ClusterFuture ... done
[16:17:44.935] result() for ClusterFuture ...
[16:17:44.936] - result already collected: FutureResult
[16:17:44.936] result() for ClusterFuture ... done
[16:17:44.936] result() for ClusterFuture ...
[16:17:44.936] - result already collected: FutureResult
[16:17:44.936] result() for ClusterFuture ... done
[16:17:44.936]  - Number of value chunks collected: 2
[16:17:44.936] Resolving 2 futures (chunks) ... DONE
[16:17:44.936] Reducing values from 2 chunks ...
[16:17:44.936]  - Number of values collected after concatenation: 6
[16:17:44.936]  - Number of values expected: 6
[16:17:44.936] Reducing values from 2 chunks ... DONE
[16:17:44.937] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:17:44.937] getGlobalsAndPackagesXApply() ...
[16:17:44.937]  - future.globals: TRUE
[16:17:44.937] getGlobalsAndPackages() ...
[16:17:44.937] Searching for globals...
[16:17:44.939] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:17:44.939] Searching for globals ... DONE
[16:17:44.939] Resolving globals: FALSE
[16:17:44.939] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:17:44.940] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:17:44.940] - globals: [1] ‘FUN’
[16:17:44.940] 
[16:17:44.940] getGlobalsAndPackages() ... DONE
[16:17:44.940]  - globals found/used: [n=1] ‘FUN’
[16:17:44.940]  - needed namespaces: [n=0] 
[16:17:44.940] Finding globals ... DONE
[16:17:44.940]  - use_args: TRUE
[16:17:44.940]  - Getting '...' globals ...
[16:17:44.941] resolve() on list ...
[16:17:44.941]  recursive: 0
[16:17:44.941]  length: 1
[16:17:44.941]  elements: ‘...’
[16:17:44.941]  length: 0 (resolved future 1)
[16:17:44.941] resolve() on list ... DONE
[16:17:44.941]    - '...' content: [n=0] 
[16:17:44.941] List of 1
[16:17:44.941]  $ ...: list()
[16:17:44.941]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.941]  - attr(*, "where")=List of 1
[16:17:44.941]   ..$ ...:<environment: 0x555be0156f20> 
[16:17:44.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.941]  - attr(*, "resolved")= logi TRUE
[16:17:44.941]  - attr(*, "total_size")= num NA
[16:17:44.944]  - Getting '...' globals ... DONE
[16:17:44.944] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:44.944] List of 2
[16:17:44.944]  $ ...future.FUN:function (x)  
[16:17:44.944]  $ ...          : list()
[16:17:44.944]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.944]  - attr(*, "where")=List of 2
[16:17:44.944]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:44.944]   ..$ ...          :<environment: 0x555be0156f20> 
[16:17:44.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.944]  - attr(*, "resolved")= logi FALSE
[16:17:44.944]  - attr(*, "total_size")= num 1768
[16:17:44.947] Packages to be attached in all futures: [n=0] 
[16:17:44.947] getGlobalsAndPackagesXApply() ... DONE
[16:17:44.950] future_lapply() ...
[16:17:44.954] Number of chunks: 2
[16:17:44.954] getGlobalsAndPackagesXApply() ...
[16:17:44.954]  - future.globals: <name-value list> with names ‘list()’
[16:17:44.955]  - use_args: TRUE
[16:17:44.955] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:44.955] List of 2
[16:17:44.955]  $ ...          : list()
[16:17:44.955]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:44.955]  $ ...future.FUN:function (x)  
[16:17:44.955]  - attr(*, "where")=List of 2
[16:17:44.955]   ..$ ...          :<environment: 0x555be0156f20> 
[16:17:44.955]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:17:44.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:44.955]  - attr(*, "resolved")= logi FALSE
[16:17:44.955]  - attr(*, "total_size")= num NA
[16:17:44.957] Packages to be attached in all futures: [n=0] 
[16:17:44.958] getGlobalsAndPackagesXApply() ... DONE
[16:17:44.958] Number of futures (= number of chunks): 2
[16:17:44.958] Launching 2 futures (chunks) ...
[16:17:44.958] Chunk #1 of 2 ...
[16:17:44.958]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.958]  - seeds: <none>
[16:17:44.958]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.958] getGlobalsAndPackages() ...
[16:17:44.959] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.959] Resolving globals: FALSE
[16:17:44.959] Tweak future expression to call with '...' arguments ...
[16:17:44.959] {
[16:17:44.959]     do.call(function(...) {
[16:17:44.959]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.959]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.959]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.959]             on.exit(options(oopts), add = TRUE)
[16:17:44.959]         }
[16:17:44.959]         {
[16:17:44.959]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.959]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.959]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.959]             })
[16:17:44.959]         }
[16:17:44.959]     }, args = future.call.arguments)
[16:17:44.959] }
[16:17:44.959] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.959] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.960] 
[16:17:44.960] getGlobalsAndPackages() ... DONE
[16:17:44.960] run() for ‘Future’ ...
[16:17:44.960] - state: ‘created’
[16:17:44.960] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:44.974] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:44.974]   - Field: ‘node’
[16:17:44.974]   - Field: ‘label’
[16:17:44.974]   - Field: ‘local’
[16:17:44.974]   - Field: ‘owner’
[16:17:44.974]   - Field: ‘envir’
[16:17:44.974]   - Field: ‘workers’
[16:17:44.975]   - Field: ‘packages’
[16:17:44.975]   - Field: ‘gc’
[16:17:44.975]   - Field: ‘conditions’
[16:17:44.975]   - Field: ‘persistent’
[16:17:44.975]   - Field: ‘expr’
[16:17:44.975]   - Field: ‘uuid’
[16:17:44.975]   - Field: ‘seed’
[16:17:44.975]   - Field: ‘version’
[16:17:44.975]   - Field: ‘result’
[16:17:44.975]   - Field: ‘asynchronous’
[16:17:44.975]   - Field: ‘calls’
[16:17:44.976]   - Field: ‘globals’
[16:17:44.976]   - Field: ‘stdout’
[16:17:44.976]   - Field: ‘earlySignal’
[16:17:44.976]   - Field: ‘lazy’
[16:17:44.976]   - Field: ‘state’
[16:17:44.976] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:44.976] - Launch lazy future ...
[16:17:44.976] Packages needed by the future expression (n = 0): <none>
[16:17:44.977] Packages needed by future strategies (n = 0): <none>
[16:17:44.977] {
[16:17:44.977]     {
[16:17:44.977]         {
[16:17:44.977]             ...future.startTime <- base::Sys.time()
[16:17:44.977]             {
[16:17:44.977]                 {
[16:17:44.977]                   {
[16:17:44.977]                     {
[16:17:44.977]                       base::local({
[16:17:44.977]                         has_future <- base::requireNamespace("future", 
[16:17:44.977]                           quietly = TRUE)
[16:17:44.977]                         if (has_future) {
[16:17:44.977]                           ns <- base::getNamespace("future")
[16:17:44.977]                           version <- ns[[".package"]][["version"]]
[16:17:44.977]                           if (is.null(version)) 
[16:17:44.977]                             version <- utils::packageVersion("future")
[16:17:44.977]                         }
[16:17:44.977]                         else {
[16:17:44.977]                           version <- NULL
[16:17:44.977]                         }
[16:17:44.977]                         if (!has_future || version < "1.8.0") {
[16:17:44.977]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:44.977]                             "", base::R.version$version.string), 
[16:17:44.977]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:44.977]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:44.977]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:44.977]                               "release", "version")], collapse = " "), 
[16:17:44.977]                             hostname = base::Sys.info()[["nodename"]])
[16:17:44.977]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:44.977]                             info)
[16:17:44.977]                           info <- base::paste(info, collapse = "; ")
[16:17:44.977]                           if (!has_future) {
[16:17:44.977]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:44.977]                               info)
[16:17:44.977]                           }
[16:17:44.977]                           else {
[16:17:44.977]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:44.977]                               info, version)
[16:17:44.977]                           }
[16:17:44.977]                           base::stop(msg)
[16:17:44.977]                         }
[16:17:44.977]                       })
[16:17:44.977]                     }
[16:17:44.977]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:44.977]                     base::options(mc.cores = 1L)
[16:17:44.977]                   }
[16:17:44.977]                   ...future.strategy.old <- future::plan("list")
[16:17:44.977]                   options(future.plan = NULL)
[16:17:44.977]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.977]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:44.977]                 }
[16:17:44.977]                 ...future.workdir <- getwd()
[16:17:44.977]             }
[16:17:44.977]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:44.977]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:44.977]         }
[16:17:44.977]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:44.977]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:44.977]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:44.977]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:44.977]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:44.977]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:44.977]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:44.977]             base::names(...future.oldOptions))
[16:17:44.977]     }
[16:17:44.977]     if (FALSE) {
[16:17:44.977]     }
[16:17:44.977]     else {
[16:17:44.977]         if (TRUE) {
[16:17:44.977]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:44.977]                 open = "w")
[16:17:44.977]         }
[16:17:44.977]         else {
[16:17:44.977]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:44.977]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:44.977]         }
[16:17:44.977]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:44.977]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:44.977]             base::sink(type = "output", split = FALSE)
[16:17:44.977]             base::close(...future.stdout)
[16:17:44.977]         }, add = TRUE)
[16:17:44.977]     }
[16:17:44.977]     ...future.frame <- base::sys.nframe()
[16:17:44.977]     ...future.conditions <- base::list()
[16:17:44.977]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:44.977]     if (FALSE) {
[16:17:44.977]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:44.977]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:44.977]     }
[16:17:44.977]     ...future.result <- base::tryCatch({
[16:17:44.977]         base::withCallingHandlers({
[16:17:44.977]             ...future.value <- base::withVisible(base::local({
[16:17:44.977]                 ...future.makeSendCondition <- base::local({
[16:17:44.977]                   sendCondition <- NULL
[16:17:44.977]                   function(frame = 1L) {
[16:17:44.977]                     if (is.function(sendCondition)) 
[16:17:44.977]                       return(sendCondition)
[16:17:44.977]                     ns <- getNamespace("parallel")
[16:17:44.977]                     if (exists("sendData", mode = "function", 
[16:17:44.977]                       envir = ns)) {
[16:17:44.977]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:44.977]                         envir = ns)
[16:17:44.977]                       envir <- sys.frame(frame)
[16:17:44.977]                       master <- NULL
[16:17:44.977]                       while (!identical(envir, .GlobalEnv) && 
[16:17:44.977]                         !identical(envir, emptyenv())) {
[16:17:44.977]                         if (exists("master", mode = "list", envir = envir, 
[16:17:44.977]                           inherits = FALSE)) {
[16:17:44.977]                           master <- get("master", mode = "list", 
[16:17:44.977]                             envir = envir, inherits = FALSE)
[16:17:44.977]                           if (inherits(master, c("SOCKnode", 
[16:17:44.977]                             "SOCK0node"))) {
[16:17:44.977]                             sendCondition <<- function(cond) {
[16:17:44.977]                               data <- list(type = "VALUE", value = cond, 
[16:17:44.977]                                 success = TRUE)
[16:17:44.977]                               parallel_sendData(master, data)
[16:17:44.977]                             }
[16:17:44.977]                             return(sendCondition)
[16:17:44.977]                           }
[16:17:44.977]                         }
[16:17:44.977]                         frame <- frame + 1L
[16:17:44.977]                         envir <- sys.frame(frame)
[16:17:44.977]                       }
[16:17:44.977]                     }
[16:17:44.977]                     sendCondition <<- function(cond) NULL
[16:17:44.977]                   }
[16:17:44.977]                 })
[16:17:44.977]                 withCallingHandlers({
[16:17:44.977]                   {
[16:17:44.977]                     do.call(function(...) {
[16:17:44.977]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.977]                       if (!identical(...future.globals.maxSize.org, 
[16:17:44.977]                         ...future.globals.maxSize)) {
[16:17:44.977]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.977]                         on.exit(options(oopts), add = TRUE)
[16:17:44.977]                       }
[16:17:44.977]                       {
[16:17:44.977]                         lapply(seq_along(...future.elements_ii), 
[16:17:44.977]                           FUN = function(jj) {
[16:17:44.977]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.977]                             ...future.FUN(...future.X_jj, ...)
[16:17:44.977]                           })
[16:17:44.977]                       }
[16:17:44.977]                     }, args = future.call.arguments)
[16:17:44.977]                   }
[16:17:44.977]                 }, immediateCondition = function(cond) {
[16:17:44.977]                   sendCondition <- ...future.makeSendCondition()
[16:17:44.977]                   sendCondition(cond)
[16:17:44.977]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.977]                   {
[16:17:44.977]                     inherits <- base::inherits
[16:17:44.977]                     invokeRestart <- base::invokeRestart
[16:17:44.977]                     is.null <- base::is.null
[16:17:44.977]                     muffled <- FALSE
[16:17:44.977]                     if (inherits(cond, "message")) {
[16:17:44.977]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:44.977]                       if (muffled) 
[16:17:44.977]                         invokeRestart("muffleMessage")
[16:17:44.977]                     }
[16:17:44.977]                     else if (inherits(cond, "warning")) {
[16:17:44.977]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:44.977]                       if (muffled) 
[16:17:44.977]                         invokeRestart("muffleWarning")
[16:17:44.977]                     }
[16:17:44.977]                     else if (inherits(cond, "condition")) {
[16:17:44.977]                       if (!is.null(pattern)) {
[16:17:44.977]                         computeRestarts <- base::computeRestarts
[16:17:44.977]                         grepl <- base::grepl
[16:17:44.977]                         restarts <- computeRestarts(cond)
[16:17:44.977]                         for (restart in restarts) {
[16:17:44.977]                           name <- restart$name
[16:17:44.977]                           if (is.null(name)) 
[16:17:44.977]                             next
[16:17:44.977]                           if (!grepl(pattern, name)) 
[16:17:44.977]                             next
[16:17:44.977]                           invokeRestart(restart)
[16:17:44.977]                           muffled <- TRUE
[16:17:44.977]                           break
[16:17:44.977]                         }
[16:17:44.977]                       }
[16:17:44.977]                     }
[16:17:44.977]                     invisible(muffled)
[16:17:44.977]                   }
[16:17:44.977]                   muffleCondition(cond)
[16:17:44.977]                 })
[16:17:44.977]             }))
[16:17:44.977]             future::FutureResult(value = ...future.value$value, 
[16:17:44.977]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.977]                   ...future.rng), globalenv = if (FALSE) 
[16:17:44.977]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:44.977]                     ...future.globalenv.names))
[16:17:44.977]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:44.977]         }, condition = base::local({
[16:17:44.977]             c <- base::c
[16:17:44.977]             inherits <- base::inherits
[16:17:44.977]             invokeRestart <- base::invokeRestart
[16:17:44.977]             length <- base::length
[16:17:44.977]             list <- base::list
[16:17:44.977]             seq.int <- base::seq.int
[16:17:44.977]             signalCondition <- base::signalCondition
[16:17:44.977]             sys.calls <- base::sys.calls
[16:17:44.977]             `[[` <- base::`[[`
[16:17:44.977]             `+` <- base::`+`
[16:17:44.977]             `<<-` <- base::`<<-`
[16:17:44.977]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:44.977]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:44.977]                   3L)]
[16:17:44.977]             }
[16:17:44.977]             function(cond) {
[16:17:44.977]                 is_error <- inherits(cond, "error")
[16:17:44.977]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:44.977]                   NULL)
[16:17:44.977]                 if (is_error) {
[16:17:44.977]                   sessionInformation <- function() {
[16:17:44.977]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:44.977]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:44.977]                       search = base::search(), system = base::Sys.info())
[16:17:44.977]                   }
[16:17:44.977]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.977]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:44.977]                     cond$call), session = sessionInformation(), 
[16:17:44.977]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:44.977]                   signalCondition(cond)
[16:17:44.977]                 }
[16:17:44.977]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:44.977]                 "immediateCondition"))) {
[16:17:44.977]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:44.977]                   ...future.conditions[[length(...future.conditions) + 
[16:17:44.977]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:44.977]                   if (TRUE && !signal) {
[16:17:44.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.977]                     {
[16:17:44.977]                       inherits <- base::inherits
[16:17:44.977]                       invokeRestart <- base::invokeRestart
[16:17:44.977]                       is.null <- base::is.null
[16:17:44.977]                       muffled <- FALSE
[16:17:44.977]                       if (inherits(cond, "message")) {
[16:17:44.977]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.977]                         if (muffled) 
[16:17:44.977]                           invokeRestart("muffleMessage")
[16:17:44.977]                       }
[16:17:44.977]                       else if (inherits(cond, "warning")) {
[16:17:44.977]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.977]                         if (muffled) 
[16:17:44.977]                           invokeRestart("muffleWarning")
[16:17:44.977]                       }
[16:17:44.977]                       else if (inherits(cond, "condition")) {
[16:17:44.977]                         if (!is.null(pattern)) {
[16:17:44.977]                           computeRestarts <- base::computeRestarts
[16:17:44.977]                           grepl <- base::grepl
[16:17:44.977]                           restarts <- computeRestarts(cond)
[16:17:44.977]                           for (restart in restarts) {
[16:17:44.977]                             name <- restart$name
[16:17:44.977]                             if (is.null(name)) 
[16:17:44.977]                               next
[16:17:44.977]                             if (!grepl(pattern, name)) 
[16:17:44.977]                               next
[16:17:44.977]                             invokeRestart(restart)
[16:17:44.977]                             muffled <- TRUE
[16:17:44.977]                             break
[16:17:44.977]                           }
[16:17:44.977]                         }
[16:17:44.977]                       }
[16:17:44.977]                       invisible(muffled)
[16:17:44.977]                     }
[16:17:44.977]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.977]                   }
[16:17:44.977]                 }
[16:17:44.977]                 else {
[16:17:44.977]                   if (TRUE) {
[16:17:44.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:44.977]                     {
[16:17:44.977]                       inherits <- base::inherits
[16:17:44.977]                       invokeRestart <- base::invokeRestart
[16:17:44.977]                       is.null <- base::is.null
[16:17:44.977]                       muffled <- FALSE
[16:17:44.977]                       if (inherits(cond, "message")) {
[16:17:44.977]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:44.977]                         if (muffled) 
[16:17:44.977]                           invokeRestart("muffleMessage")
[16:17:44.977]                       }
[16:17:44.977]                       else if (inherits(cond, "warning")) {
[16:17:44.977]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:44.977]                         if (muffled) 
[16:17:44.977]                           invokeRestart("muffleWarning")
[16:17:44.977]                       }
[16:17:44.977]                       else if (inherits(cond, "condition")) {
[16:17:44.977]                         if (!is.null(pattern)) {
[16:17:44.977]                           computeRestarts <- base::computeRestarts
[16:17:44.977]                           grepl <- base::grepl
[16:17:44.977]                           restarts <- computeRestarts(cond)
[16:17:44.977]                           for (restart in restarts) {
[16:17:44.977]                             name <- restart$name
[16:17:44.977]                             if (is.null(name)) 
[16:17:44.977]                               next
[16:17:44.977]                             if (!grepl(pattern, name)) 
[16:17:44.977]                               next
[16:17:44.977]                             invokeRestart(restart)
[16:17:44.977]                             muffled <- TRUE
[16:17:44.977]                             break
[16:17:44.977]                           }
[16:17:44.977]                         }
[16:17:44.977]                       }
[16:17:44.977]                       invisible(muffled)
[16:17:44.977]                     }
[16:17:44.977]                     muffleCondition(cond, pattern = "^muffle")
[16:17:44.977]                   }
[16:17:44.977]                 }
[16:17:44.977]             }
[16:17:44.977]         }))
[16:17:44.977]     }, error = function(ex) {
[16:17:44.977]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:44.977]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:44.977]                 ...future.rng), started = ...future.startTime, 
[16:17:44.977]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:44.977]             version = "1.8"), class = "FutureResult")
[16:17:44.977]     }, finally = {
[16:17:44.977]         if (!identical(...future.workdir, getwd())) 
[16:17:44.977]             setwd(...future.workdir)
[16:17:44.977]         {
[16:17:44.977]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:44.977]                 ...future.oldOptions$nwarnings <- NULL
[16:17:44.977]             }
[16:17:44.977]             base::options(...future.oldOptions)
[16:17:44.977]             if (.Platform$OS.type == "windows") {
[16:17:44.977]                 old_names <- names(...future.oldEnvVars)
[16:17:44.977]                 envs <- base::Sys.getenv()
[16:17:44.977]                 names <- names(envs)
[16:17:44.977]                 common <- intersect(names, old_names)
[16:17:44.977]                 added <- setdiff(names, old_names)
[16:17:44.977]                 removed <- setdiff(old_names, names)
[16:17:44.977]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:44.977]                   envs[common]]
[16:17:44.977]                 NAMES <- toupper(changed)
[16:17:44.977]                 args <- list()
[16:17:44.977]                 for (kk in seq_along(NAMES)) {
[16:17:44.977]                   name <- changed[[kk]]
[16:17:44.977]                   NAME <- NAMES[[kk]]
[16:17:44.977]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.977]                     next
[16:17:44.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.977]                 }
[16:17:44.977]                 NAMES <- toupper(added)
[16:17:44.977]                 for (kk in seq_along(NAMES)) {
[16:17:44.977]                   name <- added[[kk]]
[16:17:44.977]                   NAME <- NAMES[[kk]]
[16:17:44.977]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.977]                     next
[16:17:44.977]                   args[[name]] <- ""
[16:17:44.977]                 }
[16:17:44.977]                 NAMES <- toupper(removed)
[16:17:44.977]                 for (kk in seq_along(NAMES)) {
[16:17:44.977]                   name <- removed[[kk]]
[16:17:44.977]                   NAME <- NAMES[[kk]]
[16:17:44.977]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:44.977]                     next
[16:17:44.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:44.977]                 }
[16:17:44.977]                 if (length(args) > 0) 
[16:17:44.977]                   base::do.call(base::Sys.setenv, args = args)
[16:17:44.977]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:44.977]             }
[16:17:44.977]             else {
[16:17:44.977]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:44.977]             }
[16:17:44.977]             {
[16:17:44.977]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:44.977]                   0L) {
[16:17:44.977]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:44.977]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:44.977]                   base::options(opts)
[16:17:44.977]                 }
[16:17:44.977]                 {
[16:17:44.977]                   {
[16:17:44.977]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:44.977]                     NULL
[16:17:44.977]                   }
[16:17:44.977]                   options(future.plan = NULL)
[16:17:44.977]                   if (is.na(NA_character_)) 
[16:17:44.977]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:44.977]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:44.977]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:44.977]                     .init = FALSE)
[16:17:44.977]                 }
[16:17:44.977]             }
[16:17:44.977]         }
[16:17:44.977]     })
[16:17:44.977]     if (TRUE) {
[16:17:44.977]         base::sink(type = "output", split = FALSE)
[16:17:44.977]         if (TRUE) {
[16:17:44.977]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:44.977]         }
[16:17:44.977]         else {
[16:17:44.977]             ...future.result["stdout"] <- base::list(NULL)
[16:17:44.977]         }
[16:17:44.977]         base::close(...future.stdout)
[16:17:44.977]         ...future.stdout <- NULL
[16:17:44.977]     }
[16:17:44.977]     ...future.result$conditions <- ...future.conditions
[16:17:44.977]     ...future.result$finished <- base::Sys.time()
[16:17:44.977]     ...future.result
[16:17:44.977] }
[16:17:44.980] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[16:17:44.980] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:44.981] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.981] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[16:17:44.981] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[16:17:44.981] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[16:17:44.982] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[16:17:44.982] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:44.982] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:44.982] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:17:44.983] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:17:44.983] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[16:17:44.983] MultisessionFuture started
[16:17:44.983] - Launch lazy future ... done
[16:17:44.984] run() for ‘MultisessionFuture’ ... done
[16:17:44.984] Created future:
[16:17:44.984] MultisessionFuture:
[16:17:44.984] Label: ‘future_apply-1’
[16:17:44.984] Expression:
[16:17:44.984] {
[16:17:44.984]     do.call(function(...) {
[16:17:44.984]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.984]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.984]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.984]             on.exit(options(oopts), add = TRUE)
[16:17:44.984]         }
[16:17:44.984]         {
[16:17:44.984]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.984]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.984]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.984]             })
[16:17:44.984]         }
[16:17:44.984]     }, args = future.call.arguments)
[16:17:44.984] }
[16:17:44.984] Lazy evaluation: FALSE
[16:17:44.984] Asynchronous evaluation: TRUE
[16:17:44.984] Local evaluation: TRUE
[16:17:44.984] Environment: R_GlobalEnv
[16:17:44.984] Capture standard output: TRUE
[16:17:44.984] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:44.984] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:44.984] Packages: <none>
[16:17:44.984] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:44.984] Resolved: FALSE
[16:17:44.984] Value: <not collected>
[16:17:44.984] Conditions captured: <none>
[16:17:44.984] Early signaling: FALSE
[16:17:44.984] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:44.984] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:44.996] Chunk #1 of 2 ... DONE
[16:17:44.996] Chunk #2 of 2 ...
[16:17:44.996]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:44.996]  - seeds: <none>
[16:17:44.996]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.996] getGlobalsAndPackages() ...
[16:17:44.997] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.997] Resolving globals: FALSE
[16:17:44.997] Tweak future expression to call with '...' arguments ...
[16:17:44.997] {
[16:17:44.997]     do.call(function(...) {
[16:17:44.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:44.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:44.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:44.997]             on.exit(options(oopts), add = TRUE)
[16:17:44.997]         }
[16:17:44.997]         {
[16:17:44.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:44.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:44.997]                 ...future.FUN(...future.X_jj, ...)
[16:17:44.997]             })
[16:17:44.997]         }
[16:17:44.997]     }, args = future.call.arguments)
[16:17:44.997] }
[16:17:44.997] Tweak future expression to call with '...' arguments ... DONE
[16:17:44.998] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:44.998] 
[16:17:44.998] getGlobalsAndPackages() ... DONE
[16:17:44.998] run() for ‘Future’ ...
[16:17:44.998] - state: ‘created’
[16:17:44.998] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:45.012] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.012] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:45.012]   - Field: ‘node’
[16:17:45.012]   - Field: ‘label’
[16:17:45.012]   - Field: ‘local’
[16:17:45.012]   - Field: ‘owner’
[16:17:45.013]   - Field: ‘envir’
[16:17:45.013]   - Field: ‘workers’
[16:17:45.013]   - Field: ‘packages’
[16:17:45.013]   - Field: ‘gc’
[16:17:45.013]   - Field: ‘conditions’
[16:17:45.013]   - Field: ‘persistent’
[16:17:45.013]   - Field: ‘expr’
[16:17:45.013]   - Field: ‘uuid’
[16:17:45.013]   - Field: ‘seed’
[16:17:45.013]   - Field: ‘version’
[16:17:45.013]   - Field: ‘result’
[16:17:45.014]   - Field: ‘asynchronous’
[16:17:45.014]   - Field: ‘calls’
[16:17:45.014]   - Field: ‘globals’
[16:17:45.014]   - Field: ‘stdout’
[16:17:45.014]   - Field: ‘earlySignal’
[16:17:45.014]   - Field: ‘lazy’
[16:17:45.014]   - Field: ‘state’
[16:17:45.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:45.014] - Launch lazy future ...
[16:17:45.015] Packages needed by the future expression (n = 0): <none>
[16:17:45.015] Packages needed by future strategies (n = 0): <none>
[16:17:45.015] {
[16:17:45.015]     {
[16:17:45.015]         {
[16:17:45.015]             ...future.startTime <- base::Sys.time()
[16:17:45.015]             {
[16:17:45.015]                 {
[16:17:45.015]                   {
[16:17:45.015]                     {
[16:17:45.015]                       base::local({
[16:17:45.015]                         has_future <- base::requireNamespace("future", 
[16:17:45.015]                           quietly = TRUE)
[16:17:45.015]                         if (has_future) {
[16:17:45.015]                           ns <- base::getNamespace("future")
[16:17:45.015]                           version <- ns[[".package"]][["version"]]
[16:17:45.015]                           if (is.null(version)) 
[16:17:45.015]                             version <- utils::packageVersion("future")
[16:17:45.015]                         }
[16:17:45.015]                         else {
[16:17:45.015]                           version <- NULL
[16:17:45.015]                         }
[16:17:45.015]                         if (!has_future || version < "1.8.0") {
[16:17:45.015]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:45.015]                             "", base::R.version$version.string), 
[16:17:45.015]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:45.015]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:45.015]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:45.015]                               "release", "version")], collapse = " "), 
[16:17:45.015]                             hostname = base::Sys.info()[["nodename"]])
[16:17:45.015]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:45.015]                             info)
[16:17:45.015]                           info <- base::paste(info, collapse = "; ")
[16:17:45.015]                           if (!has_future) {
[16:17:45.015]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:45.015]                               info)
[16:17:45.015]                           }
[16:17:45.015]                           else {
[16:17:45.015]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:45.015]                               info, version)
[16:17:45.015]                           }
[16:17:45.015]                           base::stop(msg)
[16:17:45.015]                         }
[16:17:45.015]                       })
[16:17:45.015]                     }
[16:17:45.015]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:45.015]                     base::options(mc.cores = 1L)
[16:17:45.015]                   }
[16:17:45.015]                   ...future.strategy.old <- future::plan("list")
[16:17:45.015]                   options(future.plan = NULL)
[16:17:45.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:45.015]                 }
[16:17:45.015]                 ...future.workdir <- getwd()
[16:17:45.015]             }
[16:17:45.015]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:45.015]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:45.015]         }
[16:17:45.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:45.015]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:45.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:45.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:45.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:45.015]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:45.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:45.015]             base::names(...future.oldOptions))
[16:17:45.015]     }
[16:17:45.015]     if (FALSE) {
[16:17:45.015]     }
[16:17:45.015]     else {
[16:17:45.015]         if (TRUE) {
[16:17:45.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:45.015]                 open = "w")
[16:17:45.015]         }
[16:17:45.015]         else {
[16:17:45.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:45.015]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:45.015]         }
[16:17:45.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:45.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:45.015]             base::sink(type = "output", split = FALSE)
[16:17:45.015]             base::close(...future.stdout)
[16:17:45.015]         }, add = TRUE)
[16:17:45.015]     }
[16:17:45.015]     ...future.frame <- base::sys.nframe()
[16:17:45.015]     ...future.conditions <- base::list()
[16:17:45.015]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:45.015]     if (FALSE) {
[16:17:45.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:45.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:45.015]     }
[16:17:45.015]     ...future.result <- base::tryCatch({
[16:17:45.015]         base::withCallingHandlers({
[16:17:45.015]             ...future.value <- base::withVisible(base::local({
[16:17:45.015]                 ...future.makeSendCondition <- base::local({
[16:17:45.015]                   sendCondition <- NULL
[16:17:45.015]                   function(frame = 1L) {
[16:17:45.015]                     if (is.function(sendCondition)) 
[16:17:45.015]                       return(sendCondition)
[16:17:45.015]                     ns <- getNamespace("parallel")
[16:17:45.015]                     if (exists("sendData", mode = "function", 
[16:17:45.015]                       envir = ns)) {
[16:17:45.015]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:45.015]                         envir = ns)
[16:17:45.015]                       envir <- sys.frame(frame)
[16:17:45.015]                       master <- NULL
[16:17:45.015]                       while (!identical(envir, .GlobalEnv) && 
[16:17:45.015]                         !identical(envir, emptyenv())) {
[16:17:45.015]                         if (exists("master", mode = "list", envir = envir, 
[16:17:45.015]                           inherits = FALSE)) {
[16:17:45.015]                           master <- get("master", mode = "list", 
[16:17:45.015]                             envir = envir, inherits = FALSE)
[16:17:45.015]                           if (inherits(master, c("SOCKnode", 
[16:17:45.015]                             "SOCK0node"))) {
[16:17:45.015]                             sendCondition <<- function(cond) {
[16:17:45.015]                               data <- list(type = "VALUE", value = cond, 
[16:17:45.015]                                 success = TRUE)
[16:17:45.015]                               parallel_sendData(master, data)
[16:17:45.015]                             }
[16:17:45.015]                             return(sendCondition)
[16:17:45.015]                           }
[16:17:45.015]                         }
[16:17:45.015]                         frame <- frame + 1L
[16:17:45.015]                         envir <- sys.frame(frame)
[16:17:45.015]                       }
[16:17:45.015]                     }
[16:17:45.015]                     sendCondition <<- function(cond) NULL
[16:17:45.015]                   }
[16:17:45.015]                 })
[16:17:45.015]                 withCallingHandlers({
[16:17:45.015]                   {
[16:17:45.015]                     do.call(function(...) {
[16:17:45.015]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.015]                       if (!identical(...future.globals.maxSize.org, 
[16:17:45.015]                         ...future.globals.maxSize)) {
[16:17:45.015]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.015]                         on.exit(options(oopts), add = TRUE)
[16:17:45.015]                       }
[16:17:45.015]                       {
[16:17:45.015]                         lapply(seq_along(...future.elements_ii), 
[16:17:45.015]                           FUN = function(jj) {
[16:17:45.015]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.015]                             ...future.FUN(...future.X_jj, ...)
[16:17:45.015]                           })
[16:17:45.015]                       }
[16:17:45.015]                     }, args = future.call.arguments)
[16:17:45.015]                   }
[16:17:45.015]                 }, immediateCondition = function(cond) {
[16:17:45.015]                   sendCondition <- ...future.makeSendCondition()
[16:17:45.015]                   sendCondition(cond)
[16:17:45.015]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.015]                   {
[16:17:45.015]                     inherits <- base::inherits
[16:17:45.015]                     invokeRestart <- base::invokeRestart
[16:17:45.015]                     is.null <- base::is.null
[16:17:45.015]                     muffled <- FALSE
[16:17:45.015]                     if (inherits(cond, "message")) {
[16:17:45.015]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:45.015]                       if (muffled) 
[16:17:45.015]                         invokeRestart("muffleMessage")
[16:17:45.015]                     }
[16:17:45.015]                     else if (inherits(cond, "warning")) {
[16:17:45.015]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:45.015]                       if (muffled) 
[16:17:45.015]                         invokeRestart("muffleWarning")
[16:17:45.015]                     }
[16:17:45.015]                     else if (inherits(cond, "condition")) {
[16:17:45.015]                       if (!is.null(pattern)) {
[16:17:45.015]                         computeRestarts <- base::computeRestarts
[16:17:45.015]                         grepl <- base::grepl
[16:17:45.015]                         restarts <- computeRestarts(cond)
[16:17:45.015]                         for (restart in restarts) {
[16:17:45.015]                           name <- restart$name
[16:17:45.015]                           if (is.null(name)) 
[16:17:45.015]                             next
[16:17:45.015]                           if (!grepl(pattern, name)) 
[16:17:45.015]                             next
[16:17:45.015]                           invokeRestart(restart)
[16:17:45.015]                           muffled <- TRUE
[16:17:45.015]                           break
[16:17:45.015]                         }
[16:17:45.015]                       }
[16:17:45.015]                     }
[16:17:45.015]                     invisible(muffled)
[16:17:45.015]                   }
[16:17:45.015]                   muffleCondition(cond)
[16:17:45.015]                 })
[16:17:45.015]             }))
[16:17:45.015]             future::FutureResult(value = ...future.value$value, 
[16:17:45.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.015]                   ...future.rng), globalenv = if (FALSE) 
[16:17:45.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:45.015]                     ...future.globalenv.names))
[16:17:45.015]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:45.015]         }, condition = base::local({
[16:17:45.015]             c <- base::c
[16:17:45.015]             inherits <- base::inherits
[16:17:45.015]             invokeRestart <- base::invokeRestart
[16:17:45.015]             length <- base::length
[16:17:45.015]             list <- base::list
[16:17:45.015]             seq.int <- base::seq.int
[16:17:45.015]             signalCondition <- base::signalCondition
[16:17:45.015]             sys.calls <- base::sys.calls
[16:17:45.015]             `[[` <- base::`[[`
[16:17:45.015]             `+` <- base::`+`
[16:17:45.015]             `<<-` <- base::`<<-`
[16:17:45.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:45.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:45.015]                   3L)]
[16:17:45.015]             }
[16:17:45.015]             function(cond) {
[16:17:45.015]                 is_error <- inherits(cond, "error")
[16:17:45.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:45.015]                   NULL)
[16:17:45.015]                 if (is_error) {
[16:17:45.015]                   sessionInformation <- function() {
[16:17:45.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:45.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:45.015]                       search = base::search(), system = base::Sys.info())
[16:17:45.015]                   }
[16:17:45.015]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:45.015]                     cond$call), session = sessionInformation(), 
[16:17:45.015]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:45.015]                   signalCondition(cond)
[16:17:45.015]                 }
[16:17:45.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:45.015]                 "immediateCondition"))) {
[16:17:45.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:45.015]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:45.015]                   if (TRUE && !signal) {
[16:17:45.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.015]                     {
[16:17:45.015]                       inherits <- base::inherits
[16:17:45.015]                       invokeRestart <- base::invokeRestart
[16:17:45.015]                       is.null <- base::is.null
[16:17:45.015]                       muffled <- FALSE
[16:17:45.015]                       if (inherits(cond, "message")) {
[16:17:45.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.015]                         if (muffled) 
[16:17:45.015]                           invokeRestart("muffleMessage")
[16:17:45.015]                       }
[16:17:45.015]                       else if (inherits(cond, "warning")) {
[16:17:45.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.015]                         if (muffled) 
[16:17:45.015]                           invokeRestart("muffleWarning")
[16:17:45.015]                       }
[16:17:45.015]                       else if (inherits(cond, "condition")) {
[16:17:45.015]                         if (!is.null(pattern)) {
[16:17:45.015]                           computeRestarts <- base::computeRestarts
[16:17:45.015]                           grepl <- base::grepl
[16:17:45.015]                           restarts <- computeRestarts(cond)
[16:17:45.015]                           for (restart in restarts) {
[16:17:45.015]                             name <- restart$name
[16:17:45.015]                             if (is.null(name)) 
[16:17:45.015]                               next
[16:17:45.015]                             if (!grepl(pattern, name)) 
[16:17:45.015]                               next
[16:17:45.015]                             invokeRestart(restart)
[16:17:45.015]                             muffled <- TRUE
[16:17:45.015]                             break
[16:17:45.015]                           }
[16:17:45.015]                         }
[16:17:45.015]                       }
[16:17:45.015]                       invisible(muffled)
[16:17:45.015]                     }
[16:17:45.015]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.015]                   }
[16:17:45.015]                 }
[16:17:45.015]                 else {
[16:17:45.015]                   if (TRUE) {
[16:17:45.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.015]                     {
[16:17:45.015]                       inherits <- base::inherits
[16:17:45.015]                       invokeRestart <- base::invokeRestart
[16:17:45.015]                       is.null <- base::is.null
[16:17:45.015]                       muffled <- FALSE
[16:17:45.015]                       if (inherits(cond, "message")) {
[16:17:45.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.015]                         if (muffled) 
[16:17:45.015]                           invokeRestart("muffleMessage")
[16:17:45.015]                       }
[16:17:45.015]                       else if (inherits(cond, "warning")) {
[16:17:45.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.015]                         if (muffled) 
[16:17:45.015]                           invokeRestart("muffleWarning")
[16:17:45.015]                       }
[16:17:45.015]                       else if (inherits(cond, "condition")) {
[16:17:45.015]                         if (!is.null(pattern)) {
[16:17:45.015]                           computeRestarts <- base::computeRestarts
[16:17:45.015]                           grepl <- base::grepl
[16:17:45.015]                           restarts <- computeRestarts(cond)
[16:17:45.015]                           for (restart in restarts) {
[16:17:45.015]                             name <- restart$name
[16:17:45.015]                             if (is.null(name)) 
[16:17:45.015]                               next
[16:17:45.015]                             if (!grepl(pattern, name)) 
[16:17:45.015]                               next
[16:17:45.015]                             invokeRestart(restart)
[16:17:45.015]                             muffled <- TRUE
[16:17:45.015]                             break
[16:17:45.015]                           }
[16:17:45.015]                         }
[16:17:45.015]                       }
[16:17:45.015]                       invisible(muffled)
[16:17:45.015]                     }
[16:17:45.015]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.015]                   }
[16:17:45.015]                 }
[16:17:45.015]             }
[16:17:45.015]         }))
[16:17:45.015]     }, error = function(ex) {
[16:17:45.015]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:45.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.015]                 ...future.rng), started = ...future.startTime, 
[16:17:45.015]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:45.015]             version = "1.8"), class = "FutureResult")
[16:17:45.015]     }, finally = {
[16:17:45.015]         if (!identical(...future.workdir, getwd())) 
[16:17:45.015]             setwd(...future.workdir)
[16:17:45.015]         {
[16:17:45.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:45.015]                 ...future.oldOptions$nwarnings <- NULL
[16:17:45.015]             }
[16:17:45.015]             base::options(...future.oldOptions)
[16:17:45.015]             if (.Platform$OS.type == "windows") {
[16:17:45.015]                 old_names <- names(...future.oldEnvVars)
[16:17:45.015]                 envs <- base::Sys.getenv()
[16:17:45.015]                 names <- names(envs)
[16:17:45.015]                 common <- intersect(names, old_names)
[16:17:45.015]                 added <- setdiff(names, old_names)
[16:17:45.015]                 removed <- setdiff(old_names, names)
[16:17:45.015]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:45.015]                   envs[common]]
[16:17:45.015]                 NAMES <- toupper(changed)
[16:17:45.015]                 args <- list()
[16:17:45.015]                 for (kk in seq_along(NAMES)) {
[16:17:45.015]                   name <- changed[[kk]]
[16:17:45.015]                   NAME <- NAMES[[kk]]
[16:17:45.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.015]                     next
[16:17:45.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.015]                 }
[16:17:45.015]                 NAMES <- toupper(added)
[16:17:45.015]                 for (kk in seq_along(NAMES)) {
[16:17:45.015]                   name <- added[[kk]]
[16:17:45.015]                   NAME <- NAMES[[kk]]
[16:17:45.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.015]                     next
[16:17:45.015]                   args[[name]] <- ""
[16:17:45.015]                 }
[16:17:45.015]                 NAMES <- toupper(removed)
[16:17:45.015]                 for (kk in seq_along(NAMES)) {
[16:17:45.015]                   name <- removed[[kk]]
[16:17:45.015]                   NAME <- NAMES[[kk]]
[16:17:45.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.015]                     next
[16:17:45.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.015]                 }
[16:17:45.015]                 if (length(args) > 0) 
[16:17:45.015]                   base::do.call(base::Sys.setenv, args = args)
[16:17:45.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:45.015]             }
[16:17:45.015]             else {
[16:17:45.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:45.015]             }
[16:17:45.015]             {
[16:17:45.015]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:45.015]                   0L) {
[16:17:45.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:45.015]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:45.015]                   base::options(opts)
[16:17:45.015]                 }
[16:17:45.015]                 {
[16:17:45.015]                   {
[16:17:45.015]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:45.015]                     NULL
[16:17:45.015]                   }
[16:17:45.015]                   options(future.plan = NULL)
[16:17:45.015]                   if (is.na(NA_character_)) 
[16:17:45.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:45.015]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:45.015]                     .init = FALSE)
[16:17:45.015]                 }
[16:17:45.015]             }
[16:17:45.015]         }
[16:17:45.015]     })
[16:17:45.015]     if (TRUE) {
[16:17:45.015]         base::sink(type = "output", split = FALSE)
[16:17:45.015]         if (TRUE) {
[16:17:45.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:45.015]         }
[16:17:45.015]         else {
[16:17:45.015]             ...future.result["stdout"] <- base::list(NULL)
[16:17:45.015]         }
[16:17:45.015]         base::close(...future.stdout)
[16:17:45.015]         ...future.stdout <- NULL
[16:17:45.015]     }
[16:17:45.015]     ...future.result$conditions <- ...future.conditions
[16:17:45.015]     ...future.result$finished <- base::Sys.time()
[16:17:45.015]     ...future.result
[16:17:45.015] }
[16:17:45.018] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[16:17:45.018] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:45.019] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:45.019] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[16:17:45.019] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[16:17:45.019] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[16:17:45.020] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[16:17:45.020] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:45.020] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:45.020] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:17:45.021] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:17:45.021] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[16:17:45.021] MultisessionFuture started
[16:17:45.021] - Launch lazy future ... done
[16:17:45.022] run() for ‘MultisessionFuture’ ... done
[16:17:45.022] Created future:
[16:17:45.022] MultisessionFuture:
[16:17:45.022] Label: ‘future_apply-2’
[16:17:45.022] Expression:
[16:17:45.022] {
[16:17:45.022]     do.call(function(...) {
[16:17:45.022]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.022]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.022]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.022]             on.exit(options(oopts), add = TRUE)
[16:17:45.022]         }
[16:17:45.022]         {
[16:17:45.022]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.022]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.022]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.022]             })
[16:17:45.022]         }
[16:17:45.022]     }, args = future.call.arguments)
[16:17:45.022] }
[16:17:45.022] Lazy evaluation: FALSE
[16:17:45.022] Asynchronous evaluation: TRUE
[16:17:45.022] Local evaluation: TRUE
[16:17:45.022] Environment: R_GlobalEnv
[16:17:45.022] Capture standard output: TRUE
[16:17:45.022] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:45.022] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:45.022] Packages: <none>
[16:17:45.022] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:45.022] Resolved: FALSE
[16:17:45.022] Value: <not collected>
[16:17:45.022] Conditions captured: <none>
[16:17:45.022] Early signaling: FALSE
[16:17:45.022] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:45.022] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.033] Chunk #2 of 2 ... DONE
[16:17:45.033] Launching 2 futures (chunks) ... DONE
[16:17:45.034] Resolving 2 futures (chunks) ...
[16:17:45.034] resolve() on list ...
[16:17:45.034]  recursive: 0
[16:17:45.034]  length: 2
[16:17:45.034] 
[16:17:45.034] receiveMessageFromWorker() for ClusterFuture ...
[16:17:45.034] - Validating connection of MultisessionFuture
[16:17:45.035] - received message: FutureResult
[16:17:45.035] - Received FutureResult
[16:17:45.035] - Erased future from FutureRegistry
[16:17:45.035] result() for ClusterFuture ...
[16:17:45.035] - result already collected: FutureResult
[16:17:45.035] result() for ClusterFuture ... done
[16:17:45.035] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:45.035] Future #1
[16:17:45.035] result() for ClusterFuture ...
[16:17:45.036] - result already collected: FutureResult
[16:17:45.036] result() for ClusterFuture ... done
[16:17:45.036] result() for ClusterFuture ...
[16:17:45.036] - result already collected: FutureResult
[16:17:45.036] result() for ClusterFuture ... done
[16:17:45.036] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:45.036] - nx: 2
[16:17:45.036] - relay: TRUE
[16:17:45.036] - stdout: TRUE
[16:17:45.036] - signal: TRUE
[16:17:45.036] - resignal: FALSE
[16:17:45.037] - force: TRUE
[16:17:45.037] - relayed: [n=2] FALSE, FALSE
[16:17:45.037] - queued futures: [n=2] FALSE, FALSE
[16:17:45.037]  - until=1
[16:17:45.037]  - relaying element #1
[16:17:45.037] result() for ClusterFuture ...
[16:17:45.037] - result already collected: FutureResult
[16:17:45.037] result() for ClusterFuture ... done
[16:17:45.037] result() for ClusterFuture ...
[16:17:45.037] - result already collected: FutureResult
[16:17:45.037] result() for ClusterFuture ... done
[16:17:45.038] result() for ClusterFuture ...
[16:17:45.038] - result already collected: FutureResult
[16:17:45.038] result() for ClusterFuture ... done
[16:17:45.038] result() for ClusterFuture ...
[16:17:45.038] - result already collected: FutureResult
[16:17:45.038] result() for ClusterFuture ... done
[16:17:45.038] - relayed: [n=2] TRUE, FALSE
[16:17:45.038] - queued futures: [n=2] TRUE, FALSE
[16:17:45.038] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:45.038]  length: 1 (resolved future 1)
[16:17:45.066] receiveMessageFromWorker() for ClusterFuture ...
[16:17:45.066] - Validating connection of MultisessionFuture
[16:17:45.067] - received message: FutureResult
[16:17:45.067] - Received FutureResult
[16:17:45.067] - Erased future from FutureRegistry
[16:17:45.067] result() for ClusterFuture ...
[16:17:45.067] - result already collected: FutureResult
[16:17:45.067] result() for ClusterFuture ... done
[16:17:45.067] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:45.067] Future #2
[16:17:45.067] result() for ClusterFuture ...
[16:17:45.068] - result already collected: FutureResult
[16:17:45.068] result() for ClusterFuture ... done
[16:17:45.068] result() for ClusterFuture ...
[16:17:45.068] - result already collected: FutureResult
[16:17:45.068] result() for ClusterFuture ... done
[16:17:45.068] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:45.068] - nx: 2
[16:17:45.068] - relay: TRUE
[16:17:45.068] - stdout: TRUE
[16:17:45.068] - signal: TRUE
[16:17:45.069] - resignal: FALSE
[16:17:45.071] - force: TRUE
[16:17:45.071] - relayed: [n=2] TRUE, FALSE
[16:17:45.071] - queued futures: [n=2] TRUE, FALSE
[16:17:45.072]  - until=2
[16:17:45.072]  - relaying element #2
[16:17:45.072] result() for ClusterFuture ...
[16:17:45.072] - result already collected: FutureResult
[16:17:45.072] result() for ClusterFuture ... done
[16:17:45.072] result() for ClusterFuture ...
[16:17:45.072] - result already collected: FutureResult
[16:17:45.072] result() for ClusterFuture ... done
[16:17:45.072] result() for ClusterFuture ...
[16:17:45.072] - result already collected: FutureResult
[16:17:45.073] result() for ClusterFuture ... done
[16:17:45.073] result() for ClusterFuture ...
[16:17:45.073] - result already collected: FutureResult
[16:17:45.073] result() for ClusterFuture ... done
[16:17:45.073] - relayed: [n=2] TRUE, TRUE
[16:17:45.073] - queued futures: [n=2] TRUE, TRUE
[16:17:45.073] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:45.073]  length: 0 (resolved future 2)
[16:17:45.073] Relaying remaining futures
[16:17:45.073] signalConditionsASAP(NULL, pos=0) ...
[16:17:45.073] - nx: 2
[16:17:45.073] - relay: TRUE
[16:17:45.074] - stdout: TRUE
[16:17:45.074] - signal: TRUE
[16:17:45.074] - resignal: FALSE
[16:17:45.074] - force: TRUE
[16:17:45.074] - relayed: [n=2] TRUE, TRUE
[16:17:45.074] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:45.074] - relayed: [n=2] TRUE, TRUE
[16:17:45.074] - queued futures: [n=2] TRUE, TRUE
[16:17:45.074] signalConditionsASAP(NULL, pos=0) ... done
[16:17:45.074] resolve() on list ... DONE
[16:17:45.074] result() for ClusterFuture ...
[16:17:45.075] - result already collected: FutureResult
[16:17:45.075] result() for ClusterFuture ... done
[16:17:45.075] result() for ClusterFuture ...
[16:17:45.075] - result already collected: FutureResult
[16:17:45.075] result() for ClusterFuture ... done
[16:17:45.075] result() for ClusterFuture ...
[16:17:45.075] - result already collected: FutureResult
[16:17:45.075] result() for ClusterFuture ... done
[16:17:45.075] result() for ClusterFuture ...
[16:17:45.075] - result already collected: FutureResult
[16:17:45.075] result() for ClusterFuture ... done
[16:17:45.076]  - Number of value chunks collected: 2
[16:17:45.076] Resolving 2 futures (chunks) ... DONE
[16:17:45.076] Reducing values from 2 chunks ...
[16:17:45.076]  - Number of values collected after concatenation: 6
[16:17:45.076]  - Number of values expected: 6
[16:17:45.076] Reducing values from 2 chunks ... DONE
[16:17:45.076] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:17:45.076] getGlobalsAndPackagesXApply() ...
[16:17:45.076]  - future.globals: TRUE
[16:17:45.077] getGlobalsAndPackages() ...
[16:17:45.077] Searching for globals...
[16:17:45.078] - globals found: [1] ‘FUN’
[16:17:45.078] Searching for globals ... DONE
[16:17:45.078] Resolving globals: FALSE
[16:17:45.078] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:45.079] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:45.079] - globals: [1] ‘FUN’
[16:17:45.079] 
[16:17:45.079] getGlobalsAndPackages() ... DONE
[16:17:45.079]  - globals found/used: [n=1] ‘FUN’
[16:17:45.079]  - needed namespaces: [n=0] 
[16:17:45.079] Finding globals ... DONE
[16:17:45.079]  - use_args: TRUE
[16:17:45.080]  - Getting '...' globals ...
[16:17:45.080] resolve() on list ...
[16:17:45.080]  recursive: 0
[16:17:45.080]  length: 1
[16:17:45.080]  elements: ‘...’
[16:17:45.080]  length: 0 (resolved future 1)
[16:17:45.080] resolve() on list ... DONE
[16:17:45.080]    - '...' content: [n=0] 
[16:17:45.081] List of 1
[16:17:45.081]  $ ...: list()
[16:17:45.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.081]  - attr(*, "where")=List of 1
[16:17:45.081]   ..$ ...:<environment: 0x555be2902300> 
[16:17:45.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.081]  - attr(*, "resolved")= logi TRUE
[16:17:45.081]  - attr(*, "total_size")= num NA
[16:17:45.083]  - Getting '...' globals ... DONE
[16:17:45.083] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:45.083] List of 2
[16:17:45.083]  $ ...future.FUN:function (x)  
[16:17:45.083]  $ ...          : list()
[16:17:45.083]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.083]  - attr(*, "where")=List of 2
[16:17:45.083]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:45.083]   ..$ ...          :<environment: 0x555be2902300> 
[16:17:45.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.083]  - attr(*, "resolved")= logi FALSE
[16:17:45.083]  - attr(*, "total_size")= num 848
[16:17:45.086] Packages to be attached in all futures: [n=0] 
[16:17:45.086] getGlobalsAndPackagesXApply() ... DONE
[16:17:45.090] future_lapply() ...
[16:17:45.094] Number of chunks: 2
[16:17:45.094] getGlobalsAndPackagesXApply() ...
[16:17:45.094]  - future.globals: <name-value list> with names ‘list()’
[16:17:45.094]  - use_args: TRUE
[16:17:45.094] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:45.094] List of 2
[16:17:45.094]  $ ...          : list()
[16:17:45.094]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.094]  $ ...future.FUN:function (x)  
[16:17:45.094]  - attr(*, "where")=List of 2
[16:17:45.094]   ..$ ...          :<environment: 0x555be2902300> 
[16:17:45.094]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:45.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.094]  - attr(*, "resolved")= logi FALSE
[16:17:45.094]  - attr(*, "total_size")= num NA
[16:17:45.098] Packages to be attached in all futures: [n=0] 
[16:17:45.098] getGlobalsAndPackagesXApply() ... DONE
[16:17:45.098] Number of futures (= number of chunks): 2
[16:17:45.098] Launching 2 futures (chunks) ...
[16:17:45.098] Chunk #1 of 2 ...
[16:17:45.099]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:45.099]  - seeds: <none>
[16:17:45.099]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.099] getGlobalsAndPackages() ...
[16:17:45.099] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.099] Resolving globals: FALSE
[16:17:45.099] Tweak future expression to call with '...' arguments ...
[16:17:45.100] {
[16:17:45.100]     do.call(function(...) {
[16:17:45.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.100]             on.exit(options(oopts), add = TRUE)
[16:17:45.100]         }
[16:17:45.100]         {
[16:17:45.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.100]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.100]             })
[16:17:45.100]         }
[16:17:45.100]     }, args = future.call.arguments)
[16:17:45.100] }
[16:17:45.100] Tweak future expression to call with '...' arguments ... DONE
[16:17:45.100] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.100] 
[16:17:45.100] getGlobalsAndPackages() ... DONE
[16:17:45.101] run() for ‘Future’ ...
[16:17:45.101] - state: ‘created’
[16:17:45.101] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:45.115] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.115] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:45.115]   - Field: ‘node’
[16:17:45.115]   - Field: ‘label’
[16:17:45.116]   - Field: ‘local’
[16:17:45.116]   - Field: ‘owner’
[16:17:45.116]   - Field: ‘envir’
[16:17:45.116]   - Field: ‘workers’
[16:17:45.116]   - Field: ‘packages’
[16:17:45.116]   - Field: ‘gc’
[16:17:45.116]   - Field: ‘conditions’
[16:17:45.116]   - Field: ‘persistent’
[16:17:45.116]   - Field: ‘expr’
[16:17:45.116]   - Field: ‘uuid’
[16:17:45.117]   - Field: ‘seed’
[16:17:45.117]   - Field: ‘version’
[16:17:45.117]   - Field: ‘result’
[16:17:45.117]   - Field: ‘asynchronous’
[16:17:45.117]   - Field: ‘calls’
[16:17:45.117]   - Field: ‘globals’
[16:17:45.117]   - Field: ‘stdout’
[16:17:45.117]   - Field: ‘earlySignal’
[16:17:45.117]   - Field: ‘lazy’
[16:17:45.117]   - Field: ‘state’
[16:17:45.118] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:45.118] - Launch lazy future ...
[16:17:45.118] Packages needed by the future expression (n = 0): <none>
[16:17:45.118] Packages needed by future strategies (n = 0): <none>
[16:17:45.118] {
[16:17:45.118]     {
[16:17:45.118]         {
[16:17:45.118]             ...future.startTime <- base::Sys.time()
[16:17:45.118]             {
[16:17:45.118]                 {
[16:17:45.118]                   {
[16:17:45.118]                     {
[16:17:45.118]                       base::local({
[16:17:45.118]                         has_future <- base::requireNamespace("future", 
[16:17:45.118]                           quietly = TRUE)
[16:17:45.118]                         if (has_future) {
[16:17:45.118]                           ns <- base::getNamespace("future")
[16:17:45.118]                           version <- ns[[".package"]][["version"]]
[16:17:45.118]                           if (is.null(version)) 
[16:17:45.118]                             version <- utils::packageVersion("future")
[16:17:45.118]                         }
[16:17:45.118]                         else {
[16:17:45.118]                           version <- NULL
[16:17:45.118]                         }
[16:17:45.118]                         if (!has_future || version < "1.8.0") {
[16:17:45.118]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:45.118]                             "", base::R.version$version.string), 
[16:17:45.118]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:45.118]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:45.118]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:45.118]                               "release", "version")], collapse = " "), 
[16:17:45.118]                             hostname = base::Sys.info()[["nodename"]])
[16:17:45.118]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:45.118]                             info)
[16:17:45.118]                           info <- base::paste(info, collapse = "; ")
[16:17:45.118]                           if (!has_future) {
[16:17:45.118]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:45.118]                               info)
[16:17:45.118]                           }
[16:17:45.118]                           else {
[16:17:45.118]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:45.118]                               info, version)
[16:17:45.118]                           }
[16:17:45.118]                           base::stop(msg)
[16:17:45.118]                         }
[16:17:45.118]                       })
[16:17:45.118]                     }
[16:17:45.118]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:45.118]                     base::options(mc.cores = 1L)
[16:17:45.118]                   }
[16:17:45.118]                   ...future.strategy.old <- future::plan("list")
[16:17:45.118]                   options(future.plan = NULL)
[16:17:45.118]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.118]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:45.118]                 }
[16:17:45.118]                 ...future.workdir <- getwd()
[16:17:45.118]             }
[16:17:45.118]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:45.118]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:45.118]         }
[16:17:45.118]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:45.118]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:45.118]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:45.118]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:45.118]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:45.118]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:45.118]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:45.118]             base::names(...future.oldOptions))
[16:17:45.118]     }
[16:17:45.118]     if (FALSE) {
[16:17:45.118]     }
[16:17:45.118]     else {
[16:17:45.118]         if (TRUE) {
[16:17:45.118]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:45.118]                 open = "w")
[16:17:45.118]         }
[16:17:45.118]         else {
[16:17:45.118]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:45.118]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:45.118]         }
[16:17:45.118]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:45.118]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:45.118]             base::sink(type = "output", split = FALSE)
[16:17:45.118]             base::close(...future.stdout)
[16:17:45.118]         }, add = TRUE)
[16:17:45.118]     }
[16:17:45.118]     ...future.frame <- base::sys.nframe()
[16:17:45.118]     ...future.conditions <- base::list()
[16:17:45.118]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:45.118]     if (FALSE) {
[16:17:45.118]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:45.118]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:45.118]     }
[16:17:45.118]     ...future.result <- base::tryCatch({
[16:17:45.118]         base::withCallingHandlers({
[16:17:45.118]             ...future.value <- base::withVisible(base::local({
[16:17:45.118]                 ...future.makeSendCondition <- base::local({
[16:17:45.118]                   sendCondition <- NULL
[16:17:45.118]                   function(frame = 1L) {
[16:17:45.118]                     if (is.function(sendCondition)) 
[16:17:45.118]                       return(sendCondition)
[16:17:45.118]                     ns <- getNamespace("parallel")
[16:17:45.118]                     if (exists("sendData", mode = "function", 
[16:17:45.118]                       envir = ns)) {
[16:17:45.118]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:45.118]                         envir = ns)
[16:17:45.118]                       envir <- sys.frame(frame)
[16:17:45.118]                       master <- NULL
[16:17:45.118]                       while (!identical(envir, .GlobalEnv) && 
[16:17:45.118]                         !identical(envir, emptyenv())) {
[16:17:45.118]                         if (exists("master", mode = "list", envir = envir, 
[16:17:45.118]                           inherits = FALSE)) {
[16:17:45.118]                           master <- get("master", mode = "list", 
[16:17:45.118]                             envir = envir, inherits = FALSE)
[16:17:45.118]                           if (inherits(master, c("SOCKnode", 
[16:17:45.118]                             "SOCK0node"))) {
[16:17:45.118]                             sendCondition <<- function(cond) {
[16:17:45.118]                               data <- list(type = "VALUE", value = cond, 
[16:17:45.118]                                 success = TRUE)
[16:17:45.118]                               parallel_sendData(master, data)
[16:17:45.118]                             }
[16:17:45.118]                             return(sendCondition)
[16:17:45.118]                           }
[16:17:45.118]                         }
[16:17:45.118]                         frame <- frame + 1L
[16:17:45.118]                         envir <- sys.frame(frame)
[16:17:45.118]                       }
[16:17:45.118]                     }
[16:17:45.118]                     sendCondition <<- function(cond) NULL
[16:17:45.118]                   }
[16:17:45.118]                 })
[16:17:45.118]                 withCallingHandlers({
[16:17:45.118]                   {
[16:17:45.118]                     do.call(function(...) {
[16:17:45.118]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.118]                       if (!identical(...future.globals.maxSize.org, 
[16:17:45.118]                         ...future.globals.maxSize)) {
[16:17:45.118]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.118]                         on.exit(options(oopts), add = TRUE)
[16:17:45.118]                       }
[16:17:45.118]                       {
[16:17:45.118]                         lapply(seq_along(...future.elements_ii), 
[16:17:45.118]                           FUN = function(jj) {
[16:17:45.118]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.118]                             ...future.FUN(...future.X_jj, ...)
[16:17:45.118]                           })
[16:17:45.118]                       }
[16:17:45.118]                     }, args = future.call.arguments)
[16:17:45.118]                   }
[16:17:45.118]                 }, immediateCondition = function(cond) {
[16:17:45.118]                   sendCondition <- ...future.makeSendCondition()
[16:17:45.118]                   sendCondition(cond)
[16:17:45.118]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.118]                   {
[16:17:45.118]                     inherits <- base::inherits
[16:17:45.118]                     invokeRestart <- base::invokeRestart
[16:17:45.118]                     is.null <- base::is.null
[16:17:45.118]                     muffled <- FALSE
[16:17:45.118]                     if (inherits(cond, "message")) {
[16:17:45.118]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:45.118]                       if (muffled) 
[16:17:45.118]                         invokeRestart("muffleMessage")
[16:17:45.118]                     }
[16:17:45.118]                     else if (inherits(cond, "warning")) {
[16:17:45.118]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:45.118]                       if (muffled) 
[16:17:45.118]                         invokeRestart("muffleWarning")
[16:17:45.118]                     }
[16:17:45.118]                     else if (inherits(cond, "condition")) {
[16:17:45.118]                       if (!is.null(pattern)) {
[16:17:45.118]                         computeRestarts <- base::computeRestarts
[16:17:45.118]                         grepl <- base::grepl
[16:17:45.118]                         restarts <- computeRestarts(cond)
[16:17:45.118]                         for (restart in restarts) {
[16:17:45.118]                           name <- restart$name
[16:17:45.118]                           if (is.null(name)) 
[16:17:45.118]                             next
[16:17:45.118]                           if (!grepl(pattern, name)) 
[16:17:45.118]                             next
[16:17:45.118]                           invokeRestart(restart)
[16:17:45.118]                           muffled <- TRUE
[16:17:45.118]                           break
[16:17:45.118]                         }
[16:17:45.118]                       }
[16:17:45.118]                     }
[16:17:45.118]                     invisible(muffled)
[16:17:45.118]                   }
[16:17:45.118]                   muffleCondition(cond)
[16:17:45.118]                 })
[16:17:45.118]             }))
[16:17:45.118]             future::FutureResult(value = ...future.value$value, 
[16:17:45.118]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.118]                   ...future.rng), globalenv = if (FALSE) 
[16:17:45.118]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:45.118]                     ...future.globalenv.names))
[16:17:45.118]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:45.118]         }, condition = base::local({
[16:17:45.118]             c <- base::c
[16:17:45.118]             inherits <- base::inherits
[16:17:45.118]             invokeRestart <- base::invokeRestart
[16:17:45.118]             length <- base::length
[16:17:45.118]             list <- base::list
[16:17:45.118]             seq.int <- base::seq.int
[16:17:45.118]             signalCondition <- base::signalCondition
[16:17:45.118]             sys.calls <- base::sys.calls
[16:17:45.118]             `[[` <- base::`[[`
[16:17:45.118]             `+` <- base::`+`
[16:17:45.118]             `<<-` <- base::`<<-`
[16:17:45.118]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:45.118]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:45.118]                   3L)]
[16:17:45.118]             }
[16:17:45.118]             function(cond) {
[16:17:45.118]                 is_error <- inherits(cond, "error")
[16:17:45.118]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:45.118]                   NULL)
[16:17:45.118]                 if (is_error) {
[16:17:45.118]                   sessionInformation <- function() {
[16:17:45.118]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:45.118]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:45.118]                       search = base::search(), system = base::Sys.info())
[16:17:45.118]                   }
[16:17:45.118]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.118]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:45.118]                     cond$call), session = sessionInformation(), 
[16:17:45.118]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:45.118]                   signalCondition(cond)
[16:17:45.118]                 }
[16:17:45.118]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:45.118]                 "immediateCondition"))) {
[16:17:45.118]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:45.118]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.118]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:45.118]                   if (TRUE && !signal) {
[16:17:45.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.118]                     {
[16:17:45.118]                       inherits <- base::inherits
[16:17:45.118]                       invokeRestart <- base::invokeRestart
[16:17:45.118]                       is.null <- base::is.null
[16:17:45.118]                       muffled <- FALSE
[16:17:45.118]                       if (inherits(cond, "message")) {
[16:17:45.118]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.118]                         if (muffled) 
[16:17:45.118]                           invokeRestart("muffleMessage")
[16:17:45.118]                       }
[16:17:45.118]                       else if (inherits(cond, "warning")) {
[16:17:45.118]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.118]                         if (muffled) 
[16:17:45.118]                           invokeRestart("muffleWarning")
[16:17:45.118]                       }
[16:17:45.118]                       else if (inherits(cond, "condition")) {
[16:17:45.118]                         if (!is.null(pattern)) {
[16:17:45.118]                           computeRestarts <- base::computeRestarts
[16:17:45.118]                           grepl <- base::grepl
[16:17:45.118]                           restarts <- computeRestarts(cond)
[16:17:45.118]                           for (restart in restarts) {
[16:17:45.118]                             name <- restart$name
[16:17:45.118]                             if (is.null(name)) 
[16:17:45.118]                               next
[16:17:45.118]                             if (!grepl(pattern, name)) 
[16:17:45.118]                               next
[16:17:45.118]                             invokeRestart(restart)
[16:17:45.118]                             muffled <- TRUE
[16:17:45.118]                             break
[16:17:45.118]                           }
[16:17:45.118]                         }
[16:17:45.118]                       }
[16:17:45.118]                       invisible(muffled)
[16:17:45.118]                     }
[16:17:45.118]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.118]                   }
[16:17:45.118]                 }
[16:17:45.118]                 else {
[16:17:45.118]                   if (TRUE) {
[16:17:45.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.118]                     {
[16:17:45.118]                       inherits <- base::inherits
[16:17:45.118]                       invokeRestart <- base::invokeRestart
[16:17:45.118]                       is.null <- base::is.null
[16:17:45.118]                       muffled <- FALSE
[16:17:45.118]                       if (inherits(cond, "message")) {
[16:17:45.118]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.118]                         if (muffled) 
[16:17:45.118]                           invokeRestart("muffleMessage")
[16:17:45.118]                       }
[16:17:45.118]                       else if (inherits(cond, "warning")) {
[16:17:45.118]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.118]                         if (muffled) 
[16:17:45.118]                           invokeRestart("muffleWarning")
[16:17:45.118]                       }
[16:17:45.118]                       else if (inherits(cond, "condition")) {
[16:17:45.118]                         if (!is.null(pattern)) {
[16:17:45.118]                           computeRestarts <- base::computeRestarts
[16:17:45.118]                           grepl <- base::grepl
[16:17:45.118]                           restarts <- computeRestarts(cond)
[16:17:45.118]                           for (restart in restarts) {
[16:17:45.118]                             name <- restart$name
[16:17:45.118]                             if (is.null(name)) 
[16:17:45.118]                               next
[16:17:45.118]                             if (!grepl(pattern, name)) 
[16:17:45.118]                               next
[16:17:45.118]                             invokeRestart(restart)
[16:17:45.118]                             muffled <- TRUE
[16:17:45.118]                             break
[16:17:45.118]                           }
[16:17:45.118]                         }
[16:17:45.118]                       }
[16:17:45.118]                       invisible(muffled)
[16:17:45.118]                     }
[16:17:45.118]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.118]                   }
[16:17:45.118]                 }
[16:17:45.118]             }
[16:17:45.118]         }))
[16:17:45.118]     }, error = function(ex) {
[16:17:45.118]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:45.118]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.118]                 ...future.rng), started = ...future.startTime, 
[16:17:45.118]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:45.118]             version = "1.8"), class = "FutureResult")
[16:17:45.118]     }, finally = {
[16:17:45.118]         if (!identical(...future.workdir, getwd())) 
[16:17:45.118]             setwd(...future.workdir)
[16:17:45.118]         {
[16:17:45.118]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:45.118]                 ...future.oldOptions$nwarnings <- NULL
[16:17:45.118]             }
[16:17:45.118]             base::options(...future.oldOptions)
[16:17:45.118]             if (.Platform$OS.type == "windows") {
[16:17:45.118]                 old_names <- names(...future.oldEnvVars)
[16:17:45.118]                 envs <- base::Sys.getenv()
[16:17:45.118]                 names <- names(envs)
[16:17:45.118]                 common <- intersect(names, old_names)
[16:17:45.118]                 added <- setdiff(names, old_names)
[16:17:45.118]                 removed <- setdiff(old_names, names)
[16:17:45.118]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:45.118]                   envs[common]]
[16:17:45.118]                 NAMES <- toupper(changed)
[16:17:45.118]                 args <- list()
[16:17:45.118]                 for (kk in seq_along(NAMES)) {
[16:17:45.118]                   name <- changed[[kk]]
[16:17:45.118]                   NAME <- NAMES[[kk]]
[16:17:45.118]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.118]                     next
[16:17:45.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.118]                 }
[16:17:45.118]                 NAMES <- toupper(added)
[16:17:45.118]                 for (kk in seq_along(NAMES)) {
[16:17:45.118]                   name <- added[[kk]]
[16:17:45.118]                   NAME <- NAMES[[kk]]
[16:17:45.118]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.118]                     next
[16:17:45.118]                   args[[name]] <- ""
[16:17:45.118]                 }
[16:17:45.118]                 NAMES <- toupper(removed)
[16:17:45.118]                 for (kk in seq_along(NAMES)) {
[16:17:45.118]                   name <- removed[[kk]]
[16:17:45.118]                   NAME <- NAMES[[kk]]
[16:17:45.118]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.118]                     next
[16:17:45.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.118]                 }
[16:17:45.118]                 if (length(args) > 0) 
[16:17:45.118]                   base::do.call(base::Sys.setenv, args = args)
[16:17:45.118]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:45.118]             }
[16:17:45.118]             else {
[16:17:45.118]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:45.118]             }
[16:17:45.118]             {
[16:17:45.118]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:45.118]                   0L) {
[16:17:45.118]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:45.118]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:45.118]                   base::options(opts)
[16:17:45.118]                 }
[16:17:45.118]                 {
[16:17:45.118]                   {
[16:17:45.118]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:45.118]                     NULL
[16:17:45.118]                   }
[16:17:45.118]                   options(future.plan = NULL)
[16:17:45.118]                   if (is.na(NA_character_)) 
[16:17:45.118]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.118]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:45.118]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:45.118]                     .init = FALSE)
[16:17:45.118]                 }
[16:17:45.118]             }
[16:17:45.118]         }
[16:17:45.118]     })
[16:17:45.118]     if (TRUE) {
[16:17:45.118]         base::sink(type = "output", split = FALSE)
[16:17:45.118]         if (TRUE) {
[16:17:45.118]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:45.118]         }
[16:17:45.118]         else {
[16:17:45.118]             ...future.result["stdout"] <- base::list(NULL)
[16:17:45.118]         }
[16:17:45.118]         base::close(...future.stdout)
[16:17:45.118]         ...future.stdout <- NULL
[16:17:45.118]     }
[16:17:45.118]     ...future.result$conditions <- ...future.conditions
[16:17:45.118]     ...future.result$finished <- base::Sys.time()
[16:17:45.118]     ...future.result
[16:17:45.118] }
[16:17:45.122] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[16:17:45.122] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:45.122] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:45.122] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:17:45.123] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:17:45.123] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:17:45.123] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:17:45.123] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:45.123] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:45.124] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:17:45.124] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:17:45.124] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[16:17:45.124] MultisessionFuture started
[16:17:45.125] - Launch lazy future ... done
[16:17:45.125] run() for ‘MultisessionFuture’ ... done
[16:17:45.125] Created future:
[16:17:45.125] MultisessionFuture:
[16:17:45.125] Label: ‘future_apply-1’
[16:17:45.125] Expression:
[16:17:45.125] {
[16:17:45.125]     do.call(function(...) {
[16:17:45.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.125]             on.exit(options(oopts), add = TRUE)
[16:17:45.125]         }
[16:17:45.125]         {
[16:17:45.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.125]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.125]             })
[16:17:45.125]         }
[16:17:45.125]     }, args = future.call.arguments)
[16:17:45.125] }
[16:17:45.125] Lazy evaluation: FALSE
[16:17:45.125] Asynchronous evaluation: TRUE
[16:17:45.125] Local evaluation: TRUE
[16:17:45.125] Environment: R_GlobalEnv
[16:17:45.125] Capture standard output: TRUE
[16:17:45.125] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:45.125] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:45.125] Packages: <none>
[16:17:45.125] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:45.125] Resolved: FALSE
[16:17:45.125] Value: <not collected>
[16:17:45.125] Conditions captured: <none>
[16:17:45.125] Early signaling: FALSE
[16:17:45.125] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:45.125] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.136] Chunk #1 of 2 ... DONE
[16:17:45.137] Chunk #2 of 2 ...
[16:17:45.137]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:45.137]  - seeds: <none>
[16:17:45.137]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.137] getGlobalsAndPackages() ...
[16:17:45.137] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.137] Resolving globals: FALSE
[16:17:45.137] Tweak future expression to call with '...' arguments ...
[16:17:45.138] {
[16:17:45.138]     do.call(function(...) {
[16:17:45.138]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.138]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.138]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.138]             on.exit(options(oopts), add = TRUE)
[16:17:45.138]         }
[16:17:45.138]         {
[16:17:45.138]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.138]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.138]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.138]             })
[16:17:45.138]         }
[16:17:45.138]     }, args = future.call.arguments)
[16:17:45.138] }
[16:17:45.138] Tweak future expression to call with '...' arguments ... DONE
[16:17:45.138] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.138] 
[16:17:45.138] getGlobalsAndPackages() ... DONE
[16:17:45.139] run() for ‘Future’ ...
[16:17:45.139] - state: ‘created’
[16:17:45.139] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:45.153] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:45.153]   - Field: ‘node’
[16:17:45.153]   - Field: ‘label’
[16:17:45.153]   - Field: ‘local’
[16:17:45.154]   - Field: ‘owner’
[16:17:45.154]   - Field: ‘envir’
[16:17:45.154]   - Field: ‘workers’
[16:17:45.154]   - Field: ‘packages’
[16:17:45.154]   - Field: ‘gc’
[16:17:45.154]   - Field: ‘conditions’
[16:17:45.154]   - Field: ‘persistent’
[16:17:45.154]   - Field: ‘expr’
[16:17:45.154]   - Field: ‘uuid’
[16:17:45.154]   - Field: ‘seed’
[16:17:45.154]   - Field: ‘version’
[16:17:45.155]   - Field: ‘result’
[16:17:45.155]   - Field: ‘asynchronous’
[16:17:45.155]   - Field: ‘calls’
[16:17:45.155]   - Field: ‘globals’
[16:17:45.155]   - Field: ‘stdout’
[16:17:45.155]   - Field: ‘earlySignal’
[16:17:45.155]   - Field: ‘lazy’
[16:17:45.155]   - Field: ‘state’
[16:17:45.155] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:45.155] - Launch lazy future ...
[16:17:45.156] Packages needed by the future expression (n = 0): <none>
[16:17:45.156] Packages needed by future strategies (n = 0): <none>
[16:17:45.156] {
[16:17:45.156]     {
[16:17:45.156]         {
[16:17:45.156]             ...future.startTime <- base::Sys.time()
[16:17:45.156]             {
[16:17:45.156]                 {
[16:17:45.156]                   {
[16:17:45.156]                     {
[16:17:45.156]                       base::local({
[16:17:45.156]                         has_future <- base::requireNamespace("future", 
[16:17:45.156]                           quietly = TRUE)
[16:17:45.156]                         if (has_future) {
[16:17:45.156]                           ns <- base::getNamespace("future")
[16:17:45.156]                           version <- ns[[".package"]][["version"]]
[16:17:45.156]                           if (is.null(version)) 
[16:17:45.156]                             version <- utils::packageVersion("future")
[16:17:45.156]                         }
[16:17:45.156]                         else {
[16:17:45.156]                           version <- NULL
[16:17:45.156]                         }
[16:17:45.156]                         if (!has_future || version < "1.8.0") {
[16:17:45.156]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:45.156]                             "", base::R.version$version.string), 
[16:17:45.156]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:45.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:45.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:45.156]                               "release", "version")], collapse = " "), 
[16:17:45.156]                             hostname = base::Sys.info()[["nodename"]])
[16:17:45.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:45.156]                             info)
[16:17:45.156]                           info <- base::paste(info, collapse = "; ")
[16:17:45.156]                           if (!has_future) {
[16:17:45.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:45.156]                               info)
[16:17:45.156]                           }
[16:17:45.156]                           else {
[16:17:45.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:45.156]                               info, version)
[16:17:45.156]                           }
[16:17:45.156]                           base::stop(msg)
[16:17:45.156]                         }
[16:17:45.156]                       })
[16:17:45.156]                     }
[16:17:45.156]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:45.156]                     base::options(mc.cores = 1L)
[16:17:45.156]                   }
[16:17:45.156]                   ...future.strategy.old <- future::plan("list")
[16:17:45.156]                   options(future.plan = NULL)
[16:17:45.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:45.156]                 }
[16:17:45.156]                 ...future.workdir <- getwd()
[16:17:45.156]             }
[16:17:45.156]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:45.156]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:45.156]         }
[16:17:45.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:45.156]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:45.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:45.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:45.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:45.156]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:45.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:45.156]             base::names(...future.oldOptions))
[16:17:45.156]     }
[16:17:45.156]     if (FALSE) {
[16:17:45.156]     }
[16:17:45.156]     else {
[16:17:45.156]         if (TRUE) {
[16:17:45.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:45.156]                 open = "w")
[16:17:45.156]         }
[16:17:45.156]         else {
[16:17:45.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:45.156]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:45.156]         }
[16:17:45.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:45.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:45.156]             base::sink(type = "output", split = FALSE)
[16:17:45.156]             base::close(...future.stdout)
[16:17:45.156]         }, add = TRUE)
[16:17:45.156]     }
[16:17:45.156]     ...future.frame <- base::sys.nframe()
[16:17:45.156]     ...future.conditions <- base::list()
[16:17:45.156]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:45.156]     if (FALSE) {
[16:17:45.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:45.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:45.156]     }
[16:17:45.156]     ...future.result <- base::tryCatch({
[16:17:45.156]         base::withCallingHandlers({
[16:17:45.156]             ...future.value <- base::withVisible(base::local({
[16:17:45.156]                 ...future.makeSendCondition <- base::local({
[16:17:45.156]                   sendCondition <- NULL
[16:17:45.156]                   function(frame = 1L) {
[16:17:45.156]                     if (is.function(sendCondition)) 
[16:17:45.156]                       return(sendCondition)
[16:17:45.156]                     ns <- getNamespace("parallel")
[16:17:45.156]                     if (exists("sendData", mode = "function", 
[16:17:45.156]                       envir = ns)) {
[16:17:45.156]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:45.156]                         envir = ns)
[16:17:45.156]                       envir <- sys.frame(frame)
[16:17:45.156]                       master <- NULL
[16:17:45.156]                       while (!identical(envir, .GlobalEnv) && 
[16:17:45.156]                         !identical(envir, emptyenv())) {
[16:17:45.156]                         if (exists("master", mode = "list", envir = envir, 
[16:17:45.156]                           inherits = FALSE)) {
[16:17:45.156]                           master <- get("master", mode = "list", 
[16:17:45.156]                             envir = envir, inherits = FALSE)
[16:17:45.156]                           if (inherits(master, c("SOCKnode", 
[16:17:45.156]                             "SOCK0node"))) {
[16:17:45.156]                             sendCondition <<- function(cond) {
[16:17:45.156]                               data <- list(type = "VALUE", value = cond, 
[16:17:45.156]                                 success = TRUE)
[16:17:45.156]                               parallel_sendData(master, data)
[16:17:45.156]                             }
[16:17:45.156]                             return(sendCondition)
[16:17:45.156]                           }
[16:17:45.156]                         }
[16:17:45.156]                         frame <- frame + 1L
[16:17:45.156]                         envir <- sys.frame(frame)
[16:17:45.156]                       }
[16:17:45.156]                     }
[16:17:45.156]                     sendCondition <<- function(cond) NULL
[16:17:45.156]                   }
[16:17:45.156]                 })
[16:17:45.156]                 withCallingHandlers({
[16:17:45.156]                   {
[16:17:45.156]                     do.call(function(...) {
[16:17:45.156]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.156]                       if (!identical(...future.globals.maxSize.org, 
[16:17:45.156]                         ...future.globals.maxSize)) {
[16:17:45.156]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.156]                         on.exit(options(oopts), add = TRUE)
[16:17:45.156]                       }
[16:17:45.156]                       {
[16:17:45.156]                         lapply(seq_along(...future.elements_ii), 
[16:17:45.156]                           FUN = function(jj) {
[16:17:45.156]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.156]                             ...future.FUN(...future.X_jj, ...)
[16:17:45.156]                           })
[16:17:45.156]                       }
[16:17:45.156]                     }, args = future.call.arguments)
[16:17:45.156]                   }
[16:17:45.156]                 }, immediateCondition = function(cond) {
[16:17:45.156]                   sendCondition <- ...future.makeSendCondition()
[16:17:45.156]                   sendCondition(cond)
[16:17:45.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.156]                   {
[16:17:45.156]                     inherits <- base::inherits
[16:17:45.156]                     invokeRestart <- base::invokeRestart
[16:17:45.156]                     is.null <- base::is.null
[16:17:45.156]                     muffled <- FALSE
[16:17:45.156]                     if (inherits(cond, "message")) {
[16:17:45.156]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:45.156]                       if (muffled) 
[16:17:45.156]                         invokeRestart("muffleMessage")
[16:17:45.156]                     }
[16:17:45.156]                     else if (inherits(cond, "warning")) {
[16:17:45.156]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:45.156]                       if (muffled) 
[16:17:45.156]                         invokeRestart("muffleWarning")
[16:17:45.156]                     }
[16:17:45.156]                     else if (inherits(cond, "condition")) {
[16:17:45.156]                       if (!is.null(pattern)) {
[16:17:45.156]                         computeRestarts <- base::computeRestarts
[16:17:45.156]                         grepl <- base::grepl
[16:17:45.156]                         restarts <- computeRestarts(cond)
[16:17:45.156]                         for (restart in restarts) {
[16:17:45.156]                           name <- restart$name
[16:17:45.156]                           if (is.null(name)) 
[16:17:45.156]                             next
[16:17:45.156]                           if (!grepl(pattern, name)) 
[16:17:45.156]                             next
[16:17:45.156]                           invokeRestart(restart)
[16:17:45.156]                           muffled <- TRUE
[16:17:45.156]                           break
[16:17:45.156]                         }
[16:17:45.156]                       }
[16:17:45.156]                     }
[16:17:45.156]                     invisible(muffled)
[16:17:45.156]                   }
[16:17:45.156]                   muffleCondition(cond)
[16:17:45.156]                 })
[16:17:45.156]             }))
[16:17:45.156]             future::FutureResult(value = ...future.value$value, 
[16:17:45.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.156]                   ...future.rng), globalenv = if (FALSE) 
[16:17:45.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:45.156]                     ...future.globalenv.names))
[16:17:45.156]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:45.156]         }, condition = base::local({
[16:17:45.156]             c <- base::c
[16:17:45.156]             inherits <- base::inherits
[16:17:45.156]             invokeRestart <- base::invokeRestart
[16:17:45.156]             length <- base::length
[16:17:45.156]             list <- base::list
[16:17:45.156]             seq.int <- base::seq.int
[16:17:45.156]             signalCondition <- base::signalCondition
[16:17:45.156]             sys.calls <- base::sys.calls
[16:17:45.156]             `[[` <- base::`[[`
[16:17:45.156]             `+` <- base::`+`
[16:17:45.156]             `<<-` <- base::`<<-`
[16:17:45.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:45.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:45.156]                   3L)]
[16:17:45.156]             }
[16:17:45.156]             function(cond) {
[16:17:45.156]                 is_error <- inherits(cond, "error")
[16:17:45.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:45.156]                   NULL)
[16:17:45.156]                 if (is_error) {
[16:17:45.156]                   sessionInformation <- function() {
[16:17:45.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:45.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:45.156]                       search = base::search(), system = base::Sys.info())
[16:17:45.156]                   }
[16:17:45.156]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:45.156]                     cond$call), session = sessionInformation(), 
[16:17:45.156]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:45.156]                   signalCondition(cond)
[16:17:45.156]                 }
[16:17:45.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:45.156]                 "immediateCondition"))) {
[16:17:45.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:45.156]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:45.156]                   if (TRUE && !signal) {
[16:17:45.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.156]                     {
[16:17:45.156]                       inherits <- base::inherits
[16:17:45.156]                       invokeRestart <- base::invokeRestart
[16:17:45.156]                       is.null <- base::is.null
[16:17:45.156]                       muffled <- FALSE
[16:17:45.156]                       if (inherits(cond, "message")) {
[16:17:45.156]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.156]                         if (muffled) 
[16:17:45.156]                           invokeRestart("muffleMessage")
[16:17:45.156]                       }
[16:17:45.156]                       else if (inherits(cond, "warning")) {
[16:17:45.156]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.156]                         if (muffled) 
[16:17:45.156]                           invokeRestart("muffleWarning")
[16:17:45.156]                       }
[16:17:45.156]                       else if (inherits(cond, "condition")) {
[16:17:45.156]                         if (!is.null(pattern)) {
[16:17:45.156]                           computeRestarts <- base::computeRestarts
[16:17:45.156]                           grepl <- base::grepl
[16:17:45.156]                           restarts <- computeRestarts(cond)
[16:17:45.156]                           for (restart in restarts) {
[16:17:45.156]                             name <- restart$name
[16:17:45.156]                             if (is.null(name)) 
[16:17:45.156]                               next
[16:17:45.156]                             if (!grepl(pattern, name)) 
[16:17:45.156]                               next
[16:17:45.156]                             invokeRestart(restart)
[16:17:45.156]                             muffled <- TRUE
[16:17:45.156]                             break
[16:17:45.156]                           }
[16:17:45.156]                         }
[16:17:45.156]                       }
[16:17:45.156]                       invisible(muffled)
[16:17:45.156]                     }
[16:17:45.156]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.156]                   }
[16:17:45.156]                 }
[16:17:45.156]                 else {
[16:17:45.156]                   if (TRUE) {
[16:17:45.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.156]                     {
[16:17:45.156]                       inherits <- base::inherits
[16:17:45.156]                       invokeRestart <- base::invokeRestart
[16:17:45.156]                       is.null <- base::is.null
[16:17:45.156]                       muffled <- FALSE
[16:17:45.156]                       if (inherits(cond, "message")) {
[16:17:45.156]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.156]                         if (muffled) 
[16:17:45.156]                           invokeRestart("muffleMessage")
[16:17:45.156]                       }
[16:17:45.156]                       else if (inherits(cond, "warning")) {
[16:17:45.156]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.156]                         if (muffled) 
[16:17:45.156]                           invokeRestart("muffleWarning")
[16:17:45.156]                       }
[16:17:45.156]                       else if (inherits(cond, "condition")) {
[16:17:45.156]                         if (!is.null(pattern)) {
[16:17:45.156]                           computeRestarts <- base::computeRestarts
[16:17:45.156]                           grepl <- base::grepl
[16:17:45.156]                           restarts <- computeRestarts(cond)
[16:17:45.156]                           for (restart in restarts) {
[16:17:45.156]                             name <- restart$name
[16:17:45.156]                             if (is.null(name)) 
[16:17:45.156]                               next
[16:17:45.156]                             if (!grepl(pattern, name)) 
[16:17:45.156]                               next
[16:17:45.156]                             invokeRestart(restart)
[16:17:45.156]                             muffled <- TRUE
[16:17:45.156]                             break
[16:17:45.156]                           }
[16:17:45.156]                         }
[16:17:45.156]                       }
[16:17:45.156]                       invisible(muffled)
[16:17:45.156]                     }
[16:17:45.156]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.156]                   }
[16:17:45.156]                 }
[16:17:45.156]             }
[16:17:45.156]         }))
[16:17:45.156]     }, error = function(ex) {
[16:17:45.156]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:45.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.156]                 ...future.rng), started = ...future.startTime, 
[16:17:45.156]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:45.156]             version = "1.8"), class = "FutureResult")
[16:17:45.156]     }, finally = {
[16:17:45.156]         if (!identical(...future.workdir, getwd())) 
[16:17:45.156]             setwd(...future.workdir)
[16:17:45.156]         {
[16:17:45.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:45.156]                 ...future.oldOptions$nwarnings <- NULL
[16:17:45.156]             }
[16:17:45.156]             base::options(...future.oldOptions)
[16:17:45.156]             if (.Platform$OS.type == "windows") {
[16:17:45.156]                 old_names <- names(...future.oldEnvVars)
[16:17:45.156]                 envs <- base::Sys.getenv()
[16:17:45.156]                 names <- names(envs)
[16:17:45.156]                 common <- intersect(names, old_names)
[16:17:45.156]                 added <- setdiff(names, old_names)
[16:17:45.156]                 removed <- setdiff(old_names, names)
[16:17:45.156]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:45.156]                   envs[common]]
[16:17:45.156]                 NAMES <- toupper(changed)
[16:17:45.156]                 args <- list()
[16:17:45.156]                 for (kk in seq_along(NAMES)) {
[16:17:45.156]                   name <- changed[[kk]]
[16:17:45.156]                   NAME <- NAMES[[kk]]
[16:17:45.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.156]                     next
[16:17:45.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.156]                 }
[16:17:45.156]                 NAMES <- toupper(added)
[16:17:45.156]                 for (kk in seq_along(NAMES)) {
[16:17:45.156]                   name <- added[[kk]]
[16:17:45.156]                   NAME <- NAMES[[kk]]
[16:17:45.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.156]                     next
[16:17:45.156]                   args[[name]] <- ""
[16:17:45.156]                 }
[16:17:45.156]                 NAMES <- toupper(removed)
[16:17:45.156]                 for (kk in seq_along(NAMES)) {
[16:17:45.156]                   name <- removed[[kk]]
[16:17:45.156]                   NAME <- NAMES[[kk]]
[16:17:45.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.156]                     next
[16:17:45.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.156]                 }
[16:17:45.156]                 if (length(args) > 0) 
[16:17:45.156]                   base::do.call(base::Sys.setenv, args = args)
[16:17:45.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:45.156]             }
[16:17:45.156]             else {
[16:17:45.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:45.156]             }
[16:17:45.156]             {
[16:17:45.156]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:45.156]                   0L) {
[16:17:45.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:45.156]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:45.156]                   base::options(opts)
[16:17:45.156]                 }
[16:17:45.156]                 {
[16:17:45.156]                   {
[16:17:45.156]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:45.156]                     NULL
[16:17:45.156]                   }
[16:17:45.156]                   options(future.plan = NULL)
[16:17:45.156]                   if (is.na(NA_character_)) 
[16:17:45.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:45.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:45.156]                     .init = FALSE)
[16:17:45.156]                 }
[16:17:45.156]             }
[16:17:45.156]         }
[16:17:45.156]     })
[16:17:45.156]     if (TRUE) {
[16:17:45.156]         base::sink(type = "output", split = FALSE)
[16:17:45.156]         if (TRUE) {
[16:17:45.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:45.156]         }
[16:17:45.156]         else {
[16:17:45.156]             ...future.result["stdout"] <- base::list(NULL)
[16:17:45.156]         }
[16:17:45.156]         base::close(...future.stdout)
[16:17:45.156]         ...future.stdout <- NULL
[16:17:45.156]     }
[16:17:45.156]     ...future.result$conditions <- ...future.conditions
[16:17:45.156]     ...future.result$finished <- base::Sys.time()
[16:17:45.156]     ...future.result
[16:17:45.156] }
[16:17:45.159] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[16:17:45.159] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:45.160] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:45.160] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:17:45.160] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:17:45.160] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:17:45.161] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:17:45.161] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:45.161] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:45.161] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:17:45.162] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:17:45.162] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[16:17:45.162] MultisessionFuture started
[16:17:45.162] - Launch lazy future ... done
[16:17:45.162] run() for ‘MultisessionFuture’ ... done
[16:17:45.163] Created future:
[16:17:45.163] MultisessionFuture:
[16:17:45.163] Label: ‘future_apply-2’
[16:17:45.163] Expression:
[16:17:45.163] {
[16:17:45.163]     do.call(function(...) {
[16:17:45.163]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.163]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.163]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.163]             on.exit(options(oopts), add = TRUE)
[16:17:45.163]         }
[16:17:45.163]         {
[16:17:45.163]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.163]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.163]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.163]             })
[16:17:45.163]         }
[16:17:45.163]     }, args = future.call.arguments)
[16:17:45.163] }
[16:17:45.163] Lazy evaluation: FALSE
[16:17:45.163] Asynchronous evaluation: TRUE
[16:17:45.163] Local evaluation: TRUE
[16:17:45.163] Environment: R_GlobalEnv
[16:17:45.163] Capture standard output: TRUE
[16:17:45.163] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:45.163] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:45.163] Packages: <none>
[16:17:45.163] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:45.163] Resolved: FALSE
[16:17:45.163] Value: <not collected>
[16:17:45.163] Conditions captured: <none>
[16:17:45.163] Early signaling: FALSE
[16:17:45.163] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:45.163] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.174] Chunk #2 of 2 ... DONE
[16:17:45.174] Launching 2 futures (chunks) ... DONE
[16:17:45.174] Resolving 2 futures (chunks) ...
[16:17:45.174] resolve() on list ...
[16:17:45.175]  recursive: 0
[16:17:45.175]  length: 2
[16:17:45.175] 
[16:17:45.175] receiveMessageFromWorker() for ClusterFuture ...
[16:17:45.175] - Validating connection of MultisessionFuture
[16:17:45.176] - received message: FutureResult
[16:17:45.176] - Received FutureResult
[16:17:45.176] - Erased future from FutureRegistry
[16:17:45.176] result() for ClusterFuture ...
[16:17:45.176] - result already collected: FutureResult
[16:17:45.176] result() for ClusterFuture ... done
[16:17:45.176] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:45.176] Future #1
[16:17:45.176] result() for ClusterFuture ...
[16:17:45.177] - result already collected: FutureResult
[16:17:45.177] result() for ClusterFuture ... done
[16:17:45.177] result() for ClusterFuture ...
[16:17:45.177] - result already collected: FutureResult
[16:17:45.177] result() for ClusterFuture ... done
[16:17:45.177] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:45.177] - nx: 2
[16:17:45.177] - relay: TRUE
[16:17:45.177] - stdout: TRUE
[16:17:45.177] - signal: TRUE
[16:17:45.177] - resignal: FALSE
[16:17:45.177] - force: TRUE
[16:17:45.178] - relayed: [n=2] FALSE, FALSE
[16:17:45.178] - queued futures: [n=2] FALSE, FALSE
[16:17:45.178]  - until=1
[16:17:45.178]  - relaying element #1
[16:17:45.178] result() for ClusterFuture ...
[16:17:45.178] - result already collected: FutureResult
[16:17:45.178] result() for ClusterFuture ... done
[16:17:45.178] result() for ClusterFuture ...
[16:17:45.178] - result already collected: FutureResult
[16:17:45.178] result() for ClusterFuture ... done
[16:17:45.178] result() for ClusterFuture ...
[16:17:45.179] - result already collected: FutureResult
[16:17:45.179] result() for ClusterFuture ... done
[16:17:45.179] result() for ClusterFuture ...
[16:17:45.179] - result already collected: FutureResult
[16:17:45.179] result() for ClusterFuture ... done
[16:17:45.179] - relayed: [n=2] TRUE, FALSE
[16:17:45.179] - queued futures: [n=2] TRUE, FALSE
[16:17:45.179] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:45.179]  length: 1 (resolved future 1)
[16:17:45.206] receiveMessageFromWorker() for ClusterFuture ...
[16:17:45.206] - Validating connection of MultisessionFuture
[16:17:45.206] - received message: FutureResult
[16:17:45.206] - Received FutureResult
[16:17:45.206] - Erased future from FutureRegistry
[16:17:45.207] result() for ClusterFuture ...
[16:17:45.207] - result already collected: FutureResult
[16:17:45.207] result() for ClusterFuture ... done
[16:17:45.207] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:45.207] Future #2
[16:17:45.207] result() for ClusterFuture ...
[16:17:45.207] - result already collected: FutureResult
[16:17:45.207] result() for ClusterFuture ... done
[16:17:45.207] result() for ClusterFuture ...
[16:17:45.207] - result already collected: FutureResult
[16:17:45.208] result() for ClusterFuture ... done
[16:17:45.208] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:45.208] - nx: 2
[16:17:45.208] - relay: TRUE
[16:17:45.208] - stdout: TRUE
[16:17:45.208] - signal: TRUE
[16:17:45.208] - resignal: FALSE
[16:17:45.208] - force: TRUE
[16:17:45.208] - relayed: [n=2] TRUE, FALSE
[16:17:45.208] - queued futures: [n=2] TRUE, FALSE
[16:17:45.209]  - until=2
[16:17:45.209]  - relaying element #2
[16:17:45.209] result() for ClusterFuture ...
[16:17:45.209] - result already collected: FutureResult
[16:17:45.209] result() for ClusterFuture ... done
[16:17:45.209] result() for ClusterFuture ...
[16:17:45.209] - result already collected: FutureResult
[16:17:45.209] result() for ClusterFuture ... done
[16:17:45.209] result() for ClusterFuture ...
[16:17:45.209] - result already collected: FutureResult
[16:17:45.209] result() for ClusterFuture ... done
[16:17:45.210] result() for ClusterFuture ...
[16:17:45.210] - result already collected: FutureResult
[16:17:45.210] result() for ClusterFuture ... done
[16:17:45.210] - relayed: [n=2] TRUE, TRUE
[16:17:45.210] - queued futures: [n=2] TRUE, TRUE
[16:17:45.210] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:45.210]  length: 0 (resolved future 2)
[16:17:45.210] Relaying remaining futures
[16:17:45.210] signalConditionsASAP(NULL, pos=0) ...
[16:17:45.210] - nx: 2
[16:17:45.210] - relay: TRUE
[16:17:45.210] - stdout: TRUE
[16:17:45.211] - signal: TRUE
[16:17:45.211] - resignal: FALSE
[16:17:45.211] - force: TRUE
[16:17:45.211] - relayed: [n=2] TRUE, TRUE
[16:17:45.211] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:45.211] - relayed: [n=2] TRUE, TRUE
[16:17:45.211] - queued futures: [n=2] TRUE, TRUE
[16:17:45.211] signalConditionsASAP(NULL, pos=0) ... done
[16:17:45.211] resolve() on list ... DONE
[16:17:45.211] result() for ClusterFuture ...
[16:17:45.211] - result already collected: FutureResult
[16:17:45.212] result() for ClusterFuture ... done
[16:17:45.212] result() for ClusterFuture ...
[16:17:45.212] - result already collected: FutureResult
[16:17:45.212] result() for ClusterFuture ... done
[16:17:45.212] result() for ClusterFuture ...
[16:17:45.212] - result already collected: FutureResult
[16:17:45.212] result() for ClusterFuture ... done
[16:17:45.212] result() for ClusterFuture ...
[16:17:45.212] - result already collected: FutureResult
[16:17:45.212] result() for ClusterFuture ... done
[16:17:45.213]  - Number of value chunks collected: 2
[16:17:45.213] Resolving 2 futures (chunks) ... DONE
[16:17:45.213] Reducing values from 2 chunks ...
[16:17:45.213]  - Number of values collected after concatenation: 2
[16:17:45.213]  - Number of values expected: 2
[16:17:45.213] Reducing values from 2 chunks ... DONE
[16:17:45.213] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:17:45.213] getGlobalsAndPackagesXApply() ...
[16:17:45.213]  - future.globals: TRUE
[16:17:45.214] getGlobalsAndPackages() ...
[16:17:45.214] Searching for globals...
[16:17:45.215] - globals found: [1] ‘FUN’
[16:17:45.215] Searching for globals ... DONE
[16:17:45.215] Resolving globals: FALSE
[16:17:45.215] The total size of the 1 globals is 848 bytes (848 bytes)
[16:17:45.216] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:17:45.216] - globals: [1] ‘FUN’
[16:17:45.216] 
[16:17:45.216] getGlobalsAndPackages() ... DONE
[16:17:45.216]  - globals found/used: [n=1] ‘FUN’
[16:17:45.216]  - needed namespaces: [n=0] 
[16:17:45.216] Finding globals ... DONE
[16:17:45.216]  - use_args: TRUE
[16:17:45.217]  - Getting '...' globals ...
[16:17:45.217] resolve() on list ...
[16:17:45.217]  recursive: 0
[16:17:45.217]  length: 1
[16:17:45.217]  elements: ‘...’
[16:17:45.217]  length: 0 (resolved future 1)
[16:17:45.217] resolve() on list ... DONE
[16:17:45.217]    - '...' content: [n=0] 
[16:17:45.218] List of 1
[16:17:45.218]  $ ...: list()
[16:17:45.218]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.218]  - attr(*, "where")=List of 1
[16:17:45.218]   ..$ ...:<environment: 0x555be3fd6268> 
[16:17:45.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.218]  - attr(*, "resolved")= logi TRUE
[16:17:45.218]  - attr(*, "total_size")= num NA
[16:17:45.220]  - Getting '...' globals ... DONE
[16:17:45.220] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:45.220] List of 2
[16:17:45.220]  $ ...future.FUN:function (x)  
[16:17:45.220]  $ ...          : list()
[16:17:45.220]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.220]  - attr(*, "where")=List of 2
[16:17:45.220]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:45.220]   ..$ ...          :<environment: 0x555be3fd6268> 
[16:17:45.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.220]  - attr(*, "resolved")= logi FALSE
[16:17:45.220]  - attr(*, "total_size")= num 848
[16:17:45.223] Packages to be attached in all futures: [n=0] 
[16:17:45.223] getGlobalsAndPackagesXApply() ... DONE
[16:17:45.227] future_lapply() ...
[16:17:45.230] Number of chunks: 2
[16:17:45.230] getGlobalsAndPackagesXApply() ...
[16:17:45.231]  - future.globals: <name-value list> with names ‘list()’
[16:17:45.231]  - use_args: TRUE
[16:17:45.231] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:45.231] List of 2
[16:17:45.231]  $ ...          : list()
[16:17:45.231]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.231]  $ ...future.FUN:function (x)  
[16:17:45.231]  - attr(*, "where")=List of 2
[16:17:45.231]   ..$ ...          :<environment: 0x555be3fd6268> 
[16:17:45.231]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:45.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.231]  - attr(*, "resolved")= logi FALSE
[16:17:45.231]  - attr(*, "total_size")= num NA
[16:17:45.237] Packages to be attached in all futures: [n=0] 
[16:17:45.237] getGlobalsAndPackagesXApply() ... DONE
[16:17:45.237] Number of futures (= number of chunks): 2
[16:17:45.237] Launching 2 futures (chunks) ...
[16:17:45.237] Chunk #1 of 2 ...
[16:17:45.237]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:45.237]  - seeds: <none>
[16:17:45.237]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.237] getGlobalsAndPackages() ...
[16:17:45.238] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.238] Resolving globals: FALSE
[16:17:45.238] Tweak future expression to call with '...' arguments ...
[16:17:45.238] {
[16:17:45.238]     do.call(function(...) {
[16:17:45.238]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.238]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.238]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.238]             on.exit(options(oopts), add = TRUE)
[16:17:45.238]         }
[16:17:45.238]         {
[16:17:45.238]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.238]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.238]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.238]             })
[16:17:45.238]         }
[16:17:45.238]     }, args = future.call.arguments)
[16:17:45.238] }
[16:17:45.238] Tweak future expression to call with '...' arguments ... DONE
[16:17:45.239] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.239] 
[16:17:45.239] getGlobalsAndPackages() ... DONE
[16:17:45.239] run() for ‘Future’ ...
[16:17:45.239] - state: ‘created’
[16:17:45.239] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:45.253] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.253] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:45.253]   - Field: ‘node’
[16:17:45.253]   - Field: ‘label’
[16:17:45.253]   - Field: ‘local’
[16:17:45.253]   - Field: ‘owner’
[16:17:45.253]   - Field: ‘envir’
[16:17:45.254]   - Field: ‘workers’
[16:17:45.254]   - Field: ‘packages’
[16:17:45.254]   - Field: ‘gc’
[16:17:45.254]   - Field: ‘conditions’
[16:17:45.254]   - Field: ‘persistent’
[16:17:45.254]   - Field: ‘expr’
[16:17:45.254]   - Field: ‘uuid’
[16:17:45.254]   - Field: ‘seed’
[16:17:45.254]   - Field: ‘version’
[16:17:45.254]   - Field: ‘result’
[16:17:45.254]   - Field: ‘asynchronous’
[16:17:45.255]   - Field: ‘calls’
[16:17:45.255]   - Field: ‘globals’
[16:17:45.255]   - Field: ‘stdout’
[16:17:45.255]   - Field: ‘earlySignal’
[16:17:45.255]   - Field: ‘lazy’
[16:17:45.255]   - Field: ‘state’
[16:17:45.255] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:45.255] - Launch lazy future ...
[16:17:45.255] Packages needed by the future expression (n = 0): <none>
[16:17:45.256] Packages needed by future strategies (n = 0): <none>
[16:17:45.256] {
[16:17:45.256]     {
[16:17:45.256]         {
[16:17:45.256]             ...future.startTime <- base::Sys.time()
[16:17:45.256]             {
[16:17:45.256]                 {
[16:17:45.256]                   {
[16:17:45.256]                     {
[16:17:45.256]                       base::local({
[16:17:45.256]                         has_future <- base::requireNamespace("future", 
[16:17:45.256]                           quietly = TRUE)
[16:17:45.256]                         if (has_future) {
[16:17:45.256]                           ns <- base::getNamespace("future")
[16:17:45.256]                           version <- ns[[".package"]][["version"]]
[16:17:45.256]                           if (is.null(version)) 
[16:17:45.256]                             version <- utils::packageVersion("future")
[16:17:45.256]                         }
[16:17:45.256]                         else {
[16:17:45.256]                           version <- NULL
[16:17:45.256]                         }
[16:17:45.256]                         if (!has_future || version < "1.8.0") {
[16:17:45.256]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:45.256]                             "", base::R.version$version.string), 
[16:17:45.256]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:45.256]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:45.256]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:45.256]                               "release", "version")], collapse = " "), 
[16:17:45.256]                             hostname = base::Sys.info()[["nodename"]])
[16:17:45.256]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:45.256]                             info)
[16:17:45.256]                           info <- base::paste(info, collapse = "; ")
[16:17:45.256]                           if (!has_future) {
[16:17:45.256]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:45.256]                               info)
[16:17:45.256]                           }
[16:17:45.256]                           else {
[16:17:45.256]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:45.256]                               info, version)
[16:17:45.256]                           }
[16:17:45.256]                           base::stop(msg)
[16:17:45.256]                         }
[16:17:45.256]                       })
[16:17:45.256]                     }
[16:17:45.256]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:45.256]                     base::options(mc.cores = 1L)
[16:17:45.256]                   }
[16:17:45.256]                   ...future.strategy.old <- future::plan("list")
[16:17:45.256]                   options(future.plan = NULL)
[16:17:45.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:45.256]                 }
[16:17:45.256]                 ...future.workdir <- getwd()
[16:17:45.256]             }
[16:17:45.256]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:45.256]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:45.256]         }
[16:17:45.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:45.256]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:45.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:45.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:45.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:45.256]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:45.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:45.256]             base::names(...future.oldOptions))
[16:17:45.256]     }
[16:17:45.256]     if (FALSE) {
[16:17:45.256]     }
[16:17:45.256]     else {
[16:17:45.256]         if (TRUE) {
[16:17:45.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:45.256]                 open = "w")
[16:17:45.256]         }
[16:17:45.256]         else {
[16:17:45.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:45.256]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:45.256]         }
[16:17:45.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:45.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:45.256]             base::sink(type = "output", split = FALSE)
[16:17:45.256]             base::close(...future.stdout)
[16:17:45.256]         }, add = TRUE)
[16:17:45.256]     }
[16:17:45.256]     ...future.frame <- base::sys.nframe()
[16:17:45.256]     ...future.conditions <- base::list()
[16:17:45.256]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:45.256]     if (FALSE) {
[16:17:45.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:45.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:45.256]     }
[16:17:45.256]     ...future.result <- base::tryCatch({
[16:17:45.256]         base::withCallingHandlers({
[16:17:45.256]             ...future.value <- base::withVisible(base::local({
[16:17:45.256]                 ...future.makeSendCondition <- base::local({
[16:17:45.256]                   sendCondition <- NULL
[16:17:45.256]                   function(frame = 1L) {
[16:17:45.256]                     if (is.function(sendCondition)) 
[16:17:45.256]                       return(sendCondition)
[16:17:45.256]                     ns <- getNamespace("parallel")
[16:17:45.256]                     if (exists("sendData", mode = "function", 
[16:17:45.256]                       envir = ns)) {
[16:17:45.256]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:45.256]                         envir = ns)
[16:17:45.256]                       envir <- sys.frame(frame)
[16:17:45.256]                       master <- NULL
[16:17:45.256]                       while (!identical(envir, .GlobalEnv) && 
[16:17:45.256]                         !identical(envir, emptyenv())) {
[16:17:45.256]                         if (exists("master", mode = "list", envir = envir, 
[16:17:45.256]                           inherits = FALSE)) {
[16:17:45.256]                           master <- get("master", mode = "list", 
[16:17:45.256]                             envir = envir, inherits = FALSE)
[16:17:45.256]                           if (inherits(master, c("SOCKnode", 
[16:17:45.256]                             "SOCK0node"))) {
[16:17:45.256]                             sendCondition <<- function(cond) {
[16:17:45.256]                               data <- list(type = "VALUE", value = cond, 
[16:17:45.256]                                 success = TRUE)
[16:17:45.256]                               parallel_sendData(master, data)
[16:17:45.256]                             }
[16:17:45.256]                             return(sendCondition)
[16:17:45.256]                           }
[16:17:45.256]                         }
[16:17:45.256]                         frame <- frame + 1L
[16:17:45.256]                         envir <- sys.frame(frame)
[16:17:45.256]                       }
[16:17:45.256]                     }
[16:17:45.256]                     sendCondition <<- function(cond) NULL
[16:17:45.256]                   }
[16:17:45.256]                 })
[16:17:45.256]                 withCallingHandlers({
[16:17:45.256]                   {
[16:17:45.256]                     do.call(function(...) {
[16:17:45.256]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.256]                       if (!identical(...future.globals.maxSize.org, 
[16:17:45.256]                         ...future.globals.maxSize)) {
[16:17:45.256]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.256]                         on.exit(options(oopts), add = TRUE)
[16:17:45.256]                       }
[16:17:45.256]                       {
[16:17:45.256]                         lapply(seq_along(...future.elements_ii), 
[16:17:45.256]                           FUN = function(jj) {
[16:17:45.256]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.256]                             ...future.FUN(...future.X_jj, ...)
[16:17:45.256]                           })
[16:17:45.256]                       }
[16:17:45.256]                     }, args = future.call.arguments)
[16:17:45.256]                   }
[16:17:45.256]                 }, immediateCondition = function(cond) {
[16:17:45.256]                   sendCondition <- ...future.makeSendCondition()
[16:17:45.256]                   sendCondition(cond)
[16:17:45.256]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.256]                   {
[16:17:45.256]                     inherits <- base::inherits
[16:17:45.256]                     invokeRestart <- base::invokeRestart
[16:17:45.256]                     is.null <- base::is.null
[16:17:45.256]                     muffled <- FALSE
[16:17:45.256]                     if (inherits(cond, "message")) {
[16:17:45.256]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:45.256]                       if (muffled) 
[16:17:45.256]                         invokeRestart("muffleMessage")
[16:17:45.256]                     }
[16:17:45.256]                     else if (inherits(cond, "warning")) {
[16:17:45.256]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:45.256]                       if (muffled) 
[16:17:45.256]                         invokeRestart("muffleWarning")
[16:17:45.256]                     }
[16:17:45.256]                     else if (inherits(cond, "condition")) {
[16:17:45.256]                       if (!is.null(pattern)) {
[16:17:45.256]                         computeRestarts <- base::computeRestarts
[16:17:45.256]                         grepl <- base::grepl
[16:17:45.256]                         restarts <- computeRestarts(cond)
[16:17:45.256]                         for (restart in restarts) {
[16:17:45.256]                           name <- restart$name
[16:17:45.256]                           if (is.null(name)) 
[16:17:45.256]                             next
[16:17:45.256]                           if (!grepl(pattern, name)) 
[16:17:45.256]                             next
[16:17:45.256]                           invokeRestart(restart)
[16:17:45.256]                           muffled <- TRUE
[16:17:45.256]                           break
[16:17:45.256]                         }
[16:17:45.256]                       }
[16:17:45.256]                     }
[16:17:45.256]                     invisible(muffled)
[16:17:45.256]                   }
[16:17:45.256]                   muffleCondition(cond)
[16:17:45.256]                 })
[16:17:45.256]             }))
[16:17:45.256]             future::FutureResult(value = ...future.value$value, 
[16:17:45.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.256]                   ...future.rng), globalenv = if (FALSE) 
[16:17:45.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:45.256]                     ...future.globalenv.names))
[16:17:45.256]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:45.256]         }, condition = base::local({
[16:17:45.256]             c <- base::c
[16:17:45.256]             inherits <- base::inherits
[16:17:45.256]             invokeRestart <- base::invokeRestart
[16:17:45.256]             length <- base::length
[16:17:45.256]             list <- base::list
[16:17:45.256]             seq.int <- base::seq.int
[16:17:45.256]             signalCondition <- base::signalCondition
[16:17:45.256]             sys.calls <- base::sys.calls
[16:17:45.256]             `[[` <- base::`[[`
[16:17:45.256]             `+` <- base::`+`
[16:17:45.256]             `<<-` <- base::`<<-`
[16:17:45.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:45.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:45.256]                   3L)]
[16:17:45.256]             }
[16:17:45.256]             function(cond) {
[16:17:45.256]                 is_error <- inherits(cond, "error")
[16:17:45.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:45.256]                   NULL)
[16:17:45.256]                 if (is_error) {
[16:17:45.256]                   sessionInformation <- function() {
[16:17:45.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:45.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:45.256]                       search = base::search(), system = base::Sys.info())
[16:17:45.256]                   }
[16:17:45.256]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:45.256]                     cond$call), session = sessionInformation(), 
[16:17:45.256]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:45.256]                   signalCondition(cond)
[16:17:45.256]                 }
[16:17:45.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:45.256]                 "immediateCondition"))) {
[16:17:45.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:45.256]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:45.256]                   if (TRUE && !signal) {
[16:17:45.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.256]                     {
[16:17:45.256]                       inherits <- base::inherits
[16:17:45.256]                       invokeRestart <- base::invokeRestart
[16:17:45.256]                       is.null <- base::is.null
[16:17:45.256]                       muffled <- FALSE
[16:17:45.256]                       if (inherits(cond, "message")) {
[16:17:45.256]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.256]                         if (muffled) 
[16:17:45.256]                           invokeRestart("muffleMessage")
[16:17:45.256]                       }
[16:17:45.256]                       else if (inherits(cond, "warning")) {
[16:17:45.256]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.256]                         if (muffled) 
[16:17:45.256]                           invokeRestart("muffleWarning")
[16:17:45.256]                       }
[16:17:45.256]                       else if (inherits(cond, "condition")) {
[16:17:45.256]                         if (!is.null(pattern)) {
[16:17:45.256]                           computeRestarts <- base::computeRestarts
[16:17:45.256]                           grepl <- base::grepl
[16:17:45.256]                           restarts <- computeRestarts(cond)
[16:17:45.256]                           for (restart in restarts) {
[16:17:45.256]                             name <- restart$name
[16:17:45.256]                             if (is.null(name)) 
[16:17:45.256]                               next
[16:17:45.256]                             if (!grepl(pattern, name)) 
[16:17:45.256]                               next
[16:17:45.256]                             invokeRestart(restart)
[16:17:45.256]                             muffled <- TRUE
[16:17:45.256]                             break
[16:17:45.256]                           }
[16:17:45.256]                         }
[16:17:45.256]                       }
[16:17:45.256]                       invisible(muffled)
[16:17:45.256]                     }
[16:17:45.256]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.256]                   }
[16:17:45.256]                 }
[16:17:45.256]                 else {
[16:17:45.256]                   if (TRUE) {
[16:17:45.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.256]                     {
[16:17:45.256]                       inherits <- base::inherits
[16:17:45.256]                       invokeRestart <- base::invokeRestart
[16:17:45.256]                       is.null <- base::is.null
[16:17:45.256]                       muffled <- FALSE
[16:17:45.256]                       if (inherits(cond, "message")) {
[16:17:45.256]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.256]                         if (muffled) 
[16:17:45.256]                           invokeRestart("muffleMessage")
[16:17:45.256]                       }
[16:17:45.256]                       else if (inherits(cond, "warning")) {
[16:17:45.256]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.256]                         if (muffled) 
[16:17:45.256]                           invokeRestart("muffleWarning")
[16:17:45.256]                       }
[16:17:45.256]                       else if (inherits(cond, "condition")) {
[16:17:45.256]                         if (!is.null(pattern)) {
[16:17:45.256]                           computeRestarts <- base::computeRestarts
[16:17:45.256]                           grepl <- base::grepl
[16:17:45.256]                           restarts <- computeRestarts(cond)
[16:17:45.256]                           for (restart in restarts) {
[16:17:45.256]                             name <- restart$name
[16:17:45.256]                             if (is.null(name)) 
[16:17:45.256]                               next
[16:17:45.256]                             if (!grepl(pattern, name)) 
[16:17:45.256]                               next
[16:17:45.256]                             invokeRestart(restart)
[16:17:45.256]                             muffled <- TRUE
[16:17:45.256]                             break
[16:17:45.256]                           }
[16:17:45.256]                         }
[16:17:45.256]                       }
[16:17:45.256]                       invisible(muffled)
[16:17:45.256]                     }
[16:17:45.256]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.256]                   }
[16:17:45.256]                 }
[16:17:45.256]             }
[16:17:45.256]         }))
[16:17:45.256]     }, error = function(ex) {
[16:17:45.256]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:45.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.256]                 ...future.rng), started = ...future.startTime, 
[16:17:45.256]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:45.256]             version = "1.8"), class = "FutureResult")
[16:17:45.256]     }, finally = {
[16:17:45.256]         if (!identical(...future.workdir, getwd())) 
[16:17:45.256]             setwd(...future.workdir)
[16:17:45.256]         {
[16:17:45.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:45.256]                 ...future.oldOptions$nwarnings <- NULL
[16:17:45.256]             }
[16:17:45.256]             base::options(...future.oldOptions)
[16:17:45.256]             if (.Platform$OS.type == "windows") {
[16:17:45.256]                 old_names <- names(...future.oldEnvVars)
[16:17:45.256]                 envs <- base::Sys.getenv()
[16:17:45.256]                 names <- names(envs)
[16:17:45.256]                 common <- intersect(names, old_names)
[16:17:45.256]                 added <- setdiff(names, old_names)
[16:17:45.256]                 removed <- setdiff(old_names, names)
[16:17:45.256]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:45.256]                   envs[common]]
[16:17:45.256]                 NAMES <- toupper(changed)
[16:17:45.256]                 args <- list()
[16:17:45.256]                 for (kk in seq_along(NAMES)) {
[16:17:45.256]                   name <- changed[[kk]]
[16:17:45.256]                   NAME <- NAMES[[kk]]
[16:17:45.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.256]                     next
[16:17:45.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.256]                 }
[16:17:45.256]                 NAMES <- toupper(added)
[16:17:45.256]                 for (kk in seq_along(NAMES)) {
[16:17:45.256]                   name <- added[[kk]]
[16:17:45.256]                   NAME <- NAMES[[kk]]
[16:17:45.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.256]                     next
[16:17:45.256]                   args[[name]] <- ""
[16:17:45.256]                 }
[16:17:45.256]                 NAMES <- toupper(removed)
[16:17:45.256]                 for (kk in seq_along(NAMES)) {
[16:17:45.256]                   name <- removed[[kk]]
[16:17:45.256]                   NAME <- NAMES[[kk]]
[16:17:45.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.256]                     next
[16:17:45.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.256]                 }
[16:17:45.256]                 if (length(args) > 0) 
[16:17:45.256]                   base::do.call(base::Sys.setenv, args = args)
[16:17:45.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:45.256]             }
[16:17:45.256]             else {
[16:17:45.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:45.256]             }
[16:17:45.256]             {
[16:17:45.256]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:45.256]                   0L) {
[16:17:45.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:45.256]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:45.256]                   base::options(opts)
[16:17:45.256]                 }
[16:17:45.256]                 {
[16:17:45.256]                   {
[16:17:45.256]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:45.256]                     NULL
[16:17:45.256]                   }
[16:17:45.256]                   options(future.plan = NULL)
[16:17:45.256]                   if (is.na(NA_character_)) 
[16:17:45.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:45.256]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:45.256]                     .init = FALSE)
[16:17:45.256]                 }
[16:17:45.256]             }
[16:17:45.256]         }
[16:17:45.256]     })
[16:17:45.256]     if (TRUE) {
[16:17:45.256]         base::sink(type = "output", split = FALSE)
[16:17:45.256]         if (TRUE) {
[16:17:45.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:45.256]         }
[16:17:45.256]         else {
[16:17:45.256]             ...future.result["stdout"] <- base::list(NULL)
[16:17:45.256]         }
[16:17:45.256]         base::close(...future.stdout)
[16:17:45.256]         ...future.stdout <- NULL
[16:17:45.256]     }
[16:17:45.256]     ...future.result$conditions <- ...future.conditions
[16:17:45.256]     ...future.result$finished <- base::Sys.time()
[16:17:45.256]     ...future.result
[16:17:45.256] }
[16:17:45.259] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[16:17:45.259] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:45.260] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:45.260] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:17:45.260] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:17:45.260] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[16:17:45.261] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[16:17:45.261] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:45.261] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:45.261] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:17:45.262] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:17:45.262] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[16:17:45.262] MultisessionFuture started
[16:17:45.262] - Launch lazy future ... done
[16:17:45.262] run() for ‘MultisessionFuture’ ... done
[16:17:45.262] Created future:
[16:17:45.263] MultisessionFuture:
[16:17:45.263] Label: ‘future_apply-1’
[16:17:45.263] Expression:
[16:17:45.263] {
[16:17:45.263]     do.call(function(...) {
[16:17:45.263]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.263]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.263]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.263]             on.exit(options(oopts), add = TRUE)
[16:17:45.263]         }
[16:17:45.263]         {
[16:17:45.263]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.263]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.263]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.263]             })
[16:17:45.263]         }
[16:17:45.263]     }, args = future.call.arguments)
[16:17:45.263] }
[16:17:45.263] Lazy evaluation: FALSE
[16:17:45.263] Asynchronous evaluation: TRUE
[16:17:45.263] Local evaluation: TRUE
[16:17:45.263] Environment: R_GlobalEnv
[16:17:45.263] Capture standard output: TRUE
[16:17:45.263] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:45.263] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:45.263] Packages: <none>
[16:17:45.263] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:45.263] Resolved: FALSE
[16:17:45.263] Value: <not collected>
[16:17:45.263] Conditions captured: <none>
[16:17:45.263] Early signaling: FALSE
[16:17:45.263] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:45.263] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.274] Chunk #1 of 2 ... DONE
[16:17:45.274] Chunk #2 of 2 ...
[16:17:45.274]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:45.274]  - seeds: <none>
[16:17:45.275]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.275] getGlobalsAndPackages() ...
[16:17:45.275] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.275] Resolving globals: FALSE
[16:17:45.275] Tweak future expression to call with '...' arguments ...
[16:17:45.275] {
[16:17:45.275]     do.call(function(...) {
[16:17:45.275]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.275]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.275]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.275]             on.exit(options(oopts), add = TRUE)
[16:17:45.275]         }
[16:17:45.275]         {
[16:17:45.275]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.275]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.275]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.275]             })
[16:17:45.275]         }
[16:17:45.275]     }, args = future.call.arguments)
[16:17:45.275] }
[16:17:45.275] Tweak future expression to call with '...' arguments ... DONE
[16:17:45.276] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.276] 
[16:17:45.276] getGlobalsAndPackages() ... DONE
[16:17:45.276] run() for ‘Future’ ...
[16:17:45.276] - state: ‘created’
[16:17:45.277] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:45.292] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:45.292]   - Field: ‘node’
[16:17:45.292]   - Field: ‘label’
[16:17:45.292]   - Field: ‘local’
[16:17:45.292]   - Field: ‘owner’
[16:17:45.292]   - Field: ‘envir’
[16:17:45.293]   - Field: ‘workers’
[16:17:45.293]   - Field: ‘packages’
[16:17:45.293]   - Field: ‘gc’
[16:17:45.293]   - Field: ‘conditions’
[16:17:45.293]   - Field: ‘persistent’
[16:17:45.293]   - Field: ‘expr’
[16:17:45.293]   - Field: ‘uuid’
[16:17:45.293]   - Field: ‘seed’
[16:17:45.293]   - Field: ‘version’
[16:17:45.293]   - Field: ‘result’
[16:17:45.293]   - Field: ‘asynchronous’
[16:17:45.294]   - Field: ‘calls’
[16:17:45.294]   - Field: ‘globals’
[16:17:45.294]   - Field: ‘stdout’
[16:17:45.294]   - Field: ‘earlySignal’
[16:17:45.294]   - Field: ‘lazy’
[16:17:45.294]   - Field: ‘state’
[16:17:45.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:45.294] - Launch lazy future ...
[16:17:45.294] Packages needed by the future expression (n = 0): <none>
[16:17:45.295] Packages needed by future strategies (n = 0): <none>
[16:17:45.295] {
[16:17:45.295]     {
[16:17:45.295]         {
[16:17:45.295]             ...future.startTime <- base::Sys.time()
[16:17:45.295]             {
[16:17:45.295]                 {
[16:17:45.295]                   {
[16:17:45.295]                     {
[16:17:45.295]                       base::local({
[16:17:45.295]                         has_future <- base::requireNamespace("future", 
[16:17:45.295]                           quietly = TRUE)
[16:17:45.295]                         if (has_future) {
[16:17:45.295]                           ns <- base::getNamespace("future")
[16:17:45.295]                           version <- ns[[".package"]][["version"]]
[16:17:45.295]                           if (is.null(version)) 
[16:17:45.295]                             version <- utils::packageVersion("future")
[16:17:45.295]                         }
[16:17:45.295]                         else {
[16:17:45.295]                           version <- NULL
[16:17:45.295]                         }
[16:17:45.295]                         if (!has_future || version < "1.8.0") {
[16:17:45.295]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:45.295]                             "", base::R.version$version.string), 
[16:17:45.295]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:45.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:45.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:45.295]                               "release", "version")], collapse = " "), 
[16:17:45.295]                             hostname = base::Sys.info()[["nodename"]])
[16:17:45.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:45.295]                             info)
[16:17:45.295]                           info <- base::paste(info, collapse = "; ")
[16:17:45.295]                           if (!has_future) {
[16:17:45.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:45.295]                               info)
[16:17:45.295]                           }
[16:17:45.295]                           else {
[16:17:45.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:45.295]                               info, version)
[16:17:45.295]                           }
[16:17:45.295]                           base::stop(msg)
[16:17:45.295]                         }
[16:17:45.295]                       })
[16:17:45.295]                     }
[16:17:45.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:45.295]                     base::options(mc.cores = 1L)
[16:17:45.295]                   }
[16:17:45.295]                   ...future.strategy.old <- future::plan("list")
[16:17:45.295]                   options(future.plan = NULL)
[16:17:45.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:45.295]                 }
[16:17:45.295]                 ...future.workdir <- getwd()
[16:17:45.295]             }
[16:17:45.295]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:45.295]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:45.295]         }
[16:17:45.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:45.295]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:45.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:45.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:45.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:45.295]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:45.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:45.295]             base::names(...future.oldOptions))
[16:17:45.295]     }
[16:17:45.295]     if (FALSE) {
[16:17:45.295]     }
[16:17:45.295]     else {
[16:17:45.295]         if (TRUE) {
[16:17:45.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:45.295]                 open = "w")
[16:17:45.295]         }
[16:17:45.295]         else {
[16:17:45.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:45.295]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:45.295]         }
[16:17:45.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:45.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:45.295]             base::sink(type = "output", split = FALSE)
[16:17:45.295]             base::close(...future.stdout)
[16:17:45.295]         }, add = TRUE)
[16:17:45.295]     }
[16:17:45.295]     ...future.frame <- base::sys.nframe()
[16:17:45.295]     ...future.conditions <- base::list()
[16:17:45.295]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:45.295]     if (FALSE) {
[16:17:45.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:45.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:45.295]     }
[16:17:45.295]     ...future.result <- base::tryCatch({
[16:17:45.295]         base::withCallingHandlers({
[16:17:45.295]             ...future.value <- base::withVisible(base::local({
[16:17:45.295]                 ...future.makeSendCondition <- base::local({
[16:17:45.295]                   sendCondition <- NULL
[16:17:45.295]                   function(frame = 1L) {
[16:17:45.295]                     if (is.function(sendCondition)) 
[16:17:45.295]                       return(sendCondition)
[16:17:45.295]                     ns <- getNamespace("parallel")
[16:17:45.295]                     if (exists("sendData", mode = "function", 
[16:17:45.295]                       envir = ns)) {
[16:17:45.295]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:45.295]                         envir = ns)
[16:17:45.295]                       envir <- sys.frame(frame)
[16:17:45.295]                       master <- NULL
[16:17:45.295]                       while (!identical(envir, .GlobalEnv) && 
[16:17:45.295]                         !identical(envir, emptyenv())) {
[16:17:45.295]                         if (exists("master", mode = "list", envir = envir, 
[16:17:45.295]                           inherits = FALSE)) {
[16:17:45.295]                           master <- get("master", mode = "list", 
[16:17:45.295]                             envir = envir, inherits = FALSE)
[16:17:45.295]                           if (inherits(master, c("SOCKnode", 
[16:17:45.295]                             "SOCK0node"))) {
[16:17:45.295]                             sendCondition <<- function(cond) {
[16:17:45.295]                               data <- list(type = "VALUE", value = cond, 
[16:17:45.295]                                 success = TRUE)
[16:17:45.295]                               parallel_sendData(master, data)
[16:17:45.295]                             }
[16:17:45.295]                             return(sendCondition)
[16:17:45.295]                           }
[16:17:45.295]                         }
[16:17:45.295]                         frame <- frame + 1L
[16:17:45.295]                         envir <- sys.frame(frame)
[16:17:45.295]                       }
[16:17:45.295]                     }
[16:17:45.295]                     sendCondition <<- function(cond) NULL
[16:17:45.295]                   }
[16:17:45.295]                 })
[16:17:45.295]                 withCallingHandlers({
[16:17:45.295]                   {
[16:17:45.295]                     do.call(function(...) {
[16:17:45.295]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.295]                       if (!identical(...future.globals.maxSize.org, 
[16:17:45.295]                         ...future.globals.maxSize)) {
[16:17:45.295]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.295]                         on.exit(options(oopts), add = TRUE)
[16:17:45.295]                       }
[16:17:45.295]                       {
[16:17:45.295]                         lapply(seq_along(...future.elements_ii), 
[16:17:45.295]                           FUN = function(jj) {
[16:17:45.295]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.295]                             ...future.FUN(...future.X_jj, ...)
[16:17:45.295]                           })
[16:17:45.295]                       }
[16:17:45.295]                     }, args = future.call.arguments)
[16:17:45.295]                   }
[16:17:45.295]                 }, immediateCondition = function(cond) {
[16:17:45.295]                   sendCondition <- ...future.makeSendCondition()
[16:17:45.295]                   sendCondition(cond)
[16:17:45.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.295]                   {
[16:17:45.295]                     inherits <- base::inherits
[16:17:45.295]                     invokeRestart <- base::invokeRestart
[16:17:45.295]                     is.null <- base::is.null
[16:17:45.295]                     muffled <- FALSE
[16:17:45.295]                     if (inherits(cond, "message")) {
[16:17:45.295]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:45.295]                       if (muffled) 
[16:17:45.295]                         invokeRestart("muffleMessage")
[16:17:45.295]                     }
[16:17:45.295]                     else if (inherits(cond, "warning")) {
[16:17:45.295]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:45.295]                       if (muffled) 
[16:17:45.295]                         invokeRestart("muffleWarning")
[16:17:45.295]                     }
[16:17:45.295]                     else if (inherits(cond, "condition")) {
[16:17:45.295]                       if (!is.null(pattern)) {
[16:17:45.295]                         computeRestarts <- base::computeRestarts
[16:17:45.295]                         grepl <- base::grepl
[16:17:45.295]                         restarts <- computeRestarts(cond)
[16:17:45.295]                         for (restart in restarts) {
[16:17:45.295]                           name <- restart$name
[16:17:45.295]                           if (is.null(name)) 
[16:17:45.295]                             next
[16:17:45.295]                           if (!grepl(pattern, name)) 
[16:17:45.295]                             next
[16:17:45.295]                           invokeRestart(restart)
[16:17:45.295]                           muffled <- TRUE
[16:17:45.295]                           break
[16:17:45.295]                         }
[16:17:45.295]                       }
[16:17:45.295]                     }
[16:17:45.295]                     invisible(muffled)
[16:17:45.295]                   }
[16:17:45.295]                   muffleCondition(cond)
[16:17:45.295]                 })
[16:17:45.295]             }))
[16:17:45.295]             future::FutureResult(value = ...future.value$value, 
[16:17:45.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.295]                   ...future.rng), globalenv = if (FALSE) 
[16:17:45.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:45.295]                     ...future.globalenv.names))
[16:17:45.295]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:45.295]         }, condition = base::local({
[16:17:45.295]             c <- base::c
[16:17:45.295]             inherits <- base::inherits
[16:17:45.295]             invokeRestart <- base::invokeRestart
[16:17:45.295]             length <- base::length
[16:17:45.295]             list <- base::list
[16:17:45.295]             seq.int <- base::seq.int
[16:17:45.295]             signalCondition <- base::signalCondition
[16:17:45.295]             sys.calls <- base::sys.calls
[16:17:45.295]             `[[` <- base::`[[`
[16:17:45.295]             `+` <- base::`+`
[16:17:45.295]             `<<-` <- base::`<<-`
[16:17:45.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:45.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:45.295]                   3L)]
[16:17:45.295]             }
[16:17:45.295]             function(cond) {
[16:17:45.295]                 is_error <- inherits(cond, "error")
[16:17:45.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:45.295]                   NULL)
[16:17:45.295]                 if (is_error) {
[16:17:45.295]                   sessionInformation <- function() {
[16:17:45.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:45.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:45.295]                       search = base::search(), system = base::Sys.info())
[16:17:45.295]                   }
[16:17:45.295]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:45.295]                     cond$call), session = sessionInformation(), 
[16:17:45.295]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:45.295]                   signalCondition(cond)
[16:17:45.295]                 }
[16:17:45.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:45.295]                 "immediateCondition"))) {
[16:17:45.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:45.295]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:45.295]                   if (TRUE && !signal) {
[16:17:45.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.295]                     {
[16:17:45.295]                       inherits <- base::inherits
[16:17:45.295]                       invokeRestart <- base::invokeRestart
[16:17:45.295]                       is.null <- base::is.null
[16:17:45.295]                       muffled <- FALSE
[16:17:45.295]                       if (inherits(cond, "message")) {
[16:17:45.295]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.295]                         if (muffled) 
[16:17:45.295]                           invokeRestart("muffleMessage")
[16:17:45.295]                       }
[16:17:45.295]                       else if (inherits(cond, "warning")) {
[16:17:45.295]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.295]                         if (muffled) 
[16:17:45.295]                           invokeRestart("muffleWarning")
[16:17:45.295]                       }
[16:17:45.295]                       else if (inherits(cond, "condition")) {
[16:17:45.295]                         if (!is.null(pattern)) {
[16:17:45.295]                           computeRestarts <- base::computeRestarts
[16:17:45.295]                           grepl <- base::grepl
[16:17:45.295]                           restarts <- computeRestarts(cond)
[16:17:45.295]                           for (restart in restarts) {
[16:17:45.295]                             name <- restart$name
[16:17:45.295]                             if (is.null(name)) 
[16:17:45.295]                               next
[16:17:45.295]                             if (!grepl(pattern, name)) 
[16:17:45.295]                               next
[16:17:45.295]                             invokeRestart(restart)
[16:17:45.295]                             muffled <- TRUE
[16:17:45.295]                             break
[16:17:45.295]                           }
[16:17:45.295]                         }
[16:17:45.295]                       }
[16:17:45.295]                       invisible(muffled)
[16:17:45.295]                     }
[16:17:45.295]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.295]                   }
[16:17:45.295]                 }
[16:17:45.295]                 else {
[16:17:45.295]                   if (TRUE) {
[16:17:45.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.295]                     {
[16:17:45.295]                       inherits <- base::inherits
[16:17:45.295]                       invokeRestart <- base::invokeRestart
[16:17:45.295]                       is.null <- base::is.null
[16:17:45.295]                       muffled <- FALSE
[16:17:45.295]                       if (inherits(cond, "message")) {
[16:17:45.295]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.295]                         if (muffled) 
[16:17:45.295]                           invokeRestart("muffleMessage")
[16:17:45.295]                       }
[16:17:45.295]                       else if (inherits(cond, "warning")) {
[16:17:45.295]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.295]                         if (muffled) 
[16:17:45.295]                           invokeRestart("muffleWarning")
[16:17:45.295]                       }
[16:17:45.295]                       else if (inherits(cond, "condition")) {
[16:17:45.295]                         if (!is.null(pattern)) {
[16:17:45.295]                           computeRestarts <- base::computeRestarts
[16:17:45.295]                           grepl <- base::grepl
[16:17:45.295]                           restarts <- computeRestarts(cond)
[16:17:45.295]                           for (restart in restarts) {
[16:17:45.295]                             name <- restart$name
[16:17:45.295]                             if (is.null(name)) 
[16:17:45.295]                               next
[16:17:45.295]                             if (!grepl(pattern, name)) 
[16:17:45.295]                               next
[16:17:45.295]                             invokeRestart(restart)
[16:17:45.295]                             muffled <- TRUE
[16:17:45.295]                             break
[16:17:45.295]                           }
[16:17:45.295]                         }
[16:17:45.295]                       }
[16:17:45.295]                       invisible(muffled)
[16:17:45.295]                     }
[16:17:45.295]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.295]                   }
[16:17:45.295]                 }
[16:17:45.295]             }
[16:17:45.295]         }))
[16:17:45.295]     }, error = function(ex) {
[16:17:45.295]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:45.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.295]                 ...future.rng), started = ...future.startTime, 
[16:17:45.295]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:45.295]             version = "1.8"), class = "FutureResult")
[16:17:45.295]     }, finally = {
[16:17:45.295]         if (!identical(...future.workdir, getwd())) 
[16:17:45.295]             setwd(...future.workdir)
[16:17:45.295]         {
[16:17:45.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:45.295]                 ...future.oldOptions$nwarnings <- NULL
[16:17:45.295]             }
[16:17:45.295]             base::options(...future.oldOptions)
[16:17:45.295]             if (.Platform$OS.type == "windows") {
[16:17:45.295]                 old_names <- names(...future.oldEnvVars)
[16:17:45.295]                 envs <- base::Sys.getenv()
[16:17:45.295]                 names <- names(envs)
[16:17:45.295]                 common <- intersect(names, old_names)
[16:17:45.295]                 added <- setdiff(names, old_names)
[16:17:45.295]                 removed <- setdiff(old_names, names)
[16:17:45.295]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:45.295]                   envs[common]]
[16:17:45.295]                 NAMES <- toupper(changed)
[16:17:45.295]                 args <- list()
[16:17:45.295]                 for (kk in seq_along(NAMES)) {
[16:17:45.295]                   name <- changed[[kk]]
[16:17:45.295]                   NAME <- NAMES[[kk]]
[16:17:45.295]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.295]                     next
[16:17:45.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.295]                 }
[16:17:45.295]                 NAMES <- toupper(added)
[16:17:45.295]                 for (kk in seq_along(NAMES)) {
[16:17:45.295]                   name <- added[[kk]]
[16:17:45.295]                   NAME <- NAMES[[kk]]
[16:17:45.295]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.295]                     next
[16:17:45.295]                   args[[name]] <- ""
[16:17:45.295]                 }
[16:17:45.295]                 NAMES <- toupper(removed)
[16:17:45.295]                 for (kk in seq_along(NAMES)) {
[16:17:45.295]                   name <- removed[[kk]]
[16:17:45.295]                   NAME <- NAMES[[kk]]
[16:17:45.295]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.295]                     next
[16:17:45.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.295]                 }
[16:17:45.295]                 if (length(args) > 0) 
[16:17:45.295]                   base::do.call(base::Sys.setenv, args = args)
[16:17:45.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:45.295]             }
[16:17:45.295]             else {
[16:17:45.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:45.295]             }
[16:17:45.295]             {
[16:17:45.295]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:45.295]                   0L) {
[16:17:45.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:45.295]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:45.295]                   base::options(opts)
[16:17:45.295]                 }
[16:17:45.295]                 {
[16:17:45.295]                   {
[16:17:45.295]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:45.295]                     NULL
[16:17:45.295]                   }
[16:17:45.295]                   options(future.plan = NULL)
[16:17:45.295]                   if (is.na(NA_character_)) 
[16:17:45.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:45.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:45.295]                     .init = FALSE)
[16:17:45.295]                 }
[16:17:45.295]             }
[16:17:45.295]         }
[16:17:45.295]     })
[16:17:45.295]     if (TRUE) {
[16:17:45.295]         base::sink(type = "output", split = FALSE)
[16:17:45.295]         if (TRUE) {
[16:17:45.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:45.295]         }
[16:17:45.295]         else {
[16:17:45.295]             ...future.result["stdout"] <- base::list(NULL)
[16:17:45.295]         }
[16:17:45.295]         base::close(...future.stdout)
[16:17:45.295]         ...future.stdout <- NULL
[16:17:45.295]     }
[16:17:45.295]     ...future.result$conditions <- ...future.conditions
[16:17:45.295]     ...future.result$finished <- base::Sys.time()
[16:17:45.295]     ...future.result
[16:17:45.295] }
[16:17:45.298] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[16:17:45.299] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:45.299] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:45.299] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:17:45.299] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:17:45.300] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[16:17:45.300] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[16:17:45.300] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:45.301] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:45.301] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:17:45.301] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:17:45.301] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[16:17:45.302] MultisessionFuture started
[16:17:45.302] - Launch lazy future ... done
[16:17:45.302] run() for ‘MultisessionFuture’ ... done
[16:17:45.302] Created future:
[16:17:45.302] MultisessionFuture:
[16:17:45.302] Label: ‘future_apply-2’
[16:17:45.302] Expression:
[16:17:45.302] {
[16:17:45.302]     do.call(function(...) {
[16:17:45.302]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.302]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.302]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.302]             on.exit(options(oopts), add = TRUE)
[16:17:45.302]         }
[16:17:45.302]         {
[16:17:45.302]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.302]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.302]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.302]             })
[16:17:45.302]         }
[16:17:45.302]     }, args = future.call.arguments)
[16:17:45.302] }
[16:17:45.302] Lazy evaluation: FALSE
[16:17:45.302] Asynchronous evaluation: TRUE
[16:17:45.302] Local evaluation: TRUE
[16:17:45.302] Environment: R_GlobalEnv
[16:17:45.302] Capture standard output: TRUE
[16:17:45.302] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:45.302] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:45.302] Packages: <none>
[16:17:45.302] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:45.302] Resolved: FALSE
[16:17:45.302] Value: <not collected>
[16:17:45.302] Conditions captured: <none>
[16:17:45.302] Early signaling: FALSE
[16:17:45.302] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:45.302] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.314] Chunk #2 of 2 ... DONE
[16:17:45.314] Launching 2 futures (chunks) ... DONE
[16:17:45.314] Resolving 2 futures (chunks) ...
[16:17:45.314] resolve() on list ...
[16:17:45.314]  recursive: 0
[16:17:45.314]  length: 2
[16:17:45.314] 
[16:17:45.315] receiveMessageFromWorker() for ClusterFuture ...
[16:17:45.315] - Validating connection of MultisessionFuture
[16:17:45.315] - received message: FutureResult
[16:17:45.315] - Received FutureResult
[16:17:45.315] - Erased future from FutureRegistry
[16:17:45.316] result() for ClusterFuture ...
[16:17:45.316] - result already collected: FutureResult
[16:17:45.316] result() for ClusterFuture ... done
[16:17:45.316] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:45.316] Future #1
[16:17:45.316] result() for ClusterFuture ...
[16:17:45.316] - result already collected: FutureResult
[16:17:45.316] result() for ClusterFuture ... done
[16:17:45.316] result() for ClusterFuture ...
[16:17:45.316] - result already collected: FutureResult
[16:17:45.316] result() for ClusterFuture ... done
[16:17:45.317] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:45.317] - nx: 2
[16:17:45.317] - relay: TRUE
[16:17:45.317] - stdout: TRUE
[16:17:45.317] - signal: TRUE
[16:17:45.317] - resignal: FALSE
[16:17:45.317] - force: TRUE
[16:17:45.317] - relayed: [n=2] FALSE, FALSE
[16:17:45.317] - queued futures: [n=2] FALSE, FALSE
[16:17:45.317]  - until=1
[16:17:45.317]  - relaying element #1
[16:17:45.318] result() for ClusterFuture ...
[16:17:45.318] - result already collected: FutureResult
[16:17:45.318] result() for ClusterFuture ... done
[16:17:45.318] result() for ClusterFuture ...
[16:17:45.318] - result already collected: FutureResult
[16:17:45.318] result() for ClusterFuture ... done
[16:17:45.318] result() for ClusterFuture ...
[16:17:45.318] - result already collected: FutureResult
[16:17:45.318] result() for ClusterFuture ... done
[16:17:45.318] result() for ClusterFuture ...
[16:17:45.318] - result already collected: FutureResult
[16:17:45.319] result() for ClusterFuture ... done
[16:17:45.319] - relayed: [n=2] TRUE, FALSE
[16:17:45.319] - queued futures: [n=2] TRUE, FALSE
[16:17:45.319] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:45.319]  length: 1 (resolved future 1)
[16:17:45.346] receiveMessageFromWorker() for ClusterFuture ...
[16:17:45.346] - Validating connection of MultisessionFuture
[16:17:45.346] - received message: FutureResult
[16:17:45.346] - Received FutureResult
[16:17:45.346] - Erased future from FutureRegistry
[16:17:45.347] result() for ClusterFuture ...
[16:17:45.347] - result already collected: FutureResult
[16:17:45.347] result() for ClusterFuture ... done
[16:17:45.347] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:45.347] Future #2
[16:17:45.347] result() for ClusterFuture ...
[16:17:45.347] - result already collected: FutureResult
[16:17:45.347] result() for ClusterFuture ... done
[16:17:45.347] result() for ClusterFuture ...
[16:17:45.347] - result already collected: FutureResult
[16:17:45.347] result() for ClusterFuture ... done
[16:17:45.348] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:45.348] - nx: 2
[16:17:45.348] - relay: TRUE
[16:17:45.348] - stdout: TRUE
[16:17:45.348] - signal: TRUE
[16:17:45.348] - resignal: FALSE
[16:17:45.348] - force: TRUE
[16:17:45.348] - relayed: [n=2] TRUE, FALSE
[16:17:45.348] - queued futures: [n=2] TRUE, FALSE
[16:17:45.348]  - until=2
[16:17:45.348]  - relaying element #2
[16:17:45.349] result() for ClusterFuture ...
[16:17:45.349] - result already collected: FutureResult
[16:17:45.349] result() for ClusterFuture ... done
[16:17:45.349] result() for ClusterFuture ...
[16:17:45.349] - result already collected: FutureResult
[16:17:45.349] result() for ClusterFuture ... done
[16:17:45.349] result() for ClusterFuture ...
[16:17:45.349] - result already collected: FutureResult
[16:17:45.349] result() for ClusterFuture ... done
[16:17:45.349] result() for ClusterFuture ...
[16:17:45.349] - result already collected: FutureResult
[16:17:45.349] result() for ClusterFuture ... done
[16:17:45.350] - relayed: [n=2] TRUE, TRUE
[16:17:45.350] - queued futures: [n=2] TRUE, TRUE
[16:17:45.350] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:45.350]  length: 0 (resolved future 2)
[16:17:45.350] Relaying remaining futures
[16:17:45.350] signalConditionsASAP(NULL, pos=0) ...
[16:17:45.350] - nx: 2
[16:17:45.350] - relay: TRUE
[16:17:45.350] - stdout: TRUE
[16:17:45.350] - signal: TRUE
[16:17:45.350] - resignal: FALSE
[16:17:45.351] - force: TRUE
[16:17:45.351] - relayed: [n=2] TRUE, TRUE
[16:17:45.351] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:45.351] - relayed: [n=2] TRUE, TRUE
[16:17:45.351] - queued futures: [n=2] TRUE, TRUE
[16:17:45.351] signalConditionsASAP(NULL, pos=0) ... done
[16:17:45.351] resolve() on list ... DONE
[16:17:45.351] result() for ClusterFuture ...
[16:17:45.351] - result already collected: FutureResult
[16:17:45.351] result() for ClusterFuture ... done
[16:17:45.351] result() for ClusterFuture ...
[16:17:45.352] - result already collected: FutureResult
[16:17:45.352] result() for ClusterFuture ... done
[16:17:45.352] result() for ClusterFuture ...
[16:17:45.352] - result already collected: FutureResult
[16:17:45.352] result() for ClusterFuture ... done
[16:17:45.352] result() for ClusterFuture ...
[16:17:45.352] - result already collected: FutureResult
[16:17:45.352] result() for ClusterFuture ... done
[16:17:45.352]  - Number of value chunks collected: 2
[16:17:45.352] Resolving 2 futures (chunks) ... DONE
[16:17:45.352] Reducing values from 2 chunks ...
[16:17:45.353]  - Number of values collected after concatenation: 2
[16:17:45.353]  - Number of values expected: 2
[16:17:45.353] Reducing values from 2 chunks ... DONE
[16:17:45.353] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:17:45.353] getGlobalsAndPackagesXApply() ...
[16:17:45.353]  - future.globals: TRUE
[16:17:45.353] getGlobalsAndPackages() ...
[16:17:45.354] Searching for globals...
[16:17:45.356] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:17:45.356] Searching for globals ... DONE
[16:17:45.356] Resolving globals: FALSE
[16:17:45.357] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:17:45.357] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:17:45.357] - globals: [1] ‘FUN’
[16:17:45.357] 
[16:17:45.357] getGlobalsAndPackages() ... DONE
[16:17:45.358]  - globals found/used: [n=1] ‘FUN’
[16:17:45.358]  - needed namespaces: [n=0] 
[16:17:45.358] Finding globals ... DONE
[16:17:45.358]  - use_args: TRUE
[16:17:45.358]  - Getting '...' globals ...
[16:17:45.358] resolve() on list ...
[16:17:45.358]  recursive: 0
[16:17:45.358]  length: 1
[16:17:45.358]  elements: ‘...’
[16:17:45.359]  length: 0 (resolved future 1)
[16:17:45.359] resolve() on list ... DONE
[16:17:45.359]    - '...' content: [n=0] 
[16:17:45.359] List of 1
[16:17:45.359]  $ ...: list()
[16:17:45.359]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.359]  - attr(*, "where")=List of 1
[16:17:45.359]   ..$ ...:<environment: 0x555be37b5e78> 
[16:17:45.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.359]  - attr(*, "resolved")= logi TRUE
[16:17:45.359]  - attr(*, "total_size")= num NA
[16:17:45.361]  - Getting '...' globals ... DONE
[16:17:45.362] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:45.362] List of 2
[16:17:45.362]  $ ...future.FUN:function (x)  
[16:17:45.362]  $ ...          : list()
[16:17:45.362]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.362]  - attr(*, "where")=List of 2
[16:17:45.362]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:45.362]   ..$ ...          :<environment: 0x555be37b5e78> 
[16:17:45.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.362]  - attr(*, "resolved")= logi FALSE
[16:17:45.362]  - attr(*, "total_size")= num 9888
[16:17:45.364] Packages to be attached in all futures: [n=0] 
[16:17:45.364] getGlobalsAndPackagesXApply() ... DONE
[16:17:45.368] future_lapply() ...
[16:17:45.373] Number of chunks: 2
[16:17:45.373] getGlobalsAndPackagesXApply() ...
[16:17:45.373]  - future.globals: <name-value list> with names ‘list()’
[16:17:45.373]  - use_args: TRUE
[16:17:45.373] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:45.373] List of 2
[16:17:45.373]  $ ...          : list()
[16:17:45.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.373]  $ ...future.FUN:function (x)  
[16:17:45.373]  - attr(*, "where")=List of 2
[16:17:45.373]   ..$ ...          :<environment: 0x555be37b5e78> 
[16:17:45.373]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:17:45.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.373]  - attr(*, "resolved")= logi FALSE
[16:17:45.373]  - attr(*, "total_size")= num NA
[16:17:45.376] Packages to be attached in all futures: [n=0] 
[16:17:45.376] getGlobalsAndPackagesXApply() ... DONE
[16:17:45.376] Number of futures (= number of chunks): 2
[16:17:45.376] Launching 2 futures (chunks) ...
[16:17:45.376] Chunk #1 of 2 ...
[16:17:45.376]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:45.377]  - seeds: <none>
[16:17:45.377]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.377] getGlobalsAndPackages() ...
[16:17:45.377] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.377] Resolving globals: FALSE
[16:17:45.377] Tweak future expression to call with '...' arguments ...
[16:17:45.377] {
[16:17:45.377]     do.call(function(...) {
[16:17:45.377]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.377]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.377]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.377]             on.exit(options(oopts), add = TRUE)
[16:17:45.377]         }
[16:17:45.377]         {
[16:17:45.377]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.377]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.377]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.377]             })
[16:17:45.377]         }
[16:17:45.377]     }, args = future.call.arguments)
[16:17:45.377] }
[16:17:45.377] Tweak future expression to call with '...' arguments ... DONE
[16:17:45.378] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.378] 
[16:17:45.378] getGlobalsAndPackages() ... DONE
[16:17:45.378] run() for ‘Future’ ...
[16:17:45.378] - state: ‘created’
[16:17:45.379] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:45.392] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.392] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:45.392]   - Field: ‘node’
[16:17:45.392]   - Field: ‘label’
[16:17:45.393]   - Field: ‘local’
[16:17:45.393]   - Field: ‘owner’
[16:17:45.393]   - Field: ‘envir’
[16:17:45.393]   - Field: ‘workers’
[16:17:45.393]   - Field: ‘packages’
[16:17:45.393]   - Field: ‘gc’
[16:17:45.393]   - Field: ‘conditions’
[16:17:45.393]   - Field: ‘persistent’
[16:17:45.393]   - Field: ‘expr’
[16:17:45.393]   - Field: ‘uuid’
[16:17:45.394]   - Field: ‘seed’
[16:17:45.394]   - Field: ‘version’
[16:17:45.394]   - Field: ‘result’
[16:17:45.394]   - Field: ‘asynchronous’
[16:17:45.394]   - Field: ‘calls’
[16:17:45.394]   - Field: ‘globals’
[16:17:45.394]   - Field: ‘stdout’
[16:17:45.394]   - Field: ‘earlySignal’
[16:17:45.394]   - Field: ‘lazy’
[16:17:45.394]   - Field: ‘state’
[16:17:45.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:45.395] - Launch lazy future ...
[16:17:45.395] Packages needed by the future expression (n = 0): <none>
[16:17:45.395] Packages needed by future strategies (n = 0): <none>
[16:17:45.395] {
[16:17:45.395]     {
[16:17:45.395]         {
[16:17:45.395]             ...future.startTime <- base::Sys.time()
[16:17:45.395]             {
[16:17:45.395]                 {
[16:17:45.395]                   {
[16:17:45.395]                     {
[16:17:45.395]                       base::local({
[16:17:45.395]                         has_future <- base::requireNamespace("future", 
[16:17:45.395]                           quietly = TRUE)
[16:17:45.395]                         if (has_future) {
[16:17:45.395]                           ns <- base::getNamespace("future")
[16:17:45.395]                           version <- ns[[".package"]][["version"]]
[16:17:45.395]                           if (is.null(version)) 
[16:17:45.395]                             version <- utils::packageVersion("future")
[16:17:45.395]                         }
[16:17:45.395]                         else {
[16:17:45.395]                           version <- NULL
[16:17:45.395]                         }
[16:17:45.395]                         if (!has_future || version < "1.8.0") {
[16:17:45.395]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:45.395]                             "", base::R.version$version.string), 
[16:17:45.395]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:45.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:45.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:45.395]                               "release", "version")], collapse = " "), 
[16:17:45.395]                             hostname = base::Sys.info()[["nodename"]])
[16:17:45.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:45.395]                             info)
[16:17:45.395]                           info <- base::paste(info, collapse = "; ")
[16:17:45.395]                           if (!has_future) {
[16:17:45.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:45.395]                               info)
[16:17:45.395]                           }
[16:17:45.395]                           else {
[16:17:45.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:45.395]                               info, version)
[16:17:45.395]                           }
[16:17:45.395]                           base::stop(msg)
[16:17:45.395]                         }
[16:17:45.395]                       })
[16:17:45.395]                     }
[16:17:45.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:45.395]                     base::options(mc.cores = 1L)
[16:17:45.395]                   }
[16:17:45.395]                   ...future.strategy.old <- future::plan("list")
[16:17:45.395]                   options(future.plan = NULL)
[16:17:45.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:45.395]                 }
[16:17:45.395]                 ...future.workdir <- getwd()
[16:17:45.395]             }
[16:17:45.395]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:45.395]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:45.395]         }
[16:17:45.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:45.395]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:45.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:45.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:45.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:45.395]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:45.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:45.395]             base::names(...future.oldOptions))
[16:17:45.395]     }
[16:17:45.395]     if (FALSE) {
[16:17:45.395]     }
[16:17:45.395]     else {
[16:17:45.395]         if (TRUE) {
[16:17:45.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:45.395]                 open = "w")
[16:17:45.395]         }
[16:17:45.395]         else {
[16:17:45.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:45.395]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:45.395]         }
[16:17:45.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:45.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:45.395]             base::sink(type = "output", split = FALSE)
[16:17:45.395]             base::close(...future.stdout)
[16:17:45.395]         }, add = TRUE)
[16:17:45.395]     }
[16:17:45.395]     ...future.frame <- base::sys.nframe()
[16:17:45.395]     ...future.conditions <- base::list()
[16:17:45.395]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:45.395]     if (FALSE) {
[16:17:45.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:45.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:45.395]     }
[16:17:45.395]     ...future.result <- base::tryCatch({
[16:17:45.395]         base::withCallingHandlers({
[16:17:45.395]             ...future.value <- base::withVisible(base::local({
[16:17:45.395]                 ...future.makeSendCondition <- base::local({
[16:17:45.395]                   sendCondition <- NULL
[16:17:45.395]                   function(frame = 1L) {
[16:17:45.395]                     if (is.function(sendCondition)) 
[16:17:45.395]                       return(sendCondition)
[16:17:45.395]                     ns <- getNamespace("parallel")
[16:17:45.395]                     if (exists("sendData", mode = "function", 
[16:17:45.395]                       envir = ns)) {
[16:17:45.395]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:45.395]                         envir = ns)
[16:17:45.395]                       envir <- sys.frame(frame)
[16:17:45.395]                       master <- NULL
[16:17:45.395]                       while (!identical(envir, .GlobalEnv) && 
[16:17:45.395]                         !identical(envir, emptyenv())) {
[16:17:45.395]                         if (exists("master", mode = "list", envir = envir, 
[16:17:45.395]                           inherits = FALSE)) {
[16:17:45.395]                           master <- get("master", mode = "list", 
[16:17:45.395]                             envir = envir, inherits = FALSE)
[16:17:45.395]                           if (inherits(master, c("SOCKnode", 
[16:17:45.395]                             "SOCK0node"))) {
[16:17:45.395]                             sendCondition <<- function(cond) {
[16:17:45.395]                               data <- list(type = "VALUE", value = cond, 
[16:17:45.395]                                 success = TRUE)
[16:17:45.395]                               parallel_sendData(master, data)
[16:17:45.395]                             }
[16:17:45.395]                             return(sendCondition)
[16:17:45.395]                           }
[16:17:45.395]                         }
[16:17:45.395]                         frame <- frame + 1L
[16:17:45.395]                         envir <- sys.frame(frame)
[16:17:45.395]                       }
[16:17:45.395]                     }
[16:17:45.395]                     sendCondition <<- function(cond) NULL
[16:17:45.395]                   }
[16:17:45.395]                 })
[16:17:45.395]                 withCallingHandlers({
[16:17:45.395]                   {
[16:17:45.395]                     do.call(function(...) {
[16:17:45.395]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.395]                       if (!identical(...future.globals.maxSize.org, 
[16:17:45.395]                         ...future.globals.maxSize)) {
[16:17:45.395]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.395]                         on.exit(options(oopts), add = TRUE)
[16:17:45.395]                       }
[16:17:45.395]                       {
[16:17:45.395]                         lapply(seq_along(...future.elements_ii), 
[16:17:45.395]                           FUN = function(jj) {
[16:17:45.395]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.395]                             ...future.FUN(...future.X_jj, ...)
[16:17:45.395]                           })
[16:17:45.395]                       }
[16:17:45.395]                     }, args = future.call.arguments)
[16:17:45.395]                   }
[16:17:45.395]                 }, immediateCondition = function(cond) {
[16:17:45.395]                   sendCondition <- ...future.makeSendCondition()
[16:17:45.395]                   sendCondition(cond)
[16:17:45.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.395]                   {
[16:17:45.395]                     inherits <- base::inherits
[16:17:45.395]                     invokeRestart <- base::invokeRestart
[16:17:45.395]                     is.null <- base::is.null
[16:17:45.395]                     muffled <- FALSE
[16:17:45.395]                     if (inherits(cond, "message")) {
[16:17:45.395]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:45.395]                       if (muffled) 
[16:17:45.395]                         invokeRestart("muffleMessage")
[16:17:45.395]                     }
[16:17:45.395]                     else if (inherits(cond, "warning")) {
[16:17:45.395]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:45.395]                       if (muffled) 
[16:17:45.395]                         invokeRestart("muffleWarning")
[16:17:45.395]                     }
[16:17:45.395]                     else if (inherits(cond, "condition")) {
[16:17:45.395]                       if (!is.null(pattern)) {
[16:17:45.395]                         computeRestarts <- base::computeRestarts
[16:17:45.395]                         grepl <- base::grepl
[16:17:45.395]                         restarts <- computeRestarts(cond)
[16:17:45.395]                         for (restart in restarts) {
[16:17:45.395]                           name <- restart$name
[16:17:45.395]                           if (is.null(name)) 
[16:17:45.395]                             next
[16:17:45.395]                           if (!grepl(pattern, name)) 
[16:17:45.395]                             next
[16:17:45.395]                           invokeRestart(restart)
[16:17:45.395]                           muffled <- TRUE
[16:17:45.395]                           break
[16:17:45.395]                         }
[16:17:45.395]                       }
[16:17:45.395]                     }
[16:17:45.395]                     invisible(muffled)
[16:17:45.395]                   }
[16:17:45.395]                   muffleCondition(cond)
[16:17:45.395]                 })
[16:17:45.395]             }))
[16:17:45.395]             future::FutureResult(value = ...future.value$value, 
[16:17:45.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.395]                   ...future.rng), globalenv = if (FALSE) 
[16:17:45.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:45.395]                     ...future.globalenv.names))
[16:17:45.395]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:45.395]         }, condition = base::local({
[16:17:45.395]             c <- base::c
[16:17:45.395]             inherits <- base::inherits
[16:17:45.395]             invokeRestart <- base::invokeRestart
[16:17:45.395]             length <- base::length
[16:17:45.395]             list <- base::list
[16:17:45.395]             seq.int <- base::seq.int
[16:17:45.395]             signalCondition <- base::signalCondition
[16:17:45.395]             sys.calls <- base::sys.calls
[16:17:45.395]             `[[` <- base::`[[`
[16:17:45.395]             `+` <- base::`+`
[16:17:45.395]             `<<-` <- base::`<<-`
[16:17:45.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:45.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:45.395]                   3L)]
[16:17:45.395]             }
[16:17:45.395]             function(cond) {
[16:17:45.395]                 is_error <- inherits(cond, "error")
[16:17:45.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:45.395]                   NULL)
[16:17:45.395]                 if (is_error) {
[16:17:45.395]                   sessionInformation <- function() {
[16:17:45.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:45.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:45.395]                       search = base::search(), system = base::Sys.info())
[16:17:45.395]                   }
[16:17:45.395]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:45.395]                     cond$call), session = sessionInformation(), 
[16:17:45.395]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:45.395]                   signalCondition(cond)
[16:17:45.395]                 }
[16:17:45.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:45.395]                 "immediateCondition"))) {
[16:17:45.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:45.395]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:45.395]                   if (TRUE && !signal) {
[16:17:45.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.395]                     {
[16:17:45.395]                       inherits <- base::inherits
[16:17:45.395]                       invokeRestart <- base::invokeRestart
[16:17:45.395]                       is.null <- base::is.null
[16:17:45.395]                       muffled <- FALSE
[16:17:45.395]                       if (inherits(cond, "message")) {
[16:17:45.395]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.395]                         if (muffled) 
[16:17:45.395]                           invokeRestart("muffleMessage")
[16:17:45.395]                       }
[16:17:45.395]                       else if (inherits(cond, "warning")) {
[16:17:45.395]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.395]                         if (muffled) 
[16:17:45.395]                           invokeRestart("muffleWarning")
[16:17:45.395]                       }
[16:17:45.395]                       else if (inherits(cond, "condition")) {
[16:17:45.395]                         if (!is.null(pattern)) {
[16:17:45.395]                           computeRestarts <- base::computeRestarts
[16:17:45.395]                           grepl <- base::grepl
[16:17:45.395]                           restarts <- computeRestarts(cond)
[16:17:45.395]                           for (restart in restarts) {
[16:17:45.395]                             name <- restart$name
[16:17:45.395]                             if (is.null(name)) 
[16:17:45.395]                               next
[16:17:45.395]                             if (!grepl(pattern, name)) 
[16:17:45.395]                               next
[16:17:45.395]                             invokeRestart(restart)
[16:17:45.395]                             muffled <- TRUE
[16:17:45.395]                             break
[16:17:45.395]                           }
[16:17:45.395]                         }
[16:17:45.395]                       }
[16:17:45.395]                       invisible(muffled)
[16:17:45.395]                     }
[16:17:45.395]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.395]                   }
[16:17:45.395]                 }
[16:17:45.395]                 else {
[16:17:45.395]                   if (TRUE) {
[16:17:45.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.395]                     {
[16:17:45.395]                       inherits <- base::inherits
[16:17:45.395]                       invokeRestart <- base::invokeRestart
[16:17:45.395]                       is.null <- base::is.null
[16:17:45.395]                       muffled <- FALSE
[16:17:45.395]                       if (inherits(cond, "message")) {
[16:17:45.395]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.395]                         if (muffled) 
[16:17:45.395]                           invokeRestart("muffleMessage")
[16:17:45.395]                       }
[16:17:45.395]                       else if (inherits(cond, "warning")) {
[16:17:45.395]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.395]                         if (muffled) 
[16:17:45.395]                           invokeRestart("muffleWarning")
[16:17:45.395]                       }
[16:17:45.395]                       else if (inherits(cond, "condition")) {
[16:17:45.395]                         if (!is.null(pattern)) {
[16:17:45.395]                           computeRestarts <- base::computeRestarts
[16:17:45.395]                           grepl <- base::grepl
[16:17:45.395]                           restarts <- computeRestarts(cond)
[16:17:45.395]                           for (restart in restarts) {
[16:17:45.395]                             name <- restart$name
[16:17:45.395]                             if (is.null(name)) 
[16:17:45.395]                               next
[16:17:45.395]                             if (!grepl(pattern, name)) 
[16:17:45.395]                               next
[16:17:45.395]                             invokeRestart(restart)
[16:17:45.395]                             muffled <- TRUE
[16:17:45.395]                             break
[16:17:45.395]                           }
[16:17:45.395]                         }
[16:17:45.395]                       }
[16:17:45.395]                       invisible(muffled)
[16:17:45.395]                     }
[16:17:45.395]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.395]                   }
[16:17:45.395]                 }
[16:17:45.395]             }
[16:17:45.395]         }))
[16:17:45.395]     }, error = function(ex) {
[16:17:45.395]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:45.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.395]                 ...future.rng), started = ...future.startTime, 
[16:17:45.395]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:45.395]             version = "1.8"), class = "FutureResult")
[16:17:45.395]     }, finally = {
[16:17:45.395]         if (!identical(...future.workdir, getwd())) 
[16:17:45.395]             setwd(...future.workdir)
[16:17:45.395]         {
[16:17:45.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:45.395]                 ...future.oldOptions$nwarnings <- NULL
[16:17:45.395]             }
[16:17:45.395]             base::options(...future.oldOptions)
[16:17:45.395]             if (.Platform$OS.type == "windows") {
[16:17:45.395]                 old_names <- names(...future.oldEnvVars)
[16:17:45.395]                 envs <- base::Sys.getenv()
[16:17:45.395]                 names <- names(envs)
[16:17:45.395]                 common <- intersect(names, old_names)
[16:17:45.395]                 added <- setdiff(names, old_names)
[16:17:45.395]                 removed <- setdiff(old_names, names)
[16:17:45.395]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:45.395]                   envs[common]]
[16:17:45.395]                 NAMES <- toupper(changed)
[16:17:45.395]                 args <- list()
[16:17:45.395]                 for (kk in seq_along(NAMES)) {
[16:17:45.395]                   name <- changed[[kk]]
[16:17:45.395]                   NAME <- NAMES[[kk]]
[16:17:45.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.395]                     next
[16:17:45.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.395]                 }
[16:17:45.395]                 NAMES <- toupper(added)
[16:17:45.395]                 for (kk in seq_along(NAMES)) {
[16:17:45.395]                   name <- added[[kk]]
[16:17:45.395]                   NAME <- NAMES[[kk]]
[16:17:45.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.395]                     next
[16:17:45.395]                   args[[name]] <- ""
[16:17:45.395]                 }
[16:17:45.395]                 NAMES <- toupper(removed)
[16:17:45.395]                 for (kk in seq_along(NAMES)) {
[16:17:45.395]                   name <- removed[[kk]]
[16:17:45.395]                   NAME <- NAMES[[kk]]
[16:17:45.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.395]                     next
[16:17:45.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.395]                 }
[16:17:45.395]                 if (length(args) > 0) 
[16:17:45.395]                   base::do.call(base::Sys.setenv, args = args)
[16:17:45.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:45.395]             }
[16:17:45.395]             else {
[16:17:45.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:45.395]             }
[16:17:45.395]             {
[16:17:45.395]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:45.395]                   0L) {
[16:17:45.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:45.395]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:45.395]                   base::options(opts)
[16:17:45.395]                 }
[16:17:45.395]                 {
[16:17:45.395]                   {
[16:17:45.395]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:45.395]                     NULL
[16:17:45.395]                   }
[16:17:45.395]                   options(future.plan = NULL)
[16:17:45.395]                   if (is.na(NA_character_)) 
[16:17:45.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:45.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:45.395]                     .init = FALSE)
[16:17:45.395]                 }
[16:17:45.395]             }
[16:17:45.395]         }
[16:17:45.395]     })
[16:17:45.395]     if (TRUE) {
[16:17:45.395]         base::sink(type = "output", split = FALSE)
[16:17:45.395]         if (TRUE) {
[16:17:45.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:45.395]         }
[16:17:45.395]         else {
[16:17:45.395]             ...future.result["stdout"] <- base::list(NULL)
[16:17:45.395]         }
[16:17:45.395]         base::close(...future.stdout)
[16:17:45.395]         ...future.stdout <- NULL
[16:17:45.395]     }
[16:17:45.395]     ...future.result$conditions <- ...future.conditions
[16:17:45.395]     ...future.result$finished <- base::Sys.time()
[16:17:45.395]     ...future.result
[16:17:45.395] }
[16:17:45.398] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[16:17:45.399] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:45.399] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:45.399] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[16:17:45.399] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[16:17:45.399] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:17:45.400] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:17:45.400] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:45.400] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:45.400] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:17:45.401] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:17:45.401] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[16:17:45.401] MultisessionFuture started
[16:17:45.401] - Launch lazy future ... done
[16:17:45.402] run() for ‘MultisessionFuture’ ... done
[16:17:45.402] Created future:
[16:17:45.402] MultisessionFuture:
[16:17:45.402] Label: ‘future_apply-1’
[16:17:45.402] Expression:
[16:17:45.402] {
[16:17:45.402]     do.call(function(...) {
[16:17:45.402]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.402]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.402]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.402]             on.exit(options(oopts), add = TRUE)
[16:17:45.402]         }
[16:17:45.402]         {
[16:17:45.402]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.402]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.402]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.402]             })
[16:17:45.402]         }
[16:17:45.402]     }, args = future.call.arguments)
[16:17:45.402] }
[16:17:45.402] Lazy evaluation: FALSE
[16:17:45.402] Asynchronous evaluation: TRUE
[16:17:45.402] Local evaluation: TRUE
[16:17:45.402] Environment: R_GlobalEnv
[16:17:45.402] Capture standard output: TRUE
[16:17:45.402] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:45.402] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:45.402] Packages: <none>
[16:17:45.402] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:45.402] Resolved: FALSE
[16:17:45.402] Value: <not collected>
[16:17:45.402] Conditions captured: <none>
[16:17:45.402] Early signaling: FALSE
[16:17:45.402] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:45.402] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.413] Chunk #1 of 2 ... DONE
[16:17:45.413] Chunk #2 of 2 ...
[16:17:45.416]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:45.416]  - seeds: <none>
[16:17:45.416]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.416] getGlobalsAndPackages() ...
[16:17:45.416] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.416] Resolving globals: FALSE
[16:17:45.417] Tweak future expression to call with '...' arguments ...
[16:17:45.417] {
[16:17:45.417]     do.call(function(...) {
[16:17:45.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.417]             on.exit(options(oopts), add = TRUE)
[16:17:45.417]         }
[16:17:45.417]         {
[16:17:45.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.417]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.417]             })
[16:17:45.417]         }
[16:17:45.417]     }, args = future.call.arguments)
[16:17:45.417] }
[16:17:45.417] Tweak future expression to call with '...' arguments ... DONE
[16:17:45.417] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.417] 
[16:17:45.417] getGlobalsAndPackages() ... DONE
[16:17:45.418] run() for ‘Future’ ...
[16:17:45.418] - state: ‘created’
[16:17:45.418] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:45.432] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:45.432]   - Field: ‘node’
[16:17:45.432]   - Field: ‘label’
[16:17:45.432]   - Field: ‘local’
[16:17:45.432]   - Field: ‘owner’
[16:17:45.432]   - Field: ‘envir’
[16:17:45.433]   - Field: ‘workers’
[16:17:45.433]   - Field: ‘packages’
[16:17:45.433]   - Field: ‘gc’
[16:17:45.433]   - Field: ‘conditions’
[16:17:45.433]   - Field: ‘persistent’
[16:17:45.433]   - Field: ‘expr’
[16:17:45.433]   - Field: ‘uuid’
[16:17:45.433]   - Field: ‘seed’
[16:17:45.433]   - Field: ‘version’
[16:17:45.433]   - Field: ‘result’
[16:17:45.433]   - Field: ‘asynchronous’
[16:17:45.434]   - Field: ‘calls’
[16:17:45.434]   - Field: ‘globals’
[16:17:45.434]   - Field: ‘stdout’
[16:17:45.434]   - Field: ‘earlySignal’
[16:17:45.434]   - Field: ‘lazy’
[16:17:45.434]   - Field: ‘state’
[16:17:45.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:45.434] - Launch lazy future ...
[16:17:45.434] Packages needed by the future expression (n = 0): <none>
[16:17:45.434] Packages needed by future strategies (n = 0): <none>
[16:17:45.435] {
[16:17:45.435]     {
[16:17:45.435]         {
[16:17:45.435]             ...future.startTime <- base::Sys.time()
[16:17:45.435]             {
[16:17:45.435]                 {
[16:17:45.435]                   {
[16:17:45.435]                     {
[16:17:45.435]                       base::local({
[16:17:45.435]                         has_future <- base::requireNamespace("future", 
[16:17:45.435]                           quietly = TRUE)
[16:17:45.435]                         if (has_future) {
[16:17:45.435]                           ns <- base::getNamespace("future")
[16:17:45.435]                           version <- ns[[".package"]][["version"]]
[16:17:45.435]                           if (is.null(version)) 
[16:17:45.435]                             version <- utils::packageVersion("future")
[16:17:45.435]                         }
[16:17:45.435]                         else {
[16:17:45.435]                           version <- NULL
[16:17:45.435]                         }
[16:17:45.435]                         if (!has_future || version < "1.8.0") {
[16:17:45.435]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:45.435]                             "", base::R.version$version.string), 
[16:17:45.435]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:45.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:45.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:45.435]                               "release", "version")], collapse = " "), 
[16:17:45.435]                             hostname = base::Sys.info()[["nodename"]])
[16:17:45.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:45.435]                             info)
[16:17:45.435]                           info <- base::paste(info, collapse = "; ")
[16:17:45.435]                           if (!has_future) {
[16:17:45.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:45.435]                               info)
[16:17:45.435]                           }
[16:17:45.435]                           else {
[16:17:45.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:45.435]                               info, version)
[16:17:45.435]                           }
[16:17:45.435]                           base::stop(msg)
[16:17:45.435]                         }
[16:17:45.435]                       })
[16:17:45.435]                     }
[16:17:45.435]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:45.435]                     base::options(mc.cores = 1L)
[16:17:45.435]                   }
[16:17:45.435]                   ...future.strategy.old <- future::plan("list")
[16:17:45.435]                   options(future.plan = NULL)
[16:17:45.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:45.435]                 }
[16:17:45.435]                 ...future.workdir <- getwd()
[16:17:45.435]             }
[16:17:45.435]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:45.435]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:45.435]         }
[16:17:45.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:45.435]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:45.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:45.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:45.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:45.435]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:45.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:45.435]             base::names(...future.oldOptions))
[16:17:45.435]     }
[16:17:45.435]     if (FALSE) {
[16:17:45.435]     }
[16:17:45.435]     else {
[16:17:45.435]         if (TRUE) {
[16:17:45.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:45.435]                 open = "w")
[16:17:45.435]         }
[16:17:45.435]         else {
[16:17:45.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:45.435]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:45.435]         }
[16:17:45.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:45.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:45.435]             base::sink(type = "output", split = FALSE)
[16:17:45.435]             base::close(...future.stdout)
[16:17:45.435]         }, add = TRUE)
[16:17:45.435]     }
[16:17:45.435]     ...future.frame <- base::sys.nframe()
[16:17:45.435]     ...future.conditions <- base::list()
[16:17:45.435]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:45.435]     if (FALSE) {
[16:17:45.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:45.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:45.435]     }
[16:17:45.435]     ...future.result <- base::tryCatch({
[16:17:45.435]         base::withCallingHandlers({
[16:17:45.435]             ...future.value <- base::withVisible(base::local({
[16:17:45.435]                 ...future.makeSendCondition <- base::local({
[16:17:45.435]                   sendCondition <- NULL
[16:17:45.435]                   function(frame = 1L) {
[16:17:45.435]                     if (is.function(sendCondition)) 
[16:17:45.435]                       return(sendCondition)
[16:17:45.435]                     ns <- getNamespace("parallel")
[16:17:45.435]                     if (exists("sendData", mode = "function", 
[16:17:45.435]                       envir = ns)) {
[16:17:45.435]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:45.435]                         envir = ns)
[16:17:45.435]                       envir <- sys.frame(frame)
[16:17:45.435]                       master <- NULL
[16:17:45.435]                       while (!identical(envir, .GlobalEnv) && 
[16:17:45.435]                         !identical(envir, emptyenv())) {
[16:17:45.435]                         if (exists("master", mode = "list", envir = envir, 
[16:17:45.435]                           inherits = FALSE)) {
[16:17:45.435]                           master <- get("master", mode = "list", 
[16:17:45.435]                             envir = envir, inherits = FALSE)
[16:17:45.435]                           if (inherits(master, c("SOCKnode", 
[16:17:45.435]                             "SOCK0node"))) {
[16:17:45.435]                             sendCondition <<- function(cond) {
[16:17:45.435]                               data <- list(type = "VALUE", value = cond, 
[16:17:45.435]                                 success = TRUE)
[16:17:45.435]                               parallel_sendData(master, data)
[16:17:45.435]                             }
[16:17:45.435]                             return(sendCondition)
[16:17:45.435]                           }
[16:17:45.435]                         }
[16:17:45.435]                         frame <- frame + 1L
[16:17:45.435]                         envir <- sys.frame(frame)
[16:17:45.435]                       }
[16:17:45.435]                     }
[16:17:45.435]                     sendCondition <<- function(cond) NULL
[16:17:45.435]                   }
[16:17:45.435]                 })
[16:17:45.435]                 withCallingHandlers({
[16:17:45.435]                   {
[16:17:45.435]                     do.call(function(...) {
[16:17:45.435]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.435]                       if (!identical(...future.globals.maxSize.org, 
[16:17:45.435]                         ...future.globals.maxSize)) {
[16:17:45.435]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.435]                         on.exit(options(oopts), add = TRUE)
[16:17:45.435]                       }
[16:17:45.435]                       {
[16:17:45.435]                         lapply(seq_along(...future.elements_ii), 
[16:17:45.435]                           FUN = function(jj) {
[16:17:45.435]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.435]                             ...future.FUN(...future.X_jj, ...)
[16:17:45.435]                           })
[16:17:45.435]                       }
[16:17:45.435]                     }, args = future.call.arguments)
[16:17:45.435]                   }
[16:17:45.435]                 }, immediateCondition = function(cond) {
[16:17:45.435]                   sendCondition <- ...future.makeSendCondition()
[16:17:45.435]                   sendCondition(cond)
[16:17:45.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.435]                   {
[16:17:45.435]                     inherits <- base::inherits
[16:17:45.435]                     invokeRestart <- base::invokeRestart
[16:17:45.435]                     is.null <- base::is.null
[16:17:45.435]                     muffled <- FALSE
[16:17:45.435]                     if (inherits(cond, "message")) {
[16:17:45.435]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:45.435]                       if (muffled) 
[16:17:45.435]                         invokeRestart("muffleMessage")
[16:17:45.435]                     }
[16:17:45.435]                     else if (inherits(cond, "warning")) {
[16:17:45.435]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:45.435]                       if (muffled) 
[16:17:45.435]                         invokeRestart("muffleWarning")
[16:17:45.435]                     }
[16:17:45.435]                     else if (inherits(cond, "condition")) {
[16:17:45.435]                       if (!is.null(pattern)) {
[16:17:45.435]                         computeRestarts <- base::computeRestarts
[16:17:45.435]                         grepl <- base::grepl
[16:17:45.435]                         restarts <- computeRestarts(cond)
[16:17:45.435]                         for (restart in restarts) {
[16:17:45.435]                           name <- restart$name
[16:17:45.435]                           if (is.null(name)) 
[16:17:45.435]                             next
[16:17:45.435]                           if (!grepl(pattern, name)) 
[16:17:45.435]                             next
[16:17:45.435]                           invokeRestart(restart)
[16:17:45.435]                           muffled <- TRUE
[16:17:45.435]                           break
[16:17:45.435]                         }
[16:17:45.435]                       }
[16:17:45.435]                     }
[16:17:45.435]                     invisible(muffled)
[16:17:45.435]                   }
[16:17:45.435]                   muffleCondition(cond)
[16:17:45.435]                 })
[16:17:45.435]             }))
[16:17:45.435]             future::FutureResult(value = ...future.value$value, 
[16:17:45.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.435]                   ...future.rng), globalenv = if (FALSE) 
[16:17:45.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:45.435]                     ...future.globalenv.names))
[16:17:45.435]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:45.435]         }, condition = base::local({
[16:17:45.435]             c <- base::c
[16:17:45.435]             inherits <- base::inherits
[16:17:45.435]             invokeRestart <- base::invokeRestart
[16:17:45.435]             length <- base::length
[16:17:45.435]             list <- base::list
[16:17:45.435]             seq.int <- base::seq.int
[16:17:45.435]             signalCondition <- base::signalCondition
[16:17:45.435]             sys.calls <- base::sys.calls
[16:17:45.435]             `[[` <- base::`[[`
[16:17:45.435]             `+` <- base::`+`
[16:17:45.435]             `<<-` <- base::`<<-`
[16:17:45.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:45.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:45.435]                   3L)]
[16:17:45.435]             }
[16:17:45.435]             function(cond) {
[16:17:45.435]                 is_error <- inherits(cond, "error")
[16:17:45.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:45.435]                   NULL)
[16:17:45.435]                 if (is_error) {
[16:17:45.435]                   sessionInformation <- function() {
[16:17:45.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:45.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:45.435]                       search = base::search(), system = base::Sys.info())
[16:17:45.435]                   }
[16:17:45.435]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:45.435]                     cond$call), session = sessionInformation(), 
[16:17:45.435]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:45.435]                   signalCondition(cond)
[16:17:45.435]                 }
[16:17:45.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:45.435]                 "immediateCondition"))) {
[16:17:45.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:45.435]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:45.435]                   if (TRUE && !signal) {
[16:17:45.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.435]                     {
[16:17:45.435]                       inherits <- base::inherits
[16:17:45.435]                       invokeRestart <- base::invokeRestart
[16:17:45.435]                       is.null <- base::is.null
[16:17:45.435]                       muffled <- FALSE
[16:17:45.435]                       if (inherits(cond, "message")) {
[16:17:45.435]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.435]                         if (muffled) 
[16:17:45.435]                           invokeRestart("muffleMessage")
[16:17:45.435]                       }
[16:17:45.435]                       else if (inherits(cond, "warning")) {
[16:17:45.435]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.435]                         if (muffled) 
[16:17:45.435]                           invokeRestart("muffleWarning")
[16:17:45.435]                       }
[16:17:45.435]                       else if (inherits(cond, "condition")) {
[16:17:45.435]                         if (!is.null(pattern)) {
[16:17:45.435]                           computeRestarts <- base::computeRestarts
[16:17:45.435]                           grepl <- base::grepl
[16:17:45.435]                           restarts <- computeRestarts(cond)
[16:17:45.435]                           for (restart in restarts) {
[16:17:45.435]                             name <- restart$name
[16:17:45.435]                             if (is.null(name)) 
[16:17:45.435]                               next
[16:17:45.435]                             if (!grepl(pattern, name)) 
[16:17:45.435]                               next
[16:17:45.435]                             invokeRestart(restart)
[16:17:45.435]                             muffled <- TRUE
[16:17:45.435]                             break
[16:17:45.435]                           }
[16:17:45.435]                         }
[16:17:45.435]                       }
[16:17:45.435]                       invisible(muffled)
[16:17:45.435]                     }
[16:17:45.435]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.435]                   }
[16:17:45.435]                 }
[16:17:45.435]                 else {
[16:17:45.435]                   if (TRUE) {
[16:17:45.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.435]                     {
[16:17:45.435]                       inherits <- base::inherits
[16:17:45.435]                       invokeRestart <- base::invokeRestart
[16:17:45.435]                       is.null <- base::is.null
[16:17:45.435]                       muffled <- FALSE
[16:17:45.435]                       if (inherits(cond, "message")) {
[16:17:45.435]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.435]                         if (muffled) 
[16:17:45.435]                           invokeRestart("muffleMessage")
[16:17:45.435]                       }
[16:17:45.435]                       else if (inherits(cond, "warning")) {
[16:17:45.435]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.435]                         if (muffled) 
[16:17:45.435]                           invokeRestart("muffleWarning")
[16:17:45.435]                       }
[16:17:45.435]                       else if (inherits(cond, "condition")) {
[16:17:45.435]                         if (!is.null(pattern)) {
[16:17:45.435]                           computeRestarts <- base::computeRestarts
[16:17:45.435]                           grepl <- base::grepl
[16:17:45.435]                           restarts <- computeRestarts(cond)
[16:17:45.435]                           for (restart in restarts) {
[16:17:45.435]                             name <- restart$name
[16:17:45.435]                             if (is.null(name)) 
[16:17:45.435]                               next
[16:17:45.435]                             if (!grepl(pattern, name)) 
[16:17:45.435]                               next
[16:17:45.435]                             invokeRestart(restart)
[16:17:45.435]                             muffled <- TRUE
[16:17:45.435]                             break
[16:17:45.435]                           }
[16:17:45.435]                         }
[16:17:45.435]                       }
[16:17:45.435]                       invisible(muffled)
[16:17:45.435]                     }
[16:17:45.435]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.435]                   }
[16:17:45.435]                 }
[16:17:45.435]             }
[16:17:45.435]         }))
[16:17:45.435]     }, error = function(ex) {
[16:17:45.435]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:45.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.435]                 ...future.rng), started = ...future.startTime, 
[16:17:45.435]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:45.435]             version = "1.8"), class = "FutureResult")
[16:17:45.435]     }, finally = {
[16:17:45.435]         if (!identical(...future.workdir, getwd())) 
[16:17:45.435]             setwd(...future.workdir)
[16:17:45.435]         {
[16:17:45.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:45.435]                 ...future.oldOptions$nwarnings <- NULL
[16:17:45.435]             }
[16:17:45.435]             base::options(...future.oldOptions)
[16:17:45.435]             if (.Platform$OS.type == "windows") {
[16:17:45.435]                 old_names <- names(...future.oldEnvVars)
[16:17:45.435]                 envs <- base::Sys.getenv()
[16:17:45.435]                 names <- names(envs)
[16:17:45.435]                 common <- intersect(names, old_names)
[16:17:45.435]                 added <- setdiff(names, old_names)
[16:17:45.435]                 removed <- setdiff(old_names, names)
[16:17:45.435]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:45.435]                   envs[common]]
[16:17:45.435]                 NAMES <- toupper(changed)
[16:17:45.435]                 args <- list()
[16:17:45.435]                 for (kk in seq_along(NAMES)) {
[16:17:45.435]                   name <- changed[[kk]]
[16:17:45.435]                   NAME <- NAMES[[kk]]
[16:17:45.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.435]                     next
[16:17:45.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.435]                 }
[16:17:45.435]                 NAMES <- toupper(added)
[16:17:45.435]                 for (kk in seq_along(NAMES)) {
[16:17:45.435]                   name <- added[[kk]]
[16:17:45.435]                   NAME <- NAMES[[kk]]
[16:17:45.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.435]                     next
[16:17:45.435]                   args[[name]] <- ""
[16:17:45.435]                 }
[16:17:45.435]                 NAMES <- toupper(removed)
[16:17:45.435]                 for (kk in seq_along(NAMES)) {
[16:17:45.435]                   name <- removed[[kk]]
[16:17:45.435]                   NAME <- NAMES[[kk]]
[16:17:45.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.435]                     next
[16:17:45.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.435]                 }
[16:17:45.435]                 if (length(args) > 0) 
[16:17:45.435]                   base::do.call(base::Sys.setenv, args = args)
[16:17:45.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:45.435]             }
[16:17:45.435]             else {
[16:17:45.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:45.435]             }
[16:17:45.435]             {
[16:17:45.435]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:45.435]                   0L) {
[16:17:45.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:45.435]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:45.435]                   base::options(opts)
[16:17:45.435]                 }
[16:17:45.435]                 {
[16:17:45.435]                   {
[16:17:45.435]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:45.435]                     NULL
[16:17:45.435]                   }
[16:17:45.435]                   options(future.plan = NULL)
[16:17:45.435]                   if (is.na(NA_character_)) 
[16:17:45.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:45.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:45.435]                     .init = FALSE)
[16:17:45.435]                 }
[16:17:45.435]             }
[16:17:45.435]         }
[16:17:45.435]     })
[16:17:45.435]     if (TRUE) {
[16:17:45.435]         base::sink(type = "output", split = FALSE)
[16:17:45.435]         if (TRUE) {
[16:17:45.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:45.435]         }
[16:17:45.435]         else {
[16:17:45.435]             ...future.result["stdout"] <- base::list(NULL)
[16:17:45.435]         }
[16:17:45.435]         base::close(...future.stdout)
[16:17:45.435]         ...future.stdout <- NULL
[16:17:45.435]     }
[16:17:45.435]     ...future.result$conditions <- ...future.conditions
[16:17:45.435]     ...future.result$finished <- base::Sys.time()
[16:17:45.435]     ...future.result
[16:17:45.435] }
[16:17:45.438] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[16:17:45.438] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:45.438] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:45.438] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[16:17:45.439] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[16:17:45.439] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:17:45.439] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:17:45.439] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:45.440] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:45.440] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:17:45.440] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:17:45.440] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[16:17:45.441] MultisessionFuture started
[16:17:45.441] - Launch lazy future ... done
[16:17:45.441] run() for ‘MultisessionFuture’ ... done
[16:17:45.441] Created future:
[16:17:45.441] MultisessionFuture:
[16:17:45.441] Label: ‘future_apply-2’
[16:17:45.441] Expression:
[16:17:45.441] {
[16:17:45.441]     do.call(function(...) {
[16:17:45.441]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.441]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.441]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.441]             on.exit(options(oopts), add = TRUE)
[16:17:45.441]         }
[16:17:45.441]         {
[16:17:45.441]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.441]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.441]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.441]             })
[16:17:45.441]         }
[16:17:45.441]     }, args = future.call.arguments)
[16:17:45.441] }
[16:17:45.441] Lazy evaluation: FALSE
[16:17:45.441] Asynchronous evaluation: TRUE
[16:17:45.441] Local evaluation: TRUE
[16:17:45.441] Environment: R_GlobalEnv
[16:17:45.441] Capture standard output: TRUE
[16:17:45.441] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:45.441] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:45.441] Packages: <none>
[16:17:45.441] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:45.441] Resolved: FALSE
[16:17:45.441] Value: <not collected>
[16:17:45.441] Conditions captured: <none>
[16:17:45.441] Early signaling: FALSE
[16:17:45.441] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:45.441] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.453] Chunk #2 of 2 ... DONE
[16:17:45.453] Launching 2 futures (chunks) ... DONE
[16:17:45.453] Resolving 2 futures (chunks) ...
[16:17:45.453] resolve() on list ...
[16:17:45.453]  recursive: 0
[16:17:45.453]  length: 2
[16:17:45.454] 
[16:17:45.454] receiveMessageFromWorker() for ClusterFuture ...
[16:17:45.454] - Validating connection of MultisessionFuture
[16:17:45.454] - received message: FutureResult
[16:17:45.454] - Received FutureResult
[16:17:45.455] - Erased future from FutureRegistry
[16:17:45.455] result() for ClusterFuture ...
[16:17:45.455] - result already collected: FutureResult
[16:17:45.455] result() for ClusterFuture ... done
[16:17:45.455] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:45.456] Future #1
[16:17:45.456] result() for ClusterFuture ...
[16:17:45.456] - result already collected: FutureResult
[16:17:45.456] result() for ClusterFuture ... done
[16:17:45.456] result() for ClusterFuture ...
[16:17:45.457] - result already collected: FutureResult
[16:17:45.457] result() for ClusterFuture ... done
[16:17:45.457] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:45.457] - nx: 2
[16:17:45.457] - relay: TRUE
[16:17:45.458] - stdout: TRUE
[16:17:45.458] - signal: TRUE
[16:17:45.458] - resignal: FALSE
[16:17:45.458] - force: TRUE
[16:17:45.458] - relayed: [n=2] FALSE, FALSE
[16:17:45.458] - queued futures: [n=2] FALSE, FALSE
[16:17:45.458]  - until=1
[16:17:45.458]  - relaying element #1
[16:17:45.458] result() for ClusterFuture ...
[16:17:45.458] - result already collected: FutureResult
[16:17:45.458] result() for ClusterFuture ... done
[16:17:45.459] result() for ClusterFuture ...
[16:17:45.459] - result already collected: FutureResult
[16:17:45.459] result() for ClusterFuture ... done
[16:17:45.459] result() for ClusterFuture ...
[16:17:45.459] - result already collected: FutureResult
[16:17:45.459] result() for ClusterFuture ... done
[16:17:45.459] result() for ClusterFuture ...
[16:17:45.459] - result already collected: FutureResult
[16:17:45.459] result() for ClusterFuture ... done
[16:17:45.459] - relayed: [n=2] TRUE, FALSE
[16:17:45.459] - queued futures: [n=2] TRUE, FALSE
[16:17:45.460] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:45.460]  length: 1 (resolved future 1)
[16:17:45.486] receiveMessageFromWorker() for ClusterFuture ...
[16:17:45.486] - Validating connection of MultisessionFuture
[16:17:45.486] - received message: FutureResult
[16:17:45.486] - Received FutureResult
[16:17:45.486] - Erased future from FutureRegistry
[16:17:45.486] result() for ClusterFuture ...
[16:17:45.486] - result already collected: FutureResult
[16:17:45.487] result() for ClusterFuture ... done
[16:17:45.487] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:45.487] Future #2
[16:17:45.487] result() for ClusterFuture ...
[16:17:45.487] - result already collected: FutureResult
[16:17:45.487] result() for ClusterFuture ... done
[16:17:45.487] result() for ClusterFuture ...
[16:17:45.487] - result already collected: FutureResult
[16:17:45.487] result() for ClusterFuture ... done
[16:17:45.487] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:45.487] - nx: 2
[16:17:45.488] - relay: TRUE
[16:17:45.488] - stdout: TRUE
[16:17:45.488] - signal: TRUE
[16:17:45.488] - resignal: FALSE
[16:17:45.488] - force: TRUE
[16:17:45.488] - relayed: [n=2] TRUE, FALSE
[16:17:45.488] - queued futures: [n=2] TRUE, FALSE
[16:17:45.488]  - until=2
[16:17:45.488]  - relaying element #2
[16:17:45.488] result() for ClusterFuture ...
[16:17:45.488] - result already collected: FutureResult
[16:17:45.489] result() for ClusterFuture ... done
[16:17:45.489] result() for ClusterFuture ...
[16:17:45.489] - result already collected: FutureResult
[16:17:45.489] result() for ClusterFuture ... done
[16:17:45.489] result() for ClusterFuture ...
[16:17:45.489] - result already collected: FutureResult
[16:17:45.489] result() for ClusterFuture ... done
[16:17:45.489] result() for ClusterFuture ...
[16:17:45.489] - result already collected: FutureResult
[16:17:45.489] result() for ClusterFuture ... done
[16:17:45.489] - relayed: [n=2] TRUE, TRUE
[16:17:45.489] - queued futures: [n=2] TRUE, TRUE
[16:17:45.490] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:45.490]  length: 0 (resolved future 2)
[16:17:45.490] Relaying remaining futures
[16:17:45.490] signalConditionsASAP(NULL, pos=0) ...
[16:17:45.490] - nx: 2
[16:17:45.490] - relay: TRUE
[16:17:45.490] - stdout: TRUE
[16:17:45.490] - signal: TRUE
[16:17:45.490] - resignal: FALSE
[16:17:45.490] - force: TRUE
[16:17:45.490] - relayed: [n=2] TRUE, TRUE
[16:17:45.491] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:45.491] - relayed: [n=2] TRUE, TRUE
[16:17:45.491] - queued futures: [n=2] TRUE, TRUE
[16:17:45.491] signalConditionsASAP(NULL, pos=0) ... done
[16:17:45.491] resolve() on list ... DONE
[16:17:45.491] result() for ClusterFuture ...
[16:17:45.491] - result already collected: FutureResult
[16:17:45.491] result() for ClusterFuture ... done
[16:17:45.491] result() for ClusterFuture ...
[16:17:45.491] - result already collected: FutureResult
[16:17:45.491] result() for ClusterFuture ... done
[16:17:45.492] result() for ClusterFuture ...
[16:17:45.492] - result already collected: FutureResult
[16:17:45.492] result() for ClusterFuture ... done
[16:17:45.492] result() for ClusterFuture ...
[16:17:45.492] - result already collected: FutureResult
[16:17:45.492] result() for ClusterFuture ... done
[16:17:45.492]  - Number of value chunks collected: 2
[16:17:45.492] Resolving 2 futures (chunks) ... DONE
[16:17:45.492] Reducing values from 2 chunks ...
[16:17:45.492]  - Number of values collected after concatenation: 2
[16:17:45.492]  - Number of values expected: 2
[16:17:45.493] Reducing values from 2 chunks ... DONE
[16:17:45.493] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:17:45.493] getGlobalsAndPackagesXApply() ...
[16:17:45.493]  - future.globals: TRUE
[16:17:45.493] getGlobalsAndPackages() ...
[16:17:45.493] Searching for globals...
[16:17:45.496] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:17:45.496] Searching for globals ... DONE
[16:17:45.496] Resolving globals: FALSE
[16:17:45.497] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:17:45.497] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:17:45.497] - globals: [1] ‘FUN’
[16:17:45.497] 
[16:17:45.497] getGlobalsAndPackages() ... DONE
[16:17:45.498]  - globals found/used: [n=1] ‘FUN’
[16:17:45.498]  - needed namespaces: [n=0] 
[16:17:45.498] Finding globals ... DONE
[16:17:45.498]  - use_args: TRUE
[16:17:45.498]  - Getting '...' globals ...
[16:17:45.498] resolve() on list ...
[16:17:45.498]  recursive: 0
[16:17:45.498]  length: 1
[16:17:45.499]  elements: ‘...’
[16:17:45.499]  length: 0 (resolved future 1)
[16:17:45.499] resolve() on list ... DONE
[16:17:45.499]    - '...' content: [n=0] 
[16:17:45.499] List of 1
[16:17:45.499]  $ ...: list()
[16:17:45.499]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.499]  - attr(*, "where")=List of 1
[16:17:45.499]   ..$ ...:<environment: 0x555be2cda8c0> 
[16:17:45.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.499]  - attr(*, "resolved")= logi TRUE
[16:17:45.499]  - attr(*, "total_size")= num NA
[16:17:45.502]  - Getting '...' globals ... DONE
[16:17:45.502] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:45.502] List of 2
[16:17:45.502]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:17:45.502]  $ ...          : list()
[16:17:45.502]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.502]  - attr(*, "where")=List of 2
[16:17:45.502]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:45.502]   ..$ ...          :<environment: 0x555be2cda8c0> 
[16:17:45.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.502]  - attr(*, "resolved")= logi FALSE
[16:17:45.502]  - attr(*, "total_size")= num 36296
[16:17:45.504] Packages to be attached in all futures: [n=0] 
[16:17:45.504] getGlobalsAndPackagesXApply() ... DONE
[16:17:45.508] future_lapply() ...
[16:17:45.510] Generating random seeds ...
[16:17:45.510] Generating random seed streams for 2 elements ...
[16:17:45.510] Generating random seed streams for 2 elements ... DONE
[16:17:45.510] Generating random seeds ... DONE
[16:17:45.510] Will set RNG state on exit: 10407, -846597894, -1749278745, -780187651, -246648567, 2141844765, 1622961131
[16:17:45.514] Number of chunks: 2
[16:17:45.514] getGlobalsAndPackagesXApply() ...
[16:17:45.514]  - future.globals: <name-value list> with names ‘list()’
[16:17:45.514]  - use_args: TRUE
[16:17:45.514] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:17:45.514] List of 2
[16:17:45.514]  $ ...          : list()
[16:17:45.514]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:45.514]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:17:45.514]  - attr(*, "where")=List of 2
[16:17:45.514]   ..$ ...          :<environment: 0x555be2cda8c0> 
[16:17:45.514]   ..$ ...future.FUN:<environment: namespace:base> 
[16:17:45.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:45.514]  - attr(*, "resolved")= logi FALSE
[16:17:45.514]  - attr(*, "total_size")= num NA
[16:17:45.518] Packages to be attached in all futures: [n=0] 
[16:17:45.518] getGlobalsAndPackagesXApply() ... DONE
[16:17:45.518] Number of futures (= number of chunks): 2
[16:17:45.518] Launching 2 futures (chunks) ...
[16:17:45.518] Chunk #1 of 2 ...
[16:17:45.518]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:45.518]  - seeds: [1] <seeds>
[16:17:45.518]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.519] getGlobalsAndPackages() ...
[16:17:45.519] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.519] Resolving globals: FALSE
[16:17:45.519] Tweak future expression to call with '...' arguments ...
[16:17:45.519] {
[16:17:45.519]     do.call(function(...) {
[16:17:45.519]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.519]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.519]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.519]             on.exit(options(oopts), add = TRUE)
[16:17:45.519]         }
[16:17:45.519]         {
[16:17:45.519]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.519]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.519]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:45.519]                   envir = globalenv(), inherits = FALSE)
[16:17:45.519]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.519]             })
[16:17:45.519]         }
[16:17:45.519]     }, args = future.call.arguments)
[16:17:45.519] }
[16:17:45.519] Tweak future expression to call with '...' arguments ... DONE
[16:17:45.520] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.520] 
[16:17:45.520] getGlobalsAndPackages() ... DONE
[16:17:45.520] run() for ‘Future’ ...
[16:17:45.520] - state: ‘created’
[16:17:45.520] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:45.534] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.534] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:45.534]   - Field: ‘node’
[16:17:45.534]   - Field: ‘label’
[16:17:45.534]   - Field: ‘local’
[16:17:45.534]   - Field: ‘owner’
[16:17:45.535]   - Field: ‘envir’
[16:17:45.535]   - Field: ‘workers’
[16:17:45.535]   - Field: ‘packages’
[16:17:45.535]   - Field: ‘gc’
[16:17:45.535]   - Field: ‘conditions’
[16:17:45.535]   - Field: ‘persistent’
[16:17:45.535]   - Field: ‘expr’
[16:17:45.535]   - Field: ‘uuid’
[16:17:45.535]   - Field: ‘seed’
[16:17:45.535]   - Field: ‘version’
[16:17:45.535]   - Field: ‘result’
[16:17:45.536]   - Field: ‘asynchronous’
[16:17:45.536]   - Field: ‘calls’
[16:17:45.536]   - Field: ‘globals’
[16:17:45.536]   - Field: ‘stdout’
[16:17:45.536]   - Field: ‘earlySignal’
[16:17:45.536]   - Field: ‘lazy’
[16:17:45.536]   - Field: ‘state’
[16:17:45.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:45.536] - Launch lazy future ...
[16:17:45.537] Packages needed by the future expression (n = 0): <none>
[16:17:45.537] Packages needed by future strategies (n = 0): <none>
[16:17:45.537] {
[16:17:45.537]     {
[16:17:45.537]         {
[16:17:45.537]             ...future.startTime <- base::Sys.time()
[16:17:45.537]             {
[16:17:45.537]                 {
[16:17:45.537]                   {
[16:17:45.537]                     {
[16:17:45.537]                       base::local({
[16:17:45.537]                         has_future <- base::requireNamespace("future", 
[16:17:45.537]                           quietly = TRUE)
[16:17:45.537]                         if (has_future) {
[16:17:45.537]                           ns <- base::getNamespace("future")
[16:17:45.537]                           version <- ns[[".package"]][["version"]]
[16:17:45.537]                           if (is.null(version)) 
[16:17:45.537]                             version <- utils::packageVersion("future")
[16:17:45.537]                         }
[16:17:45.537]                         else {
[16:17:45.537]                           version <- NULL
[16:17:45.537]                         }
[16:17:45.537]                         if (!has_future || version < "1.8.0") {
[16:17:45.537]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:45.537]                             "", base::R.version$version.string), 
[16:17:45.537]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:45.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:45.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:45.537]                               "release", "version")], collapse = " "), 
[16:17:45.537]                             hostname = base::Sys.info()[["nodename"]])
[16:17:45.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:45.537]                             info)
[16:17:45.537]                           info <- base::paste(info, collapse = "; ")
[16:17:45.537]                           if (!has_future) {
[16:17:45.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:45.537]                               info)
[16:17:45.537]                           }
[16:17:45.537]                           else {
[16:17:45.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:45.537]                               info, version)
[16:17:45.537]                           }
[16:17:45.537]                           base::stop(msg)
[16:17:45.537]                         }
[16:17:45.537]                       })
[16:17:45.537]                     }
[16:17:45.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:45.537]                     base::options(mc.cores = 1L)
[16:17:45.537]                   }
[16:17:45.537]                   ...future.strategy.old <- future::plan("list")
[16:17:45.537]                   options(future.plan = NULL)
[16:17:45.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:45.537]                 }
[16:17:45.537]                 ...future.workdir <- getwd()
[16:17:45.537]             }
[16:17:45.537]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:45.537]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:45.537]         }
[16:17:45.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:45.537]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:45.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:45.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:45.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:45.537]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:45.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:45.537]             base::names(...future.oldOptions))
[16:17:45.537]     }
[16:17:45.537]     if (FALSE) {
[16:17:45.537]     }
[16:17:45.537]     else {
[16:17:45.537]         if (TRUE) {
[16:17:45.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:45.537]                 open = "w")
[16:17:45.537]         }
[16:17:45.537]         else {
[16:17:45.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:45.537]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:45.537]         }
[16:17:45.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:45.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:45.537]             base::sink(type = "output", split = FALSE)
[16:17:45.537]             base::close(...future.stdout)
[16:17:45.537]         }, add = TRUE)
[16:17:45.537]     }
[16:17:45.537]     ...future.frame <- base::sys.nframe()
[16:17:45.537]     ...future.conditions <- base::list()
[16:17:45.537]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:45.537]     if (FALSE) {
[16:17:45.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:45.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:45.537]     }
[16:17:45.537]     ...future.result <- base::tryCatch({
[16:17:45.537]         base::withCallingHandlers({
[16:17:45.537]             ...future.value <- base::withVisible(base::local({
[16:17:45.537]                 ...future.makeSendCondition <- base::local({
[16:17:45.537]                   sendCondition <- NULL
[16:17:45.537]                   function(frame = 1L) {
[16:17:45.537]                     if (is.function(sendCondition)) 
[16:17:45.537]                       return(sendCondition)
[16:17:45.537]                     ns <- getNamespace("parallel")
[16:17:45.537]                     if (exists("sendData", mode = "function", 
[16:17:45.537]                       envir = ns)) {
[16:17:45.537]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:45.537]                         envir = ns)
[16:17:45.537]                       envir <- sys.frame(frame)
[16:17:45.537]                       master <- NULL
[16:17:45.537]                       while (!identical(envir, .GlobalEnv) && 
[16:17:45.537]                         !identical(envir, emptyenv())) {
[16:17:45.537]                         if (exists("master", mode = "list", envir = envir, 
[16:17:45.537]                           inherits = FALSE)) {
[16:17:45.537]                           master <- get("master", mode = "list", 
[16:17:45.537]                             envir = envir, inherits = FALSE)
[16:17:45.537]                           if (inherits(master, c("SOCKnode", 
[16:17:45.537]                             "SOCK0node"))) {
[16:17:45.537]                             sendCondition <<- function(cond) {
[16:17:45.537]                               data <- list(type = "VALUE", value = cond, 
[16:17:45.537]                                 success = TRUE)
[16:17:45.537]                               parallel_sendData(master, data)
[16:17:45.537]                             }
[16:17:45.537]                             return(sendCondition)
[16:17:45.537]                           }
[16:17:45.537]                         }
[16:17:45.537]                         frame <- frame + 1L
[16:17:45.537]                         envir <- sys.frame(frame)
[16:17:45.537]                       }
[16:17:45.537]                     }
[16:17:45.537]                     sendCondition <<- function(cond) NULL
[16:17:45.537]                   }
[16:17:45.537]                 })
[16:17:45.537]                 withCallingHandlers({
[16:17:45.537]                   {
[16:17:45.537]                     do.call(function(...) {
[16:17:45.537]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.537]                       if (!identical(...future.globals.maxSize.org, 
[16:17:45.537]                         ...future.globals.maxSize)) {
[16:17:45.537]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.537]                         on.exit(options(oopts), add = TRUE)
[16:17:45.537]                       }
[16:17:45.537]                       {
[16:17:45.537]                         lapply(seq_along(...future.elements_ii), 
[16:17:45.537]                           FUN = function(jj) {
[16:17:45.537]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.537]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:45.537]                               envir = globalenv(), inherits = FALSE)
[16:17:45.537]                             ...future.FUN(...future.X_jj, ...)
[16:17:45.537]                           })
[16:17:45.537]                       }
[16:17:45.537]                     }, args = future.call.arguments)
[16:17:45.537]                   }
[16:17:45.537]                 }, immediateCondition = function(cond) {
[16:17:45.537]                   sendCondition <- ...future.makeSendCondition()
[16:17:45.537]                   sendCondition(cond)
[16:17:45.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.537]                   {
[16:17:45.537]                     inherits <- base::inherits
[16:17:45.537]                     invokeRestart <- base::invokeRestart
[16:17:45.537]                     is.null <- base::is.null
[16:17:45.537]                     muffled <- FALSE
[16:17:45.537]                     if (inherits(cond, "message")) {
[16:17:45.537]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:45.537]                       if (muffled) 
[16:17:45.537]                         invokeRestart("muffleMessage")
[16:17:45.537]                     }
[16:17:45.537]                     else if (inherits(cond, "warning")) {
[16:17:45.537]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:45.537]                       if (muffled) 
[16:17:45.537]                         invokeRestart("muffleWarning")
[16:17:45.537]                     }
[16:17:45.537]                     else if (inherits(cond, "condition")) {
[16:17:45.537]                       if (!is.null(pattern)) {
[16:17:45.537]                         computeRestarts <- base::computeRestarts
[16:17:45.537]                         grepl <- base::grepl
[16:17:45.537]                         restarts <- computeRestarts(cond)
[16:17:45.537]                         for (restart in restarts) {
[16:17:45.537]                           name <- restart$name
[16:17:45.537]                           if (is.null(name)) 
[16:17:45.537]                             next
[16:17:45.537]                           if (!grepl(pattern, name)) 
[16:17:45.537]                             next
[16:17:45.537]                           invokeRestart(restart)
[16:17:45.537]                           muffled <- TRUE
[16:17:45.537]                           break
[16:17:45.537]                         }
[16:17:45.537]                       }
[16:17:45.537]                     }
[16:17:45.537]                     invisible(muffled)
[16:17:45.537]                   }
[16:17:45.537]                   muffleCondition(cond)
[16:17:45.537]                 })
[16:17:45.537]             }))
[16:17:45.537]             future::FutureResult(value = ...future.value$value, 
[16:17:45.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.537]                   ...future.rng), globalenv = if (FALSE) 
[16:17:45.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:45.537]                     ...future.globalenv.names))
[16:17:45.537]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:45.537]         }, condition = base::local({
[16:17:45.537]             c <- base::c
[16:17:45.537]             inherits <- base::inherits
[16:17:45.537]             invokeRestart <- base::invokeRestart
[16:17:45.537]             length <- base::length
[16:17:45.537]             list <- base::list
[16:17:45.537]             seq.int <- base::seq.int
[16:17:45.537]             signalCondition <- base::signalCondition
[16:17:45.537]             sys.calls <- base::sys.calls
[16:17:45.537]             `[[` <- base::`[[`
[16:17:45.537]             `+` <- base::`+`
[16:17:45.537]             `<<-` <- base::`<<-`
[16:17:45.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:45.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:45.537]                   3L)]
[16:17:45.537]             }
[16:17:45.537]             function(cond) {
[16:17:45.537]                 is_error <- inherits(cond, "error")
[16:17:45.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:45.537]                   NULL)
[16:17:45.537]                 if (is_error) {
[16:17:45.537]                   sessionInformation <- function() {
[16:17:45.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:45.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:45.537]                       search = base::search(), system = base::Sys.info())
[16:17:45.537]                   }
[16:17:45.537]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:45.537]                     cond$call), session = sessionInformation(), 
[16:17:45.537]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:45.537]                   signalCondition(cond)
[16:17:45.537]                 }
[16:17:45.537]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:17:45.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:45.537]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:45.537]                   if (TRUE && !signal) {
[16:17:45.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.537]                     {
[16:17:45.537]                       inherits <- base::inherits
[16:17:45.537]                       invokeRestart <- base::invokeRestart
[16:17:45.537]                       is.null <- base::is.null
[16:17:45.537]                       muffled <- FALSE
[16:17:45.537]                       if (inherits(cond, "message")) {
[16:17:45.537]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.537]                         if (muffled) 
[16:17:45.537]                           invokeRestart("muffleMessage")
[16:17:45.537]                       }
[16:17:45.537]                       else if (inherits(cond, "warning")) {
[16:17:45.537]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.537]                         if (muffled) 
[16:17:45.537]                           invokeRestart("muffleWarning")
[16:17:45.537]                       }
[16:17:45.537]                       else if (inherits(cond, "condition")) {
[16:17:45.537]                         if (!is.null(pattern)) {
[16:17:45.537]                           computeRestarts <- base::computeRestarts
[16:17:45.537]                           grepl <- base::grepl
[16:17:45.537]                           restarts <- computeRestarts(cond)
[16:17:45.537]                           for (restart in restarts) {
[16:17:45.537]                             name <- restart$name
[16:17:45.537]                             if (is.null(name)) 
[16:17:45.537]                               next
[16:17:45.537]                             if (!grepl(pattern, name)) 
[16:17:45.537]                               next
[16:17:45.537]                             invokeRestart(restart)
[16:17:45.537]                             muffled <- TRUE
[16:17:45.537]                             break
[16:17:45.537]                           }
[16:17:45.537]                         }
[16:17:45.537]                       }
[16:17:45.537]                       invisible(muffled)
[16:17:45.537]                     }
[16:17:45.537]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.537]                   }
[16:17:45.537]                 }
[16:17:45.537]                 else {
[16:17:45.537]                   if (TRUE) {
[16:17:45.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.537]                     {
[16:17:45.537]                       inherits <- base::inherits
[16:17:45.537]                       invokeRestart <- base::invokeRestart
[16:17:45.537]                       is.null <- base::is.null
[16:17:45.537]                       muffled <- FALSE
[16:17:45.537]                       if (inherits(cond, "message")) {
[16:17:45.537]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.537]                         if (muffled) 
[16:17:45.537]                           invokeRestart("muffleMessage")
[16:17:45.537]                       }
[16:17:45.537]                       else if (inherits(cond, "warning")) {
[16:17:45.537]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.537]                         if (muffled) 
[16:17:45.537]                           invokeRestart("muffleWarning")
[16:17:45.537]                       }
[16:17:45.537]                       else if (inherits(cond, "condition")) {
[16:17:45.537]                         if (!is.null(pattern)) {
[16:17:45.537]                           computeRestarts <- base::computeRestarts
[16:17:45.537]                           grepl <- base::grepl
[16:17:45.537]                           restarts <- computeRestarts(cond)
[16:17:45.537]                           for (restart in restarts) {
[16:17:45.537]                             name <- restart$name
[16:17:45.537]                             if (is.null(name)) 
[16:17:45.537]                               next
[16:17:45.537]                             if (!grepl(pattern, name)) 
[16:17:45.537]                               next
[16:17:45.537]                             invokeRestart(restart)
[16:17:45.537]                             muffled <- TRUE
[16:17:45.537]                             break
[16:17:45.537]                           }
[16:17:45.537]                         }
[16:17:45.537]                       }
[16:17:45.537]                       invisible(muffled)
[16:17:45.537]                     }
[16:17:45.537]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.537]                   }
[16:17:45.537]                 }
[16:17:45.537]             }
[16:17:45.537]         }))
[16:17:45.537]     }, error = function(ex) {
[16:17:45.537]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:45.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.537]                 ...future.rng), started = ...future.startTime, 
[16:17:45.537]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:45.537]             version = "1.8"), class = "FutureResult")
[16:17:45.537]     }, finally = {
[16:17:45.537]         if (!identical(...future.workdir, getwd())) 
[16:17:45.537]             setwd(...future.workdir)
[16:17:45.537]         {
[16:17:45.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:45.537]                 ...future.oldOptions$nwarnings <- NULL
[16:17:45.537]             }
[16:17:45.537]             base::options(...future.oldOptions)
[16:17:45.537]             if (.Platform$OS.type == "windows") {
[16:17:45.537]                 old_names <- names(...future.oldEnvVars)
[16:17:45.537]                 envs <- base::Sys.getenv()
[16:17:45.537]                 names <- names(envs)
[16:17:45.537]                 common <- intersect(names, old_names)
[16:17:45.537]                 added <- setdiff(names, old_names)
[16:17:45.537]                 removed <- setdiff(old_names, names)
[16:17:45.537]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:45.537]                   envs[common]]
[16:17:45.537]                 NAMES <- toupper(changed)
[16:17:45.537]                 args <- list()
[16:17:45.537]                 for (kk in seq_along(NAMES)) {
[16:17:45.537]                   name <- changed[[kk]]
[16:17:45.537]                   NAME <- NAMES[[kk]]
[16:17:45.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.537]                     next
[16:17:45.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.537]                 }
[16:17:45.537]                 NAMES <- toupper(added)
[16:17:45.537]                 for (kk in seq_along(NAMES)) {
[16:17:45.537]                   name <- added[[kk]]
[16:17:45.537]                   NAME <- NAMES[[kk]]
[16:17:45.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.537]                     next
[16:17:45.537]                   args[[name]] <- ""
[16:17:45.537]                 }
[16:17:45.537]                 NAMES <- toupper(removed)
[16:17:45.537]                 for (kk in seq_along(NAMES)) {
[16:17:45.537]                   name <- removed[[kk]]
[16:17:45.537]                   NAME <- NAMES[[kk]]
[16:17:45.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.537]                     next
[16:17:45.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.537]                 }
[16:17:45.537]                 if (length(args) > 0) 
[16:17:45.537]                   base::do.call(base::Sys.setenv, args = args)
[16:17:45.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:45.537]             }
[16:17:45.537]             else {
[16:17:45.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:45.537]             }
[16:17:45.537]             {
[16:17:45.537]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:45.537]                   0L) {
[16:17:45.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:45.537]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:45.537]                   base::options(opts)
[16:17:45.537]                 }
[16:17:45.537]                 {
[16:17:45.537]                   {
[16:17:45.537]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:45.537]                     NULL
[16:17:45.537]                   }
[16:17:45.537]                   options(future.plan = NULL)
[16:17:45.537]                   if (is.na(NA_character_)) 
[16:17:45.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:45.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:45.537]                     .init = FALSE)
[16:17:45.537]                 }
[16:17:45.537]             }
[16:17:45.537]         }
[16:17:45.537]     })
[16:17:45.537]     if (TRUE) {
[16:17:45.537]         base::sink(type = "output", split = FALSE)
[16:17:45.537]         if (TRUE) {
[16:17:45.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:45.537]         }
[16:17:45.537]         else {
[16:17:45.537]             ...future.result["stdout"] <- base::list(NULL)
[16:17:45.537]         }
[16:17:45.537]         base::close(...future.stdout)
[16:17:45.537]         ...future.stdout <- NULL
[16:17:45.537]     }
[16:17:45.537]     ...future.result$conditions <- ...future.conditions
[16:17:45.537]     ...future.result$finished <- base::Sys.time()
[16:17:45.537]     ...future.result
[16:17:45.537] }
[16:17:45.540] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[16:17:45.540] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:45.541] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:45.541] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[16:17:45.584] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[16:17:45.585] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:17:45.585] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:17:45.586] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[16:17:45.586] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[16:17:45.586] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:17:45.586] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:17:45.586] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[16:17:45.587] MultisessionFuture started
[16:17:45.587] - Launch lazy future ... done
[16:17:45.587] run() for ‘MultisessionFuture’ ... done
[16:17:45.587] Created future:
[16:17:45.587] MultisessionFuture:
[16:17:45.587] Label: ‘future_apply-1’
[16:17:45.587] Expression:
[16:17:45.587] {
[16:17:45.587]     do.call(function(...) {
[16:17:45.587]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.587]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.587]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.587]             on.exit(options(oopts), add = TRUE)
[16:17:45.587]         }
[16:17:45.587]         {
[16:17:45.587]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.587]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.587]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:45.587]                   envir = globalenv(), inherits = FALSE)
[16:17:45.587]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.587]             })
[16:17:45.587]         }
[16:17:45.587]     }, args = future.call.arguments)
[16:17:45.587] }
[16:17:45.587] Lazy evaluation: FALSE
[16:17:45.587] Asynchronous evaluation: TRUE
[16:17:45.587] Local evaluation: TRUE
[16:17:45.587] Environment: R_GlobalEnv
[16:17:45.587] Capture standard output: TRUE
[16:17:45.587] Capture condition classes: <none>
[16:17:45.587] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:45.587] Packages: <none>
[16:17:45.587] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:17:45.587] Resolved: FALSE
[16:17:45.587] Value: <not collected>
[16:17:45.587] Conditions captured: <none>
[16:17:45.587] Early signaling: FALSE
[16:17:45.587] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:45.587] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.599] Chunk #1 of 2 ... DONE
[16:17:45.599] Chunk #2 of 2 ...
[16:17:45.599]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:17:45.599]  - seeds: [1] <seeds>
[16:17:45.599]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.600] getGlobalsAndPackages() ...
[16:17:45.600] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.600] Resolving globals: FALSE
[16:17:45.600] Tweak future expression to call with '...' arguments ...
[16:17:45.600] {
[16:17:45.600]     do.call(function(...) {
[16:17:45.600]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.600]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.600]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.600]             on.exit(options(oopts), add = TRUE)
[16:17:45.600]         }
[16:17:45.600]         {
[16:17:45.600]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.600]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.600]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:45.600]                   envir = globalenv(), inherits = FALSE)
[16:17:45.600]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.600]             })
[16:17:45.600]         }
[16:17:45.600]     }, args = future.call.arguments)
[16:17:45.600] }
[16:17:45.600] Tweak future expression to call with '...' arguments ... DONE
[16:17:45.601] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:45.601] 
[16:17:45.601] getGlobalsAndPackages() ... DONE
[16:17:45.601] run() for ‘Future’ ...
[16:17:45.601] - state: ‘created’
[16:17:45.601] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:45.615] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.615] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:45.615]   - Field: ‘node’
[16:17:45.615]   - Field: ‘label’
[16:17:45.615]   - Field: ‘local’
[16:17:45.616]   - Field: ‘owner’
[16:17:45.616]   - Field: ‘envir’
[16:17:45.616]   - Field: ‘workers’
[16:17:45.616]   - Field: ‘packages’
[16:17:45.616]   - Field: ‘gc’
[16:17:45.616]   - Field: ‘conditions’
[16:17:45.616]   - Field: ‘persistent’
[16:17:45.616]   - Field: ‘expr’
[16:17:45.616]   - Field: ‘uuid’
[16:17:45.616]   - Field: ‘seed’
[16:17:45.617]   - Field: ‘version’
[16:17:45.617]   - Field: ‘result’
[16:17:45.617]   - Field: ‘asynchronous’
[16:17:45.617]   - Field: ‘calls’
[16:17:45.617]   - Field: ‘globals’
[16:17:45.617]   - Field: ‘stdout’
[16:17:45.617]   - Field: ‘earlySignal’
[16:17:45.617]   - Field: ‘lazy’
[16:17:45.617]   - Field: ‘state’
[16:17:45.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:45.617] - Launch lazy future ...
[16:17:45.618] Packages needed by the future expression (n = 0): <none>
[16:17:45.618] Packages needed by future strategies (n = 0): <none>
[16:17:45.618] {
[16:17:45.618]     {
[16:17:45.618]         {
[16:17:45.618]             ...future.startTime <- base::Sys.time()
[16:17:45.618]             {
[16:17:45.618]                 {
[16:17:45.618]                   {
[16:17:45.618]                     {
[16:17:45.618]                       base::local({
[16:17:45.618]                         has_future <- base::requireNamespace("future", 
[16:17:45.618]                           quietly = TRUE)
[16:17:45.618]                         if (has_future) {
[16:17:45.618]                           ns <- base::getNamespace("future")
[16:17:45.618]                           version <- ns[[".package"]][["version"]]
[16:17:45.618]                           if (is.null(version)) 
[16:17:45.618]                             version <- utils::packageVersion("future")
[16:17:45.618]                         }
[16:17:45.618]                         else {
[16:17:45.618]                           version <- NULL
[16:17:45.618]                         }
[16:17:45.618]                         if (!has_future || version < "1.8.0") {
[16:17:45.618]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:45.618]                             "", base::R.version$version.string), 
[16:17:45.618]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:45.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:45.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:45.618]                               "release", "version")], collapse = " "), 
[16:17:45.618]                             hostname = base::Sys.info()[["nodename"]])
[16:17:45.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:45.618]                             info)
[16:17:45.618]                           info <- base::paste(info, collapse = "; ")
[16:17:45.618]                           if (!has_future) {
[16:17:45.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:45.618]                               info)
[16:17:45.618]                           }
[16:17:45.618]                           else {
[16:17:45.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:45.618]                               info, version)
[16:17:45.618]                           }
[16:17:45.618]                           base::stop(msg)
[16:17:45.618]                         }
[16:17:45.618]                       })
[16:17:45.618]                     }
[16:17:45.618]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:45.618]                     base::options(mc.cores = 1L)
[16:17:45.618]                   }
[16:17:45.618]                   ...future.strategy.old <- future::plan("list")
[16:17:45.618]                   options(future.plan = NULL)
[16:17:45.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:45.618]                 }
[16:17:45.618]                 ...future.workdir <- getwd()
[16:17:45.618]             }
[16:17:45.618]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:45.618]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:45.618]         }
[16:17:45.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:45.618]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:17:45.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:45.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:45.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:45.618]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:45.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:45.618]             base::names(...future.oldOptions))
[16:17:45.618]     }
[16:17:45.618]     if (FALSE) {
[16:17:45.618]     }
[16:17:45.618]     else {
[16:17:45.618]         if (TRUE) {
[16:17:45.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:45.618]                 open = "w")
[16:17:45.618]         }
[16:17:45.618]         else {
[16:17:45.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:45.618]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:45.618]         }
[16:17:45.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:45.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:45.618]             base::sink(type = "output", split = FALSE)
[16:17:45.618]             base::close(...future.stdout)
[16:17:45.618]         }, add = TRUE)
[16:17:45.618]     }
[16:17:45.618]     ...future.frame <- base::sys.nframe()
[16:17:45.618]     ...future.conditions <- base::list()
[16:17:45.618]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:45.618]     if (FALSE) {
[16:17:45.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:45.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:45.618]     }
[16:17:45.618]     ...future.result <- base::tryCatch({
[16:17:45.618]         base::withCallingHandlers({
[16:17:45.618]             ...future.value <- base::withVisible(base::local({
[16:17:45.618]                 ...future.makeSendCondition <- base::local({
[16:17:45.618]                   sendCondition <- NULL
[16:17:45.618]                   function(frame = 1L) {
[16:17:45.618]                     if (is.function(sendCondition)) 
[16:17:45.618]                       return(sendCondition)
[16:17:45.618]                     ns <- getNamespace("parallel")
[16:17:45.618]                     if (exists("sendData", mode = "function", 
[16:17:45.618]                       envir = ns)) {
[16:17:45.618]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:45.618]                         envir = ns)
[16:17:45.618]                       envir <- sys.frame(frame)
[16:17:45.618]                       master <- NULL
[16:17:45.618]                       while (!identical(envir, .GlobalEnv) && 
[16:17:45.618]                         !identical(envir, emptyenv())) {
[16:17:45.618]                         if (exists("master", mode = "list", envir = envir, 
[16:17:45.618]                           inherits = FALSE)) {
[16:17:45.618]                           master <- get("master", mode = "list", 
[16:17:45.618]                             envir = envir, inherits = FALSE)
[16:17:45.618]                           if (inherits(master, c("SOCKnode", 
[16:17:45.618]                             "SOCK0node"))) {
[16:17:45.618]                             sendCondition <<- function(cond) {
[16:17:45.618]                               data <- list(type = "VALUE", value = cond, 
[16:17:45.618]                                 success = TRUE)
[16:17:45.618]                               parallel_sendData(master, data)
[16:17:45.618]                             }
[16:17:45.618]                             return(sendCondition)
[16:17:45.618]                           }
[16:17:45.618]                         }
[16:17:45.618]                         frame <- frame + 1L
[16:17:45.618]                         envir <- sys.frame(frame)
[16:17:45.618]                       }
[16:17:45.618]                     }
[16:17:45.618]                     sendCondition <<- function(cond) NULL
[16:17:45.618]                   }
[16:17:45.618]                 })
[16:17:45.618]                 withCallingHandlers({
[16:17:45.618]                   {
[16:17:45.618]                     do.call(function(...) {
[16:17:45.618]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.618]                       if (!identical(...future.globals.maxSize.org, 
[16:17:45.618]                         ...future.globals.maxSize)) {
[16:17:45.618]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.618]                         on.exit(options(oopts), add = TRUE)
[16:17:45.618]                       }
[16:17:45.618]                       {
[16:17:45.618]                         lapply(seq_along(...future.elements_ii), 
[16:17:45.618]                           FUN = function(jj) {
[16:17:45.618]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.618]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:45.618]                               envir = globalenv(), inherits = FALSE)
[16:17:45.618]                             ...future.FUN(...future.X_jj, ...)
[16:17:45.618]                           })
[16:17:45.618]                       }
[16:17:45.618]                     }, args = future.call.arguments)
[16:17:45.618]                   }
[16:17:45.618]                 }, immediateCondition = function(cond) {
[16:17:45.618]                   sendCondition <- ...future.makeSendCondition()
[16:17:45.618]                   sendCondition(cond)
[16:17:45.618]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.618]                   {
[16:17:45.618]                     inherits <- base::inherits
[16:17:45.618]                     invokeRestart <- base::invokeRestart
[16:17:45.618]                     is.null <- base::is.null
[16:17:45.618]                     muffled <- FALSE
[16:17:45.618]                     if (inherits(cond, "message")) {
[16:17:45.618]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:45.618]                       if (muffled) 
[16:17:45.618]                         invokeRestart("muffleMessage")
[16:17:45.618]                     }
[16:17:45.618]                     else if (inherits(cond, "warning")) {
[16:17:45.618]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:45.618]                       if (muffled) 
[16:17:45.618]                         invokeRestart("muffleWarning")
[16:17:45.618]                     }
[16:17:45.618]                     else if (inherits(cond, "condition")) {
[16:17:45.618]                       if (!is.null(pattern)) {
[16:17:45.618]                         computeRestarts <- base::computeRestarts
[16:17:45.618]                         grepl <- base::grepl
[16:17:45.618]                         restarts <- computeRestarts(cond)
[16:17:45.618]                         for (restart in restarts) {
[16:17:45.618]                           name <- restart$name
[16:17:45.618]                           if (is.null(name)) 
[16:17:45.618]                             next
[16:17:45.618]                           if (!grepl(pattern, name)) 
[16:17:45.618]                             next
[16:17:45.618]                           invokeRestart(restart)
[16:17:45.618]                           muffled <- TRUE
[16:17:45.618]                           break
[16:17:45.618]                         }
[16:17:45.618]                       }
[16:17:45.618]                     }
[16:17:45.618]                     invisible(muffled)
[16:17:45.618]                   }
[16:17:45.618]                   muffleCondition(cond)
[16:17:45.618]                 })
[16:17:45.618]             }))
[16:17:45.618]             future::FutureResult(value = ...future.value$value, 
[16:17:45.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.618]                   ...future.rng), globalenv = if (FALSE) 
[16:17:45.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:45.618]                     ...future.globalenv.names))
[16:17:45.618]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:45.618]         }, condition = base::local({
[16:17:45.618]             c <- base::c
[16:17:45.618]             inherits <- base::inherits
[16:17:45.618]             invokeRestart <- base::invokeRestart
[16:17:45.618]             length <- base::length
[16:17:45.618]             list <- base::list
[16:17:45.618]             seq.int <- base::seq.int
[16:17:45.618]             signalCondition <- base::signalCondition
[16:17:45.618]             sys.calls <- base::sys.calls
[16:17:45.618]             `[[` <- base::`[[`
[16:17:45.618]             `+` <- base::`+`
[16:17:45.618]             `<<-` <- base::`<<-`
[16:17:45.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:45.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:45.618]                   3L)]
[16:17:45.618]             }
[16:17:45.618]             function(cond) {
[16:17:45.618]                 is_error <- inherits(cond, "error")
[16:17:45.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:45.618]                   NULL)
[16:17:45.618]                 if (is_error) {
[16:17:45.618]                   sessionInformation <- function() {
[16:17:45.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:45.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:45.618]                       search = base::search(), system = base::Sys.info())
[16:17:45.618]                   }
[16:17:45.618]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:45.618]                     cond$call), session = sessionInformation(), 
[16:17:45.618]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:45.618]                   signalCondition(cond)
[16:17:45.618]                 }
[16:17:45.618]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:17:45.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:45.618]                   ...future.conditions[[length(...future.conditions) + 
[16:17:45.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:45.618]                   if (TRUE && !signal) {
[16:17:45.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.618]                     {
[16:17:45.618]                       inherits <- base::inherits
[16:17:45.618]                       invokeRestart <- base::invokeRestart
[16:17:45.618]                       is.null <- base::is.null
[16:17:45.618]                       muffled <- FALSE
[16:17:45.618]                       if (inherits(cond, "message")) {
[16:17:45.618]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.618]                         if (muffled) 
[16:17:45.618]                           invokeRestart("muffleMessage")
[16:17:45.618]                       }
[16:17:45.618]                       else if (inherits(cond, "warning")) {
[16:17:45.618]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.618]                         if (muffled) 
[16:17:45.618]                           invokeRestart("muffleWarning")
[16:17:45.618]                       }
[16:17:45.618]                       else if (inherits(cond, "condition")) {
[16:17:45.618]                         if (!is.null(pattern)) {
[16:17:45.618]                           computeRestarts <- base::computeRestarts
[16:17:45.618]                           grepl <- base::grepl
[16:17:45.618]                           restarts <- computeRestarts(cond)
[16:17:45.618]                           for (restart in restarts) {
[16:17:45.618]                             name <- restart$name
[16:17:45.618]                             if (is.null(name)) 
[16:17:45.618]                               next
[16:17:45.618]                             if (!grepl(pattern, name)) 
[16:17:45.618]                               next
[16:17:45.618]                             invokeRestart(restart)
[16:17:45.618]                             muffled <- TRUE
[16:17:45.618]                             break
[16:17:45.618]                           }
[16:17:45.618]                         }
[16:17:45.618]                       }
[16:17:45.618]                       invisible(muffled)
[16:17:45.618]                     }
[16:17:45.618]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.618]                   }
[16:17:45.618]                 }
[16:17:45.618]                 else {
[16:17:45.618]                   if (TRUE) {
[16:17:45.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:45.618]                     {
[16:17:45.618]                       inherits <- base::inherits
[16:17:45.618]                       invokeRestart <- base::invokeRestart
[16:17:45.618]                       is.null <- base::is.null
[16:17:45.618]                       muffled <- FALSE
[16:17:45.618]                       if (inherits(cond, "message")) {
[16:17:45.618]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:45.618]                         if (muffled) 
[16:17:45.618]                           invokeRestart("muffleMessage")
[16:17:45.618]                       }
[16:17:45.618]                       else if (inherits(cond, "warning")) {
[16:17:45.618]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:45.618]                         if (muffled) 
[16:17:45.618]                           invokeRestart("muffleWarning")
[16:17:45.618]                       }
[16:17:45.618]                       else if (inherits(cond, "condition")) {
[16:17:45.618]                         if (!is.null(pattern)) {
[16:17:45.618]                           computeRestarts <- base::computeRestarts
[16:17:45.618]                           grepl <- base::grepl
[16:17:45.618]                           restarts <- computeRestarts(cond)
[16:17:45.618]                           for (restart in restarts) {
[16:17:45.618]                             name <- restart$name
[16:17:45.618]                             if (is.null(name)) 
[16:17:45.618]                               next
[16:17:45.618]                             if (!grepl(pattern, name)) 
[16:17:45.618]                               next
[16:17:45.618]                             invokeRestart(restart)
[16:17:45.618]                             muffled <- TRUE
[16:17:45.618]                             break
[16:17:45.618]                           }
[16:17:45.618]                         }
[16:17:45.618]                       }
[16:17:45.618]                       invisible(muffled)
[16:17:45.618]                     }
[16:17:45.618]                     muffleCondition(cond, pattern = "^muffle")
[16:17:45.618]                   }
[16:17:45.618]                 }
[16:17:45.618]             }
[16:17:45.618]         }))
[16:17:45.618]     }, error = function(ex) {
[16:17:45.618]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:45.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:45.618]                 ...future.rng), started = ...future.startTime, 
[16:17:45.618]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:45.618]             version = "1.8"), class = "FutureResult")
[16:17:45.618]     }, finally = {
[16:17:45.618]         if (!identical(...future.workdir, getwd())) 
[16:17:45.618]             setwd(...future.workdir)
[16:17:45.618]         {
[16:17:45.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:45.618]                 ...future.oldOptions$nwarnings <- NULL
[16:17:45.618]             }
[16:17:45.618]             base::options(...future.oldOptions)
[16:17:45.618]             if (.Platform$OS.type == "windows") {
[16:17:45.618]                 old_names <- names(...future.oldEnvVars)
[16:17:45.618]                 envs <- base::Sys.getenv()
[16:17:45.618]                 names <- names(envs)
[16:17:45.618]                 common <- intersect(names, old_names)
[16:17:45.618]                 added <- setdiff(names, old_names)
[16:17:45.618]                 removed <- setdiff(old_names, names)
[16:17:45.618]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:45.618]                   envs[common]]
[16:17:45.618]                 NAMES <- toupper(changed)
[16:17:45.618]                 args <- list()
[16:17:45.618]                 for (kk in seq_along(NAMES)) {
[16:17:45.618]                   name <- changed[[kk]]
[16:17:45.618]                   NAME <- NAMES[[kk]]
[16:17:45.618]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.618]                     next
[16:17:45.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.618]                 }
[16:17:45.618]                 NAMES <- toupper(added)
[16:17:45.618]                 for (kk in seq_along(NAMES)) {
[16:17:45.618]                   name <- added[[kk]]
[16:17:45.618]                   NAME <- NAMES[[kk]]
[16:17:45.618]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.618]                     next
[16:17:45.618]                   args[[name]] <- ""
[16:17:45.618]                 }
[16:17:45.618]                 NAMES <- toupper(removed)
[16:17:45.618]                 for (kk in seq_along(NAMES)) {
[16:17:45.618]                   name <- removed[[kk]]
[16:17:45.618]                   NAME <- NAMES[[kk]]
[16:17:45.618]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:45.618]                     next
[16:17:45.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:45.618]                 }
[16:17:45.618]                 if (length(args) > 0) 
[16:17:45.618]                   base::do.call(base::Sys.setenv, args = args)
[16:17:45.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:45.618]             }
[16:17:45.618]             else {
[16:17:45.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:45.618]             }
[16:17:45.618]             {
[16:17:45.618]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:45.618]                   0L) {
[16:17:45.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:45.618]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:45.618]                   base::options(opts)
[16:17:45.618]                 }
[16:17:45.618]                 {
[16:17:45.618]                   {
[16:17:45.618]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:45.618]                     NULL
[16:17:45.618]                   }
[16:17:45.618]                   options(future.plan = NULL)
[16:17:45.618]                   if (is.na(NA_character_)) 
[16:17:45.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:45.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:45.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:45.618]                     .init = FALSE)
[16:17:45.618]                 }
[16:17:45.618]             }
[16:17:45.618]         }
[16:17:45.618]     })
[16:17:45.618]     if (TRUE) {
[16:17:45.618]         base::sink(type = "output", split = FALSE)
[16:17:45.618]         if (TRUE) {
[16:17:45.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:45.618]         }
[16:17:45.618]         else {
[16:17:45.618]             ...future.result["stdout"] <- base::list(NULL)
[16:17:45.618]         }
[16:17:45.618]         base::close(...future.stdout)
[16:17:45.618]         ...future.stdout <- NULL
[16:17:45.618]     }
[16:17:45.618]     ...future.result$conditions <- ...future.conditions
[16:17:45.618]     ...future.result$finished <- base::Sys.time()
[16:17:45.618]     ...future.result
[16:17:45.618] }
[16:17:45.621] Exporting 5 global objects (35.63 KiB) to cluster node #2 ...
[16:17:45.622] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:45.622] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:45.623] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[16:17:45.664] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[16:17:45.665] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:17:45.665] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:17:45.665] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[16:17:45.666] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[16:17:45.666] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:17:45.666] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:17:45.666] Exporting 5 global objects (35.63 KiB) to cluster node #2 ... DONE
[16:17:45.667] MultisessionFuture started
[16:17:45.667] - Launch lazy future ... done
[16:17:45.667] run() for ‘MultisessionFuture’ ... done
[16:17:45.667] Created future:
[16:17:45.667] MultisessionFuture:
[16:17:45.667] Label: ‘future_apply-2’
[16:17:45.667] Expression:
[16:17:45.667] {
[16:17:45.667]     do.call(function(...) {
[16:17:45.667]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:45.667]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:45.667]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:45.667]             on.exit(options(oopts), add = TRUE)
[16:17:45.667]         }
[16:17:45.667]         {
[16:17:45.667]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:45.667]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:45.667]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:17:45.667]                   envir = globalenv(), inherits = FALSE)
[16:17:45.667]                 ...future.FUN(...future.X_jj, ...)
[16:17:45.667]             })
[16:17:45.667]         }
[16:17:45.667]     }, args = future.call.arguments)
[16:17:45.667] }
[16:17:45.667] Lazy evaluation: FALSE
[16:17:45.667] Asynchronous evaluation: TRUE
[16:17:45.667] Local evaluation: TRUE
[16:17:45.667] Environment: R_GlobalEnv
[16:17:45.667] Capture standard output: TRUE
[16:17:45.667] Capture condition classes: <none>
[16:17:45.667] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:17:45.667] Packages: <none>
[16:17:45.667] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:17:45.667] Resolved: FALSE
[16:17:45.667] Value: <not collected>
[16:17:45.667] Conditions captured: <none>
[16:17:45.667] Early signaling: FALSE
[16:17:45.667] Owner process: 160b8488-6835-2df7-1b22-a41309bb56d8
[16:17:45.667] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:45.679] Chunk #2 of 2 ... DONE
[16:17:45.679] Launching 2 futures (chunks) ... DONE
[16:17:45.679] Resolving 2 futures (chunks) ...
[16:17:45.679] resolve() on list ...
[16:17:45.679]  recursive: 0
[16:17:45.679]  length: 2
[16:17:45.679] 
[16:17:45.680] receiveMessageFromWorker() for ClusterFuture ...
[16:17:45.682] - Validating connection of MultisessionFuture
[16:17:45.682] - received message: FutureResult
[16:17:45.682] - Received FutureResult
[16:17:45.683] - Erased future from FutureRegistry
[16:17:45.683] result() for ClusterFuture ...
[16:17:45.683] - result already collected: FutureResult
[16:17:45.683] result() for ClusterFuture ... done
[16:17:45.683] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:45.683] Future #1
[16:17:45.683] result() for ClusterFuture ...
[16:17:45.683] - result already collected: FutureResult
[16:17:45.683] result() for ClusterFuture ... done
[16:17:45.683] result() for ClusterFuture ...
[16:17:45.683] - result already collected: FutureResult
[16:17:45.683] result() for ClusterFuture ... done
[16:17:45.684] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:45.684] - nx: 2
[16:17:45.684] - relay: TRUE
[16:17:45.684] - stdout: TRUE
[16:17:45.684] - signal: TRUE
[16:17:45.684] - resignal: FALSE
[16:17:45.684] - force: TRUE
[16:17:45.684] - relayed: [n=2] FALSE, FALSE
[16:17:45.684] - queued futures: [n=2] FALSE, FALSE
[16:17:45.684]  - until=1
[16:17:45.684]  - relaying element #1
[16:17:45.685] result() for ClusterFuture ...
[16:17:45.685] - result already collected: FutureResult
[16:17:45.685] result() for ClusterFuture ... done
[16:17:45.685] result() for ClusterFuture ...
[16:17:45.685] - result already collected: FutureResult
[16:17:45.685] result() for ClusterFuture ... done
[16:17:45.685] result() for ClusterFuture ...
[16:17:45.685] - result already collected: FutureResult
[16:17:45.685] result() for ClusterFuture ... done
[16:17:45.685] result() for ClusterFuture ...
[16:17:45.685] - result already collected: FutureResult
[16:17:45.685] result() for ClusterFuture ... done
[16:17:45.686] - relayed: [n=2] TRUE, FALSE
[16:17:45.686] - queued futures: [n=2] TRUE, FALSE
[16:17:45.686] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:45.686]  length: 1 (resolved future 1)
[16:17:45.710] receiveMessageFromWorker() for ClusterFuture ...
[16:17:45.710] - Validating connection of MultisessionFuture
[16:17:45.710] - received message: FutureResult
[16:17:45.710] - Received FutureResult
[16:17:45.710] - Erased future from FutureRegistry
[16:17:45.710] result() for ClusterFuture ...
[16:17:45.710] - result already collected: FutureResult
[16:17:45.710] result() for ClusterFuture ... done
[16:17:45.711] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:45.711] Future #2
[16:17:45.711] result() for ClusterFuture ...
[16:17:45.711] - result already collected: FutureResult
[16:17:45.711] result() for ClusterFuture ... done
[16:17:45.711] result() for ClusterFuture ...
[16:17:45.711] - result already collected: FutureResult
[16:17:45.711] result() for ClusterFuture ... done
[16:17:45.711] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:45.711] - nx: 2
[16:17:45.711] - relay: TRUE
[16:17:45.712] - stdout: TRUE
[16:17:45.712] - signal: TRUE
[16:17:45.712] - resignal: FALSE
[16:17:45.712] - force: TRUE
[16:17:45.712] - relayed: [n=2] TRUE, FALSE
[16:17:45.712] - queued futures: [n=2] TRUE, FALSE
[16:17:45.712]  - until=2
[16:17:45.712]  - relaying element #2
[16:17:45.712] result() for ClusterFuture ...
[16:17:45.712] - result already collected: FutureResult
[16:17:45.712] result() for ClusterFuture ... done
[16:17:45.712] result() for ClusterFuture ...
[16:17:45.713] - result already collected: FutureResult
[16:17:45.713] result() for ClusterFuture ... done
[16:17:45.713] result() for ClusterFuture ...
[16:17:45.713] - result already collected: FutureResult
[16:17:45.713] result() for ClusterFuture ... done
[16:17:45.713] result() for ClusterFuture ...
[16:17:45.713] - result already collected: FutureResult
[16:17:45.713] result() for ClusterFuture ... done
[16:17:45.713] - relayed: [n=2] TRUE, TRUE
[16:17:45.713] - queued futures: [n=2] TRUE, TRUE
[16:17:45.714] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:45.714]  length: 0 (resolved future 2)
[16:17:45.714] Relaying remaining futures
[16:17:45.714] signalConditionsASAP(NULL, pos=0) ...
[16:17:45.714] - nx: 2
[16:17:45.714] - relay: TRUE
[16:17:45.714] - stdout: TRUE
[16:17:45.714] - signal: TRUE
[16:17:45.714] - resignal: FALSE
[16:17:45.714] - force: TRUE
[16:17:45.714] - relayed: [n=2] TRUE, TRUE
[16:17:45.714] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:45.715] - relayed: [n=2] TRUE, TRUE
[16:17:45.715] - queued futures: [n=2] TRUE, TRUE
[16:17:45.715] signalConditionsASAP(NULL, pos=0) ... done
[16:17:45.715] resolve() on list ... DONE
[16:17:45.715] result() for ClusterFuture ...
[16:17:45.715] - result already collected: FutureResult
[16:17:45.715] result() for ClusterFuture ... done
[16:17:45.715] result() for ClusterFuture ...
[16:17:45.715] - result already collected: FutureResult
[16:17:45.715] result() for ClusterFuture ... done
[16:17:45.715] result() for ClusterFuture ...
[16:17:45.716] - result already collected: FutureResult
[16:17:45.716] result() for ClusterFuture ... done
[16:17:45.716] result() for ClusterFuture ...
[16:17:45.716] - result already collected: FutureResult
[16:17:45.716] result() for ClusterFuture ... done
[16:17:45.716]  - Number of value chunks collected: 2
[16:17:45.716] Resolving 2 futures (chunks) ... DONE
[16:17:45.716] Reducing values from 2 chunks ...
[16:17:45.716]  - Number of values collected after concatenation: 2
[16:17:45.716]  - Number of values expected: 2
[16:17:45.716] Reducing values from 2 chunks ... DONE
[16:17:45.717] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:17:45.717] plan(): Setting new future strategy stack:
[16:17:45.717] List of future strategies:
[16:17:45.717] 1. sequential:
[16:17:45.717]    - args: function (..., envir = parent.frame())
[16:17:45.717]    - tweaked: FALSE
[16:17:45.717]    - call: plan(sequential)
[16:17:45.718] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[16:17:45.719] plan(): Setting new future strategy stack:
[16:17:45.719] List of future strategies:
[16:17:45.719] 1. FutureStrategy:
[16:17:45.719]    - args: function (..., envir = parent.frame())
[16:17:45.719]    - tweaked: FALSE
[16:17:45.719]    - call: future::plan(oplan)
[16:17:45.720] plan(): nbrOfWorkers() = 1
> 
